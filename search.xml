<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C++ STL —— 基于算法竞赛</title>
      <link href="/posts/47059.html"/>
      <url>/posts/47059.html</url>
      
        <content type="html"><![CDATA[<h1 id="原作者在这里！本文基于行码棋的文件进行的翻改！"><a href="#原作者在这里！本文基于行码棋的文件进行的翻改！" class="headerlink" title="原作者在这里！本文基于行码棋的文件进行的翻改！"></a><a href="https://wyqz.top/p/870124582.html">原作者在这里！本文基于行码棋的文件进行的翻改！</a></h1><blockquote><p>  [!NOTE]</p><p>  <a href="https://io.zouht.com/154.html">相关好文推荐，这篇 STL 我也觉得非常不错！分享给你！</a></p><p>  简单分享一下：我特别幸运地找到了一篇超适合 <code>STL</code> 入门和竞赛的文章！一开始只是随便翻了翻，没想到内容不仅全面详细，而且非常实用，只记得那天下午用了两个小时，从头到尾仔细的看了一遍，结果越看越上头，不靠视频也能高效、快速的学习（对当时完全没阅读习惯的我来说，简直是个奇迹）。后来的几天时间也是断断续续的在看，一周时间就可以快速上手 <code>STL</code> 了。相信屏幕前的你比我更快！</p><p>  这篇文章最大的优点就是实用，不是那种光讲理论、没法落地的内容。在后来的刷题和深入学习的过程中，每次遇到不会的地方，我也时不时的会翻出来查，就像一本随身的 <code>STL</code> 字典。某些地方反复看了很多遍，每次都会有新的收获。随着不断 <strong>实践 + 回顾</strong>，相关知识越来越清晰，使用起来也越来越顺手，简直就像高中查笔记一样，真的让我受益匪浅！希望也能帮到你~</p></blockquote><blockquote><p>  [!TIP]</p><p>  <strong>实践才是检验真理的唯一标准！</strong></p></blockquote><h2 id="1-vector"><a href="#1-vector" class="headerlink" title="1 vector"></a>1 vector</h2><h2 id="1-1-介绍"><a href="#1-1-介绍" class="headerlink" title="1.1 介绍"></a>1.1 介绍</h2><h3 id="1-1-1-简介"><a href="#1-1-1-简介" class="headerlink" title="1.1.1 简介"></a>1.1.1 简介</h3><p><code>vector</code> 为可变长数组（动态数组），定义的 <code>vector</code> 数组可以随时添加数值和删除元素。</p><blockquote><p>注意：<strong>在局部区域中（比如局部函数里面）开 vector 数组，是在堆空间里面开的。</strong></p><p>在局部区域开数组是在栈空间开的，而栈空间比较小，如果开了非常长的数组就会发生爆栈。</p><p>故局部区域 <strong>不可以</strong> 开大长度数组，但是可以开大长度 <code>vector</code>。</p></blockquote><p>包含头文件：</p><h3 id="1-1-2-初始化"><a href="#1-1-2-初始化" class="headerlink" title="1.1.2 初始化"></a>1.1.2 初始化</h3><ul><li><p><strong>一维初始化：</strong></p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; a; <span class="comment">//定义了一个名为 a 的一维数组, 数组存储 int 类型数据</span></span><br><span class="line">vector&lt;<span class="type">double</span>&gt; b; <span class="comment">//定义了一个名为 b 的一维数组，数组存储 double 类型数据</span></span><br><span class="line">vector&lt;node&gt; c; <span class="comment">//定义了一个名为 c 的一维数组，数组存储结构体类型数据，node 是结构体类型</span></span><br></pre></td></tr></table></figure><p>  指定 <strong>长度</strong> 和 <strong>初始值</strong> 的初始化</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(n)</span></span>; <span class="comment">// 定义一个长度为 n 的数组，初始值默认为 0，下标范围 [0, n - 1]</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(n, <span class="number">1</span>)</span></span>; <span class="comment">// v [0] 到 v [n - 1] 所有的元素初始值均为 1</span></span><br><span class="line"><span class="comment">//注意：指定数组长度之后（指定长度后的数组就相当于正常的数组了）</span></span><br></pre></td></tr></table></figure><p>  初始化中有多个元素</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; a&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;<span class="comment">//数组 a 中有五个元素，数组长度就为 5</span></span><br></pre></td></tr></table></figure><p>  拷贝初始化</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">b</span><span class="params">(a)</span></span>;               <span class="comment">// 两个数组中的类型必须相同, a 和 b 都是长度为 n+1，初始值都为 0 的数组</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; c = a;              <span class="comment">// 也是拷贝初始化, c 和 a 是完全一样的数组</span></span><br></pre></td></tr></table></figure></li><li><p><strong>二维初始化：</strong><br>  定义第一维固定长度为 <code>5</code>，第二维可变化的二维数组</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v[<span class="number">5</span>];           <span class="comment">//定义可变长二维数组</span></span><br><span class="line"><span class="comment">//注意：行不可变（只有 5 行）, 而列可变, 可以在指定行添加元素</span></span><br><span class="line"><span class="comment">//第一维固定长度为 5，第二维长度可以改变</span></span><br></pre></td></tr></table></figure><blockquote><p><code>vector&lt;int&gt; v[5]</code> 可以这样理解：长度为 5 的 v 数组，数组中存储的是 <code>vector&lt;int&gt;</code> 数据类型，而该类型就是数组形式，故 <code>v</code> 为二维数组。其中每个数组元素均为空，因为没有指定长度，所以第二维可变长。可以进行下述操作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">v[<span class="number">1</span>].<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">v[<span class="number">2</span>].<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br></pre></td></tr></table></figure></blockquote><p>  行列均可变</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化二维均可变长数组</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; v;<span class="comment">//定义一个行和列均可变的二维数组</span></span><br></pre></td></tr></table></figure><blockquote><p>应用：可以在 <code>v</code> 数组里面装多个数组</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; t1&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; t2&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">v.<span class="built_in">push_back</span>(t1);</span><br><span class="line">v.<span class="built_in">push_back</span>(t2);</span><br><span class="line">v.<span class="built_in">push_back</span>(&#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;) <span class="comment">// &#123;3, 4, 5, 6&#125;可以作为 vector 的初始化, 相当于一个无名 vector</span></span><br></pre></td></tr></table></figure></blockquote><p>  行列长度均固定 <code>n + 1</code> 行 <code>m + 1</code> 列初始值为 0</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">a</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m + <span class="number">1</span>, <span class="number">0</span>));</span><br></pre></td></tr></table></figure><p>  c++17 及以上支持的形式（定义模板类的对象时，可以不指定模板参数，但必须要在构造函数中能推导出模板参数）</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector a&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;; <span class="comment">// 声明一个 int 类型动态数组，初识元素自己指定</span></span><br><span class="line"><span class="function">vector <span class="title">b</span><span class="params">(n + <span class="number">1</span>, vector(m + <span class="number">1</span>, <span class="number">0</span>))</span></span>;</span><br></pre></td></tr></table></figure></li></ul><h2 id="1-2-方法函数"><a href="#1-2-方法函数" class="headerlink" title="1.2 方法函数"></a>1.2 方法函数</h2><h3 id="1-2-1-函数总结"><a href="#1-2-1-函数总结" class="headerlink" title="1.2.1 函数总结"></a>1.2.1 函数总结</h3><p>注：c 指定为数组名称</p><table><thead><tr><th>代码</th><th>算法复杂度</th><th>返回值类型</th><th>含义</th></tr></thead><tbody><tr><td><code>c.front()</code></td><td>O(1)O(1)</td><td>引用</td><td>返回容器中的第一个数据</td></tr><tr><td><code>c.back()</code></td><td>O(1)O(1)</td><td>引用</td><td>返回容器中的最后一个数据</td></tr><tr><td><code>c.at(idx)</code></td><td></td><td>引用</td><td>返回 <code>c[idx]</code> ，会进行边界检查，如果越界会报错，比直接使用 <code>[]</code> 更好一些，常在项目中使用</td></tr><tr><td><code>c.size()</code></td><td>O(1)O(1)</td><td></td><td>返回实际数据个数（unsigned 类型）</td></tr><tr><td><code>c.begin()</code></td><td>O(1)O(1)</td><td>迭代器</td><td>返回首元素的迭代器（通俗来说就是地址）</td></tr><tr><td><code>c.end()</code></td><td>O(1)O(1)</td><td>迭代器</td><td>返回最后一个元素后一个位置的迭代器（地址）</td></tr><tr><td><code>c.empty()</code></td><td>O(1)O(1)</td><td>bool</td><td>判断是否为空，为空返回真，反之返回假</td></tr><tr><td><code>c.reserve(sz)</code></td><td></td><td></td><td>为数组提前分配 <code>sz</code> 的内存大小，即改变了 <code>capacity</code> 的大小，主要是为了防止在 <code>push_back</code> 过程中多次的内存拷贝</td></tr><tr><td><code>c.assign(beg, end)</code></td><td></td><td></td><td>将另外一个容器 <code>[x.begin(), x.end())</code> 里的内容拷贝到 <code>c</code> 中</td></tr><tr><td><code>c.assign(n, val)</code></td><td></td><td></td><td>将 <code>n</code> 个 <code>val</code> 值拷贝到 <code>c</code> 数组中，这会清除掉容器中以前的内容，<code>c</code> 数组的 <code>size</code> 将变为 <code>n</code>，<code>capacity</code> 不会改变</td></tr><tr><td><code>c.pop_back()</code></td><td>O(1)O(1)</td><td></td><td>删除最后一个数据</td></tr><tr><td><code>c.push_back(element)</code></td><td>O(1)O(1)</td><td></td><td>在尾部加一个数据</td></tr><tr><td><code>c.emplace_back(ele)</code></td><td>O(1)O(1)</td><td></td><td>在数组中加入一个数据，和 <code>push_back</code> 功能基本一样，在某些情况下比它效率更高，支持传入多个构造参数</td></tr><tr><td><code>c.clear()</code></td><td>O(N)O(N)</td><td></td><td>清除容器中的所有元素</td></tr><tr><td><code>c.resize(n, v)</code></td><td></td><td></td><td>改变数组大小为 <code>n</code>, <code>n</code> 个空间数值赋为 <code>v</code>，如果没有默认赋值为 <code>0</code></td></tr><tr><td><code>c.insert(pos, x)</code></td><td>O(N)O(N)</td><td></td><td>向任意迭代器 <code>pos</code> 插入一个元素 <code>x</code></td></tr><tr><td>例：<code>c.insert(c.begin() + 2, -1)</code></td><td></td><td></td><td>将 <code>-1</code> 插入 <code>c[2]</code> 的位置</td></tr><tr><td><code>c.erase(first, last)</code></td><td>O(N)O(N)</td><td></td><td>删除 <code>[first, last)</code> 的所有元素</td></tr></tbody></table><h3 id="1-2-2-注意情况"><a href="#1-2-2-注意情况" class="headerlink" title="1.2.2 注意情况"></a>1.2.2 注意情况</h3><ul><li><p><code>end()</code> 返回的是最后一个元素的后一个位置的地址，不是最后一个元素的地址，<strong>所有 STL 容器均是如此</strong></p></li><li><p>使用 <code>vi.resize(n, v)</code> 函数时，若 <code>vi</code> 之前指定过大小为 <code>pre</code></p><ul><li><code>pre &gt; n</code> ：即数组大小变小了，数组会保存前 <code>n</code> 个元素，前 <code>n</code> 个元素值为原来的值，不是都为 <code>v</code></li><li><code>pre &lt; n</code> ：即数组大小变大了，数组会在后面插入 <code>n - pre</code> 个值为 <code>v</code> 的元素</li></ul><p>  也就是说，这个初始值 <code>v</code> 只对新插入的元素生效。</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">out</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x: a) cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>; cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">5</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="built_in">out</span>(a); <span class="comment">// 1 1 1 1 1</span></span><br><span class="line">a.<span class="built_in">resize</span>(<span class="number">10</span>, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">out</span>(a); <span class="comment">// 1 1 1 1 1 2 2 2 2 2</span></span><br><span class="line">a.<span class="built_in">resize</span>(<span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">out</span>(a); <span class="comment">// 1 1 1</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用 <code>sort</code> 排序要: <code>sort(c.begin(), c.end());</code></p></li></ul><blockquote><p><code>sort()</code> 为 STL 函数，请参考本文最后面 STL 函数系列。</p></blockquote><p>对所有元素进行排序，如果要对指定区间进行排序，可以对 <code>sort()</code> 里面的参数进行加减改动。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="built_in">sort</span>(a.<span class="built_in">begin</span>() + <span class="number">1</span>, a.<span class="built_in">end</span>()); <span class="comment">// 对 [1, n] 区间进行从小到大排序</span></span><br></pre></td></tr></table></figure><h2 id="1-3-元素访问"><a href="#1-3-元素访问" class="headerlink" title="1.3 元素访问"></a>1.3 元素访问</h2><p>共三种方法：</p><ul><li><strong>下标法</strong> ： 和普通数组一样</li></ul><p>注意：一维数组的下标是从 <code>0</code> 到 <code>v.size() - 1</code> ，访问之外的数会出现越界错误</p><ul><li><strong>迭代器法</strong> ： 类似指针一样的访问 ，首先需要声明迭代器变量，和声明指针变量一样，可以根据代码进行理解（附有注释）。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; vi; <span class="comment">//定义一个 vi 数组</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it = vi.<span class="built_in">begin</span>();  <span class="comment">//声明一个迭代器指向 vi 的初始位置</span></span><br></pre></td></tr></table></figure><ul><li><strong>使用 auto</strong> ：非常简便，但是会访问数组的所有元素（特别注意 0 位置元素也会访问到）</li></ul><h3 id="1-3-1-下标访问"><a href="#1-3-1-下标访问" class="headerlink" title="1.3.1 下标访问"></a>1.3.1 下标访问</h3><p>直接和普通数组一样进行访问即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加元素</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">vi.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//下标访问 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; vi[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br></pre></td></tr></table></figure><h3 id="1-3-2-迭代器访问"><a href="#1-3-2-迭代器访问" class="headerlink" title="1.3.2 迭代器访问"></a>1.3.2 迭代器访问</h3><p>类似指针，迭代器就是充当指针的作用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; vi&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="comment">//迭代器访问</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it;   </span><br><span class="line"><span class="comment">// 相当于声明了一个迭代器类型的变量 it</span></span><br><span class="line"><span class="comment">// 通俗来说就是声明了一个指针变量</span></span><br></pre></td></tr></table></figure><ul><li>方式一：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it = vi.<span class="built_in">begin</span>(); </span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *(it + i) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br></pre></td></tr></table></figure><ul><li>方式二</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it;</span><br><span class="line"><span class="keyword">for</span>(it = vi.<span class="built_in">begin</span>(); it != vi.<span class="built_in">end</span>();it ++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//vi.end()指向尾元素地址的下一个地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">auto</span> it = vi.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span> (it != vi.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    it++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-3-智能指针"><a href="#1-3-3-智能指针" class="headerlink" title="1.3.3 智能指针"></a>1.3.3 智能指针</h3><p><strong>只能遍历完数组</strong>，如果要指定的内容进行遍历，需要另选方法。</p><p><code>auto</code> 能够自动识别并获取类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 输入</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x: a)</span><br><span class="line">&#123;</span><br><span class="line">    cin &gt;&gt; x; <span class="comment">// 可以进行输入，注意加引用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 输出</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">12</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">241</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> val : v)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 12 241</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>vector</code> 注意：</p><ul><li><p><code>vi[i]</code> 和 <code>*(vi.begin() + i)</code> 等价，与指针类似。</p></li><li><p><code>vector</code> 和 <code>string</code> 的 <code>STL</code> 容器支持 <code>*(it + i)</code> 的元素访问，其它容器可能也可以支持这种方式访问，但用的不多，可自行尝试。</p></li></ul></blockquote><h2 id="2-stack"><a href="#2-stack" class="headerlink" title="2 stack"></a>2 stack</h2><h2 id="2-1-介绍"><a href="#2-1-介绍" class="headerlink" title="2.1 介绍"></a>2.1 介绍</h2><p>栈为数据结构的一种，是 STL 中实现的一个先进后出，后进先出的容器。</p><p>包含头文件：</p><p>初始化：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">stack&lt;string&gt; s;</span><br><span class="line">stack&lt;node&gt; s;<span class="comment">//node 是结构体类型</span></span><br></pre></td></tr></table></figure><h2 id="2-2-方法函数"><a href="#2-2-方法函数" class="headerlink" title="2.2 方法函数"></a>2.2 方法函数</h2><table><thead><tr><th>代码</th><th>含义</th></tr></thead><tbody><tr><td><code>s.push(ele)</code></td><td>元素 <code>ele</code> 入栈，增加元素 O(1)O(1)</td></tr><tr><td><code>s.pop()</code></td><td>移除栈顶元素 O(1)O(1)</td></tr><tr><td><code>s.top()</code></td><td>取得栈顶元素（但不删除）O(1)O(1)</td></tr><tr><td><code>s.empty()</code></td><td>检测栈内是否为空，空为真 O(1)O(1)</td></tr><tr><td><code>s.size()</code></td><td>返回栈内元素的个数 O(1)O(1)</td></tr></tbody></table><h2 id="2-3-栈元素访问"><a href="#2-3-栈元素访问" class="headerlink" title="2.3 栈元素访问"></a>2.3 栈元素访问</h2><h3 id="2-3-1-栈遍历"><a href="#2-3-1-栈遍历" class="headerlink" title="2.3.1 栈遍历"></a>2.3.1 栈遍历</h3><p>栈只能对栈顶元素进行操作，如果想要进行遍历，只能将栈中元素一个个取出来存在数组中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line">st.<span class="built_in">push</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!st.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> tp = st.<span class="built_in">top</span>(); <span class="comment">// 栈顶元素</span></span><br><span class="line">    st.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-2-数组模拟栈进行遍历"><a href="#2-3-2-数组模拟栈进行遍历" class="headerlink" title="2.3.2 数组模拟栈进行遍历"></a>2.3.2 数组模拟栈进行遍历</h3><p>通过一个 <strong>数组</strong> 对栈进行模拟，一个存放下标的变量 <code>top</code> 模拟指向栈顶的指针。</p><blockquote><p>一般来说单调栈和单调队列写法均可使用额外变量 <code>tt</code> 或 <code>hh</code> 来进行模拟</p></blockquote><p><strong>特点：</strong> 比 <code>STL</code> 的 <code>stack</code> 速度更快，遍历元素方便</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> s[<span class="number">100</span>]; <span class="comment">// 栈 从左至右为栈底到栈顶</span></span><br><span class="line"><span class="type">int</span> tt = <span class="number">-1</span>; <span class="comment">// tt 代表栈顶指针, 初始栈内无元素，tt 为-1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">5</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//入栈 </span></span><br><span class="line">s[++tt] = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出栈</span></span><br><span class="line"><span class="type">int</span> top_element = s[tt--]; </span><br><span class="line"></span><br><span class="line"><span class="comment">//入栈操作示意</span></span><br><span class="line"><span class="comment">//  0  1  2  3  4  5  </span></span><br><span class="line"><span class="comment">//                tt</span></span><br><span class="line"><span class="comment">//出栈后示意</span></span><br><span class="line"><span class="comment">//  0  1  2  3  4 </span></span><br><span class="line"><span class="comment">//              tt</span></span><br></pre></td></tr></table></figure><h2 id="3-queue"><a href="#3-queue" class="headerlink" title="3 queue"></a>3 queue</h2><h2 id="3-1-介绍"><a href="#3-1-介绍" class="headerlink" title="3.1 介绍"></a>3.1 介绍</h2><p>队列是一种先进先出的数据结构。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 包含头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br></pre></td></tr></table></figure><h2 id="3-2-方法函数"><a href="#3-2-方法函数" class="headerlink" title="3.2 方法函数"></a>3.2 方法函数</h2><table><thead><tr><th>代码</th><th>含义</th></tr></thead><tbody><tr><td><code>q.front()</code></td><td>返回队首元素 O(1)O(1)</td></tr><tr><td><code>q.back()</code></td><td>返回队尾元素 O(1)O(1)</td></tr><tr><td><code>q.push(element)</code></td><td>尾部添加一个元素 <code>element</code> 进队 O(1)O(1)</td></tr><tr><td><code>q.pop()</code></td><td>删除第一个元素 出队 O(1)O(1)</td></tr><tr><td><code>q.size()</code></td><td>返回队列中元素个数，返回值类型 <code>unsigned int</code> O(1)O(1)</td></tr><tr><td><code>q.empty()</code></td><td>判断是否为空，队列为空，返回 <code>true</code> O(1)O(1)</td></tr></tbody></table><h2 id="3-3-队列模拟"><a href="#3-3-队列模拟" class="headerlink" title="3.3 队列模拟"></a>3.3 队列模拟</h2><p>使用 <code>q[]</code> 数组模拟队列</p><p><code>hh</code> 表示队首元素的下标，初始值为 <code>0</code></p><p><code>tt</code> 表示队尾元素的下标，初始值为 <code>-1</code>，表示刚 <strong>开始队列为空</strong></p><blockquote><p>一般来说单调栈和单调队列写法均可使用额外变量 <code>tt</code> 或 <code>hh</code> 来进行模拟</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> hh = <span class="number">0</span>,tt = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//入队 </span></span><br><span class="line">q[++tt] = <span class="number">1</span>;</span><br><span class="line">q[++tt] = <span class="number">2</span>; </span><br><span class="line">    </span><br><span class="line"><span class="comment">//将所有元素出队 </span></span><br><span class="line"><span class="keyword">while</span>(hh &lt;= tt)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="type">int</span> t = q[hh++];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure><h2 id="4-deque"><a href="#4-deque" class="headerlink" title="4 deque"></a>4 deque</h2><h2 id="4-1-介绍"><a href="#4-1-介绍" class="headerlink" title="4.1 介绍"></a>4.1 介绍</h2><p>首尾都可插入和删除的队列为双端队列。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="comment">//初始化定义</span></span><br><span class="line">deque&lt;<span class="type">int</span>&gt; dq;</span><br></pre></td></tr></table></figure><h2 id="4-2-方法函数"><a href="#4-2-方法函数" class="headerlink" title="4.2 方法函数"></a>4.2 方法函数</h2><blockquote><p>注意双端队列的常数比较大。</p></blockquote><table><thead><tr><th>代码</th><th>含义</th></tr></thead><tbody><tr><td><code>push_back(x)/push_front(x)</code></td><td>把 <code>x</code> 插入队尾后 &#x2F; 队首 O(1)O(1)</td></tr><tr><td><code>back()/front()</code></td><td>返回队尾 &#x2F; 队首元素 O(1)O(1)</td></tr><tr><td><code>pop_back() / pop_front()</code></td><td>删除队尾 &#x2F; 队首元素 O(1)O(1)</td></tr><tr><td><code>erase(iterator it)</code></td><td>删除双端队列中的某一个元素</td></tr><tr><td><code>erase(iterator first,iterator last)</code></td><td>删除双端队列中 <code>[first,last)</code> 中的元素</td></tr><tr><td><code>empty()</code></td><td>判断 deque 是否空 O(1)O(1)</td></tr><tr><td><code>size()</code></td><td>返回 deque 的元素数量 O(1)O(1)</td></tr><tr><td><code>clear()</code></td><td>清空 deque</td></tr></tbody></table><h2 id="4-3-注意点"><a href="#4-3-注意点" class="headerlink" title="4.3 注意点"></a>4.3 注意点</h2><p>deque 可以进行排序</p><blockquote><p>双端队列排序一般不用，感觉毫无用处，使用其他 STL 依然可以实现相同功能</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从小到大</span></span><br><span class="line"><span class="built_in">sort</span>(q.<span class="built_in">begin</span>(), q.<span class="built_in">end</span>())</span><br><span class="line"><span class="comment">//从大到小排序</span></span><br><span class="line"><span class="built_in">sort</span>(q.<span class="built_in">begin</span>(), q.<span class="built_in">end</span>(), <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());<span class="comment">//deque 里面的类型需要是 int 型</span></span><br><span class="line"><span class="built_in">sort</span>(q.<span class="built_in">begin</span>(), q.<span class="built_in">end</span>(), <span class="built_in">greater</span>());<span class="comment">//高版本 C++才可以用</span></span><br></pre></td></tr></table></figure><h2 id="5-priority-queue"><a href="#5-priority-queue" class="headerlink" title="5 priority_queue"></a>5 priority_queue</h2><h2 id="5-1-介绍"><a href="#5-1-介绍" class="headerlink" title="5.1 介绍"></a>5.1 介绍</h2><p>优先队列是在正常队列的基础上加了优先级，保证每次的队首元素都是优先级最大的。</p><p>可以实现每次从优先队列中取出的元素都是队列中 <strong>优先级最大</strong> 的一个。</p><p>它的底层是通过 <strong>堆</strong> 来实现的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="comment">//初始化定义</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>&gt; q;</span><br></pre></td></tr></table></figure><h2 id="5-2-函数方法"><a href="#5-2-函数方法" class="headerlink" title=" 5.2 函数方法"></a><a href="#52-%E5%87%BD%E6%95%B0%E6%96%B9%E6%B3%95"></a> 5.2 函数方法</h2><table><thead><tr><th>代码</th><th>含义</th></tr></thead><tbody><tr><td><code>q.top()</code></td><td>访问队首元素 O(1)O(1)</td></tr><tr><td><code>q.push()</code></td><td>入队 O(logN)O(logN)</td></tr><tr><td><code>q.pop()</code></td><td>堆顶（队首）元素出队 O(logN)O(logN)</td></tr><tr><td><code>q.size()</code></td><td>队列元素个数 O(1)O(1)</td></tr><tr><td><code>q.empty()</code></td><td>是否为空 O(1)O(1)</td></tr><tr><td><strong>注意</strong> 没有 <code>clear()</code>！</td><td>不提供该方法</td></tr><tr><td>优先队列只能通过 <code>top()</code> 访问队首元素（优先级最高的元素）</td><td></td></tr></tbody></table><h2 id="5-3-设置优先级"><a href="#5-3-设置优先级" class="headerlink" title="5.3 设置优先级"></a>5.3 设置优先级</h2><h3 id="5-3-1-基本数据类型的优先级"><a href="#5-3-1-基本数据类型的优先级" class="headerlink" title="5.3.1 基本数据类型的优先级"></a>5.3.1 基本数据类型的优先级</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;<span class="type">int</span>&gt; pq;                                 <span class="comment">// 默认大根堆, 即每次取出的元素是队列中的最大值</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; q;       <span class="comment">// 小根堆, 每次取出的元素是队列中的最小值</span></span><br></pre></td></tr></table></figure><p>参数解释：</p><ul><li><p>第一个参数：就是优先队列中存储的数据类型</p></li><li><p>第二个参数：</p><p>  <code>vector&lt;int&gt;</code> 是用来承载底层数据结构堆的容器，若优先队列中存放的是 <code>double</code> 型数据，就要填 <code>vector&lt; double &gt;</code><br>  <strong>总之存的是什么类型的数据，就相应的填写对应类型。同时也要改动第三个参数里面的对应类型。</strong></p></li><li><p>第三个参数：<br>  <code>less&lt;int&gt;</code> 表示数字大的优先级大，堆顶为最大的数字<br>  <code>greater&lt;int&gt;</code> 表示数字小的优先级大，堆顶为最小的数字<br>  <strong>int 代表的是数据类型，也要填优先队列中存储的数据类型</strong></p></li></ul><hr><p>下面介绍基础数据类型优先级设置的写法：</p><ol><li>基础写法（非常常用）：</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;<span class="type">int</span>&gt; q1;                                 <span class="comment">// 默认大根堆, 即每次取出的元素是队列中的最大值</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, less&lt;<span class="type">int</span>&gt; &gt; q2;        <span class="comment">// 大根堆, 每次取出的元素是队列中的最大值，同第一行</span></span><br><span class="line"></span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt; &gt; q3;     <span class="comment">// 小根堆, 每次取出的元素是队列中的最小值</span></span><br></pre></td></tr></table></figure><ol start="2"><li>自定义排序（不常见，主要是写着麻烦）：</li></ol><p>下面的代码比较长，基础类型优先级写着太麻烦，用第一种即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">cmp1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"><span class="keyword">return</span> x &gt; y;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cmp2</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> <span class="type">int</span> x, <span class="type">const</span> <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"><span class="keyword">return</span> x &lt; y;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, cmp1&gt; q1; <span class="comment">// 小根堆</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, cmp2&gt; q2; <span class="comment">// 大根堆</span></span><br></pre></td></tr></table></figure><h3 id="5-3-2-高级数据类型-结构体-优先级"><a href="#5-3-2-高级数据类型-结构体-优先级" class="headerlink" title="5.3.2 高级数据类型(结构体)优先级"></a>5.3.2 高级数据类型(结构体)优先级</h3><blockquote><p>即优先队列中存储结构体类型，必须要设置优先级，即结构体的比较运算（因为优先队列的堆中要比较大小，才能将对应最大或者最小元素移到堆顶）。</p></blockquote><p>优先级设置可以定义在 <strong>结构体内</strong> 进行小于号重载，也可以定义在 <strong>结构体外</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//要排序的结构体（存储在优先队列里面的）</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> x, y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>版本一：自定义全局比较规则</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义的比较结构体</span></span><br><span class="line"><span class="comment">//注意：cmp 是个结构体 </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cmp</span><span class="comment">//自定义堆的排序规则 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Point&amp; a,<span class="type">const</span> Point&amp; b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a.x &lt; b.x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化定义， </span></span><br><span class="line">priority_queue&lt;Point, vector&lt;Point&gt;, cmp&gt; q; <span class="comment">// x 大的在堆顶</span></span><br></pre></td></tr></table></figure><ul><li><strong>版本二：直接在结构体里面写</strong></li></ul><blockquote><p>因为是在结构体内部自定义的规则，一旦需要比较结构体，自动调用结构体内部重载运算符规则。</p></blockquote><p>结构体内部有两种方式：</p><p><strong>方式一</strong> ：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> x, y;</span><br><span class="line"><span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span> &lt; (Point a, Point b)<span class="comment">//为两个结构体参数，结构体调用一定要写上 friend</span></span><br><span class="line">    &#123;</span><br><span class="line"><span class="keyword">return</span> a.x &lt; b.x;  <span class="comment">//按 x 从小到大排，x 大的在堆顶</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>方式二</strong> ：（推荐此种）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> Point &amp;a) <span class="type">const</span><span class="comment">//直接传入一个参数，不必要写 friend</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> x &lt; a.x;  <span class="comment">//按 x 升序排列，x 大的在堆顶</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>优先队列的定义</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;Point&gt; q;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 优先队列自定义排序规则和 <code>sort()</code> 函数定义 <code>cmp</code> 函数很相似，但是最后返回的情况是 <strong>相反</strong> 的。即相同的符号，最后定义的排列顺序是完全相反的。<br>所以只需要记住 <code>sort</code> 的排序规则和优先队列的排序规则是相反的就可以了。</p><blockquote><p>当理解了堆的原理就会发现，堆调整时比较顺序是孩子和父亲节点进行比较，如果是 <code>&gt;</code> ，那么孩子节点要大于父亲节点，堆顶自然是最小值。</p></blockquote><h2 id="5-4-存储特殊类型的优先级"><a href="#5-4-存储特殊类型的优先级" class="headerlink" title="5.4 存储特殊类型的优先级"></a>5.4 存储特殊类型的优先级</h2><h3 id="5-4-1-存储-pair-类型"><a href="#5-4-1-存储-pair-类型" class="headerlink" title="5.4.1 存储 pair 类型"></a>5.4.1 存储 pair 类型</h3><ul><li>排序规则：<br>  默认先对 <code>pair</code> 的 <code>first</code> 进行降序排序，然后再对 <code>second</code> 降序排序<br>  对 <code>first</code> 先排序，大的排在前面，如果 <code>first</code> 元素相同，再对 <code>second</code> 元素排序，保持大的在前面。</li></ul><blockquote><p><code>pair</code> 请参考下文</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &gt;q;</span><br><span class="line">q.<span class="built_in">push</span>(&#123;<span class="number">7</span>, <span class="number">8</span>&#125;);</span><br><span class="line">q.<span class="built_in">push</span>(&#123;<span class="number">7</span>, <span class="number">9</span>&#125;);</span><br><span class="line">q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(<span class="number">8</span>, <span class="number">7</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; q.<span class="built_in">top</span>().first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; q.<span class="built_in">top</span>().second &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>结果：<br>8 7<br>7 9<br>7 8</p></blockquote><h2 id="6-map"><a href="#6-map" class="headerlink" title="6 map"></a>6 map</h2><h2 id="6-1-介绍"><a href="#6-1-介绍" class="headerlink" title="6.1 介绍"></a>6.1 介绍</h2><h3 id="6-1-1-简介"><a href="#6-1-1-简介" class="headerlink" title="6.1.1 简介"></a>6.1.1 简介</h3><p>映射类似于函数的对应关系，每个 <code>x</code> 对应一个 <code>y</code>，而 <code>map</code> 是每个键对应一个值。这和 python 的字典类型非常相似。</p><p>容器中的每个存储对为一个键值对，包含两个元素（键和值）。</p><h3 id="6-1-2-初始化"><a href="#6-1-2-初始化" class="headerlink" title="6.1.2 初始化"></a>6.1.2 初始化</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化定义</span></span><br><span class="line">map&lt;string, string&gt; mp;</span><br><span class="line">map&lt;string, <span class="type">int</span>&gt; mp;</span><br><span class="line">map&lt;<span class="type">int</span>, node&gt; mp;<span class="comment">//node 是结构体类型</span></span><br></pre></td></tr></table></figure><blockquote><p>map 特性：map 会按照键的顺序从小到大自动排序，键的类型必须可以比较大小</p></blockquote><h2 id="6-2-函数方法"><a href="#6-2-函数方法" class="headerlink" title="6.2 函数方法"></a>6.2 函数方法</h2><h3 id="6-2-1-函数方法"><a href="#6-2-1-函数方法" class="headerlink" title="6.2.1 函数方法"></a>6.2.1 函数方法</h3><table><thead><tr><th>代码</th><th>含义</th><th>复杂度</th></tr></thead><tbody><tr><td><code>mp.find(key)</code></td><td>返回键为 key 的映射的迭代器 注意：用 find 函数来定位数据出现位置，它返回一个迭代器。当数据存在时，返回数据所在位置的迭代器，数据不存在时，返回 mp.end()mp.end()</td><td>O(logN)O(logN)</td></tr><tr><td><code>mp.erase(it)</code></td><td>删除迭代器对应的键和值</td><td>O(logN)O(logN)</td></tr><tr><td><code>mp.erase(key)</code></td><td>根据映射的键删除键和值</td><td>O(logN)O(logN)</td></tr><tr><td><code>mp.erase(first,last)</code></td><td>删除左闭右开区间迭代器对应的键和值</td><td>O(last−first)O(last-first)</td></tr><tr><td><code>mp.size()</code></td><td>返回映射的对数</td><td>O(1)O(1)</td></tr><tr><td><code>mp.clear()</code></td><td>清空 map 中的所有元素</td><td>O(N)O(N)</td></tr><tr><td><code>mp.insert()</code></td><td>插入元素，插入时要构造键值对</td><td>O(N)O(N)</td></tr><tr><td><code>mp.empty()</code></td><td>如果 map 为空，返回 true，否则返回 false</td><td>O(1)O(1)</td></tr><tr><td><code>mp.begin()</code></td><td>返回指向 map 第一个元素的迭代器（地址）</td><td>O(1)O(1)</td></tr><tr><td><code>mp.end()</code></td><td>返回指向 map 尾部的迭代器（最后一个元素的 <strong>下一个</strong> 地址）</td><td>O(1)O(1)</td></tr><tr><td><code>mp.rbegin()</code></td><td>返回指向 map 最后一个元素的迭代器（地址）</td><td>O(1)O(1)</td></tr><tr><td><code>mp.rend()</code></td><td>返回指向 map 第一个元素前面(上一个）的逆向迭代器（地址）</td><td>O(1)O(1)</td></tr><tr><td><code>mp.count(key)</code></td><td>查看元素是否存在，因为 map 中键是唯一的，所以存在返回 1，不存在返回 0</td><td>O(logN)O(logN)</td></tr><tr><td><code>mp.lower_bound()</code></td><td>返回一个迭代器，指向键值 &gt;&#x3D; <strong>key</strong> 的第一个元素</td><td></td></tr><tr><td><code>mp.upper_bound()</code></td><td>返回一个迭代器，指向键值 &gt; key 的第一个元素</td><td></td></tr></tbody></table><h3 id="6-2-2-注意情况"><a href="#6-2-2-注意情况" class="headerlink" title="6.2.2 注意情况"></a>6.2.2 注意情况</h3><p><strong>下面说明部分函数方法的注意点</strong></p><ul><li>注意点一：<br>  查找元素是否存在时，可以使用 ① <code>mp.find()</code> ② <code>mp.count()</code> ③ <code>mp[key]</code><br>  但是第三种情况，如果不存在对应的 <code>key</code> 时，会自动创建一个键值对（产生一个额外的键值对空间）<br>  所以为了不增加额外的空间负担，最好使用前两种方法。</li></ul><h3 id="6-2-3-迭代器进行正反向遍历"><a href="#6-2-3-迭代器进行正反向遍历" class="headerlink" title="6.2.3 迭代器进行正反向遍历"></a>6.2.3 迭代器进行正反向遍历</h3><ul><li><code>mp.begin()</code> 和 <code>mp.end()</code> 用法：</li></ul><p><strong>用于正向遍历 map</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; mp;</span><br><span class="line">mp[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">mp[<span class="number">2</span>] = <span class="number">3</span>;</span><br><span class="line">mp[<span class="number">3</span>] = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">auto</span> it = mp.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span>(it != mp.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">it ++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果：</strong></p><ul><li><code>mp.rbegin()</code> 和 <code>mp.rend()</code></li></ul><p><strong>用于逆向遍历 map</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; mp;</span><br><span class="line">mp[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">mp[<span class="number">2</span>] = <span class="number">3</span>;</span><br><span class="line">mp[<span class="number">3</span>] = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">auto</span> it = mp.<span class="built_in">rbegin</span>();</span><br><span class="line"><span class="keyword">while</span>(it != mp.<span class="built_in">rend</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">it ++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果：</strong></p><h3 id="6-2-4-二分查找"><a href="#6-2-4-二分查找" class="headerlink" title="6.2.4 二分查找"></a>6.2.4 二分查找</h3><p>二分查找 <code>lower_bound() upper_bound()</code></p><blockquote><p>map 的二分查找以第一个元素（即键为准），对 <strong>键</strong> 进行二分查找<br>返回值为 map 迭代器类型</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; m&#123;&#123;<span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">2</span>, <span class="number">2</span>&#125;, &#123;<span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">8</span>, <span class="number">2</span>&#125;, &#123;<span class="number">6</span>, <span class="number">2</span>&#125;&#125;;<span class="comment">//有序</span></span><br><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::iterator it1 = m.<span class="built_in">lower_bound</span>(<span class="number">2</span>);</span><br><span class="line">cout &lt;&lt; it1-&gt;first &lt;&lt; <span class="string">&quot;\n&quot;</span>;<span class="comment">//it1-&gt; first = 2</span></span><br><span class="line"></span><br><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::iterator it2 = m.<span class="built_in">upper_bound</span>(<span class="number">2</span>);</span><br><span class="line">cout &lt;&lt; it2-&gt;first &lt;&lt; <span class="string">&quot;\n&quot;</span>;<span class="comment">//it2-&gt; first = 6</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-3-添加元素"><a href="#6-3-添加元素" class="headerlink" title="6.3 添加元素"></a>6.3 添加元素</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先声明</span></span><br><span class="line">map&lt;string, string&gt; mp;</span><br></pre></td></tr></table></figure><ul><li><strong>方式一：</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mp[<span class="string">&quot;学习&quot;</span>] = <span class="string">&quot;看书&quot;</span>;</span><br><span class="line">mp[<span class="string">&quot;玩耍&quot;</span>] = <span class="string">&quot;打游戏&quot;</span>;</span><br></pre></td></tr></table></figure><ul><li><strong>方式二：插入元素构造键值对</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mp.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="string">&quot;vegetable&quot;</span>, <span class="string">&quot;蔬菜&quot;</span>));</span><br></pre></td></tr></table></figure><ul><li><strong>方式三：</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mp.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;string,string&gt;(<span class="string">&quot;fruit&quot;</span>,<span class="string">&quot;水果&quot;</span>));</span><br></pre></td></tr></table></figure><ul><li><strong>方式四:</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mp.<span class="built_in">insert</span>(&#123;<span class="string">&quot;hahaha&quot;</span>,<span class="string">&quot;wawawa&quot;</span>&#125;);</span><br></pre></td></tr></table></figure><h2 id="6-4-访问元素"><a href="#6-4-访问元素" class="headerlink" title="6.4 访问元素"></a>6.4 访问元素</h2><h3 id="6-4-1-下标访问"><a href="#6-4-1-下标访问" class="headerlink" title="6.4.1 下标访问"></a>6.4.1 下标访问</h3><p>(大部分情况用于访问单个元素)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mp[<span class="string">&quot;菜哇菜&quot;</span>] = <span class="string">&quot;强哇强&quot;</span>;</span><br><span class="line">cout &lt;&lt; mp[<span class="string">&quot;菜哇菜&quot;</span>] &lt;&lt; <span class="string">&quot;\n&quot;</span>;<span class="comment">//只是简写的一个例子，程序并不完整</span></span><br></pre></td></tr></table></figure><h3 id="6-4-2-遍历访问"><a href="#6-4-2-遍历访问" class="headerlink" title="6.4.2 遍历访问"></a>6.4.2 遍历访问</h3><ul><li>方式一：迭代器访问</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string,string&gt;::iterator it;</span><br><span class="line"><span class="keyword">for</span>(it = mp.<span class="built_in">begin</span>(); it != mp.<span class="built_in">end</span>(); it++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//      键                 值 </span></span><br><span class="line"><span class="comment">// it 是结构体指针访问所以要用 -&gt; 访问</span></span><br><span class="line">cout &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//*it 是结构体变量 访问要用 . 访问</span></span><br><span class="line"><span class="comment">//cout &lt;&lt;(*it).first &lt;&lt; &quot; &quot; &lt;&lt;(* it).second;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>方式二：智能指针访问</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i : mp)</span><br><span class="line">cout &lt;&lt; i.first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; i.second &lt;&lt; endl;<span class="comment">//键，值</span></span><br></pre></td></tr></table></figure><ul><li>方式三：对指定单个元素访问</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="type">char</span>,<span class="type">int</span>&gt;::iterator it = mp.<span class="built_in">find</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">cout &lt;&lt; it -&gt; first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt;  it-&gt;second &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br></pre></td></tr></table></figure><ul><li>方式四：c++17 特性才具有</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> [x, y] : mp)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//x, y 对应键和值</span></span><br></pre></td></tr></table></figure><h2 id="6-5-与-unordered-map-的比较"><a href="#6-5-与-unordered-map-的比较" class="headerlink" title="6.5 与 unordered_map 的比较"></a>6.5 与 unordered_map 的比较</h2><p>这里就不单开一个大目录讲 unordered_map 了，直接在 map 里面讲了。</p><h3 id="6-5-1-内部实现原理"><a href="#6-5-1-内部实现原理" class="headerlink" title="6.5.1 内部实现原理"></a>6.5.1 内部实现原理</h3><p><strong>map</strong>：内部用 <strong>红黑树</strong> 实现，具有 <strong>自动排序</strong>（按键从小到大）功能。</p><p><strong>unordered_map</strong>：内部用 <strong>哈希表</strong> 实现，内部元素无序杂乱。</p><h3 id="6-5-2-效率比较"><a href="#6-5-2-效率比较" class="headerlink" title="6.5.2 效率比较"></a>6.5.2 效率比较</h3><p><strong>map</strong>：</p><ul><li><p>优点：内部用红黑树实现，内部元素具有有序性，查询删除等操作复杂度为 O(logN)O(logN)</p></li><li><p>缺点：占用空间，红黑树里每个节点需要保存父子节点和红黑性质等信息，空间占用较大。</p></li></ul><p><strong>unordered_map</strong>：</p><ul><li>优点：内部用哈希表实现，查找速度非常快（适用于大量的查询操作）。</li><li>缺点：建立哈希表比较耗时。</li></ul><blockquote><p>两者方法函数基本一样，差别不大。</p><p>注意：</p><ul><li><p>随着内部元素越来越多，两种容器的插入删除查询操作的时间都会逐渐变大，效率逐渐变低。</p></li><li><p>使用 <code>[]</code> 查找元素时，如果元素不存在，两种容器 <strong>都是</strong> 创建一个空的元素；如果存在，会正常索引对应的值。所以如果查询过多的不存在的元素值，容器内部会创建大量的空的键值对，后续查询创建删除效率会 <strong>大大降低</strong>。</p></li><li><p>查询容器内部元素的最优方法是：先判断存在与否，再索引对应值（适用于这两种容器）</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以 map 为例</span></span><br><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line"><span class="type">int</span> x = <span class="number">999999999</span>;</span><br><span class="line"><span class="keyword">if</span>(mp.<span class="built_in">count</span>(x)) <span class="comment">// 此处判断是否存在 x 这个键</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; mp[x] &lt;&lt; <span class="string">&quot;\n&quot;</span>;   <span class="comment">// 只有存在才会索引对应的值，避免不存在 x 时多余空元素的创建</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></blockquote><p>另外：</p><blockquote><p>还有一种映射：<code>multimap</code></p><p>键可以重复，即一个键对应多个值，如要了解，可以自行搜索。</p></blockquote><h2 id="6-5-3-自定义-hash-函数"><a href="#6-5-3-自定义-hash-函数" class="headerlink" title="6.5.3 自定义 hash 函数"></a>6.5.3 自定义 hash 函数</h2><p>由于 unordered_map 中的元素需要具备 hash 特性，如果语言没有自带 hash 特性的话，需要我们自定义 hash 函数，以下举一个 <code>pair&lt;int, int&gt;</code> 的 hash 函数定义的例子，hash 函数看自己怎么定义了（只要能实现 hash 功能就行）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 lambda 表达式来定义哈希函数</span></span><br><span class="line"><span class="keyword">auto</span> hash_pair = [](<span class="type">const</span> std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; p) -&gt; std::<span class="type">size_t</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> hash&lt;<span class="type">long</span> <span class="type">long</span>&gt; hash_ll;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">hash_ll</span>(p.first + (<span class="built_in">static_cast</span>&lt;<span class="type">long</span> <span class="type">long</span>&gt;(p.second) &lt;&lt; <span class="number">32</span>));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 lambda 表达式作为哈希函数定义 unordered_map, 10 为桶的数量</span></span><br><span class="line">std::unordered_map&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, <span class="type">int</span>, <span class="keyword">decltype</span>(hash_pair)&gt; <span class="built_in">my_map</span>(<span class="number">10</span>, hash_pair);</span><br></pre></td></tr></table></figure><h2 id="7-set"><a href="#7-set" class="headerlink" title="7 set"></a>7 set</h2><h2 id="7-1-介绍"><a href="#7-1-介绍" class="headerlink" title="7.1 介绍"></a>7.1 介绍</h2><p>set 容器中的元素不会重复，当插入集合中已有的元素时，并不会插入进去，而且 set 容器里的元素自动从小到大排序。</p><p>即：set 里面的元素 <strong>不重复且有序</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="comment">//初始化定义</span></span><br><span class="line">set&lt;<span class="type">int</span>&gt; s;</span><br></pre></td></tr></table></figure><p>Cpp</p><h2 id="7-2-函数方法"><a href="#7-2-函数方法" class="headerlink" title="7.2 函数方法"></a>7.2 函数方法</h2><table><thead><tr><th>代码</th><th>复杂度</th><th>含义</th></tr></thead><tbody><tr><td><code>s.begin()</code></td><td>O(1)O(1)</td><td>返回 set 容器的第一个元素的地址（迭代器）</td></tr><tr><td><code>s.end()</code></td><td>O(1)O(1)</td><td>返回 set 容器的最后一个元素的下一个地址（迭代器）</td></tr><tr><td><code>s.rbegin()</code></td><td>O(1)O(1)</td><td>返回逆序迭代器，指向容器元素最后一个位置</td></tr><tr><td><code>s.rend()</code></td><td>O(1)O(1)</td><td>返回逆序迭代器，指向容器第一个元素前面的位置</td></tr><tr><td><code>s.clear()</code></td><td>O(N)O(N)</td><td>删除 set 容器中的所有的元素, 无返回值</td></tr><tr><td><code>s.empty()</code></td><td>O(1)O(1)</td><td>判断 set 容器是否为空</td></tr><tr><td><code>s.insert(element)</code></td><td>O(logN)O(logN)</td><td>插入一个元素</td></tr><tr><td><code>s.size()</code></td><td>O(1)O(1)</td><td>返回当前 set 容器中的元素个数</td></tr><tr><td><code>erase(iterator)</code></td><td>O(logN)O(logN)</td><td>删除定位器 iterator 指向的值</td></tr><tr><td><code>erase(first, second）</code></td><td></td><td>删除定位器 first 和 second 之间的值</td></tr><tr><td><code>erase(key_value)</code></td><td>O(logN)O(logN)</td><td>删除键值 key_value 的值</td></tr><tr><td>查找</td><td></td><td></td></tr><tr><td><code>s.find(element)</code></td><td></td><td>查找 set 中的某一元素，有则返回该元素对应的迭代器，无则返回结束迭代器</td></tr><tr><td><code>s.count(element)</code></td><td></td><td>查找 set 中的元素出现的个数，由于 set 中元素唯一，此函数相当于查询 element 是否出现</td></tr><tr><td><code>s.lower_bound(k)</code></td><td>O(logN)O(logN)</td><td>返回大于等于 k 的第一个元素的迭代器</td></tr><tr><td><code>s.upper_bound(k)</code></td><td>O(logN)O(logN)</td><td>返回大于 k 的第一个元素的迭代器</td></tr></tbody></table><h2 id="7-3-元素访问"><a href="#7-3-元素访问" class="headerlink" title="7.3 元素访问"></a>7.3 元素访问</h2><ul><li><strong>迭代器访问</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(set&lt;<span class="type">int</span>&gt;::iterator it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>智能指针</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i : s)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>访问最后一个元素</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一种</span></span><br><span class="line">cout &lt;&lt; *s.<span class="built_in">rbegin</span>() &lt;&lt; endl;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//第二种</span></span><br><span class="line">set&lt;<span class="type">int</span>&gt;::iterator iter = s.<span class="built_in">end</span>();</span><br><span class="line">iter--;</span><br><span class="line">cout &lt;&lt; (*iter) &lt;&lt; endl; <span class="comment">//打印 2;</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第三种</span></span><br><span class="line">cout &lt;&lt; *(--s.<span class="built_in">end</span>()) &lt;&lt; endl;</span><br></pre></td></tr></table></figure><h2 id="7-4-重载-运算符"><a href="#7-4-重载-运算符" class="headerlink" title="7.4 重载 &lt; 运算符"></a>7.4 重载 &lt; 运算符</h2><ul><li><strong>基础数据类型</strong></li></ul><p>方式一：改变 set 排序规则，set 中默认使用 less 比较器，即从小到大排序。（常用）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set&lt;<span class="type">int</span>&gt; s1; <span class="comment">// 默认从小到大排序</span></span><br><span class="line">set&lt;<span class="type">int</span>, greater&lt;<span class="type">int</span>&gt; &gt; s2;  <span class="comment">// 从大到小排序</span></span><br></pre></td></tr></table></figure><p>方式二：重载运算符。（很麻烦，不太常用，没必要）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//重载 &lt; 运算符</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cmp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span> <span class="params">()</span> <span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; u, <span class="type">const</span> <span class="type">int</span>&amp; v)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">       <span class="comment">// return + 返回条件</span></span><br><span class="line">       <span class="keyword">return</span> u &gt; v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">set&lt;<span class="type">int</span>, cmp&gt; s; </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">s.<span class="built_in">insert</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i : s)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 10 9 8 7 6 5 4 3 2 1</span></span><br></pre></td></tr></table></figure><p>方式三：初始化时使用匿名函数定义比较规则</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">set&lt;<span class="type">int</span>, function&lt;<span class="type">bool</span>(<span class="type">int</span>, <span class="type">int</span>)&gt;&gt; <span class="built_in">s</span>([&amp;](<span class="type">int</span> i, <span class="type">int</span> j)&#123;</span><br><span class="line">    <span class="keyword">return</span> i &gt; j; <span class="comment">// 从大到小</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">s.<span class="built_in">insert</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> x : s)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>高级数据类型（结构体）</strong></li></ul><p>直接重载结构体运算符即可，让结构体可以比较。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> x, y;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> Point &amp;p) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line"><span class="comment">// 按照点的横坐标从小到大排序, 如果横坐标相同, 纵坐标从小到大</span></span><br><span class="line"><span class="keyword">if</span>(x == p.x)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> y &lt; p.y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> x &lt; p.x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">set&lt;Point&gt; s;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    s.<span class="built_in">insert</span>(&#123;x, y&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 输入</span></span><br><span class="line"><span class="comment">5 4</span></span><br><span class="line"><span class="comment">5 2</span></span><br><span class="line"><span class="comment">3 7</span></span><br><span class="line"><span class="comment">3 5</span></span><br><span class="line"><span class="comment">4 8</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i : s)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; i.x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; i.y &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 输出</span></span><br><span class="line"><span class="comment">3 5</span></span><br><span class="line"><span class="comment">3 7</span></span><br><span class="line"><span class="comment">4 8</span></span><br><span class="line"><span class="comment">5 2</span></span><br><span class="line"><span class="comment">5 4</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="7-5-multiset"><a href="#7-5-multiset" class="headerlink" title="7.5 multiset"></a>7.5 multiset</h2><p><code>multiset</code> ：元素可以重复，且元素有序</p><ul><li><p>注意点一：方法函数基本和 <code>set</code> 一样，参考 set 即可。</p></li><li><p>注意点二：进行删除操作时，要明确删除目标。（ <code>s</code> 为声明的 multiset 变量名）</p><p>  删除多个元素：由于元素可以重复，注意使用 <code>s.erase(val)</code> 方法时，会删除掉所有与 <code>val</code> 相等的元素</p><p>  删除一个元素：需要删除一个元素时，需要使用 <code>s.erase(s.find(val))</code> 操作，先找到一个与 <code>val</code> 相等的元素迭代器，专门删除这个元素</p></li><li><p>注意点三：头文件操作为 <code>#include&lt;set&gt;</code></p></li></ul><p><code>unordered_set</code> ：元素无序且只能出现一次</p><p><code>unordered_multiset</code> ：元素无序可以出现多次</p><h2 id="8-pair"><a href="#8-pair" class="headerlink" title="8 pair"></a>8 pair</h2><h2 id="8-1-介绍"><a href="#8-1-介绍" class="headerlink" title="8.1 介绍"></a>8.1 介绍</h2><p>pair 只含有两个元素，可以看作是只有两个元素的结构体。</p><p><strong>应用：</strong></p><ul><li>代替二元结构体</li><li>作为 map 键值对进行插入（代码如下）</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, <span class="type">int</span>&gt;mp;</span><br><span class="line">mp.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;string, <span class="type">int</span>&gt;(<span class="string">&quot;xingmaqi&quot;</span>, <span class="number">1</span>));</span><br><span class="line"><span class="comment">// mp.insert(make_pair(&quot;xingmaqi&quot;, 1));</span></span><br><span class="line"><span class="comment">// mp.insert(&#123;&quot;xingmaqi&quot;, 1&#125;);</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.初始化定义</span></span><br><span class="line"><span class="function">pair&lt;string, <span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="string">&quot;wangyaqi&quot;</span>, <span class="number">1</span>)</span></span>;  <span class="comment">//带初始值的</span></span><br><span class="line">pair&lt;string, <span class="type">int</span>&gt; p;<span class="comment">//不带初始值的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.赋值</span></span><br><span class="line">p = &#123;<span class="string">&quot;wang&quot;</span>, <span class="number">18</span>&#125;;</span><br><span class="line">p = <span class="built_in">make_pair</span>(<span class="string">&quot;wang&quot;</span>, <span class="number">18</span>);</span><br><span class="line">p = <span class="built_in">pair</span>&lt;string, <span class="type">int</span>&gt;(<span class="string">&quot;wang&quot;</span>, <span class="number">18</span>);</span><br></pre></td></tr></table></figure><h2 id="8-2-访问"><a href="#8-2-访问" class="headerlink" title="8.2 访问"></a>8.2 访问</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义结构体数组</span></span><br><span class="line">pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; p[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//和结构体类似，first 代表第一个元素，second 代表第二个元素</span></span><br><span class="line">cout &lt;&lt; p[i].first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; p[i].second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9-string"><a href="#9-string" class="headerlink" title="9 string"></a>9 string</h2><h2 id="9-1-介绍"><a href="#9-1-介绍" class="headerlink" title="9.1 介绍"></a>9.1 介绍</h2><p>string 是一个字符串类，和 <code>char</code> 型字符串类似。</p><p>可以把 string 理解为一个字符串类型，像 int 一样可以定义</p><h2 id="9-2-初始化及定义"><a href="#9-2-初始化及定义" class="headerlink" title="9.2 初始化及定义"></a>9.2 初始化及定义</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.</span></span><br><span class="line">string str1;                 <span class="comment">//生成空字符串</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.</span></span><br><span class="line"><span class="function">string <span class="title">str2</span><span class="params">(<span class="string">&quot;123456789&quot;</span>)</span></span>;           <span class="comment">//生成 &quot;1234456789&quot; 的复制品 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3.</span></span><br><span class="line"><span class="function">string <span class="title">str3</span><span class="params">(<span class="string">&quot;12345&quot;</span>, <span class="number">0</span>, <span class="number">3</span>)</span></span>;         <span class="comment">//结果为 &quot;123&quot; ，从 0 位置开始，长度为 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//4.</span></span><br><span class="line"><span class="function">string <span class="title">str4</span><span class="params">(<span class="string">&quot;123456&quot;</span>, <span class="number">5</span>)</span></span>;           <span class="comment">//结果为 &quot;12345&quot; ，长度为 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//5.</span></span><br><span class="line"><span class="function">string <span class="title">str5</span><span class="params">(<span class="number">5</span>, <span class="string">&#x27;2&#x27;</span>)</span></span>;                <span class="comment">//结果为 &quot;22222&quot; , 构造 5 个字符&#x27;2&#x27;连接而成的字符串</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//6.</span></span><br><span class="line"><span class="function">string <span class="title">str6</span><span class="params">(str2, <span class="number">2</span>)</span></span>;               <span class="comment">//结果为 &quot;3456789&quot;，截取第三个元素（2 对应第三位）到最后</span></span><br></pre></td></tr></table></figure><p><strong>简单使用</strong></p><ul><li>访问单个字符：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">string s = <span class="string">&quot;xing ma qi!!!&quot;</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; s[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>string</code> 数组使用：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">string s[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">s[i] = <span class="string">&quot;loading...  &quot;</span> ;</span><br><span class="line">cout &lt;&lt; s[i] &lt;&lt; i &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">loading...  <span class="number">1</span></span><br><span class="line">loading...  <span class="number">2</span></span><br><span class="line">loading...  <span class="number">3</span></span><br><span class="line">loading...  <span class="number">4</span></span><br><span class="line">loading...  <span class="number">5</span></span><br><span class="line">loading...  <span class="number">6</span></span><br><span class="line">loading...  <span class="number">7</span></span><br><span class="line">loading...  <span class="number">8</span></span><br><span class="line">loading...  <span class="number">9</span></span><br></pre></td></tr></table></figure><h2 id="9-3-string-特性"><a href="#9-3-string-特性" class="headerlink" title="9.3 string 特性"></a>9.3 string 特性</h2><ul><li><p>支持 <strong>比较</strong> 运算符<br>  string 字符串支持常见的比较操作符 <code>（&gt;,&gt;=,&lt;,&lt;=,==,!=）</code>，支持 <code>string</code> 与 <code>C-string</code> 的比较（如 <code>str &lt; &quot;hello&quot;</code>）。<br>  在使用 <code>&gt;,&gt;=,&lt;,&lt;=</code> 这些操作符的时候是根据“当前字符特性”将字符按 <code>字典顺序</code> 进行逐一得 比较。字典排序靠前的字符小， 比较的顺序是从前向后比较，遇到不相等的字符就按这个位置上的两个字符的比较结果确定两个字符串的大小（前面减后面）。</p><p>  同时，<code>string (&quot;aaaa&quot;) &lt;string(aaaaa)</code>。</p></li><li><p>支持 <code>+</code> <strong>运算</strong> 符，代表拼接字符串<br>  string 字符串可以拼接，通过 “+” 运算符进行拼接。</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string s1 = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">string s2 = <span class="string">&quot;456&quot;</span>;</span><br><span class="line">string s = s1 + s2;</span><br><span class="line">cout &lt;&lt; s;   <span class="comment">//123456</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="9-4-读入详解"><a href="#9-4-读入详解" class="headerlink" title="9.4 读入详解"></a>9.4 读入详解</h2><p><strong>读入字符串，遇空格，回车结束</strong></p><p><strong>读入一行字符串（包括空格），遇回车结束</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string s;</span><br><span class="line"><span class="built_in">getline</span>(cin, s);</span><br></pre></td></tr></table></figure><p>注意: <code>getline(cin, s)</code> 会获取前一个输入的换行符，需要在前面添加读取换行符的语句。如：<code>getchar()</code> 或 <code>cin.get()</code></p><p>错误读取：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;</span><br><span class="line">string s;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="built_in">getline</span>(cin, s); <span class="comment">//此时读取相当于读取了前一个回车字符</span></span><br></pre></td></tr></table></figure><p>正确读取：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;</span><br><span class="line">string s;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="built_in">getchar</span>(); <span class="comment">//cin.get()</span></span><br><span class="line"><span class="built_in">getline</span>(cin, s);<span class="comment">//可正确读入下一行的输入</span></span><br></pre></td></tr></table></figure><blockquote><p><code>cin</code> 与 <code>cin.getline()</code> 混用</p><p>cin 输入完后，回车，cin 遇到回车结束输入，但回车还在输入流中，cin 并不会清除，导致 <code>getline()</code> 读取回车，结束。<br>需要在 cin 后面加 <code>cin.ignore()</code>；主动删除输入流中的换行符。（不常用）</p></blockquote><p><strong>cin 和 cout 解锁</strong></p><p>代码（写在 main 函数开头）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="number">0</span>),cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><blockquote><p>为什么要进行 <code>cin</code> 和 <code>cout</code> 的解锁，原因是：</p><p>在一些题目中，读入的 <strong>数据量很大</strong>，往往超过了 1e5（105）的数据量, 而 <code>cin</code> 和 <code>cout</code> 的读入输出的速度 <strong>很慢</strong>（是因为 <code>cin</code> 和 <code>cout</code> 为了兼容 C 语言的读入输出在性能上做了妥协），远不如 <code>scanf</code> 和 <code>printf</code> 的速度，具体原因可以搜索相关的博客进行了解。</p><p><strong>所以</strong> 对 <code>cin</code> 和 <code>cout</code> 进行解锁使 <code>cin</code> 和 <code>cout</code> 的速度几乎接近 <code>scanf</code> 和 <code>printf</code>，避免输入输出超时。</p></blockquote><p><strong>注意</strong>：<code>cin cout</code> 解锁使用时，不能与 <code>scanf,getchar, printf,cin.getline()</code> 混用，一定要注意，会出错。</p><blockquote><p><strong>string 与 C 语言字符串（C-string）的区别</strong></p><ul><li>string<br>  是 C++的一个类，专门实现字符串的相关操作。具有丰富的操作方法，数据类型为 <code>string</code>，字符串结尾没有 <code>\0</code> 字符</li><li>C-string<br>  C 语言中的字符串，用 char 数组实现，类型为 <code>const char *</code>, 字符串结尾以 <code>\0</code> 结尾</li></ul></blockquote><p>一般来说 string 向 char 数组转换会出现一些问题，所以为了能够实现转换，string 有一个方法 <code>c_str()</code> 实现 string 向 char 数组的转换。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string s = <span class="string">&quot;xing ma qi&quot;</span>;</span><br><span class="line"><span class="type">char</span> s2[] = s.<span class="built_in">c_str</span>();</span><br></pre></td></tr></table></figure><h2 id="9-5-函数方法"><a href="#9-5-函数方法" class="headerlink" title="9.5 函数方法"></a>9.5 函数方法</h2><ul><li><strong>获取字符串长度</strong></li></ul><table><thead><tr><th>代码</th><th>含义</th></tr></thead><tbody><tr><td><code>s.size()</code> 和 <code>s.length()</code></td><td>返回 string 对象的字符个数，他们执行效果相同。</td></tr><tr><td><code>s.max_size()</code></td><td>返回 string 对象最多包含的字符数，超出会抛出 length_error 异常</td></tr><tr><td><code>s.capacity()</code></td><td>重新分配内存之前，string 对象能包含的最大字符数</td></tr></tbody></table><ul><li><strong>插入</strong></li></ul><table><thead><tr><th>代码</th><th>含义</th></tr></thead><tbody><tr><td><code>s.push_back()</code></td><td>在末尾插入</td></tr><tr><td>例：<code>s.push_back(&#39;a&#39;)</code></td><td>末尾插入一个字符 a</td></tr><tr><td><code>s.insert(pos,element)</code></td><td>在 pos 位置插入 element</td></tr><tr><td>例：<code>s.insert(s.begin(),&#39;1&#39;)</code></td><td>在第一个位置插入 1 字符</td></tr><tr><td><code>s.append(str)</code></td><td>在 s 字符串结尾添加 str 字符串</td></tr><tr><td>例：<code>s.append(&quot;abc&quot;)</code></td><td>在 s 字符串末尾添加字符串“abc”</td></tr></tbody></table><ul><li><strong>删除</strong></li></ul><table><thead><tr><th>代码</th><th>含义</th></tr></thead><tbody><tr><td><code>erase(iterator p)</code></td><td>删除字符串中 p 所指的字符</td></tr><tr><td><code>erase(iterator first, iterator last)</code></td><td>删除字符串中迭代器区间 <code>[first,last)</code> 上所有字符</td></tr><tr><td><code>erase(pos, len)</code></td><td>删除字符串中从索引位置 pos 开始的 len 个字符</td></tr><tr><td><code>clear()</code></td><td>删除字符串中所有字符</td></tr></tbody></table><ul><li><strong>字符替换</strong></li></ul><table><thead><tr><th>代码</th><th>含义</th></tr></thead><tbody><tr><td><code>s.replace(pos,n,str)</code></td><td>把当前字符串从索引 pos 开始的 n 个字符替换为 str</td></tr><tr><td><code>s.replace(pos,n,n1,c)</code></td><td>把当前字符串从索引 pos 开始的 n 个字符替换为 n1 个字符 c</td></tr><tr><td><code>s.replace(it1,it2,str)</code></td><td>把当前字符串 <code>[it1,it2)</code> 区间替换为 str <strong>it1 , it2 为迭代器哦</strong></td></tr></tbody></table><ul><li><strong>大小写转换</strong></li></ul><p>法一：</p><table><thead><tr><th>代码</th><th>含义</th></tr></thead><tbody><tr><td><code>tolower(s[i])</code></td><td>转换为小写</td></tr><tr><td><code>toupper(s[i])</code></td><td>转换为大写</td></tr></tbody></table><p>法二：</p><p>通过 stl 的 <code>transform</code> 算法配合 <code>tolower</code> 和 <code>toupper</code> 实现。<br>有 4 个参数，前 2 个指定要转换的容器的起止范围，第 3 个参数是结果存放容器的起始位置，第 4 个参数是一元运算。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string s;</span><br><span class="line"><span class="built_in">transform</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>(),s.<span class="built_in">begin</span>(),::tolower);<span class="comment">//转换小写</span></span><br><span class="line"><span class="built_in">transform</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>(),s.<span class="built_in">begin</span>(),::toupper);<span class="comment">//转换大写</span></span><br></pre></td></tr></table></figure><ul><li><strong>分割</strong></li></ul><table><thead><tr><th>代码</th><th>含义</th></tr></thead><tbody><tr><td><code>s.substr(pos,n)</code></td><td>截取从 pos 索引开始的 n 个字符</td></tr></tbody></table><ul><li><strong>查找</strong></li></ul><table><thead><tr><th>代码</th><th>含义</th></tr></thead><tbody><tr><td><code>s.find (str, pos)</code></td><td>在当前字符串的 pos 索引位置（默认为 0）开始，查找子串 str，返回找到的位置索引，-1 表示查找不到子串</td></tr><tr><td><code>s.find (c, pos)</code></td><td>在当前字符串的 pos 索引位置（默认为 0）开始，查找字符 c，返回找到的位置索引，-1 表示查找不到字符</td></tr><tr><td><code>s.rfind (str, pos)</code></td><td>在当前字符串的 pos 索引位置开始，反向查找子串 s，返回找到的位置索引，-1 表示查找不到子串</td></tr><tr><td><code>s.rfind (c,pos)</code></td><td>在当前字符串的 pos 索引位置开始，反向查找字符 c，返回找到的位置索引，-1 表示查找不到字符</td></tr><tr><td><code>s.find_first_of (str, pos)</code></td><td>在当前字符串的 pos 索引位置（默认为 0）开始，查找子串 s 的字符，返回找到的位置索引，-1 表示查找不到字符</td></tr><tr><td><code>s.find_first_not_of (str,pos)</code></td><td>在当前字符串的 pos 索引位置（默认为 0）开始，查找第一个不位于子串 s 的字符，返回找到的位置索引，-1 表示查找不到字符</td></tr><tr><td><code>s.find_last_of(str, pos)</code></td><td>在当前字符串的 pos 索引位置开始，查找最后一个位于子串 s 的字符，返回找到的位置索引，-1 表示查找不到字符</td></tr><tr><td><code>s.find_last_not_of ( str, pos)</code></td><td>在当前字符串的 pos 索引位置开始，查找最后一个不位于子串 s 的字符，返回找到的位置索引，-1 表示查找不到子串</td></tr></tbody></table><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">string <span class="title">s</span><span class="params">(<span class="string">&quot;dog bird chicken bird cat&quot;</span>)</span></span>;</span><br><span class="line">    <span class="comment">//字符串查找-----找到后返回首字母在字符串中的下标</span></span><br><span class="line">    <span class="comment">// 1. 查找一个字符串</span></span><br><span class="line">    cout &lt;&lt; s.<span class="built_in">find</span>(<span class="string">&quot;chicken&quot;</span>) &lt;&lt; endl;              <span class="comment">// 结果是：9</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 从下标为 6 开始找字符&#x27;i&#x27;，返回找到的第一个 i 的下标</span></span><br><span class="line">    cout &lt;&lt; s.<span class="built_in">find</span>(<span class="string">&#x27;i&#x27;</span>, <span class="number">6</span>) &lt;&lt; endl;                 <span class="comment">// 结果是：11</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 从字符串的末尾开始查找字符串，返回的还是首字母在字符串中的下标</span></span><br><span class="line">    cout &lt;&lt; s.<span class="built_in">rfind</span>(<span class="string">&quot;chicken&quot;</span>) &lt;&lt; endl;             <span class="comment">// 结果是：9</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 从字符串的末尾开始查找字符</span></span><br><span class="line">    cout &lt;&lt; s.<span class="built_in">rfind</span>(<span class="string">&#x27;i&#x27;</span>) &lt;&lt; endl;                   <span class="comment">// 结果是：18 因为是从末尾开始查找，所以返回第一次找到的字符</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 在该字符串中查找第一个属于字符串 s 的字符</span></span><br><span class="line">    cout &lt;&lt; s.<span class="built_in">find_first_of</span>(<span class="string">&quot;13br98&quot;</span>) &lt;&lt; endl;      <span class="comment">// 结果是：4---b</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 在该字符串中查找第一个不属于字符串 s 的字符------先匹配 dog，然后 bird 匹配不到，所以打印 4</span></span><br><span class="line">    cout &lt;&lt; s.<span class="built_in">find_first_not_of</span>(<span class="string">&quot;hello dog 2006&quot;</span>) &lt;&lt; endl;      <span class="comment">// 结果是：4</span></span><br><span class="line">    cout &lt;&lt; s.<span class="built_in">find_first_not_of</span>(<span class="string">&quot;dog bird 2006&quot;</span>) &lt;&lt; endl;       <span class="comment">// 结果是：9</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7. 在该字符串最后中查找第一个属于字符串 s 的字符</span></span><br><span class="line">    cout &lt;&lt; s.<span class="built_in">find_last_of</span>(<span class="string">&quot;13r98&quot;</span>) &lt;&lt; endl;        <span class="comment">// 结果是：19</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 8. 在该字符串最后中查找第一个不属于字符串 s 的字符------先匹配 t--a---c，然后空格匹配不到，所以打印 21</span></span><br><span class="line">    cout &lt;&lt; s.<span class="built_in">find_last_not_of</span>(<span class="string">&quot;teac&quot;</span>) &lt;&lt; endl;     <span class="comment">// 结果是：21</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>排序</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sort</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>());  <span class="comment">//按 ASCII 码排序</span></span><br></pre></td></tr></table></figure><h2 id="10-bitset"><a href="#10-bitset" class="headerlink" title="10 bitset"></a>10 bitset</h2><h2 id="10-1-介绍"><a href="#10-1-介绍" class="headerlink" title="10.1 介绍"></a>10.1 介绍</h2><p>bitset 在 bitset 头文件中，它类似数组，并且每一个元素只能是 ０ 或 １，每个元素只用 １bit 空间</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bitset&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="10-2-初始化定义"><a href="#10-2-初始化定义" class="headerlink" title="10.2 初始化定义"></a>10.2 初始化定义</h2><p>初始化方法</p><table><thead><tr><th>代码</th><th>含义</th></tr></thead><tbody><tr><td><code>bitset&lt;n&gt; a</code></td><td>a 有 n 位，每位都为 0</td></tr><tr><td><code>bitset&lt;n&gt; a(b)</code></td><td>a 是 unsigned long 型 u 的一个副本</td></tr><tr><td><code>bitset&lt;n&gt; a(s)</code></td><td>a 是 string 对象 s 中含有的位串的副本</td></tr><tr><td><code>bitset&lt;n&gt; a(s, pos, n)</code></td><td>a 是 s 中从位置 pos 开始的 n 个位的副本</td></tr></tbody></table><blockquote><p>注意：<code>n</code> 必须为常量表达式</p></blockquote><p>演示代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bitset&lt;4&gt; bitset1;　　        <span class="comment">//无参构造，长度为 ４，默认每一位为 0</span></span><br><span class="line"></span><br><span class="line">    <span class="function">bitset&lt;9&gt; <span class="title">bitset2</span><span class="params">(<span class="number">12</span>)</span></span>;　      <span class="comment">//长度为 9，二进制保存，前面用 0 补充</span></span><br><span class="line"></span><br><span class="line">    string s = <span class="string">&quot;100101&quot;</span>;</span><br><span class="line">    <span class="function">bitset&lt;10&gt; <span class="title">bitset3</span><span class="params">(s)</span></span>;　　    <span class="comment">//长度为 10，前面用 0 补充</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> s2[] = <span class="string">&quot;10101&quot;</span>;</span><br><span class="line">    <span class="function">bitset&lt;13&gt; <span class="title">bitset4</span><span class="params">(s2)</span></span>;　　   <span class="comment">//长度为 13，前面用 0 补充</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; bitset1 &lt;&lt; endl;　　  <span class="comment">//0000</span></span><br><span class="line">    cout &lt;&lt; bitset2 &lt;&lt; endl;　　  <span class="comment">//000001100</span></span><br><span class="line">    cout &lt;&lt; bitset3 &lt;&lt; endl;　　  <span class="comment">//0000100101</span></span><br><span class="line">    cout &lt;&lt; bitset4 &lt;&lt; endl;　    <span class="comment">//0000000010101</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-3-特性"><a href="#10-3-特性" class="headerlink" title="10.3 特性"></a>10.3 特性</h2><p><code>bitset</code> 可以进行 <strong>位操作</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">bitset&lt;4&gt; <span class="title">foo</span><span class="params">(string(<span class="string">&quot;1001&quot;</span>))</span></span>;</span><br><span class="line"><span class="function">bitset&lt;4&gt; <span class="title">bar</span><span class="params">(string(<span class="string">&quot;0011&quot;</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; (foo ^= bar) &lt;&lt; endl;       <span class="comment">// 1010 (foo 对 bar 按位异或后赋值给 foo)</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; (foo &amp;= bar) &lt;&lt; endl;       <span class="comment">// 0001 (按位与后赋值给 foo)</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; (foo |= bar) &lt;&lt; endl;       <span class="comment">// 1011 (按位或后赋值给 foo)</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; (foo &lt;&lt;= <span class="number">2</span>) &lt;&lt; endl;        <span class="comment">// 0100 (左移 2 位，低位补 0，有自身赋值)</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; (foo &gt;&gt;= <span class="number">1</span>) &lt;&lt; endl;        <span class="comment">// 0100 (右移 1 位，高位补 0，有自身赋值)</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; (~bar) &lt;&lt; endl;             <span class="comment">// 1100 (按位取反)</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; (bar &lt;&lt; <span class="number">1</span>) &lt;&lt; endl;         <span class="comment">// 0110 (左移，不赋值)</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; (bar &gt;&gt; <span class="number">1</span>) &lt;&lt; endl;         <span class="comment">// 0001 (右移，不赋值)</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; (foo == bar) &lt;&lt; endl;       <span class="comment">// false (1001 == 0011 为 false)</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; (foo != bar) &lt;&lt; endl;       <span class="comment">// true  (1001!= 0011 为 true)</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; (foo &amp; bar) &lt;&lt; endl;        <span class="comment">// 0001 (按位与，不赋值)</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; (foo | bar) &lt;&lt; endl;        <span class="comment">// 1011 (按位或，不赋值)</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; (foo ^ bar) &lt;&lt; endl;        <span class="comment">// 1010 (按位异或，不赋值)</span></span><br></pre></td></tr></table></figure><p><strong>访问</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可以通过 [] 访问元素(类似数组)，注意最低位下标为 0，类似于数的二进制表示，如下：</span></span><br><span class="line"><span class="function">bitset&lt;4&gt; <span class="title">f</span><span class="params">(<span class="string">&quot;1011&quot;</span>)</span></span>; </span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; f[i];<span class="comment">// 输出 1101</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-4-方法函数"><a href="#10-4-方法函数" class="headerlink" title="10.4 方法函数"></a>10.4 方法函数</h2><table><thead><tr><th>代码</th><th>含义</th></tr></thead><tbody><tr><td><code>b.any()</code></td><td>b 中是否存在置为 1 的二进制位，有 返回 true</td></tr><tr><td><code>b.none()</code></td><td>b 中是否没有 1，没有 返回 true</td></tr><tr><td><code>b.count()</code></td><td>b 中为 1 的个数</td></tr><tr><td><code>b.size()</code></td><td>b 中二进制位的个数</td></tr><tr><td><code>b.test(pos)</code></td><td>测试 b 在 pos 位置是否为 1，是 返回 true</td></tr><tr><td><code>b[pos]</code></td><td>返回 b 在 pos 处的二进制位</td></tr><tr><td><code>b.set()</code></td><td>把 b 中所有位都置为 1</td></tr><tr><td><code>b.set(pos)</code></td><td>把 b 中 pos 位置置为 1</td></tr><tr><td><code>b.reset()</code></td><td>把 b 中所有位都置为 0</td></tr><tr><td><code>b.reset(pos)</code></td><td>把 b 中 pos 位置置为 0</td></tr><tr><td><code>b.flip()</code></td><td>把 b 中所有二进制位取反</td></tr><tr><td><code>b.flip(pos)</code></td><td>把 b 中 pos 位置取反</td></tr><tr><td><code>b.to_ulong()</code></td><td>用 b 中同样的二进制位返回一个 unsigned long 值</td></tr></tbody></table><h2 id="10-5-bitset-优化"><a href="#10-5-bitset-优化" class="headerlink" title="10.5 bitset 优化"></a>10.5 bitset 优化</h2><p>一般会使用 bitset 来优化时间复杂度，大概时间复杂度会除 64 或 32，例如没有优化的时间复杂度为 O(NM)O(NM) ，使用 bitset 优化后复杂度可能就为 O(NM64)O(\frac{NM}{64})</p><p>bitset 还有开动态空间的技巧，bitset 常用在 <code>01背包</code> 优化等算法中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态长度 bitset 实现</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;              <span class="comment">// 开空间的上限，一般为数据范围附近的值</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> len = <span class="number">1</span>&gt;</span><br><span class="line"><span class="type">void</span> <span class="built_in">bitset_</span>(<span class="type">int</span> sz)    <span class="comment">// sz 即为想要开的大小</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (len &lt; sz)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">bitset_</span>&lt;<span class="built_in">min</span>(len * <span class="number">2</span>, N)&gt;(sz); <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bitset&lt;len + 1&gt; dp;</span><br><span class="line">    <span class="comment">// 具体算法的实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="11-array"><a href="#11-array" class="headerlink" title="11 array"></a>11 array</h2><h2 id="11-1-介绍"><a href="#11-1-介绍" class="headerlink" title="11.1 介绍"></a>11.1 介绍</h2><p>头文件</p><p><code>array</code> 是 C++11 新增的容器，效率与普通数据相差无几，比 <code>vector</code> 效率要高，自身添加了一些成员函数。</p><p>和其它容器不同，array 容器的大小是 <strong>固定</strong> 的，无法动态的扩展或收缩，<strong>只允许访问或者替换存储的元素。</strong></p><p><strong>注意：</strong></p><p><code>array</code> 的使用要在 <code>std</code> 命名空间里</p><h2 id="11-2-声明与初始化"><a href="#11-2-声明与初始化" class="headerlink" title="11.2 声明与初始化"></a>11.2 声明与初始化</h2><p><strong>基础数据类型</strong></p><p>声明一个大小为 100 的 <code>int</code> 型数组，元素的值不确定</p><p>声明一个大小为 100 的 <code>int</code> 型数组，初始值均为 <code>0</code>(初始值与默认元素类型等效)</p><p>声明一个大小为 100 的 <code>int</code> 型数组，初始化部分值，其余全部为 <code>0</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array&lt;<span class="type">int</span>, 100&gt; a&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure><p>或者可以用等号</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array&lt;<span class="type">int</span>, 100&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure><p><strong>高级数据类型</strong></p><p>不同于数组的是对元素类型不做要求，可以套结构体</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array&lt;string, 2&gt; s = &#123;<span class="string">&quot;ha&quot;</span>, <span class="built_in">string</span>(<span class="string">&quot;haha&quot;</span>)&#125;;</span><br><span class="line">array&lt;node, 2&gt; a;</span><br></pre></td></tr></table></figure><h2 id="11-3-存取元素"><a href="#11-3-存取元素" class="headerlink" title="11.3 存取元素"></a>11.3 存取元素</h2><ul><li>修改元素</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array&lt;<span class="type">int</span>, 4&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">a[<span class="number">0</span>] = <span class="number">4</span>;</span><br></pre></td></tr></table></figure><ul><li>访问元素</li></ul><p>下标访问</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">array&lt;<span class="type">int</span>, 4&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) </span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; \n&quot;</span>[i == <span class="number">3</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用 <code>auto</code> 访问</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i : a)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>迭代器访问</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> it = a.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">for</span>(; it != a.<span class="built_in">end</span>(); it++) </span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>at()</code> 函数访问</p><p>下标为 <code>1</code> 的元素加上下标为 <code>2</code> 的元素，答案为 <code>5</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array&lt;<span class="type">int</span>, 4&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="type">int</span> res = a.<span class="built_in">at</span>(<span class="number">1</span>) + a.<span class="built_in">at</span>(<span class="number">2</span>);</span><br><span class="line">cout &lt;&lt; res &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br></pre></td></tr></table></figure><p><code>get</code> 方法访问</p><p>将 <code>a</code> 数组下标为 <code>1</code> 位置处的值改为 <code>x</code></p><p>注意：获取的下标只能写数字，不能填变量</p><h2 id="11-4-成员函数"><a href="#11-4-成员函数" class="headerlink" title="11.4 成员函数"></a>11.4 成员函数</h2><table><thead><tr><th>成员函数</th><th>功能</th></tr></thead><tbody><tr><td><code>begin()</code></td><td>返回容器中第一个元素的访问迭代器（地址）</td></tr><tr><td><code>end()</code></td><td>返回容器最后一个元素之后一个位置的访问迭代器（地址）</td></tr><tr><td><code>rbegin()</code></td><td>返回最后一个元素的访问迭代器（地址）</td></tr><tr><td><code>rend()</code></td><td>返回第一个元素之前一个位置的访问迭代器（地址）</td></tr><tr><td><code>size()</code></td><td>返回容器中元素的数量，其值等于初始化 array 类的第二个模板参数 <code>N</code></td></tr><tr><td><code>max_size()</code></td><td>返回容器可容纳元素的最大数量，其值始终等于初始化 array 类的第二个模板参数 N</td></tr><tr><td><code>empty()</code></td><td>判断容器是否为空</td></tr><tr><td><code>at(n)</code></td><td>返回容器中 n 位置处元素的引用，函数会自动检查 n 是否在有效的范围内，如果不是则抛出 out_of_range 异常</td></tr><tr><td><code>front()</code></td><td>返回容器中第一个元素的直接引用，函数不适用于空的 array 容器</td></tr><tr><td><code>back()</code></td><td>返回容器中最后一个元素的直接引用，函数不适用于空的 array 容器。</td></tr><tr><td><code>data()</code></td><td>返回一个指向容器首个元素的指针。利用该指针，可实现复制容器中所有元素等类似功能</td></tr><tr><td><code>fill(x)</code></td><td>将 <code>x</code> 这个值赋值给容器中的每个元素, 相当于初始化</td></tr><tr><td><code>array1.swap(array2)</code></td><td>交换 array1 和 array2 容器中的所有元素，但前提是它们具有相同的长度和类型</td></tr></tbody></table><h2 id="11-5-部分用法示例"><a href="#11-5-部分用法示例" class="headerlink" title="11.5 部分用法示例"></a>11.5 部分用法示例</h2><p><code>data()</code></p><p>指向底层元素存储的指针。对于非空容器，返回的指针与首元素地址比较相等。</p><p><code>at()</code></p><p>下标为 <code>1</code> 的元素加上下标为 <code>2</code> 的元素，答案为 <code>5</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array&lt;<span class="type">int</span>, 4&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="type">int</span> res = a.<span class="built_in">at</span>(<span class="number">1</span>) + a.<span class="built_in">at</span>(<span class="number">2</span>);</span><br><span class="line">cout &lt;&lt; res &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br></pre></td></tr></table></figure><p><code>fill()</code></p><p>array 的 <code>fill()</code> 函数，将 <code>a</code> 数组全部元素值变为 <code>x</code></p><p>另外还有其它的 <code>fill()</code> 函数: 将 <code>a</code> 数组[begin, end)[begin, end)全部值变为 <code>x</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fill</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), x);</span><br></pre></td></tr></table></figure><p><strong>get 方法获取元素值</strong></p><p>将 <code>a</code> 数组下标为 <code>1</code> 位置处的值改为 <code>x</code></p><p>注意: 获取的下标只能写数字，不能填变量</p><p><strong>排序</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sort</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure><h2 id="12-tuple"><a href="#12-tuple" class="headerlink" title="12 tuple"></a>12 tuple</h2><h2 id="12-1-介绍"><a href="#12-1-介绍" class="headerlink" title="12.1 介绍"></a>12.1 介绍</h2><p>tuple 模板是 pair 的泛化，可以封装不同类型任意数量的对象。</p><p>可以把 tuple 理解为 pair 的扩展，tuple 可以声明二元组，也可以声明三元组。</p><p>tuple 可以等价为 <strong>结构体</strong> 使用</p><p><strong>头文件</strong></p><h2 id="12-2-声明初始化"><a href="#12-2-声明初始化" class="headerlink" title="12.2 声明初始化"></a>12.2 声明初始化</h2><p>声明一个空的 <code>tuple</code> 三元组</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tuple&lt;<span class="type">int</span>, <span class="type">int</span>, string&gt; t1;</span><br></pre></td></tr></table></figure><p>赋值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t1 = <span class="built_in">make_tuple</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="string">&quot;hahaha&quot;</span>);</span><br></pre></td></tr></table></figure><p>创建的同时初始化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">tuple&lt;<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">t2</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>可以使用 pair 对象构造 tuple 对象，但 tuple 对象必须是两个元素</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> p = <span class="built_in">make_pair</span>(<span class="string">&quot;wang&quot;</span>, <span class="number">1</span>);</span><br><span class="line">tuple&lt;string, <span class="type">int</span>&gt; t3 &#123;p&#125;; <span class="comment">//将 pair 对象赋给 tuple 对象</span></span><br></pre></td></tr></table></figure><h2 id="12-3-元素操作"><a href="#12-3-元素操作" class="headerlink" title="12.3 元素操作"></a>12.3 元素操作</h2><p>获取 tuple 对象 <code>t</code> 的第一个元素</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> first = <span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(t);</span><br></pre></td></tr></table></figure><p>修改 tuple 对象 <code>t</code> 的第一个元素</p><h2 id="12-4-函数操作"><a href="#12-4-函数操作" class="headerlink" title="12.4 函数操作"></a>12.4 函数操作</h2><ul><li>获取元素个数</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">tuple&lt;<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">t</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; tuple_size&lt;<span class="keyword">decltype</span>(t)&gt;::value &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><ul><li>获取对应元素的值</li></ul><p>通过 <code>get&lt;n&gt;(obj)</code> 方法获取, <code>n</code> 必须为数字不能是变量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">tuple&lt;<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">t</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; <span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(t) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="comment">// 1</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(t) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="comment">// 2</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(t) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><ul><li>通过 <code>tie</code> 解包 获取元素值</li></ul><p><code>tie</code> 可以让 tuple 变量中的三个值依次赋到 tie 中的三个变量中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> one, three;</span><br><span class="line">string two; </span><br><span class="line"><span class="function">tuple&lt;<span class="type">int</span>, string, <span class="type">int</span>&gt; <span class="title">t</span><span class="params">(<span class="number">1</span>, <span class="string">&quot;hahaha&quot;</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line"><span class="built_in">tie</span>(one, two, three) = t;</span><br><span class="line">cout &lt;&lt; one &lt;&lt; two &lt;&lt; three &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">// 1hahaha3</span></span><br></pre></td></tr></table></figure><hr><h2 id="STL-函数"><a href="#STL-函数" class="headerlink" title="STL 函数"></a>STL 函数</h2><h2 id="sort-——-排序"><a href="#sort-——-排序" class="headerlink" title="sort —— 排序"></a>sort —— 排序</h2><p><strong>时间复杂度：</strong> O(N logN)</p><blockquote><p>作用：对一个序列进行排序</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原型：</span></span><br><span class="line"><span class="built_in">sort</span>(beg, end);</span><br><span class="line"><span class="built_in">sort</span>(beg, end, cmp);</span><br></pre></td></tr></table></figure><p>几种排序的常见操作：</p><ul><li>操作一：对数组正常升序排序</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[N]; <span class="comment">// 普通数组定义</span></span><br><span class="line"><span class="comment">// 对 a 数组的 [1, n] 位置进行从小到大排序</span></span><br><span class="line"><span class="built_in">sort</span>(a + <span class="number">1</span>, a + <span class="number">1</span> + n);</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">b</span><span class="params">(n + <span class="number">1</span>)</span></span>; <span class="comment">// vector 数组定义</span></span><br><span class="line"><span class="built_in">sort</span>(b.<span class="built_in">begin</span>() + <span class="number">1</span>, b.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure><ul><li>操作二：使用第三个参数，进行降序排序</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对 a 数组的 [0, n-1] 位置从大到小排序</span></span><br><span class="line"><span class="built_in">sort</span>(a, a + n, <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line"><span class="comment">//对 a 数组的 [0, n-1] 位置从小到大排序</span></span><br><span class="line"><span class="built_in">sort</span>(a, a + n, <span class="built_in">less</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">b</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="built_in">sort</span>(b.<span class="built_in">begin</span>() + <span class="number">1</span>, b.<span class="built_in">end</span>()); <span class="comment">// 升序</span></span><br><span class="line"><span class="built_in">sort</span>(b.<span class="built_in">begin</span>() + <span class="number">1</span>, b.<span class="built_in">end</span>(), <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;()); <span class="comment">// 降序</span></span><br></pre></td></tr></table></figure><ul><li>操作三：另外一种降序排序方法，针对 <code>vector</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line"><span class="built_in">sort</span>(a.<span class="built_in">rbegin</span>(), a.<span class="built_in">rend</span>()); <span class="comment">// 使用反向迭代器进行降序排序</span></span><br></pre></td></tr></table></figure><ul><li>操作四：自定义排序规则</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 使用函数自定义排序，定义比较函数</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(node a, node b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//按结构体里面的 x 值降序排列</span></span><br><span class="line">    <span class="keyword">return</span> a.x &gt; b.x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(node, node + n, cmp); <span class="comment">// 只能接受 以函数为形式的自定义排序规则，无法接受以结构体为形式的自定义排序规则</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 或者使用匿名函数自定义排序规则</span></span><br><span class="line"><span class="built_in">sort</span>(node, node + n, [](node a, node b) &#123;</span><br><span class="line">    <span class="keyword">return</span> a.x &gt; b.x;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="stable-sort"><a href="#stable-sort" class="headerlink" title="stable_sort"></a>stable_sort</h3><p><strong>复杂度：</strong> O(N logN)</p><blockquote><p>功能和 <code>sort()</code> 基本一样</p><p>区别在于 <code>stable_sort()</code> 能够保证相等元素的相对位置，排序时不会改变相等元素的相对位置</p></blockquote><p>使用用法和 <code>sort()</code> 一样，见上</p><h3 id="is-sorted"><a href="#is-sorted" class="headerlink" title="is_sorted"></a>is_sorted</h3><p><strong>复杂度：</strong> O(N)</p><blockquote><p>判断序列是否有序（升序），返回 <code>bool</code> 值</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果序列有序，输出 YES</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">is_sorted</span>(a, a + n))</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;YES\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="iota"><a href="#iota" class="headerlink" title="iota"></a>iota</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">iota</span>(beg, end, start)</span><br></pre></td></tr></table></figure><blockquote><p>让序列递增赋值</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="built_in">iota</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i : a)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0 1 2 3 4 5 6 7 8 9</span></span><br></pre></td></tr></table></figure><h3 id="partial-sort"><a href="#partial-sort" class="headerlink" title="partial_sort"></a>partial_sort</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">partial_sort</span>(beg, mid, end)</span><br></pre></td></tr></table></figure><p><strong>时间复杂度：</strong> 大概 O(N logM) ，其中 <code>M</code> 为距离</p><blockquote><p>部分排序, 排序 mid-beg 个元素，mid 为要排序区间元素的尾后的一个位置</p><p>从 beg 到 mid <strong>前</strong> 的元素都排好序</p></blockquote><p>对 a 数组前 5 个元素排序按从小到大排序</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">6</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="built_in">partial_sort</span>(a, a + <span class="number">5</span>, a + <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; a[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1 2 3 4 5 9 8 10 7 6</span></span><br><span class="line"><span class="comment">//前五个元素都有序</span></span><br></pre></td></tr></table></figure><p>也可以添加自定义排序规则：</p><p><code>partial_sort(beg,mid,end,cmp)</code></p><p>对 a 的前五个元素都是降序排列</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">6</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="built_in">partial_sort</span>(a, a + <span class="number">5</span>, a + <span class="number">10</span>, <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) </span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; a[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//10 9 8 7 6 1 2 4 5 3</span></span><br><span class="line"><span class="comment">//前五个元素降序有序</span></span><br></pre></td></tr></table></figure><h2 id="max-min-——-找最值"><a href="#max-min-——-找最值" class="headerlink" title="max + min —— 找最值"></a>max + min —— 找最值</h2><p><strong>时间复杂度：</strong> O(1)</p><blockquote><p>找多个元素的最大值和最小值</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//找 a，b 的最大值和最小值</span></span><br><span class="line">mx = <span class="built_in">max</span>(a, b);</span><br><span class="line">mn = <span class="built_in">min</span>(a, b);</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//找到 a, b, c, d 的最大值和最小值</span></span><br><span class="line">mx = <span class="built_in">max</span>(&#123;a, b, c, d&#125;);</span><br><span class="line">mn = <span class="built_in">min</span>(&#123;a, b, c, d&#125;);</span><br></pre></td></tr></table></figure><h3 id="max-element-min-element"><a href="#max-element-min-element" class="headerlink" title="max_element+min_element"></a>max_element+min_element</h3><p><strong>复杂度：</strong> O(N)</p><blockquote><p>找最大最小值</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数都是返回地址，需要加*解引用取值</span></span><br><span class="line"><span class="type">int</span> mx = *<span class="built_in">max_element</span>(a, a + n);</span><br><span class="line"><span class="type">int</span> mn = *<span class="built_in">min_element</span>(a, a + n);</span><br></pre></td></tr></table></figure><h3 id="nth-element-——-寻找第-n-小的值"><a href="#nth-element-——-寻找第-n-小的值" class="headerlink" title="nth_element —— 寻找第 n 小的值"></a>nth_element —— 寻找第 n 小的值</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">nth_element</span>(beg, nth, end)</span><br></pre></td></tr></table></figure><p><strong>复杂度：</strong> 平均 O(N)</p><blockquote><p>寻找第序列第 n 小的值</p></blockquote><p><code>nth</code> 为一个迭代器，指向序列中的一个元素。第 n 小的值恰好在 <code>nth</code> 位置上。</p><p>执行 <code>nth_element()</code> 之后，序列中的元素会围绕 nth 进行划分：<strong>nth 之前的元素都小于等于它，而之后的元素都大于等于它</strong></p><p><strong>实例：求序列中的第 3 小的元素</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">nth_element</span>(a, a + <span class="number">2</span>, a + n);</span><br><span class="line">cout &lt;&lt; a[<span class="number">2</span>] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="minmax"><a href="#minmax" class="headerlink" title="minmax"></a>minmax</h3><p><strong>复杂度：</strong> O(1)</p><blockquote><p>返回一个 <code>pair</code> 类型，第一个元素是 <code>min(a, b)</code>， 第二个元素是 <code>max(a, b)</code></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; t = <span class="built_in">minmax</span>(<span class="number">4</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">// t.first = 2, t.second = 4</span></span><br></pre></td></tr></table></figure><h3 id="minmax-element"><a href="#minmax-element" class="headerlink" title="minmax_element"></a>minmax_element</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">minmax_element</span>(beg, end)</span><br></pre></td></tr></table></figure><p><strong>复杂度：</strong> O(N)</p><blockquote><p>返回序列中的最小和最大值组成 pair 的对应的地址，返回类型为 <code>pair&lt;vector&lt;int&gt;::iterator, vector&lt;int&gt;::iterator&gt;</code></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n = <span class="number">10</span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line"><span class="built_in">iota</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), <span class="number">1</span>);</span><br><span class="line"><span class="keyword">auto</span> t = <span class="built_in">minmax_element</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>()); <span class="comment">// 返回的是最小值和最大值对应的地址</span></span><br><span class="line"><span class="comment">// *t.first = 1, * t.second = 10 输出对应最小最大值时需要使用指针</span></span><br></pre></td></tr></table></figure><h2 id="to-string-——-将数字转化成字符串"><a href="#to-string-——-将数字转化成字符串" class="headerlink" title="to_string —— 将数字转化成字符串"></a>to_string —— 将数字转化成字符串</h2><blockquote><p>将数字转化为字符串，支持小数（double）</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">12345678</span>;</span><br><span class="line">cout &lt;&lt; <span class="built_in">to_string</span>(a) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br></pre></td></tr></table></figure><h2 id="lower-bound-upper-bound-——-二分查找"><a href="#lower-bound-upper-bound-——-二分查找" class="headerlink" title="lower_bound + upper_bound —— 二分查找"></a>lower_bound + upper_bound —— 二分查找</h2><p><strong>复杂度：</strong> O(logN)</p><blockquote><p>作用：二分查找</p><p><strong>注意：用 * 解引用之后是取出来的是值，减去 <code>begin()</code> 得到的是下标！</strong></p><ul><li><strong>三个参数</strong>：<code>(起始位置, 结束位置, 目标值)</code>。</li><li><strong>范围</strong>：左闭右开 <code>[start, end)</code>。</li><li><strong>返回值</strong>：成功返回有效迭代器&#x2F;指针，失败返回 <code>end</code>。</li><li><strong>前提</strong>：数据必须有序！</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果未找到，返回尾地址的下一个位置的地址</span></span><br><span class="line"><span class="built_in">lower_bound</span>(起始迭代器 / 指针, 结束迭代器 / 指针, 目标值);</span><br><span class="line"><span class="built_in">upper_bound</span>(起始迭代器 / 指针, 结束迭代器 / 指针, 目标值);</span><br><span class="line"><span class="built_in">lower_bound</span>(a, a + n, x);        <span class="comment">//在 a 数组中查找第一个大于等于 x 的元素，返回该元素的地址</span></span><br><span class="line"><span class="built_in">upper_bound</span>(a, a + n, x);        <span class="comment">//在 a 数组中查找第一个大于 x 的元素，返回该元素的地址</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span>             <span class="comment">// 包含 lower_bound 和 upper_bound</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a[] = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">9</span>, <span class="number">9</span>, <span class="number">11</span> &#125;;</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">sizeof</span>(a) / <span class="built_in">sizeof</span>(a[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 示例 1：使用 lower_bound 查找第一个 &gt;= 3 的元素</span></span><br><span class="line">    <span class="type">int</span> x = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">auto</span> it1 = <span class="built_in">lower_bound</span>(a, a + n, x);</span><br><span class="line">    <span class="keyword">if</span> (it1 != a + n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> index = it1 - a;        <span class="comment">// 计算下标</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;第一个大于等于 &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; 的元素是 a[&quot;</span> &lt;&lt; index &lt;&lt; <span class="string">&quot;] = &quot;</span> &lt;&lt; *it1 &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 第一个大于等于 3 的元素是 a [1] = 3</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;没有找到大于等于 &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; 的元素&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 示例 2：使用 upper_bound 查找第一个 &gt; 3 的元素</span></span><br><span class="line">    <span class="keyword">auto</span> it2 = <span class="built_in">upper_bound</span>(a, a + n, x);</span><br><span class="line">    <span class="keyword">if</span> (it2 != a + n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> index = it2 - a;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;第一个大于 &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; 的元素是 a[&quot;</span> &lt;&lt; index &lt;&lt; <span class="string">&quot;] = &quot;</span> &lt;&lt; *it2 &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 第一个大于 3 的元素是 a [3] = 5</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;没有找到大于 &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; 的元素&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 示例 3：查找不存在的元素</span></span><br><span class="line">    x = <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">auto</span> it3 = <span class="built_in">lower_bound</span>(a, a + n, x);</span><br><span class="line">    <span class="keyword">if</span> (it3 != a + n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> index = it3 - a;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;第一个大于等于 &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; 的元素是 a[&quot;</span> &lt;&lt; index &lt;&lt; <span class="string">&quot;] = &quot;</span> &lt;&lt; *it3 &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 第一个大于等于 8 的元素是 a [5] = 9</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;没有找到大于等于 &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; 的元素&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 示例 4：统计某个值出现的次数</span></span><br><span class="line">    x = <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">auto</span> left = <span class="built_in">lower_bound</span>(a, a + n, x);</span><br><span class="line">    <span class="keyword">auto</span> right = <span class="built_in">upper_bound</span>(a, a + n, x);</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; <span class="string">&quot; 出现的次数: &quot;</span> &lt;&lt; right - left &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 9 出现的次数: 3</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 示例 5：在 vector 中使用</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v = &#123; <span class="number">2</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span> &#125;;</span><br><span class="line">    <span class="keyword">auto</span> itv = <span class="built_in">lower_bound</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">if</span> (itv != v.<span class="built_in">end</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> index = itv - v.<span class="built_in">begin</span>();</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;vector 中第一个大于等于 5 的元素是 v[&quot;</span> &lt;&lt; index &lt;&lt; <span class="string">&quot;] = &quot;</span> &lt;&lt; *itv &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// vector 中第一个大于等于 5 的元素是 v [3] = 6</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="atoi-——-将字符串转整型"><a href="#atoi-——-将字符串转整型" class="headerlink" title="atoi —— 将字符串转整型"></a>atoi —— 将字符串转整型</h2><blockquote><p>将字符串转换为 <code>int</code> 类型</p></blockquote><p>注意参数为 <code>char</code> 型数组，如果需要将 string 类型转换为 int 类型，可以使用 <code>stoi</code> 函数（参考下文），或者将 <code>string</code> 类型转换为 <code>const char *</code> 类型。</p><p>关于输出数字的范围：<br><code>atoi</code> <strong>不做</strong> 范围检查，如果超出上界，输出上界，超出下界，输出下界。<br><code>stoi</code> <strong>会做</strong> 范围检查，默认必须在 <code>int</code> 范围内，如果超出范围，会出现 RE（Runtime Error）错误。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string s = <span class="string">&quot;1234&quot;</span>;</span><br><span class="line"><span class="type">int</span> a = <span class="built_in">atoi</span>(s.<span class="built_in">c_str</span>());</span><br><span class="line">cout &lt;&lt; a &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">// 1234</span></span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> s[] = <span class="string">&quot;1234&quot;</span>;</span><br><span class="line"><span class="type">int</span> a = <span class="built_in">atoi</span>(s);</span><br><span class="line">cout &lt;&lt; a &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br></pre></td></tr></table></figure><h2 id="stoi-stoll-stod-…-——-将字符串转整型（更常用）"><a href="#stoi-stoll-stod-…-——-将字符串转整型（更常用）" class="headerlink" title="stoi &#x2F; stoll &#x2F; stod &#x2F; … —— 将字符串转整型（更常用）"></a>stoi &#x2F; stoll &#x2F; stod &#x2F; … —— 将字符串转整型（更常用）</h2><blockquote><p>将对应 string 类型字符串转换为数字（<code>int</code> 型），记忆：<code>s -&gt; t 分别对应两个数据类型的某个字母</code></p></blockquote><p>注意参数为 <code>string</code> 字符串类型。</p><p><strong>如果要转换为其他类型的数字可使用 <code>stoll（转换为 long long）</code> ， <code>stoull（转换为 unsigned long long）</code>，<code>stod（转换为 double）</code> 等函数。</strong></p><p>关于输出数字的范围：</p><ul><li><p><code>stoi</code> <strong>会做</strong> 范围检查，默认必须在 <code>int</code> 范围内，如果超出范围，会出现 RE（Runtime Error）错误。</p></li><li><p><code>atoi</code> <strong>不做</strong> 范围检查，如果超出上界，输出上界，超出下界，输出下界。</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string s = <span class="string">&quot;1234&quot;</span>;</span><br><span class="line"><span class="type">int</span> a = <span class="built_in">stoi</span>(s);</span><br><span class="line">cout &lt;&lt; a &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">// 1234</span></span><br></pre></td></tr></table></figure><h2 id="reverse-——-翻转"><a href="#reverse-——-翻转" class="headerlink" title="reverse —— 翻转"></a>reverse —— 翻转</h2><p><strong>时间复杂度：</strong> O(N)</p><blockquote><p>对序列进行前后翻转，包含在头文件 <code>#include &lt;algorithm&gt;</code> 中。</p></blockquote><blockquote><p>  [!NOTE]</p><p>  <strong><code>reverse</code> 函数在解决回文串相关问题格外好用</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">string s = <span class="string">&quot;abcde&quot;</span>;</span><br><span class="line"><span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());<span class="comment">//对 s 进行翻转</span></span><br><span class="line">cout &lt;&lt; s &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;<span class="comment">//edcba</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对 a 数组进行翻转</span></span><br><span class="line"><span class="type">int</span> a[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="built_in">reverse</span>(a, a + <span class="number">4</span>);</span><br><span class="line">cout &lt;&lt; a[<span class="number">0</span>] &lt;&lt; a[<span class="number">1</span>] &lt;&lt; a[<span class="number">2</span>] &lt;&lt; a[<span class="number">3</span>];<span class="comment">//4321</span></span><br></pre></td></tr></table></figure><h2 id="getline-istringstream-——-读取一行-对字符串流进行分割"><a href="#getline-istringstream-——-读取一行-对字符串流进行分割" class="headerlink" title="getline + istringstream —— 读取一行&#x2F;对字符串流进行分割"></a>getline + istringstream —— 读取一行&#x2F;对字符串流进行分割</h2><blockquote><p><strong>时间复杂度： O(n)头文件：<string> (getline)，<sstream> （istringstream）</strong></p></blockquote><blockquote><p>读取一行（包括空格），搭配 <code>istringstream </code> 实现分割处理</p><ul><li><code>getline</code>(输入流, 变量); → 读取整行</li><li><code>istringstream</code>(字符串变量); → 把字符串当作输入流</li><li><code>getline</code>(字符串流, 变量, 分隔符); → 按分隔符拆分数据</li><li><code>while </code>(字符串流 &gt;&gt; 变量) → 按空格拆分数据</li></ul><p><code>istringstream </code> 用于把字符串当作输入流；<code>getline </code> 用于按分隔符拆分数据；<code>while </code> 循环用于按空格拆分数据。</p><p>快速记忆：<code>getline</code>(字符串流, 变量, 分隔符); → <code>getline</code> 用于读取一整行包括空格，默认（指定分割符）直到遇到换行符（换行符会被丢弃，不存入变量）才结束。如果指定了分隔符，则会读取到 分隔符 为止（即分隔符的前一个位置，分隔符也会被丢弃，不存入变量），读取的部分会被存储在指定的变量中，而分隔符本身不会被包含在结果中。然后，剩余的部分（分隔符后的字符）会留在输入流中，为下一次读取做准备。下一次调用 <code>getline</code> 会继续从流中读取，直到遇到下一个分隔符或者行结束为止。这个过程会一直继续，直到所有需要的数据都被提取出来。</p></blockquote><blockquote><p>  [!IMPORTANT]</p><p>  <code>cin</code> 不能读取换行&#x2F;回车，所以如果在 <code>getline</code> 之前使用了 <code>cin</code>（ 混合输入），那么 <code>getline</code> 实际读取到的是换行&#x2F;回车，就无法正确读入数据，很多时候就是因为这个原因导致程序出错！常用解决方法：当使用了这样的混合输入必须要在 <code>cin</code> 和 <code>getline</code> 之间写上 <strong><code>getchar();</code> 或者 <code>cin.ignore();</code> 来清除输入缓冲区中的换行符！</strong> 例子：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="comment">// 清除输入缓冲区中的换行符（任选其一）</span></span><br><span class="line"><span class="comment">// getchar();</span></span><br><span class="line">cin.<span class="built_in">ignore</span>();</span><br><span class="line"></span><br><span class="line">string s;</span><br><span class="line"><span class="built_in">getline</span>(cin, s);</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span>                   <span class="comment">// 包含 getline</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span>                  <span class="comment">// 包含 stringstream</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 示例 1：输入 &quot;YYYY-MM-DD&quot;，输出 &quot;YYYY/MM/DD&quot;</span></span><br><span class="line">    string year, month, day;</span><br><span class="line">    <span class="built_in">getline</span>(cin, year, <span class="string">&#x27;-&#x27;</span>);        <span class="comment">// 读取到第一个 &#x27;-&#x27; 为止</span></span><br><span class="line">    <span class="built_in">getline</span>(cin, month, <span class="string">&#x27;-&#x27;</span>);       <span class="comment">// 继续读取到下一个 &#x27;-&#x27;</span></span><br><span class="line">    <span class="built_in">getline</span>(cin, day);              <span class="comment">// 读取剩余部分（默认到行尾）</span></span><br><span class="line">    cout &lt;&lt; year &lt;&lt; <span class="string">&quot;/&quot;</span> &lt;&lt; month &lt;&lt; <span class="string">&quot;/&quot;</span> &lt;&lt; day &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 示例 2：按空格拆分 &quot;42 3.14 hello&quot;</span></span><br><span class="line">    string data = <span class="string">&quot;42 3.14 hello&quot;</span>;</span><br><span class="line">    <span class="function">istringstream <span class="title">iss</span><span class="params">(data)</span></span>;        <span class="comment">// 将字符串转为流</span></span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="type">double</span> pi;</span><br><span class="line">    string word;</span><br><span class="line">    iss &gt;&gt; num &gt;&gt; pi &gt;&gt; word;       <span class="comment">// 按空格提取</span></span><br><span class="line">    cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; pi &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; word &lt;&lt; endl;    <span class="comment">// 输出: 42 3.14 hello</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 示例 3：按逗号拆分 CSV 数据 &quot;apple, orange, banana&quot;</span></span><br><span class="line">    string csv = <span class="string">&quot;apple,orange,banana&quot;</span>;</span><br><span class="line">    <span class="function">istringstream <span class="title">iss_csv</span><span class="params">(csv)</span></span>;</span><br><span class="line">    string fruit;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">getline</span>(iss_csv, fruit, <span class="string">&#x27;,&#x27;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; fruit &lt;&lt; <span class="string">&quot; &quot;</span>;       <span class="comment">// 输出: apple orange banana</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 示例 4：逐行处理输入（如文件或控制台）</span></span><br><span class="line">    string line;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">getline</span>(cin, line))      <span class="comment">// 每次读取一行</span></span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="function">istringstream <span class="title">ss</span><span class="params">(line)</span></span>;</span><br><span class="line">        string token;</span><br><span class="line">        <span class="keyword">while</span> (ss &gt;&gt; token)</span><br><span class="line">        &#123;     </span><br><span class="line">            cout &lt;&lt; token &lt;&lt; <span class="string">&quot; &quot;</span>;   <span class="comment">// 按空格拆分每行</span></span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="set-union-set-intersection-set-difference-——-交并差集"><a href="#set-union-set-intersection-set-difference-——-交并差集" class="headerlink" title="set_union, set_intersection, set_difference —— 交并差集"></a>set_union, set_intersection, set_difference —— 交并差集</h2><p>复杂度： O(N+M)</p><blockquote><p>求两个集合的并集，交集，差集。手动实现双指针就可以搞定，嫌麻烦可以使用该函数。</p></blockquote><table><thead><tr><th>函数</th><th>作用</th><th>说明</th></tr></thead><tbody><tr><td><code>set_union</code></td><td>并集</td><td>两个集合所有元素（去重）</td></tr><tr><td><code>set_intersection</code></td><td>交集</td><td>两个集合共同的元素</td></tr><tr><td><code>set_difference</code></td><td>差集</td><td>第一个集合有而第二个集合没有的元素</td></tr></tbody></table><p><strong>注意：</strong></p><ul><li><strong>必须有序（sorted），但不强制升序或降序。</strong></li><li><strong>只要两个输入区间是按照相同的排序规则（比如都是升序、或者都是降序）排好的，就可以正常使用。</strong></li></ul><p>两个集合 <strong>必须为有序集合</strong>，所以下面演示代码使用了排序。<code>vector</code> 容器可以替换成 <code>set</code> 容器，因为 <code>set</code> 自动会对元素进行排序。函数的参数有五个，前两个为第一个容器的首尾迭代器，第三四个为第二个容器的首尾迭代器，最后一个为插入位置，即将结果插入到哪个地址之后。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span><span class="comment">// 头文件</span></span></span><br><span class="line"><span class="built_in">set_union</span>(起始迭代器<span class="number">1</span>, 结束迭代器<span class="number">1</span>, 起始迭代器<span class="number">2</span>, 结束迭代器<span class="number">2</span>, 输出迭代器);</span><br><span class="line"><span class="built_in">set_intersection</span>(起始迭代器<span class="number">1</span>, 结束迭代器<span class="number">1</span>, 起始迭代器<span class="number">2</span>, 结束迭代器<span class="number">2</span>, 输出迭代器);</span><br><span class="line"><span class="built_in">set_difference</span>(起始迭代器<span class="number">1</span>, 结束迭代器<span class="number">1</span>, 起始迭代器<span class="number">2</span>, 结束迭代器<span class="number">2</span>, 输出迭代器);</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">8</span>&#125;, b = &#123;<span class="number">5</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="built_in">sort</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>()); <span class="comment">// 1 2 4 5 8</span></span><br><span class="line"><span class="built_in">sort</span>(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>()); <span class="comment">// 2 3 5 8 9</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; c, d, e;</span><br><span class="line"><span class="comment">// a 并 b：1 2 3 4 5 8 9</span></span><br><span class="line"><span class="built_in">set_union</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>(), <span class="built_in">inserter</span>(c, c.<span class="built_in">begin</span>()));</span><br><span class="line"><span class="comment">// a 交 b：2 5 8</span></span><br><span class="line"><span class="built_in">set_intersection</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>(), <span class="built_in">inserter</span>(d, d.<span class="built_in">begin</span>()));</span><br><span class="line"><span class="comment">// a 差 b： 1 4</span></span><br><span class="line"><span class="built_in">set_difference</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>(), <span class="built_in">inserter</span>(e, e.<span class="built_in">begin</span>()));</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span>                    <span class="comment">// 包含 set_union、set_intersection、set_difference</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span> &#125;;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; b = &#123; <span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span> &#125;;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">Intersection</span><span class="params">(<span class="number">10</span>)</span></span>;       <span class="comment">// 交集，预留足够空间</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">Union</span><span class="params">(<span class="number">10</span>)</span></span>;              <span class="comment">// 并集，预留足够空间</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">Difference</span><span class="params">(<span class="number">10</span>)</span></span>;         <span class="comment">// 差集，预留足够空间</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 求交集</span></span><br><span class="line">    <span class="keyword">auto</span> it1 = <span class="built_in">set_intersection</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>(), Intersection.<span class="built_in">begin</span>());</span><br><span class="line">    Intersection.<span class="built_in">resize</span>(it1 - Intersection.<span class="built_in">begin</span>());    <span class="comment">// 调整交集实际大小</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 求并集</span></span><br><span class="line">    <span class="keyword">auto</span> it2 = <span class="built_in">set_union</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>(), Union.<span class="built_in">begin</span>());</span><br><span class="line">    Union.<span class="built_in">resize</span>(it2 - Union.<span class="built_in">begin</span>());                  <span class="comment">// 调整并集实际大小</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 求差集</span></span><br><span class="line">    <span class="keyword">auto</span> it3 = <span class="built_in">set_difference</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>(), Difference.<span class="built_in">begin</span>());</span><br><span class="line">    Difference.<span class="built_in">resize</span>(it3 - Difference.<span class="built_in">begin</span>());        <span class="comment">// 调整差集实际大小</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出交集</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : Intersection)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">// 输出交集元素 3</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出并集</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : Union)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">// 输出并集元素 1 2 3 5 6</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出差集</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : Difference)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">// 输出差集元素 1 5</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="back-inserter"><a href="#back-inserter" class="headerlink" title="back_inserter"></a>back_inserter</h4><p><code>back_inserter(容器名)</code> 是一个 <strong>生成输出迭代器的小工具</strong>，帮你 <strong>自动在容器尾部插入元素</strong>。<strong>平常如果不用 back_inserter，你需要预先分配好大空间，还要 resize，很麻烦。</strong> 而用 <code>back_inserter</code> 就可以：</p><ul><li>不需要提前开空间！</li><li>自动 <code>push_back</code> 加元素！</li></ul><p><strong>1. 传统写法（需要开大空间）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">result</span><span class="params">(<span class="number">100</span>)</span></span>;  <span class="comment">// 必须提前开好足够空间</span></span><br><span class="line"><span class="keyword">auto</span> it = <span class="built_in">set_union</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>(), result.<span class="built_in">begin</span>());</span><br><span class="line">result.<span class="built_in">resize</span>(it - result.<span class="built_in">begin</span>());  <span class="comment">// 最后再调整大小</span></span><br></pre></td></tr></table></figure><p><strong>2. 使用 back_inserter（最推荐）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; result;  <span class="comment">// 不需要开空间，空的就行</span></span><br><span class="line"><span class="built_in">set_union</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>(), <span class="built_in">back_inserter</span>(result));</span><br><span class="line"><span class="comment">// 不需要 resize，直接用 result 即可</span></span><br></pre></td></tr></table></figure><p>看到了吗？<code>back_inserter</code> 自动帮你扩容，<strong>代码更简洁、安全，强烈推荐使用！</strong></p><h2 id="isdigit、isalpha-——-判断是否是数字-字符"><a href="#isdigit、isalpha-——-判断是否是数字-字符" class="headerlink" title="isdigit、isalpha —— 判断是否是数字&#x2F;字符"></a>isdigit、isalpha —— 判断是否是数字&#x2F;字符</h2><blockquote><p>处于标准库函数（头文件 <code>&lt;cctype&gt;</code>）。正常来说下面前 4 个是较为常用的，记不住也没关系，大多数情况也还是手动实现的。</p></blockquote><table><thead><tr><th>函数名</th><th>作用</th><th>示例输入</th><th>示例输出</th></tr></thead><tbody><tr><td><strong><code>isdigit(c)</code></strong></td><td><strong>判断是否为数字（0~9）</strong></td><td><code>&#39;5&#39;</code></td><td><code>true</code></td></tr><tr><td><strong><code>isalpha(c)</code></strong></td><td><strong>判断是否为字母（A-Z 或 a-z）</strong></td><td><code>&#39;a&#39;</code> &#x2F; <code>&#39;Z&#39;</code></td><td><code>true</code></td></tr><tr><td><strong><code>islower(c)</code></strong></td><td><strong>判断是否为小写字母</strong></td><td><code>&#39;g&#39;</code></td><td><code>true</code></td></tr><tr><td><strong><code>isupper(c)</code></strong></td><td><strong>判断是否为大写字母</strong></td><td><code>&#39;G&#39;</code></td><td><code>true</code></td></tr><tr><td><code>isalnum(c)</code></td><td>判断是否为字母或数字</td><td><code>&#39;a&#39;</code>, <code>&#39;9&#39;</code></td><td><code>true</code></td></tr><tr><td><code>isspace(c)</code></td><td>判断是否为空白字符（空格、\t、\n）</td><td><code>&#39; &#39;</code></td><td><code>true</code></td></tr><tr><td><code>isxdigit(c)</code></td><td>判断是否为十六进制数字（0 <del>9, A</del> F, a~f）</td><td><code>&#39;F&#39;</code></td><td><code>true</code></td></tr><tr><td><code>isprint(c)</code></td><td>判断是否为可打印字符</td><td><code>&#39;!&#39;</code></td><td><code>true</code></td></tr><tr><td><code>ispunct(c)</code></td><td>判断是否为标点符号</td><td><code>&#39;!&#39;</code>, <code>&#39;,&#39;</code></td><td><code>true</code></td></tr><tr><td><code>isgraph(c)</code></td><td>是否为可见字符（不含空格）</td><td><code>&#39;A&#39;</code>, <code>&#39;%&#39;</code></td><td><code>true</code></td></tr></tbody></table><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">my_isdigit</span><span class="params">(<span class="type">char</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>;            <span class="comment">// 判断是否为数字字符（ASCII: 48~57）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">my_isalpha</span><span class="params">(<span class="type">char</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (c &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;z&#x27;</span>) || (c &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;Z&#x27;</span>);    <span class="comment">// 判断是否为字母（大写或小写，ASCII: a~z: 97~122, A~Z: 65~90）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">my_islower</span><span class="params">(<span class="type">char</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;z&#x27;</span>;            <span class="comment">// 判断是否为小写字母</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">my_isupper</span><span class="params">(<span class="type">char</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;Z&#x27;</span>;            <span class="comment">// 判断是否为大写字母</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="gcd-——-最大公约数，lcm-——-最小公倍数"><a href="#gcd-——-最大公约数，lcm-——-最小公倍数" class="headerlink" title="gcd —— 最大公约数，lcm —— 最小公倍数"></a>gcd —— 最大公约数，lcm —— 最小公倍数</h2><table><thead><tr><th>名称</th><th>所属</th><th>是否标准</th><th>头文件</th><th>支持类型</th><th>特点说明</th></tr></thead><tbody><tr><td><code>std::gcd</code></td><td>C++17 标准库</td><td>✅ 是</td><td><code>&lt;numeric&gt;</code></td><td><code>int</code>、<code>long long</code> 等整数</td><td>类型安全，支持 <code>constexpr</code>，推荐使用于现代 C++</td></tr><tr><td><code>std::lcm</code></td><td>C++17 标准库</td><td>✅ 是</td><td><code>&lt;numeric&gt;</code></td><td><code>int</code>、<code>long long</code> 等整数</td><td>求最小公倍数，现代推荐方式</td></tr><tr><td><code>__gcd</code></td><td>GNU 扩展</td><td>❌ 否</td><td><code>&lt;algorithm&gt;</code></td><td>原始定义只明确支持 <code>int</code> 类型，后续做了处理，可以接受 <code>long</code>、<code>long long</code> 等整型参数，但仍有部分编译器不支持！</td><td>GCC 特有，非标准函数，竞赛中常用</td></tr></tbody></table><blockquote><p>C++17 引入，头文件：<code>#include &lt;numeric&gt; </code></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">24</span>, b = <span class="number">64</span>;</span><br><span class="line">cout &lt;&lt; <span class="built_in">gcd</span>(a, b) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="built_in">lcm</span>(a, b) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">如果环境不支持，可以手动实现其两者功能：</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b == <span class="number">0</span> ? a : <span class="built_in">gcd</span>(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lcm</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a * b) / <span class="built_in">gcd</span>(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="gcd-——-最大公约数"><a href="#gcd-——-最大公约数" class="headerlink" title="__gcd —— 最大公约数"></a>__gcd —— 最大公约数</h3><blockquote><p>求 a 和 b 的最大公约数，使用时要包含 <code>&lt;algorithm&gt;</code> 头文件。准确的来说它是一个 <code>GNU</code> 扩展，不属于 <code>STL</code>。</p></blockquote><p><code>__gcd(12,15) = 3</code></p><p><code>__gcd(21,0) = 21</code></p><h2 id="lg"><a href="#lg" class="headerlink" title="__lg"></a>__lg</h2><blockquote><ol><li>求一个数二进制下最高位位于第几位（从 <strong>第 0 位</strong> 开始）（或二进制数下有几位）</li><li><code>__lg(x)</code> 相当于返回 $log_2 x$</li><li>复杂度 O(1)</li></ol></blockquote><p><code>__lg(8) = 3</code></p><p><code>__lg(15) = 3</code></p><h2 id="accumulate-——-序列求和"><a href="#accumulate-——-序列求和" class="headerlink" title="accumulate —— 序列求和"></a>accumulate —— 序列求和</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">accumulate</span>(beg, end, init)</span><br></pre></td></tr></table></figure><p><strong>复杂度：</strong> O(N)</p><blockquote><p>作用：对一个序列的元素求和</p></blockquote><p><code>init</code> 为对序列元素求和的 <strong>初始值</strong></p><p>返回值类型：与 <code>init</code> 相同</p><ul><li><strong>基础累加求和：</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[]=&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">10</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对 [0,2] 区间求和，初始值为 0，结果为 0 + 1 + 3 + 5 = 9</span></span><br><span class="line"><span class="type">int</span> res1 = <span class="built_in">accumulate</span>(a, a + <span class="number">3</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//对 [0,3] 区间求和，初始值为 5，结果为 5 + 1 + 3 + 5 + 9 = 23</span></span><br><span class="line"><span class="type">int</span> res2 = <span class="built_in">accumulate</span>(a, a + <span class="number">4</span>, <span class="number">5</span>);</span><br></pre></td></tr></table></figure><ul><li><strong>自定义二元对象求和：</strong></li></ul><p>使用 <code>lambda</code> 表达式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    ll num;</span><br><span class="line">&#125; st[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">st[i].num = i + <span class="number">10000000000</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回值类型与 init 一致，同时注意参数类型（a）也要一样</span></span><br><span class="line"><span class="comment">//初始值为 1，累加 1+10000000001+10000000002+10000000003 = 30000000007</span></span><br><span class="line">ll res = <span class="built_in">accumulate</span>(st + <span class="number">1</span>, st + <span class="number">4</span>, <span class="number">1ll</span>, [](ll a,node b) &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b.num;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="ceil-——-向上取整"><a href="#ceil-——-向上取整" class="headerlink" title="ceil —— 向上取整"></a><code>ceil</code> —— 向上取整</h2><blockquote><p>头文件：<code>&lt;cmath&gt;</code>&#x2F;<code>&lt;math.h&gt;</code>。</p><p><code>ceil</code> 函数的功能是返回不小于给定参数 <code>x</code> 的最小整数，也就是我们所说的 <strong>向上取整</strong>。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">ceil</span><span class="params">(<span class="type">double</span> x)</span></span>;</span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">ceil</span><span class="params">(<span class="type">float</span> x)</span></span>;                    <span class="comment">// C++ 中新增的重载版本</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">double</span> <span class="title">ceil</span><span class="params">(<span class="type">long</span> <span class="type">double</span> x)</span></span>;        <span class="comment">// C++ 中新增的重载版本</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span>                        <span class="comment">// 包含了 ceil 函数的头文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">ceil</span>(a) &lt;&lt; endl;            <span class="comment">// 输出 1</span></span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> b = <span class="number">2.5</span>;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">ceil</span>(b) &lt;&lt; endl;            <span class="comment">// 输出 3</span></span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> c = <span class="number">-2.4</span>;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">ceil</span>(c) &lt;&lt; endl;            <span class="comment">// 输出 -2</span></span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="type">double</span> d = <span class="number">3.1415926</span>;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">ceil</span>(d) &lt;&lt; endl;            <span class="comment">// 输出 4</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="fill"><a href="#fill" class="headerlink" title="fill"></a>fill</h2><p><strong>复杂度：</strong> O(N)O(N)</p><blockquote><p>对一个序列进行初始化赋值</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对 a 数组的所有元素赋 1</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">5</span>];</span><br><span class="line"><span class="built_in">fill</span>(a, a + <span class="number">5</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1 1 1 1 1</span></span><br></pre></td></tr></table></figure><p>注意区分 memset：</p><p><code>memset()</code> 是按 <strong>字节</strong> 进行赋值，对于初始化赋 <code>0</code> 或 <code>-1</code> 有比较好的效果.</p><p>如果赋某个特定的数会 <strong>出错</strong>，赋值特定的数建议使用 <code>fill()</code>。</p><h2 id="next-permutation"><a href="#next-permutation" class="headerlink" title="next_permutation"></a>next_permutation</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">next_permutation</span>(beg, end)</span><br></pre></td></tr></table></figure><p><strong>时间复杂度：</strong> O(N)</p><blockquote><p>求序列的下一个排列，下一个排列是字典序大一号的排列</p></blockquote><p>返回 <code>true</code> 或 <code>false</code></p><ul><li><p><code>next_permutation(beg, end)</code></p><p>  如果是最后一个排列，返回 <code>false</code>, 否则求出下一个序列后，返回 <code>true</code></p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对 a 序列进行重排</span></span><br><span class="line"><span class="built_in">next_permutation</span>(a, a + n);</span><br></pre></td></tr></table></figure><p><strong>应用：求所有的排列</strong></p><p>输出 <code>a</code> 的所有排列</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组 a 不一定是最小字典序序列，一定注意将它排序</span></span><br><span class="line"><span class="built_in">sort</span>(a, a + n);</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i]);</span><br><span class="line"> &#125;</span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="built_in">next_permutation</span>(a, a + n));</span><br></pre></td></tr></table></figure><ul><li><code>prev_permutation(beg, end)</code></li></ul><blockquote><p>求出前一个排列，如果序列为最小的排列，将其重排为最大的排列，返回 false。</p></blockquote><h2 id="random-shuffle"><a href="#random-shuffle" class="headerlink" title="random_shuffle"></a>random_shuffle</h2><p><strong>复杂度：</strong> O(N)</p><blockquote><ol><li>随机打乱序列的顺序</li><li><code>random_shuffle</code> 在 <code>C++14</code> 中被弃用，在 <code>C++17</code> 中被废除，C++11 之后应尽量使用 <code>shuffle</code> 来代替。</li></ol></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">b</span><span class="params">(n)</span></span>;</span><br><span class="line"><span class="built_in">iota</span>(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>(), <span class="number">1</span>);<span class="comment">// 序列 b 递增赋值 1, 2, 3, 4,...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对 a 数组随机重排</span></span><br><span class="line"><span class="built_in">random_shuffle</span>(a, a + n);</span><br><span class="line"></span><br><span class="line"><span class="comment">// C++11 之后尽量使用 shuffle</span></span><br><span class="line"><span class="built_in">shuffle</span>(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure><h2 id="transform"><a href="#transform" class="headerlink" title="transform"></a>transform</h2><p><strong>复杂度：</strong> O(N)</p><blockquote><p>作用：使用给定操作，将结果写到 dest 中</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原型：</span></span><br><span class="line"><span class="built_in">transform</span>(beg, end, dest, unaryOp);</span><br></pre></td></tr></table></figure><p>一般不怎么使用，徒增记忆负担，不如手动实现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将序列开始地址 beg 到结束地址 end 大小写转换，把结果存到起始地址为 dest 的序列中</span></span><br><span class="line"><span class="built_in">transform</span>(beg, end, dest, ::tolower);</span><br><span class="line"><span class="built_in">transform</span>(beg, end, dest, ::toupper);</span><br></pre></td></tr></table></figure><h2 id="unique"><a href="#unique" class="headerlink" title="unique"></a>unique</h2><p><strong>复杂度：</strong> O(N)</p><blockquote><p>消除重复元素，返回消除完重复元素的下一个位置的地址</p><p>如：<code>a[] = &#123;1, 3, 2, 3, 6&#125;</code>;</p><p><code>unique</code> 之后 <code>a</code> 数组为 <code>&#123;1, 2, 3, 6, 3&#125;</code> 前面为无重复元素的数组，后面则是重复元素移到后面，返回 <code>a[4]</code> 位置的地址（不重复元素的尾后地址）</p></blockquote><p>消除重复元素一般需要原序列是 <strong>有序序列</strong></p><p><strong>应用：离散化</strong></p><ul><li>方法一：利用数组离散化</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    cin &gt;&gt; a[i];</span><br><span class="line">    b[i] = a[i];                    <span class="comment">//将 a 数组复制到 b 数组</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 排序后 b：&#123;1, 2, 3, 3, 6&#125;</span></span><br><span class="line"><span class="built_in">sort</span>(b, b + n);                     <span class="comment">//对 b 数组排序</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 消除重复元素 b：&#123;1, 2, 3, 6, 3&#125; 返回的地址为最后一个元素 3 的地址 </span></span><br><span class="line"><span class="type">int</span> len = <span class="built_in">unique</span>(b, b + n) - b;     <span class="comment">//消除 b 的重复元素，并获取长度</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//因为 b 有序，查找到的下标就是对应的 相对大小（离散化后的值）</span></span><br><span class="line">    <span class="type">int</span> pos = <span class="built_in">lower_bound</span>(b, b + len, a[i]) - b;        <span class="comment">//在 b 数组中二分查找第一个大于等于 a [i] 的下标</span></span><br><span class="line">    a[i] = pos;                     <span class="comment">// 离散化赋值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>方法二：利用 <code>vector</code> 进行离散化</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    cin &gt;&gt; a[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; b = a;</span><br><span class="line"><span class="built_in">sort</span>(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>());</span><br><span class="line">b.<span class="built_in">erase</span>(<span class="built_in">unique</span>(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>()), b.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">a[i] = <span class="built_in">lower_bound</span>(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>(), a[i]) - b.<span class="built_in">begin</span>() + <span class="number">1</span>; <span class="comment">// 离散后的数据从 1 开始   </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="builtin-内置位运算函数"><a href="#builtin-内置位运算函数" class="headerlink" title="__builtin_ 内置位运算函数"></a><code>__builtin_</code> 内置位运算函数</h2><blockquote><p>需要注意：内置函数有相应的 <code>unsigned lnt</code> 和 <code>unsigned long long</code> 版本，<code>unsigned long long</code> 只需要在函数名后面加上 <code>ll</code> 就可以了，比如 <code>__builtin_clzll(x)</code> ，默认是 32 位 <code>unsigned int</code></p><p>很多题目和 <code>long long</code> 数据类型有关，如有需要注意添加 <code>ll</code></p></blockquote><ul><li><code>__builtin_ffs</code></li></ul><blockquote><p>二进制中对应最后一位 <code>1</code> 的位数，比如 <code>4</code> 会返回 <code>3</code>（100）</p></blockquote><ul><li><code>__builtin_popcount</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__builtin_popcount(x)</span><br></pre></td></tr></table></figure><blockquote><p><code>x</code> 中 <code>1</code> 的个数</p></blockquote><ul><li><code>__builtin_ctz</code></li></ul><blockquote><p><code>x</code> 末尾 <code>0</code> 的个数（<code>count tail zero</code>）</p></blockquote><ul><li><code>__builtin_clz</code></li></ul><blockquote><p><code>x</code> 前导 <code>0</code> 的个数（<code>count leading zero</code>）</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; __builtin_clz(<span class="number">32</span>); <span class="comment">// 26</span></span><br><span class="line"><span class="comment">//因为共有 6 位, 默认数据范围为 32 位，32 - 6 = 26</span></span><br></pre></td></tr></table></figure><ul><li><code>__builtin_parity</code></li></ul><blockquote><p><code>x</code> 中 1 的个数的奇偶性， 奇数输出 <code>1</code>，偶数输出 <code>0</code></p></blockquote><h2 id="C-20-ranges"><a href="#C-20-ranges" class="headerlink" title="C++20 ranges"></a>C++20 ranges</h2><p>ranges 主要用来简化迭代器操作，可以少写很多迭代器操作相关的代码。<br>ranges 集成了很多 STL 函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ranges::<span class="built_in">sort</span>(a); <span class="comment">// sort(a.begin(), a.end());</span></span><br><span class="line">ranges::<span class="built_in">sort</span>(a, <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());  <span class="comment">// sort(a.begin(), a.end(), greater &lt;int&gt;());</span></span><br><span class="line"><span class="type">int</span> mx = *ranges::<span class="built_in">max_element</span>(a);</span><br><span class="line"><span class="type">int</span> mn = *ranges::<span class="built_in">min_element</span>(a);</span><br></pre></td></tr></table></figure><blockquote><p>可参考链接：</p><ol><li><a href="https://www.luogu.com.cn/blog/AccRobin/grammar-candies">C++语法糖</a> <a href="https://www.luogu.com.cn/blog/AccRobin/grammar-candies">https://www.luogu.com.cn/blog/AccRobin/grammar-candies</a></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>“一周年”，我的成长蜕变与收获</title>
      <link href="/posts/57061.html"/>
      <url>/posts/57061.html</url>
      
        <content type="html"><![CDATA[<h1 id="“一周年”，我的成长蜕变与收获"><a href="#“一周年”，我的成长蜕变与收获" class="headerlink" title="“一周年”，我的成长蜕变与收获"></a>“一周年”，我的成长蜕变与收获</h1><blockquote><p>今天是 2025 年 5 月 22 日，一个值得纪念的日子 —— 一年前的今天，我毅然选择报班学习，踏上了改变命运的征程。在这一年里，我经历了从迷茫到觉醒的成长蜕变，踩过无数坑后总结出血泪教训，也收获了宝贵的心得与经验。这篇文章分成三个部分展开：我的成长故事、大学避坑指南，以及成长心得分享与总结。</p></blockquote><h2 id="1-初入象牙塔：从志愿时长-100-到迷茫的“闲鱼”生活"><a href="#1-初入象牙塔：从志愿时长-100-到迷茫的“闲鱼”生活" class="headerlink" title="1. 初入象牙塔：从志愿时长 100+到迷茫的“闲鱼”生活"></a>1. 初入象牙塔：从志愿时长 100+到迷茫的“闲鱼”生活</h2><p>我来到大学的日子是 2023 年 8 月 26 日，那时候真的是天真得不行，时间也多得用不完。每天就是老老实实去上课，下课后就呆在宿舍玩一玩，偶尔出去搞点志愿活动，对了，当时我加入了青年志愿者社团，短短小半年时间，志愿时长已经有 100 多小时了。有时候也会去打打球，放松一下。可是这样的生活让我渐渐觉得很乏味，也不能说是乏味吧，就觉得有点没劲，也不能完全说是没劲，就是感觉如果一直这么混下去，以后会一事无成，沦落到街头混饭吃。所以，我就萌生了做点什么事情挣点钱，当时的想法很简单，就是赚点小钱补贴生活费，顺便也为以后谋生攒点经验。</p><h2 id="2-搞钱初体验：从线上“搬砖”到被坑到“怀疑人生”"><a href="#2-搞钱初体验：从线上“搬砖”到被坑到“怀疑人生”" class="headerlink" title="2. 搞钱初体验：从线上“搬砖”到被坑到“怀疑人生”"></a>2. 搞钱初体验：从线上“搬砖”到被坑到“怀疑人生”</h2><p>于是，我就一头扎进了挣钱的路子。初期什么都不了解，没人带我，也没有门道，只能自己胡乱的摸索，上网到处找点门道。从最开始试着做线上任务，一块两块地挣，麻烦不说，还贼繁琐，赚的那点钱连一顿饭都不够。后来又跑去知乎写文章，想靠流量挣钱，结果可想而知，惨败收场，总共才弄到不到 50 米。沉默了一段时间，在校园墙上看到了一些代课、写作业或者完成任务的信息，我二话不说果断就去了，结果呢？累得要死不说，还遇到跑路的和挨骂的 😭，真是气得我整个人都不好了。</p><h2 id="3-误入“传销”工作室：那些年我们差点交的智商税"><a href="#3-误入“传销”工作室：那些年我们差点交的智商税" class="headerlink" title="3. 误入“传销”工作室：那些年我们差点交的智商税"></a>3. 误入“传销”工作室：那些年我们差点交的智商税</h2><p>再后来，我听说有个校园业务的工作室，还是一样果断跑去尝试，结果只能说——“传销的味儿太重了”。我半信半疑地听着，期间那个工作室的“老大”掏出一堆证，四六级、营业执照、心理咨询师（听说是中科院心理所才能发）啥的，说随便啥证都能直接办下来，还在那儿一顿胡吹海吹。我心里不由得冷笑，这东西一看就是假的，国家颁发到你这就这么容易？这事儿也就这么不了了之了。直到小半年后，一次碰巧偶遇了那个工作室的一个成员，才知道真相：他们“老大”寒假忽悠大家进厂干活，说是高薪，结果被抽成抽到时薪连 10 米都不到，其他校园业务也是充满欺骗，加入还得交 1000 米的入会费……最后这位老大被其他成员联手踢了出去，好像又因为挂科太多等原因退学了，活该！</p><h2 id="4-创业记：从个人创业的短暂尝试到“送货上门”的无奈停业"><a href="#4-创业记：从个人创业的短暂尝试到“送货上门”的无奈停业" class="headerlink" title="4. 创业记：从个人创业的短暂尝试到“送货上门”的无奈停业"></a>4. 创业记：从个人创业的短暂尝试到“送货上门”的无奈停业</h2><p>那时候的我正在搞点知识付费、人工代跑、小说推文（这个是真能挣点米，推荐有兴趣的朋友可以试试，<strong>方法：微信搜索“青风助手”，can666 这是我的邀请码</strong>，已是 180+ 人的“团队”，只需要剪剪视频，我的收入也有小几百，当然需要坚持，这是一个从难到简的过程）、流量卡啥的“小生意”，零零散散混着。后来结识了双创主席，开始做宿舍小卖铺。大学嘛，不就是要敢想敢干！拉上一个舍友一起合伙，去城里批发市场跟人谈价钱，最后宿舍小卖铺也是成功开起来了，学校物价很贵，我们凭借偏低的物价和“送货上门”也是小挣了几百，尝到甜头了。可惜好景不长，合伙的舍友后来迷上了打球，退出了，我呢，又因为课程繁忙，精力有限，难以独自支撑整个小卖部的运营，最终只能无奈地按下了暂停键，这段创业尝试也就草草收场了。</p><h2 id="5-觉醒时刻：从知识星球到狠心报班的“破釜沉舟”"><a href="#5-觉醒时刻：从知识星球到狠心报班的“破釜沉舟”" class="headerlink" title="5. 觉醒时刻：从知识星球到狠心报班的“破釜沉舟”"></a>5. 觉醒时刻：从知识星球到狠心报班的“破釜沉舟”</h2><p>再到后来，觉得一事无成、很失败，陷入无限焦虑中。那段时间非常压抑，最后我决定：得好好学习，卷技术。其实从进入大学以来，就有一直好好学习，可能有点高中的行为和思维固化，只知道跟着老师走，当时也会偶尔课外学一点编程，现在看来不过是浪费时间，实际没学到多少东西。大一各科成绩一直挺靠前，总成绩在班里排第三。说到编程技术，我只有点课堂上学的皮毛，啥也不会。可能是突然开窍了，也可能是命运推了我一把，我开始上网自学技术。刚开始学得稀稀拉拉，没啥进展，后来在哔哩哔哩刷到了一个 C 语言课程，一开始我对这个课完全没兴趣，画面是画图板加真人讲解，视频时长还很长，由于之前刷到过那种动画讲编程的视频，下意识就觉得动画讲有意思、容易理解，不太喜这种类似课堂的讲解。好巧不巧，视频下面有个知识星球的社群链接，想着进去看看，结果就像打开了潘多拉魔盒，一发不可收拾。里面都是一些正在努力的大学生，有很多“大佬”问着我看不懂的问题，也有着和我一样的萌新，来寻求人生方向和发问编程问题的人，清晰记得有一条发文说有人已经将所学运用开始接单挣钱了，剩下还有一些学长分享的 offer 经历，这更坚定了我要学技术的信心。瞬间感觉志同道合，找到了组织！</p><p>到了 2024 年 5 月 17 日，我开始正式深入了解。一开始还是有点半信半疑，各种问题抛出去一一得到解答，到后来的一句“有内推、包就业”，当时不知道内推是什么意思，以为是什么内部渠道，就觉得很高大上，其实不然，而包就业则是一直服务到就业，但那时候就觉得很牛逼。我直接就狠下心来和父母说了这件事，结果交谈并不那么顺利，他们不太支持。我呢也就没有再多说，毕竟命运是掌握在自己手中的！于是用自己不多的家底在 2024.5.22 报了班，开始我默默努力学习的道路，将来发达了，我会证明我的选择是正确的，不发达就当没干过 🤣。</p><blockquote><p>同步时间，2024.5.17 这几天学校举行了程序设计校赛（具体时间记不清了），凭借我之前学到的一些知识，也是拿到了一个个位名次，成功进入 517 算法实验室，后来才知道这场校赛是为 ACM 校队纳新的，我也是成功成为了校队的一名新成员，同时走上了我的算法竞赛之路……</p></blockquote><p>我相信，2024 年 5 月 22 日，命运的齿轮，就从这一刻开始转动……</p><blockquote><p>后来的一年里，我基本上是在实验室中度过的，没课就基本呆在实验室，我见过实验室人满为患的样子，也见过假期和晚上 11 点钟稀稀疏疏的人影。这一年，我远离了吵闹的宿舍，远离了爱打游戏、摆烂的舍友，远离了各种乱七八糟的社团，放弃了各种部长、班干部、评奖评优的竞选……我感觉后来的这一年过的很快很快，比高中还快，我过的很踏实也很充实，学到了很多、见到了很多、也成长了很多……</p><p>这里着重感谢一下刘*鑫学长，感谢你每次的教导，教我写题、写代码……虽然你每次都说我很笨、很蠢 😂，但我真的很受益！感谢！😘</p></blockquote><hr><h1 id="大学避坑指南：这些坑我替你踩过了！"><a href="#大学避坑指南：这些坑我替你踩过了！" class="headerlink" title="大学避坑指南：这些坑我替你踩过了！"></a>大学避坑指南：这些坑我替你踩过了！</h1><blockquote><p>  [!NOTE]</p><p>  我的大学生活大概是全靠自己去摸索，没有前人的指点和引导，所以吃过很多亏和踩过很多坑，现在总结放在这里，为后来者提供参考，希望后来者的你们可以一步到位，避免重蹈覆辙。</p><p>  <strong>注：下面内容的编排并非绝对遵循时间顺序，仅是大致按照时间发展脉络进行整理。在此，我需要再次郑重声明：脱离具体场景的结论往往是片面且不负责任的，因此以下所有观点和总结，均是基于我本人所处的大学校园环境、个人所见所闻以及亲身经历所提炼出的真实感悟与认知，旨在为读者呈现出更贴合实际、更具参考价值的经验分享，而非放之四海而皆准的绝对真理。仅供参考！</strong></p></blockquote><h2 id="一定要学好英语"><a href="#一定要学好英语" class="headerlink" title="一定要学好英语!!!"></a>一定要学好英语!!!</h2><p>我的英语很差，这主要就要从小学说起了，小学不知从哪里听到“我是中国人，不需学外国文”等类似的话，于是我也就盲目跟风不学英语，后来发现只有我把这句话当真了，到了初高中都会有老师给出了希望，两次都是信心满满的去尝试将英语捡起，奈何基础太差跟不上老师上课节奏，换来失败，直到大学学计算机，才知道英语的重要性，不要说什么可以用拼音！为什么？因为有些命名稍长，拼音的长度就跟指数一样上去了，另外拼音不利于阅读，在团队的项目中大家统一都用英语，谁会想要去读你的拼音？而且用拼音不利于代码维护，再者就很 low。</p><p>有人问，那你现在学英语嘛？准备过四六级嘛？我的回答是学，但肯定是不能从 0 基础开始，我的时间好像不太充裕了（这里指的是毕业前找实习和 offer 之前）。我的英语底子我非常清楚，还是比较有自知之明的，所以我并不打算过四六级（如果后面有机会的话，可能还是会想要试试 🙃）。我认为四六级也只能代表个人英语的相对情况，考证也或多或少存在一些水分，举个例子：<code>ACM-icpc</code> 需要三人组队，题目是英文，历届学长曾找过一个英语专业（四级已过）的学生共同参赛，结果是根本翻译不了一点，看不懂、翻不通。这里只是个例，并不能代表全部，说到底大多数人不可能记得住所有的单词，也会有陌生和忘记的，他也需要去查单词，和我没有太大区别，好吧，我承认区别还是蛮大的，至少我查的会多一点 😭，所以我是面向就业，先专注于就业常用的单词，再去查漏补缺。<strong>这里推荐我的背单词软件——墨墨背单词，以及常用的软件翻译（提升效率）：沉浸式翻译、Sider、谷歌翻译、DeepL 翻译、全局的夸克划词翻译等。</strong> 看来我还是在翻译上下了功夫滴 😁，顺便展示一下我的背单词的成果：</p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Blog/20250520113406396.jpeg" alt="2024 墨墨记忆年度报告"></p><p><strong>总之，英语真的很重要，它应该是一项必备技能！扎实的英语功底一定会为你带来很多便捷！</strong></p><h2 id="学习无用？名校和二本的差距，比想象中更残酷！"><a href="#学习无用？名校和二本的差距，比想象中更残酷！" class="headerlink" title="学习无用？名校和二本的差距，比想象中更残酷！"></a>学习无用？名校和二本的差距，比想象中更残酷！</h2><p>说实话，高中学的“死知识”，但现在我都不知道到有什么用，但是高考成绩是相当重要的！</p><p>正巧，前段时间去西工大打天梯赛，才知道一所好学校的含金量。只知道西工大站地面积大，却不知有那么大，校园的小电驴要骑行近 2 小时才能浏览完其全貌，各种景色和建筑也都是堪称硬核与无法言表的，不知道的还以为是顶级公园 + 一流市中心呢。天梯赛我有幸左右两大西工大护法，我才通过了几个题，他们就已经通过 2&#x2F;3 左右了，压力很大，最后两个大佬也是只有两个题没有做出来，但有步骤分，少说也有 230 分以上（总分 290）。西工大人不仅学习好，而且文明热情。当我问朋友何尊组雕位置时，碰巧被本校学生听到，主动为我们介绍、指路，真是太爱了。现在想想我的学校那都是些什么啊？走在路上全是不文明的行为，不多说懂得都懂。除西工大外（偷偷告诉你，西工大公众号可以直接预约参观哦~），还有还多名校未曾接触，还有很多认知之外的事情……想去吗，得分够啊！所以 <strong>一个好的环境和氛围是靠高考分换来的，你说学习重要吗？</strong></p><p>高中的分很重要，那么大学呢？我不了解像西工大那些名校的相关培养，但是我能保守的说，像二本甚至一些一本，课堂上传授的知识基本上没用，对，你没有听错，就是没用！于我来说，老师讲一个学期的 C 语言（循环、判断、指针、结构体、文件等），我现在 3 天就能学完，甚至还有充足时间用来复习，最关键的是比课堂的更深刻、更深入，毕竟老师可不会讲程序地址空间、内存布局和字节对齐等。<strong>专业课传授的内容远不及企业入门的门槛！</strong> 好在遇到了一个讲的好的数据结构的老师，讲的虽好，但是还是太浅了，而且只有理论，没有实战啥也不是，试问台下能有 5 人能用代码实现吗？讲了一个学期的物理，从来没听过，考试前一天晚上才预习 😏，考试照样七八十分，这就是应试教育。我先声明这没有作弊，也不是老师捞人，是真的“预习”出来的，<strong>传授一下如何突击期末考试：只针对期末考试题型复习，不是学做题方法，而是记做题方法，记做题步骤、顺序、要点，不要问为什么，只要记就行了，记不下来的，背也要背下来，就相当于是一个背模板的过程。</strong></p><p><strong>还有太多难说和说不清的，点到为止吧：学习很重要，学习不一定能改变你的命运，但不学习，你的命运一定不会改变，学习力和学习的能力，永远是成功最关键的因素！</strong></p><h2 id="万能的-B-站大学：更实用的“中国第三大高校”"><a href="#万能的-B-站大学：更实用的“中国第三大高校”" class="headerlink" title="万能的 B 站大学：更实用的“中国第三大高校”"></a>万能的 B 站大学：更实用的“中国第三大高校”</h2><p>众所周知，中国只有三种大学是有用的：985、211 和 B 站大学。在学习的征程中怎么能少得了 B 站这个利器，B 站原名哔哩哔哩，很多人只知道它是一个二次元的领地，殊不知他才是一个真正的学习软件！我大学后才知道 B 站，如果早一点知道，高考少说指定多几十分，多说就不要了（已是过去事 😮‍💨）。</p><p>你想学的这里都有，关键是自己会不会去 B 站的搜索引擎搜索，否则再强大的工具也发挥不出他的作用。赶快把手机上的抖音卸载了吧，投入 B 站的怀抱，反正我从来没刷过抖音，我刷快手 🤣，不过后来也就只剩了一个 B 站，毕竟 B 站也能刷快手、抖音同款 🤣（说笑了，好好学习，不要天天刷视频，<strong>常刷降智，少刷放松</strong>）。</p><h2 id="为什么逃课要趁早？"><a href="#为什么逃课要趁早？" class="headerlink" title="为什么逃课要趁早？"></a>为什么逃课要趁早？</h2><p>我大一很老实，认认真真的上课，认认真真的学习，一节课都没旷，成绩班级前三，但是没什么用（<strong>大部分是水课</strong>）。我同级的朋友大一旷课自学，大二就已经开始找实习、找工作了。再看看我，除了课堂上无用的知识，什么都不会，现在后悔了，大二上才旷了几节课，大二下就全是小班授课，而且上面领导要对学校进行学年考核，抓得更紧了，无奈只能老老实实的上完这无用、枯燥和煎熬的课程。</p><p><strong>所以，旷课要乘早，但是旷课要有意义，不能旷课去玩，而是旷课学习！如果实在旷不了，那就把电脑带进教室，上课随便学点（实测老师的干扰专不下心，建议写博客&#x2F;算法题），正常来说和专业相关的老师不会说什么，但是像数学、政治、英语慎重！切记：在课上自己学自己的就行，不要干扰他人，也不要被干扰，更不要主动去和任课老师说自学的事！！这就像是大学的潜规则，你自己学不学无所谓，但是自己指明了不听课，刁钻的老师就是会不同意，而且可能留下不太好的印象！</strong></p><h2 id="不要贪“机哥”：一年半两次大修的血泪史"><a href="#不要贪“机哥”：一年半两次大修的血泪史" class="headerlink" title="不要贪“机哥”：一年半两次大修的血泪史"></a>不要贪“机哥”：一年半两次大修的血泪史</h2><p>2023 年 10 月入手的机械革命旷世 G16，当时也就是看到了机哥的性价比直接入手，不曾想，时至今日，这台陪伴了我 <strong>一年半的机哥已经经过两次大修了</strong>，第一次是 24 年 6 月，无缘无故电脑风扇狂转不停，返厂维修后直接也是换了硬件，再次拿到手时，电脑的数据已经全没了，摄像头也是莫名检测不到、用不了，而且一个铰链&#x2F;转轴还给干断了，这售后真是牛波一！<code>gitee</code> 的打卡也是断掉了 😭：</p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Blog/20250522104225833.png" alt="image-20250522104218723"></p><p>时间来到 25 年 4 月，机哥又莫名其妙的开不开机到开机进不去系统，期间屏幕也是一直出现闪屏的状况，找到线下的维修店说是系统的原因，需要重做一个系统，但是那家店太黑了，我没同意。回来后，机哥突然能进系统了，检测不到一年的摄像头也是突然正常了，吓得我急忙备份文件……一个即将毕业的学长看了看说，他也是机哥，是机哥的锐龙系列，也有闪屏的情况，据他所说是显卡虚焊。在到后来的一次停电，正用着呢，机哥突然开始闪屏，我也是见怪不怪了，好在只停了一分钟的电，这里看来似乎又和电压不稳有关系。闪屏和系统问题是第二次大修 😡。</p><p><strong>我的机哥除了除了两次大修外，期间也是各种小问题不断，比如莫名的关机、死机、睡死、黑屏、闪屏等问题时有发生。这是我第一次选择机哥也是最后一次 😡！我的感受是除了性价比，什么都差！售后差！质量差！已经准备换了，所以，还没买电脑的朋友建议避雷一下机械革命！</strong></p><h2 id="一定要有一个自己实名长期使用的手机号！校园卡-vs-流量卡，哪个更划算？"><a href="#一定要有一个自己实名长期使用的手机号！校园卡-vs-流量卡，哪个更划算？" class="headerlink" title="一定要有一个自己实名长期使用的手机号！校园卡 vs 流量卡，哪个更划算？"></a>一定要有一个自己实名长期使用的手机号！校园卡 vs 流量卡，哪个更划算？</h2><p>在大学中，用到手机号的场景很多，比如，导员找不到你或是有急事会打电话，需要确保电话畅通；各类竞赛（传智杯、普通话等等）的报名，报名可能需要用手机号注册账号、比赛时间和题目信息会用手机短信通知、预留参赛信息等，需要保证手机通讯和收发验证码正常。下面是最最常用的场景——流量，出门在外，没有流量、上不了网的手机不就成板砖了吗？所以流量也很重要！</p><p>所以，如果有需求的朋友可以从 <a href="https://ym.ksjhaoka.com/?s=Kr8M3NTs212675">官方正规号卡</a> 办理一张大流量卡来应对，我使用的是一张保号套餐和从 <a href="https://ym.ksjhaoka.com/?s=Kr8M3NTs212675">官方正规号卡</a> 办理的大流量卡，两张卡每月只需要贡献 <code>29 + 5</code> 米就有 <code>300+</code> 用不完的流量。</p><h2 id="降噪耳机：大学生活的第一生产力"><a href="#降噪耳机：大学生活的第一生产力" class="headerlink" title="降噪耳机：大学生活的第一生产力"></a>降噪耳机：大学生活的第一生产力</h2><p>在大学，无论什么样的学校，只要你运气不好，就会和不文明、吵闹的人一起度过一段时间，这段时间可能是大学 4 年也可能是一堂课，感受过的朋友一定很煎熬，所以有一个降噪耳机是很必要的！此外如果你想在课堂上自己学，不想被老师的讲话声打扰，降噪耳机就更有存在的必要了！</p><p><strong>降噪耳机怎么选？</strong> 推荐一下我用的：<strong>头戴式用的是 <code>QCY H3</code></strong>，使用体验：价比高、降噪效果好，但是好像使用时间久了，或是被我压过，降噪效果下降了一点，影响不大，有多余预算的建议直接上 <code>Pro</code> 版。如果在外不想使用头戴式，<strong>也可以看看 <code>QCY MeloBuds Pro</code></strong>，使用体验：降噪挺好，虽然不能完全阻挡老师的扩音器，但是放个背景白噪音再看书&#x2F;看课很容易专下心来，降噪不仅将声音降低了，而且感觉说话声变远了整体很不错。<strong>这两款耳机均支持双蓝牙同时连接，价格在 200 以内。如果预算很充足，也可以看看其他高价产品，这里仅是分享，市面上正常降噪也就 <code>50dB</code> 上下，效果分别其实没有特别大，选一款适合自己的才最好，还是建议长期使用的降噪耳机不要吝啬。</strong>（如果 QCY 官方看到请给我打广告费 😂）</p><h2 id="账号管理翻车：不要随意注册莫名网站的莫名账号"><a href="#账号管理翻车：不要随意注册莫名网站的莫名账号" class="headerlink" title="账号管理翻车：不要随意注册莫名网站的莫名账号"></a>账号管理翻车：不要随意注册莫名网站的莫名账号</h2><p>如今我的浏览器记录了 107 个站点和 134 个账密，以前也不知道为什么会去各种站点进行账号注册，导致现在有很多用处不大网站的账号，虽然并不影响日常使用，可能我有强迫症吧，就是不用就不想要这些账号，有相同“强迫症”的朋友一定不要直接注册账号，因为有可能网站 <strong>不支持删除账户</strong>，这里点名一下 C 语言中文网（现在都是跟着视频学习，这个网站基本用不上）和 <code>PTA</code>（程序设计类实验辅助教学平台）等，建议每次对不知名网站先用小号&#x2F;测试号&#x2F;无用号注册，再考虑是否需要注册长期使用的账号。还有一种情况：选择使用 <code>GitHub</code> 登录还是 <strong>谷歌账号</strong> 登录，建议进行统一，账号一多，自己都不知道哪些是 <code>GitHub</code> 登录的还是谷歌登录的。<strong>另外推荐一个好习惯：尽量在确认账号长期使用后，将账号和微信&#x2F;邮箱&#x2F;QQ&#x2F;谷歌&#x2F;GitHub 等进行关联，避免重复或遗忘账号，并且账密做备份，浏览器也好，其他备份也好，总之一定要备份！！</strong></p><p>注：像牛客、力扣、洛谷、PTA、CSDN、gitee、GitHub、蓝桥云客、微软、谷歌等比较知名的直接注册就好，没什么问题，只需要注意一下部分“奇奇怪怪”的站点。</p><h2 id="不推荐盲目打工！"><a href="#不推荐盲目打工！" class="headerlink" title="不推荐盲目打工！"></a>不推荐盲目打工！</h2><p>我用亲身经历告诉你，作为大学生不要盲目去打工，经常就是不讨好，还一肚子气，也别被“大学生整顿职场”误导，现实一定会打破流言蜚语为我证明！“大学生整顿职场”不过是段子，现实的大学生进入职场是真不容易，进去大多是边角料、出气筒，不要说什么特例，说真的，你觉得特例会是自己吗？</p><p>像海底捞、服务员、做奶茶等这些工作没有实际意义，对个人成长帮助微乎甚微（除非经济危机），你应该把这些时间拿去做个人成长，培养一门手艺，精进一门技能，<strong>永远不要为了一时的蝇头小利而错失更大的利益！</strong></p><h2 id="导员一定可信吗？大学里的“善意谎言”！"><a href="#导员一定可信吗？大学里的“善意谎言”！" class="headerlink" title="导员一定可信吗？大学里的“善意谎言”！"></a>导员一定可信吗？大学里的“善意谎言”！</h2><p>那还真不一定！虽然是导员，但是导员也要服从学校的意思，这就会出现善良的导员和学生玩“文字游戏”，不善良的就是直接进行欺骗&#x2F;哄骗。这里就不多说了，大家知道、注意一下！</p><h2 id="校园两大传销：驾校和校园卡，谁在割韭菜？"><a href="#校园两大传销：驾校和校园卡，谁在割韭菜？" class="headerlink" title="校园两大传销：驾校和校园卡，谁在割韭菜？"></a>校园两大传销：驾校和校园卡，谁在割韭菜？</h2><p>我的大学听过的最大的传销就是驾校和校园卡，驾校总是会用各种谎言忽悠着你去报名，然而呢，我们学校的驾校场地小、车少，人却是非常多，这就导致每次去都得要排队，非常麻烦，报名前吹的各种服务，在报名后全都烟消云散，那么多人，谁管得上你对吧？而且对于大学生收费还不低，我们打折后是 <code>3980</code> 米 😲。还有不要通过一些“中间商”去报驾校，据我所知，我们学校这些中间商每介绍一个学员，就有 <code>500</code> 米的介绍费（相当于自己多交的 💴），自己拿着去吃点好、买点好的不香吗？更有介绍到旁边学校里报驾校的，报了之后你就知道，去另一所学校考驾照是有多麻烦！不说其他的，倒闭了自己都不知道！<strong>所以建议要考驾照的朋友慎重考虑！我建议是最好在高考完的暑假快速拿证！如果错过了，就在大学期间挑一个寒暑假去专门考证，不要拖延！尽量在大学毕业前拿下驾照。尽量不要在学校报驾校，直接自己在家附近找或者去外面找，当然，如果你学校驾校很好，当我没说。</strong></p><p>其次就是所谓的校园卡，他们总是会拿着没有校园卡请不了假、抢不了课、进不了教务&#x2F;校园系统等之类的谎言欺骗学生去办卡，据我所知，我们学校的校园卡出了省就用不了了，价格也是高的离谱，毕业时各种理由不让销户，销户还得回学校，真是离了个大谱！我自己在 <a href="https://ym.ksjhaoka.com/?s=Kr8M3NTs212675">官方正规号卡</a> 办的流量卡用着一点问题没有，能抢课也能进教务系统，最重要的是月租 <code>29</code> 米流量用不完，网速嘎嘎快，支持线上销户，就没有那么多麻烦事。<strong>所以建议屏幕前的朋友要小心校园卡刺客。</strong></p><h2 id="不要虚荣奖项，那些“水奖”真的有用吗？"><a href="#不要虚荣奖项，那些“水奖”真的有用吗？" class="headerlink" title="不要虚荣奖项，那些“水奖”真的有用吗？"></a>不要虚荣奖项，那些“水奖”真的有用吗？</h2><p><strong>这里说的是那些不知名、没有实际意义的“奖项”。</strong> 那么什么才算是呢？比如（部分是当时志愿者部长的哄骗与要求）：</p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Blog/20250421223123887.png"></p><p>反正就是 <strong>任何不费吹灰之力就能得到的奖项都没用！</strong> 简单想一下，如果不用努力、不费力气得来的奖项真的有用吗？真的有含金量吗？而且上面这些所谓的奖项已经替你们试过了，学校不认，不能加学分，唯一的作用就是满足自己的虚荣心。</p><h2 id="别等机会敲门，机会不是等来的！"><a href="#别等机会敲门，机会不是等来的！" class="headerlink" title="别等机会敲门，机会不是等来的！"></a>别等机会敲门，机会不是等来的！</h2><p>我见过有些有想法的同学会找到我们的实验室来，可能是纳新和校赛错过了，也可能是压根不知道，不管什么原因，后来这些同学来到实验室就说，“我想做项目，能不能收我”“我会编程，我能进不？”……我很佩服他们自荐的勇气，但是要么是和实验室方向不相关，要么就是基础太差，反正一个也没进来 😮‍💨。</p><p>每个学校或多或少都会有一些实验室&#x2F;工作室，我建议想学的同学可以大胆先去了解，然后提升自己的基本实力，学成归来在大胆的去力荐自己！我认为这种自动去寻找机会和力荐自己的精神很可贵！要学会去尝试！</p><h1 id="成长心得分享与总结"><a href="#成长心得分享与总结" class="headerlink" title="成长心得分享与总结"></a>成长心得分享与总结</h1><p><strong>突破自我局限：</strong> 阻碍你前进的往往不是外部竞争，而是固步自封的思维；决定成败的并非小聪明，而是基于长远视野的理性选择。</p><p><strong>成功的稀缺性：</strong> 成功之路并不拥挤，因为多数人仅停留在 “想要” 而非 “必须” 的层面，缺乏持续行动和代价付出的决心。</p><p><strong>认知与行动的鸿沟：</strong> 人们习惯用偏见判断事物，却拒绝验证与纠错；总是等待 “完美时机”，却从未真正开始，导致机会在观望中流失。</p><p><strong>经验优于准备：</strong> 人生不需要过度准备，需要的是在行动中试错、迭代。唯有持续实践才能积累真实认知，空想只会停滞不前。</p><p><strong>知识的有效转化：</strong> 单纯的知识储备无意义，只有学习能指导实践、解决问题的知识，才能真正改变命运。</p><hr><p>真正的成长始于打破思维惯性，成于持续行动与理性选择。少纠结 “是否正确”，多问 “是否行动”；少沉迷准备，多投入实践——在试错中校准方向，才是普通人跃迁的核心路径。大学生活中，我们要用于尝试，失败不可怕，可怕的是你永远不敢去行动！大学的试错机会很多，试错成本也很低，年轻人一定要把握机会！</p><hr><p>真正的成长不是盲目填满时间表，而是学会区分 “虚假忙碌” 和 “有效突破”。在舒适区重复 100 次不如在挑战区失败 1 次。衡量进步的标准不是投入时间，而是认知边界的拓展。</p><hr><p>退出 5 个闲聊群后，我完成了人生第一个开源项目。不是所有社交都值得维系，有些关系就像内存泄漏的程序，不断消耗你的精力却毫无产出。现在我的交友原则很简单：要么能一起创造价值，要么能让彼此成为更好的人。</p><hr><p>小学生学会造句以后还要下很大功夫才能写出像样的作文。编程需要大量的练习，只看和听是不够的，反过来，如果只是盲目的练习，不看不听也是不明智的。有效的“听”要靠教师的辛勤劳动，而有效的“练”则要靠学生自己。——摘自《算法竞赛 入门经典（第 2 版） 前言部分》</p><hr><p>知识早已浩瀚无边，我们所能接触到的不过大海之一滴，所能理解掌握谨记于心的更不过是这一滴中很微小的一部分，我们每日所做的也不过是为了使这一滴更大，使那一部分更多而已。如果把这一滴比作我们所掌握的资源，那么我们平时开发时应该不求下笔千行，而力求迅速地从各种资源中找到解决方案。——摘自《Linux 内核修炼之道 317 页》</p><hr><p>“真正的智慧不在于知道答案，而在于提出更好的问题；不在于避免犯错，而在于从错误中提炼认知模式。” —— 我的实验室日记第 182 天</p>]]></content>
      
      
      <categories>
          
          <category> 学习历程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习历程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>001 环境搭建</title>
      <link href="/posts/49772.html"/>
      <url>/posts/49772.html</url>
      
        <content type="html"><![CDATA[<h3 id="Linux-环境搭建全解析：从历史到实践"><a href="#Linux-环境搭建全解析：从历史到实践" class="headerlink" title="Linux 环境搭建全解析：从历史到实践"></a>Linux 环境搭建全解析：从历史到实践</h3><p>Linux 作为开源操作系统，已经成为了当今信息技术领域的重要组成部分。无论是服务器、桌面，还是嵌入式设备，Linux 的身影几乎无处不在。那么，Linux 究竟是如何发展而来的？它又是如何在当今的技术世界中占据一席之地的？本篇博客将从 Linux 的历史背景出发，逐步讲解如何在 Linux 环境下进行开发与管理，最后提供具体的 Linux 环境搭建教程。</p><h4 id="一、Linux-的起源与发展"><a href="#一、Linux-的起源与发展" class="headerlink" title="一、Linux 的起源与发展"></a>一、Linux 的起源与发展</h4><p><strong>1.1 UNIX 的历史背景</strong></p><p>在深入探讨 Linux 之前，我们需要了解它的前身——UNIX。UNIX 的诞生始于 1969 年，由 AT&amp;T 贝尔实验室的 Ken Thompson 和 Dennis Ritchie 等人开发。最初，UNIX 被设计为一种多任务、多用户的操作系统，能够有效地支持科研工作。UNIX 继承了当时 Multics 操作系统的部分思想，但它的设计更加简洁和高效，这使得 UNIX 逐渐成为主流操作系统之一。</p><p>随着 UNIX 的逐步发展，不同的版本也相继诞生，包括伯克利软件发行版（BSD）和 System V。这两个版本代表了 UNIX 的不同发展方向，并为后来的 Linux 打下了基础。</p><p><strong>1.2 Linux 的诞生与成长</strong></p><p>1991 年，芬兰赫尔辛基大学的学生 Linus Torvalds 在 Usenet 新闻组发布了自己开发的 Linux 操作系统的早期版本。尽管最初的版本非常基础，但它在接下来的几年中迅速发展，吸引了全球程序员的贡献与支持。1994 年，Linux 发布了 1.0 版本，这标志着其成为成熟的操作系统。</p><p>Linux 的发展离不开开源社区的支持，其强大的开发社区和活跃的贡献使得 Linux 得以迅速成熟，并在全球范围内获得广泛应用。</p><h4 id="二、开源的力量"><a href="#二、开源的力量" class="headerlink" title="二、开源的力量"></a>二、开源的力量</h4><p>Linux 作为一个开源操作系统，采用了 GNU 通用公共许可证（GPL）。这意味着用户可以自由地使用、修改和发布 Linux 的源代码，并且任何基于 Linux 的修改版也必须遵循相同的开源协议。这种开源理念促进了技术的迅速发展，并使得 Linux 成为了全球技术创新的推动者。</p><p>随着时间的推移，Linux 不仅在服务器领域取得了巨大成功，还逐渐渗透到桌面、嵌入式、移动设备等多个领域，证明了开源软件的强大生命力和适应性。</p><h4 id="三、Linux-的应用现状"><a href="#三、Linux-的应用现状" class="headerlink" title="三、Linux 的应用现状"></a>三、Linux 的应用现状</h4><p><strong>3.1 服务器领域</strong></p><p>Linux 在服务器领域的地位几乎是无可替代的。根据统计数据，Linux 在全球服务器市场的占有率已超过 75%，成为各大云计算服务商和企业数据中心的首选操作系统。它在政府、金融、电信等关键行业中得到了广泛应用。此外，Linux 在云计算和大数据平台上也有着举足轻重的地位，86%的企业选择 Linux 作为其云平台的基础操作系统。</p><p><strong>3.2 桌面领域</strong></p><p>尽管 Linux 在桌面市场的份额相对较低，但它在特定场景下，如政府机构和企业内部，正在逐渐获得认可。特别是在中国，许多本土厂商推出了定制化的 Linux 桌面版本，例如中标麒麟、红旗 Linux 等。这些版本在本地市场表现良好，并在政府、企业等领域得到了广泛应用。</p><p>然而，从整体而言，Linux 桌面系统仍然面临一定的挑战，尤其是在用户易用性和软件兼容性方面。与 Windows 相比，Linux 在硬件支持、软件兼容性等方面还存在一定差距。</p><p><strong>3.3 移动嵌入式领域</strong></p><p>Linux 在嵌入式系统中具有无可比拟的优势。由于其低成本、高度可定制性和良好的移植性，Linux 广泛应用于移动设备、路由器、智能家居等领域。例如，Android 操作系统就是基于 Linux 内核开发的，它已经成为全球最流行的智能手机操作系统。</p><p>不仅如此，Linux 还被广泛应用于数字电视、路由器、网络防火墙等设备中，这一切都得益于 Linux 的开放性和高度定制化。</p><h4 id="四、主流-Linux-发行版介绍"><a href="#四、主流-Linux-发行版介绍" class="headerlink" title="四、主流 Linux 发行版介绍"></a>四、主流 Linux 发行版介绍</h4><p>Linux 的开源特性使得各种 Linux 发行版层出不穷。以下是几种主流的 Linux 发行版及其特点：</p><ul><li><strong>Debian</strong>: 以稳定性著称，适合用于服务器环境。它拥有庞大的社区支持和丰富的软件包资源，适合需要长期稳定支持的用户。</li><li><strong>Ubuntu</strong>: 基于 Debian，用户友好，易于安装和使用。Ubuntu 广泛应用于个人计算和云计算领域，尤其适合 Linux 初学者。</li><li><strong>红帽企业级 Linux (RHEL)</strong>: 针对企业环境设计，提供商业级支持。RHEL 适用于对安全性和稳定性要求较高的企业。</li><li><strong>CentOS</strong>: RHEL 的免费重构版，几乎完全兼容 RHEL，适合希望体验 RHEL 特性的用户，但不愿支付高额费用。</li><li><strong>Fedora</strong>: 一个小巧灵活的发行版，适合那些希望体验前沿技术的开发者。Fedora 是 RHEL 的测试平台，许多新技术会首先在 Fedora 中出现。</li><li><strong>Kali Linux</strong>: 专为渗透测试和网络安全设计，预装了大量安全工具。它是网络安全专家和渗透测试人员的首选操作系统。</li></ul><h4 id="五、Linux-环境搭建指南"><a href="#五、Linux-环境搭建指南" class="headerlink" title="五、Linux 环境搭建指南"></a>五、Linux 环境搭建指南</h4><p>对于新手来说，搭建 Linux 环境是一个非常好的学习机会。以下是通过云服务器搭建 Linux 环境的详细步骤。</p><p><strong>5.1 购买云服务器</strong></p><ul><li><strong>选择云服务商</strong>：可以选择腾讯云、阿里云、华为云等提供的学生优惠套餐，价格实惠且无需担心物理硬件维护。</li><li><strong>登录账号</strong>：使用 QQ、微信等账号登录云服务商官网。</li><li><strong>选择配置</strong>：选择适合自己的操作系统（例如 CentOS 7.6 64 位）和配置，购买时长建议至少一年。</li><li><strong>获取服务器信息</strong>：记录下服务器的公网 IP、管理员账户（通常为 root）及密码，这些信息是远程登录服务器所必须的。</li></ul><p><strong>5.2 设置服务器</strong></p><ul><li><strong>设置 root 密码</strong>：进入控制台后，选择服务器并重置 root 密码，确保密码复杂度较高，以保证安全。</li><li><strong>配置安全组规则</strong>：调整安全组规则，仅开放必要的端口和服务，如 SSH（22 端口）、HTTP（80 端口）等。</li></ul><p><strong>5.3 安装 XShell</strong></p><ul><li><strong>下载安装 XShell</strong>：XShell 是一款流行的 SSH 客户端，可以通过官方网站下载并安装。</li><li><strong>新建会话</strong>：创建新的会话，输入服务器的公网 IP 地址，选择 SSH 协议进行连接。</li><li><strong>登录服务器</strong>：首次登录时，确认主机指纹并输入用户名（root）和密码，成功后即可开始操作。</li></ul><p>&#x3D;&#x3D;<strong>连接：ssh root@……（ssh + 空格 + root@ + 自己的公网 IP），输入自己的密码，如果跳出像乱码的弹窗选择信任并接受即可</strong>&#x3D;&#x3D;</p><p><strong>5.4 使用 XShell 进行日常操作</strong></p><ul><li><strong>基本命令</strong>：熟悉常用的 Linux 命令，如文件管理命令（ls、cd、cp、mv）、文本编辑命令（vi、vim）等。</li><li><strong>复制粘贴技巧</strong>：在 XShell 中使用 Ctrl+Insert 复制，Shift+Insert 粘贴，而不是 Windows 常用的 Ctrl+C&#x2F;V。</li><li><strong>常用工具安装</strong>：使用命令安装软件包（如 Apache、MySQL 等），常用命令包括 <code>yum</code>、<code>apt-get</code> 等。</li></ul><h4 id="六、结语"><a href="#六、结语" class="headerlink" title="六、结语"></a>六、结语</h4><p>Linux 已经不仅仅是一个操作系统，它是开源、自由、创新的象征。通过本篇博客的介绍，相信你对 Linux 有了更深入的了解。无论是在服务器管理、软件开发，还是在日常操作中，Linux 都能够提供高效、稳定的支持。而通过云服务搭建 Linux 环境，你可以轻松快速地开始你的 Linux 之旅。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>002 创建普通账户（为朋友创建、删除账户）</title>
      <link href="/posts/55415.html"/>
      <url>/posts/55415.html</url>
      
        <content type="html"><![CDATA[<h1 id="在-Linux-系统中管理用户账户：创建、设置密码及删除操作"><a href="#在-Linux-系统中管理用户账户：创建、设置密码及删除操作" class="headerlink" title="在 Linux 系统中管理用户账户：创建、设置密码及删除操作"></a>在 Linux 系统中管理用户账户：创建、设置密码及删除操作</h1><h2 id="1-创建新用户"><a href="#1-创建新用户" class="headerlink" title="1. 创建新用户"></a>1. 创建新用户</h2><p>在 Linux 系统中，我们可以使用 <code>adduser</code> 或 <code>useradd</code> 命令来创建新用户。推荐使用 <code>adduser</code> 命令，因为它相对简单，且可以交互式地引导你完成用户创建过程。</p><h3 id="创建新用户命令："><a href="#创建新用户命令：" class="headerlink" title="创建新用户命令："></a>创建新用户命令：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adduser 用户名</span><br></pre></td></tr></table></figure><p>这里，<code>用户名</code> 是您自定义的用户名称。假设我们要创建一个名为 <code>friend</code> 的新用户，那么命令应该是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adduser friend</span><br></pre></td></tr></table></figure><p>执行该命令后，系统将自动创建一个新的用户账户。具体操作步骤如下：</p><ol><li>在 <code>/home</code> 目录下为该用户创建一个子目录（即 <code>home/friend</code>）。</li><li>配置默认的 shell（通常是 <code>/bin/bash</code>）。</li><li>创建该用户的相关信息文件，并将用户信息记录到 <code>/etc/passwd</code> 文件中。</li></ol><h3 id="示例输出："><a href="#示例输出：" class="headerlink" title="示例输出："></a>示例输出：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@server]# adduser friend</span><br></pre></td></tr></table></figure><p>执行该命令后，系统会创建新用户，并在终端中显示相关信息。</p><h2 id="2-为新用户设置密码"><a href="#2-为新用户设置密码" class="headerlink" title="2. 为新用户设置密码"></a>2. 为新用户设置密码</h2><p>在创建新用户后，我们需要为该用户设置一个密码。可以使用 <code>passwd</code> 命令来设置用户密码。</p><h3 id="设置密码命令："><a href="#设置密码命令：" class="headerlink" title="设置密码命令："></a>设置密码命令：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd 用户名</span><br></pre></td></tr></table></figure><p>对于我们刚刚创建的 <code>friend</code> 用户，设置密码的命令是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd friend</span><br></pre></td></tr></table></figure><p>系统会提示你输入密码，并要求重新输入确认密码。在输入密码时，注意密码不会 &#x3D;&#x3D;回显&#x3D;&#x3D;，即 <strong>不会显示在终端</strong> 上，这是出于安全考虑。系统会根据输入的密码自动进行验证，确保密码符合要求（如长度、复杂度等）。</p><h3 id="示例输出：-1"><a href="#示例输出：-1" class="headerlink" title="示例输出："></a>示例输出：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@server]# passwd friend</span><br><span class="line">Changing password <span class="keyword">for</span> user friend.</span><br><span class="line">New password: *******  (输入密码)</span><br><span class="line">Retype new password: *******  (确认密码)</span><br><span class="line">passwd: all authentication tokens updated successfully.</span><br></pre></td></tr></table></figure><p>如果密码强度不符合要求，系统会给出相应的提示，例如：“密码过短”或“密码不符合复杂度要求”。确保输入一个符合规则的密码。</p><h2 id="3-删除用户"><a href="#3-删除用户" class="headerlink" title="3. 删除用户"></a>3. 删除用户</h2><p>当某个用户不再需要时，我们可以通过 <code>userdel</code> 命令将其从系统中删除。若要同时删除该用户的家目录和相关文件，可以使用 <code>-r</code> 选项。</p><h3 id="删除用户命令："><a href="#删除用户命令：" class="headerlink" title="删除用户命令："></a>删除用户命令：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">userdel -r 用户名</span><br></pre></td></tr></table></figure><p>对于我们之前创建的 <code>friend</code> 用户，删除该用户并清理相关文件的命令是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">userdel -r friend</span><br></pre></td></tr></table></figure><p>该命令执行后，系统会删除 <code>friend</code> 用户，并且连同该用户的家目录（即 <code>/home/friend</code>）和其他相关文件一并删除。</p><h3 id="示例输出：-2"><a href="#示例输出：-2" class="headerlink" title="示例输出："></a>示例输出：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@server]# userdel -r friend</span><br></pre></td></tr></table></figure><p>执行删除命令后，用户和其相关文件将永久删除。请小心使用此命令，因为删除操作是不可恢复的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过以上三个命令，你可以轻松地在 Linux 系统中管理用户账户：</p><ol><li><strong>创建用户</strong>：使用 <code>adduser friend</code> 命令创建新用户。</li><li><strong>设置密码</strong>：使用 <code>passwd friend</code> 命令为用户设置密码。</li><li><strong>删除用户</strong>：使用 <code>userdel -r friend</code> 命令删除用户及其相关文件。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>003 系统和入门指令</title>
      <link href="/posts/42463.html"/>
      <url>/posts/42463.html</url>
      
        <content type="html"><![CDATA[<h2 id="操作系统（OS）的基础概念"><a href="#操作系统（OS）的基础概念" class="headerlink" title="操作系统（OS）的基础概念"></a>操作系统（OS）的基础概念</h2><p>操作系统是计算机硬件和软件之间的中介，它负责管理计算机硬件资源并为应用程序提供一个运行环境。简单来说，操作系统的目标是使计算机变得更好用。它使得硬件的复杂性对用户透明，提供更高效的资源管理，并使应用程序能够正常运行。</p><h3 id="1-操作系统的层次结构"><a href="#1-操作系统的层次结构" class="headerlink" title="1. 操作系统的层次结构"></a>1. 操作系统的层次结构</h3><p>操作系统通常由多个层次构成，每一层提供不同的功能：</p><ol><li><strong>硬件层（硬件）</strong><br> 这是计算机的基础物理部分，包括 CPU、内存、硬盘、显示器、键盘等。硬件直接提供计算和存储资源。</li><li><strong>设备驱动层</strong><br> 这一层负责控制和管理硬件设备，如声卡、显卡、打印机等。操作系统通过设备驱动程序与硬件进行通信，确保硬件的正常运行。</li><li><strong>操作系统层</strong><br> 这一层是操作系统的核心部分，负责管理硬件资源，调度进程，提供文件管理、内存管理等基本功能。常见的操作系统包括 Windows、Linux、macOS 等。</li><li><strong>应用软件层</strong><br> 最顶层是应用软件，它包括各种应用程序，如 Word、Matlab 等。用户通过这些软件与计算机互动，完成各种任务。</li></ol><h3 id="2-操作系统的功能"><a href="#2-操作系统的功能" class="headerlink" title="2. 操作系统的功能"></a>2. 操作系统的功能</h3><ol><li><strong>资源管理</strong><br> 操作系统需要高效管理计算机的资源，如 CPU 时间、内存、磁盘存储等。它通过调度算法分配资源，确保每个进程能够公平、高效地使用资源。</li><li><strong>进程管理</strong><br> 操作系统负责管理和调度各个运行的进程，确保它们按优先级运行，并避免资源冲突。</li><li><strong>文件系统管理</strong><br> 操作系统提供一个文件系统，用于组织和管理存储在磁盘上的数据。它确保数据能够有效地存储和检索。</li><li><strong>用户界面</strong><br> 操作系统提供一个用户界面，让用户能够与计算机交互。传统的图形用户界面（GUI）或命令行界面（CLI）让用户输入指令并接收反馈。</li></ol><h3 id="3-常见操作系统"><a href="#3-常见操作系统" class="headerlink" title="3. 常见操作系统"></a>3. 常见操作系统</h3><ul><li><strong>Windows</strong>：广泛应用于个人电脑和办公环境，是最常见的桌面操作系统。</li><li><strong>Linux</strong>：一个开源的操作系统，具有高度的可定制性，广泛应用于服务器和嵌入式系统。</li><li><strong>macOS</strong>：苹果公司开发的操作系统，具有优雅的图形界面和强大的开发工具，广泛应用于苹果设备。</li></ul><h3 id="4-一个好的操作系统衡量指标："><a href="#4-一个好的操作系统衡量指标：" class="headerlink" title="4. 一个好的操作系统衡量指标："></a>4. 一个好的操作系统衡量指标：</h3><ol><li><strong>性能</strong>：快速响应、有效的资源利用、高吞吐量。</li><li><strong>稳定性</strong>：高可靠性、容错能力强、进程隔离良好。</li><li><strong>安全性</strong>：强大的权限管理、数据保护、及时的漏洞修复。</li><li><strong>可扩展性</strong>：支持多种硬件、兼容多种软件、有效管理多任务。</li><li><strong>易用性</strong>：直观的用户界面、完善的文档支持、灵活的配置管理工具。</li><li><strong>支持和维护</strong>：强大的社区支持、定期更新、丰富的开发者生态。</li><li><strong>兼容性</strong>：跨平台兼容和向后兼容，确保广泛的软件和硬件支持。</li><li><strong>资源管理</strong>：高效的内存、磁盘和 CPU 调度管理。</li></ol><h4 id="我们的所有的软件行为，全部都要-自顶向下（应用软件-–-操作系统-–-设备驱动-–-硬件）-贯穿-计算机的软硬件结构，几乎我们的所有的软件行为，未来都和操作系统直接或者间接相关！"><a href="#我们的所有的软件行为，全部都要-自顶向下（应用软件-–-操作系统-–-设备驱动-–-硬件）-贯穿-计算机的软硬件结构，几乎我们的所有的软件行为，未来都和操作系统直接或者间接相关！" class="headerlink" title="我们的所有的软件行为，全部都要 自顶向下（应用软件 –&gt; &#x3D;&#x3D;操作系统&#x3D;&#x3D; –&gt; 设备驱动 –&gt; 硬件）&#x3D;&#x3D;贯穿&#x3D;&#x3D; 计算机的软硬件结构，几乎我们的所有的软件行为，未来都和操作系统直接或者间接相关！"></a>我们的所有的软件行为，全部都要 <strong>自顶向下（应用软件 –&gt; &#x3D;&#x3D;操作系统&#x3D;&#x3D; –&gt; 设备驱动 –&gt; 硬件）&#x3D;&#x3D;贯穿&#x3D;&#x3D;</strong> 计算机的软硬件结构，几乎我们的所有的软件行为，未来都和操作系统直接或者间接相关！</h4><blockquote><h2 id="传道解惑"><a href="#传道解惑" class="headerlink" title="传道解惑"></a>传道解惑</h2><h3 id="Q1：为什么要有操作系统？"><a href="#Q1：为什么要有操作系统？" class="headerlink" title="Q1：为什么要有操作系统？"></a>Q1：为什么要有操作系统？</h3><ul><li><strong>操作系统的核心工作</strong>：操作系统通过管理硬件资源（如 CPU、内存、硬盘等）来保证计算机的高效运行。</li><li><strong>目标</strong>：通过良好的资源管理，提供给用户一个稳定、快速且安全的工作环境。</li><li><strong>稳定、快速、安全</strong>：这三个关键词表明，操作系统不仅要确保系统不容易崩溃，还要在处理任务时迅速反应，并保护用户数据的安全性。</li></ul><p>简而言之，操作系统的核心任务是协调硬件和软件的交互，确保计算机可以高效、稳定并安全地执行任务。</p><p>操作系统的发展历史表明，<strong>先有指令</strong>（即命令行界面），再有图形用户界面（GUI）。这是因为操作系统最初的设计目标是通过命令行接口与计算机进行交互，而图形界面是为了提高用户体验而逐渐发展出来的。</p><h3 id="Q2：为什么先有指令，再有图形界面？"><a href="#Q2：为什么先有指令，再有图形界面？" class="headerlink" title="Q2：为什么先有指令，再有图形界面？"></a>Q2：为什么先有指令，再有图形界面？</h3><h4 id="1-指令先行："><a href="#1-指令先行：" class="headerlink" title="1. 指令先行："></a>1. 指令先行：</h4><ul><li>早期的计算机操作系统（如 UNIX、DOS 等）主要依赖命令行界面（CLI）。用户通过输入指令（如 <code>ls</code>、<code>dir</code> 等）来与操作系统进行交互。这种方式对计算机硬件的控制更加精确、灵活，适用于开发人员和技术人员。</li></ul><h4 id="2-图形界面后发展："><a href="#2-图形界面后发展：" class="headerlink" title="2. 图形界面后发展："></a>2. 图形界面后发展：</h4><ul><li>随着计算机技术的发展，尤其是在个人计算机普及后，用户开始需要更加直观和易用的操作方式。图形用户界面（GUI）应运而生，典型的例子如 Mac OS、Windows 等。GUI 通过图标、窗口、按钮等元素提供了更为友好的用户体验。</li></ul><h4 id="3-为什么？"><a href="#3-为什么？" class="headerlink" title="3. 为什么？"></a>3. 为什么？</h4><ul><li><strong>技术限制</strong>：早期的计算机资源有限，硬件和图形显示技术还不成熟，因此以文字和命令行的方式与计算机交互是最有效的。</li><li><strong>用户群体</strong>：早期计算机主要用于科研、军事和技术开发，用户多为专业人员，他们更习惯于通过指令行与计算机沟通。</li><li><strong>演化需求</strong>：随着计算机的普及，更多非技术用户开始使用计算机，需求变得更加注重易用性，于是图形界面得以逐渐发展并成为主流。</li></ul><p>因此，指令是操作系统的基础，而图形界面是在后期发展起来的，目的是让操作系统更加易用、亲民。</p></blockquote><hr><h2 id="Linux-下基础命令详解"><a href="#Linux-下基础命令详解" class="headerlink" title="Linux 下基础命令详解"></a>Linux 下基础命令详解</h2><p>在 Linux 操作系统中，有许多常用的命令帮助用户管理文件系统、执行操作及进行系统管理。本文将介绍一些常见的命令以及如何使用它们，帮助初学者更好地理解和使用 Linux。</p><p><strong>初见：</strong></p><ul><li><strong>ls</strong>：显示当前文件夹下的文件和目录。</li><li><strong>pwd</strong>：显示当前所在的目录路径。</li><li><strong>mkdir 新文件夹名称</strong>：在当前位置创建一个新的文件夹。</li><li><strong>cd 目录</strong>：进入指定目录。</li></ul><p>如果你想创建的是文件而非文件夹，可以使用命令 <code>touch 文件名称</code> 来创建一个空文件。</p><h3 id="1-ls-指令——文件和目录的显示命令"><a href="#1-ls-指令——文件和目录的显示命令" class="headerlink" title="1. ls 指令——文件和目录的显示命令"></a>1. ls 指令——文件和目录的显示命令</h3><p><strong>语法</strong>: <code>ls [选项] [目录或文件]</code>  </p><ul><li><p><strong>ls</strong>：列出当前目录下的文件和目录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span></span><br></pre></td></tr></table></figure></li><li><p><strong>ls -l</strong>：以长格式显示目录内容，包含详细的文件信息（如权限、所有者、文件大小等）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -l</span><br></pre></td></tr></table></figure></li><li><p><strong>ll</strong>：<code>ll</code> 是 <code>ls -l</code> 的简写，执行结果相同。它是许多 Linux 系统中为了简化命令输入而创建的别名。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ll</span><br></pre></td></tr></table></figure></li><li><p><strong>ls -a</strong>：显示包括隐藏文件在内的所有文件（以 <code>.</code> 开头的文件为隐藏文件）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -a</span><br></pre></td></tr></table></figure></li><li><p><strong>ls -al 或 ls -la</strong>：这两个命令等价，表示显示所有文件，包括隐藏文件，且以长格式显示。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -al</span><br></pre></td></tr></table></figure></li></ul><table><thead><tr><th align="center"><code>ls</code> 命令</th><th>说明</th></tr></thead><tbody><tr><td align="center"><code>ls -a</code></td><td>列出目录下的所有文件，包括以 <code>.</code> 开头的隐藏文件。</td></tr><tr><td align="center"><code>ls -d</code></td><td>将目录像文件一样显示，而不是显示其内容。例如：<code>ls -d 指定目录</code>。</td></tr><tr><td align="center"><code>ls -i</code></td><td>输出文件的 inode 节点的索引信息。例如：<code>ls -ai 指定文件</code>。</td></tr><tr><td align="center"><code>ls -k</code></td><td>以 k 字节的形式显示文件大小。例如：<code>ls -alk</code> 指定文件。</td></tr><tr><td align="center"><code>ls -l</code></td><td>列出文件的详细信息。</td></tr><tr><td align="center"><code>ls -n</code></td><td>用数字的 UID、GID 代替名称（介绍 UID、GID）。</td></tr><tr><td align="center"><code>ls -F</code></td><td>在每个文件名后附加一个字符以说明该文件的类型，<code>*</code> 表示可执行的普通文件，<code>/</code> 表示目录，&#96;</td></tr><tr><td align="center"><code>ls -r</code></td><td>对目录反向排序。</td></tr><tr><td align="center"><code>ls -t</code></td><td>以时间排序。</td></tr><tr><td align="center"><code>ls -s</code></td><td>在文件名后输出该文件的大小（大&#x2F;小排序，如如何找到目录下最大的文件）。</td></tr><tr><td align="center"><code>ls -R</code></td><td>列出所有子目录下的文件（递归）。</td></tr><tr><td align="center"><code>ls -1</code></td><td>一行输出一个文件。</td></tr></tbody></table><h3 id="2-文件类型说明"><a href="#2-文件类型说明" class="headerlink" title="2. 文件类型说明"></a>2. 文件类型说明</h3><ul><li><strong>d</strong>：表示一个目录。</li><li><strong>-</strong>：表示一个普通文件。</li><li><strong>以 . 开头的文件</strong>：这些文件是隐藏文件，通常用于存储配置或系统信息。</li></ul><h3 id="3-路径说明"><a href="#3-路径说明" class="headerlink" title="3. 路径说明"></a>3. 路径说明</h3><ul><li>相对路径与绝对路径：<ul><li><strong>绝对路径</strong>：从根目录 <code>/</code> 开始的路径，具有唯一性。在任何环境中都能准确指向一个文件或目录。例如：<code>/home/user/docs/file.txt</code>。</li><li><strong>相对路径</strong>：相对于当前所在目录的路径。路径会根据当前所在目录的不同而有所变化。相对路径更短，但在路径变动时可能失效。</li></ul></li><li>. 和 .. 的含义：<ul><li><code>.</code>：表示当前目录。</li><li><code>..</code>：表示上一级目录。</li></ul></li></ul><h3 id="4-用户管理命令和-cd-指令"><a href="#4-用户管理命令和-cd-指令" class="headerlink" title="4. 用户管理命令和 cd 指令"></a>4. 用户管理命令和 <code>cd</code> 指令</h3><ul><li><strong>whoami</strong>：显示当前登录的用户名。</li><li><strong>家目录</strong>：在 Linux 系统中，每个用户都有一个家目录。普通用户的家目录通常位于 <code>/home/用户名</code>，而超级用户（root）的家目录通常是 <code>/root</code>。</li></ul><table><thead><tr><th align="center"><code>cd</code> 命令</th><th>描述</th></tr></thead><tbody><tr><td align="center"><code>cd ..</code></td><td>返回上级目录</td></tr><tr><td align="center"><code>cd /home/litao/linux/</code></td><td>绝对路径</td></tr><tr><td align="center"><code>cd ../day02/</code></td><td>相对路径</td></tr><tr><td align="center"><code>cd ~</code></td><td>进入当前用户家目录，<code>~</code> 是当前用户家目录的快捷表示</td></tr><tr><td align="center"><code>cd -</code></td><td>返回最近访问目录（切换回上一次所在的目录）</td></tr></tbody></table><h3 id="5-文件和目录操作命令"><a href="#5-文件和目录操作命令" class="headerlink" title="5. 文件和目录操作命令"></a>5. 文件和目录操作命令</h3><ul><li><p><strong>touch 文件</strong>：创建一个空文件。如果文件已经存在，<code>touch</code> 会更新文件的访问时间和修改时间。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">touch</span> newfile.txt</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">touch 命令</th><th>描述</th></tr></thead><tbody><tr><td align="center"><code>-a</code></td><td>–time &#x3D; atime 或 –time &#x3D; access，只更新访问时间。</td></tr><tr><td align="center"><code>-c</code></td><td>–no-create，不创建任何文件。</td></tr><tr><td align="center"><code>-d</code></td><td>使用指定的日期时间，而非当前时间。</td></tr><tr><td align="center"><code>-f</code></td><td>该参数将忽略不予处理，仅负责解决 BSD 版本的 touch 命令的兼容性问题。</td></tr><tr><td align="center"><code>-m</code></td><td>–time &#x3D; mtime 或 –time &#x3D; modify，只更新修改时间。</td></tr><tr><td align="center"><code>-r</code></td><td>把指定文件或目录的日期时间，统一成文件或目录的日期时间。</td></tr><tr><td align="center"><code>-t</code></td><td>使用指定的日期时间，而非当前时间。</td></tr></tbody></table></li><li><p><strong>mkdir 目录名</strong>：创建一个新目录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> newdir</span><br></pre></td></tr></table></figure></li><li><p><strong>mkdir –p test&#x2F;test1 :</strong> 递归建立多个目录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> –p <span class="built_in">test</span>/test1</span><br></pre></td></tr></table></figure></li></ul><p><strong>rmdir 目录名</strong>：删除一个空目录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rmdir</span> emptydir</span><br></pre></td></tr></table></figure><ul><li><p><strong>rm 文件</strong>：删除指定文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> file.txt</span><br></pre></td></tr></table></figure></li><li><p><strong>rm -f 文件</strong>：强制删除文件，不会提示确认。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> -f file.txt</span><br></pre></td></tr></table></figure></li><li><p><strong>rm -r 目录</strong>：递归删除目录及其中的所有文件和子目录。注意：使用 <code>rm</code> 删除文件时不能直接删除目录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> -r directory</span><br></pre></td></tr></table></figure></li><li><p><strong>rm -rf 目录</strong>：强制递归删除目录及其内容，不会询问是否确认删除。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> -rf directory</span><br></pre></td></tr></table></figure></li></ul><h3 id="6-安装与显示目录结构"><a href="#6-安装与显示目录结构" class="headerlink" title="6. 安装与显示目录结构"></a>6. 安装与显示目录结构</h3><ul><li><p><strong>yum install -y tree</strong>：安装 <code>tree</code> 命令（需要 root 权限）。<code>tree</code> 命令用于以树状图形式显示目录结构。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y tree</span><br></pre></td></tr></table></figure></li><li><p><strong>tree</strong>：显示目录结构的树状图。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tree</span><br></pre></td></tr></table></figure></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Linux 提供了一系列强大的命令帮助用户管理文件和目录。理解这些命令的功能及使用场景，将极大提高操作效率。本文介绍了一些基本的命令，它们包括文件和目录的查看、管理、删除命令以及路径的操作方式。掌握这些命令是使用 Linux 系统的基础，并为更高级的操作奠定了基础。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>006 yum和Linux生态</title>
      <link href="/posts/15646.html"/>
      <url>/posts/15646.html</url>
      
        <content type="html"><![CDATA[<h2 id="Linux-软件包管理器-yum"><a href="#Linux-软件包管理器-yum" class="headerlink" title="Linux 软件包管理器 yum"></a><code>Linux</code> 软件包管理器 <code>yum</code></h2><p>在 Linux 中，安装软件的常见方式主要有三种：源代码安装、<code>rpm</code> 安装和 <code>yum</code> 安装。它们各自有优缺点，适用于不同的场景。</p><table><thead><tr><th>安装方式</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td><strong>源代码安装</strong></td><td>- 高度定制化（调整编译选项、安装路径等）</td><td>- 操作复杂，需要手动执行 <code>./configure</code>, <code>make</code>, <code>make install</code> 等步骤</td></tr><tr><td></td><td>- 软件版本灵活（能获取最新版本或特定版本）</td><td>- 依赖管理困难，需手动解决依赖关系</td></tr><tr><td></td><td>- 跨平台兼容性强（适配不同架构或操作系统）</td><td>- 编译过程时间长，消耗大量计算资源</td></tr><tr><td></td><td></td><td>- 升级和卸载困难，缺乏统一的版本管理</td></tr><tr><td><strong><code>rpm</code> 安装</strong></td><td>- 安装速度快，使用预编译的二进制包</td><td>- 依赖需手动解决，可能出现“依赖地狱”</td></tr><tr><td></td><td>- 安装时自动检查并提示缺少的依赖项</td><td>- 版本受限于本地或下载的 RPM 包，可能无法获取最新版本</td></tr><tr><td></td><td>- 通过 <code>rpm</code> 命令可管理软件包（查询、验证、升级、卸载等）</td><td>- 默认不关联远程仓库，依赖本地或手动下载的 RPM 包</td></tr><tr><td><strong><code>yum</code> 安装</strong></td><td>- 自动解决依赖关系，简化安装过程</td><td>- 需要联网访问仓库（离线环境需配置本地镜像）</td></tr><tr><td></td><td>- 支持多个远程仓库，软件版本经过测试，保证兼容性</td><td>- 仓库中的软件版本可能滞后于上游源码版本</td></tr><tr><td></td><td>- 简化操作，支持一键安装、更新、卸载</td><td></td></tr><tr><td></td><td>- 安全更新，仓库提供数字签名验证</td><td></td></tr><tr><td></td><td>- 版本灵活性，支持快速切换软件版本</td><td></td></tr></tbody></table><p><strong>总的来说：</strong></p><ul><li><strong>源代码安装</strong>：复杂、遥远，普通用户几乎不需要使用。</li><li><strong><code>rpm</code> 安装</strong>：依赖问题复杂，对小白用户不够友好。</li><li><strong><code>yum</code> 安装</strong>：自动解决依赖、操作简单、版本管理方便，是普通用户的最佳选择。</li></ul><hr><h3 id="什么是软件包？"><a href="#什么是软件包？" class="headerlink" title="什么是软件包？"></a>什么是软件包？</h3><p><strong>1. 软件包和软件包管理器的关系</strong></p><ul><li><strong>软件包（Package）</strong>：就像 Windows 下的安装程序一样，软件包是已经编译好的软件，通常包含了可执行程序、配置文件、依赖关系和其他必要的资源。用户只需要通过简单的命令就可以将它们安装到系统中。软件包一般是针对特定操作系统或发行版（如 CentOS、Ubuntu 等）预编译的。</li><li><strong>软件包管理器（Package Manager）</strong>：它就像是“应用商店”，提供一个方便的接口让用户可以搜索、安装、更新和删除软件包。包管理器可以自动处理依赖关系、下载并安装正确的软件版本，同时还能确保系统的其他软件和包的一致性。</li></ul><p><strong>2. <code>yum</code>（Yellowdog Updater, Modified）</strong></p><p><strong>YUM</strong> 是一种在 Linux 下非常常用的包管理工具，它的作用类似于应用商店，让用户能够轻松地安装、更新、卸载软件包。</p><p><strong>主要特点：</strong></p><ul><li><strong>自动化安装和更新</strong>：只需使用简单的命令（如 <code>yum install 软件包名</code>）就能自动获取并安装软件包。包管理器会自动处理依赖关系，确保安装过程的顺利进行。</li><li><strong>依赖关系管理</strong>：在 Linux 中，很多软件都依赖于其他库或软件。<code>yum</code> 会自动检测软件包的依赖，确保安装时不会漏掉必要的组件。</li><li><strong>仓库支持</strong>：<code>yum </code> 通过配置软件仓库（Repository）来获取软件包，仓库相当于存放了大量软件包的 <strong>服务器</strong>。用户无需自己编译软件，只需要指定仓库，<code>yum </code> 就可以从中获取到已经编译好的软件包。</li><li><strong>简便的命令行界面</strong>：<code>yum</code> 提供了简单的命令行接口来处理软件包的安装、更新和卸载。比如：<ul><li><code>yum install &lt;软件包名&gt;</code>：安装软件包</li><li><code>yum update</code>：更新所有已安装的软件包</li><li><code>yum remove &lt;软件包名&gt;</code>：卸载软件包</li><li><code>yum search &lt;软件包名&gt;</code>：搜索软件包</li></ul></li><li><strong>安全性与稳定性</strong>：<code>yum</code> 的仓库中的软件包经过了测试（相当于经过应用商店审核），保证了软件与系统的兼容性。而且，<code>yum</code> 会自动处理安全更新，确保系统和软件的安全。</li></ul><p><strong>3. 对比 Windows 安装软件</strong></p><p>就像在 Windows 系统上，用户经常通过应用商店（例如 Microsoft Store）或者直接从第三方网站下载安装程序来安装软件一样，Linux 系统上的 <code>yum</code> 就是一个类似的工具。区别在于，Linux 下的软件包管理是更集成化和自动化的，依赖关系和版本更新会自动处理，而在 Windows 上，安装程序通常需要手动处理依赖或者更新。</p><p><strong>4. <code>yum</code> 的优势</strong></p><ul><li><strong>省时省力</strong>：不像从源代码编译那样需要手动下载、配置和编译。</li><li><strong>确保兼容性</strong>：<code>yum</code> 通过仓库（厂商或发行版维护者的 <strong>服务器</strong>）提供的软件包保证了软件和操作系统的兼容性，减少了因版本不匹配导致的问题。</li><li><strong>易于管理</strong>：通过 <code>yum</code>，用户可以方便地管理已安装的软件包，无论是安装新软件、更新已有软件，还是卸载不需要的软件，所有操作都可以通过简单的命令完成。</li></ul><hr><h3 id="基于-Linux-系统（CentOS-7）中使用-yum-命令来安装、卸载和管理-lrzsz-工具的步骤和注意事项。"><a href="#基于-Linux-系统（CentOS-7）中使用-yum-命令来安装、卸载和管理-lrzsz-工具的步骤和注意事项。" class="headerlink" title="基于 Linux 系统（CentOS 7）中使用 yum 命令来安装、卸载和管理 lrzsz 工具的步骤和注意事项。"></a>基于 Linux 系统（CentOS 7）中使用 <code>yum</code> 命令来安装、卸载和管理 <code>lrzsz</code> 工具的步骤和注意事项。</h3><p><strong>注意：</strong> 一般 Linux 操作系统，默认配置的 <code>yum</code> 源是国外的，有可能你的 <code>yum</code> 源访问会比较慢，可能需要更新 <code>yum</code> 源 替换 <code>yum</code> 源文件（这里常指使用虚拟机的）， <code>yum</code> <strong>服务器</strong> 一般厂商已经替换了，这就是学习时 <strong>云服务器优于虚拟机</strong> 的一个原因。</p><h4 id="关于-lrzsz-工具"><a href="#关于-lrzsz-工具" class="headerlink" title="关于 lrzsz 工具"></a>关于 <code>lrzsz</code> 工具</h4><p><strong>用途</strong>：<strong><code>lrzsz</code> 是一组用于在 Windows 和远程 Linux 机器之间通过 XShell 传输文件的工具。</strong> 我们可以通过拖拽的方式将文件从 <strong>Windows</strong> 机器上传到远程的 <strong>Linux</strong> 服务器。</p><p>安装了 <code>rzsz</code> 工具后，XShell 会自动识别，并允许我们将文件从 Windows 拖动到终端中，并通过 <code>rz</code>（接收文件）命令将文件上传到 Linux 系统。反过来，也可以从 <strong>Linux</strong> 下载文件到 <strong>Windows</strong>。只需在 Linux 上执行 <code>sz</code>（发送文件）命令，XShell 会自动接收并将文件传输到本地的 Windows 系统。</p><ul><li>在 <strong>XShell</strong> 中，执行 <code>rz</code> 命令（这将启动接收模式）。</li><li>在 <strong>XShell</strong> 中，执行 <code>sz 文件名</code> 命令（这将启动发送模式）。（<strong>通常是 XShell 的默认目录，可以设置特定的路径</strong>）</li></ul><p><strong>注意事项</strong>：确认 <strong>网络连接正常</strong>。在进行任何与 <code>yum</code> 相关的操作前，必须确保主机（或虚拟机）的网络正常工作。可以使用命令 <code>ping www.baidu.com</code> 来验证网络是否畅通。</p><h4 id="查看与筛选软件包"><a href="#查看与筛选软件包" class="headerlink" title="查看与筛选软件包"></a>查看与筛选软件包</h4><ul><li><p>查看可用软件包：使用 <code>yum list</code> 命令可以列出所有可用的软件包。由于软件包列表可能非常长，可以结合 <code>grep</code> 命令筛选出感兴趣的软件包。例如，查找 <code>lrzsz</code> 相关的信息，可以执行：<code>yum list | grep lrzsz</code></p></li><li><p>理解软件包名称：软件包名称一般格式如下：<strong><code>主版本号.次版本号.源程序发行号-软件包的发行号.主机平台.cpu架构</code></strong> 例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">lrzsz.x86_64 0.12.20-36.el7 @base</span><br><span class="line"><span class="comment"># lrzsz：软件包的名称</span></span><br><span class="line"><span class="comment"># x86_64：表示软件包适用于64位架构的CPU</span></span><br><span class="line"><span class="comment"># 0.12.20：软件的主要版本号，lrzsz 的版本是0.12.20</span></span><br><span class="line"><span class="comment"># 36：打包版本号</span></span><br><span class="line"><span class="comment"># el7：el：centos，7：主版本。也就是centos7</span></span><br><span class="line"><span class="comment"># @base：表明了软件包的来源仓库（软件仓库）。理解成厂商即可，例如华为/快手/……</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h4><ul><li><p><strong>安装命令</strong>：通过以下命令可以安装 <code>lrzsz</code> 工具：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> yum install lrzsz</span><br></pre></td></tr></table></figure><p>执行该命令后，<code>yum</code> 会自动解决依赖关系并提示需要下载哪些软件包。确认后（通常按“y”）开始安装。</p></li><li><p><strong>权限要求</strong>：由于安装过程中需要向系统目录写入文件，因此需要使用 <code>sudo</code> 或切换到 <strong>root 账户</strong>。</p></li><li><p><strong>串行安装</strong>：由于 <code>yum</code> 进程锁定，<strong>同一时间只能执行一个安装任务</strong>。一个 <code>yum</code> 安装过程未完成时，尝试启动另一个 <code>yum</code> 安装会导致错误，因此需要 <strong>按顺序进行安装</strong>。</p></li></ul><h4 id="EPEL-仓库（需要-sudo-或-root-账户）"><a href="#EPEL-仓库（需要-sudo-或-root-账户）" class="headerlink" title="EPEL 仓库（需要 sudo 或 root 账户）"></a>EPEL 仓库（需要 <code>sudo</code> 或 root 账户）</h4><p>EPEL 是由 <strong>Fedora</strong> 社区维护的一个额外的软件仓库，专门为 RHEL 和 CentOS 提供额外的软件包。默认情况下，RHEL 和 CentOS 的官方仓库只包含基本的软件包，很多流行的第三方软件包并不包括在其中。而 EPEL 仓库则包含了大量的额外软件包，这些软件包经过测试，适用于 RHEL 和 CentOS 系统。通过启用 EPEL 仓库，可以访问到很多 <strong>非官方但稳定的软件包</strong>，比如开发工具、网络工具、数据库、Web 服务器、数据分析工具等。</p><p><code>yum install -y epel-release</code> 这个命令用于 <strong>CentOS</strong>、<strong>Red Hat</strong> 和其他基于 RHEL（Red Hat Enterprise Linux）的 Linux 发行版上，它的作用是安装 <strong>EPEL（Extra Packages for Enterprise Linux）</strong> 仓库的配置包。<strong>通常有需要的包安装不上和包不在默认仓库中可以使用（多存在虚拟机）。</strong></p><p>假设想安装 <code>htop</code>，这是一个用于查看系统资源使用情况的命令行工具。在 CentOS 中，<code>htop</code> 不在默认仓库中，但它可以在 EPEL 仓库中找到。启用 EPEL 仓库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y epel-release</span><br></pre></td></tr></table></figure><p>然后，可以通过 <code>yum</code> 安装 <code>htop</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install htop</span><br></pre></td></tr></table></figure><h4 id="卸载软件"><a href="#卸载软件" class="headerlink" title="卸载软件"></a>卸载软件</h4><p>卸载命令：要卸载已安装的软件包（如 <code>lrzsz</code>），可以使用以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> yum remove lrzsz</span><br></pre></td></tr></table></figure><h4 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h4><p>如果遇到 <code>yum</code> 相关的错误，需要根据具体的错误信息进行搜索和解决。<code>yum</code> 的错误原因可能有很多种，具体的解决办法可以通过错误信息来判断。</p><blockquote><p>  [!NOTE]</p><p>  <strong>一些好玩软件：</strong></p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y sl</span><br></pre></td></tr></table></figure><p>  效果（命令：<code>sl</code>）：</p><p>  <img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250309134404605.png"></p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install cowsay</span><br></pre></td></tr></table></figure><p>  效果（<code>cowsay “你是一个好人”</code>）：</p><p>  <img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250309134740648.png" alt="image-20250309134740567"></p></blockquote><hr><h2 id="Linux-生态"><a href="#Linux-生态" class="headerlink" title="Linux 生态"></a>Linux 生态</h2><p><strong>1. 开源不等于免费</strong></p><p>开源软件本身是免费提供源代码的，但这并不意味着所有相关的服务、支持和维护都是免费的。许多公司选择开源作为其商业战略的一部分，以吸引更多的用户、开发者或合作伙伴，但背后的成本往往在其他地方。</p><ul><li><strong>技术支持</strong>：开源软件往往需要专业的技术支持和定制化服务。这些服务通常是收费的。</li><li><strong>培训和咨询</strong>：一些开源软件的公司可能提供培训、技术咨询、系统集成等服务，这些都需要付费。</li><li><strong>维护和更新</strong>：开源项目需要持续的开发和维护。虽然代码本身是开放的，但公司通常会雇佣开发人员来维护代码、修复漏洞、添加新特性，这也是一种商业成本。</li></ul><p><strong>2. 吸引用户并从中盈利</strong></p><p>很多公司选择开源是为了吸引广泛的用户基础和社区支持，积累用户基础，然后通过向大公司、企业用户提供高级功能或支持来实现盈利。但他们通常会通过提供增值服务来实现盈利。这些增值服务可能包括：</p><ul><li><strong>云服务</strong>：它们的核心技术是开源的，但公司通过提供托管服务（例如容器编排平台）来盈利。</li><li><strong>专业版</strong>：许多开源项目会提供免费的社区版和付费的企业版。企业版通常包含额外的功能、更高的性能或专属的客户支持服务。</li></ul><p><strong>3. 营销和品牌建设</strong></p><p>开源作为一种商业战略，往往有助于品牌的建立和市场份额的扩展。通过开源，企业能够让更多的开发者和技术人员接触到他们的产品，从而建立品牌认知度，进而吸引更多客户或合作伙伴。然而，这种营销策略本身也需要大量的投入：</p><ul><li><strong>社区建设</strong>：开源项目需要社区的支持，而建立一个活跃的社区需要时间、资金和人员投入。</li><li><strong>文档和教程</strong>：为了让用户能够有效使用开源软件，企业往往需要投入大量资源制作文档、教程、示例代码和开发工具。</li><li><strong>开发者生态系统</strong>：很多公司会通过开源建立强大的开发者生态系统，这样可以在未来通过收取支持、咨询费用、举办培训等方式获利。</li></ul><p><strong>4. 间接盈利和市场控制</strong></p><p>有些公司可能不会直接从开源软件本身盈利，而是通过开源获得更多的市场控制权或客户资源。例如：</p><ul><li><strong>市场领导地位</strong>：通过开源，某家公司可以在某一领域建立市场领导地位，使得其他公司不得不采用他们的产品或服务，间接创造盈利机会。</li><li><strong>数据和分析</strong>：通过开源，企业可以获得大量的使用数据和反馈，这有助于他们改进产品，甚至为其其他商业产品提供数据支持和创新。</li></ul><p><strong>5. 开源的潜在成本</strong></p><ul><li><strong>竞争压力</strong>：开源可能会增加市场上的竞争，因为一旦源代码公开，任何人都可以修改并重用代码，从而可能影响原公司的市场份额。</li><li><strong>开发和维护成本</strong>：持续开发和维护开源项目需要大量的人力和时间，尤其是当项目规模和社区活跃度增加时，这可能变成一项昂贵的长期投资。</li></ul><p>&#x3D;&#x3D;开源软件是一种非常有效的商业战略，能够吸引大量用户并建立广泛的社区基础，但背后的成本往往是隐性的。虽然软件本身免费，但从商业角度来看，开源并不等于廉价，相关的技术支持、增值服务、品牌推广、社区建设和持续维护等方面的投入都可能让开源项目变得非常昂贵。&#x3D;&#x3D;</p><p>&#x3D;&#x3D;一个好的 Linux 软件生态应具备 <strong>丰富的软件选择、高效的包管理、稳定的版本、活跃的社区支持、良好的硬件兼容性、完善的安全机制和高度的灵活性</strong>。这样的生态能够为用户提供 <strong>易用、稳定、安全且自由</strong> 的操作环境，同时吸引更多开发者和用户参与，形成良性循环。&#x3D;&#x3D;</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>005 权限的理解</title>
      <link href="/posts/35315.html"/>
      <url>/posts/35315.html</url>
      
        <content type="html"><![CDATA[<h2 id="shell-命令以及运行原理"><a href="#shell-命令以及运行原理" class="headerlink" title="shell 命令以及运行原理"></a>shell 命令以及运行原理</h2><h3 id="1-Shell-是什么？"><a href="#1-Shell-是什么？" class="headerlink" title="1. Shell 是什么？"></a>1. Shell 是什么？</h3><p><strong>Shell 是用户与操作系统内核（Kernel）之间的“翻译官”。</strong>  </p><p>你可以把操作系统内核想象成一个国家的总统（Kernel），他直接管理国家资源（CPU、内存、磁盘等）。但普通人（用户）无法直接和总统对话，必须通过一个“秘书”（Shell）来传达需求。  </p><ul><li><strong>用户通过 Shell 输入命令</strong>（比如 <code>ls</code>、<code>cd</code>）。  </li><li><strong>Shell 将命令“翻译”成内核能理解的指令</strong>，交给内核执行。  </li><li><strong>内核处理完成后，结果再通过 Shell 返回给用户</strong>。</li></ul><h3 id="2-为什么不能直接操作内核？"><a href="#2-为什么不能直接操作内核？" class="headerlink" title="2. 为什么不能直接操作内核？"></a>2. 为什么不能直接操作内核？</h3><ul><li><strong>内核是操作系统的核心，直接操作风险极高</strong>。比如，直接让内核删除某个文件，就像让总统亲自去处理一个普通任务——虽然高效但风险极高，一旦出错可能导致系统崩溃。</li><li><strong>Shell 的存在是为了安全和易用</strong>：  <ul><li>用户无需理解底层硬件细节（比如如何读写磁盘）。  </li><li>Shell 通过权限控制和语法检查，避免用户误操作导致系统崩溃。</li></ul></li></ul><hr><h3 id="3-Shell-的“媒婆”比喻"><a href="#3-Shell-的“媒婆”比喻" class="headerlink" title="3. Shell 的“媒婆”比喻"></a>3. Shell 的“媒婆”比喻</h3><p><strong>Shell 是“媒婆”，内核是“村花小花”</strong>：你想追求小花（让内核干活），但不好意思直接开口（直接操作内核）。于是你找媒婆王婆（Shell）帮忙：  </p><ul><li>你告诉王婆需求（输入命令）。  </li><li>王婆转达给小花（Shell 解析命令并调用内核）。  </li><li>小花办好后，王婆再把结果告诉你（Shell 返回输出）。</li></ul><p><strong>媒婆的作用</strong>：  </p><ul><li><strong>翻译需求</strong>：用户说“想送花”，媒婆翻译成小花能理解的“执行送花程序”。  </li><li><strong>过滤错误</strong>：用户说“送一车榴莲”，媒婆会提醒“榴莲不在允许的礼物列表”（语法错误提示）。  </li><li><strong>权限检查</strong>：用户想进小花家的后院（系统敏感目录），媒婆会核实身份（权限验证）。</li></ul><p><strong>为什么必须通过媒婆？直接表白行不行？（<em>同为什么不能直接操作内核</em>）</strong></p><ul><li><strong>直接操作内核的风险</strong>：  <ul><li>用户可能说错话（输入错误命令），导致小花误解（系统崩溃）。  </li><li>用户可能要求不合理（删除系统关键文件），小花直接拒绝（权限不足）。</li></ul></li><li><strong>媒婆的安全保障</strong>：  <ul><li><strong>权限控制</strong>：媒婆会检查用户身份，比如普通用户不能修改系统配置（<code>sudo</code> 提权需要密码）。  </li><li><strong>错误拦截</strong>：用户输入“删库跑路”，媒婆会反问“你确定吗？”（<code>rm -rf /</code> 前的确认提示）。</li></ul></li></ul><p><strong>如果媒婆罢工了（Shell 崩溃）？</strong></p><ul><li><strong>用户会陷入沉默</strong>：无法与小花沟通，只能重启终端（找新媒婆）。  </li><li><strong>内核依然在运行</strong>：小花继续管理村庄，但用户无法直接互动。  </li><li><strong>解决方案</strong>：  <ul><li>使用备用媒婆（不同 Shell 类型：Bash、Zsh、Fish）。  </li><li>通过远程媒婆（SSH 连接）继续工作。</li></ul></li></ul><p><strong>终极金句</strong>：  </p><blockquote><p>没有媒婆的牵线，程序员的爱情（操作内核）将寸步难行；<br>没有 Shell 的翻译，用户与内核的对话将鸡同鸭讲。</p></blockquote><hr><h3 id="4-图形界面（GUI）也是-Shell？"><a href="#4-图形界面（GUI）也是-Shell？" class="headerlink" title="4. 图形界面（GUI）也是 Shell？"></a>4. 图形界面（GUI）也是 Shell？</h3><ul><li><strong>无论是命令行（CLI）还是图形界面（GUI），本质都是用户与内核的中介</strong>。  <ul><li><strong>Windows 的 GUI</strong>：双击图标 → 图形界面程序调用内核完成任务。  </li><li><strong>Linux 的 Shell</strong>：输入命令 → Shell 调用内核完成任务。</li></ul></li><li><strong>区别在于交互方式</strong>：  <ul><li>CLI 更高效，适合程序员和自动化脚本。  </li><li>GUI 更直观，适合普通用户。</li></ul></li></ul><h3 id="5-Shell-的高级功能"><a href="#5-Shell-的高级功能" class="headerlink" title="5. Shell 的高级功能"></a>5. Shell 的高级功能</h3><ul><li><strong>脚本编程</strong>：将多个命令写成脚本，一键执行复杂任务。  </li><li><strong>管道（<code>|</code>）</strong>：将一个命令的输出作为另一个命令的输入。例如：<code>ls | grep .txt</code>（列出所有文件，再过滤出 <code>.txt</code> 文件）。  </li><li><strong>重定向（<code>&gt;</code>、<code>&gt;&gt;</code>）</strong>：将命令结果保存到文件。例如：<code>ls &gt; files.txt</code>（将文件列表保存到 <code>files.txt</code>）。</li></ul><hr><h2 id="Linux-权限的概念"><a href="#Linux-权限的概念" class="headerlink" title="Linux 权限的概念"></a>Linux 权限的概念</h2><h3 id="一、用户类型详解"><a href="#一、用户类型详解" class="headerlink" title="一、用户类型详解"></a>一、用户类型详解</h3><h4 id="1-超级用户（root）"><a href="#1-超级用户（root）" class="headerlink" title="1. 超级用户（root）"></a>1. 超级用户（root）</h4><ul><li><strong>权限</strong>：拥有系统的最高权限，可以执行任何操作。包括安装、删除软件、修改系统设置、删除系统文件等危险行为。操作不当可能导致系统崩溃。</li><li><strong>提示符</strong>：<code>#</code>（如 <code>[root@server ~]#</code>），在命令行中，<code>#</code> 表示当前是 root 用户。</li><li><strong>默认路径</strong>：<code>/root</code>，这是 root 用户的家目录。</li><li><strong>危险提示</strong>：建议平时使用普通用户，而非 root 用户，避免误操作导致的系统崩溃或损坏。</li></ul><h4 id="2-普通用户"><a href="#2-普通用户" class="headerlink" title="2. 普通用户"></a>2. 普通用户</h4><ul><li><strong>权限</strong>：只能访问和操作自己的文件目录（默认在 <code>/home/用户名</code> 下），以及有限的系统资源。无法修改系统配置或执行需要高权限的操作。</li><li><strong>提示符</strong>：<code>$</code>（如 <code>[user@server ~]$</code>），表示当前是普通用户。</li><li><strong>默认路径</strong>：<code>/home/用户名</code>，每个普通用户都会有自己的家目录。</li><li><strong>优势</strong>：使用普通用户更安全，避免误操作破坏系统。</li></ul><h3 id="二、用户切换操作详解"><a href="#二、用户切换操作详解" class="headerlink" title="二、用户切换操作详解"></a>二、用户切换操作详解</h3><h4 id="1-su-命令-——-切换用户的命令。"><a href="#1-su-命令-——-切换用户的命令。" class="headerlink" title="1. su 命令 —— 切换用户的命令。"></a>1. <code>su</code> 命令 —— 切换用户的命令。</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su [选项] [用户名]</span><br></pre></td></tr></table></figure><ul><li><strong>不带参数</strong>：默认切换到 root 用户（需要输入 root 密码）。</li><li><strong>带用户名</strong>：切换到指定的用户（需要输入目标用户密码）。</li></ul><p><strong>具体场景（注意各自切换所要输入的密码）：</strong></p><ol><li><p><strong>普通用户 → root</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[user@server ~]$ su -</span><br><span class="line">Password:  <span class="comment"># 输入 root 密码</span></span><br><span class="line">[root@server ~]#  <span class="comment"># 成功切换到 root</span></span><br></pre></td></tr></table></figure></li><li><p><strong>root → 普通用户</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@server ~]# su - user</span><br><span class="line">[user@server ~]$  <span class="comment"># 成功切换到普通用户 user</span></span><br></pre></td></tr></table></figure></li><li><p><strong>普通用户 → 其他普通用户</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[user1@server ~]$ su - user2</span><br><span class="line">Password:  <span class="comment"># 输入 user2 密码</span></span><br><span class="line">[user2@server ~]$  <span class="comment"># 成功切换到 user2 用户</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="2-su-与-su-的区别"><a href="#2-su-与-su-的区别" class="headerlink" title="2. su 与 su - 的区别"></a>2. <code>su</code> 与 <code>su -</code> 的区别</h4><table><thead><tr><th>命令</th><th>环境变量</th><th>工作目录</th><th>使用场景</th></tr></thead><tbody><tr><td><code>su</code></td><td>保留当前环境</td><td>当前目录</td><td>临时执行少量命令</td></tr><tr><td><code>su -</code></td><td>重新加载用户环境</td><td>目标用户家目录</td><td>需要完整用户环境时</td></tr></tbody></table><p><strong>示例对比：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 su</span></span><br><span class="line">[root@server /]# su user</span><br><span class="line">[user@server /]$ <span class="built_in">pwd</span></span><br><span class="line">/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 su -</span></span><br><span class="line">[root@server /]# su - user</span><br><span class="line">[user@server ~]$ <span class="built_in">pwd</span></span><br><span class="line">/home/user</span><br></pre></td></tr></table></figure><h3 id="三、sudo-基础权限配置（了解，后面详讲）"><a href="#三、sudo-基础权限配置（了解，后面详讲）" class="headerlink" title="三、sudo 基础权限配置（了解，后面详讲）"></a>三、sudo 基础权限配置（了解，后面详讲）</h3><h4 id="1-sudo-基础"><a href="#1-sudo-基础" class="headerlink" title="1. sudo 基础"></a>1. sudo 基础</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> &lt;命令&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>作用</strong>：使用 <code>sudo</code> 命令，普通用户可以临时以 root 权限执行特权命令。</li><li><strong>要求</strong>：用户必须在 <code>/etc/sudoers</code> 文件中有权限设置。</li></ul><h4 id="2-配置-sudo-权限（这是一种方法，可以先了解，不建议现在进行配置）"><a href="#2-配置-sudo-权限（这是一种方法，可以先了解，不建议现在进行配置）" class="headerlink" title="2. 配置 sudo 权限（这是一种方法，可以先了解，不建议现在进行配置）"></a>2. 配置 sudo 权限（这是一种方法，可以先了解，不建议现在进行配置）</h4><p>配置 <code>sudo</code> 权限时，建议使用 <code>visudo</code> 命令，因为它可以在保存前检查语法错误，避免不小心出错。</p><ol><li><p><strong>切换到 root 用户</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su -  <span class="comment"># 切换到 root</span></span><br></pre></td></tr></table></figure></li><li><p><strong>使用 visudo 编辑 <code>/etc/sudoers</code> 文件</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">visudo  <span class="comment"># 进入编辑模式，自动检查语法</span></span><br></pre></td></tr></table></figure></li><li><p><strong>配置示例</strong>：</p><ul><li><p>允许普通用户 <code>user</code> 执行所有命令，且无需密码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user    ALL=(ALL)       NOPASSWD: ALL</span><br></pre></td></tr></table></figure></li><li><p>允许 <code>wheel</code> 组的成员使用 <code>sudo</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%wheel  ALL=(ALL)       ALL</span><br></pre></td></tr></table></figure></li></ul></li></ol><h4 id="3-验证配置"><a href="#3-验证配置" class="headerlink" title="3. 验证配置"></a>3. 验证配置</h4><p>如果配置成功，可以通过 <code>sudo</code> 执行命令来验证：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[user@server ~]$ <span class="built_in">sudo</span> systemctl restart sshd</span><br><span class="line"><span class="comment"># 如果配置成功，可以执行命令而无需输入密码</span></span><br></pre></td></tr></table></figure><h4 id="4-典型错误处理"><a href="#4-典型错误处理" class="headerlink" title="4. 典型错误处理"></a>4. 典型错误处理</h4><p>当用户不在 <code>sudoers</code> 文件中时，可能会看到以下错误：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user is not <span class="keyword">in</span> the sudoers file. This incident will be reported.</span><br></pre></td></tr></table></figure><p><strong>解决方法</strong>：</p><ol><li><p>切换到 root 用户：<code>su -</code></p></li><li><p>将用户加入 <code>wheel</code> 组：<code>usermod -aG wheel user</code></p></li><li><p>确保 <code>/etc/sudoers</code> 文件中有以下配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%wheel  ALL=(ALL)       ALL</span><br></pre></td></tr></table></figure></li></ol><h3 id="四、最佳实践建议"><a href="#四、最佳实践建议" class="headerlink" title="&#x3D;&#x3D;四、最佳实践建议&#x3D;&#x3D;"></a>&#x3D;&#x3D;四、最佳实践建议&#x3D;&#x3D;</h3><ol><li><strong>日常使用普通用户</strong>：避免直接以 root 用户登录，普通用户更安全。使用 <code>sudo</code> 执行特权命令。</li><li><strong>重要操作前备份</strong>：在执行任何高风险操作时，尤其是以 root 权限进行修改时，要确保有备份。</li><li><strong>sudo 权限最小化</strong>：只为需要的用户分配 <code>sudo</code> 权限，避免随意赋予 <code>NOPASSWD: ALL</code> 权限。</li><li>会话管理：<ul><li>进入 root 环境后，要及时使用 <code>exit</code> 或 <code>Ctrl+D</code> 退出。</li><li>使用 <code>whoami</code> 命令确认当前用户身份，避免误操作。</li></ul></li></ol><h3 id="五、操作流程图解"><a href="#五、操作流程图解" class="headerlink" title="五、操作流程图解"></a>五、操作流程图解</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">普通用户环境</span><br><span class="line">   │</span><br><span class="line">   ├─ 需要执行特权命令 → sudo &lt;命令&gt;</span><br><span class="line">   │     ├─ 有权限 → 执行成功</span><br><span class="line">   │     └─ 无权限 → 拒绝执行</span><br><span class="line">   │</span><br><span class="line">   └─ 需要切换用户 → su/su -</span><br><span class="line">         ├─ 切换到 root → 输入 root 密码</span><br><span class="line">         └─ 切换其他用户 → 输入目标用户密码</span><br></pre></td></tr></table></figure><hr><h2 id="Linux-权限管理"><a href="#Linux-权限管理" class="headerlink" title="Linux 权限管理"></a>Linux 权限管理</h2><h3 id="一、Linux-权限管理"><a href="#一、Linux-权限管理" class="headerlink" title="一、Linux 权限管理"></a>一、Linux 权限管理</h3><p>Linux 系统中的权限管理决定了文件和目录的访问控制。权限管理涉及两个主要方面：</p><ol><li><strong>权限认证</strong>：确定谁（用户）可以访问文件或目录。</li><li><strong>权限类型</strong>：确定可以对文件或目录执行什么操作（<strong><code>读、写、执行</code></strong>）。</li></ol><h3 id="二、文件的权限和文件属性"><a href="#二、文件的权限和文件属性" class="headerlink" title="二、文件的权限和文件属性"></a>二、文件的权限和文件属性</h3><h4 id="1-文件访问者的分类（“人”）"><a href="#1-文件访问者的分类（“人”）" class="headerlink" title="1. 文件访问者的分类（“人”）"></a>1. 文件访问者的分类（“<code>人</code>”）</h4><p>权限分为三类：</p><ul><li><strong><code>u</code></strong> (User)：文件或目录的 <strong><code>所有者</code></strong>&#x2F;<strong><code>拥有者</code></strong>。即文件的创建者或被赋予所有权的用户。</li><li><strong><code>g</code></strong> (Group)：文件或目录的 <strong><code>所属组</code></strong> 的用户。即拥有该文件或目录的同组成员。</li><li><strong><code>o</code></strong> (Others)：<strong><code>其他用户</code></strong>，指的是既不是文件所有者，也不属于文件所属组的用户。</li></ul><h4 id="2-权限表示方式"><a href="#2-权限表示方式" class="headerlink" title="2. 权限表示方式"></a>2. 权限表示方式</h4><p>举个栗子，并逐一解析：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">drwxrwxr-x 2 hcc hcc 4096 Feb  3 20:26 temp</span><br><span class="line"><span class="comment"># 怎么看：</span></span><br><span class="line">drwxrwxr-x（1 | 9）/（1 | 3|3|3）</span><br><span class="line"><span class="comment"># drwxrwxr-x 对应着 &lt;file-type&gt;&lt;user-permissions&gt;&lt;group-permissions&gt;&lt;other-permissions&gt;</span></span><br></pre></td></tr></table></figure><ol><li><strong>文件类型</strong>（第一个字符）：<ul><li><strong>d</strong>：表示这是一个目录文件。</li></ul></li><li><strong>文件权限</strong>（后面的 9 个字符 3 位一看）：<ul><li><code>rwx</code>：表示 <strong>用户（文件所有者）</strong> 具有读、写、执行权限。</li><li><code>rwx</code>：表示 <strong>组用户</strong> 具有读、写、执行权限。</li><li><code>r-x</code>：表示 <strong>其他用户</strong> 具有读和执行权限，但没有写权限。</li></ul></li><li><strong>其他信息</strong>：<ul><li><code>2</code>：表示该目录下的硬链接数量。</li><li><code>hcc</code> <strong>（前一个）</strong>：表示文件的 <strong>拥有者</strong>（User）是 <code>hcc</code>。</li><li><code>hcc</code> <strong>（后一个）</strong>：表示文件的 <strong>所属组</strong>（Group）是 <code>hcc</code>。</li><li><code>4096</code>：表示该文件（或目录）的大小（单位为字节）。</li><li><code>Feb  3 20:26</code>：表示文件的最后修改时间。</li><li><code>temp</code>：表示文件的名称。</li></ul></li></ol><h4 id="3-文件类型和访问权限（“事物属性”）"><a href="#3-文件类型和访问权限（“事物属性”）" class="headerlink" title="3. 文件类型和访问权限（“事物属性”）"></a>3. 文件类型和访问权限（“事物属性”）</h4><p><strong>文件类型（第一位字符）：</strong></p><table><thead><tr><th align="center">文件类型字符</th><th>含义</th><th>示例</th></tr></thead><tbody><tr><td align="center"><strong><code>d</code></strong></td><td><strong>目录文件（Directory）</strong></td><td><code>drwxr-xr-x</code>（表示这是一个目录文件）</td></tr><tr><td align="center"><strong><code>-</code></strong></td><td><strong>普通文件（Regular file）</strong></td><td><code>-rwxr-xr-x</code>（表示这是一个普通文件）</td></tr><tr><td align="center"><strong>l</strong></td><td>软链接（Symbolic link）</td><td><code>lrwxrwxrwx</code>（类似于 Windows 的快捷方式）</td></tr><tr><td align="center"><strong>b</strong></td><td>块设备文件（Block device file）</td><td><code>brw-rw----</code>（如硬盘、光驱等）</td></tr><tr><td align="center"><strong>p</strong></td><td>管道文件（Pipe file）</td><td><code>prw-r--r--</code>（用于进程间通信）</td></tr><tr><td align="center"><strong>c</strong></td><td>字符设备文件（Character device file）</td><td><code>crw-rw----</code>（如终端设备、打印机等）</td></tr><tr><td align="center"><strong>s</strong></td><td>套接口文件（Socket file）</td><td><code>srwxrwxrwx</code>（用于网络通信等）</td></tr></tbody></table><p><strong>权限（后三位字符）：</strong></p><table><thead><tr><th align="center">权限字符</th><th>含义</th><th align="center">对应数字</th><th>说明</th></tr></thead><tbody><tr><td align="center"><strong>r</strong></td><td>读权限（Read）</td><td align="center">4</td><td>对文件：允许读取文件内容；对目录：允许列出目录中的文件。</td></tr><tr><td align="center"><strong>w</strong></td><td>写权限（Write）</td><td align="center">2</td><td>对文件：允许修改文件内容；对目录：允许创建、删除、移动目录中的文件。</td></tr><tr><td align="center"><strong>x</strong></td><td>执行权限（Execute）</td><td align="center">1</td><td>对文件：允许执行文件；对目录：允许进入该目录。</td></tr><tr><td align="center"><strong>-</strong></td><td>没有权限</td><td align="center">0</td><td>表示没有该项权限。</td></tr></tbody></table><p><strong>权限的组合（后三位字符表示权限）：</strong></p><table><thead><tr><th align="center">权限组合</th><th>含义</th><th align="center">数字表示</th><th>说明</th></tr></thead><tbody><tr><td align="center"><strong>rwx</strong></td><td>读、写、执行权限（可完全访问）</td><td align="center">7</td><td>用户&#x2F;组&#x2F;其他均有读、写、执行权限。</td></tr><tr><td align="center"><strong>rw-</strong></td><td>读、写权限（没有执行权限）</td><td align="center">6</td><td>用户&#x2F;组&#x2F;其他可以读取和修改文件，但不能执行。</td></tr><tr><td align="center"><strong>r-x</strong></td><td>读、执行权限（没有写权限）</td><td align="center">5</td><td>用户&#x2F;组&#x2F;其他可以读取和执行文件，但不能修改。</td></tr><tr><td align="center"><strong>r–</strong></td><td>只有读权限</td><td align="center">4</td><td>用户&#x2F;组&#x2F;其他只能读取文件，无法修改或执行。</td></tr><tr><td align="center"><strong>wx-</strong></td><td>写、执行权限（没有读权限）</td><td align="center">3</td><td>用户&#x2F;组&#x2F;其他可以修改文件并执行文件，但不能读取文件。</td></tr><tr><td align="center"><strong>x–</strong></td><td>只有执行权限</td><td align="center">1</td><td>用户&#x2F;组&#x2F;其他只能执行文件，无法读取或修改文件。</td></tr><tr><td align="center"><strong>—</strong></td><td>没有任何权限</td><td align="center">0</td><td>用户&#x2F;组&#x2F;其他没有任何权限。</td></tr></tbody></table><p>每个权限都有两个状态：<strong>有权限</strong> 或 <strong>没有权限</strong>，这恰好对应了二进制的 <code>1</code> 和 <code>0</code>，所以数字表示的由来是二进制：</p><table><thead><tr><th align="center">权限符号（读写执行）</th><th align="center">八进制（数字表示）</th><th align="center">二进制</th></tr></thead><tbody><tr><td align="center">r</td><td align="center">4</td><td align="center">100</td></tr><tr><td align="center">w</td><td align="center">2</td><td align="center">010</td></tr><tr><td align="center">x</td><td align="center">1</td><td align="center">001</td></tr><tr><td align="center">rw</td><td align="center">6</td><td align="center">110</td></tr><tr><td align="center">rx</td><td align="center">5</td><td align="center">101</td></tr><tr><td align="center">wx</td><td align="center">3</td><td align="center">011</td></tr><tr><td align="center">rwx</td><td align="center">7</td><td align="center">111</td></tr><tr><td align="center">—</td><td align="center">0</td><td align="center">000</td></tr></tbody></table><hr><h3 id="三、文件访问权限的相关设置方法"><a href="#三、文件访问权限的相关设置方法" class="headerlink" title="三、文件访问权限的相关设置方法"></a>三、文件访问权限的相关设置方法</h3><h4 id="1-chmod-设置文件的访问权限"><a href="#1-chmod-设置文件的访问权限" class="headerlink" title="1. chmod - 设置文件的访问权限"></a>1. <code>chmod</code> - 设置文件的访问权限</h4><p><code>chmod</code> 命令用于设置文件的访问权限。它允许你改变文件或目录的权限，分为两种方式：使用符号表示法和使用八进制表示法。</p><ul><li><strong>普通用户</strong>：普通用户只能修改自己拥有的文件或目录的权限。如果普通用户尝试修改其他用户的文件或目录权限，会提示 <code>Permission denied</code>（权限被拒绝）。</li><li><strong>root 用户</strong>：<code>root</code> 用户是系统管理员，具有所有权限，因此 <code>root</code> 可以修改任何文件或目录的权限。</li></ul><p><strong>语法格式：<code>chmod [参数] 权限 文件名</code></strong></p><p><strong>常用选项：<code>-R</code>：递归地修改目录和其中所有文件的权限。</strong></p><p><strong>权限的表示方法：</strong></p><table><thead><tr><th align="center">符号</th><th>描述</th></tr></thead><tbody><tr><td align="center"><code>+</code></td><td>向权限范围增加权限</td></tr><tr><td align="center"><code>-</code></td><td>向权限范围取消权限</td></tr><tr><td align="center"><code>=</code></td><td>设置权限，覆盖现有权限</td></tr></tbody></table><p><strong>用户符号：</strong></p><table><thead><tr><th align="center">符号</th><th>描述</th></tr></thead><tbody><tr><td align="center"><code>u</code></td><td>拥有者（user）</td></tr><tr><td align="center"><code>g</code></td><td>所属组（group）</td></tr><tr><td align="center"><code>o</code></td><td>其他用户（others）</td></tr><tr><td align="center"><code>a</code></td><td>所有用户（all）</td></tr></tbody></table><p><strong>权限符号：</strong></p><table><thead><tr><th align="center">符号</th><th>描述</th></tr></thead><tbody><tr><td align="center"><code>r</code></td><td>读取权限（read）</td></tr><tr><td align="center"><code>w</code></td><td>写入权限（write）</td></tr><tr><td align="center"><code>x</code></td><td>执行权限（execute）</td></tr></tbody></table><p><strong>示例：</strong></p><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>chmod u+w /home/abc.txt</code></td><td>给文件 <code>/home/abc.txt</code> 的拥有者添加写权限。</td></tr><tr><td><code>chmod o-x /home/abc.txt</code></td><td>去掉其他用户的执行权限。</td></tr><tr><td><code>chmod a=x /home/abc.txt</code></td><td>给所有用户赋予执行权限，其他权限被去除。</td></tr></tbody></table><h4 id="八进制表示法："><a href="#八进制表示法：" class="headerlink" title="八进制表示法："></a>八进制表示法：</h4><table><thead><tr><th align="center">权限组合</th><th align="center">八进制数字</th><th>说明</th></tr></thead><tbody><tr><td align="center"><code>rwx</code></td><td align="center">7</td><td>读取、写入、执行权限（4+2+1）</td></tr><tr><td align="center"><code>rw-</code></td><td align="center">6</td><td>读取、写入权限（4+2）</td></tr><tr><td align="center"><code>r-x</code></td><td align="center">5</td><td>读取、执行权限（4+1）</td></tr><tr><td align="center"><code>r--</code></td><td align="center">4</td><td>读取权限（4）</td></tr><tr><td align="center"><code>wx-</code></td><td align="center">3</td><td>写入、执行权限（2+1）</td></tr><tr><td align="center"><code>w--</code></td><td align="center">2</td><td>写入权限（2）</td></tr><tr><td align="center"><code>x--</code></td><td align="center">1</td><td>执行权限（1）</td></tr><tr><td align="center"><code>---</code></td><td align="center">0</td><td>无权限</td></tr></tbody></table><p><strong>示例：</strong></p><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>chmod 664 /home/abc.txt</code></td><td>设置文件权限为 <code>rw-rw-r--</code>，即拥有者和所属组有读写权限，其他用户只有读权限。</td></tr><tr><td><code>chmod 640 /home/abc.txt</code></td><td>设置文件权限为 <code>rw-r-----</code>，即拥有者有读写权限，拥有者有读写权限，所属组有读权限，其他用户没有权限。</td></tr></tbody></table><hr><h4 id="2-chown-修改文件的拥有者"><a href="#2-chown-修改文件的拥有者" class="headerlink" title="2. chown - 修改文件的拥有者"></a>2. <code>chown</code> - 修改文件的拥有者</h4><p><code>chown</code> 命令用于修改文件的所有者和所属组。</p><ul><li><strong>普通用户</strong>：普通用户只能更改自己拥有的文件的所有者。如果尝试更改其他用户的文件或目录的拥有者，普通用户会看到 <code>Permission denied</code>。</li><li><strong>root 用户</strong>：<code>root</code> 用户能够修改任何文件或目录的拥有者，不受任何限制。</li></ul><p><strong>语法格式：<code>chown [参数] 用户名 文件名</code></strong></p><p><strong>常用选项：<code>-R</code>：递归地修改目录和其中所有文件的权限。</strong></p><p><strong>示例：</strong></p><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>chown user1 f1</code></td><td>将文件 <code>f1</code> 的拥有者更改为 <code>user1</code>。</td></tr><tr><td><code>chown -R user1 filegroup1</code></td><td>递归地将目录 <code>filegroup1</code> 及其子文件的所有者更改为 <code>user1</code>。</td></tr></tbody></table><hr><h4 id="3-chgrp-修改文件或目录的所属组"><a href="#3-chgrp-修改文件或目录的所属组" class="headerlink" title="3. chgrp - 修改文件或目录的所属组"></a>3. <code>chgrp</code> - 修改文件或目录的所属组</h4><p><code>chgrp</code> 命令用于修改文件或目录的所属组。</p><ul><li><strong>普通用户</strong>：普通用户只能更改自己拥有的文件或目录的所属组。如果尝试更改其他用户的文件或目录的所属组，则会提示 <code>Permission denied</code>。</li><li><strong>root 用户</strong>：<code>root</code> 用户可以修改任何文件或目录的所属组，无论该文件是否属于 <code>root</code> 或其他用户。</li></ul><p><strong>语法格式：<code>chgrp [参数] 用户组名 文件名</code></strong></p><p><strong>常用选项：<code>-R</code>：递归地修改目录和其中所有文件的权限。</strong></p><p><strong>示例：</strong></p><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>chgrp users /abc/f2</code></td><td>将文件 <code>/abc/f2</code> 的所属组更改为 <code>users</code>。</td></tr></tbody></table><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><table><thead><tr><th>操作类型</th><th>普通用户能否执行</th><th>root 用户能否执行</th><th>执行成功&#x2F;失败</th></tr></thead><tbody><tr><td><code>chmod</code> 修改权限</td><td>只能修改自己拥有的文件</td><td>可以修改任何文件</td><td>普通用户成功：文件属于自己；失败：<code>Permission denied</code></td></tr><tr><td><code>chown</code> 修改拥有者</td><td>只能修改自己拥有的文件</td><td>可以修改任何文件</td><td>普通用户成功：文件属于自己；失败：<code>Permission denied</code></td></tr><tr><td><code>chgrp</code> 修改所属组</td><td>只能修改自己拥有的文件</td><td>可以修改任何文件</td><td>普通用户成功：文件属于自己；失败：<code>Permission denied</code></td></tr></tbody></table><hr><h3 id="file-命令"><a href="#file-命令" class="headerlink" title="file 命令"></a><code>file</code> 命令</h3><p><code>file</code> 命令用于识别文件的类型。它会根据文件的内容、格式以及文件头部的标识来判断分析文件内部的结构来推测其类型，不依赖于文件的扩展名，非常有用。</p><p><strong>语法：<code>file [选项] 文件或目录...</code></strong></p><p><strong>常用选项</strong>：</p><ul><li><code>-c</code>：显示详细的执行过程，帮助你分析程序的执行情况。例如，它可以显示 <code>file</code> 命令如何判断文件类型，通常在调试时很有用。</li><li><code>-z</code>：尝试解压缩压缩文件，并分析压缩文件中的内容。如果你有一个 <code>.tar.gz</code> 或 <code>.zip</code> 文件，使用 <code>-z</code> 可以让 <code>file</code> 查看并识别压缩文件内部的内容类型。</li></ul><p><strong>示例</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">file test.txt      <span class="comment"># 输出 test.txt 文件的类型（如：ASCII text）</span></span><br><span class="line">file -z archive.gz <span class="comment"># 解压并识别压缩文件内容类型</span></span><br></pre></td></tr></table></figure><blockquote><h3 id="传道解惑"><a href="#传道解惑" class="headerlink" title="传道解惑"></a>传道解惑</h3><h4 id="Q1：起始权限问题：普通文件：664，目录文件：775，为什么我们创建文件的默认权限是我们现在看到的样子？"><a href="#Q1：起始权限问题：普通文件：664，目录文件：775，为什么我们创建文件的默认权限是我们现在看到的样子？" class="headerlink" title="Q1：起始权限问题：普通文件：664，目录文件：775，为什么我们创建文件的默认权限是我们现在看到的样子？"></a>Q1：起始权限问题：普通文件：664，目录文件：775，为什么我们创建文件的默认权限是我们现在看到的样子？</h4><p>默认权限的设置与 <strong>umask（文件创建权限掩码）</strong> 有关系，它控制了文件或目录在创建时默认的权限。我们创建普通文件和目录时，通常会看到不同的权限，这是因为操作系统使用了一种“减法”策略（<strong>最终权限 &#x3D; 起始权限 &amp; (~umask)</strong>），根据 <strong>umask</strong> 来修改文件和目录的默认权限。</p><p><strong>umask</strong> 决定了文件和目录创建时权限的“减法”规则，我们最终看到的其实是已经套公式算好的。</p><ul><li><strong>普通文件（664）</strong>：默认给普通文件的起始权限其实是 <code>666</code>，<code>666 &amp; (~0002)</code> → <code>666 &amp; 7754</code> &#x3D; <code>664</code>。</li><li><strong>目录文件（775）</strong>：默认给目录文件的起始权限其实是 <code>777</code>，<code>777 &amp; (~0002)</code> → <code>777 &amp; 7754</code> &#x3D; <code>775</code>。</li></ul><h3 id="umask-是什么？"><a href="#umask-是什么？" class="headerlink" title="umask 是什么？"></a>umask 是什么？</h3><p><code>umask</code> 是一个权限掩码，它定义了在文件或目录创建时，通过从系统的默认权限中 <strong>“去除”</strong> 权限来决定最终的权限。 <strong>umask 的值</strong> 表示哪些权限会被“去除”，而 <strong>最终权限</strong> 是通过使用按位与（<code>&amp;</code>）操作来计算的。</p><ul><li>默认的权限是固定的，即普通文件的起始权限为 <code>666</code>，目录的起始权限为 <code>777</code>。</li><li><code>umask</code> 用来“去除”权限，使用的规则是按位与：<strong>最终权限 &#x3D; 起始权限 &amp; (~umask)</strong>。</li><li><code>~umask</code> 是对 <code>umask</code> 值取反，即对 <code>umask</code> 中的每一位进行反转（0 变成 1，1 变成 0），然后与默认权限进行按位与运算。</li></ul><p>如果需要查看当前的 <strong>umask</strong> 值，可以运行 <code>umask</code> 命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="built_in">umask</span></span><br></pre></td></tr></table></figure><p><strong>常见的 umask 值</strong>：<code>umask</code> 的值虽然会显示 <code>0002</code>，<code>umask</code> 的四位数字中，第一位表示特殊权限（如粘滞位），后三位才是基本权限。但普通文件&#x2F;目录的默认权限计算时通常只关注后三位。常见的 <code>umask</code> 值：</p><table><thead><tr><th>umask 值</th><th>解释</th><th>结果权限（普通文件）</th><th>结果权限（目录文件）</th></tr></thead><tbody><tr><td><code>0002</code></td><td>所有者、组、其他用户都没有限制</td><td>664</td><td>775</td></tr><tr><td><code>0022</code></td><td>其他用户没有写权限</td><td>644</td><td>755</td></tr><tr><td><code>0077</code></td><td>只有文件拥有者有权限</td><td>600</td><td>700</td></tr></tbody></table><p><strong>umask 设置与效果</strong>：<strong>umask</strong> 的值会影响文件和目录的默认权限。当你修改 <code>umask</code> 时，操作系统会自动改变你创建的文件和目录的默认权限。</p><p>例如：如果设置 <code>umask 0022</code>，则：</p><ul><li>普通文件的权限会变为 <code>644</code>（去除其他用户的写权限）。</li><li>目录的权限会变为 <code>755</code>（去除其他用户的写权限）。</li></ul><p>可以通过以下命令查看和设置 <code>umask</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;# 查看当前 <span class="built_in">umask</span> 值</span><br><span class="line">&gt;<span class="built_in">umask</span></span><br><span class="line"></span><br><span class="line">&gt;# 设置 <span class="built_in">umask</span> 为 0022</span><br><span class="line">&gt;<span class="built_in">umask</span> 0022</span><br></pre></td></tr></table></figure><h3 id="Q2：关于文件权限-r-rw-1-a-a-的情况怎么解释？"><a href="#Q2：关于文件权限-r-rw-1-a-a-的情况怎么解释？" class="headerlink" title="Q2：关于文件权限 -r--rw---- 1 a a ... 的情况怎么解释？"></a>Q2：关于文件权限 <code>-r--rw---- 1 a a ...</code> 的情况怎么解释？</h3><p>在文件权限系统中，<strong>拥有者的权限</strong> 和 <strong>所属组的权限</strong> 是独立的，因此可能会出现拥有者的权限比所属组更少的情况。文件的权限可能是通过某些命令错误地配置的。例如，管理员或拥有者可能故意将拥有者的权限设置得比所属组的权限少。这种情况可能是在文件创建时，由于错误的 <code>chmod</code> 命令或文件权限管理不当造成的。当然也有可能是必须的，因为这种现象并非错误。</p><p><strong>关键点：拥有者权限和所属组权限独立</strong></p><ul><li><strong>拥有者权限（a）：</strong> 只能读取文件，但不能修改（没有写权限）。</li><li><strong>所属组权限（a 组）：</strong> 可以读写文件（<code>rw-</code>），但不具有执行权限。</li></ul><h4 id="权限判断顺序："><a href="#权限判断顺序：" class="headerlink" title="权限判断顺序："></a>权限判断顺序：</h4><p>在 Linux 系统中，<strong>在进行认证的时候只能选择一个角色进行认证</strong>，文件的权限是根据三种不同的身份来判断的：<strong>文件拥有者</strong>、<strong>文件所属组</strong> 和 <strong>其他用户</strong>。系统在判断文件权限时会先检查文件拥有者的权限，如果拥有者权限不足，再检查所属组的权限，最后才检查其他用户的权限。</p><ol><li><strong>文件拥有者权限</strong>（User 权限）：系统首先会检查当前操作用户是否是文件的拥有者，如果是，则优先使用文件拥有者的权限来进行访问判断。</li><li><strong>所属组权限</strong>（Group 权限）：如果当前用户不是文件的拥有者，但属于文件的所属组，则会检查文件所属组的权限。</li><li><strong>其他用户权限</strong>（Other 权限）：如果当前用户既不是文件的拥有者，也不属于文件的所属组，那么就会检查其他用户的权限。</li></ol><p><strong>解决方法</strong></p><ol><li><strong>检查文件的权限设置</strong>：首先确认文件的权限是如何设置的。如果文件的拥有者权限被误设为 <code>r--</code>，而所属组权限是 <code>rw-</code>，可以使用 <code>chmod</code> 修改文件的拥有者权限：</li></ol>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> u+w filename</span><br></pre></td></tr></table></figure><ol start="2"><li><p><strong>角色切换</strong>：如果你仅能选择一个角色进行认证，但需要更高权限来修改文件，考虑切换到具有更高权限的角色（例如通过 <code>sudo</code> 进行管理员认证）。</p></li><li><p><strong>文件所有权调整</strong>：如果你不是文件的拥有者，但需要进行修改，考虑使用 <code>chown</code> 或 <code>chgrp</code> 更改文件的拥有者或所属组，或者请求管理员为你添加权限。</p></li></ol></blockquote><hr><h2 id="目录的权限"><a href="#目录的权限" class="headerlink" title="目录的权限"></a>目录的权限</h2><p>理解目录权限的三个关键点：</p><ol><li><strong>可读权限（<code>r</code>）</strong>：<strong>决定是否允许我们查看指定目录下的文件内容。</strong> 如果没有读权限，即使目录本身是可执行的，用户也无法看到目录中的文件列表。例如，无法用 <code>ls</code> 查看该目录下的文件。</li><li><strong>可写权限（<code>w</code>）</strong>：<strong>决定是否允许我们在当前目录下进行创建、更改、<code>删除（主要）</code>。</strong> 如果没有写权限，用户就不能在该目录中创建新文件，不能删除文件，也不能重命名文件 &#x3D;&#x3D;（<strong>一个文件能否被删除，并不由文件本身决定，由这个文件所处的目录决定！</strong>）&#x3D;&#x3D;。</li><li><strong>可执行权限（<code>x</code>）</strong>：<strong>决定是否允许用户进入对应的目录！</strong> 如果一个目录没有执行权限，即使你有其他权限，也无法进入该目录进行任何操作。比如无法 <code>cd</code> 进入该目录。</li></ol><h3 id="权限细节及例子-——-想要保护多人-共享-文件数据"><a href="#权限细节及例子-——-想要保护多人-共享-文件数据" class="headerlink" title="权限细节及例子 —— 想要保护多人 共享 文件数据"></a>权限细节及例子 —— 想要保护多人 <code>共享</code> 文件数据</h3><p>假设用户 <strong>张三</strong> 在自己的目录下创建了一个文件 <code>temp</code>，并且给自己设置了文件权限（例如 <code>rw-r--r--</code>）。这意味着张三可以读写文件，而其他用户只能读取文件。看起来应该是其他用户不能删除 <code>temp</code> 文件，对吧？但是，实际上 <strong>其他用户仍然可以删除 <code>temp</code> 文件</strong>，即使他们没有写权限。这是因为文件的删除权限是由 <strong>目录的权限</strong> 决定的，而不是文件的权限。（张三在自己的文件夹里放了一本书（文件 temp），即使没有给其他人修改这本书的权限，如果他们对张三存放书的那个房间（目录）有写入权限，他们仍然能够把张三的书从房间里移除或删除。这看起来不太公平，因为张三并没有允许别人动他的东西）。</p><p>如果去掉了共享目录的 <code>w</code> 权限，张三同时也无法创建文件啦！共享目录，共享体现在哪里呢？</p><h3 id="解决方案：引入“粘滞位”"><a href="#解决方案：引入“粘滞位”" class="headerlink" title="解决方案：引入“粘滞位”"></a>解决方案：引入“粘滞位”</h3><p>为了避免一个用户删除其他用户创建的文件，Linux 引入了 <strong>粘滞位（sticky bit）</strong> 的概念。</p><p><strong>粘滞位（Sticky Bit）</strong> 是一个特殊的权限，用来限制在目录中删除文件的权限。具体来说，只有以下三类用户才能删除目录中的文件：</p><ol><li><strong>超级管理员（root）</strong>：<code>root</code> 用户可以删除任何文件，不受限制。</li><li><strong>目录的所有者</strong>：目录的拥有者可以删除该目录中的文件。</li><li><strong>文件的所有者</strong>：文件的拥有者可以删除自己创建的文件。</li></ol><p><strong>如何设置粘滞位？</strong> 可以使用 <code>chmod +t</code> 命令来给目录设置粘滞位：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> +t /path/to/directory</span><br></pre></td></tr></table></figure><p><strong>示例：</strong> 假设我们有一个目录 <code>/shared</code>，这是一个共享目录，所有用户都可以在其中创建文件。如果没有粘滞位，任何具有写权限的用户都可以删除目录中的文件，即使文件是由其他用户创建的。但如果我们给目录设置了粘滞位：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> +t /shared</span><br><span class="line">drwxrwxrwt    <span class="comment"># 粘滞位生效，末尾为 t</span></span><br></pre></td></tr></table></figure><p>设置了粘滞位后，只有以下三类用户可以删除文件：</p><ul><li><code>root</code> 用户可以删除目录中的任何文件。</li><li>该目录的所有者（例如管理员）可以删除文件。</li><li>文件的拥有者（例如，创建文件的用户）可以删除自己的文件。</li></ul><p>这样，即使其他用户拥有对目录的写权限，也无法删除其他用户创建的文件，增强了安全性。</p><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>目录权限：</strong></p><ol><li><strong>可读权限（<code>r</code>）</strong>：是否可以列出该目录中的文件。没有 <code>r</code> 权限，即使有 <code>x</code> 权限，也无法执行 <code>ls</code> 或查看目录中的内容。</li><li><strong>可写权限（<code>w</code>）</strong>：是否可以在目录中创建、删除或重命名文件。没有 <code>w</code> 权限，用户无法创建、删除或重命名目录中的文件。</li><li><strong>可执行权限（<code>x</code>）</strong>：是否可以进入该目录。没有 <code>x</code> 权限，即使有读权限，也无法 <code>cd</code> 进入目录。</li></ol><p><strong>家目录权限：</strong></p><ul><li>通常情况下，用户的家目录权限是 <code>700</code>，即只有该用户和 <code>root</code> 用户能访问和操作其家目录中的文件。其他用户无法访问、查看或修改这些文件。</li><li>这种权限设置通常用于保护用户的个人文件，使其不被其他用户看到或修改。</li></ul><p><strong>共享目录中的权限管理：</strong></p><ul><li>在共享目录中，其他用户通常有读取、创建和修改文件的权限。但 <strong>为了避免文件被随意删除</strong>，可以设置 <strong>粘滞位</strong>。</li><li>如果去掉共享目录的写权限，用户将无法在目录中创建文件或删除文件。这也意味着，如果一个目录没有写权限，那么所有用户都不能在其中创建或删除文件，目录就无法作为有效的共享目录。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>004 Linux基本指令</title>
      <link href="/posts/9242.html"/>
      <url>/posts/9242.html</url>
      
        <content type="html"><![CDATA[<h2 id="写在最前"><a href="#写在最前" class="headerlink" title="写在最前"></a>写在最前</h2><h3 id="一、Linux-指令的本质与执行逻辑"><a href="#一、Linux-指令的本质与执行逻辑" class="headerlink" title="一、Linux 指令的本质与执行逻辑"></a>一、Linux 指令的本质与执行逻辑</h3><ol><li><p><strong>指令与可执行程序的关系</strong>  </p><ul><li><strong>指令即程序</strong>：用户输入的指令（如 <code>ls</code>、<code>cp</code>）本质是 <strong>可执行程序或脚本</strong>，以文件形式存储在系统路径中（如 <code>/bin</code>、<code>/usr/bin</code>）。</li><li><strong>位置依赖</strong>：指令执行前需在系统预设路径（由 <code>$PATH</code> 环境变量定义）中查找对应文件。若未找到，提示 <code>command not found</code>。</li></ul></li><li><p><strong>指令执行流程</strong>  </p><ul><li><strong>查找与验证</strong>：系统按 <code>$PATH</code> 路径顺序搜索可执行文件，并检查文件权限（需具备可执行权限）。</li><li><strong>执行过程</strong>：找到文件后，操作系统加载程序至内存运行，用户通过命令行解释器间接与内核交互。</li></ul></li></ol><h3 id="二、核心设计哲学：Linux-下一切皆文件"><a href="#二、核心设计哲学：Linux-下一切皆文件" class="headerlink" title="二、核心设计哲学：Linux 下一切皆文件"></a>二、核心设计哲学：Linux 下一切皆文件</h3><ol><li><p><strong>抽象统一性</strong>  </p><ul><li><strong>硬件设备抽象为文件</strong>：<ul><li><strong>显示器</strong>：通过 <code>fwrite</code> 写入数据（如 <code>echo &quot;Hello&quot; &gt; /dev/tty</code>）。</li><li><strong>键盘</strong>：通过 <code>fread</code> 读取输入（如 <code>cat /dev/input/eventX</code>）。</li></ul></li><li><strong>统一操作接口</strong>：无论是硬件设备（如显示器、键盘）还是普通的文件，都可以通过文件操作进行读 <code>read()</code>、写 <code>write()</code> 等系统调用，简化编程与设备管理，更证实了 Linux 下一切皆文件。</li></ul></li><li><p><strong>文件系统层级</strong>  </p><ul><li><strong>普通文件</strong>：文本、二进制等常规数据。</li><li><strong>特殊文件</strong>：设备文件（如 <code>/dev/sda</code>）、管道文件、套接字文件等。</li></ul></li></ol><h3 id="三、用户与操作系统的交互机制"><a href="#三、用户与操作系统的交互机制" class="headerlink" title="三、用户与操作系统的交互机制"></a>三、用户与操作系统的交互机制</h3><ol><li><p><strong>命令行解释器（Shell）的核心作用</strong>  </p><ul><li><strong>功能分层</strong>：<ul><li><strong>命令解析</strong>：将用户输入的字符串解析为可执行操作。</li><li><strong>系统保护</strong>：拦截非法操作（如权限不足的命令、危险系统调用）。</li></ul></li><li><strong>必要性</strong>：直接操作内核复杂度高，Shell 提供安全且易用的交互层。</li></ul></li><li><p><strong>命令行提示符详解</strong>  </p><ul><li>示例：<code>[damai@VM-16-11-centos ~]$</code><ul><li><strong>用户名</strong>：<code>damai</code>（当前登录用户）。</li><li><strong>主机名</strong>：<code>VM-16-11-centos</code>（标识运行环境）。</li><li><strong>当前目录</strong>：<code>~</code>（用户家目录的简写，如 <code>/home/damai</code>）。</li><li><strong>提示符</strong>：<code>$</code> 表示普通用户，<code>#</code> 表示管理员（root）。</li></ul></li></ul></li></ol><h3 id="四、系统管理与高效操作技巧"><a href="#四、系统管理与高效操作技巧" class="headerlink" title="四、系统管理与高效操作技巧"></a>四、系统管理与高效操作技巧</h3><ol><li><p><strong>历史命令管理</strong>  </p><ul><li><strong>记录与搜索</strong>：<ul><li>默认保存最近 1000 条命令（通过 <code>HISTSIZE</code> 变量可调整）。</li><li>快捷键 <code>CTRL + r</code>（支持模糊搜索）快速定位历史命令。</li></ul></li><li><strong>持久化存储</strong>：历史记录保存在 <code>~/.bash_history</code>，便于审计与回溯。</li></ul></li><li><p><strong>环境变量与路径管理</strong>  </p><ul><li><strong>PATH 变量</strong>：定义可执行文件的搜索路径，可通过 <code>export PATH=$PATH:/custom/path</code> 扩展。</li><li><strong>查看路径</strong>：使用 <code>which ls</code> 或 <code>whereis ls</code> 定位指令的存储位置。</li></ul></li><li><p><strong>系统运行模式</strong>  </p><ul><li><strong>常开性设计</strong>：Linux 服务器通常长期运行（不关机），依赖以下特性：<ul><li>高稳定性内核与进程管理。</li><li>日志系统（如 <code>journalctl</code>）与监控工具（如 <code>top</code>）保障运维。</li></ul></li></ul></li></ol><h3 id="五、总结与核心理念"><a href="#五、总结与核心理念" class="headerlink" title="五、总结与核心理念"></a>五、总结与核心理念</h3><ol><li><strong>指令本质</strong>：用户输入字符串 → Shell 解析 → 执行对应可执行文件。</li><li><strong>文件抽象哲学</strong>：硬件、数据、操作均通过文件接口统一管理（<strong>Linux 中的一切皆文件</strong>）。</li><li><strong>用户隔离设计</strong>：Shell 作为安全屏障，防止直接内核操作引发系统风险。</li><li><strong>操作习惯</strong>：<ul><li>善用历史命令提升效率。</li><li>理解环境变量配置优化工作流。</li></ul></li></ol><hr><h2 id="重要的几个热键"><a href="#重要的几个热键" class="headerlink" title="重要的几个热键"></a>重要的几个热键</h2><table><thead><tr><th align="center"><strong>热键</strong></th><th><strong>功能描述</strong></th></tr></thead><tbody><tr><td align="center"><strong>&#x3D;&#x3D;Tab&#x3D;&#x3D;</strong></td><td>&#x3D;&#x3D;自动补全&#x3D;&#x3D; 命令或文件名</td></tr><tr><td align="center"><strong>&#x3D;&#x3D;Ctrl + C&#x3D;&#x3D;</strong></td><td>&#x3D;&#x3D;终止&#x3D;&#x3D; 当前正在运行的命令（中断）</td></tr><tr><td align="center"><strong>&#x3D;&#x3D;Ctrl + D&#x3D;&#x3D;</strong></td><td>&#x3D;&#x3D;退出&#x3D;&#x3D; 当前 shell（相当于 <code>exit</code> 命令）</td></tr><tr><td align="center"><strong>&#x3D;&#x3D;Ctrl + L&#x3D;&#x3D;</strong></td><td>&#x3D;&#x3D;清屏&#x3D;&#x3D;，类似于 <code>clear</code> 命令，但不会清除历史记录</td></tr><tr><td align="center"><strong>Ctrl + Shift + C</strong></td><td>&#x3D;&#x3D;复制&#x3D;&#x3D; 选中的文本</td></tr><tr><td align="center"><strong>Ctrl + Shift + V</strong></td><td>&#x3D;&#x3D;粘贴&#x3D;&#x3D; 剪贴板中的内容</td></tr><tr><td align="center"><strong>Ctrl + A</strong></td><td>移动光标到当前行的开头</td></tr><tr><td align="center"><strong>Ctrl + E</strong></td><td>移动光标到当前行的结尾</td></tr><tr><td align="center"><strong>Ctrl + U</strong></td><td>删除光标到行首的内容</td></tr><tr><td align="center"><strong>Ctrl + K</strong></td><td>删除光标到行尾的内容</td></tr><tr><td align="center"><strong>Ctrl + W</strong></td><td>删除光标前的单词</td></tr><tr><td align="center"><strong>Ctrl + Z</strong></td><td>将当前进程挂起并放入后台</td></tr><tr><td align="center"><strong>Ctrl + Shift + T</strong></td><td>新建一个终端标签页</td></tr><tr><td align="center"><strong>Ctrl + Shift + W</strong></td><td>关闭当前的终端标签页</td></tr></tbody></table><hr><h2 id="Linux-指令"><a href="#Linux-指令" class="headerlink" title="Linux 指令"></a>Linux 指令</h2><h3 id="touch-——-创建文件-修改文件时间戳"><a href="#touch-——-创建文件-修改文件时间戳" class="headerlink" title="touch —— 创建文件&#x2F;修改文件时间戳"></a><code>touch</code> —— 创建文件&#x2F;修改文件时间戳</h3><p><strong>1. 语法：<code>touch [选项] 文件名...</code></strong></p><p><strong>2. 常用选项</strong></p><table><thead><tr><th align="center">选项</th><th>作用</th></tr></thead><tbody><tr><td align="center"><code>-a</code></td><td>仅修改文件的 <strong>访问时间</strong>（Access Time）</td></tr><tr><td align="center"><code>-c</code></td><td><strong>不创建</strong> 新文件（如果文件不存在，则不会创建）</td></tr><tr><td align="center"><code>-d &quot;时间字符串&quot;</code></td><td>以指定时间字符串设置时间戳（支持相对时间）</td></tr><tr><td align="center"><code>-f</code></td><td>兼容性选项，通常无实际作用（可忽略）</td></tr><tr><td align="center"><code>-m</code></td><td>仅修改文件的 <strong>修改时间</strong>（Modify Time）</td></tr><tr><td align="center"><code>-r 参考文件</code></td><td>使用参考文件的时间戳</td></tr><tr><td align="center"><code>-t [[CC]YY]MMDDhhmm[.ss]</code></td><td>以指定格式手动设置时间戳</td></tr></tbody></table><p><strong>3. 使用示例</strong></p><p><strong>① 创建一个新文件</strong>：<code>touch newfile.txt</code>，如果 <code>newfile.txt</code> 不存在，则创建一个空文件；如果已存在，则更新时间戳。</p><p><strong>② 仅修改文件的访问时间</strong>：<code>touch -a file.txt</code>，只更新 <code>file.txt</code> 的访问时间，修改时间不变。</p><p><strong>③ 不创建新文件，仅更新时间</strong>：<code>touch -c file.txt</code>，如果 <code>file.txt</code> 不存在，则不创建新文件。</p><p><strong>④ 使用时间字符串</strong>：<code>touch -d &quot;2025-01-01 00:00:00&quot; file.txt</code>，将 <code>file.txt</code> 的时间戳修改为 <strong>2025 年 01 月 01 日 00:00:00</strong>。</p><p><strong>⑤ 仅修改文件的修改时间</strong>：<code>touch -m file.txt</code>，只更新 <code>file.txt</code> 的修改时间，访问时间不变。</p><p><strong>⑥ 使用参考文件的时间戳</strong>：<code>touch -r reference.txt target.txt</code>，让 <code>target.txt</code> 的时间戳与 <code>reference.txt</code> 相同。</p><p><strong>⑦ 指定时间戳</strong>：<code>touch -t 202501011230.45 file.txt</code>，设置 <code>file.txt</code> 的时间为 <strong>2025 年 01 月 01 日 12:30:45</strong>。</p><p><strong>⑧ 查看文件的时间戳：</strong> <code>stat file.txt</code>。</p><hr><h3 id="man-——-访问-Linux-手册页（重要）"><a href="#man-——-访问-Linux-手册页（重要）" class="headerlink" title="man —— 访问 Linux 手册页（重要）"></a><code>man</code> —— 访问 Linux 手册页（重要）</h3><p><code>man</code> 是用来查看 Linux 命令、程序、配置文件等的手册页的工具。通过它，你可以快速了解命令的用法、选项、示例等详细信息。<strong>在命令行中输入 <code>man man</code> 的作用是显示 <code>man</code> 命令自身的手册页。</strong></p><p><strong>1. 语法：<code>man [选项] 命令</code></strong></p><p><strong>2. 常用选项：</strong></p><table><thead><tr><th align="center"><strong>选项</strong></th><th><strong>解释说明</strong></th><th><strong>示例与说明</strong></th></tr></thead><tbody><tr><td align="center"><code>-k</code></td><td>根据关键词搜索命令或手册内容</td><td><code>man -k copy</code>：搜索所有与“copy”相关的命令，如 <code>cp</code>。</td></tr><tr><td align="center"><code>-f</code></td><td>显示命令的简短描述</td><td><code>man -f ls</code>：显示 <code>ls</code> 命令的简短描述（类似 <code>whatis</code>）。</td></tr><tr><td align="center"><code>-a</code></td><td>打开所有相关的手册页</td><td><code>man -a ls</code>：打开所有与 <code>ls</code> 相关的手册页。</td></tr><tr><td align="center"><code>-s</code></td><td>指定章节号查看手册</td><td><code>man -s 5 passwd</code>：查看 <code>passwd</code> 的第 5 章手册页（文件格式）。</td></tr><tr><td align="center"><code>-c</code></td><td>清除缓存并打开手册页</td><td><code>man -c ls</code>：清除缓存并打开 <code>ls</code> 的手册页。</td></tr></tbody></table><p><strong>3. 查阅命令的不同部分</strong>：手册页通常会分为几个部分，不同章节对应不同类型的命令。常见的部分包括：</p><ul><li><strong>1</strong>：用户命令（User Commands）</li><li><strong>2</strong>：系统调用（System Calls）</li><li><strong>3</strong>：库函数（Library Functions）</li><li><strong>4</strong>：设备（Devices）</li><li><strong>5</strong>：文件格式（File Formats）</li><li><strong>6</strong>：游戏（Games）</li><li><strong>7</strong>：杂项（Miscellaneous）</li><li><strong>8</strong>：系统管理命令（System Administration Commands）</li></ul><p><strong>4. 分页浏览</strong>：手册页通常是通过分页器（如 <code>less</code>）显示的，浏览时不能使用鼠标滚轮，&#x3D;&#x3D;<strong>推荐直接使用方向键</strong>&#x3D;&#x3D;，以下是一些常用的分页操作：</p><table><thead><tr><th><strong>操作</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>空格键</strong></td><td>向下滚动一页。</td></tr><tr><td><strong>B</strong></td><td>向上滚动一页。</td></tr><tr><td><strong>Enter</strong></td><td>向下滚动一行。</td></tr><tr><td><strong>&#x2F;关键词</strong></td><td>搜索关键词。在 <code>man</code> 命令的输出中，按 <code>/</code> 键进入搜索模式，查找手册页中的特定内容。例如：按下 <code>/</code> 键后输入 <code>-l</code>，搜索 <code>ls</code> 手册页中的 <code>-l</code>。</td></tr><tr><td><strong>N</strong></td><td>查找下一个匹配的关键词。</td></tr><tr><td><strong><code>Q</code></strong></td><td>退出手册页。</td></tr></tbody></table><hr><h3 id="cp-——-复制文件或目录（重要）"><a href="#cp-——-复制文件或目录（重要）" class="headerlink" title="cp —— 复制文件或目录（重要）"></a><code>cp</code> —— 复制文件或目录（重要）</h3><p><code>cp</code> 是 Linux 系统中用来复制文件或目录的命令。它可以复制单个文件、多个文件以及整个目录，并且支持多种选项来定制复制行为。<strong>说明: 如同时指定两个以上的文件或目录，且最后的目的地是一个已经存在的目录，则它会把前面指定的所有文件或目录复制到此目录中。若同时指定多个文件或目录，而最后的目的地并非一个已存在的目录，则会出现错误信息。</strong></p><p><strong>1. 语法：<code>cp [选项] 源文件 目标文件</code></strong></p><p><strong>2. 常用选项：</strong></p><table><thead><tr><th><strong>选项</strong></th><th><strong>解释说明</strong></th><th><strong>示例与说明</strong></th></tr></thead><tbody><tr><td><code>-r</code> 或 <code>-R</code> 或 <code>--recursive</code></td><td>递归复制目录及其内容（适用于目录）</td><td><code>cp -r /source/dir /dest/dir</code>：复制整个目录及其内容到目标目录。<code>-r</code> 和 <code>-R</code> 都是递归选项，用来复制目录及其内容。它们的功能是完全相同的，因此你可以根据自己的喜好选择使用大写或小写。</td></tr><tr><td><code>-f</code> 或 <code>--force</code></td><td>&#x3D;&#x3D;强制复制&#x3D;&#x3D;，覆盖目标文件时不询问</td><td><code>cp -f file1 file2</code>：如果目标文件已存在，则直接覆盖，不询问。</td></tr><tr><td><code>-i</code> 或 <code>--interactive</code></td><td>覆盖文件之前 &#x3D;&#x3D;提示&#x3D;&#x3D; 用户确认</td><td><code>cp -i file1 file2</code>：如果 <code>file2</code> 已存在，系统会提示是否覆盖。</td></tr><tr><td><code>-v</code> 或 <code>--verbose</code></td><td>显示详细的输出，列出每个复制的文件</td><td><code>cp -v file1 file2</code>：复制时显示文件复制过程。</td></tr><tr><td><code>-p</code> 或 <code>--preserve</code></td><td>保持文件的属性（如修改时间、权限等）</td><td><code>cp -p file1 file2</code>：复制时保留文件的时间戳和权限。</td></tr></tbody></table><p><strong>3. 示例：</strong></p><ul><li><strong>复制文件：<code>cp file1.txt file2.txt</code></strong>，这个命令将 <code>file1.txt</code> 复制到 <code>file2.txt</code>，如果 <code>file2.txt</code> 已存在，它会被覆盖。</li><li><strong>复制目录：<code>cp -r /home/user/dir /home/user/backup/</code></strong>，这个命令将目录 <code>/home/user/dir</code> 及其所有内容递归地复制到 <code>/home/user/backup/</code> 目录下。</li><li><strong>递归复制并显示详细输出：<code>cp -rv /home/user/dir /home/user/backup/</code></strong>，这个命令会递归地复制目录，并显示每个文件和目录的复制过程。</li><li><strong>复制文件，覆盖前询问确认：<code>cp -i file1.txt file2.txt</code></strong>，如果 <code>file2.txt</code> 已存在，<code>-i</code> 选项会提示你是否覆盖该文件。</li></ul><p><strong>4. 其他说明：</strong> <code>cp</code> 命令支持多种组合选项，可以根据需要灵活使用，结合不同选项可以实现很多高级操作。它是一个非常常见且实用的命令，几乎在所有 Linux 系统中都可以找到它。</p><hr><h3 id="mv-——-移动或重命名文件和目录（重要）"><a href="#mv-——-移动或重命名文件和目录（重要）" class="headerlink" title="mv —— 移动或重命名文件和目录（重要）"></a><code>mv</code> —— 移动或重命名文件和目录（重要）</h3><p><code>mv</code> 是 Linux 中用来移动文件或目录的命令，也可以用来重命名文件或目录。它非常常用，通常用于将文件从一个位置移动到另一个位置，或者给文件和目录重新命名。</p><p><strong>1. 语法：<code>mv [选项] 源文件/目录 目标文件/目录</code></strong></p><ul><li><strong>移动文件</strong>：将源文件移动到目标位置。</li><li><strong>重命名文件</strong>：将源文件重命名为目标文件。</li><li><strong>移动目录</strong>：将源目录及其内容移动到目标位置。</li></ul><p><strong>2. 常用选项：</strong></p><table><thead><tr><th><strong>选项</strong></th><th><strong>解释说明</strong></th><th><strong>示例与说明</strong></th></tr></thead><tbody><tr><td><code>-i</code> 或 <code>--interactive</code></td><td>在覆盖文件之前询问用户确认</td><td><code>mv -i file1.txt file2.txt</code>：如果 <code>file2.txt</code> 已存在，系统会询问是否覆盖。</td></tr><tr><td><code>-f</code> 或 <code>--force</code></td><td>强制执行，不询问用户直接覆盖文件</td><td><code>mv -f file1.txt file2.txt</code>：如果目标文件已存在，则直接覆盖。</td></tr><tr><td><code>-u</code> 或 <code>--update</code></td><td>仅在源文件比目标文件新时才进行移动或重命名</td><td><code>mv -u file1.txt file2.txt</code>：如果 <code>file1.txt</code> 比 <code>file2.txt</code> 新，则移动。</td></tr><tr><td><code>-v</code> 或 <code>--verbose</code></td><td>显示详细的输出，列出每个移动或重命名的文件操作</td><td><code>mv -v file1.txt /home/user/backup/</code>：移动文件并显示操作过程。</td></tr><tr><td><code>-n</code> 或 <code>--no-clobber</code></td><td>不覆盖已存在的目标文件，若目标文件已存在则不进行操作</td><td><code>mv -n file1.txt file2.txt</code>：如果 <code>file2.txt</code> 已存在，不会覆盖。</td></tr><tr><td><code>-b</code> 或 <code>--backup</code></td><td>在覆盖文件之前，先备份目标文件（备份文件名后缀为 <code>~</code>）</td><td><code>mv -b file1.txt file2.txt</code>：覆盖时会保留 <code>file2.txt~</code> 作为备份文件。</td></tr></tbody></table><p><strong>3. 重要说明：</strong></p><ul><li><code>mv</code> 可以用来重命名文件和目录，因此可以简单地通过给目标文件&#x2F;目录提供新名称来完成重命名操作（<strong>重命名</strong>：当第二个参数是文件时，<code>mv</code> 会将源文件重命名为目标文件名。<strong>移动文件或目录</strong>：当第二个参数是已存在的目录时，<code>mv</code> 会将源文件或目录移动到该目录中）。</li><li>如果目标位置已经存在一个同名文件或目录，默认情况下，<code>mv</code> 会覆盖它。</li><li><code>mv</code> 操作的结果是原文件或目录会从原位置移除，而不会再保留一份副本。</li><li><code>-i</code> 选项非常有用，它在移动或重命名时会提示你确认是否覆盖已有文件，防止误操作。</li><li><code>-f</code> 是强制选项，它会直接覆盖文件或目录，避免询问确认。</li></ul><p><code>mv</code> 是一个非常强大且灵活的命令，适用于文件和目录的移动、重命名等常见操作，尤其在文件管理、备份和文件系统操作中常用。</p><hr><h3 id="cat-——-查看目标文件的内容（不适合看大文本，适合看小文本）"><a href="#cat-——-查看目标文件的内容（不适合看大文本，适合看小文本）" class="headerlink" title="cat —— 查看目标文件的内容（不适合看大文本，适合看小文本）"></a><code>cat</code> —— 查看目标文件的内容（不适合看大文本，适合看小文本）</h3><p><strong>1. 语法：<code>cat [选项] [文件]...</code></strong></p><p><strong>2. 常用选项：</strong></p><table><thead><tr><th><strong>选项</strong></th><th><strong>解释说明</strong></th><th><strong>示例与说明</strong></th></tr></thead><tbody><tr><td><code>-n</code> 或 <code>--number</code></td><td>给每一行加上行号</td><td><code>cat -n file.txt</code>：为 <code>file.txt</code> 的每行添加行号后输出。</td></tr><tr><td><code>-b</code> 或 <code>--number-nonblank</code></td><td>只给非空行加上行号</td><td><code>cat -b file.txt</code>：只为 <code>file.txt</code> 的非空行添加行号后输出。</td></tr><tr><td><code>-s</code> 或 <code>--squeeze-blank</code></td><td>压缩连续的空行成一行</td><td><code>cat -s file.txt</code>：如果 <code>file.txt</code> 中有连续的空行，则将其压缩成一行。</td></tr><tr><td><code>-E</code> 或 <code>--show-ends</code></td><td>在每行结尾显示 <code>$</code> 字符</td><td><code>cat -E file.txt</code>：在 <code>file.txt</code> 每一行末尾加上 <code>$</code> 后输出。</td></tr></tbody></table><p><strong>3. 重要说明：</strong></p><ul><li><code>cat</code> 最常见的用途是显示文件内容，例如 <code>cat file.txt</code> 会将 <code>file.txt</code> 的内容输出到终端。</li><li>它也可以用于一次性查看多个文件的内容，例如 <code>cat file1.txt file2.txt</code> 会依次显示这两个文件的内容。</li><li><strong>输入重定向</strong>：<code>cat</code> 还能用于创建文件，如 <code>cat &gt; newfile.txt</code> 然后输入内容，按 <code>Ctrl+D</code> 结束输入并保存；<code>cat &lt; temp.txt</code> <strong>默认行为</strong>：<code>cat</code> 从键盘（标准输入）读取内容并显示，使用 <code>&lt;</code>，<code>cat</code> <strong>从指定的文件读取内容</strong>，而不是从键盘。</li><li>当使用 <code>cat</code> 连接文件时，比如 <code>cat file1.txt file2.txt &gt; combined.txt</code>，它会将两个文件的内容合并到一个新的文件中。</li><li><code>cat</code> 可以通过组合选项来执行更多功能，比如显示行号、显示制表符、查看不可打印字符等，这对于调试文件、查看格式化问题等非常有用。</li><li><code>cat</code> 通常用来快速查看文件的内容，适合小文件。如果文件内容较长，使用 <code>cat</code> 可能会导致终端滚动过快，难以阅读，此时可以考虑使用 <code>less</code> 或 <code>more</code> 命令。</li></ul><hr><h3 id="echo-——-输出文本或变量的值"><a href="#echo-——-输出文本或变量的值" class="headerlink" title="echo —— 输出文本或变量的值"></a><code>echo</code> —— 输出文本或变量的值</h3><p><code>echo</code> 用于在终端中输出文本或变量的值。它常用于脚本中打印调试信息、向用户显示提示信息，或将输出写入文件。</p><p><strong>1. 语法：<code>echo [选项] [文本]</code></strong></p><p><strong>2. 常用选项：</strong></p><table><thead><tr><th><strong>选项</strong></th><th><strong>解释说明</strong></th><th><strong>示例与说明</strong></th></tr></thead><tbody><tr><td><code>-n</code></td><td>不在输出的末尾添加换行符</td><td><code>echo -n &quot;Hello&quot;</code>：输出 <code>Hello</code>，但不换行。</td></tr><tr><td><code>-e</code></td><td>启用转义字符解析（如 <code>\n</code>、<code>\t</code> 等）</td><td><code>echo -e &quot;Line1\nLine2&quot;</code>：输出两行 <code>Line1</code> 和 <code>Line2</code>，用换行符分隔。</td></tr><tr><td><code>-E</code></td><td>禁用转义字符解析（这是默认行为）</td><td><code>echo -E &quot;Line1\nLine2&quot;</code>：输出 <code>Line1\nLine2</code>，不会换行。</td></tr><tr><td><code>--help</code></td><td>显示 <code>echo</code> 命令的帮助信息</td><td><code>echo --help</code>：显示 <code>echo</code> 命令的帮助文档。</td></tr><tr><td><code>--version</code></td><td>显示 <code>echo</code> 命令的版本信息</td><td><code>echo --version</code>：显示 <code>echo</code> 命令的版本信息。</td></tr></tbody></table><p><strong>3. 常见用法：</strong></p><ul><li><strong>输出文本</strong>：<code>echo &quot;Hello, World!&quot;</code>：输出 <code>Hello, World!</code>。</li><li><strong>显示变量的值</strong>：<code>name=&quot;Alice&quot;; echo $name</code>：输出变量 <code>name</code> 的值，结果为 <code>Alice</code>。</li><li><strong>输出带换行符的文本</strong>：<code>echo &quot;Hello\nWorld&quot;</code>：输出 <code>Hello</code> 和 <code>World</code>，并换行。若使用 <code>-e</code> 选项才能正确解析换行符。</li><li><strong>不换行输出</strong>：<code>echo -n &quot;Hello&quot;</code>：输出 <code>Hello</code>，但不自动换行。</li><li><strong>启用转义字符解析</strong>：<code>echo -e &quot;Hello\tWorld&quot;</code>：输出 <code>Hello</code> 和 <code>World</code>，并在它们之间加入一个制表符（tab）。</li><li><strong>重定向输出到文件</strong>：<ul><li><strong>示例</strong>：<code>echo &quot;Hello&quot; &gt; file.txt</code>：将 <code>Hello</code> 写入 <code>file.txt</code> 文件中。如果文件已存在，则会覆盖它。</li><li><strong>示例</strong>：<code>echo &quot;Hello&quot; &gt;&gt; file.txt</code>：将 <code>Hello</code> 追加到 <code>file.txt</code> 文件末尾。</li></ul></li></ul><p><strong>4. 重要说明：</strong></p><ul><li><code>echo</code> 默认会在输出内容的末尾添加换行符。如果不需要换行符，可以使用 <code>-n</code> 选项。</li><li>启用转义字符解析时，<code>echo</code> 会识别诸如 <code>\n</code>（换行符）、<code>\t</code>（制表符）、<code>\r</code>（回车符）等特殊字符，需要使用 <code>-e</code> 选项才能生效。</li><li>如果你需要在脚本或命令行中快速查看某个变量的值，<code>echo</code> 是一个非常方便的工具。</li></ul><hr><h3 id="more-——-分页显示文件内容（功能类似-cat-适用于查看较长的文件）"><a href="#more-——-分页显示文件内容（功能类似-cat-适用于查看较长的文件）" class="headerlink" title="more —— 分页显示文件内容（功能类似 cat 适用于查看较长的文件）"></a><code>more</code> —— 分页显示文件内容（功能类似 <code>cat</code> 适用于查看较长的文件）</h3><p><code>more</code> 是 Linux 中用来分页显示文本文件内容的命令，通常用于查看较长的文件，逐页显示文件内容，直到文件结束。当文件内容过长时，<code>more</code> 会将内容分成一页一页地显示，你可以通过键盘命令逐页查看文件内容。</p><p><strong>1. 语法：<code>more [选项] 文件</code></strong></p><p><strong>2. 常用选项：</strong></p><table><thead><tr><th><strong>选项</strong></th><th><strong>解释说明</strong></th><th><strong>示例与说明</strong></th></tr></thead><tbody><tr><td><code>-n</code></td><td>设置每页显示的行数</td><td><code>more -5 file.txt</code>：每页显示 5 行，文件内容逐页显示。</td></tr><tr><td><code>+NUM</code></td><td>从文件的第 <code>NUM</code> 行开始显示</td><td><code>more +10 file.txt</code>：从第 10 行开始显示文件内容。</td></tr><tr><td><code>-c</code></td><td>清屏显示（每次显示内容前先清屏）</td><td><code>more -c file.txt</code>：显示文件内容时，每一页都会先清屏。</td></tr><tr><td><code>-s</code></td><td>压缩连续的空白行，显示为一行</td><td><code>more -s file.txt</code>：显示文件时连续的空行会被压缩成一行。</td></tr><tr><td><code>-d</code></td><td>在文件结束时显示 <code>--More--(next)</code> 提示符（可以使用 <code>q</code> 退出）</td><td><code>more -d file.txt</code>：结束时显示提示符，用户可以按 <code>q</code> 退出。</td></tr><tr><td><code>-p</code></td><td>在显示内容时，保持当前页面的显示，不使用滚动条</td><td><code>more -p file.txt</code>：显示文件时，每页会直接覆盖，不滚动。</td></tr></tbody></table><p><strong>3. 分页浏览操作：</strong> <code>more</code> 通过分页器显示文件内容，<strong>推荐使用方向键</strong>，也可以使用以下键进行浏览：</p><table><thead><tr><th align="center"><strong>操作</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td align="center"><strong>空格键</strong></td><td>向下翻一页</td></tr><tr><td align="center"><strong>Enter</strong></td><td>向下滚动一行</td></tr><tr><td align="center"><strong>B</strong></td><td>向上翻一页</td></tr><tr><td align="center"><strong>&#x2F;关键词</strong></td><td>搜索关键词，在文件内容中查找。</td></tr><tr><td align="center"><strong>N</strong></td><td>查找下一个匹配的关键词</td></tr><tr><td align="center"><strong><code>Q</code></strong></td><td>退出 <code>more</code>，停止文件浏览</td></tr><tr><td align="center"><strong>H</strong></td><td>显示 <code>more</code> 命令的帮助信息</td></tr><tr><td align="center"><strong>D</strong></td><td>向下滚动半页</td></tr><tr><td align="center"><strong>U</strong></td><td>向上滚动半页</td></tr></tbody></table><p><strong>4. 管道用法与分页显示</strong></p><p><code>more</code> 命令不仅限于直接显示文件内容，它还可以与其他命令结合使用，通过管道（pipe）将命令的输出分页显示。管道符号 <code>|</code> 是用来将前一个命令的输出作为输入传递给后一个命令的。这意味着，第一个命令的标准输出（<code>stdout</code>）被“传递”到第二个命令的标准输入（<code>stdin</code>）。例如：</p><ul><li><strong><code>ls -l / | more</code></strong>：<code>ls</code> 命令列出 <code>/</code> 目录下的文件和子目录，<code>-l</code> 选项让 <code>ls</code> 显示文件的详细信息，包括权限、拥有者、大小等。<code>more</code> 命令接收从 <code>ls -l /</code> 命令输出的数据，并分页显示它。因为 <code>/</code> 目录下通常包含很多文件，使用 <code>more</code> 可以让你逐页查看输出。</li><li><strong><code>ps aux | more</code></strong>：分页显示所有当前运行的进程。</li></ul><p><strong>&#x3D;&#x3D;管道（Pipe）概念：&#x3D;&#x3D;</strong></p><p>管道符号 <code>|</code> 用来将前一个命令的输出传递给下一个命令作为输入。也就是说，<code>more</code> 可以接收其他命令的输出并逐页显示，而不是单独显示文件内容。通过管道可以方便地查看大量命令输出的内容。</p><p><strong>&#x3D;&#x3D;为什么使用管道？&#x3D;&#x3D;</strong></p><p><code>ls -l /</code> 的输出可能很长，直接在终端中显示出来可能会很难查看。通过管道将输出传递给 <code>more</code> 命令，可以让你一页一页地查看内容，避免内容溢出屏幕。</p><hr><h3 id="less-——-分页显示文件内容（比-more-更强大）（重要）"><a href="#less-——-分页显示文件内容（比-more-更强大）（重要）" class="headerlink" title="less —— 分页显示文件内容（比 more 更强大）（重要）"></a><code>less</code> —— 分页显示文件内容（比 <code>more</code> 更强大）（重要）</h3><p><code>less</code> 与 <code>more</code> 相似，都是用来分页显示文件内容，但 <code>less</code> 提供了更多的控制和操作选项。与 <code>more</code> 相比：<code>less</code> 提供了更高的灵活性，可以向前和向后翻阅文件内容，同时支持更丰富的搜索功能。与 <code>more</code> 不同：<code>less</code> 会在查看文件时不会一次性加载整个文件，而是按需加载数据，这样更加高效。</p><p><strong>1. 语法： <code>less [选项] 文件</code></strong></p><ul><li><code>less</code> 工具也是对文件或其它输出进行分页显示的工具，应该说是 linux 正统查看文件内容的工具，功能极其强大。</li><li><code>less</code> 的用法比起 <code>more</code> 更加的有弹性。在 <code>more</code> 的时候，我们并没有办法向前面翻， 只能往后面看</li><li>但若使用了 <code>less</code> 时，就可以使用 【<code>pageup</code>】【<code>pagedown</code>】 等按键的功能来往前往后翻看文件，更容易用来查看一个文件的内容！</li><li>除此之外，在 <code>less</code> 里头可以拥有更多的搜索功能，不止可以向下搜，也可以向上搜</li></ul><p><strong>2. 常用选项：</strong></p><table><thead><tr><th align="center"><strong>选项</strong></th><th><strong>解释说明</strong></th><th><strong>示例与说明</strong></th></tr></thead><tbody><tr><td align="center"><code>-i</code></td><td>搜索时忽略大小写</td><td><code>less -i file.txt</code>：在搜索时忽略大小写。</td></tr><tr><td align="center"><code>-N</code></td><td>显示每行的行号</td><td><code>less -N file.txt</code>：显示每行内容时，在行首显示行号。</td></tr><tr><td align="center"><code>/字符串</code></td><td>向下搜索指定的字符串</td><td><code>/error</code>：在文件中向下搜索并定位到包含 “error” 的行。</td></tr><tr><td align="center"><code>?字符串</code></td><td>向上搜索指定的字符串</td><td><code>?warning</code>：在文件中向上搜索并定位到包含 “warning” 的行。</td></tr><tr><td align="center"><code>n</code></td><td>重复上次的向下搜索</td><td><code>n</code>：再次向下查找上次搜索的字符串。</td></tr><tr><td align="center"><code>N</code></td><td>反向重复上次的搜索</td><td><code>N</code>：反向查找上次搜索的字符串。</td></tr><tr><td align="center"><code>q</code></td><td>退出 <code>less</code>，停止文件浏览</td><td><code>q</code>：退出 <code>less</code>，停止文件的浏览。</td></tr></tbody></table><p><strong>3. 分页浏览操作：</strong> 与 <code>more</code> 类似，<code>less</code> 也支持分页显示文件内容，且可以使用更多的翻页和搜索操作。以下是常用的分页浏览操作：</p><table><thead><tr><th align="center"><strong>操作</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td align="center"><strong>空格键</strong></td><td>向下翻一页</td></tr><tr><td align="center"><strong>Enter</strong></td><td>向下滚动一行</td></tr><tr><td align="center"><strong>B</strong></td><td>向上翻一页</td></tr><tr><td align="center"><strong>PageUp</strong></td><td>向上翻一页</td></tr><tr><td align="center"><strong>PageDown</strong></td><td>向下翻一页</td></tr><tr><td align="center"><strong><code>Q</code></strong></td><td>退出 <code>less</code>，停止文件浏览</td></tr><tr><td align="center"><strong>H</strong></td><td>显示 <code>less</code> 命令的帮助信息</td></tr><tr><td align="center"><strong>G</strong></td><td>跳转到文件末尾</td></tr><tr><td align="center"><strong>g</strong></td><td>跳转到文件开头</td></tr><tr><td align="center"><strong>D</strong></td><td>向下滚动半页</td></tr><tr><td align="center"><strong>U</strong></td><td>向上滚动半页</td></tr></tbody></table><p><strong>4. 管道用法与分页显示</strong></p><p>与 <code>more</code> 一样，<code>less</code> 也支持管道操作，可以将其他命令的输出通过管道传递给 <code>less</code> 进行分页显示。例如：</p><ul><li><strong><code>ls -l / | less</code></strong>：通过管道将 <code>ls -l /</code> 的输出传递给 <code>less</code>，实现分页显示 <code>/</code> 目录下的详细文件信息。</li></ul><p>管道符号 <code>|</code> 用来将前一个命令的输出传递给下一个命令作为输入。通过管道，可以方便地查看其他命令的输出，而不必一次性加载全部内容。</p><hr><h3 id="head-——-显示文件的开头内容"><a href="#head-——-显示文件的开头内容" class="headerlink" title="head —— 显示文件的开头内容"></a><code>head</code> —— 显示文件的开头内容</h3><p><code>head</code> 命令用于显示文件的开头部分内容，默认情况下，<code>head</code> 会显示文件的前 10 行。你可以通过 <code>-n</code> 选项来指定显示更多或更少的行。</p><p><strong>1. 语法： <code>head [选项]... [文件]...</code></strong></p><p><strong>2. 常用选项：</strong></p><table><thead><tr><th><strong>选项</strong></th><th><strong>解释说明</strong></th><th><strong>示例与说明</strong></th></tr></thead><tbody><tr><td><code>-n &lt;行数&gt;</code></td><td>指定要显示的行数</td><td><code>head -n 20 file.txt</code>：显示 <code>file.txt</code> 的前 20 行。</td></tr><tr><td><code>-c &lt;字节数&gt;</code></td><td>显示文件的前 <code>&lt;字节数&gt;</code> 个字节</td><td><code>head -c 50 file.txt</code>：显示 <code>file.txt</code> 的前 50 个字节。</td></tr><tr><td><code>-q</code></td><td>不显示文件名（用于多个文件时）</td><td><code>head -n 10 file1.txt file2.txt</code>：默认会显示文件名，<code>-q</code> 选项可以去除文件名。</td></tr></tbody></table><p><strong>3. 示例：</strong></p><ul><li><strong><code>head -n 10 file.txt</code></strong>：显示文件 <code>file.txt</code> 的前 10 行（默认行为）。</li><li><strong><code>head -n 50 file.txt</code></strong>：显示 <code>file.txt</code> 的前 50 行。</li><li><strong><code>head -c 100 file.txt</code></strong>：显示 <code>file.txt</code> 的前 100 字节。</li></ul><h3 id="tail-——-显示文件的尾部内容"><a href="#tail-——-显示文件的尾部内容" class="headerlink" title="tail —— 显示文件的尾部内容"></a><code>tail</code> —— 显示文件的尾部内容</h3><p><code>tail</code> 命令用于显示文件的尾部内容，通常用来查看日志文件的最新内容。默认情况下，<code>tail</code> 会显示文件的最后 10 行。你可以通过 <code>-n</code> 选项来指定显示的行数，使用 <code>-f</code> 选项可以实时查看文件内容的变化（常用于查看实时日志）。</p><p><strong>1. 语法： <code>tail [选项] [文件]</code></strong></p><p><strong>2. 常用选项：</strong></p><table><thead><tr><th><strong>选项</strong></th><th><strong>解释说明</strong></th><th><strong>示例与说明</strong></th></tr></thead><tbody><tr><td><code>-n &lt;行数&gt;</code></td><td>显示文件的最后 <code>&lt;行数&gt;</code> 行内容</td><td><code>tail -n 20 file.txt</code>：显示 <code>file.txt</code> 的最后 20 行。</td></tr><tr><td><code>-f</code></td><td>实时跟踪文件内容的变化，常用于查看日志文件</td><td><code>tail -f file.log</code>：实时显示 <code>file.log</code> 文件的最新内容。</td></tr><tr><td><code>-c &lt;字节数&gt;</code></td><td>显示文件的最后 <code>&lt;字节数&gt;</code> 个字节</td><td><code>tail -c 100 file.txt</code>：显示 <code>file.txt</code> 的最后 100 个字节。</td></tr></tbody></table><p><strong>3. 示例：</strong></p><ul><li><strong><code>tail -n 10 file.txt</code></strong>：显示 <code>file.txt</code> 的最后 10 行（默认行为）。</li><li><strong><code>tail -n 50 file.txt</code></strong>：显示 <code>file.txt</code> 的最后 50 行。</li><li><strong><code>tail -f /var/log/syslog</code></strong>：实时显示 <code>syslog</code> 文件的新内容，适用于查看实时日志。</li><li><strong><code>tail -n 20 file.txt | head -n 10</code></strong>：先显示 <code>file.txt</code> 的最后 20 行，再从中显示前 10 行。</li></ul><h3 id="结合使用-head-和-tail-——-提取文件的指定行"><a href="#结合使用-head-和-tail-——-提取文件的指定行" class="headerlink" title="结合使用 head 和 tail —— 提取文件的指定行"></a>结合使用 <code>head</code> 和 <code>tail</code> —— 提取文件的指定行</h3><p>在某些情况下，我们需要从文件中提取指定行。<code>head</code> 和 <code>tail</code> 结合使用可以很方便地实现这一功能。</p><p><strong>举例：</strong> 假设有一个文件 <code>test</code>，它有 100 行内容，如果我们想要提取第 50 行，可以使用以下方法：</p><h4 id="方法-1：-使用临时文件"><a href="#方法-1：-使用临时文件" class="headerlink" title="方法 1： 使用临时文件"></a>方法 1： 使用临时文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">head</span> -n 50 <span class="built_in">test</span> &gt; tmp    <span class="comment"># 将前 50 行存入临时文件 tmp</span></span><br><span class="line"><span class="built_in">tail</span> -n 1 tmp            <span class="comment"># 获取临时文件 tmp 的最后一行，即第 50 行</span></span><br></pre></td></tr></table></figure><h4 id="方法-2：使用管道"><a href="#方法-2：使用管道" class="headerlink" title="方法 2：使用管道"></a>方法 2：使用管道</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">head</span> -n 50 <span class="built_in">test</span> | <span class="built_in">tail</span> -n 1    <span class="comment"># 先用 head 提取前 50 行，再用 tail 提取最后一行（即第 50 行）</span></span><br></pre></td></tr></table></figure><p>这种方法可以灵活提取文件中间的指定行，通过 <code>head</code> 和 <code>tail</code> 的组合，方便地提取任何位置的内容。</p><hr><h3 id="时间相关的指令"><a href="#时间相关的指令" class="headerlink" title="时间相关的指令"></a>时间相关的指令</h3><p>在 Linux 中，时间相关的操作可以通过 <code>date</code> 命令进行。<code>date</code> 命令用于显示和设置系统的日期和时间，同时它也支持转换时间戳，格式化输出等功能。</p><h3 id="date-——-显示和设置日期与时间"><a href="#date-——-显示和设置日期与时间" class="headerlink" title="date —— 显示和设置日期与时间"></a><code>date</code> —— 显示和设置日期与时间</h3><p><code>date</code> 命令用于显示当前的日期和时间，或者设置系统的时间。</p><p><strong>1. 显示当前时间：</strong> <code>date</code> 可以按照指定的格式显示当前的日期和时间。语法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">date</span> [OPTION]... [+FORMAT]</span><br></pre></td></tr></table></figure><ul><li><code>+FORMAT</code> 可以自定义显示的时间格式，格式由一系列标记组成，常见的标记有：</li></ul><table><thead><tr><th><strong>标记</strong></th><th><strong>含义</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td><code>%H</code></td><td>小时（00..23）</td><td><code>date +%H</code> → <code>14</code></td></tr><tr><td><code>%M</code></td><td>分钟（00..59）</td><td><code>date +%M</code> → <code>30</code></td></tr><tr><td><code>%S</code></td><td>秒（00..61）</td><td><code>date +%S</code> → <code>15</code></td></tr><tr><td><code>%X</code></td><td>相当于 <code>%H:%M:%S</code></td><td><code>date +%X</code> → <code>14:30:15</code></td></tr><tr><td><code>%d</code></td><td>日（01..31）</td><td><code>date +%d</code> → <code>23</code></td></tr><tr><td><code>%m</code></td><td>月份（01..12）</td><td><code>date +%m</code> → <code>02</code></td></tr><tr><td><code>%Y</code></td><td>完整年份（0000..9999）</td><td><code>date +%Y</code> → <code>2025</code></td></tr><tr><td><code>%F</code></td><td>相当于 <code>%Y-%m-%d</code></td><td><code>date +%F</code> → <code>2025-02-23</code>（这样的格式更 &#x3D;&#x3D;<strong>常用</strong>&#x3D;&#x3D;）</td></tr></tbody></table><p><strong>示例：</strong></p><ul><li><strong><code>date +%Y-%m-%d</code>：</strong> 显示当前日期，格式为 <code>年-月-日</code>，如 <code>2025-02-23</code>。</li><li><strong><code>date +%H:%M:%S</code></strong>：显示当前时间，格式为 <code>小时:分钟:秒</code>，如 <code>14:30:15</code>。</li><li><strong><code>date +%F</code></strong>：显示当前日期，格式为 <code>年-月-日</code>，如 <code>2025-02-23</code>。</li></ul><p><strong>2. 设置时间：</strong></p><p><code>date</code> 命令也可以用来设置系统的日期和时间。此功能通常需要 root 权限才能执行。</p><p><strong>语法：<code>date -s &quot;YYYY-MM-DD HH:MM:SS&quot;</code></strong></p><p><strong>设置日期和时间：</strong> 可以用 <code>-s</code> 选项设置日期和时间。例如：</p><ul><li><strong><code>date -s &quot;2025-02-23 01:01:01&quot;</code></strong>：将系统时间设置为 <code>2025-02-23 01:01:01</code>。</li><li><strong><code>date -s &quot;01:01:01&quot;</code></strong>：设置具体的时间（日期保持当前系统时间）。</li><li><strong><code>date -s &quot;2025-02-23&quot;</code></strong>：仅设置日期为 <code>2025-02-23</code>，时间默认为 <code>00:00:00</code>。</li><li><strong><code>date -s &quot;01:01:01 2025-02-23&quot;</code></strong>：设置日期和时间为 <code>2025-02-23 01:01:01</code>。</li></ul><p><strong>3. 时间戳相关操作：</strong></p><p><code>date</code> 命令可以方便地在日期和时间与 Unix 时间戳之间进行转换。</p><ul><li><p><strong>日期转换为时间戳：<code>date +%s</code></strong>：这将输出当前时间的 Unix 时间戳，表示从 <code>1970年1月1日 00:00:00 UTC（协调世界时）</code> 到当前时间所经过的秒数。<strong>示例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">date</span> +%s</span><br><span class="line"><span class="comment"># 输出类似: 1738486946</span></span><br></pre></td></tr></table></figure></li><li><p><strong>时间戳转换为日期：</strong> 使用 <code>-d</code> 选项和 <code>@&lt;时间戳&gt;</code>，可以将 Unix 时间戳转换为可读的日期和时间。<code>date -d @1738486946</code>：这将输出 Unix 时间戳 <code>1738486946</code> 对应的日期和时间。<strong>示例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">date</span> -d @1738486946</span><br><span class="line"><span class="comment"># 输出类似: Sun Feb  2 17:02:26 CST 2025</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">date</span> -d @0</span><br><span class="line">Thu Jan  1 08:00:00 CST 1970</span><br><span class="line"><span class="comment"># 这里日期其实应该是1970年1月1日 00:00:00，但是由于CST（中国标准时间）是 UTC +8 时区，所以它比 UTC 时间快 8 小时。</span></span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="cal-——-显示日历"><a href="#cal-——-显示日历" class="headerlink" title="cal —— 显示日历"></a><code>cal</code> —— 显示日历</h3><p><code>cal</code> 命令是 Linux 中用来显示公历（阳历）日历的命令，广泛用于查看某个月或某一年的日历。<code>cal</code> 显示的日历基于公历（格列历），通常用于日常的时间安排或日期查询。</p><p><strong>1. 语法：<code>cal [参数] [月份] [年份]</code></strong></p><ul><li><strong>月份</strong>：指定某个月的日历，1 到 12 的整数，表示月份。</li><li><strong>年份</strong>：指定某一年的日历，1 到 9999 的整数，表示年份。</li></ul><p><strong>2. 常用选项：</strong></p><table><thead><tr><th><strong>选项</strong></th><th><strong>解释说明</strong></th><th><strong>示例与说明</strong></th></tr></thead><tbody><tr><td><code>-3</code></td><td>显示系统前一个月、当前月和下一个月的月历</td><td><code>cal -3</code>：显示当前月及前后一个月的日历。</td></tr><tr><td><code>-j</code></td><td>显示当前日期在当年中的第几天（默认显示当前月在一年中的天数）</td><td><code>cal -j</code>：显示当前月份和当前日期在一年中的第几天。</td></tr><tr><td><code>-y</code></td><td>显示当前年份的完整日历</td><td><code>cal -y</code>：显示当前年份的完整日历。</td></tr><tr><td><code>-m</code></td><td>显示指定月份的日历（不指定年份默认当前年份）</td><td><code>cal 6</code>：显示当前年份的 6 月份日历。</td></tr><tr><td><code>-A</code></td><td>显示当前月份及其后 <code>A</code> 个月的日历</td><td><code>cal -A 3</code>：显示当前月份及之后 3 个月的日历。</td></tr><tr><td><code>-B</code></td><td>显示当前月份及其前 <code>B</code> 个月的日历</td><td><code>cal -B 2</code>：显示当前月份及之前 2 个月的日历。</td></tr></tbody></table><p><strong>3. 示例：</strong></p><ul><li><p><strong>查看当前月份的日历：<code>cal</code></strong>：默认显示当前月的日历。</p></li><li><p><strong>查看指定月份和年份的日历：<code>cal 12 2025</code></strong>：显示 2025 年 12 月的日历。</p></li><li><p><strong>查看当前年份的完整日历：<code>cal -y</code>：</strong> 显示完整的当前年份的日历。</p></li><li><p><strong>查看当前月、前一个月和下一个月的日历：<code>cal -3</code></strong>：显示当前月、前一个月和下一个月的日历。</p></li><li><p><strong>查看当前日期是今年的第几天：<code>cal -j</code></strong>：显示当前日期是当前年份的第几天。</p></li><li><p>如果你只输入一个数字 <code>cal 12</code>，它会默认显示当前年份的指定月份 <code>12</code> 的日历。</p></li><li><p><code>cal -A</code> 和 <code>cal -B</code> 可以让你一次性查看前后的月份。</p></li></ul><hr><h3 id="指令（通配符）"><a href="#指令（通配符）" class="headerlink" title="* 指令（通配符）"></a><code>*</code> 指令（通配符）</h3><p>在 Linux 中，<code>*</code> 并不是一个命令，而是一个常用的通配符（wildcard），表示匹配任意数量的字符（包括零个字符）。它在文件名扩展（glob）操作中被广泛使用，特别是在命令行中与其他命令一起使用，它可以用于匹配文件或目录的名称，常用于文件查找、复制、删除等操作。</p><p><strong>常见用途：</strong></p><ol><li><p><strong>匹配所有文件</strong>：<code>*</code> 可以用来匹配当前目录下所有的文件和子目录（包括隐藏文件和目录除外）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> *</span><br></pre></td></tr></table></figure></li><li><p><strong>匹配特定类型的文件</strong>：使用 <code>*</code> 来匹配特定类型的文件，例如所有 <code>.txt</code> 文件，该命令会列出当前目录下所有扩展名为 <code>.txt</code> 的文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> *.txt</span><br></pre></td></tr></table></figure></li><li><p><strong>匹配多个字符</strong>：<code>*</code> 可以替代文件名中的任意字符（包括多个字符），比如查找包含特定前缀或后缀的文件，该命令会列出所有以 <code>file</code> 开头的文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> file*</span><br></pre></td></tr></table></figure></li><li><p><strong>与其他命令结合使用</strong>：<code>*</code> 可以与其他命令结合使用来实现批量操作，该命令会删除当前目录下所有扩展名为 <code>.log</code> 的文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> *.<span class="built_in">log</span></span><br></pre></td></tr></table></figure></li></ol><p><strong>注意事项：</strong></p><ul><li><code>*</code> 只匹配非隐藏文件。如果你需要包括隐藏文件，可以使用 <code>.*</code> 或 <code>.* *</code> 来匹配。</li><li><code>*</code> 不匹配目录结构中的分隔符 <code>/</code>，即它不会匹配子目录的名字。</li><li>如果文件名中包含特殊字符（如空格、星号、问号等），你可能需要用引号或转义字符来处理这些字符。</li></ul><hr><h3 id="whereis-指令-——-查找命令的相关文件"><a href="#whereis-指令-——-查找命令的相关文件" class="headerlink" title="whereis 指令 —— 查找命令的相关文件"></a><code>whereis</code> 指令 —— 查找命令的相关文件</h3><p><code>whereis</code> 是 Linux 中用来查找命令的二进制文件、源代码文件和手册页位置的命令。它不会像 <code>which</code> 命令那样仅搜索 <code>PATH</code> 环境变量指定的目录，而是搜索一些常见的系统路径。通常用于快速定位某个命令或程序的安装位置，尤其是二进制文件和相关文档。</p><p><strong>语法：<code>whereis [选项] [命令或文件]</code></strong></p><p><strong>常用选项：</strong></p><table><thead><tr><th align="center"><strong>选项</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td align="center"><code>-b</code></td><td>查找命令的二进制文件（binary files）。</td></tr><tr><td align="center"><code>-m</code></td><td>查找命令的手册页（man pages）。</td></tr><tr><td align="center"><code>-s</code></td><td>查找命令的源代码文件（source files）。</td></tr><tr><td align="center"><code>-u</code></td><td>显示未找到命令的路径。</td></tr></tbody></table><p><strong>基本用法：</strong></p><ol><li><p><strong>查找命令的二进制文件、源代码和手册页：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whereis <span class="built_in">ls</span></span><br></pre></td></tr></table></figure><p>该命令会查找 <code>ls</code> 命令的相关文件，输出类似：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span>: /bin/ls /usr/share/man/man1/ls.1.gz</span><br></pre></td></tr></table></figure><p>这表示 <code>ls</code> 的二进制文件位于 <code>/bin/ls</code>，手册页位于 <code>/usr/share/man/man1/ls.1.gz</code>。</p></li><li><p><strong>仅查找命令的二进制文件：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whereis -b <span class="built_in">ls</span></span><br></pre></td></tr></table></figure><p>该命令只查找 <code>ls</code> 的二进制文件，输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span>: /bin/ls</span><br></pre></td></tr></table></figure></li><li><p><strong>仅查找命令的手册页：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whereis -m <span class="built_in">ls</span></span><br></pre></td></tr></table></figure><p>该命令只查找 <code>ls</code> 的手册页，输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span>: /usr/share/man/man1/ls.1.gz</span><br></pre></td></tr></table></figure></li><li><p><strong>仅查找命令的源代码文件：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whereis -s <span class="built_in">ls</span></span><br></pre></td></tr></table></figure><p>该命令查找 <code>ls</code> 的源代码文件，如果系统中有相关源代码，则会输出相关路径。</p></li><li><p><strong>查找命令或程序是否安装：</strong> 如果你 <strong>不知道某个命令是否安装</strong>，可以用 <code>whereis</code> 检查该命令的位置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whereis xyz</span><br></pre></td></tr></table></figure><p>如果返回为空，说明该命令或文件在系统中未找到。</p></li></ol><p><strong>注意事项：</strong></p><ul><li><code>whereis</code> 搜索的目录是固定的，主要包括系统的标准目录，比如 <code>/bin</code>、<code>/usr/bin</code>、<code>/sbin</code>、<code>/usr/sbin</code> 等，因此它可能不会显示在其他非标准路径上的文件。</li><li>与 <code>which</code> 命令不同，<code>whereis</code> 搜索的范围更广，包含了手册页和源代码等信息。</li></ul><hr><h3 id="find-——-在文件系统中查找文件（非常重要）"><a href="#find-——-在文件系统中查找文件（非常重要）" class="headerlink" title="find —— 在文件系统中查找文件（非常重要）"></a><code>find</code> —— 在文件系统中查找文件（非常重要）</h3><p><code>find</code> 是一个功能强大的 Linux 命令，用于在文件系统中查找文件或目录，并对它们执行指定的操作。由于 Linux 的文件系统通常包含大量文件，<code>find</code> 命令提供了高效的查找功能，并支持多种条件和操作，非常适用于搜索文件、管理文件、批量处理文件等任务。</p><p><strong>1. 语法：<code>find [路径] [选项] [条件] [操作]</code></strong></p><ul><li><strong>路径</strong>：指定查找的目录路径，如果不指定路径，默认为当前目录。</li><li><strong>选项</strong>：用于修改 <code>find</code> 命令的行为。</li><li><strong>条件</strong>：定义查找的条件，例如按文件名、修改时间、文件大小等查找。</li><li><strong>操作</strong>：在查找到符合条件的文件后，执行相应的操作，如显示文件、删除文件、修改文件权限等。</li></ul><p><strong>2. 常用选项和条件：</strong></p><table><thead><tr><th><strong>选项&#x2F;条件</strong></th><th><strong>解释说明</strong></th><th><strong>示例与说明</strong></th></tr></thead><tbody><tr><td><code>-name</code></td><td>按文件名查找文件，支持通配符 <code>*</code>、<code>?</code> 等匹配方式。</td><td><code>find /home -name &quot;*.txt&quot;</code>：在 <code>/home</code> 目录下查找所有 <code>.txt</code> 文件。</td></tr><tr><td><code>-type</code></td><td>按文件类型查找文件，常用类型有 <code>f</code>（普通文件）、<code>d</code>（目录）、<code>l</code>（符号链接）等。</td><td><code>find / -type f</code>：查找系统中所有普通文件。</td></tr><tr><td><code>-size</code></td><td>按文件大小查找文件，支持指定文件大小单位（<code>b</code>、<code>c</code>、<code>k</code>、<code>M</code> 等）。</td><td><code>find /var -size +10M</code>：查找 <code>/var</code> 目录下大于 10MB 的文件。</td></tr><tr><td><code>-mtime</code></td><td>按修改时间查找文件，单位为天数，<code>+</code> 表示大于指定天数，<code>-</code> 表示小于指定天数。</td><td><code>find /tmp -mtime -7</code>：查找最近 7 天内修改过的文件。</td></tr><tr><td><code>-atime</code></td><td>按访问时间查找文件，单位为天数，<code>+</code> 和 <code>-</code> 与 <code>-mtime</code> 类似。</td><td><code>find /home/user -atime +30</code>：查找 30 天前访问过的文件。</td></tr><tr><td><code>-exec</code></td><td>对查找到的文件执行指定的命令，常用于批量处理文件。</td><td><code>find /home -name &quot;*.log&quot; -exec rm -f &#123;&#125; \;</code>：查找并删除所有 <code>.log</code> 文件。</td></tr><tr><td><code>-print</code></td><td>显示查找到的文件，默认情况下会显示。</td><td><code>find /home -name &quot;*.txt&quot; -print</code>：查找 <code>.txt</code> 文件并显示它们。</td></tr><tr><td><code>-maxdepth</code></td><td>限制查找的目录层级，防止遍历过深的目录结构。</td><td><code>find / -maxdepth 2</code>：查找 <code>/</code> 目录下最多 2 层的文件。</td></tr><tr><td><code>-mindepth</code></td><td>限制查找的最小目录层级。</td><td><code>find / -mindepth 2</code>：查找 <code>/</code> 目录下从第二层开始的文件。</td></tr></tbody></table><p><strong>3. 示例：</strong></p><ul><li><p><strong>按文件名查找文件：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /home/user -name <span class="string">&quot;*.txt&quot;</span><span class="comment"># 查找 `/home/user` 目录下所有扩展名为 `.txt` 的文件</span></span><br></pre></td></tr></table></figure></li><li><p><strong>查找特定类型的文件：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -<span class="built_in">type</span> d -name <span class="string">&quot;Documents&quot;</span><span class="comment"># 查找系统中所有名为 `Documents` 的目录</span></span><br></pre></td></tr></table></figure></li><li><p><strong>查找最近 7 天内修改过的文件：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /tmp -mtime -7<span class="comment"># 查找 `/tmp` 目录下最近 7 天内修改过的文件</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /var/log -name <span class="string">&quot;*.log&quot;</span> -mtime +7 -<span class="built_in">exec</span> <span class="built_in">rm</span> &#123;&#125; \;<span class="comment"># 查找并删除7天前的日志文件</span></span><br></pre></td></tr></table></figure></li><li><p><strong>查找并删除文件：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /home/user -name <span class="string">&quot;*.bak&quot;</span> -<span class="built_in">exec</span> <span class="built_in">rm</span> -f &#123;&#125; \;<span class="comment">#查找 `/home/user` 目录下所有扩展名为 `.bak` 的文件，并删除它们</span></span><br></pre></td></tr></table></figure></li><li><p><strong>查找并显示所有文件的大小：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /var -<span class="built_in">type</span> f -<span class="built_in">exec</span> <span class="built_in">du</span> -h &#123;&#125; \;<span class="comment"># 查找 `/var` 目录下所有的普通文件，并显示它们的大小</span></span><br></pre></td></tr></table></figure></li><li><p><strong>查找并显示文件的权限：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -name <span class="string">&quot;*.sh&quot;</span> -<span class="built_in">exec</span> <span class="built_in">ls</span> -l &#123;&#125; \;<span class="comment"># 查找所有 `.sh` 文件，并显示它们的详细权限和属性</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>4. 小技巧：</strong></p><ul><li><p><strong>使用 <code>-prune</code> 跳过某些目录：</strong> 如果你想跳过某些目录，可以使用 <code>-prune</code> 选项。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">find /home -path <span class="string">&quot;/home/user/ignore&quot;</span> -prune -o -name <span class="string">&quot;*.txt&quot;</span> -<span class="built_in">print</span></span><br><span class="line"><span class="comment"># 这个命令会跳过 `/home/user/ignore` 目录，只查找其他 `.txt` 文件</span></span><br></pre></td></tr></table></figure></li><li><p><strong>结合 <code>-exec</code> 使用 <code>&#123;&#125; \;</code> 或 <code>+</code>：</strong> <code>-exec</code> 后面可以跟 <code>&#123;&#125;</code> 来代表当前查找到的文件。</p><ul><li><code>\;</code>：每找到一个文件，执行一次命令。</li><li><code>+</code>：将多个文件作为一次命令的参数传递，效率更高。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">find /home -name <span class="string">&quot;*.txt&quot;</span> -<span class="built_in">exec</span> <span class="built_in">cat</span> &#123;&#125; \;</span><br><span class="line">find /home -name <span class="string">&quot;*.txt&quot;</span> -<span class="built_in">exec</span> <span class="built_in">cat</span> &#123;&#125; +</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="grep-指令-——-搜索文件中的字符串"><a href="#grep-指令-——-搜索文件中的字符串" class="headerlink" title="grep 指令 —— 搜索文件中的字符串"></a><code>grep</code> 指令 —— 搜索文件中的字符串</h3><p><code>grep</code> 是一个强大的文本搜索工具，通过指定的字符串（或模式）来查找文件中的匹配内容，并打印出匹配到的行。它的名字来源于 “global regular expression print”，意味着支持使用正则表达式，根据正则表达式搜索内容并打印匹配的行。</p><p><strong>1. 语法：<code>grep [选项] 搜寻字符串 文件</code></strong></p><ul><li><strong>选项</strong>：用于修改 <code>grep</code> 的行为。</li><li><strong>搜寻字符串</strong>：指定需要查找的模式或字符串。</li><li><strong>文件</strong>：指定要搜索的文件，支持多个文件。</li></ul><p><strong>2. 常用选项</strong>：</p><table><thead><tr><th><strong>选项</strong></th><th><strong>解释说明</strong></th><th><strong>示例与说明</strong></th></tr></thead><tbody><tr><td><code>-i</code></td><td>忽略大小写，匹配时不区分大小写</td><td><code>grep -i &quot;pattern&quot; file.txt</code>：搜索文件中的 “pattern”，忽略大小写。</td></tr><tr><td><code>-n</code></td><td>显示匹配行的行号</td><td><code>grep -n &quot;pattern&quot; file.txt</code>：输出匹配行和相应的行号。</td></tr><tr><td><code>-v</code></td><td>反向选择，显示不包含匹配字符串的行</td><td><code>grep -v &quot;pattern&quot; file.txt</code>：输出不包含 “pattern” 的行。</td></tr><tr><td><code>-r</code> 或 <code>-R</code></td><td>递归查找目录下的文件，<code>-r</code> 和 <code>-R</code> 功能相同，保留两者仅为兼容性考虑。</td><td><code>grep -r &quot;pattern&quot; dir/</code>：在 <code>dir/</code> 目录及其子目录下查找 “pattern”。</td></tr><tr><td><code>-l</code></td><td>只输出包含匹配字符串的文件名，而不是具体内容</td><td><code>grep -l &quot;pattern&quot; *.txt</code>：列出包含 “pattern” 的所有 <code>.txt</code> 文件。</td></tr><tr><td><code>-w</code></td><td>只匹配整个单词（完全匹配）</td><td><code>grep -w &quot;word&quot; file.txt</code>：只匹配整个 “word”，而不是 “wording”。</td></tr><tr><td><code>-c</code></td><td>显示匹配行的数量</td><td><code>grep -c &quot;pattern&quot; file.txt</code>：显示文件中 “pattern” 出现的次数。</td></tr><tr><td><code>-H</code></td><td>显示匹配内容的文件名（默认启用，仅针对多个文件）</td><td><code>grep -H &quot;pattern&quot; *.txt</code>：显示文件名和匹配内容。</td></tr><tr><td><code>-A NUM</code></td><td>显示匹配行之后的 <code>NUM</code> 行</td><td><code>grep -A 3 &quot;pattern&quot; file.txt</code>：显示匹配行及其后的 3 行内容。</td></tr><tr><td><code>-B NUM</code></td><td>显示匹配行之前的 <code>NUM</code> 行</td><td><code>grep -B 2 &quot;pattern&quot; file.txt</code>：显示匹配行及其前的 2 行内容。</td></tr><tr><td><code>-C NUM</code></td><td>显示匹配行前后的 <code>NUM</code> 行</td><td><code>grep -C 3 &quot;pattern&quot; file.txt</code>：显示匹配行及其前后的 3 行内容。</td></tr></tbody></table><p><strong>3. 使用示例</strong>：</p><ol><li><p><strong>忽略大小写查找</strong>：在 <code>file.txt</code> 文件中查找 “hello”（忽略大小写），无论是 “Hello”、”HELLO” 还是 “hElLo” 都会匹配：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -i <span class="string">&quot;hello&quot;</span> file.txt</span><br></pre></td></tr></table></figure></li><li><p><strong>显示行号</strong>：查找 <code>file.txt</code> 中的 “pattern”，并输出匹配行的行号：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -n <span class="string">&quot;pattern&quot;</span> file.txt</span><br></pre></td></tr></table></figure></li><li><p><strong>反向选择（显示不匹配的行）</strong>：显示 <code>file.txt</code> 中不包含 “pattern” 的所有行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -v <span class="string">&quot;pattern&quot;</span> file.txt</span><br></pre></td></tr></table></figure></li><li><p><strong>递归查找目录中的文件</strong>：在指定的目录及其子目录下递归查找包含 “pattern” 的文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -r <span class="string">&quot;pattern&quot;</span> /path/to/directory/</span><br></pre></td></tr></table></figure></li><li><p><strong>只显示匹配行的文件名</strong>：列出当前目录下所有包含 “pattern” 的 <code>.txt</code> 文件，不显示具体的匹配内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -l <span class="string">&quot;pattern&quot;</span> *.txt</span><br></pre></td></tr></table></figure></li><li><p><strong>显示匹配行及其上下文</strong>：在 <code>file.txt</code> 中查找 “pattern”，并显示匹配行及其后面 2 行的内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -A 2 <span class="string">&quot;pattern&quot;</span> file.txt</span><br></pre></td></tr></table></figure></li></ol><hr><h3 id="zip-unzip-指令-——-压缩和解压缩文件"><a href="#zip-unzip-指令-——-压缩和解压缩文件" class="headerlink" title="zip &#x2F; unzip 指令 —— 压缩和解压缩文件"></a><code>zip</code> &#x2F; <code>unzip</code> 指令 —— 压缩和解压缩文件</h3><p>Linux 中压缩文件的格式非常多，需要时查找对应的资料即可。虽然有多种压缩格式，但 <code>.zip</code> 格式却是最常用的之一，它广泛用于存储和传输多个文件和目录。<code>zip</code> 和 <code>unzip</code> 是 Linux 系统中用于压缩和解压缩 <code>.zip</code> 格式文件的常用工具，<code>.zip</code> 常用主要原因如下：</p><ul><li><strong>广泛兼容</strong>：<code>.zip</code> 格式几乎可以在所有操作系统（Windows、Linux、macOS）中轻松打开和创建，因此跨平台兼容性非常强。</li><li><strong>简便易用</strong>：使用 <code>zip</code> 和 <code>unzip</code> 命令在 Linux 中非常简单，且支持压缩多个文件和目录。</li><li><strong>易于理解</strong>：<code>.zip</code> 格式的操作相对直观，且不需要额外的工具或插件，特别适合日常使用。</li></ul><table><thead><tr><th>多种压缩格式</th><th>说明</th><th>常用工具</th><th>备注</th></tr></thead><tbody><tr><td><code>.zip</code></td><td>最常用的压缩格式，广泛兼容于不同操作系统</td><td><code>zip</code>, <code>unzip</code></td><td>适合日常使用，跨平台支持好</td></tr><tr><td><code>.tar</code></td><td>归档格式，不进行压缩，常与其他压缩工具结合</td><td><code>tar</code></td><td>常与 <code>gzip</code> 或 <code>bzip2</code> 一起使用</td></tr><tr><td><code>.gz</code></td><td><code>gzip</code> 压缩格式，通常与 <code>.tar</code> 配合使用</td><td><code>gzip</code>, <code>gunzip</code></td><td>适合单个文件压缩</td></tr><tr><td><code>.bz2</code></td><td><code>bzip2</code> 压缩格式，比 <code>gzip</code> 压缩率更高</td><td><code>bzip2</code>, <code>bunzip2</code></td><td>常与 <code>tar</code> 一起使用</td></tr><tr><td><code>.xz</code></td><td><code>xz</code> 压缩格式，压缩率非常高</td><td><code>xz</code>, <code>unxz</code></td><td>适用于大文件压缩，压缩率高</td></tr><tr><td><code>.7z</code></td><td><code>7zip</code> 压缩格式，压缩比非常高</td><td><code>7zip</code></td><td>常用于 Windows 和 Linux 之间交换文件</td></tr><tr><td><code>.rar</code></td><td><code>RAR</code> 压缩格式，通常需要额外工具来解压</td><td><code>rar</code>, <code>unrar</code></td><td>常用于 Windows 环境</td></tr><tr><td><code>.tar.Z</code></td><td>旧的 <code>compress</code> 工具格式，逐渐被替代</td><td><code>compress</code>, <code>uncompress</code></td><td>已被 <code>gzip</code> 和 <code>bzip2</code> 替代</td></tr></tbody></table><p><strong>对于其他压缩格式的使用：</strong></p><ul><li><strong><code>.tar.gz</code> &#x2F; <code>.tar.bz2</code> &#x2F; <code>.tar.xz</code></strong>：这些格式在 Linux 环境下非常流行，尤其在打包和备份数据时。如果你不熟悉这些格式，查阅相关文档即可。</li><li><strong><code>.7z</code></strong>：虽然这个格式在 Linux 上也支持，但它主要用于高压缩率需求的场景，或者作为 Windows 环境中的常用格式。</li><li><strong><code>.rar</code></strong>：对于 <code>.rar</code> 文件，Linux 默认没有支持解压的工具，但可以通过安装 <code>unrar</code> 工具来支持。</li></ul><p><strong>&#x3D;&#x3D;在 Linux 上，某些解压工具默认可能没有安装，你可以百度一下安装命令进行安装，注意：根据不同的 Linux 发行版，使用的包管理器不同！&#x3D;&#x3D;</strong></p><p><strong>1. <code>zip</code> 指令 —— 压缩文件</strong>，用于将文件或目录压缩成 <code>.zip</code> 格式。</p><p><strong>语法：<code>zip [选项] 压缩文件.zip 文件或目录</code></strong></p><ul><li><strong>选项</strong>：用于指定压缩时的行为。</li><li><strong>压缩文件.zip</strong>：指定压缩后的文件名。</li><li><strong>文件或目录</strong>：指定要压缩的文件或目录，可以是多个文件或目录。</li></ul><p><strong>常用选项</strong>：</p><table><thead><tr><th><strong>选项</strong></th><th><strong>解释说明</strong></th><th><strong>示例与说明</strong></th></tr></thead><tbody><tr><td><code>-r</code></td><td><strong>支持递归</strong> 处理目录，包含子目录及其中的文件</td><td><code>zip -r archive.zip folder/</code>：压缩 <code>folder</code> 目录及其所有文件和子目录。</td></tr><tr><td><code>-e</code></td><td>在压缩时加密，要求输入密码</td><td><code>zip -e archive.zip file.txt</code>：压缩文件并加密，需要输入密码。</td></tr><tr><td><code>-q</code></td><td>静默模式，不输出任何压缩过程信息</td><td><code>zip -q archive.zip file1.txt file2.txt</code>：压缩文件，不显示进度信息。</td></tr><tr><td><code>-x</code></td><td>排除某些文件或目录</td><td><code>zip -r archive.zip folder/ -x &quot;*.bak&quot;</code>：压缩 <code>folder</code> 目录，但排除 <code>.bak</code> 文件。</td></tr><tr><td><code>-9</code></td><td>使用最佳压缩级别（最慢但最小文件）</td><td><code>zip -9 archive.zip folder/</code>：使用最强压缩来压缩 <code>folder</code> 目录。</td></tr><tr><td><code>-j</code></td><td>不保存文件的路径信息，只保存文件本身</td><td><code>zip -j archive.zip file1.txt file2.txt</code>：只压缩文件，不保存目录结构。</td></tr></tbody></table><p><strong>示例</strong>：</p><ol><li><p><strong>压缩文件</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zip archive.zip file1.txt file2.txt<span class="comment"># 将 `file1.txt` 和 `file2.txt` 压缩成 `archive.zip` 文件</span></span><br></pre></td></tr></table></figure></li><li><p><strong>递归压缩目录</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zip -r archive.zip folder/<span class="comment"># 将 `folder/` 目录及其中的所有文件和子目录压缩为 `archive.zip` 文件</span></span><br></pre></td></tr></table></figure></li><li><p><strong>排除文件</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zip -r archive.zip folder/ -x <span class="string">&quot;*.bak&quot;</span><span class="comment"># 压缩 `folder/` 目录，但排除所有 `.bak` 文件</span></span><br></pre></td></tr></table></figure></li><li><p><strong>使用加密</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zip -e archive.zip file1.txt<span class="comment"># 压缩 `file1.txt` 并加密，要求输入密码</span></span><br></pre></td></tr></table></figure></li></ol><p><strong>2. <code>unzip</code> 指令 —— 解压缩文件</strong>，用于解压 <code>.zip</code> 格式的压缩文件。</p><p><strong>语法：<code>unzip [选项] 压缩文件.zip</code></strong></p><ul><li><strong>选项</strong>：用于指定解压缩时的行为。</li><li><strong>压缩文件.zip</strong>：&#x3D;&#x3D;指定&#x3D;&#x3D; 要解压的 <code>.zip</code> 文件。</li></ul><p><strong>常用选项</strong>：</p><table><thead><tr><th><strong>选项</strong></th><th><strong>解释说明</strong></th><th><strong>示例与说明</strong></th></tr></thead><tbody><tr><td><code>-d</code></td><td>指定解压的目标目录</td><td><code>unzip archive.zip -d /path/to/destination/</code>：将文件解压到指定目录。</td></tr><tr><td><code>-l</code></td><td>列出 <code>.zip</code> 文件中的文件内容，而不解压</td><td><code>unzip -l archive.zip</code>：列出压缩包中的文件，不进行解压。</td></tr><tr><td><code>-o</code></td><td>解压时覆盖现有文件，不询问</td><td><code>unzip -o archive.zip</code>：解压时如果文件已存在，则自动覆盖。</td></tr><tr><td><code>-q</code></td><td>静默模式，不输出解压过程信息</td><td><code>unzip -q archive.zip</code>：解压时不显示进度或文件信息。</td></tr><tr><td><code>-j</code></td><td>解压时不保存文件的路径结构，只解压文件本身</td><td><code>unzip -j archive.zip</code>：解压时不保留目录结构。</td></tr><tr><td><code>-n</code></td><td>如果文件已经存在，不解压该文件</td><td><code>unzip -n archive.zip</code>：解压时如果文件已存在，不会覆盖它。</td></tr></tbody></table><p><strong>示例</strong>：</p><ol><li><p><strong>解压 <code>.zip</code> 文件</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip archive.zip<span class="comment"># 将 `archive.zip` 文件解压到当前目录</span></span><br></pre></td></tr></table></figure></li><li><p><strong>指定解压到目标目录</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip archive.zip -d /path/to/destination/<span class="comment"># 将 `archive.zip` 解压到 `/path/to/destination/` 目录</span></span><br></pre></td></tr></table></figure></li><li><p><strong>列出 <code>.zip</code> 文件中的内容</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip -l archive.zip<span class="comment"># 列出 `archive.zip` 文件中包含的所有文件，而不进行解压</span></span><br></pre></td></tr></table></figure></li><li><p><strong>解压时自动覆盖现有文件</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip -o archive.zip<span class="comment"># 解压时，如果目标目录已有同名文件，会自动覆盖现有文件</span></span><br></pre></td></tr></table></figure></li></ol><hr><h3 id="tar-指令-——-打包和解包文件"><a href="#tar-指令-——-打包和解包文件" class="headerlink" title="tar 指令 —— 打包和解包文件"></a><code>tar</code> 指令 —— 打包和解包文件</h3><p><code>tar</code> 是 Linux 中一个非常重要的命令，通常用来打包（归档）和解包（提取）文件。它不仅可以压缩文件，还可以将多个文件或目录合并成一个文件，便于传输和存储。<code>tar</code> 通常与其他压缩工具（如 <code>gzip</code>、<code>bzip2</code>）结合使用，以减少文件大小。</p><p><strong>语法：<code>tar [选项] [文件名] [目录或文件]</code></strong></p><p><strong>常用选项</strong>：</p><table><thead><tr><th align="center"><strong>选项</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td align="center"><code>-c</code></td><td>创建一个新的压缩包（create）。</td></tr><tr><td align="center"><code>-x</code></td><td>解压文件（extract）。</td></tr><tr><td align="center"><code>-t</code></td><td>列出压缩包中的文件内容（list）。</td></tr><tr><td align="center"><code>-z</code></td><td>使用 <code>gzip</code> 压缩或解压缩文件。</td></tr><tr><td align="center"><code>-j</code></td><td>使用 <code>bzip2</code> 压缩或解压缩文件。</td></tr><tr><td align="center"><code>-v</code></td><td>显示详细信息（verbose），即在压缩或解压过程中显示文件。</td></tr><tr><td align="center"><code>-f</code></td><td>指定压缩包的文件名（file）。</td></tr><tr><td align="center"><code>-C</code></td><td>解压时指定目录，将文件解压到指定的目录。</td></tr><tr><td align="center"><code>-p</code></td><td>保持文件的原始权限。</td></tr><tr><td align="center"><code>--exclude</code></td><td>排除指定的文件或目录。</td></tr><tr><td align="center"><code>-N</code></td><td>只备份比指定日期更新的文件。</td></tr></tbody></table><p><strong>基本用法：</strong></p><ol><li><p><strong>将目录打包成 <code>.tar</code> 文件</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -cvf etc.tar ./etc    <span class="comment"># 打包当前目录下的 `etc` 目录</span></span><br></pre></td></tr></table></figure></li><li><p><strong>将目录打包并压缩成 <code>.tar.gz</code> 文件</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zcvf /tmp/etc.tar.gz /etc<span class="comment"># 将 `/etc` 目录打包并使用 `gzip` 压缩，生成 `.tar.gz` 文件</span></span><br></pre></td></tr></table></figure></li><li><p><strong>将目录打包并压缩成 <code>.tar.bz2</code> 文件</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -jcvf /tmp/etc.tar.bz2 /etc<span class="comment"># 将 `/etc` 目录打包并使用 `bzip2` 压缩，生成 `.tar.bz2` 文件</span></span><br></pre></td></tr></table></figure></li><li><p><strong>查看 <code>.tar.gz</code> 文件中的内容</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -ztvf /tmp/etc.tar.gz<span class="comment"># 列出压缩包 `etc.tar.gz` 中的文件内容。`z` 选项是因为使用了 `gzip` 压缩</span></span><br></pre></td></tr></table></figure></li><li><p><strong>解压 <code>.tar.gz</code> 文件到指定目录</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf /tmp/etc.tar.gz -C /usr/local/src<span class="comment"># 解压 `etc.tar.gz` 文件并将内容解压到 `/usr/local/src` 目录下</span></span><br></pre></td></tr></table></figure></li><li><p><strong>只提取 <code>.tar.gz</code> 文件中的某一特定文件</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf /tmp/etc.tar.gz etc/passwd</span><br><span class="line"><span class="comment"># 解压 `etc.tar.gz` 文件中的 `etc/passwd` 文件到当前目录。注意，在 `tar` 文件内的路径可能去除了前导的 `/`，这也是为何没有 `/etc/passwd` 这样的绝对路径</span></span><br></pre></td></tr></table></figure></li><li><p><strong>备份文件时保留文件权限</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvpf /tmp/etc.tar.gz /etc<span class="comment"># 使用 `-p` 选项来确保在备份过程中保留文件的权限</span></span><br></pre></td></tr></table></figure></li><li><p><strong>备份特定日期之后的文件</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -N <span class="string">&quot;2025/12/31&quot;</span> -zcvf home.tar.gz /home<span class="comment"># 备份 `/home` 目录下自 2025 年 12 月 31 日以来的文件。</span></span><br></pre></td></tr></table></figure></li><li><p><strong>排除某个目录或文件进行备份</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar --exclude=/home/user/temp -zcvf mybackup.tar.gz /home<span class="comment">#备份 `/home` 目录，但排除了 `/home/user/temp` 目录</span></span><br></pre></td></tr></table></figure></li><li><p><strong>在没有生成文件的情况下直接解压到目标目录</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar -cvf - /etc | tar -xvf - -C /tmp</span><br><span class="line"><span class="comment"># 使用管道（`|`）来传递输出，这样就可以直接将 `/etc` 目录的内容解压到 `/tmp` 目录，而无需在中间创建一个 `.tar` 文件</span></span><br></pre></td></tr></table></figure></li></ol><p><strong>注意事项：</strong></p><ul><li><code>tar</code> 默认会保留文件的权限、时间戳等属性，特别是在备份系统文件时非常重要。</li><li>使用 <code>-C</code> 选项时，解压内容会被放置在指定的目录中，而不是当前工作目录。</li><li><code>tar</code> 解包时，如果文件已存在，会覆盖原有文件，使用时需要小心。</li><li><code>.tar</code> 文件本身并不压缩，通常是用来打包多个文件和目录。如果需要压缩，应该使用 <code>gzip</code>（<code>.tar.gz</code>）或 <code>bzip2</code>（<code>.tar.bz2</code>）等工具。</li></ul><hr><h3 id="bc-指令-——-命令行计算器"><a href="#bc-指令-——-命令行计算器" class="headerlink" title="bc 指令 —— 命令行计算器"></a><code>bc</code> 指令 —— 命令行计算器</h3><p><code>bc</code> 是 Linux 系统中一个非常强大的命令行计算器，能够执行任意精度的数学运算。它不仅支持整数运算，还支持浮点数、算术运算、逻辑运算、条件判断、循环等，功能非常强大。你可以使用 <code>bc</code> 来进行简单的计算，也可以用它执行复杂的数学表达式，甚至用于脚本编程或需要高精度运算的场景。（<strong>计算器的功能 <code>bc</code> 基本上都支持，更多高级功能请自行百度</strong>）</p><p><strong>语法：<code>bc [选项] [文件]</code></strong></p><ul><li><p>如果没有指定文件，<code>bc</code> 会进入交互模式，等待用户输入表达式进行计算。</p></li><li><p>如果指定了文件，<code>bc</code> 会读取该文件并执行其中的命令。</p></li><li><p>可以执行数学计算，包括整数、浮点数、十六进制、八进制和二进制运算。</p></li><li><p>支持标准的算术运算、数学函数、变量、控制语句（如条件判断和循环）。</p></li><li><p>具有任意精度运算的能力，可以设置计算精度。</p></li></ul><p><strong>常用选项：</strong></p><table><thead><tr><th><strong>选项</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><code>-l</code></td><td>启动数学库，包含常用的数学函数（如 <code>sqrt</code>、<code>sin</code>、<code>cos</code> 等）。</td></tr><tr><td><code>-q</code></td><td>禁止显示提示符。</td></tr></tbody></table><p><strong>基本用法：</strong></p><ol><li><p><strong>进入 <code>bc</code> 交互模式：</strong> 直接运行 <code>bc</code>，进入交互式计算模式。此时你可以直接输入数学表达式，计算结果会立即返回。在进入 <code>bc</code> 后，你可以进行算术运算。例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3 + 2<span class="comment"># 输出：5</span></span><br><span class="line">7 / 3<span class="comment"># 输出：2</span></span><br></pre></td></tr></table></figure></li><li><p><strong>设置精度：</strong> 默认情况下，<code>bc</code> 只执行整数运算。如果需要更高的精度，可以设置小数点后的位数。使用 <code>scale</code> 来指定小数位数，精度可以设置为非常高的值：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scale=10</span><br><span class="line">10 / 3<span class="comment"># 输出：3.3333333333</span></span><br></pre></td></tr></table></figure></li><li><p><strong>执行数学表达式：</strong> 你可以在 <code>bc</code> 中输入复杂的数学表达式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(5 + 3) * 2<span class="comment"># 输出：16</span></span><br></pre></td></tr></table></figure></li><li><p><strong>使用数学函数：</strong> 如果启动了 <code>-l</code> 选项，可以使用内置的数学函数，如 <code>sqrt</code>（平方根）、<code>sin</code>（正弦）、<code>cos</code>（余弦）等：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bc -l</span><br><span class="line">sqrt(16)<span class="comment"># 输出：4</span></span><br></pre></td></tr></table></figure></li><li><p><strong>从文件读取命令：</strong> 你可以将一系列的计算命令保存到文件中，使用 <code>bc</code> 执行。</p></li><li><p><strong>条件语句和循环：</strong> <code>bc</code> 还支持条件语句和循环控制结构。</p></li><li><p><strong>支持进制转换：</strong> <code>bc</code> 支持不同进制之间的转换，例如从二进制到十进制、十六进制到十进制等。二进制转十进制：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ibase=2</span><br><span class="line">1010<span class="comment"># 输出：10</span></span><br></pre></td></tr></table></figure></li></ol><hr><h3 id="uname-r-指令-——-查看内核版本"><a href="#uname-r-指令-——-查看内核版本" class="headerlink" title="uname -r 指令 —— 查看内核版本"></a><code>uname -r</code> 指令 —— 查看内核版本</h3><p><code>uname</code> 命令用于显示系统的相关信息，包括操作系统、内核、硬件平台等。而 <code>uname -r</code> 特别用来显示当前操作系统的 <strong>内核版本</strong>。</p><p><strong>语法：<code>uname -r</code></strong></p><p><strong>示例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">uname</span> -r</span><br><span class="line">3.10.0-1160.119.1.el7.x86_64<span class="comment"># 有兴趣的可以查一下相关内核说明</span></span><br></pre></td></tr></table></figure><p><strong>常见选项：</strong></p><table><thead><tr><th align="center"><strong>选项</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td align="center"><code>-r</code></td><td>显示内核版本。</td></tr><tr><td align="center"><code>-a</code></td><td>显示所有信息（内核名称、主机名、内核版本、硬件平台等）。</td></tr><tr><td align="center"><code>-s</code></td><td>显示内核名称。</td></tr><tr><td align="center"><code>-n</code></td><td>显示网络主机名称（主机名）。</td></tr><tr><td align="center"><code>-v</code></td><td>显示内核版本号及版本信息。</td></tr><tr><td align="center"><code>-m</code></td><td>显示机器硬件名称（比如 <code>x86_64</code>）。</td></tr></tbody></table><p><strong>查看所有系统信息示例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">uname</span> -a</span><br><span class="line">Linux VM-16-11-centos 3.10.0-1160.119.1.el7.x86_64 <span class="comment">#1 SMP Tue Jun 4 14:43:51 UTC 2024 x86_64 x86_64 x86_64 GNU/Linux</span></span><br></pre></td></tr></table></figure><p>其中，<code>uname -a</code> 会输出系统的更多信息，包括：</p><ul><li><strong>内核名称</strong>：<code>Linux</code> 表示操作系统的内核类型。</li><li><strong>主机名</strong>：<code>hostname</code> 为该系统的主机名。</li><li><strong>内核版本</strong>：<code>5.10.0-8-amd64</code> 表示使用的是 Linux 5.10 版本的内核，且支持 AMD64 架构（64 位）。</li><li><strong>内核编译信息</strong>：<code>#1 SMP Debian 5.10.17-1 (2021-03-07)</code> 表示该内核是 Debian 5.10.17-1 版本的编译，构建日期为 <code>2021-03-07</code>，且支持对称多处理（SMP）。</li><li><strong>硬件架构</strong>：<code>x86_64</code> 表示该系统是 64 位架构。</li><li><strong>操作系统</strong>：<code>GNU/Linux</code> 表示该系统是 GNU 操作系统与 Linux 内核组合构成的操作系统。</li></ul><hr><h3 id="shutdown-指令（关机命令）"><a href="#shutdown-指令（关机命令）" class="headerlink" title="shutdown 指令（关机命令）"></a><code>shutdown</code> 指令（关机命令）</h3><p><strong>语法：<code>shutdown [选项] [时间] [原因]</code></strong></p><p><strong>常见选项：</strong></p><table><thead><tr><th align="center"><strong>选项</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td align="center"><code>-h</code></td><td>关闭系统（关机）。停掉系统所有服务后关闭计算机。</td></tr><tr><td align="center"><code>-r</code></td><td>重启系统。停掉系统服务后重新启动计算机。</td></tr><tr><td align="center"><code>-t sec</code></td><td>指定延迟时间（以秒为单位），过 <code>sec</code> 秒后执行关机或重启。</td></tr><tr><td align="center"><code>-c</code></td><td>取消已经计划的关机操作（如果有的话）。</td></tr><tr><td align="center"><code>-P</code></td><td>执行关机后停止电源（适用于支持的硬件）。</td></tr></tbody></table><p><strong>例子：</strong></p><ul><li><strong>立即关机：<code>shutdown -h now</code></strong></li><li><strong>重启系统：<code>shutdown -r now</code></strong></li><li><strong>计划 10 分钟后关机：<code>shutdown -h +10</code></strong></li><li><strong>立即关机并指定原因：<code>shutdown -h now &quot;System maintenance&quot;</code></strong></li><li><strong>取消已经计划的关机：<code>shutdown -c</code></strong></li><li><strong>过 30 秒后关机：<code>shutdown -h -t 30</code></strong></li></ul><hr><h3 id="以下命令作为扩展："><a href="#以下命令作为扩展：" class="headerlink" title="以下命令作为扩展："></a>以下命令作为扩展：</h3><p><strong>◆ 安装和登录命令</strong>：<code>login、shutdown、halt、reboot、install、mount、umount、chsh、exit、last；</code></p><p><strong>◆ 文件处理命令：</strong> <code>file、mkdir、grep、dd、find、mv、ls、diff、cat、ln；</code></p><p><strong>◆ 系统管理相关命令</strong>：<code>df、top、free、quota、at、lp、adduser、groupadd、kill、crontab；</code></p><p><strong>◆ 网络操作命令</strong>：<code>ifconfig、ip、ping、netstat、telnet、ftp、route、rlogin、rcp、finger、mail、 nslookup；</code></p><p><strong>◆ 系统安全相关命令：</strong> <code>passwd、su、umask、chgrp、chmod、chown、chattr、sudo ps、who；</code></p><p><strong>◆ 其它命令：</strong> <code>tar、unzip、gunzip、unarj、mtools、man、unendcode、uudecode。</code></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>007 Linux 开发工具（上）—— vim、解放sudo、gc+</title>
      <link href="/posts/62462.html"/>
      <url>/posts/62462.html</url>
      
        <content type="html"><![CDATA[<h2 id="Linux-开发工具（上）"><a href="#Linux-开发工具（上）" class="headerlink" title="Linux 开发工具（上）"></a>Linux 开发工具（上）</h2><h3 id="Linux-编辑器-——-vim"><a href="#Linux-编辑器-——-vim" class="headerlink" title="Linux 编辑器 —— vim"></a>Linux 编辑器 —— <code>vim</code></h3><p>Vim 是一个强大、多模式的文本编辑器，具有高度的可定制性和丰富的功能。<strong>打开文件</strong>：在命令行中输入 <code>vim filename</code>，打开指定文件。<a href="https://github.com/wsdjeg/vim-galore-zh_cn?tab=readme-ov-file">Vim 从入门到牛逼</a> &#x2F; <a href="https://wsdjeg.net/vim-galore-zh-cn/">Vim 从入门到牛逼（备用）</a></p><p>打开当前目录下的文件 <code>code.c</code>，使用命令：<code>vim code.c</code>，同时 <strong>支持相对路径和绝对路径</strong> 打开：<code>vim home/code.c</code>。</p><h4 id="Vim-的主要模式："><a href="#Vim-的主要模式：" class="headerlink" title="Vim 的主要模式："></a>Vim 的主要模式：</h4><ul><li><strong>命令模式（Normal Mode）</strong>：命令模式是 Vim 的核心模式，几乎所有操作都从这里开始，启动 Vim 后，<strong>默认处于命令模式</strong>。在此模式下，<strong>键盘输入被解释为命令而非文本输入</strong>。只能使用方向键、删除、复制、粘贴等操作用来进行文本的导航、选择、删除、替换等。（按 <code>i</code> 进入插入模式，按 <code>:</code> 进入底行模式，按 <code>Esc</code> 从其他模式返回到命令模式）</li><li><strong>插入模式（Insert Mode）</strong>：按下 <code>i</code> 键进入插入模式。插入模式下可以像普通文本编辑器一样输入文本。按 <code>Esc</code> 键返回命令模式。</li><li><strong>底行模式（Ex Mode 或 Bottom Line Mode）</strong>：底行模式是 Vim 的强大功能之一，支持复杂的文件操作和配置。按下 <code>shift</code>+<code>；</code> （也就是 <code>:</code>） 键进入底行模式。在底行模式下可以执行文件保存、退出、查找替换等命令。例：<code>:wq</code> 保存并退出 Vim。按 <code>Esc</code> 键返回命令模式。（<strong>注意：</strong> <code>Ctrl+C</code> 也可以退出底行模式并返回命令模式，尽量不要使用，可能会出现未知错误）</li></ul><h4 id="Vim-命令模式下的一些常用操作-史上最全-Vim-快捷键键位图（入门到进阶）"><a href="#Vim-命令模式下的一些常用操作-史上最全-Vim-快捷键键位图（入门到进阶）" class="headerlink" title="Vim 命令模式下的一些常用操作: 史上最全 Vim 快捷键键位图（入门到进阶）"></a>Vim 命令模式下的一些常用操作: <a href="https://www.runoob.com/w3cnote/all-vim-cheatsheat.html">史上最全 Vim 快捷键键位图（入门到进阶）</a></h4><p><strong>导航</strong></p><ul><li><code>gg</code>: 定位光标到最开始行。</li><li><code>shift+g</code> 或 <code>G</code>: 定位光标到最结尾行。</li><li><code>n+shift+g</code> 或 <code>nG</code>: 定位光标到任意行——跳到指定行号 <code>n</code>。</li><li><code>shift+$</code>: 定位光标到当前行的结尾。</li><li><code>shift+^</code>: 定位光标到当前行的开始。</li><li><code>w, b</code>: 光标按照单词进行行内移动，分别向右或向左移动一个单词。</li><li><code>h, j, k, l</code>: 分别移动光标左、下、上、右。</li></ul><p><strong>文本编辑</strong></p><ul><li><code>(n)yy</code>: 复制光标所在行或指定行数的内容。</li><li><code>(n)dd</code>: 剪切（删除）当前行或指定行数的内容。</li><li><code>(n)p</code>: 粘贴 <code>n</code> （次数）行到光标所在下一行。</li><li><code>u</code>: 撤销上一步操作。</li><li><code>ctrl+r</code>: 撤销之前的撤销（重做撤销的操作）。</li></ul><p><strong>其他操作</strong></p><ul><li><code>shift+~</code>: 大小写转换。</li><li><code>(n)r</code>: 对光标字符之后的 <code>n</code> 个字符进行批量化替换。</li><li><code>shift+R</code>: 进入替换模式，对内容进行整体替换 → 第四种模式。</li><li><code>(n)x</code>: 对光标后面的 <code>n</code> 个字符进行删除。</li><li><code>:w</code> 保存，<code>:w!</code> 强制保存，<code>:q</code> 退出，<code>:q!</code> 强制退出，<code>:wq!</code> 强制退出并保存</li></ul><p>这两个命令 (<code>shift+$</code> 和 <code>shift+^</code>) 被称为“<strong>锚点</strong>”，因为它们将光标快速固定到行的特定位置——就像锚点固定物体的位置一样。在文本编辑器中，<strong>锚点</strong> 通常指的是可以用来快速定位或固定某个位置的标记。</p><p>为什么 <code>vim</code> 快捷键不像现在键盘的常规操作：主要是因为早期的键盘并不像现在这样有功能键（F1-F12）、方向键或数字小键盘。Vim 的许多快捷键都是为了适应这些限制而设计的。（可以查找一下那个时代的键盘 🤪）</p><h4 id="Vim-多文件编辑与窗口管理"><a href="#Vim-多文件编辑与窗口管理" class="headerlink" title="Vim 多文件编辑与窗口管理"></a>Vim 多文件编辑与窗口管理</h4><p>在 Vim 中，你可以同时打开多个文件，并使用 <strong>分割窗口</strong> 来进行并行编辑。</p><p><strong>打开多个文件 —— 垂直分割窗口 (<code>vs</code>)：</strong></p><ul><li>作用：在当前窗口 <strong>右侧</strong> 打开一个新的窗口，并加载指定的文件。</li><li>用法：<code>:vs file2.c</code>。示例：先打开 <code>file1.c</code>，然后在 Vim 中输入 <code>:vs file2.c</code>，即可在右侧创建一个窗口并打开 <code>file2.c</code>。</li></ul><p><strong>窗口切换 <code>Ctrl+w w</code>：</strong></p><ul><li>作用：在多个窗口之间切换光标位置。</li><li>操作方式：按 <code>Ctrl+w</code>，再按 <code>w</code>，光标会跳到下一个窗口。如果有多个窗口，重复 <code>Ctrl+w w</code> 可以在所有窗口之间循环切换。</li></ul><p><strong>窗口内编辑</strong>：<strong>光标在哪个窗口里面，就对哪一个窗口进行操作</strong>，你可以在当前窗口进行 <strong>插入、删除、复制等编辑操作</strong>，而不会影响其他窗口。</p><ul><li>水平分割窗口：<code>:sp file2.c</code></li><li>调整窗口大小：<code>Ctrl+w +</code>（增加高度）、<code>Ctrl+w -</code>（减少高度）。</li></ul><hr><h4 id="简单的-vim-配置（Vim-改装）"><a href="#简单的-vim-配置（Vim-改装）" class="headerlink" title="简单的 vim 配置（Vim 改装）"></a>简单的 <code>vim</code> 配置（<a href="https://blog.csdn.net/wooin/article/details/1858917">Vim 改装</a>）</h4><p>Vim 的配置文件有两个主要位置，<strong>注意：一个用户配置一个 <code>vim</code> 文件，不会互相影响，不建议给 <code>root</code> 做配置，推荐用普通用户！</strong></p><ol><li><strong>全局配置文件</strong>：<code>/etc/vimrc</code>，对所有用户都生效。</li><li><strong>用户私有配置文件</strong>：每个用户可以在其主目录下创建 <code>.vimrc</code>，仅对该用户生效。例如，<code>/root/.vimrc</code> 适用于 <code>root</code> 用户。</li></ol><p><strong>如何修改 <code>.vimrc</code></strong></p><ol><li>切换到自己的用户目录（确保在自己的 home 目录下）：<code>cd ~</code></li><li>打开 <code>.vimrc</code> 文件（如果不存在，则创建）：<code>vim .vimrc</code></li></ol><p><strong>常用 Vim 配置</strong></p><p>在 <code>.vimrc</code> 文件中添加以下配置：</p><ul><li><strong>设置语法高亮：<code>syntax on</code>，作用：</strong> 开启 Vim 的语法高亮功能，使代码有不同颜色，提高可读性。</li><li><strong>显示行号：<code>set nu</code>，作用：</strong> 开启行号显示，在左侧显示每行的编号，方便定位代码行。</li><li><strong>设置缩进的空格数：<code>set shiftwidth=4</code>，作用：</strong> 设定每次缩进的空格数为 4。适用于代码自动缩进，提高代码可读性。</li></ul><p><strong>测试配置</strong></p><p>修改 <code>.vimrc</code> 文件后，需要重新打开 Vim 或者在 Vim 内输入以下命令让配置生效：<code>:source ~/.vimrc</code> 然后可以在 Vim 中测试：</p><ul><li>输入 <code>:set nu?</code> 检查行号是否开启。</li><li>输入 <code>:set shiftwidth?</code> 检查缩进空格数。</li></ul><p>这样就完成了简单的 Vim 配置！ 🚀 </p><p><strong>使用插件（进阶）</strong></p><p>Vim 支持插件扩展功能，要配置好看的 <code>vim</code>，原生的配置可能功能不全，可以选择安装插件来完善配置，保证用户是你要配置的用户。Vim 的插件管理工具如 Vim-Plug，一些常用的插件如 NERDTree、coc.nvim 等，以增强 Vim 的功能。</p><p>推荐使用 <a href="https://github.com/junegunn/vim-plug">Vim-Plug</a> 作为插件管理器。</p><ol><li><p><strong>安装 Vim-Plug</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -fLo ~/.vim/autoload/plug.vim --create-dirs \</span><br><span class="line">    https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim</span><br></pre></td></tr></table></figure></li><li><p><strong>配置插件</strong>：在 <code>.vimrc</code> 中添加以下内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">call plug#begin(<span class="string">&#x27;~/.vim/plugged&#x27;</span>)</span><br><span class="line">Plug <span class="string">&#x27;插件名称&#x27;</span>  <span class="string">&quot; 例如：Plug &#x27;preservim/nerdtree&#x27;</span></span><br><span class="line"><span class="string">call plug#end()</span></span><br></pre></td></tr></table></figure></li><li><p><strong>安装插件</strong>：<br>在 Vim 中运行 <code>:PlugInstall</code> 安装配置的插件。</p></li></ol><hr><p><a href="https://gitee.com/HGtz2222/VimForCpp">我的 <code>vim</code> 配置</a>：</p><p><strong>安装方法：</strong> 在 <code>shell</code> 中执行指令(想在哪个用户下让 <code>vim</code> 配置生效，就在哪个用户下执行这个指令。强烈 “不推荐” 直接在 root 下执行)，需要按照提示输入 <code>root </code> 密码。您的 <code>root </code> 密码不会被上传，请放心输入。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -sLf https://gitee.com/HGtz2222/VimForCpp/raw/master/install.sh -o ./install.sh &amp;&amp; bash ./install.sh</span><br></pre></td></tr></table></figure><p><strong>&#x3D;&#x3D;注意：安装完成后一定要手动执行 <code>source ~/.bashrc</code> 或重启终端，这样配置才能生效！&#x3D;&#x3D;</strong> 说明：安装完成后，目录下会有一个名为 <code>install.sh</code> 的配套脚本，处于安全考虑，可以执行 <code>mv install.sh .install.sh</code> 进行隐藏。</p><p>默认缩进配置为 <code>2</code> 个字符，将 <code>tab</code> 键换成 <code>4</code> 个字符的方法：到达家目录下执行 <code>vim .vimrc</code>，大概在 50 行进行修改：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> tabstop=4       <span class="string">&quot; 每个制表符占用 4 个空格</span></span><br><span class="line"><span class="string">set softtabstop=4   &quot;</span> 插入制表符时插入 4 个空格</span><br><span class="line"><span class="built_in">set</span> shiftwidth=4    <span class="string">&quot; 自动缩进和文本块操作时使用 4 个空格</span></span><br></pre></td></tr></table></figure><p><strong>&#x3D;&#x3D;卸载方法&#x3D;&#x3D;：</strong> 在安装了 VimForCpp 的用户下执行:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash ~/.VimForCpp/uninstall.sh</span><br></pre></td></tr></table></figure><hr><h3 id="解放-sudo-权限"><a href="#解放-sudo-权限" class="headerlink" title="解放 sudo 权限"></a>解放 <code>sudo</code> 权限</h3><p>使用 <code>root</code> 账户执行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/sudoers</span><br></pre></td></tr></table></figure><p>按下 <code>i</code> 键进入插入模式，找到大约第 100 行左右的位置（附近会有 <code>root    ALL=(ALL)    ALL</code> 的字眼），在其下方添加以下内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">username    ALL=(ALL)    ALL</span><br></pre></td></tr></table></figure><ul><li><code>username</code>：替换为你要授权的账户名。</li><li><code>ALL=(ALL)</code>：允许用户以任何用户身份执行命令。</li><li><code>ALL</code>：允许执行所有命令。</li></ul><p>按 <code>Esc</code> 键返回到默认模式，然后输入 <code>:wq!</code> 强制保存并退出。</p><p><strong>验证</strong>：切换到该用户并测试 <code>sudo</code> 权限：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">su - username</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">ls</span> /root</span><br></pre></td></tr></table></figure><p>如果 <code>sudo</code> 配置正确，系统会提示输入密码，然后执行命令。</p><hr><h3 id="Linux-编译器-——-gcc-g"><a href="#Linux-编译器-——-gcc-g" class="headerlink" title="Linux 编译器 —— gcc &#x2F; g++"></a>Linux 编译器 —— <code>gcc </code>&#x2F; <code>g++</code></h3><h4 id="背景知识回顾-——-C-C-程序的编译流程"><a href="#背景知识回顾-——-C-C-程序的编译流程" class="headerlink" title="背景知识回顾 —— C&#x2F;C++ 程序的编译流程"></a>背景知识回顾 —— C&#x2F;C++ 程序的编译流程</h4><p>C&#x2F;C++ 程序从源代码到可执行文件需经历四个主要阶段：<strong>预处理 → 编译 → 汇编 → 链接</strong>。每个阶段由编译器（如 GCC、Clang 或 MSVC）逐步处理，最终生成可执行文件或库文件。</p><h4 id="1-预处理-Preprocessing"><a href="#1-预处理-Preprocessing" class="headerlink" title="1. 预处理 (Preprocessing)"></a>1. 预处理 (Preprocessing)</h4><p>预处理是编译的第一步，主要处理源代码中的宏、注释、头文件等。预处理的输出是一个经过宏替换、去注释、头文件展开的中间代码。</p><p><strong>主要工作：</strong></p><ul><li><strong>去除注释</strong>：删除代码中的注释部分。</li><li><strong>宏替换</strong>：替换代码中的宏定义（如 <code>#define</code>）。</li><li><strong>头文件展开</strong>：将 <code>#include</code> 指令包含的头文件内容插入到当前文件。</li><li><strong>条件编译</strong>：根据条件编译指令（如 <code>#ifdef</code>、<code>#endif</code>）选择性地包含或排除代码。</li></ul><p><strong>输出：</strong></p><ul><li>预处理后的文件通常是一个 <code>.i</code> 文件，它是源代码经过宏替换和头文件展开后的中间结果。</li></ul><p><strong>命令示例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -E temp.c -o temp.i<span class="comment"># 执行预处理后就停止，`-E` 选项表示只进行预处理，输出 `.i` 文件。</span></span><br></pre></td></tr></table></figure><p><strong>重要说明：</strong> 预处理后的文件仍然是 C 语言代码，因此可以说经过预处理后，程序依然是 C 语言程序。</p><h4 id="2-编译-Compilation"><a href="#2-编译-Compilation" class="headerlink" title="2. 编译 (Compilation)"></a>2. 编译 (Compilation)</h4><p>编译阶段的作用是将预处理后的代码转化为汇编代码。编译器会对代码进行语法分析、语义分析和优化，最终生成与平台架构相关的汇编代码。</p><p><strong>主要工作：</strong></p><ul><li><strong>语法分析</strong>：检查代码是否符合语法规则。</li><li><strong>语义分析</strong>：检查变量类型、函数调用等语义是否正确。</li><li><strong>优化</strong>：对代码进行优化，使得生成的汇编代码更高效。</li></ul><p><strong>输出：</strong></p><ul><li>编译后的文件是一个 <code>.s</code> 文件，包含了平台特定的汇编代码。</li></ul><p><strong>命令示例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -S temp.i -o temp.s<span class="comment"># 执行编译后就停止，`-S` 选项表示将预处理后的文件编译成汇编语言。</span></span><br></pre></td></tr></table></figure><h4 id="3-汇编-Assembly"><a href="#3-汇编-Assembly" class="headerlink" title="3. 汇编 (Assembly)"></a>3. 汇编 (Assembly)</h4><p>汇编阶段的作用是将汇编代码转换为机器可识别的二进制目标代码。汇编器会将汇编代码翻译为机器指令，生成可重定位目标文件。</p><p><strong>主要工作：</strong></p><ul><li><strong>汇编</strong>：将汇编代码转换为目标代码，生成二进制文件。</li></ul><p><strong>输出：</strong></p><ul><li>汇编后的文件是一个 <code>.o</code>（Linux）或 <code>.obj</code>（Windows）文件，这些文件是目标文件，包含机器指令，但尚未链接成最终的可执行文件。</li></ul><p><strong>命令示例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c temp.s -o temp.o<span class="comment"># 执行汇编后停止，`-c` 选项表示只进行汇编，不进行链接，输出 `.o` 文件。</span></span><br></pre></td></tr></table></figure><p><strong>重要说明：</strong> 可重定位目标二进制文件，简称目标文件，<code>.obj</code> 文件不可以独立执行，虽然已经是二进制了，还需要经过链接才能执行！</p><blockquote><h2 id="传道解惑"><a href="#传道解惑" class="headerlink" title="传道解惑"></a>传道解惑</h2><p>在 Linux 中，可重定位目标二进制文件（Relocatable Object File）是一种 <strong>中间二进制文件</strong>，它是由编译器或汇编器生成的，但还 <strong>不能直接执行</strong>，必须经过 <strong>链接（Linking）</strong> 处理后才能成为最终的可执行文件或库文件。</p><h3 id="Q1：什么是可重定位目标文件？"><a href="#Q1：什么是可重定位目标文件？" class="headerlink" title="Q1：什么是可重定位目标文件？"></a>Q1：什么是可重定位目标文件？</h3><p>可重定位目标文件通常以 <strong><code>.o</code></strong> 结尾（Windows 上是 <code>.obj</code>），它包含：</p><ul><li><strong>机器指令（Machine Instructions）</strong>：程序的可执行代码，但未指定最终内存地址。</li><li><strong>符号表（Symbol Table）</strong>：记录函数、变量等符号，供链接器解析。</li><li><strong>重定位信息（Relocation Information）</strong>：用于在链接时调整地址。</li><li><strong>节（Section）结构</strong>：比如 <code>.text</code>（代码段）、<code>.data</code>（已初始化数据段）、<code>.bss</code>（未初始化数据段）等。</li></ul><p>这些文件是 <strong>“可重定位”</strong> 的，因为它们的地址信息 <strong>尚未固定</strong>，而是由 <strong>链接器</strong> 在合并多个目标文件时决定最终的内存布局。</p><h3 id="Q2：为什么需要可重定位目标文件？"><a href="#Q2：为什么需要可重定位目标文件？" class="headerlink" title="Q2：为什么需要可重定位目标文件？"></a>Q2：为什么需要可重定位目标文件？</h3><p>如果编译器直接把 C&#x2F;C++ 源代码编译成最终可执行程序，那么：</p><ul><li><strong>无法将不同的模块（文件）合并</strong>，无法进行大规模项目开发。</li><li><strong>无法使用动态链接库（Shared Library）</strong>，会导致程序体积庞大。</li><li><strong>无法延迟地址分配</strong>，不适用于操作系统的内存管理策略。</li></ul><p>所以，编译器通常 <strong>先</strong> 生成 <strong>可重定位目标文件</strong>，再由 <strong>链接器</strong> 进行 <strong>地址调整和符号解析</strong>，最终得到可执行程序。</p><p><strong>示例：生成可重定位目标文件</strong></p><p>假设我们有一个简单的 C 代码 <code>temp.c</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">&gt;<span class="type">void</span> <span class="title function_">hello</span><span class="params">()</span></span><br><span class="line">&gt;&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Hello, World!\n&quot;</span>);</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p><strong>第一步：编译但不链接</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;gcc -c temp.c -o temp.o</span><br></pre></td></tr></table></figure><p>这样会生成 <code>temp.o</code>，它是一个 <strong>可重定位目标文件</strong>，里面的 <code>hello</code> 还没有绑定到最终的地址。</p><p><strong>第二步：使用 <code>readelf</code> 查看目标文件</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;readelf -h temp.o</span><br></pre></td></tr></table></figure><p>部分输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;Type:           REL (Relocatable file)</span><br><span class="line">&gt;Machine:        x86-64</span><br></pre></td></tr></table></figure><p>可以看到 <code>Type</code> 是 <code>REL</code>，表示它是一个 <strong>可重定位文件</strong>。</p><h3 id="Q3：什么时候会被最终链接？"><a href="#Q3：什么时候会被最终链接？" class="headerlink" title="Q3：什么时候会被最终链接？"></a>Q3：什么时候会被最终链接？</h3><p>可重定位目标文件 <strong>通常不会单独使用</strong>，它最终会：</p><ol><li><strong>静态链接（Static Linking）</strong>：被 <code>ld</code>（链接器）合并到最终的可执行文件中。</li><li><strong>动态链接（Dynamic Linking）</strong>：与共享库（<code>.so</code> 文件）进行链接，在运行时加载。</li></ol><p>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;gcc temp.o -o temp</span><br><span class="line">&gt;./temp</span><br></pre></td></tr></table></figure><p>这时 <code>temp.o</code> 经过链接后变成可执行文件 <code>temp</code>，可以直接运行。</p></blockquote><h4 id="4-链接-Linking"><a href="#4-链接-Linking" class="headerlink" title="4. 链接 (Linking)"></a>4. 链接 (Linking)</h4><p>链接阶段的作用是将多个目标文件（如 <code>.o</code> 文件）和库文件进行链接，生成最终的可执行文件或库文件。链接器会处理符号引用、重定位等工作，确保程序能够正确运行。</p><p><strong>主要工作：</strong></p><ul><li><strong>符号解析</strong>：将不同目标文件中的符号（如函数名、变量名等）进行链接，确保各部分之间的正确引用。</li><li><strong>重定位</strong>：调整代码中地址的引用，使得目标文件能够在内存中正确加载。</li></ul><p><strong>输出：</strong></p><ul><li>链接后的输出通常是一个可执行文件（如 <code>a.out</code> 或 <code>program.exe</code>）或动态链接库（如 <code>.so</code> 或 <code>.dll</code> 文件）。</li></ul><p><strong>命令示例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc source.o -o program<span class="comment"># 默认链接 C 标准库，这条命令将目标文件 `temp.o` 链接为可执行文件 `program`。</span></span><br></pre></td></tr></table></figure><hr><h4 id="为什么我们能在-Windows-或-Linux-上进行-C-C-开发？"><a href="#为什么我们能在-Windows-或-Linux-上进行-C-C-开发？" class="headerlink" title="为什么我们能在 Windows 或 Linux 上进行 C&#x2F;C++ 开发？"></a>为什么我们能在 Windows 或 Linux 上进行 C&#x2F;C++ 开发？</h4><p>在 Windows 和 Linux 上进行 C&#x2F;C++ 开发是因为这些操作系统提供了支持编译和执行 C&#x2F;C++ 代码的工具链。具体而言，需要安装开发环境（如 GCC、Visual Studio 等）以及相关的库文件和头文件。</p><p><strong>1. 头文件和库文件</strong></p><ul><li><strong>头文件</strong>：定义了语言的核心功能、标准库以及外部库的接口（如 <code>stdio.h</code>、<code>stdlib.h</code>）。</li><li><strong>库文件</strong>：包含预编译的二进制代码（如 <code>libc.a</code> 或 <code>msvcrt.dll</code>），在链接阶段与用户代码结合。</li></ul><p><strong>2. 开发工具</strong></p><ul><li><strong>编译器</strong>：如 GCC（GNU Compiler Collection）、g++，以及 Visual Studio（VS）等 IDE，提供了代码编辑、编译、调试等功能。</li><li><strong>语言支持包</strong>：<strong>安装开发工具时，会自动下载头文件和库。</strong> 例如，安装 VS 时选择“C++ 开发”，会附带 C++ 标准库（如 STL）和 Windows API 库。</li></ul><p><strong>3. 跨平台开发</strong></p><ul><li><strong>条件编译</strong>：通过宏（如 <code>#ifdef __linux__</code>）区分不同平台的代码逻辑。</li><li><strong>平台专属库</strong>：Linux 依赖 <code>glibc</code>，Windows 依赖 <code>msvcrt.dll</code>。开发者需调用标准接口或使用跨平台库（如 Qt、Boost）。</li></ul><h4 id="软件版本管理：社区版-vs-专业版"><a href="#软件版本管理：社区版-vs-专业版" class="headerlink" title="软件版本管理：社区版 vs 专业版"></a>软件版本管理：社区版 vs 专业版</h4><p><strong>1. 代码维护策略</strong></p><ul><li><p><strong>单一代码库</strong>：企业无需维护多份代码，而是通过 <strong>条件编译</strong> 控制功能模块的启用或禁用。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PROFESSIONAL_EDITION</span></span><br><span class="line">  enableAdvancedFeatures();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></li><li><p><strong>编译参数控制</strong>：构建时通过宏定义（如 <code>-DPROFESSIONAL_EDITION</code>）选择版本。</p></li></ul><p><strong>2. 功能裁剪 —— 不需要维护两份代码，根据不同的编译条件，会裁剪掉社区版不需要的功能即可</strong></p><ul><li><strong>社区版</strong>：禁用部分高级功能（如性能分析工具、企业级加密）。</li><li><strong>专业版</strong>：包含完整功能，通过编译选项开启。</li></ul><hr><h4 id="关键命令与文件类型总结"><a href="#关键命令与文件类型总结" class="headerlink" title="关键命令与文件类型总结"></a>关键命令与文件类型总结</h4><table><thead><tr><th align="center">阶段</th><th align="center">命令选项</th><th align="center">输入文件</th><th align="center">输出文件</th><th align="center">文件内容</th></tr></thead><tbody><tr><td align="center">预处理</td><td align="center"><code>-E</code></td><td align="center"><code>.c</code></td><td align="center"><code>.i</code></td><td align="center">展开后的 C 代码</td></tr><tr><td align="center">编译</td><td align="center"><code>-S</code></td><td align="center"><code>.i</code></td><td align="center"><code>.s</code></td><td align="center">汇编代码</td></tr><tr><td align="center">汇编</td><td align="center"><code>-c</code></td><td align="center"><code>.s</code></td><td align="center"><code>.o</code>（Linux）</td><td align="center">目标二进制文件</td></tr><tr><td align="center">链接</td><td align="center">无</td><td align="center"><code>.o</code></td><td align="center"><code>a.out</code>（默认）</td><td align="center">可执行文件</td></tr></tbody></table><h4 id="记忆法"><a href="#记忆法" class="headerlink" title="记忆法"></a>记忆法</h4><ul><li><p><strong>ESC 键记忆法</strong>：键盘左上角的 ESC 键可以关联各个阶段的后缀：</p><ul><li><strong>.i</strong> -&gt; <strong>预处理</strong>（Preprocessing）</li><li><strong>.s</strong> -&gt; <strong>汇编</strong>（Assembly）</li><li><strong>.o</strong> -&gt; <strong>目标文件</strong>（Object file）</li></ul></li><li><p><strong>iso → 镜像文件后缀。</strong> 最终的可执行文件或库文件就是链接的结果。</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">编译流程：</span><br><span class="line">.c 源文件 → 预处理 → 编译 → 汇编 → 链接 → 可执行文件</span><br><span class="line">          (-E)     (-S)   (-c)    </span><br><span class="line">        </span><br><span class="line">多文件编译例如：</span><br><span class="line">processBar.c → processBar.o ─┐</span><br><span class="line">                             ├→ processBar</span><br><span class="line">processBarmain.c → processBarmain.o ─┘</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="函数库的概念与作用"><a href="#函数库的概念与作用" class="headerlink" title="函数库的概念与作用"></a>函数库的概念与作用</h3><p>在 C&#x2F;C++语言编程中，函数库（Library）允许开发者复用已有的代码，而不必每次都从头开始编写。函数库通常包含一组预先编写好的函数，这些函数可以被多个程序调用。通过使用函数库，开发者可以节省时间，减少重复劳动，并提高代码的可靠性和可维护性。</p><h4 id="函数库的分类"><a href="#函数库的分类" class="headerlink" title="函数库的分类"></a>函数库的分类</h4><p>函数库主要分为两种类型：<strong>静态库</strong> 和 <strong>动态库</strong>。</p><p><strong>1. 静态库（Static Library）</strong></p><ul><li><strong>定义</strong>：静态库在编译链接时，会将库文件的代码全部加入到可执行文件中。因此，生成的可执行文件会比较大，但在运行时不再需要库文件。</li><li><strong>后缀名</strong>：静态库的后缀名通常为 <code>.a</code>（例如 <code>libmylib.a</code>）。</li><li><strong>优点</strong>：由于库代码被直接嵌入到可执行文件中，程序运行时不需要依赖外部的库文件，因此具有较好的独立性。</li><li><strong>缺点</strong>：生成的可执行文件较大，且如果多个程序使用相同的静态库，每个程序都会包含一份库代码的副本，导致内存浪费。</li></ul><p><strong>2. 动态库（Dynamic Library）</strong></p><ul><li><strong>定义</strong>：动态库在编译链接时并不会将库文件的代码加入到可执行文件中，而是在程序运行时由操作系统的运行时链接器动态加载。这样可以节省系统的开销。</li><li><strong>后缀名</strong>：动态库的后缀名通常为 <code>.so</code>（例如 <code>libmylib.so</code>）。</li><li><strong>优点</strong>：生成的可执行文件较小，多个程序可以共享同一个动态库，节省内存和磁盘空间。此外，动态库可以在不重新编译程序的情况下更新。</li><li><strong>缺点</strong>：程序运行时需要依赖外部的库文件，如果库文件丢失或版本不兼容，程序可能无法运行。</li></ul><h4 id="函数库的命名规则"><a href="#函数库的命名规则" class="headerlink" title="函数库的命名规则"></a>函数库的命名规则</h4><p>函数库的命名通常遵循一定的规则，以便于识别和使用。常见的命名格式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">libname.so.XXX</span><br></pre></td></tr></table></figure><ul><li><code>lib</code> 是前缀，表示这是一个库文件。</li><li><code>name</code> 是库的名称，例如 <code>c</code> 表示 C 标准库。</li><li><code>.so</code> 表示这是一个动态库（静态库通常使用 <code>.a</code>）。</li><li><code>XXX</code> 是版本号，表示库的版本。</li></ul><p>例如，<code>libc.so.6</code> 是 C 标准库的动态库，版本号为 6。</p><h4 id="函数库的使用"><a href="#函数库的使用" class="headerlink" title="函数库的使用"></a>函数库的使用</h4><p>在 C 语言中，常用的函数库如 <code>printf</code> 函数的实现并没有直接包含在源代码中，也没有在头文件 <code>stdio.h</code> 中定义。那么，这些函数是如何被调用的呢？</p><p><strong>1. 头文件的作用</strong>：头文件（如 <code>stdio.h</code>）中只包含了函数的声明（即函数原型），告诉编译器这些函数的存在及其参数和返回值的类型。头文件并不包含函数的实现。</p><p><strong>2. 库文件的作用</strong>：函数的实现通常位于库文件中。例如，<code>printf</code> 函数的实现位于 C 标准库的动态库 <code>libc.so.6</code> 中。编译器在链接阶段会将这些库文件与代码结合起来，生成最终的可执行文件。</p><p><strong>3. 链接过程</strong></p><ul><li><strong>静态链接</strong>：在编译时，静态库的代码会被直接嵌入到可执行文件中。生成的可执行文件不依赖外部的库文件。</li><li><strong>动态链接</strong>：在编译时，动态库的代码不会被嵌入到可执行文件中。程序运行时，动态链接器会根据预定义的路径规则去查找这些库文件。</li></ul><h4 id="函数库的作用-——-不让我们做重复工作，站在巨人的肩膀上享受"><a href="#函数库的作用-——-不让我们做重复工作，站在巨人的肩膀上享受" class="headerlink" title="函数库的作用 —— 不让我们做重复工作，站在巨人的肩膀上享受"></a>函数库的作用 —— 不让我们做重复工作，站在巨人的肩膀上享受</h4><ul><li>代码复用：避免重复造轮子，开发者可以直接使用封装好的函数，而不用自己实现复杂的功能。</li><li>隐藏源码：共享库只提供 <code>.so</code> 文件，而不公开 <code>.c</code> 源文件，保护代码的知识产权。</li><li>提高程序效率：通过动态链接的方式，多个程序可以 <strong>共享同一份库文件</strong>，减少内存占用，提高运行效率。</li></ul><hr><h3 id="Linux-中的可执行文件链接方式：动态、静态与混合链接"><a href="#Linux-中的可执行文件链接方式：动态、静态与混合链接" class="headerlink" title="Linux 中的可执行文件链接方式：动态、静态与混合链接"></a>Linux 中的可执行文件链接方式：动态、静态与混合链接</h3><p>在 Linux 中，<code>gcc</code> 编译形成可执行程序时，<strong>默认采用动态链接</strong>，即程序运行时依赖 <code>.so</code>（共享库），这样可以减少可执行文件的大小，并允许多个程序共享相同的库文件。然而，我们可以通过 <strong>静态链接</strong> 或 <strong>混合链接</strong> 的方式来改变默认的链接行为。</p><blockquote><h3 id="小故事理解动静态链接"><a href="#小故事理解动静态链接" class="headerlink" title="小故事理解动静态链接"></a>小故事理解动静态链接</h3><p>想象一下，你正在设计一款可以快速适应不同地形的汽车。为了实现这一目标，你决定使用一些通用的动态链接库，比如“越野轮子”、“城市轮胎”和“雪地链”。这些组件可以在不同的车型之间共享，并且可以根据需要在车辆启动时或行驶过程中即时替换。如果一个顾客今天想要一辆适合城市驾驶的汽车，你可以安装“城市轮胎”；如果明天他想去越野冒险，只需更换为“越野轮子”。这种灵活性就像动态链接（库），程序运行时按需加载，多个程序共享，节省内存，灵活高效。</p><p>另一方面，有些汽车组件一旦安装就不能轻易更改了，例如车身结构或者发动机。这些是根据特定需求量身定做的。当你选择了一种类型的发动机后，它就永久性地成为汽车的一部分，无法在不拆卸整个汽车的情况下进行更换。静态链接库就像发动机，在编译时整合进程序，成为其固定组成部分，提供稳定功能，但程序体积较大，独立运行。</p></blockquote><h4 id="1-默认情况下，gcc-采用动态链接"><a href="#1-默认情况下，gcc-采用动态链接" class="headerlink" title="1. 默认情况下，gcc 采用动态链接"></a>1. 默认情况下，gcc 采用动态链接</h4><p>当我们编译 C 语言程序：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc hello.c -o hello</span><br></pre></td></tr></table></figure><p>默认情况下，<code>gcc</code> <strong>优先链接动态库</strong>（<code>.so</code>），并在执行时加载库文件。例如，标准 C 库 <code>libc.so.6</code> 是动态链接的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ldd hello</span><br></pre></td></tr></table></figure><p>示例输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">linux-vdso.so.1 =&gt;  (0x00007fffca9fe000)</span><br><span class="line">libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f2a4c3c9000)</span><br><span class="line">/lib64/ld-linux-x86-64.so.2 (0x00007f2a4c788000)</span><br></pre></td></tr></table></figure><p>这表示 <code>hello</code> 依赖 <code>libc.so.6</code>，而不是 <code>libc.a</code>（静态库）。</p><h4 id="2-强制使用静态链接（-static-选项）"><a href="#2-强制使用静态链接（-static-选项）" class="headerlink" title="2. 强制使用静态链接（-static 选项）"></a>2. 强制使用静态链接（<code>-static</code> 选项）</h4><p>如果想让程序采用 <strong>纯静态链接</strong>，可以使用 <code>-static</code> 选项：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc hello.c -o hello -static</span><br></pre></td></tr></table></figure><p>这时，编译器会 <strong>优先查找并链接静态库（<code>.a</code>）</strong>，把所有库代码嵌入可执行文件中，使其不再依赖外部 <code>.so</code> 文件。检查：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ldd hello</span><br></pre></td></tr></table></figure><p>如果是纯静态链接，输出会是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">not a dynamic executable</span><br></pre></td></tr></table></figure><p>这表明 <code>hello</code> <strong>不依赖任何动态库</strong>。</p><h4 id="3-static-的本质：改变库的优先级"><a href="#3-static-的本质：改变库的优先级" class="headerlink" title="3. -static 的本质：改变库的优先级"></a>3. <code>-static</code> 的本质：改变库的优先级</h4><p>使用 <code>-static</code> 选项时，<strong>必须保证所有依赖库的静态版本（<code>.a</code>）都存在</strong>，否则，编译会失败。如果没有静态库，但强制使用 <code>-static</code> 会报错！<strong>如果系统只有静态库，没有动态库</strong>，即使没有 <code>-static</code>，<code>gcc</code> 仍然会成功编译，并采用静态链接。因为它找不到 <code>.so</code> 文件，只能用 <code>.a</code>。</p><ul><li><strong>默认情况下</strong>，<code>gcc</code> <strong>优先选择动态库（<code>.so</code>）</strong>。</li><li><strong>加上 <code>-static</code></strong>，<code>gcc</code> <strong>强制使用静态库（<code>.a</code>）</strong>，如果找不到静态库，则会报错。</li><li>并且 <code>-static</code> 是“一次性”的，即：<ul><li><strong>所有</strong> 需要的库都必须静态链接。</li><li><strong>不能部分使用动态库，部分使用静态库</strong>。</li></ul></li></ul><p>如果 <code>-static</code> 选项下某个库没有 <code>.a</code> 文件，编译就会失败。</p><h4 id="4-混合链接（部分静态，部分动态）"><a href="#4-混合链接（部分静态，部分动态）" class="headerlink" title="4. 混合链接（部分静态，部分动态）"></a>4. 混合链接（部分静态，部分动态）</h4><p>虽然 <code>-static</code> 会让所有库都静态链接，但我们可以通过手动指定库的链接方式，实现 <strong>混合链接</strong>（部分库静态，部分库动态）。</p><p><strong>让特定库使用静态链接</strong>：使用 <code>-Wl,-Bstatic</code> 指定部分库静态链接：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc hello.c -o hello -Wl,-Bstatic -lcustomlib -Wl,-Bdynamic -lc</span><br></pre></td></tr></table></figure><ul><li><code>-Wl,-Bstatic</code> 让 <code>-lcustomlib</code> 采用静态库 <code>libcustomlib.a</code>。</li><li><code>-Wl,-Bdynamic</code> 让 <code>-lc</code> 采用动态库 <code>libc.so</code>（恢复默认动态链接）。</li><li>这样就实现了 <strong>混合链接</strong>（部分库静态，部分库动态）。</li></ul><h4 id="5-static-的优缺点"><a href="#5-static-的优缺点" class="headerlink" title="5. -static 的优缺点"></a>5. <code>-static</code> 的优缺点</h4><table><thead><tr><th>方式</th><th><strong>优点</strong></th><th><strong>缺点</strong></th></tr></thead><tbody><tr><td><strong>动态链接（默认）</strong></td><td>- 可执行文件小，多个程序共享库，节省磁盘、内存、网络等空间  - 库可以独立更新，不需重新编译程序</td><td>- 依赖外部 <code>.so</code> 文件，库缺失时程序无法运行</td></tr><tr><td><strong>静态链接（-static）</strong></td><td>- 程序可以独立运行，无需依赖库文件  - 适用于嵌入式系统或无共享库的环境</td><td>- 可执行文件大（<strong>是动态的几十上百倍！</strong>），占用更多磁盘、内存、网络空间  - 无法通过库更新修复漏洞，需要重新编译</td></tr></tbody></table><h4 id="6-推荐场景"><a href="#6-推荐场景" class="headerlink" title="6. 推荐场景"></a>6. 推荐场景</h4><table><thead><tr><th><strong>场景</strong></th><th><strong>建议链接方式</strong></th></tr></thead><tbody><tr><td>普通 Linux 应用</td><td><strong>默认动态链接</strong>（节省空间，便于更新）</td></tr><tr><td>需要独立运行的程序</td><td><strong>静态链接（<code>-static</code>）</strong>，避免外部依赖</td></tr><tr><td>服务器软件</td><td><strong>混合链接</strong>，关键库静态，其余动态</td></tr><tr><td>嵌入式系统</td><td><strong>静态链接</strong>，减少依赖</td></tr></tbody></table><hr><h3 id="Debug-与-Release-模式-ELF-可执行文件格式"><a href="#Debug-与-Release-模式-ELF-可执行文件格式" class="headerlink" title="Debug 与 Release 模式 &amp; ELF 可执行文件格式"></a>Debug 与 Release 模式 &amp; ELF 可执行文件格式</h3><h4 id="1-Debug-模式（调试模式）"><a href="#1-Debug-模式（调试模式）" class="headerlink" title="1. Debug 模式（调试模式）"></a>1. Debug 模式（调试模式）</h4><ul><li><strong>包含调试信息</strong>（如变量名、函数符号表）。</li><li><strong>没有优化</strong>，代码尽量保持源代码的执行逻辑，方便调试。</li><li><strong>可追踪调试</strong>，可以用 <code>gdb</code>（GNU Debugger）进行断点、变量查看等操作。</li></ul><p><strong>编译方式：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -g hello.c -o hello_debug</span><br></pre></td></tr></table></figure><ul><li><code>-g</code> 选项：生成调试信息，方便 <code>gdb</code> 进行调试。</li><li><code>hello_debug</code>：可执行文件，但体积较大，因为包含了额外的调试信息。</li></ul><p><strong>调试方式：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb ./hello_debug<span class="comment"># 可以设置断点、查看变量值等。</span></span><br></pre></td></tr></table></figure><h4 id="2-Release-模式（发布模式）"><a href="#2-Release-模式（发布模式）" class="headerlink" title="2. Release 模式（发布模式）"></a>2. Release 模式（发布模式）</h4><ul><li><strong>优化代码，提高执行效率</strong>。</li><li><strong>去除调试信息，减小可执行文件大小</strong>。</li><li><strong>适用于正式发布的程序</strong>，但不方便调试。</li></ul><p><strong>编译方式：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -O2 hello.c -o hello_release</span><br></pre></td></tr></table></figure><ul><li><code>-O2</code>（优化等级 2）：让编译器优化代码，提高执行速度（<code>-O3</code> 可进一步优化）。</li><li><strong>没有 <code>-g</code>，不生成调试信息</strong>。</li></ul><h4 id="3-ELF（Executable-and-Linkable-Format，可执行文件格式）"><a href="#3-ELF（Executable-and-Linkable-Format，可执行文件格式）" class="headerlink" title="3. ELF（Executable and Linkable Format，可执行文件格式）"></a>3. ELF（Executable and Linkable Format，可执行文件格式）</h4><p><strong>在 Linux 下，可执行程序形成的时候，不是无顺的二进制构成，可执行程序有自己的二进制格式 —— ELF 格式。</strong></p><ul><li><strong>程序头部</strong>（Program Header）：描述如何加载程序。</li><li><strong>代码段</strong>（.text）：存放程序的可执行代码。</li><li><strong>数据段</strong>（.data、.bss）：存放全局变量、静态变量等。</li><li><strong>符号表</strong>（仅 Debug 模式下存在）：包含函数、变量等信息，方便调试器使用。</li></ul><p><strong>查看 ELF 结构：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">readelf -h hello_debug   <span class="comment"># 查看 ELF 头部信息</span></span><br><span class="line">objdump -d hello_debug   <span class="comment"># 反汇编可执行文件</span></span><br></pre></td></tr></table></figure><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>GCC&#x2F;G++ 在 Linux 下的常用编译选项</strong></p><table><thead><tr><th><strong>选项</strong></th><th><strong>作用</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td><code>-o &lt;文件名&gt;</code></td><td>指定输出的可执行文件名（<code>gcc -o 输出文件 源文件</code> 和 <code>gcc 源文件 -o 输出文件</code> 均可，更推荐后者！）</td><td><code>gcc hello.c -o hello</code></td></tr><tr><td><code>-c</code></td><td>仅编译，不进行链接，生成 <code>.o</code> 目标文件</td><td><code>gcc -c hello.c -o hello.o</code></td></tr><tr><td><code>-g</code></td><td>生成调试信息，便于 <code>gdb</code> 调试</td><td><code>gcc -g hello.c -o hello_debug</code></td></tr><tr><td><code>-O0</code></td><td><strong>不优化</strong>，适用于 Debug</td><td><code>gcc -O0 hello.c -o hello</code></td></tr><tr><td><code>-O1</code></td><td><strong>基本优化</strong>，适用于一般调试</td><td><code>gcc -O1 hello.c -o hello</code></td></tr><tr><td><code>-O2</code></td><td><strong>标准优化</strong>，提高性能，适用于 Release</td><td><code>gcc -O2 hello.c -o hello</code></td></tr><tr><td><code>-O3</code></td><td><strong>高级优化</strong>，可能影响可读性和调试</td><td><code>gcc -O3 hello.c -o hello</code></td></tr><tr><td><code>-Wall</code></td><td>启用所有常见警告</td><td><code>gcc -Wall hello.c -o hello</code></td></tr><tr><td><code>-Wextra</code></td><td>启用额外的警告信息</td><td><code>gcc -Wall -Wextra hello.c -o hello</code></td></tr><tr><td><code>-Werror</code></td><td>把所有警告当作错误</td><td><code>gcc -Werror hello.c -o hello</code></td></tr><tr><td><code>-static</code></td><td>进行 <strong>静态链接</strong>，不依赖 <code>.so</code> 库</td><td><code>gcc -static hello.c -o hello</code></td></tr><tr><td><code>-shared</code></td><td>生成 <strong>共享库（动态库）</strong> <code>.so</code> 文件</td><td><code>gcc -shared -fPIC hello.c -o libhello.so</code></td></tr><tr><td><code>-fPIC</code></td><td>生成位置无关代码（用于动态库）</td><td><code>gcc -fPIC -c hello.c -o hello.o</code></td></tr><tr><td><code>-L&lt;路径&gt;</code></td><td>指定库文件搜索路径</td><td><code>gcc hello.c -L/usr/local/lib -lhello -o hello</code></td></tr><tr><td><code>-I&lt;路径&gt;</code></td><td>指定头文件搜索路径</td><td><code>gcc hello.c -I/usr/local/include -o hello</code></td></tr><tr><td><code>-l&lt;库名&gt;</code></td><td>链接指定的库（默认搜索 <code>/lib</code> 和 <code>/usr/lib</code>）</td><td><code>gcc hello.c -lm -o hello</code>（链接 <code>libm.so</code> 数学库）</td></tr><tr><td><code>-pthread</code></td><td>支持多线程编译</td><td><code>gcc hello.c -pthread -o hello</code></td></tr><tr><td><code>-std=&lt;标准&gt;</code></td><td>指定 C 或 C++ 标准</td><td><code>gcc -std=c99 hello.c -o hello</code></td></tr><tr><td><code>-D&lt;宏定义&gt;</code></td><td>定义宏，等效于 <code>#define</code></td><td><code>gcc -DDEBUG hello.c -o hello</code></td></tr><tr><td><code>-E</code></td><td>仅进行 <strong>预处理</strong>，输出 <code>.i</code> 文件</td><td><code>gcc -E hello.c -o hello.i</code></td></tr><tr><td><code>-S</code></td><td>仅进行 <strong>编译</strong>，输出汇编代码 <code>.s</code> 文件</td><td><code>gcc -S hello.c -o hello.s</code></td></tr><tr><td><code>-v</code></td><td>显示详细的编译过程</td><td><code>gcc -v hello.c -o hello</code></td></tr><tr><td><code>--version</code></td><td>显示 <code>gcc/g++</code> 版本</td><td><code>gcc --version</code></td></tr></tbody></table><p><strong>G++ 额外的选项</strong></p><table><thead><tr><th><strong>选项</strong></th><th><strong>作用</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td><code>-fno-rtti</code></td><td>禁用运行时类型识别（RTTI）</td><td><code>g++ -fno-rtti hello.cpp -o hello</code></td></tr><tr><td><code>-fno-exceptions</code></td><td>禁用异常处理（<code>try/catch</code>）</td><td><code>g++ -fno-exceptions hello.cpp -o hello</code></td></tr><tr><td><code>-std=c++11</code></td><td>使用 C++11 标准</td><td><code>g++ -std=c++11 hello.cpp -o hello</code></td></tr><tr><td><code>-std=c++17</code></td><td>使用 C++17 标准</td><td><code>g++ -std=c++17 hello.cpp -o hello</code></td></tr><tr><td><code>-std=c++20</code></td><td>使用 C++20 标准</td><td><code>g++ -std=c++20 hello.cpp -o hello</code></td></tr></tbody></table><p><strong><code>gcc</code> 与 <code>g++</code> 的关系</strong></p><ul><li><p><code>g++</code> <strong>可以使用 <code>gcc</code> 的全部选项</strong>，因为 <code>g++</code> 本质上是 <code>gcc</code> 的一个前端，专门用于编译 C++ 代码。</p></li><li><p><code>gcc</code> 既可以编译 C 也可以编译 C++，但默认 <strong>不会自动链接 C++ 标准库</strong>。</p></li><li><p><code>g++</code> 默认 <strong>会自动链接 C++ 标准库</strong>（如 <code>libstdc++</code>），并开启 C++ 语法支持。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>04 类与对象（下）</title>
      <link href="/posts/10381.html"/>
      <url>/posts/10381.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-再谈构造函数"><a href="#1-再谈构造函数" class="headerlink" title="1. 再谈构造函数"></a>1. 再谈构造函数</h2><p>在面向对象编程中，<strong>构造函数</strong> 是一种特殊的成员函数，它在对象创建时自动调用，负责初始化对象的成员变量（创建对象时赋初值），确保对象在创建时有一个有效的状态。接下来，我们将详细讲解关于构造函数的几个重要概念。</p><h3 id="1-1-构造函数体赋值"><a href="#1-1-构造函数体赋值" class="headerlink" title="1.1 构造函数体赋值"></a>1.1 构造函数体赋值</h3><p>当我们创建一个对象时，构造函数会被自动调用，用来给对象的各个成员变量提供一个初始值。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="built_in">MyClass</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        a = <span class="number">10</span>;  <span class="comment">// 这里是构造函数体中的赋值操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这个例子中，构造函数的作用是将 <code>a</code> 赋值为 10。然而，这里要注意，<strong>构造函数体中的赋值操作和初始化是有区别的</strong>。构造函数体中对成员变量的赋值只能算是给成员变量“赋初值”，而不是“初始化”。因为初始化是指给成员变量设置一个初始值，而且初始化只能发生一次，而赋值操作可以发生多次。</p><p>再例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> _x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> x)</span><br><span class="line">    &#123;</span><br><span class="line">        _x = x; <span class="comment">// 赋值操作：_x 在此之前已经默认初始化（如果有的话），然后被赋值为 x。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">上述代码中，`_x = x;`是赋值，而非初始化，因为初始化只能通过构造函数外部的初始化列表来完成。</span><br><span class="line"></span><br><span class="line">在构造函数体中对成员变量的赋值操作，实际上是先通过默认初始化（如果有的话），然后通过赋值操作覆盖初始值。这与初始化列表直接初始化成员变量有本质区别。</span><br></pre></td></tr></table></figure><p>换句话说，<strong>初始化只能在构造函数中通过初始化列表来进行一次，而构造函数体中的赋值可以反复进行</strong>。</p><p>所以，<strong>赋值与初始化的区别</strong> 在于：</p><ul><li><strong>初始化</strong>：是在对象创建时为成员变量设置初始值的过程，每个成员变量只能被初始化一次，通常在构造函数的初始化列表中进行（只能进行一次）。</li><li><strong>赋值</strong>：是在对象创建后对成员变量进行值的修改，可以发生多次，可以在构造函数体中，也可以在对象的生命周期中的任何时候进行（可以重复进行）。</li></ul><hr><h3 id="1-2-初始化列表"><a href="#1-2-初始化列表" class="headerlink" title="1.2 初始化列表"></a>1.2 初始化列表</h3><p>初始化列表是构造函数中的一种写法（直接初始化类的成员变量的一种方式），允许我们在构造函数调用之前就给成员变量提供初始值。语法是在构造函数的括号后加冒号和成员变量列表，其基本格式是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">MyClass</span>() : <span class="built_in">a</span>(<span class="number">10</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 构造函数体</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">这里的:`<span class="built_in">a</span>(<span class="number">10</span>)`就是初始化列表，它会在构造函数体执行之前初始化成员变量`a`为<span class="number">10</span>。</span><br></pre></td></tr></table></figure><p>再或者：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> _x;</span><br><span class="line">    <span class="type">int</span> _y;</span><br><span class="line">    <span class="type">int</span> _val;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> x)</span><br><span class="line">        : _x(x), </span><br><span class="line">          _y(<span class="number">0</span>), </span><br><span class="line">          _val(<span class="number">0</span>)</span><br><span class="line">    &#123;&#125; <span class="comment">// 初始化列表</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>注意事项</strong>：</p><ol><li>每个成员变量在初始化列表中只能出现一次。初始化列表的目的是对成员进行一次初始化。</li><li>对于某些特殊类型的成员变量，必须使用初始化列表来进行初始化。例如：<ul><li><strong>引用成员变量</strong>：引用一旦初始化就不可更改，只能在初始化列表中赋值。</li><li><strong>const 成员变量</strong>：常量变量（const 变量）在对象创建时必须初始化，且不可更改；必须在声明时初始化，不能通过构造函数体赋值。</li><li><strong>自定义类型成员</strong>&#x2F;<strong>没有默认构造函数的自定义类型</strong>：自定义类型变量如果没有默认构造函数，只能通过初始化列表初始化。</li></ul></li><li>尽量使用初始化列表初始化，因为不管你是否使用初始化列表，对于自定义类型成员变量，一定会先使用初始化列表初始化。</li><li><strong>初始化列表的顺序</strong>：初始化列表中的成员变量的初始化顺序 <strong>和它们在类中声明的顺序一致</strong>，而不是按照初始化列表中出现的顺序（编译器会按照成员变量在类中声明的顺序进行内存布局，因此初始化顺序也必须与之匹配）。</li></ol><p><strong>推荐使用初始化列表的原因</strong>： 对于自定义类型，编译器会自动调用其构造函数完成初始化，不使用初始化列表而采用先默认构造再赋值可能导致性能浪费。</p><p><strong>类的成员变量初始化顺序</strong> 取决于 <strong>成员变量的声明顺序</strong>，而不是初始化列表的顺序：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 此处先声明 a, 再声明 b</span></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> b;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> x) : <span class="built_in">b</span>(<span class="number">20</span>), <span class="built_in">a</span>(x) <span class="comment">// 初始化列表：b 在 a 之前初始化（就会导致一些奇怪的错误：未定义行为（UB））</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// b 在 a 之后声明，所以 a 会先被初始化，b 才会初始化！</span></span><br><span class="line"><span class="comment">// 如果 b 的初始化依赖 a，就会导致意外的错误或 UB！</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;, b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">MyClass <span class="title">obj</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">// 输出：a = 10, b = 20</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="1-3-explicit-关键字"><a href="#1-3-explicit-关键字" class="headerlink" title="1.3 explicit 关键字"></a>1.3 explicit 关键字</h3><p>如果构造函数接收单一参数，它可能会被编译器用于隐式类型转换。而 <code>explicit</code> 关键字则用来标记构造函数，防止它参与隐式类型转换。 隐式类型转换可能导致临时对象的创建和销毁，增加不必要的性能开销，或者在代码中引入难以察觉的错误。</p><p>在 C++中，构造函数不仅可以用来构造和初始化对象，还可以在特定条件下用作类型转换的“隐式转换构造函数”。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 构造函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// error: conversion from &#x27;int&#x27; to non-scalar type &#x27;MyClass&#x27; requested</span></span><br><span class="line">MyClass obj = <span class="number">10</span>;  <span class="comment">// 编译器会用构造函数将10转换为MyClass对象</span></span><br><span class="line"></span><br><span class="line">在上述代码中，`<span class="built_in">MyClass</span>(<span class="type">int</span> x)`构造函数是一个单参构造函数，可以将`<span class="type">int</span>`类型的<span class="number">10</span>隐式转换为`MyClass`类型的对象。</span><br><span class="line">为防止这种类型转换，我们可以在构造函数前加上`<span class="keyword">explicit</span>`关键字，这样就禁止了隐式转换：</span><br><span class="line">    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MyClass</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 构造函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MyClass obj = <span class="number">10</span>;  <span class="comment">// 错误：不能隐式转换</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> x) &#123;&#125; <span class="comment">// 单参构造函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A obj = <span class="number">10</span>; <span class="comment">// 隐式调用构造函数</span></span><br><span class="line"></span><br><span class="line">**<span class="keyword">explicit</span>的作用**： 使用`<span class="keyword">explicit</span>`关键字禁止隐式类型转换：</span><br><span class="line">    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">A</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A obj = <span class="number">10</span>; <span class="comment">// 错误，禁止隐式转换</span></span><br><span class="line"><span class="function">A <span class="title">obj2</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> x) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyExplicitClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MyExplicitClass</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MyClass obj1 = <span class="number">10</span>;  <span class="comment">// 隐式类型转换</span></span><br><span class="line">    MyExplicitClass obj2 = <span class="number">10</span>;  <span class="comment">// 错误：禁止隐式类型转换</span></span><br><span class="line">    <span class="function">MyExplicitClass <span class="title">obj3</span><span class="params">(<span class="number">10</span>)</span></span>;  <span class="comment">// 显式类型转换</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;obj1 created successfully.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; &quot;obj2 created successfully.&quot; &lt;&lt; endl;  // 编译错误</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;obj3 created successfully.&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>explicit</code> 关键字后，只有明确调用构造函数时才能进行类型转换，不能再进行隐式转换。所以，构造函数不仅仅负责创建对象，它还通过初始化列表给对象成员变量赋初值。通过 <code>explicit</code> 关键字，我们可以禁止单参构造函数的隐式类型转换，确保代码的类型安全。</p><hr><h2 id="2-static-成员"><a href="#2-static-成员" class="headerlink" title="2. static 成员"></a>2. static 成员</h2><h3 id="2-1-概念"><a href="#2-1-概念" class="headerlink" title="2.1 概念"></a>2.1 概念</h3><p>在 C++中，类成员可以被声明为 <code>static</code>，这样的成员称为 <strong>静态成员</strong>。静态成员包括静态成员变量和静态成员函数。</p><ul><li><strong>静态成员变量</strong>：使用 <code>static</code> 修饰的类成员变量，所有对象共享这个变量，不属于某个特定的对象。静态成员变量必须在类外进行初始化（被修饰的变量属于类本身，而不是某个对象）。</li><li><strong>静态成员函数</strong>：使用 <code>static</code> 修饰的成员函数，它是属于类的，而不是类的某个对象（修饰的函数属于类本身，可以直接通过类名调用）。</li></ul><h4 id="2-2-特性"><a href="#2-2-特性" class="headerlink" title="2.2 特性"></a>2.2 特性</h4><ol><li><p><strong>静态成员的共享性</strong>： 静态成员变量为所有对象共享，修改其中一个对象的静态成员变量值，会影响其他对象。</p><ul><li>静态成员变量和静态成员函数是属于类本身的，而不是类的某个特定对象。</li><li>所有类对象共享静态成员，这意味着静态成员的值对所有对象是相同的。</li><li>静态成员并不存储在每个对象中，而是存放在一个全局的静态区。</li></ul><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> _count;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Increment</span><span class="params">()</span> </span>&#123; _count++; &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">GetCount</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _count; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> A::_count = <span class="number">0</span>;<span class="comment">//  静态变量必须在类外定义/初始化</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A::<span class="built_in">Increment</span>();</span><br><span class="line">    cout &lt;&lt; A::<span class="built_in">GetCount</span>() &lt;&lt; endl; <span class="comment">// 输出1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>静态成员变量的初始化</strong>：</p><ul><li><p>静态成员变量在类外进行定义和初始化，而在类内部仅声明。</p></li><li><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> count;  <span class="comment">// 静态成员变量声明</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> MyClass::count = <span class="number">0</span>;  <span class="comment">// 静态成员变量初始化</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>访问静态成员</strong>：</p><ul><li>可以通过类名直接访问静态成员：<code>类名::静态成员</code>。</li><li>也可以通过对象访问静态成员：<code>对象.静态成员</code>。但是，通常推荐通过类名来访问，保持代码的清晰和一致性。</li></ul></li><li><p><strong>静态成员函数没有 <code>this</code> 指针</strong>：</p><ul><li>静态成员函数与类的对象无关，静态成员函数属于类本身，而不是某个对象，因此它没有隐藏的 <code>this</code> 指针。</li><li>由于没有 <code>this</code> 指针，静态成员函数无法访问类的非静态成员变量或非静态成员函数（只能访问静态变量，不能访问非静态成员）。</li><li>非静态成员属于对象，而静态成员函数与对象无关，因此无法通过 <code>this</code> 指针访问非静态成员。</li></ul></li><li><p><strong>访问权限</strong>：</p><ul><li>静态成员仍然受类的访问控制（<code>public</code>、<code>protected</code>、<code>private</code>）的限制。</li></ul></li></ol><h3 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h3><p>假设我们要实现一个类，统计类的对象创建次数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> count; <span class="comment">// 静态成员变量，属于类本身</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">MyClass</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        count++; <span class="comment">// 每创建一个对象，静态变量 count 加 1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">getCount</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count; <span class="comment">// 静态成员函数，返回静态变量的值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> MyClass::count = <span class="number">0</span>; <span class="comment">// 类外初始化静态成员变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MyClass obj1, obj2, obj3;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;创建的对象数：&quot;</span> &lt;&lt; MyClass::<span class="built_in">getCount</span>() &lt;&lt; endl; <span class="comment">// 输出：创建的对象数：3</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态成员函数和非静态成员函数的区别：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> staticVar;</span><br><span class="line">    <span class="type">int</span> nonStaticVar;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">staticFunction</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;static 函数，staticVar =&quot;</span> &lt;&lt; staticVar &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; &quot;非静态 var =&quot; &lt;&lt; nonStaticVar &lt;&lt; endl;  // 编译错误</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">nonStaticFunction</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;非静态函数，nonStaticVar =&quot;</span> &lt;&lt; nonStaticVar &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;静态 var =&quot;</span> &lt;&lt; staticVar &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> MyClass::staticVar = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MyClass::<span class="built_in">staticFunction</span>();  <span class="comment">// 静态函数调用</span></span><br><span class="line">    MyClass obj;</span><br><span class="line">    obj.<span class="built_in">nonStaticFunction</span>();  <span class="comment">// 非静态函数调用</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h3 id="传道解惑："><a href="#传道解惑：" class="headerlink" title="传道解惑："></a>传道解惑：</h3><h4 id="Q1：静态成员函数可以调用非静态成员函数吗？"><a href="#Q1：静态成员函数可以调用非静态成员函数吗？" class="headerlink" title="Q1：静态成员函数可以调用非静态成员函数吗？"></a>Q1：静态成员函数可以调用非静态成员函数吗？</h4><p><strong>不可以</strong>。静态成员函数没有 <code>this</code> 指针，它与对象无关。因此，它无法访问类的非静态成员变量和非静态成员函数。如果静态成员函数试图访问非静态成员函数或成员变量，会导致编译错误。</p><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&gt;&#123;</span><br><span class="line">&gt;<span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">nonStaticFunction</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;这是一个非静态函数。&quot;</span> &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">staticFunction</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">          <span class="comment">// 不能访问非静态成员函数</span></span><br><span class="line">          <span class="comment">// nonStaticFunction();  // 错误：静态成员函数不能访问非静态成员函数</span></span><br><span class="line">   &#125;</span><br><span class="line">&gt;&#125;;</span><br></pre></td></tr></table></figure><h4 id="Q2-非静态成员函数可以调用类的静态成员函数吗？"><a href="#Q2-非静态成员函数可以调用类的静态成员函数吗？" class="headerlink" title="Q2: 非静态成员函数可以调用类的静态成员函数吗？"></a>Q2: 非静态成员函数可以调用类的静态成员函数吗？</h4><p><strong>可以</strong>。非静态成员函数属于某个对象，可以访问类的静态成员变量和静态成员函数。非静态成员函数是通过对象的 <code>this</code> 指针来访问类的成员的，所以它可以直接访问静态成员。</p><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&gt;&#123;</span><br><span class="line">&gt;<span class="keyword">public</span>:</span><br><span class="line">   <span class="type">static</span> <span class="type">int</span> staticVar;</span><br><span class="line">   <span class="type">int</span> nonStaticVar;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">nonStaticFunction</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">          <span class="comment">// 可以访问静态成员函数</span></span><br><span class="line">          <span class="built_in">staticFunction</span>();</span><br><span class="line">          cout &lt;&lt; <span class="string">&quot;静态变量：&quot;</span> &lt;&lt; staticVar &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">staticFunction</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;这是一个静态函数。&quot;</span> &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="type">int</span> MyClass::staticVar = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">&gt;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">&gt;</span>&#123;</span><br><span class="line">   MyClass obj;</span><br><span class="line">   obj.<span class="built_in">nonStaticFunction</span>();  <span class="comment">// 调用非静态成员函数，内部可以访问静态成员函数</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;这是一个静态函数。</span><br><span class="line">&gt;静态变量：10</span><br></pre></td></tr></table></figure></blockquote><hr><h2 id="3-友元（Friend）"><a href="#3-友元（Friend）" class="headerlink" title="3. 友元（Friend）"></a>3. 友元（Friend）</h2><p><strong>友元</strong> 是一种打破封装的方式，它允许特定的函数或类访问类的私有成员和保护成员。通常情况下，类的私有成员是只能通过类的成员函数来访问的，但友元提供了一个特例，使得外部函数或类可以访问这些私有成员。尽管友元能提供便利，但它也会增加类之间的耦合度，破坏封装性，因此在设计时应当小心使用。</p><p>友元可以分为两种类型：<strong>友元函数</strong> 和 <strong>友元类</strong>。</p><h3 id="3-1-友元函数"><a href="#3-1-友元函数" class="headerlink" title="3.1 友元函数"></a>3.1 友元函数</h3><ul><li><p><strong>友元函数的定义</strong>： 友元函数是定义在类外的普通函数，但可以访问类的私有成员和保护成员。它并不是类的成员函数，因此没有 <code>this</code> 指针。虽然它是类外的函数，但为了让它可以访问类的私有成员，必须在类内声明为友元函数，使用 <code>friend</code> 关键字。</p></li><li><p><strong>友元函数的特性：</strong></p><ul><li><strong>声明位置</strong>：可以在类定义的任何地方声明，只要在类内部用 <code>friend</code> 关键字。</li><li><strong>访问权限</strong>：友元函数可以访问类的私有和保护成员，但它并不属于类的成员函数。</li><li><strong>不属于类的成员函数</strong>：友元函数的调用和普通函数一样，不通过对象调用，没有 <code>this</code> 指针。</li><li><strong>不能用 <code>const</code> 修饰</strong>：友元函数不能被声明为 <code>const</code>，因为它可能会修改类的私有成员。</li></ul><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>;  <span class="comment">// 前向声明类 A</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> _y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>(<span class="type">int</span> y) : _y(y) &#123;&#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">A</span>;  <span class="comment">// 友元类：A 类可以访问 B 的私有成员</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> _x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> x) : _x(x) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">Print</span><span class="params">(<span class="type">const</span> A&amp; a)</span></span>;  <span class="comment">// 友元函数声明</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 友元类 A 可以访问 B 的私有成员</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(<span class="type">const</span> B&amp; b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Friend class: &quot;</span> &lt;&lt; b._y &lt;&lt; endl;  <span class="comment">// 访问 B 的私有成员</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(<span class="type">const</span> A&amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Friend function: &quot;</span> &lt;&lt; a._x &lt;&lt; endl;  <span class="comment">// 访问 A 的私有成员</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="built_in">Print</span>(a);  <span class="comment">// 调用友元函数</span></span><br><span class="line"></span><br><span class="line">    <span class="function">B <span class="title">b</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line">    a.<span class="built_in">Print</span>(b);  <span class="comment">// 调用友元类中的成员函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>友元函数的使用场景</strong>：</p><ul><li>当需要定义一个全局函数，并且需要访问类的私有数据时。</li><li>常用于重载操作符 <code>&lt;&lt;</code> 和 <code>&gt;&gt;</code>。</li></ul></li></ul><blockquote><h3 id="传道解惑"><a href="#传道解惑" class="headerlink" title="传道解惑"></a>传道解惑</h3><h4 id="Q1：为什么使用友元函数？"><a href="#Q1：为什么使用友元函数？" class="headerlink" title="Q1：为什么使用友元函数？"></a>Q1：为什么使用友元函数？</h4><p>友元函数常用于那些不能作为成员函数实现的操作。例如，重载输入输出运算符 <code>&lt;&lt;</code> 和 <code>&gt;&gt;</code> 时，<code>cout</code> 和 <code>cin</code> 对象是流对象，需要通过全局函数进行操作，而不能作为类的成员函数。</p><h5 id="示例：重载-operator"><a href="#示例：重载-operator" class="headerlink" title="示例：重载 operator&lt;&lt;（输出流）为友元函数"></a>示例：重载 <code>operator&lt;&lt;</code>（输出流）为友元函数</h5><p>假设我们有一个 <code>Box</code> 类，想要重载 <code>&lt;&lt;</code> 运算符来输出 <code>Box</code> 的内容，<code>cout</code> 需要是左操作数，因此 <code>&lt;&lt;</code> 不能作为成员函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">&gt;<span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">Box</span></span><br><span class="line">&gt;&#123;</span><br><span class="line">&gt;<span class="keyword">private</span>:</span><br><span class="line">       <span class="type">int</span> length;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">       <span class="built_in">Box</span>(<span class="type">int</span> l) : <span class="built_in">length</span>(l) &#123;&#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 声明友元函数</span></span><br><span class="line">       <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os, <span class="type">const</span> Box&amp; box);</span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 友元函数的定义</span></span><br><span class="line">&gt;ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os, <span class="type">const</span> Box&amp; box)</span><br><span class="line">&gt;&#123;</span><br><span class="line">       os &lt;&lt; <span class="string">&quot;箱长：&quot;</span> &lt;&lt; box.length;</span><br><span class="line">       <span class="keyword">return</span> os;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">&gt;</span>&#123;</span><br><span class="line">       <span class="function">Box <span class="title">box</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">       cout &lt;&lt; box &lt;&lt; endl;  <span class="comment">// 使用重载的operator&lt;&lt;</span></span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;箱长：10</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>operator&lt;&lt;</code> 是一个友元函数，它被声明为 <code>Box</code> 类的友元，因此它可以访问 <code>Box</code> 类的私有成员 <code>length</code>。</p></blockquote><hr><h3 id="3-2-友元类"><a href="#3-2-友元类" class="headerlink" title="3.2 友元类"></a>3.2 友元类</h3><p><strong>友元类</strong> 是指一个类的所有成员函数都可以成为另一个类的友元函数，因此友元类的所有成员函数都可以访问当前类的私有成员和保护成员。</p><h4 id="友元类的特性："><a href="#友元类的特性：" class="headerlink" title="友元类的特性："></a>友元类的特性：</h4><ul><li><strong>单向关系</strong>：如果类 A 声明类 B 为友元类，那么类 B 的成员函数可以访问类 A 的私有成员，但类 A 的成员函数不能访问类 B 的私有成员。友元关系是单向的（声明友元类 B 后，B 能访问 A，但 A 不能访问 B）。</li><li><strong>不能继承</strong>：友元关系不能被继承，如果类 A 是类 B 的友元类，那么类 B 的派生类不会自动成为类 A 的友元类。</li><li><strong>关系不可传递</strong>：如果 B 是 A 的友元，C 是 B 的友元，那么 C 并不是 A 的友元。</li></ul><h4 id="示例：友元类"><a href="#示例：友元类" class="headerlink" title="示例：友元类"></a>示例：友元类</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> _x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> x) : _x(x) &#123;&#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">B</span>; <span class="comment">// 声明B为友元类</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AccessA</span><span class="params">(<span class="type">const</span> A&amp; a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; a._x &lt;&lt; endl; <span class="comment">// 访问A的私有成员</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>再假设我们有 <code>Time</code> 类和 <code>Date</code> 类，并希望 <code>Time</code> 类可以访问 <code>Date</code> 类的私有成员。我们可以在 <code>Time</code> 类中声明 <code>Date</code> 为友元类。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Time</span>; <span class="comment">// 前向声明</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printTime</span><span class="params">(<span class="type">const</span> Time&amp; t)</span></span>; <span class="comment">// 声明函数，访问 Time 类的私有成员</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Time</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> hour;</span><br><span class="line">    <span class="type">int</span> minute;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Time</span>(<span class="type">int</span> h, <span class="type">int</span> m) : <span class="built_in">hour</span>(h), <span class="built_in">minute</span>(m) &#123;&#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Date</span>; <span class="comment">// 声明 Date 类为友元类</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Date::printTime</span><span class="params">(<span class="type">const</span> Time&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Time: &quot;</span> &lt;&lt; t.hour &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; t.minute &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Time <span class="title">t</span><span class="params">(<span class="number">10</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">    Date d;</span><br><span class="line">    d.<span class="built_in">printTime</span>(t); <span class="comment">// 输出：Time: 10:30</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>Time</code> 类声明了 <code>Date</code> 类为友元类，这样 <code>Date</code> 类的成员函数 <code>printTime</code> 就能够访问 <code>Time</code> 类的私有成员（如 <code>hour</code> 和 <code>minute</code>）。</p><h3 id="SO："><a href="#SO：" class="headerlink" title="SO："></a>SO：</h3><ul><li><strong>友元函数</strong>：允许非成员函数访问类的私有和保护成员。它不是类的成员函数，通常用于操作符重载等场景。</li><li><strong>友元类</strong>：允许一个类的所有成员函数访问另一个类的私有和保护成员。它们的关系是单向的。</li><li><strong>使用场景</strong>：友元可以提高代码的灵活性和可操作性，但过多使用会增加类之间的耦合度，破坏封装，因此要谨慎使用。</li></ul><hr><h2 id="4-内部类（Nested-Class）"><a href="#4-内部类（Nested-Class）" class="headerlink" title="4. 内部类（Nested Class）"></a>4. 内部类（Nested Class）</h2><h3 id="4-1-概念："><a href="#4-1-概念：" class="headerlink" title="4.1 概念："></a>4.1 概念：</h3><p><strong>内部类</strong> 是定义在另一个类内部的类。它是一个独立的类，和外部类没有直接的归属关系，即它并不属于外部类的对象。外部类不能直接访问内部类的成员，反之，内部类可以访问外部类的成员，特别是当外部类的成员是 <code>static</code> 时（内部类天然是外部类的友元，可以访问外部类的私有成员）。</p><p><strong>内部类</strong> 有时也被称为 <strong>嵌套类</strong>，通常用于将一个类作为一个辅助工具类嵌套在另一个类中，通常与外部类的功能紧密相关。</p><p><strong>例如：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> _count;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">ShowCount</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            cout &lt;&lt; _count &lt;&lt; endl; <span class="comment">// 直接访问静态成员</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> A::_count = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A::B b;</span><br><span class="line">    b.<span class="built_in">ShowCount</span>(); <span class="comment">// 输出10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="关键点："><a href="#关键点：" class="headerlink" title="关键点："></a>关键点：</h4><ol><li><strong>独立性</strong>：内部类是一个完全独立的类，它不属于外部类的对象。因此，外部类不能通过自身的对象直接访问内部类的成员。</li><li><strong>友元关系</strong>：虽然外部类不能直接访问内部类的成员，但内部类可以通过外部类的对象访问外部类的所有成员（包括私有成员）。从这个角度来看，内部类可以看作外部类的友元类（<strong>内部类天然具有可以访问外部类的私有成员这种访问权限，而不是因为它是友元类</strong>）。</li></ol><h3 id="4-2-内部类的特性"><a href="#4-2-内部类的特性" class="headerlink" title="4.2 内部类的特性"></a>4.2 内部类的特性</h3><ol><li><strong>访问权限</strong>：<ul><li>内部类可以定义在外部类的 <code>public</code>、<code>protected</code>、<code>private</code> 等任何区域，和外部类的访问权限相同。</li><li>但外部类不能直接访问内部类的成员，除非通过内部类的对象来访问。</li><li>内部类可以访问外部类的非静态成员，但需要通过外部类的对象来访问。</li></ul></li><li><strong>访问外部类的静态成员</strong>：<ul><li>内部类可以直接访问外部类中的 <code>static</code> 成员，无需外部类的对象或类名。这是因为静态成员是属于类本身的，而不是某个特定对象的。</li></ul></li><li><strong><code>sizeof</code> 外部类和内部类</strong>：<ul><li>外部类和内部类是两个独立的实体，它们占用不同的内存空间。通过 <code>sizeof</code> 计算外部类的大小时，和内部类没有直接关系。</li></ul></li></ol><h3 id="4-3-内部类的分类"><a href="#4-3-内部类的分类" class="headerlink" title="4.3 内部类的分类"></a>4.3 内部类的分类</h3><ul><li><strong>静态内部类</strong>（<code>static</code> nested class）：内部类是静态的，意味着它不需要外部类的实例就可以访问。静态内部类不能访问外部类的实例成员，但可以访问外部类的静态成员。</li><li><strong>非静态内部类</strong>（普通内部类）：需要通过外部类的实例来创建实例，且能够访问外部类的所有成员（包括非静态成员）。</li></ul><h3 id="示例：内部类的使用"><a href="#示例：内部类的使用" class="headerlink" title="示例：内部类的使用"></a>示例：内部类的使用</h3><p>下面我们通过一个例子，详细讲解内部类的使用。</p><h4 id="1-普通的内部类"><a href="#1-普通的内部类" class="headerlink" title="1. 普通的内部类"></a>1. 普通的内部类</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> outerVar = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Inner</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">accessOuter</span><span class="params">(Outer&amp; outer)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="comment">// 内部类可以访问外部类的私有成员</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;访问外部类 private 成员：&quot;</span> &lt;&lt; outer.outerVar &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Outer outer;</span><br><span class="line">    Outer::Inner inner;  <span class="comment">// 创建内部类对象</span></span><br><span class="line">    inner.<span class="built_in">accessOuter</span>(outer);  <span class="comment">// 通过内部类访问外部类的成员</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">访问外部类 private 成员：10</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>Inner</code> 是 <code>Outer</code> 类的内部类。<code>Inner</code> 类可以访问 <code>Outer</code> 类的私有成员 <code>outerVar</code>，并且我们通过 <code>Outer</code> 类的对象来访问外部类的成员。</p><h4 id="2-静态内部类"><a href="#2-静态内部类" class="headerlink" title="2. 静态内部类"></a>2. 静态内部类</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> staticVar;  <span class="comment">// 静态成员</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="keyword">class</span> <span class="title class_">Inner</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">accessOuter</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="comment">// 静态内部类可以访问外部类的静态成员</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;访问外部类 static 成员：&quot;</span> &lt;&lt; staticVar &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Outer::staticVar = <span class="number">20</span>;<span class="comment">// 类外初始化静态成员变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Outer::Inner inner;  <span class="comment">// 创建静态内部类对象</span></span><br><span class="line">    inner.<span class="built_in">accessOuter</span>();  <span class="comment">// 静态内部类访问外部类的静态成员</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">访问外部类 static 成员：20</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>Inner</code> 是 <code>Outer</code> 类的静态内部类。静态内部类可以直接访问 <code>Outer</code> 类的静态成员 <code>staticVar</code>，不需要外部类的对象。</p><h4 id="3-普通内部类和静态内部类的区别："><a href="#3-普通内部类和静态内部类的区别：" class="headerlink" title="3. 普通内部类和静态内部类的区别："></a>3. 普通内部类和静态内部类的区别：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> outerVar = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Inner</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">accessOuter</span><span class="params">(Outer&amp; outer)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;非静态内部类：&quot;</span> &lt;&lt; outer.outerVar &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="keyword">class</span> <span class="title class_">StaticInner</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">accessOuter</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;static 内部类：&quot;</span> &lt;&lt; outerVar &lt;&lt; endl;  <span class="comment">// 编译错误</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Outer outer;</span><br><span class="line">    Outer::Inner inner;</span><br><span class="line">    inner.<span class="built_in">accessOuter</span>(outer);  <span class="comment">// 非静态内部类访问外部类成员</span></span><br><span class="line"></span><br><span class="line">    Outer::StaticInner staticInner;</span><br><span class="line">    <span class="comment">// staticInner.accessOuter();  // 编译错误</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SO"><a href="#SO" class="headerlink" title="SO:"></a>SO:</h3><ul><li><strong>内部类</strong> 是定义在另一个类内部的类。它是独立的类，外部类不能直接访问内部类的成员，内部类可以通过外部类的对象访问外部类的所有成员。</li><li><strong>友元关系</strong>：从某种角度看，内部类可以访问外部类的私有成员，所以可以视作外部类的友元类。</li><li>内部类可以是 <strong>静态的</strong>（<code>static</code>），也可以是 <strong>非静态的</strong>，它们的访问权限和行为有所不同。</li></ul><p>内部类通常用于处理一些与外部类紧密相关的功能，帮助将代码组织得更好。</p><hr><h2 id="5-匿名对象（Anonymous-Object）"><a href="#5-匿名对象（Anonymous-Object）" class="headerlink" title="5. 匿名对象（Anonymous Object）"></a>5. 匿名对象（Anonymous Object）</h2><p>在 C++中，匿名对象指的是没有明确名称的对象。它通常用于函数返回、临时数据传递、类型转换等场景，它们的生命周期仅限于它们所在的表达式或者函数调用，执行完毕后即被销毁。通过合理使用匿名对象，可以简化代码、减少不必要的对象创建，提高程序的效率。下面我将详细讲解匿名对象的相关知识点及其使用。</p><h3 id="5-1-匿名对象的定义和创建"><a href="#5-1-匿名对象的定义和创建" class="headerlink" title="5.1 匿名对象的定义和创建"></a>5.1 匿名对象的定义和创建</h3><p>匿名对象是没有名字的临时对象。在 C++中，匿名对象通常出现在以下场景：</p><ul><li><strong>作为函数返回值：</strong> 当函数返回一个对象时，C++会创建一个匿名对象来接收返回值。</li><li><strong>临时对象：</strong> 用作表达式的操作数时，编译器会创建一个临时对象。</li><li><strong>类型转换：</strong> 在类型转换过程中，C++会临时创建匿名对象。</li></ul><h3 id="5-2-匿名对象的生命周期"><a href="#5-2-匿名对象的生命周期" class="headerlink" title="5.2 匿名对象的生命周期"></a>5.2 匿名对象的生命周期</h3><p>匿名对象的生命周期非常短，通常只在一个表达式或者函数调用期间有效。它们会在表达式结束后立即销毁。这是因为它们没有名字，无法直接引用它们。</p><h3 id="5-3-匿名对象的使用示例"><a href="#5-3-匿名对象的使用示例" class="headerlink" title="5.3 匿名对象的使用示例"></a>5.3 匿名对象的使用示例</h3><h4 id="示例-1：作为函数返回值的匿名对象"><a href="#示例-1：作为函数返回值的匿名对象" class="headerlink" title="示例 1：作为函数返回值的匿名对象"></a>示例 1：作为函数返回值的匿名对象</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;MyClass 构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">MyClass</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;MyClass 析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sayHello</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Hello from MyClass!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数返回匿名对象</span></span><br><span class="line"><span class="function">MyClass <span class="title">createObject</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">MyClass</span>();  <span class="comment">// 返回一个匿名对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">createObject</span>().<span class="built_in">sayHello</span>();  <span class="comment">// 创建一个匿名对象并调用它的方法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解释：</strong></p><ul><li>在 <code>createObject</code> 函数中，<code>return MyClass();</code> 创建了一个匿名对象并返回。</li><li>在 <code>main</code> 函数中，调用 <code>createObject().sayHello()</code> 时，匿名对象在 <code>createObject</code> 函数返回时创建，并且调用 <code>sayHello()</code> 方法。</li><li>程序运行时，首先会打印构造函数的消息，接着打印 <code>sayHello()</code> 的消息，然后销毁匿名对象，打印析构函数的消息。</li></ul><h4 id="示例-2：作为临时对象"><a href="#示例-2：作为临时对象" class="headerlink" title="示例 2：作为临时对象"></a>示例 2：作为临时对象</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;MyClass 构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">MyClass</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;MyClass 析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sayHello</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Hello from MyClass!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MyClass obj;</span><br><span class="line">    obj.<span class="built_in">sayHello</span>();</span><br><span class="line">    <span class="built_in">MyClass</span>().<span class="built_in">sayHello</span>();  <span class="comment">// 这里是一个匿名对象调用方法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解释：</strong></p><ul><li>在 <code>main</code> 函数中，<code>MyClass().sayHello();</code> 创建了一个匿名对象并调用了 <code>sayHello</code> 方法。</li><li>这个匿名对象仅在该行代码执行时有效，执行完后立即销毁。</li></ul><h4 id="示例-3：通过类型转换创建匿名对象"><a href="#示例-3：通过类型转换创建匿名对象" class="headerlink" title="示例 3：通过类型转换创建匿名对象"></a>示例 3：通过类型转换创建匿名对象</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> value) : <span class="built_in">m_value</span>(value)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;MyClass 构造函数：&quot;</span> &lt;&lt; m_value &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">MyClass</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;MyClass 析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="number">10</span>);  <span class="comment">// 创建一个匿名对象并传递给构造函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解释：</strong></p><ul><li><code>MyClass(10);</code> 创建了一个匿名对象，并且传递了参数 <code>10</code> 给构造函数。</li><li>这个匿名对象在创建后立即销毁，生命周期仅限于该行代码。</li></ul><h3 id="5-4-匿名对象的应用场景"><a href="#5-4-匿名对象的应用场景" class="headerlink" title="5.4 匿名对象的应用场景"></a>5.4 匿名对象的应用场景</h3><p>匿名对象有很多实际应用，下面列出一些常见的场景：</p><ol><li><p><strong>临时数据传递：</strong> 在函数调用时传递临时对象，避免了不必要的对象复制。</p><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">processObject</span><span class="params">(<span class="type">const</span> MyClass&amp; obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 处理传入的对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">processObject</span>(<span class="built_in">MyClass</span>(<span class="number">5</span>));  <span class="comment">// 创建一个匿名对象并传递</span></span><br></pre></td></tr></table></figure></li><li><p><strong>简化代码：</strong> 当不需要重复使用对象时，可以通过匿名对象来简化代码，避免创建多余的变量。</p></li><li><p><strong>链式调用：</strong> 匿名对象可以用于链式调用多个函数。</p><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">MyClass</span>().<span class="built_in">sayHello</span>().<span class="built_in">anotherFunction</span>();  <span class="comment">// 链式调用匿名对象的方法</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="5-5-注意事项"><a href="#5-5-注意事项" class="headerlink" title="5.5 注意事项"></a>5.5 注意事项</h3><ul><li><strong>内存管理：</strong> 匿名对象通常是自动管理的，C++会在它们超出作用域后自动销毁。这意味着开发者不需要手动释放内存，但如果匿名对象涉及到动态内存分配（如 <code>new</code>），则需要特别注意内存管理。</li><li><strong>避免悬挂引用：</strong> 由于匿名对象的生命周期很短，必须避免在它销毁后访问它。</li></ul><blockquote><h2 id="传道解惑-1"><a href="#传道解惑-1" class="headerlink" title="传道解惑"></a>传道解惑</h2><h3 id="Q1：为什么匿名对象加-const-可以延长生命周期"><a href="#Q1：为什么匿名对象加-const-可以延长生命周期" class="headerlink" title="Q1：为什么匿名对象加 const 可以延长生命周期?"></a>Q1：为什么匿名对象加 <code>const</code> 可以延长生命周期?</h3><p>将匿名对象加上 <code>const</code> 修饰符，<strong>可以延长其生命周期</strong>。但这种延长的生命周期并不是无条件的，它的背后有一些特定的规则和原理。</p><p>在 C++中，匿名对象的生命周期是由它们的 <strong>作用域</strong> 决定的，通常在一个表达式或函数调用结束时，匿名对象会被销毁。但是，如果将匿名对象声明为 <code>const</code> 类型，它将与一个 <strong>引用</strong> 绑定，从而延长其生命周期。这是因为 <code>const</code> 引用允许我们在对象生命周期结束后，依然通过引用来使用它。</p><h4 id="具体解释："><a href="#具体解释：" class="headerlink" title="具体解释："></a>具体解释：</h4><ol><li><strong>匿名对象与临时对象的生命周期：</strong></li></ol><ul><li><p>默认情况下，匿名对象（临时对象）的生命周期通常非常短，仅限于它的表达式或语句的结束。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">MyClass</span>().<span class="built_in">doSomething</span>();  <span class="comment">// 匿名对象在 doSomething() 执行完后销毁</span></span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li><strong>使用 <code>const</code> 引用延长生命周期：</strong></li></ol><ul><li>当匿名对象绑定到一个 <code>const</code> 引用时，C++会保证匿名对象的生命周期至少延长到该引用的生命周期结束。也就是说，这个引用会“延迟”对象销毁的时机，直到引用被销毁。</li><li><strong>关键点：</strong> <code>const</code> 引用可以延长临时对象的生命周期，使其存在于引用的作用域中，直到引用超出作用域。</li></ul><p>  示例：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">const</span> MyClass&amp; obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    obj.<span class="built_in">doSomething</span>();  <span class="comment">// obj 是对匿名对象的引用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">foo</span>(<span class="built_in">MyClass</span>());  <span class="comment">// 匿名对象绑定到 const 引用 obj</span></span><br><span class="line">    <span class="comment">// 匿名对象在 foo() 返回时才销毁</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  在这个例子中：</p><ul><li><code>MyClass()</code> 创建了一个匿名对象。</li><li>这个匿名对象会被传递给 <code>foo()</code> 函数，并绑定到 <code>const MyClass&amp; obj</code> 上。</li><li>匿名对象的生命周期被延长，直到 <code>obj</code> 超出作用域，也就是 <code>foo()</code> 函数结束。</li></ul><p><strong>临时对象的绑定规则：</strong></p><ul><li>当临时对象（匿名对象）被绑定到一个 <code>const</code> 引用时，C++会延长临时对象的生命周期，直到引用超出作用域。</li><li>这样做的目的是为了避免因临时对象提前销毁而导致引用悬挂问题（即引用一个已销毁的临时对象）。</li></ul><h3 id="例子：匿名对象与-const-引用"><a href="#例子：匿名对象与-const-引用" class="headerlink" title="例子：匿名对象与 const 引用"></a>例子：匿名对象与 <code>const</code> 引用</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">&gt;<span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&gt;&#123;</span><br><span class="line">&gt;<span class="keyword">public</span>:</span><br><span class="line">   <span class="built_in">MyClass</span>()</span><br><span class="line">   &#123;</span><br><span class="line">       cout &lt;&lt; <span class="string">&quot;MyClass 构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   ~<span class="built_in">MyClass</span>()</span><br><span class="line">   &#123;</span><br><span class="line">       cout &lt;&lt; <span class="string">&quot;MyClass 析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">doSomething</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       cout &lt;&lt; <span class="string">&quot;做点什么！&quot;</span> &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="function"><span class="type">void</span> <span class="title">processObject</span><span class="params">(<span class="type">const</span> MyClass&amp; obj)</span></span></span><br><span class="line"><span class="function">&gt;</span>&#123;</span><br><span class="line">   obj.<span class="built_in">doSomething</span>();  <span class="comment">// 这里 obj 是对匿名对象的引用</span></span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">&gt;</span>&#123;</span><br><span class="line">   <span class="built_in">processObject</span>(<span class="built_in">MyClass</span>());  <span class="comment">// 匿名对象绑定到 const 引用 obj</span></span><br><span class="line">   <span class="comment">// 匿名对象的生命周期会被延长，直到 processObject 返回</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;MyClass 构造函数</span><br><span class="line">&gt;做点什么！</span><br><span class="line">&gt;MyClass 析构函数</span><br></pre></td></tr></table></figure><p><strong>解释：</strong></p><ul><li>在 <code>processObject</code> 函数中，<code>MyClass()</code> 创建了一个匿名对象，它被传递并绑定到 <code>const MyClass&amp; obj</code>。</li><li>由于 <code>obj</code> 是 <code>const</code> 引用，匿名对象的生命周期被延长，直到 <code>processObject</code> 函数返回。</li><li>匿名对象的析构函数只会在 <code>processObject</code> 函数结束后调用。</li></ul><h3 id="重要说明："><a href="#重要说明：" class="headerlink" title="重要说明："></a>重要说明：</h3><ul><li><strong><code>const</code> 引用延长生命周期的作用范围：</strong> <code>const</code> 引用的作用是延长临时对象的生命周期，<strong>直到引用超出作用域</strong>。这意味着匿名对象在引用的作用域内存在，引用超出作用域后，匿名对象才会销毁。而这样做是为了避免临时对象在使用时被提前销毁，确保引用对象的有效性。这种机制是 C++中的一种特性，它通过引用的生命周期来保证匿名对象在函数作用域内的安全访问。</li><li><strong>非 <code>const</code> 引用不允许绑定临时对象：</strong> 如果你尝试用一个非 <code>const</code> 引用绑定临时对象，C++ 编译器会报错，因为非 <code>const</code> 引用无法延长临时对象的生命周期。</li></ul><hr><h3 id="Q2：匿名对象-VS-有名对象"><a href="#Q2：匿名对象-VS-有名对象" class="headerlink" title="Q2：匿名对象 VS 有名对象"></a>Q2：匿名对象 VS 有名对象</h3><p><strong>匿名对象</strong> 和 <strong>有名对象</strong> 在 C++中的最大区别在于命名、生命周期以及访问方式。匿名对象通常用于临时需要的场合，生命周期短，而有名对象则用于需要在多个地方访问和操作的情形，生命周期较长。下面我将详细解释：</p><p><strong>命名</strong></p><ul><li><p>匿名对象（Anonymous Object）：顾名思义，它没有明确的名称，通常是临时创建的对象，不会绑定到变量上。</p></li><li><p>例如：<code>MyClass().doSomething();</code>，在这里 <code>MyClass()</code> 创建了一个匿名对象，它没有名称，仅用于调用 <code>doSomething()</code> 方法。</p></li><li><p>有名对象（Named Object）：有明确的名称，可以通过变量名访问。</p></li><li><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyClass obj;  <span class="comment">// obj 是有名对象</span></span><br><span class="line">obj.<span class="built_in">doSomething</span>();</span><br></pre></td></tr></table></figure></li></ul><p><strong>生命周期</strong></p><ul><li>匿名对象：生命周期非常短暂，仅存在于当前表达式或者语句中，一旦使用完毕，匿名对象会被销毁。</li><li>例如：<code>MyClass().doSomething();</code> 中，匿名对象会在调用 <code>doSomething()</code> 后立刻销毁。</li><li>有名对象：生命周期通常由它的作用域决定。对象在创建时分配内存，并在其作用域结束时被销毁。如果对象在栈上创建，它会在离开作用域时销毁；如果在堆上创建，则需要手动释放内存。</li><li>例如：<code>MyClass obj;</code> 在 <code>obj</code> 离开作用域时销毁。</li></ul><p><strong>访问方式</strong></p><ul><li><strong>匿名对象</strong>：不能通过变量名访问，因为它没有名称。只能在它创建的上下文中直接使用它。</li><li>例如：<code>MyClass().doSomething();</code> 中没有 <code>MyClass</code> 对象的名称，无法在之后访问它。</li><li><strong>有名对象</strong>：可以通过对象的名称来引用和访问对象的成员。</li><li>例如：<code>obj.doSomething();</code> 中，<code>obj</code> 是有名对象，可以在之后的代码中多次使用。</li></ul><p><strong>内存管理</strong></p><ul><li><strong>匿名对象</strong>：由于没有名称，它通常是栈上分配的，编译器在合适的时候自动管理内存。对于返回值优化（RVO&#x2F;NRVO）等，编译器会优化创建匿名对象的内存管理，避免不必要的拷贝。</li><li><strong>有名对象</strong>：有名称，可以显式创建在栈上或堆上。栈上的对象在作用域结束时自动销毁，而堆上的对象则需要手动 <code>delete</code>。</li></ul><p><strong>应用场景</strong></p><p><strong>匿名对象</strong>：</p><ul><li><p>适用于 <strong>临时使用</strong>，例如一次性计算或者在函数调用中使用临时对象。</p></li><li><p>常见于函数返回值、类型转换、临时数据传递等场景。</p></li><li><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">processObject</span><span class="params">(MyClass obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    obj.<span class="built_in">doSomething</span>();</span><br><span class="line">&#125;</span><br><span class="line">                     </span><br><span class="line"><span class="built_in">processObject</span>(<span class="built_in">MyClass</span>());  <span class="comment">// 匿名对象作为参数传递</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>有名对象</strong>：</p><ul><li><p>适用于 <strong>需要多次访问</strong> 的场景，或者需要在多个地方使用该对象。</p></li><li><p>典型用法是作为类的实例，创建时需要明确的对象名来进行后续操作。</p></li><li><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyClass obj;  <span class="comment">// 有名对象</span></span><br><span class="line">obj.<span class="built_in">doSomething</span>();  <span class="comment">// 可以在后续访问该对象</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>返回值优化（RVO&#x2F;NRVO）</strong></p><ul><li><p><strong>匿名对象</strong> 在函数返回值时，编译器会尽可能优化，避免多余的拷贝操作，这被称为 <strong>返回值优化</strong>（RVO）或者 <strong>命名返回值优化</strong>（NRVO）。这意味着，返回匿名对象时，编译器会直接在调用位置构造返回对象，而不会创建临时对象。</p></li><li><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MyClass <span class="title">createObject</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">MyClass</span>();  <span class="comment">// 匿名对象直接返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>有名对象</strong> 没有这样的优化问题，通常会被拷贝或者移动到调用处，特别是在涉及对象返回时。</p></li></ul><p><strong>性能差异</strong></p><ul><li>匿名对象：由于其生命周期非常短，编译器有时能够优化它们的创建和销毁过程，避免不必要的复制。</li><li>在某些场景中，匿名对象能避免额外的内存分配和释放开销，提升性能。</li><li><strong>有名对象</strong>：虽然生命周期较长，但如果不合理使用，有时会增加额外的开销，尤其是在传递大对象时，可能会发生不必要的拷贝操作。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><table><thead><tr><th>特性</th><th>匿名对象</th><th>有名对象</th></tr></thead><tbody><tr><td><strong>命名</strong></td><td>没有名称，仅为临时对象</td><td>有名称，可以通过变量名访问</td></tr><tr><td><strong>生命周期</strong></td><td>短暂，仅在表达式或函数调用期间存在</td><td>生命周期由作用域决定，作用域结束时销毁</td></tr><tr><td><strong>访问方式</strong></td><td>不能直接访问，通常仅在当前表达式中使用</td><td>可以通过名称多次访问</td></tr><tr><td><strong>内存管理</strong></td><td>编译器自动管理内存，通常是栈上分配</td><td>可以是栈上或堆上，需要显式管理堆对象的内存</td></tr><tr><td><strong>应用场景</strong></td><td>临时数据传递、返回值、一次性计算等</td><td>需要多次使用、存储数据或状态等</td></tr><tr><td><strong>性能差异</strong></td><td>编译器优化可能避免不必要的复制</td><td>如果不小心使用，可能有不必要的拷贝操作### 总结</td></tr></tbody></table></blockquote><hr><h2 id="6-再次理解类和对象"><a href="#6-再次理解类和对象" class="headerlink" title="6. 再次理解类和对象"></a>6. 再次理解类和对象</h2><p>理解 <strong>类</strong> 和 <strong>对象</strong> 的概念，能帮助我们更好地理解面向对象编程（OOP）的核心思想。为了更通俗地讲解这个内容，我们可以通过一个现实中的例子来帮助理解。</p><h3 id="1-类是对事物的抽象"><a href="#1-类是对事物的抽象" class="headerlink" title="1. 类是对事物的抽象"></a>1. 类是对事物的抽象</h3><p>类就像是对某种 <strong>事物</strong>（例如洗衣机）的 <strong>抽象描述</strong>。它是 <strong>对现实中事物的建模</strong>，在程序中描述这个事物的 <strong>属性</strong> 和 <strong>行为</strong>。</p><ul><li><strong>属性</strong>：就是这个事物的特征，比如洗衣机的品牌、颜色、容量等。</li><li><strong>行为</strong>：就是这个事物可以做的事情，比如洗衣机可以“启动”、“停止”、“洗衣服”等。</li></ul><p>举个例子，洗衣机这个事物可以用类来描述：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WashingMachine</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string brand;      <span class="comment">// 洗衣机的品牌</span></span><br><span class="line">    string color;      <span class="comment">// 洗衣机的颜色</span></span><br><span class="line">    <span class="type">int</span> capacity;      <span class="comment">// 洗衣机的容量（比如5kg、10kg）</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Washing machine started.&quot;</span> &lt;&lt; endl;    <span class="comment">// 启动洗衣机</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">stop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Washing machine stopped.&quot;</span> &lt;&lt; endl;      <span class="comment">// 停止洗衣机</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>WashingMachine</code> 类描述了一个洗衣机的 <strong>属性</strong>（<code>brand</code>, <code>color</code>, <code>capacity</code>）和 <strong>行为</strong>（<code>start()</code>，<code>stop()</code>）。这个类的作用就是 <strong>抽象化</strong> 洗衣机，将它的特征和行为描述给计算机。</p><h3 id="2-对象是类的实例化"><a href="#2-对象是类的实例化" class="headerlink" title="2. 对象是类的实例化"></a>2. 对象是类的实例化</h3><p>类是对现实事物的抽象描述，但计算机无法直接“认识”类，必须通过 <strong>实例化</strong> 类来创建 <strong>对象</strong>，而对象才是计算机可以操作的具体实体。</p><ul><li><strong>实例化</strong>：就是通过类创建具体的对象的过程。</li><li><strong>对象</strong>：是类的具体实例，表示现实世界中的某个具体的事物。比如，你可以通过 <code>WashingMachine</code> 类创建多个洗衣机对象，每个对象代表一个具体的洗衣机。</li></ul><p>例子继续，假设我们现在创建了一个洗衣机对象：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WashingMachine</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string brand;      <span class="comment">// 洗衣机的品牌</span></span><br><span class="line">    string color;      <span class="comment">// 洗衣机的颜色</span></span><br><span class="line">    <span class="type">int</span> capacity;      <span class="comment">// 洗衣机的容量（单位：kg）</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Washing machine started.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">stop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Washing machine stopped.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">wash</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Washing clothes...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    WashingMachine wm1;</span><br><span class="line">    wm<span class="number">1.</span>brand = <span class="string">&quot;小米&quot;</span>;</span><br><span class="line">    wm<span class="number">1.</span>color = <span class="string">&quot;白色&quot;</span>;</span><br><span class="line">    wm<span class="number">1.</span>capacity = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    wm<span class="number">1.</span><span class="built_in">start</span>();  <span class="comment">// 启动洗衣机</span></span><br><span class="line">    wm<span class="number">1.</span><span class="built_in">wash</span>();   <span class="comment">// 洗衣服</span></span><br><span class="line">    wm<span class="number">1.</span><span class="built_in">stop</span>();   <span class="comment">// 停止洗衣机</span></span><br><span class="line"></span><br><span class="line">    WashingMachine wm2;</span><br><span class="line">    wm<span class="number">2.</span>brand = <span class="string">&quot;格力&quot;</span>;</span><br><span class="line">    wm<span class="number">2.</span>color = <span class="string">&quot;黑色&quot;</span>;</span><br><span class="line">    wm<span class="number">2.</span>capacity = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    wm<span class="number">2.</span><span class="built_in">start</span>();</span><br><span class="line">    wm<span class="number">2.</span><span class="built_in">wash</span>();</span><br><span class="line">    wm<span class="number">2.</span><span class="built_in">stop</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>wm1</code> 和 <code>wm2</code> 是 <code>WashingMachine</code> 类的两个 <strong>对象</strong>。它们分别代表两个不同的洗衣机，每个对象的属性（<code>brand</code>, <code>color</code>, <code>capacity</code>）可以有不同的值。通过这些对象，我们可以模拟现实中的多个洗衣机。</p><h3 id="3-通过类创建对象"><a href="#3-通过类创建对象" class="headerlink" title="3. 通过类创建对象"></a>3. 通过类创建对象</h3><p>从以上的例子可以看出，类只是描述了洗衣机的属性和行为，而对象才是 <strong>具体的实例</strong>。你可以通过类创建出多个对象，每个对象都代表一个具体的事物。类就像是一个模板或蓝图，具体的对象是根据这个模板生成的。</p><h3 id="4-类和对象的关系"><a href="#4-类和对象的关系" class="headerlink" title="4. 类和对象的关系"></a>4. 类和对象的关系</h3><ul><li><strong>类</strong> 是对 <strong>事物</strong> 的一种描述，它定义了这个事物的 <strong>属性</strong> 和 <strong>行为</strong>。</li><li><strong>对象</strong> 是类的 <strong>实例</strong>，是计算机可以直接操作的具体实体。通过类可以创建多个对象，每个对象都有不同的属性值和方法。</li></ul><p>总结一下，类和对象的关系可以类比为：</p><ul><li><strong>类</strong>：就像是一本 <strong>描述洗衣机的说明书</strong>，它告诉我们洗衣机有哪些属性（品牌、颜色、容量）和行为（启动、停止）。</li><li><strong>对象</strong>：就像是根据这本说明书实际生产出来的 <strong>具体洗衣机</strong>。每一台洗衣机都有自己的品牌、颜色、容量等信息，并可以执行启动、停止等操作。</li></ul><h3 id="5-现实中的例子：洗衣机类"><a href="#5-现实中的例子：洗衣机类" class="headerlink" title="5. 现实中的例子：洗衣机类"></a>5. 现实中的例子：洗衣机类</h3><p>让我们通过现实中的洗衣机来进一步理解。</p><ol><li><strong>抽象洗衣机</strong>：当我们想到洗衣机时，我们并不会想到具体某一台洗衣机，而是先想到了“洗衣机”这个概念。它有品牌、颜色、容量这些特征，并且有启动、停止这些操作。这就是 <strong>类</strong> 的作用：把这些共性的特征和行为总结出来。</li><li><strong>创建洗衣机对象</strong>：当你去买洗衣机时，你选择了一个品牌、颜色、容量等具体参数的洗衣机。每一台洗衣机就是一个 <strong>对象</strong>，它是类的实例化。</li><li><strong>操作洗衣机</strong>：当你开始使用这台洗衣机时，你可以通过按按钮来“启动”和“停止”，这就是对象通过类提供的操作（方法）来实现的行为。</li></ol><hr><h3 id="SO-1"><a href="#SO-1" class="headerlink" title="SO:"></a>SO:</h3><ul><li><strong>类</strong> 是对现实世界中事物的抽象描述，它总结了事物的 <strong>属性</strong> 和 <strong>行为</strong>。</li><li><strong>对象</strong> 是类的具体实例，是计算机能够识别和操作的实体。</li><li><strong>类</strong> 是对事物的抽象描述，而 <strong>对象</strong> 是根据类创建的具体实例。</li><li>通过 <strong>类</strong>，我们可以创建多个不同的 <strong>对象</strong>，每个对象具有类中定义的属性和行为。</li></ul><p>通过理解类和对象的关系，你将能够更好地理解面向对象编程（OOP）的核心思想，这对于学习和使用 C++、Java 等面向对象语言非常重要。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>03 类与对象（中）</title>
      <link href="/posts/30432.html"/>
      <url>/posts/30432.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-类的-6-个默认成员函数"><a href="#1-类的-6-个默认成员函数" class="headerlink" title="1. 类的 6 个默认成员函数"></a>1. 类的 6 个默认成员函数</h2><p><strong>默认成员函数的含义</strong>：<br> 即使一个类什么都不写，编译器也会默认生成 <code>4</code> 以下个成员函数：</p><ol><li><strong>默认构造函数</strong>（初始化对象时调用）。</li><li><strong>拷贝构造函数</strong>（用已有对象创建新对象时调用）。</li><li><strong>析构函数</strong>（对象生命周期结束时调用）。</li><li><strong>赋值运算符重载</strong>（用 <code>=</code> 赋值时调用）。</li></ol><p>可以直接使用的操作符：</p><ol><li><strong>取地址操作符</strong> <code>&amp;</code>。</li><li><strong>常量取地址操作符</strong> <code>const &amp;</code>。</li></ol><p><strong>代码示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 空类，未显式定义任何成员函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Example e1;  <span class="comment">// 调用默认构造函数</span></span><br><span class="line">    Example e2 = e1;  <span class="comment">// 调用拷贝构造函数</span></span><br><span class="line">    Example* ePtr = &amp;e1;  <span class="comment">// 调用取地址操作符</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 在程序结束时，e1 和 e2 调用析构函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h2 id="传道解惑："><a href="#传道解惑：" class="headerlink" title="传道解惑："></a>传道解惑：</h2><h3 id="Q1：e1——类的实例化："><a href="#Q1：e1——类的实例化：" class="headerlink" title="Q1：e1——类的实例化："></a>Q1：<code>e1</code>——类的实例化：</h3><ul><li><strong>实例化</strong>（Instantiating）指的是通过类来创建对象的过程。当你写出类似 <code>Example e1;</code> 的代码时，<code>e1</code> 就是 <code>Example</code> 类的一个实例（对象）。实例化的本质就是通过类（<code>Example</code>）来创建一个具体的对象（<code>e1</code>）。</li><li><strong>类</strong> 是一种模板或者蓝图，它描述了对象的属性和行为，但它本身不是一个具体的对象。类可以看作是定义对象的结构和功能，而实例化就是将类的结构和功能变成一个可以使用的具体对象。</li></ul><p><strong>举个例子</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">Example</span></span><br><span class="line">&gt;&#123;</span><br><span class="line">&gt;<span class="keyword">public</span>:</span><br><span class="line">   <span class="type">int</span> value;  <span class="comment">// 类的成员</span></span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">&gt;</span>&#123;</span><br><span class="line">   Example e1;  <span class="comment">// 创建一个名为 e1 的 Example 类对象</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><ul><li><code>Example</code> 是一个类，定义了一个成员变量 <code>value</code>。</li><li><code>e1</code> 是通过 <code>Example</code> 类进行实例化的对象。它是 <code>Example</code> 类的一个具体实例。</li></ul><hr><h3 id="Q2：ePtr-——-Example-类的指针："><a href="#Q2：ePtr-——-Example-类的指针：" class="headerlink" title="Q2：ePtr —— Example 类的指针："></a>Q2：<code>ePtr</code> —— <code>Example</code> 类的指针：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;Example* ePtr = &amp;e1;</span><br></pre></td></tr></table></figure><ul><li><code>ePtr</code> 是一个指向 <code>Example</code> 类对象的指针。<code>Example*</code> 表示“指向 <code>Example</code> 类的指针”。</li><li><code>&amp;e1</code> 表示取 <code>e1</code> 对象的地址，也就是 <code>ePtr</code> 指向 <code>e1</code> 的内存位置。</li><li><code>ePtr</code> 可以通过指针操作访问 <code>e1</code> 对象的成员（虽然在这个示例中 <code>Example</code> 类没有成员）。</li></ul></blockquote><p>&#x3D;&#x3D;<strong>注意</strong>&#x3D;&#x3D;：如果用户显式定义任何一个成员函数，编译器将不再生成对应的默认版本。</p><hr><h2 id="2-构造函数"><a href="#2-构造函数" class="headerlink" title="2. 构造函数"></a>2. 构造函数</h2><p><strong>构造函数</strong>（Constructor）：是类的一个特殊成员函数，用于在创建对象时进行初始化。构造函数的名字与类名相同，并且没有返回值。它可以是 <strong>无参构造函数</strong>（即默认构造函数）或者 <strong>带参构造函数</strong>（即带参数的构造函数），主要是用于初始化对象的成员函数，可以有参数。</p><ul><li><strong>无参构造函数</strong>（Default Constructor）：也称作 <strong>默认构造函数</strong>，是一种特殊类型的构造函数，<strong>没有参数</strong>。它用于当创建对象时不需要传递任何参数，如果类没有其他构造函数，编译器通常会自动提供一个默认的版本。（<strong>所以</strong>，默认构造函数是一种特殊的构造函数，是构造函数的一种形式，可以是显式定义的，也可以是编译器自动生成的，通常在创建对象时，如果没有传递任何参数，就会调用它）</li><li><strong>带参构造函数</strong>（Parameterized Constructor）：是另一种构造函数，它 <strong>带有参数</strong>，在创建对象时，通过传递不同的参数来定制对象的初始化。</li></ul><blockquote><p>构造函数是 C++ 中用于初始化对象的特殊函数。它的名字虽然叫“构造”，但它的主要任务不是开辟内存空间，而是初始化对象的成员变量。以下是构造函数 <code>7</code> 个特征：</p><h4 id="1-函数名与类名相同"><a href="#1-函数名与类名相同" class="headerlink" title="1. 函数名与类名相同"></a>1. 函数名与类名相同</h4><ul><li><p>构造函数的名字和类名完全一样，这是 C++ 的规定，用于识别构造函数。</p></li><li><p>例子：</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&gt;&#123;</span><br><span class="line">&gt;<span class="keyword">public</span>:</span><br><span class="line">   <span class="built_in">MyClass</span>()</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="comment">// 初始化代码</span></span><br><span class="line">   &#125;</span><br><span class="line">&gt;&#125;;</span><br></pre></td></tr></table></figure><h4 id="2-无返回值"><a href="#2-无返回值" class="headerlink" title="2. 无返回值"></a>2. 无返回值</h4><ul><li>构造函数没有返回值，也不能定义返回类型（包括 <code>void</code>）。</li><li>理由：构造函数的目的是初始化对象，不需要返回任何东西，调用它的结果就是一个已初始化的对象。</li></ul><h4 id="3-对象实例化时，自动调用构造函数"><a href="#3-对象实例化时，自动调用构造函数" class="headerlink" title="3. 对象实例化时，自动调用构造函数"></a>3. 对象实例化时，自动调用构造函数</h4><ul><li>构造函数会在对象创建时由编译器自动调用，无需显式调用。例如：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&gt;&#123;</span><br><span class="line">&gt;<span class="keyword">public</span>:</span><br><span class="line">   <span class="built_in">MyClass</span>()</span><br><span class="line">   &#123;</span><br><span class="line">       cout &lt;&lt; <span class="string">&quot;构造函数被调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;MyClass obj; <span class="comment">// 自动调用构造函数</span></span><br></pre></td></tr></table></figure><h4 id="4-构造函数可以重载"><a href="#4-构造函数可以重载" class="headerlink" title="4. 构造函数可以重载"></a>4. 构造函数可以重载</h4><ul><li><p>构造函数支持重载（即可以有多个构造函数，但参数列表必须不同）。</p></li><li><p>通过重载，用户可以根据需要初始化对象：</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&gt;&#123;</span><br><span class="line">&gt;<span class="keyword">public</span>:</span><br><span class="line">   <span class="built_in">MyClass</span>()</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="comment">// 无参构造函数</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">MyClass</span>(<span class="type">int</span> x)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="comment">// 带参数的构造函数</span></span><br><span class="line">   &#125;</span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;MyClass obj1;     <span class="comment">// 调用无参构造函数</span></span><br><span class="line">&gt;<span class="function">MyClass <span class="title">obj2</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">// 调用带参构造函数</span></span><br></pre></td></tr></table></figure><h4 id="5-默认构造函数的生成规则"><a href="#5-默认构造函数的生成规则" class="headerlink" title="5. 默认构造函数的生成规则"></a>5. 默认构造函数的生成规则</h4><ul><li><p>如果类中没有显式定义无参构造函数，编译器会自动生成一个默认无参构造函数。</p></li><li><p>如果用户显式定义了任意构造函数（无论是否带参数），编译器将不再生成默认无参构造函数，除非显式定义一个无参构造函数。</p></li><li><p>例子：</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&gt;&#123;</span><br><span class="line">   <span class="type">int</span> x;</span><br><span class="line">&gt;&#125;;</span><br><span class="line">&gt;MyClass obj; <span class="comment">// 自动生成无参默认构造函数</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">MyClass2</span></span><br><span class="line">&gt;&#123;</span><br><span class="line">&gt;<span class="keyword">public</span>:</span><br><span class="line">   <span class="built_in">MyClass2</span>(<span class="type">int</span> y) &#123;&#125;</span><br><span class="line">&gt;&#125;;</span><br><span class="line">&gt;MyClass2 obj2; <span class="comment">// 错误，因为没有无参构造函数</span></span><br></pre></td></tr></table></figure><h4 id="6-默认构造函数对内置和自定义类型的处理"><a href="#6-默认构造函数对内置和自定义类型的处理" class="headerlink" title="6. 默认构造函数对内置和自定义类型的处理"></a>6. 默认构造函数对内置和自定义类型的处理</h4><ul><li><p><strong>内置类型（如 <code>int</code>, <code>char</code>）</strong>：</p></li><li><p>默认构造函数不会初始化内置类型成员，成员变量可能是随机值。例如：</p></li></ul> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x; <span class="comment">// 默认值是随机的</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>解决方法：使用 C++11 提供的默认值：</li></ul> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>; <span class="comment">// 默认值为 0</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p><strong>自定义类型（如 <code>class</code>, <code>struct</code>）</strong>：</p></li><li><p>编译器生成的默认构造函数会调用这些类型成员的默认构造函数。</p></li><li><p>例子：</p></li></ul> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Inner</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Inner</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Inner 构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span></span><br><span class="line">&#123;</span><br><span class="line">    Inner obj; <span class="comment">// 自定义类型成员</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Outer obj; <span class="comment">// 实例化自定义类型成员</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：Inner 构造函数</span><br></pre></td></tr></table></figure><h4 id="7-默认构造函数的种类"><a href="#7-默认构造函数的种类" class="headerlink" title="7. 默认构造函数的种类"></a>7. 默认构造函数的种类</h4><p><strong>无参的构造函数</strong> 和 <strong>全缺省的构造函数</strong>（所有参数都有默认值的构造函数）都称为 <strong>默认构造函数</strong>，并且默认构造函数只能有一个。</p><p>注意：无参构造函数、全缺省构造函数、我们没写编译器默认生成的构造函数，都可以认为是默认构造函数。</p><ul><li><p><strong>无参构造函数</strong>：没有任何参数的构造函数。</p></li><li><p><strong>全缺省构造函数</strong>：所有参数都有默认值的构造函数。 两者都属于默认构造函数的范畴，但它们的定义和使用场景有所不同。</p></li><li><p>例子：</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&gt;&#123;</span><br><span class="line">&gt;<span class="keyword">public</span>:</span><br><span class="line">   <span class="built_in">MyClass</span>() &#123;&#125; <span class="comment">// 无参构造函数</span></span><br><span class="line">   <span class="built_in">MyClass</span>(<span class="type">int</span> x = <span class="number">0</span>) &#123;&#125; <span class="comment">// 全缺省构造函数</span></span><br><span class="line">&gt;&#125;;</span><br></pre></td></tr></table></figure><hr><p>构造函数的核心是初始化对象的成员，而非创建内存空间。默认构造函数的行为取决于对象成员的类型：</p><ul><li>内置类型成员默认不初始化，可能是随机值。</li><li>自定义类型成员会自动调用其默认构造函数。</li></ul><p>通过合理设计构造函数，可以确保对象在创建时处于有效的初始状态。（在 C++11 及更高版本中，编译器还会生成 <strong>移动构造函数</strong> 和 <strong>移动赋值运算符</strong>，用于优化资源管理。这些函数允许对象在移动语义下高效地转移资源，而不是进行拷贝。例如，移动构造函数可以将一个临时对象的资源直接转移给新对象，避免不必要的拷贝操作。这些内容将在后续章节中详细介绍。）</p></blockquote><h3 id="2-1-无参构造函数（默认构造函数）"><a href="#2-1-无参构造函数（默认构造函数）" class="headerlink" title="2.1. 无参构造函数（默认构造函数）"></a>2.1. 无参构造函数（默认构造函数）</h3><p>没有参数，创建对象时会被默认调用。</p><ul><li>如果用户没有定义任何构造函数，编译器会生成一个无参构造函数。</li><li>一旦用户定义了任何构造函数，编译器将不再生成。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Date</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        year = <span class="number">2025</span>;</span><br><span class="line">        month = <span class="number">1</span>;</span><br><span class="line">        day = <span class="number">1</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;无参构造函数被调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; year &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; month &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; day &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> year, month, day;<span class="comment">// 私有成员变量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Date d;  <span class="comment">// 调用无参构造函数，注意：如果通过无参构造函数创建对象时，对象后面不用跟括号，否则就成了函数声明</span></span><br><span class="line">    d.<span class="built_in">Print</span>();  <span class="comment">// 输出：2025-1-1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-带参构造函数"><a href="#2-2-带参构造函数" class="headerlink" title="2.2 带参构造函数"></a>2.2 带参构造函数</h3><p>可接受参数，并根据用户输入初始化对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Date</span>(<span class="type">int</span> y, <span class="type">int</span> m, <span class="type">int</span> d)</span><br><span class="line">        : <span class="built_in">year</span>(y), </span><br><span class="line">    <span class="built_in">month</span>(m), </span><br><span class="line">    <span class="built_in">day</span>(d)</span><br><span class="line">        &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 如果只定义了带参构造函数，编译器不会生成默认无参构造函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123; cout &lt;&lt; year &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; month &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; day &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> year, month, day;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Date <span class="title">d</span><span class="params">(<span class="number">2025</span>, <span class="number">1</span>, <span class="number">1</span>)</span></span>; <span class="comment">// 正常调用</span></span><br><span class="line">    <span class="comment">// Date d2; // 错误：没有默认无参构造函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h2 id="传道解惑：-1"><a href="#传道解惑：-1" class="headerlink" title="传道解惑："></a>传道解惑：</h2><h3 id="Q1：公有（public）私有（private）部分的关系："><a href="#Q1：公有（public）私有（private）部分的关系：" class="headerlink" title="Q1：公有（public）私有（private）部分的关系："></a>Q1：公有（public）私有（private）部分的关系：</h3><p>在 C++ 中，类的成员（变量和函数）可以被指定为 <strong>公有（public）</strong> 或 <strong>私有（private）</strong>，这些访问控制符决定了成员的访问权限。接下来，我会详细讲解 <strong>公有部分</strong> 和 <strong>私有部分</strong> 的作用和关系。</p><p><strong>公有部分（public）</strong></p><ul><li><strong>访问权限：</strong> 任何外部代码（比如 <code>main()</code> 函数）都可以直接访问和修改公有成员。简单来说，<strong>公有部分</strong> 的成员对外部可见。</li><li><strong>适用场景：</strong> 一般情况下，我们会将类中的 <strong>接口函数</strong> 或 <strong>需要外部访问的数据</strong> 声明为公有，以便外部能够与对象交互。</li></ul><p><strong>私有部分（private）</strong></p><ul><li><strong>访问权限：</strong> 私有成员 <strong>只能在类内部的成员函数中访问</strong>，外部的代码无法直接访问或修改这些成员。<strong>私有部分</strong> 用于隐藏类的内部实现细节，只允许通过公有的接口与外部交互。</li><li><strong>适用场景：</strong> 私有成员通常是 <strong>类的内部数据</strong>，这些数据不希望被外部代码随意修改。通过这种方式，我们可以控制数据的访问权限和保证数据的正确性（通过公有函数进行访问或修改）。</li></ul><p><strong>关系</strong></p><ul><li><strong>数据封装（Encapsulation）：</strong> 这就是面向对象编程的核心之一，即将数据和操作数据的代码封装在一起。私有成员数据保护了对象的内部状态，避免了外部对数据的不恰当修改。公有函数则为外部提供了访问和修改数据的接口。</li><li><strong>分离接口与实现：</strong> 通过将接口函数（如 <code>Print()</code>）放在公有部分，类的使用者只需关心接口如何使用，而不需要知道具体的实现方式。私有部分负责实现细节，公有部分提供与外界的交互。</li><li><strong>保护：</strong> 私有成员提供类的内部实现，而公有成员则提供与外部的交互接口。这种设计有助于 <strong>封装</strong> 和 <strong>数据保护</strong>，确保类的使用者不破坏对象的状态。</li></ul><hr><h3 id="Q2：私有变量是否必须在公有部分出现？"><a href="#Q2：私有变量是否必须在公有部分出现？" class="headerlink" title="Q2：私有变量是否必须在公有部分出现？"></a>Q2：私有变量是否必须在公有部分出现？</h3><p><strong>不需要。</strong></p><p>类中的私有变量 (<code>private</code>) 是可以仅供类内部使用的，它们不一定需要通过公有部分 (<code>public</code>) 暴露出来。私有成员通常是不公开给外部的，所以是非必须出现在公有部分的。实际上，<strong>类的设计应该遵循数据隐藏原则</strong>：即只有通过公有函数，外部才能间接地访问或修改私有数据。这样能保护数据的完整性，避免外部代码直接改变私有数据。如果你希望外部能够访问和操作这些私有变量，通常会提供一些公有方法（如 <code>getter</code> 和 <code>setter</code>）来间接操作它们，但这不是强制的。</p><h3 id="Q3：关于编译器生成的默认成员函数，在不实现构造函数的情况下，编译器会生成默认的构造函数。但是看起来默认构造函数又没什么用？对象调用了编译器生成的默认构造函数，但是对象里依旧是随机值。也就是说，在这里编译器生成的默认构造函数并没有什么用？"><a href="#Q3：关于编译器生成的默认成员函数，在不实现构造函数的情况下，编译器会生成默认的构造函数。但是看起来默认构造函数又没什么用？对象调用了编译器生成的默认构造函数，但是对象里依旧是随机值。也就是说，在这里编译器生成的默认构造函数并没有什么用？" class="headerlink" title="Q3：关于编译器生成的默认成员函数，在不实现构造函数的情况下，编译器会生成默认的构造函数。但是看起来默认构造函数又没什么用？对象调用了编译器生成的默认构造函数，但是对象里依旧是随机值。也就是说，在这里编译器生成的默认构造函数并没有什么用？"></a>Q3：关于编译器生成的默认成员函数，在不实现构造函数的情况下，编译器会生成默认的构造函数。但是看起来默认构造函数又没什么用？对象调用了编译器生成的默认构造函数，但是对象里依旧是随机值。也就是说，在这里编译器生成的默认构造函数并没有什么用？</h3><p>解答：C++把类型分成内置类型(基本类型)和自定义类型。内置类型就是语言提供的数据类型，如：<code>int/char...</code>，自定义类型就是我们使用 <code>class/struct/union</code> 等自己定义的类型，编译器生成默认的构造函数会对自定义类型成员调用的它的默认成员函数。<strong>即编译器生成的默认构造函数在类的成员变量是自定义类型（非内置类型）时，会自动调用这些自定义类型的默认构造函数。这是 C++ 的一个机制，用于确保对象的每个成员都得到正确的初始化。</strong></p><p><strong>具体解释</strong></p><ol><li><strong>内置类型（如 <code>int</code>、<code>float</code> 等）：</strong></li></ol><ul><li><p>编译器生成的默认构造函数不会对内置类型成员进行初始化，这些成员会是随机值。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x; <span class="comment">// 内置类型成员</span></span><br><span class="line">&#125;;</span><br><span class="line">                                        </span><br><span class="line">MyClass obj; <span class="comment">// 编译器生成的默认构造函数不会初始化 x</span></span><br><span class="line">cout &lt;&lt; obj.x; <span class="comment">// 随机值</span></span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li><strong>自定义类型（如 <code>class</code> 或 <code>struct</code>）：</strong></li></ol><ul><li><p>如果类中包含自定义类型的成员变量，编译器生成的默认构造函数会自动调用这些成员的默认构造函数，以初始化它们。</p></li><li><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Inner</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Inner</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Inner 的默认构造函数被调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Inner innerMember; <span class="comment">// 自定义类型成员</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Outer obj; <span class="comment">// 自动调用编译器生成的默认构造函数</span></span><br><span class="line"></span><br><span class="line">输出：Inner 的默认构造函数被调用</span><br></pre></td></tr></table></figure></li><li><p>在这个例子中，<code>Outer</code> 类没有显式定义构造函数，但编译器生成了一个默认构造函数。而这个默认构造函数在初始化 <code>innerMember</code> 时，自动调用了 <code>Inner</code> 类的默认构造函数。</p></li></ul><p><strong>为什么这样设计？</strong></p><ul><li>自定义类型的对象可能需要复杂的初始化工作，比如为动态分配内存、初始化状态等。默认构造函数确保这些工作在创建对象时正确完成。</li><li>内置类型如 <code>int</code>、<code>float</code> 等通常不需要调用构造函数，默认值可以通过 C++11 中的默认值赋予。</li></ul><p>当类中有自定义类型的成员变量时：</p><ol><li>如果没有显式定义构造函数，编译器会生成一个默认构造函数。</li><li>这个默认构造函数会对 <strong>自定义类型成员变量</strong> 调用它们自己的默认构造函数，确保它们被正确初始化。</li></ol><p>这意味着你无需手动初始化这些成员，自定义类型的构造函数会自动运行完成初始化工作。</p></blockquote><hr><h2 id="3-析构函数"><a href="#3-析构函数" class="headerlink" title="3. 析构函数"></a>3. 析构函数</h2><p>析构函数：与构造函数功能相反，析构函数不是完成对对象本身的销毁，局部对象销毁工作是由编译器完成的。而 <strong>对象在销毁时会自动调用析构函数，完成对象中资源的清理工作</strong>。即用于释放资源。</p><p>析构函数是 C++中的一个特殊成员函数，专门用于对象生命周期结束时释放资源。以下是对上述特征的通俗易懂的解释：</p><blockquote><h3 id="3-1-析构函数的-6-个特征："><a href="#3-1-析构函数的-6-个特征：" class="headerlink" title="3.1 析构函数的 6 个特征："></a>3.1 析构函数的 <code>6</code> 个特征：</h3><h4 id="1-析构函数的命名规则：类名前加字符"><a href="#1-析构函数的命名规则：类名前加字符" class="headerlink" title="1. 析构函数的命名规则：类名前加字符 ~"></a>1. 析构函数的命名规则：类名前加字符 <code>~</code></h4><p>析构函数的名字和类名类似，但前面加了一个波浪号 <code>~</code>，它是 C++的规定，用来显式区分析构函数。比如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&gt;&#123;</span><br><span class="line">&gt;<span class="keyword">public</span>:</span><br><span class="line">   ~<span class="built_in">MyClass</span>()</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="comment">// 析构代码</span></span><br><span class="line">   &#125;</span><br><span class="line">&gt;&#125;;</span><br></pre></td></tr></table></figure><h4 id="2-无参数、无返回值类型"><a href="#2-无参数、无返回值类型" class="headerlink" title="2. 无参数、无返回值类型"></a>2. 无参数、无返回值类型</h4><p>析构函数不接受任何参数，也不能返回任何值。它的作用是清理资源，而不是用来进行复杂的逻辑处理，因此不需要参数或返回值。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;~<span class="built_in">MyClass</span>(); <span class="comment">// 不允许带参数或返回值</span></span><br></pre></td></tr></table></figure><h4 id="3-一个类只能有一个析构函数，且不能重载"><a href="#3-一个类只能有一个析构函数，且不能重载" class="headerlink" title="3. 一个类只能有一个析构函数，且不能重载"></a>3. 一个类只能有一个析构函数，且不能重载</h4><p>析构函数唯一且不能有多个版本。C++编译器在编译时，知道如何自动调用析构函数，因此多版本没有意义。</p><h4 id="4-对象生命周期结束时，自动调用析构函数"><a href="#4-对象生命周期结束时，自动调用析构函数" class="headerlink" title="4. 对象生命周期结束时，自动调用析构函数"></a>4. 对象生命周期结束时，自动调用析构函数</h4><p>当一个对象不再需要时（如超出作用域、程序结束或显式删除时），C++编译器会自动调用析构函数，无需手动调用。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&#123;</span><br><span class="line">   MyClass obj; <span class="comment">// 创建对象，调用构造函数</span></span><br><span class="line">&gt;&#125; <span class="comment">// 作用域结束，析构函数自动调用</span></span><br></pre></td></tr></table></figure><p>如果对象是动态分配的，用 <code>delete</code> 释放时也会调用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;MyClass* p = <span class="keyword">new</span> <span class="built_in">MyClass</span>(); <span class="comment">// 动态创建对象</span></span><br><span class="line">&gt;<span class="keyword">delete</span> p; <span class="comment">// 自动调用析构函数</span></span><br></pre></td></tr></table></figure><h4 id="5-默认析构函数：处理类中自定义类型成员的析构"><a href="#5-默认析构函数：处理类中自定义类型成员的析构" class="headerlink" title="5. 默认析构函数：处理类中自定义类型成员的析构"></a>5. 默认析构函数：处理类中自定义类型成员的析构</h4><p>如果没有显式定义析构函数，编译器会生成一个 <strong>默认析构函数</strong>。它会对类中所有非基本类型的成员调用其析构函数，比如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&gt;&#123;</span><br><span class="line">   std::string str; <span class="comment">// 自定义类型成员</span></span><br><span class="line">&gt;&#125;;</span><br></pre></td></tr></table></figure><p>编译器生成的默认析构函数会自动调用 <code>std::string</code> 的析构函数，释放其内部的资源。</p><h4 id="6-没有资源时可以不写，有资源时必须写"><a href="#6-没有资源时可以不写，有资源时必须写" class="headerlink" title="6. 没有资源时可以不写，有资源时必须写"></a>6. 没有资源时可以不写，有资源时必须写</h4><ul><li><strong>没有资源</strong>：如果类中没有动态分配的资源，直接使用编译器生成的默认析构函数即可，在这种情况下，系统生成的默认析构函数已经足够。比如：</li></ul> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> year, month, day; <span class="comment">// 无动态资源</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>有资源</strong>：如果类中有动态分配的资源（如 <code>new</code> 申请的内存），一定要定义析构函数，手动释放这些资源，否则会造成 <strong>内存泄漏</strong>：</li></ul> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span>* arr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Stack</span>(<span class="type">int</span> size)</span><br><span class="line">    &#123;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="type">int</span>[size]; <span class="comment">// 动态分配内存</span></span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Stack</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] arr; <span class="comment">// 释放内存，避免泄漏</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>析构函数的核心作用是 <strong>清理资源</strong>，尤其是在有动态分配资源的情况下。如果没有动态资源，则可以省略不写。C++的编译器会在合适的时候自动调用析构函数，无需我们手动干预。<strong>记住</strong>：如果忘记写析构函数释放资源，程序可能会导致 <strong>内存泄漏</strong>，尤其是当类中包含动态内存时！</p></blockquote><blockquote><h3 id="3-2-示例："><a href="#3-2-示例：" class="headerlink" title="3.2 示例："></a>3.2 示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">&gt;<span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">Example</span></span><br><span class="line">&gt;&#123;</span><br><span class="line">&gt;<span class="keyword">public</span>:</span><br><span class="line">       <span class="built_in">Example</span>()</span><br><span class="line">       &#123;</span><br><span class="line">           cout &lt;&lt; <span class="string">&quot;构造函数被调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       ~<span class="built_in">Example</span>()</span><br><span class="line">       &#123;</span><br><span class="line">           cout &lt;&lt; <span class="string">&quot;析构函数被调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">       &#125;</span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">&gt;</span>&#123;</span><br><span class="line">       Example e;  <span class="comment">// 创建对象时调用构造函数</span></span><br><span class="line">       <span class="comment">// 程序结束时，e 被销毁，析构函数自动调用</span></span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;构造函数被调用</span><br><span class="line">&gt;析构函数被调用</span><br></pre></td></tr></table></figure></blockquote><h2 id="4-拷贝构造函数"><a href="#4-拷贝构造函数" class="headerlink" title="4. 拷贝构造函数"></a>4. 拷贝构造函数</h2><p>拷贝构造函数是 C++ 中的一个特殊构造函数，用于 <strong>通过已有对象初始化一个新对象</strong>（创建一个与已有对象内容完全相同的新对象）。</p><blockquote><h2 id="4-1-拷贝构造函数的-5-个特征："><a href="#4-1-拷贝构造函数的-5-个特征：" class="headerlink" title="4.1 拷贝构造函数的 5 个特征："></a>4.1 拷贝构造函数的 <code>5</code> 个特征：</h2><h4 id="1-拷贝构造函数是构造函数的一个重载形式"><a href="#1-拷贝构造函数是构造函数的一个重载形式" class="headerlink" title="1. 拷贝构造函数是构造函数的一个重载形式"></a>1. 拷贝构造函数是构造函数的一个重载形式</h4><ul><li><p>拷贝构造函数和普通构造函数一样是初始化对象的，但它专门用于用 <strong>另一个对象</strong> 初始化当前对象。</p></li><li><p>它是构造函数的一种重载形式，形式如下：</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&gt;&#123;</span><br><span class="line">&gt;<span class="keyword">public</span>:</span><br><span class="line">   <span class="built_in">MyClass</span>(<span class="type">const</span> MyClass&amp; obj); <span class="comment">// 拷贝构造函数声明</span></span><br><span class="line">&gt;&#125;;</span><br></pre></td></tr></table></figure><ul><li>注意：拷贝构造函数的名字和类名一样，只是参数是当前类对象的引用。</li></ul><h4 id="2-参数必须是类类型的引用"><a href="#2-参数必须是类类型的引用" class="headerlink" title="2. 参数必须是类类型的引用"></a>2. 参数必须是类类型的引用</h4><ul><li>拷贝构造函数的参数只能是 <strong>类类型的引用</strong>，不能用 <strong>值传递</strong>，否则会导致编译器报错或发生死循环：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="built_in">MyClass</span>(<span class="type">const</span> MyClass obj); <span class="comment">// 错误，值传递会导致递归调用</span></span><br></pre></td></tr></table></figure><ul><li>这是因为：</li></ul><ol><li>如果参数使用值传递（<code>MyClass obj</code>），在传递参数时会调用拷贝构造函数。</li><li>拷贝构造函数又会调用自己，导致无限递归，最终栈溢出。</li></ol><ul><li>正确形式：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="built_in">MyClass</span>(<span class="type">const</span> MyClass&amp; obj); <span class="comment">// 使用引用，避免递归</span></span><br></pre></td></tr></table></figure><h4 id="3-默认拷贝构造函数"><a href="#3-默认拷贝构造函数" class="headerlink" title="3. 默认拷贝构造函数"></a>3. 默认拷贝构造函数</h4><ul><li>如果用户没有显式定义拷贝构造函数，<strong>编译器会自动生成一个默认的拷贝构造函数</strong>。</li><li>默认拷贝构造函数会逐字节拷贝对象的成员变量，这种拷贝被称为 <strong>浅拷贝</strong>。</li></ul><p><strong>浅拷贝的含义：</strong></p><ul><li>对于 <strong>内置类型</strong>（如 <code>int</code>、<code>float</code>），直接复制值。</li><li>对于 <strong>自定义类型</strong> 成员，编译器会调用这些成员自己的拷贝构造函数。</li><li>例子：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">&gt;<span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&gt;&#123;</span><br><span class="line">&gt;<span class="keyword">public</span>:</span><br><span class="line">   <span class="type">int</span> a;</span><br><span class="line">   <span class="type">int</span>* p;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">MyClass</span>() : <span class="built_in">a</span>(<span class="number">0</span>), <span class="built_in">p</span>(<span class="literal">nullptr</span>) &#123;&#125;<span class="comment">// 默认构造函数</span></span><br><span class="line">   <span class="built_in">MyClass</span>(<span class="type">const</span> MyClass&amp; other) : <span class="built_in">a</span>(other.a), <span class="built_in">p</span>(other.p) &#123;&#125;<span class="comment">// 拷贝构造函数（浅拷贝）</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 析构函数，用于释放动态分配的内存</span></span><br><span class="line">   ~<span class="built_in">MyClass</span>()</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">if</span> (p != <span class="literal">nullptr</span>)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">delete</span> p;<span class="comment">// 如果 p 指向动态分配的内存，释放它</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">&gt;</span>&#123;</span><br><span class="line">   MyClass obj1;</span><br><span class="line">   obj<span class="number">1.</span>a = <span class="number">10</span>;</span><br><span class="line">   obj<span class="number">1.</span>p = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">20</span>); <span class="comment">// 动态分配内存</span></span><br><span class="line"></span><br><span class="line">   MyClass obj2 = obj1; <span class="comment">// 浅拷贝：obj2 会与 obj1 共享相同的指针 p</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 输出 obj1 和 obj2 的值</span></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;obj1.a = &quot;</span> &lt;&lt; obj<span class="number">1.</span>a &lt;&lt; <span class="string">&quot;, obj1.p = &quot;</span> &lt;&lt; *obj<span class="number">1.</span>p &lt;&lt; endl;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;obj2.a = &quot;</span> &lt;&lt; obj<span class="number">2.</span>a &lt;&lt; <span class="string">&quot;, obj2.p = &quot;</span> &lt;&lt; *obj<span class="number">2.</span>p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 手动释放 obj1 的动态内存</span></span><br><span class="line">   <span class="keyword">delete</span> obj<span class="number">1.</span>p;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 现在 obj2.p 是悬空指针，访问它会导致未定义行为</span></span><br><span class="line">   <span class="comment">// cout &lt;&lt; &quot;obj2.p after obj1.delete: &quot; &lt;&lt; *obj2.p &lt;&lt; endl; // 危险！</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p><strong>问题</strong>：如果类中有指针等动态资源，浅拷贝会导致问题。比如 <code>obj1.p</code> 和 <code>obj2.p</code> 指向同一块内存，释放时可能导致重复释放（<strong>悬空指针</strong>）。</p><h4 id="4-是否需要显式定义拷贝构造函数？"><a href="#4-是否需要显式定义拷贝构造函数？" class="headerlink" title="4. 是否需要显式定义拷贝构造函数？"></a>4. 是否需要显式定义拷贝构造函数？</h4><ul><li><p><strong>没有动态资源时（不涉及指针或资源申请）：</strong> 编译器生成的默认拷贝构造函数已经可以正常工作，可以不写。</p></li><li><p><strong>有动态资源时（涉及指针或资源申请）：</strong> 必须显式定义拷贝构造函数，完成深拷贝，避免内存管理问题。</p></li><li><p><strong>深拷贝的实现：</strong> 深拷贝指的是重新分配内存，并复制内容，而不是直接复制指针地址：</p></li></ul> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span>* p;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自定义拷贝构造函数</span></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">const</span> MyClass&amp; obj)</span><br><span class="line">    &#123;</span><br><span class="line">        a = obj.a;</span><br><span class="line">        p = <span class="keyword">new</span> <span class="built_in">int</span>(*obj.p); <span class="comment">// 深拷贝，重新分配内存</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">MyClass</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> p;  <span class="comment">// 释放动态资源</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="5-拷贝构造函数的典型调用场景"><a href="#5-拷贝构造函数的典型调用场景" class="headerlink" title="5. 拷贝构造函数的典型调用场景"></a>5. 拷贝构造函数的典型调用场景</h4><ul><li><strong>场景 1：使用已有对象创建新对象</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;MyClass obj1;       <span class="comment">// 普通构造函数</span></span><br><span class="line">&gt;MyClass obj2 = obj1; <span class="comment">// 拷贝构造函数</span></span><br></pre></td></tr></table></figure><ul><li><strong>场景 2：函数参数为类类型对象</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(MyClass obj)</span></span>; <span class="comment">// 如果不使用引用，会调用拷贝构造函数</span></span><br></pre></td></tr></table></figure><ul><li><strong>场景 3：函数返回类类型对象</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="function">MyClass <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">&gt;</span>&#123;</span><br><span class="line">   MyClass obj;</span><br><span class="line">   <span class="keyword">return</span> obj; <span class="comment">// 返回时可能调用拷贝构造函数</span></span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><h4 id="提高效率的建议"><a href="#提高效率的建议" class="headerlink" title="提高效率的建议"></a>提高效率的建议</h4><ol><li><strong>传参时使用引用</strong>：避免拷贝对象的开销。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">const</span> MyClass&amp; obj)</span></span>; <span class="comment">// 使用引用，不调用拷贝构造函数</span></span><br></pre></td></tr></table></figure><ol start="2"><li><strong>返回值优化（C++11 的移动语义）：</strong> 对于返回值尽量结合移动构造函数使用，减少不必要的拷贝。</li></ol><p><strong>综上：</strong></p><ul><li>拷贝构造函数是用已有对象初始化新对象的工具。</li><li>编译器默认的拷贝构造函数使用浅拷贝，只能处理简单类（没有动态资源）。</li><li>对于涉及动态资源的类，必须显式定义拷贝构造函数，确保深拷贝，避免内存泄漏或重复释放。</li></ul></blockquote><h3 id="4-2-默认拷贝构造函数"><a href="#4-2-默认拷贝构造函数" class="headerlink" title="4.2 默认拷贝构造函数"></a>4.2 默认拷贝构造函数</h3><p>编译器默认会生成一个浅拷贝版本：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Date</span>(<span class="type">int</span> y, <span class="type">int</span> m, <span class="type">int</span> d) : <span class="built_in">year</span>(y), <span class="built_in">month</span>(m), <span class="built_in">day</span>(d) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123; cout &lt;&lt; year &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; month &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; day &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> year, month, day;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Date <span class="title">d1</span><span class="params">(<span class="number">2025</span>, <span class="number">1</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">    Date d2 = d1;  <span class="comment">// 调用默认拷贝构造函数</span></span><br><span class="line">    d<span class="number">2.</span><span class="built_in">Print</span>();  <span class="comment">// 输出：2025-1-1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-自定义拷贝构造函数"><a href="#4-3-自定义拷贝构造函数" class="headerlink" title="4.3 自定义拷贝构造函数"></a>4.3 自定义拷贝构造函数</h3><p>当对象包含动态资源时，必须显式定义深拷贝逻辑。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Example</span>(<span class="type">int</span> size)</span><br><span class="line">    &#123;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="type">int</span>[size];</span><br><span class="line">        <span class="keyword">this</span>-&gt;size = size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自定义拷贝构造函数</span></span><br><span class="line">    <span class="built_in">Example</span>(<span class="type">const</span> Example&amp; other)</span><br><span class="line">    &#123;</span><br><span class="line">        size = other.size;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="type">int</span>[size];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            arr[i] = other.arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Example</span>() &#123; <span class="keyword">delete</span>[] arr; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span>* arr;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="5-赋值运算符重载"><a href="#5-赋值运算符重载" class="headerlink" title="5. 赋值运算符重载"></a>5. 赋值运算符重载</h2><blockquote><p>C++ 中的 <strong>运算符重载</strong> 允许我们为类或对象定义新的运算符行为，使代码更直观和可读。</p><h2 id="5-1-对运算符重载关键点解释："><a href="#5-1-对运算符重载关键点解释：" class="headerlink" title="5.1 对运算符重载关键点解释："></a>5.1 对运算符重载关键点解释：</h2><h4 id="1-运算符重载的本质"><a href="#1-运算符重载的本质" class="headerlink" title="1. 运算符重载的本质"></a>1. 运算符重载的本质</h4><ul><li><p>运算符重载是通过定义一个特殊的函数，改变运算符对类对象的行为。</p></li><li><p><strong>函数名称：</strong> <code>operator</code> 后接具体运算符。例如：<code>operator+</code> 是用来重载加法运算符的函数。</p></li><li><p><strong>函数原型：</strong></p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;返回值类型 <span class="keyword">operator</span>操作符(参数列表);</span><br></pre></td></tr></table></figure><ul><li>例子：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&gt;&#123;</span><br><span class="line">&gt;<span class="keyword">public</span>:</span><br><span class="line">   MyClass <span class="keyword">operator</span>+(<span class="type">const</span> MyClass&amp; obj);</span><br><span class="line">&gt;&#125;;</span><br></pre></td></tr></table></figure><h4 id="2-运算符重载规则"><a href="#2-运算符重载规则" class="headerlink" title="2. 运算符重载规则"></a>2. 运算符重载规则</h4><ul><li><strong>不能创建新的运算符：</strong> 只能重载已有运算符，不能重载不存在的符号（如 <code>operator@</code> 是非法的）。</li><li><strong>内置类型的运算符不能改变其含义：</strong> 例如整数相加（<code>3 + 5</code>）的行为不能被改变。</li><li><strong>某些运算符不能被重载：</strong> <code>.</code>, <code>.*</code>, <code>::</code>, <code>sizeof</code>, <code>?:</code> 不能被重载。</li><li><strong>至少有一个操作数是类类型：</strong> 不能对完全是内置类型的运算符重载，比如试图重载 <code>int + int</code>。</li></ul><h4 id="3-成员函数-vs-全局函数重载"><a href="#3-成员函数-vs-全局函数重载" class="headerlink" title="3. 成员函数 vs 全局函数重载"></a>3. 成员函数 vs 全局函数重载</h4><ul><li>运算符重载可以是类的 <strong>成员函数</strong> 或 <strong>全局函数</strong>。</li><li><strong>成员函数重载：</strong> 第一个操作数是当前对象，编译器会将操作数传递给隐藏的 <code>this</code> 指针。</li><li><strong>全局函数重载：</strong> 需要将两个操作数都作为参数传递。</li><li><strong>注意：赋值运算符重载（<code>operator=</code>）必须是成员函数，不能是全局函数。</strong></li></ul><h4 id="4-常见运算符重载的实现"><a href="#4-常见运算符重载的实现" class="headerlink" title="4. 常见运算符重载的实现"></a>4. 常见运算符重载的实现</h4><hr><h4 id="赋值运算符重载（operator-）"><a href="#赋值运算符重载（operator-）" class="headerlink" title="赋值运算符重载（operator=）"></a>赋值运算符重载（<code>operator=</code>）</h4><p><strong>特点：</strong></p><ol><li><strong>参数类型：</strong> <code>const T&amp;</code>，避免不必要的拷贝，传引用效率更高。</li><li><strong>返回值类型：</strong> <code>T&amp;</code>，返回对象的引用支持连续赋值（如 <code>a = b = c</code>）。</li><li><strong>检测自赋值：</strong> 检查是否给自己赋值（<code>if (this == &amp;obj)</code>）。</li></ol><ul><li>自赋值检查非常重要，因为如果不检查自赋值，可能会导致资源被错误释放或重复释放。例如，如果 <code>this == &amp;obj</code>，则 <code>delete data;</code> 会释放当前对象的资源，导致后续操作无法正确执行。</li></ul><ol start="4"><li><strong>返回 <code>*this</code>：</strong> 让赋值语句返回当前对象。</li></ol><p><strong>实现：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&gt;&#123;</span><br><span class="line">&gt;<span class="keyword">public</span>:</span><br><span class="line"> <span class="type">int</span>* data;</span><br><span class="line"></span><br><span class="line"> MyClass&amp; <span class="keyword">operator</span>=(<span class="type">const</span> MyClass&amp; obj)</span><br><span class="line"> &#123;</span><br><span class="line">     <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;obj) <span class="comment">// 检测是否自赋值</span></span><br><span class="line">     &#123;</span><br><span class="line">         <span class="keyword">delete</span> data;    <span class="comment">// 释放已有资源</span></span><br><span class="line">         data = <span class="keyword">new</span> <span class="built_in">int</span>(*obj.data); <span class="comment">// 深拷贝，避免共享指针导致问题</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">// 返回当前对象的引用</span></span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;;</span><br></pre></td></tr></table></figure><hr><h4 id="前置-和-后置-重载"><a href="#前置-和-后置-重载" class="headerlink" title="前置++ 和 后置++ 重载"></a>前置++ 和 后置++ 重载</h4><ul><li><strong>前置++（<code>++obj</code>）：</strong> 返回增加后的值。</li><li><strong>后置++（<code>obj++</code>）：</strong> 返回增加前的旧值，调用时会多传一个 <code>int</code> 参数（编译器自动处理）。</li></ul><p><strong>实现：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&gt;&#123;</span><br><span class="line">&gt;<span class="keyword">public</span>:</span><br><span class="line"> <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 前置++，返回引用</span></span><br><span class="line"> MyClass&amp; <span class="keyword">operator</span>++()</span><br><span class="line"> &#123;</span><br><span class="line">     ++value; <span class="comment">// 自增</span></span><br><span class="line">     <span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">// 返回当前对象</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 后置++，返回值</span></span><br><span class="line"> MyClass <span class="keyword">operator</span>++(<span class="type">int</span>)</span><br><span class="line"> &#123;</span><br><span class="line">     MyClass temp = *<span class="keyword">this</span>; <span class="comment">// 保存当前对象</span></span><br><span class="line">     ++value;              <span class="comment">// 自增</span></span><br><span class="line">     <span class="keyword">return</span> temp;          <span class="comment">// 返回旧值</span></span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;;</span><br></pre></td></tr></table></figure><hr><h4 id="加法运算符重载（operator-）"><a href="#加法运算符重载（operator-）" class="headerlink" title="加法运算符重载（operator+）"></a>加法运算符重载（<code>operator+</code>）</h4><p>加法运算符重载支持对象间的相加操作。</p><p><strong>实现：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&gt;&#123;</span><br><span class="line">&gt;<span class="keyword">public</span>:</span><br><span class="line"> <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 重载加法运算符</span></span><br><span class="line"> MyClass <span class="keyword">operator</span>+(<span class="type">const</span> MyClass&amp; obj) <span class="type">const</span></span><br><span class="line"> &#123;</span><br><span class="line">     MyClass result;</span><br><span class="line">     result.value = <span class="keyword">this</span>-&gt;value + obj.value; <span class="comment">// 两个对象相加</span></span><br><span class="line">     <span class="keyword">return</span> result;</span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;;</span><br></pre></td></tr></table></figure><hr><h4 id="5-默认运算符重载-vs-自定义实现"><a href="#5-默认运算符重载-vs-自定义实现" class="headerlink" title="5. 默认运算符重载 vs 自定义实现"></a>5. 默认运算符重载 vs 自定义实现</h4><p><strong>默认行为：</strong></p><ul><li>如果不显式实现赋值运算符（<code>operator=</code>）或拷贝构造函数（<code>operator=</code>），编译器会生成默认版本，逐字节拷贝。</li><li>默认行为对于 <strong>内置类型</strong>（如 <code>int</code>、<code>char</code>）完全适用。</li><li>对于 <strong>动态资源</strong>（如指针），默认行为可能导致 <strong>浅拷贝</strong> 问题（资源共享导致重复释放或悬空指针）。</li></ul><p><strong>是否需要自定义实现：</strong></p><ul><li>如果类中没有动态资源（如只包含内置类型或 STL 容器），默认生成的运算符重载就够用。</li><li>如果类中有动态资源（如指针），必须自定义运算符重载，确保深拷贝和正确释放资源。</li></ul><h4 id="6-为什么返回引用？"><a href="#6-为什么返回引用？" class="headerlink" title="6. 为什么返回引用？"></a>6. 为什么返回引用？</h4><ul><li><p>在运算符重载中，返回引用（<code>T&amp;</code>）有助于提高效率，并支持连续赋值操作（如 <code>a = b = c</code>）。</p></li><li><p>例如赋值运算符：</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;MyClass&amp; <span class="keyword">operator</span>=(<span class="type">const</span> MyClass&amp; obj)</span><br><span class="line">&gt;&#123;</span><br><span class="line">   <span class="comment">// 处理赋值逻辑</span></span><br><span class="line">   <span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">// 返回当前对象的引用</span></span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><ul><li>如果返回值而非引用，则每次赋值都会产生一个临时对象，效率低。</li></ul><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>运算符重载让类对象可以像内置类型一样进行操作，提升了代码的可读性。但以下几点需要注意：</p><ol><li>只有已有的运算符可以被重载，且至少有一个操作数是类类型。</li><li>对于有动态资源的类，必须重载运算符以避免浅拷贝问题。</li><li>返回引用是为了支持连续赋值和提高效率。</li><li>某些运算符不能被重载，比如 <code>.</code>、<code>::</code>、<code>sizeof</code> 和 <code>?:</code>。</li></ol><p>通过合理设计运算符重载，可以让类使用起来更像内置类型，从而写出更加优雅和简洁的代码。</p></blockquote><blockquote><h2 id="5-2-示例："><a href="#5-2-示例：" class="headerlink" title="5.2 示例："></a>5.2 示例：</h2><h4 id="1-默认实现"><a href="#1-默认实现" class="headerlink" title="1. 默认实现"></a>1. 默认实现</h4><p>编译器默认按字节拷贝，可能造成资源冲突。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">Date</span></span><br><span class="line">&gt;&#123;</span><br><span class="line">&gt;<span class="keyword">public</span>:</span><br><span class="line">   <span class="built_in">Date</span>(<span class="type">int</span> y, <span class="type">int</span> m, <span class="type">int</span> d) : <span class="built_in">year</span>(y), <span class="built_in">month</span>(m), <span class="built_in">day</span>(d) &#123;&#125;</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123; cout &lt;&lt; year &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; month &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; day &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> year, month, day;</span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">&gt;</span>&#123;</span><br><span class="line">   <span class="function">Date <span class="title">d1</span><span class="params">(<span class="number">2025</span>, <span class="number">1</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">   <span class="function">Date <span class="title">d2</span><span class="params">(<span class="number">2024</span>, <span class="number">12</span>, <span class="number">31</span>)</span></span>;</span><br><span class="line">   d2 = d1;  <span class="comment">// 调用默认赋值运算符</span></span><br><span class="line">   d<span class="number">2.</span><span class="built_in">Print</span>();  <span class="comment">// 输出：2025-1-1</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><h4 id="2-重载赋值运算符"><a href="#2-重载赋值运算符" class="headerlink" title="2. 重载赋值运算符"></a>2. 重载赋值运算符</h4><p>当对象管理动态资源时，需要自定义赋值运算符。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">Example</span></span><br><span class="line">&gt;&#123;</span><br><span class="line">&gt;<span class="keyword">public</span>:</span><br><span class="line">   <span class="built_in">Example</span>(<span class="type">int</span> size)</span><br><span class="line">   &#123;</span><br><span class="line">      arr = <span class="keyword">new</span> <span class="type">int</span>[size];</span><br><span class="line">      <span class="keyword">this</span>-&gt;size = size;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   Example&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Example&amp; other)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other)<span class="comment">// 防止自赋值</span></span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">delete</span>[] arr;</span><br><span class="line">          size = other.size;</span><br><span class="line">          arr = <span class="keyword">new</span> <span class="type">int</span>[size];</span><br><span class="line">          </span><br><span class="line">          <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">          &#123;</span><br><span class="line">              arr[i] = other.arr[i];</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">Example</span>() &#123; <span class="keyword">delete</span>[] arr; &#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">private</span>:</span><br><span class="line">   <span class="type">int</span>* arr;</span><br><span class="line">   <span class="type">int</span> size;</span><br><span class="line">&gt;&#125;;</span><br></pre></td></tr></table></figure><h4 id="重载"><a href="#重载" class="headerlink" title="重载 +"></a>重载 <code>+</code></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">Date</span></span><br><span class="line">&gt;&#123;</span><br><span class="line">&gt;<span class="keyword">public</span>:</span><br><span class="line">   <span class="built_in">Date</span>(<span class="type">int</span> y, <span class="type">int</span> m, <span class="type">int</span> d) : <span class="built_in">year</span>(y), <span class="built_in">month</span>(m), <span class="built_in">day</span>(d) &#123;&#125;</span><br><span class="line">   Date <span class="keyword">operator</span>+(<span class="type">int</span> days) &#123; <span class="keyword">return</span> <span class="built_in">Date</span>(year, month, day + days); &#125;</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123; cout &lt;&lt; year &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; month &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; day &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> year, month, day;</span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">&gt;</span>&#123;</span><br><span class="line">   <span class="function">Date <span class="title">d</span><span class="params">(<span class="number">2025</span>, <span class="number">1</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">   Date d2 = d + <span class="number">5</span>;  <span class="comment">// 日期加5天</span></span><br><span class="line">   d<span class="number">2.</span><span class="built_in">Print</span>();  <span class="comment">// 输出：2025-1-6</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><h4 id="重载-1"><a href="#重载-1" class="headerlink" title="重载 =="></a>重载 <code>==</code></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">Date</span></span><br><span class="line">&gt;&#123;</span><br><span class="line">&gt;<span class="keyword">public</span>:</span><br><span class="line">   <span class="built_in">Date</span>(<span class="type">int</span> y, <span class="type">int</span> m, <span class="type">int</span> d) : <span class="built_in">year</span>(y), <span class="built_in">month</span>(m), <span class="built_in">day</span>(d) &#123;&#125;</span><br><span class="line">   <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Date&amp; other)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">return</span> year == other.year &amp;&amp; month == other.month &amp;&amp; day == other.day;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> year, month, day;</span><br><span class="line">&gt;&#125;;</span><br></pre></td></tr></table></figure></blockquote><h2 id="6-const-成员"><a href="#6-const-成员" class="headerlink" title="6. const 成员"></a>6. <code>const</code> 成员</h2><p>将 <code>const</code> 修饰的“<strong>成员函数</strong>”称之为 <code>const</code> 成员函数，<code>const</code> 成员函数修饰了隐含的 <code>this</code> 指针为 <code>const</code> 类型（<code>const ClassName* this</code>），表示该函数不能修改类的成员变量。但可以通过 <code>mutable</code> 修饰的成员变量在 <code>const</code> 成员函数中进行修改。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Date</span>(<span class="type">int</span> year, <span class="type">int</span> month, <span class="type">int</span> day)</span><br><span class="line">    &#123;</span><br><span class="line">        _year = year;</span><br><span class="line">        _month = month;</span><br><span class="line">        _day = day;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Print()&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;year:&quot;</span> &lt;&lt; _year &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;month:&quot;</span> &lt;&lt; _month &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;day:&quot;</span> &lt;&lt; _day &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PrintConst</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Print(const)&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;year:&quot;</span> &lt;&lt; _year &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;month:&quot;</span> &lt;&lt; _month &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;day:&quot;</span> &lt;&lt; _day &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _year;   <span class="comment">// 年</span></span><br><span class="line">    <span class="type">int</span> _month;  <span class="comment">// 月</span></span><br><span class="line">    <span class="type">int</span> _day;    <span class="comment">// 日</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Date <span class="title">d1</span><span class="params">(<span class="number">2025</span>, <span class="number">1</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">    d<span class="number">1.</span><span class="built_in">Print</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">const</span> Date <span class="title">d2</span><span class="params">(<span class="number">2025</span>, <span class="number">1</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">    d<span class="number">2.</span><span class="built_in">Print</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让我们逐步理解上面代码：</p><ol><li>定义了两个 <code>Print</code> 函数：<ul><li><code>void Print()</code>：普通成员函数，允许修改对象。</li><li><code>void Print() const</code>：<code>const</code> 成员函数，不能修改对象。</li></ul></li><li><code>Test</code> 函数中：<ul><li><code>Date d1(2022, 1, 13);</code> 是普通对象，调用 <code>d1.Print()</code> 时，编译器会选择非 <code>const</code> 版本的 <code>Print()</code>。</li><li><code>const Date d2(2022, 1, 13);</code> 是 <code>const</code> 对象，调用 <code>d2.Print()</code> 时，编译器会选择 <code>const</code> 版本的 <code>Print()</code>。</li></ul></li></ol><h3 id="6-1-总结规则："><a href="#6-1-总结规则：" class="headerlink" title="6.1 总结规则："></a>6.1 总结规则：</h3><ol><li><strong>非 <code>const</code> 对象</strong>：<ul><li>可以调用普通成员函数。</li><li>可以调用 <code>const</code> 成员函数。</li></ul></li><li><strong><code>const</code> 对象</strong>：<ul><li>只能调用 <code>const</code> 成员函数。</li></ul></li><li><strong>普通成员函数</strong>：<ul><li>可以调用普通成员函数。</li><li>不能调用 <code>const</code> 成员函数。</li></ul></li><li><strong><code>const</code> 成员函数</strong>：<ul><li>不能调用普通成员函数。</li><li>可以调用 <code>const</code> 成员函数。</li></ul></li></ol><hr><h3 id="6-2-适用场景："><a href="#6-2-适用场景：" class="headerlink" title="6.2 适用场景："></a>6.2 适用场景：</h3><ul><li>当你希望某个成员函数不修改对象的任何成员变量时，应将其声明为 <code>const</code> 成员函数。</li><li>这样可以确保该函数在 <code>const</code> 对象上调用时不会破坏对象的不可变性。</li><li>例如，<code>Print()</code> 函数通常不需要修改对象状态，因此可以声明为 <code>const</code> 成员函数。</li></ul><hr><h3 id="6-3-关键知识点："><a href="#6-3-关键知识点：" class="headerlink" title="6.3 关键知识点："></a>6.3 关键知识点：</h3><ul><li><strong><code>const</code> 修饰的成员函数</strong>：会将隐含的 <code>this</code> 指针转换为 <code>const</code> 类型（<code>const ClassName* this</code>）。</li><li>编译器通过 <code>const</code> 限定符，保证不会在 <code>const</code> 成员函数中修改成员变量。</li><li>如果非 <code>const</code> 成员变量必须在 <code>const</code> 成员函数中被修改，可以使用 <code>mutable</code> 关键字修饰这些变量，使其在 <code>const</code> 上下文中也可变（但要谨慎使用）。</li></ul><hr><blockquote><h2 id="传道解惑：-2"><a href="#传道解惑：-2" class="headerlink" title="传道解惑："></a>传道解惑：</h2><h3 id="Q1：-const-对象可以调用非-const-成员函数吗？"><a href="#Q1：-const-对象可以调用非-const-成员函数吗？" class="headerlink" title="Q1： const 对象可以调用非 const 成员函数吗？"></a>Q1： <code>const</code> 对象可以调用非 <code>const</code> 成员函数吗？</h3><p><strong>不可以</strong>。</p><p><code>const</code> 对象意味着这个对象的任何成员都不能被修改。非 <code>const</code> 成员函数没有限制修改成员变量的行为，因此 <code>const</code> 对象无法调用非 <code>const</code> 成员函数，否则会破坏 <code>const</code> 对象的不变性。</p><p>在上面代码中，<code>const Date d2</code> 是一个 <code>const</code> 对象，只能调用 <code>Print(const)</code>，不能调用 <code>Print()</code>（非 <code>const</code> 成员函数）。编译器会通过检查 <code>const</code> 属性阻止这种调用。</p><hr><h3 id="Q2：const-对象可以调用-const-成员函数吗？"><a href="#Q2：const-对象可以调用-const-成员函数吗？" class="headerlink" title="Q2：const 对象可以调用 const 成员函数吗？"></a>Q2：<code>const</code> 对象可以调用 <code>const</code> 成员函数吗？</h3><p><strong>可以</strong>。</p><p><code>const</code> 成员函数会修饰 <code>this</code> 指针为 <code>const Date* this</code>，表示该函数内部不会修改类的成员变量。因此 <code>const</code> 对象可以调用 <code>const</code> 成员函数，因为这不会破坏 <code>const</code> 对象的不可变性。</p><p>在上面代码中，<code>d2.Print()</code> 调用的就是 <code>Print(const)</code>，因为 <code>Print(const)</code> 是 <code>const</code> 成员函数。</p><hr><h3 id="Q3：const-成员函数内可以调用其它的非-const-成员函数吗？"><a href="#Q3：const-成员函数内可以调用其它的非-const-成员函数吗？" class="headerlink" title="Q3：const 成员函数内可以调用其它的非 const 成员函数吗？"></a>Q3：<code>const</code> 成员函数内可以调用其它的非 <code>const</code> 成员函数吗？</h3><p><strong>不可以</strong>。</p><p>因为 <code>const</code> 成员函数的 <code>this</code> 指针是 <code>const</code> 的，即 <code>const Date* this</code>，表示它不能修改成员变量。而非 <code>const</code> 成员函数默认的 <code>this</code> 指针是 <code>Date* this</code>，允许修改成员变量。<br>因此，<code>const</code> 成员函数无法调用非 <code>const</code> 成员函数，因为这样可能导致间接修改成员变量，从而违反了 <code>const</code> 的约束。</p><hr><h3 id="Q4-const-成员函数内可以调用其它的-const-成员函数吗？"><a href="#Q4-const-成员函数内可以调用其它的-const-成员函数吗？" class="headerlink" title="Q4: const 成员函数内可以调用其它的 const 成员函数吗？"></a>Q4: <code>const</code> 成员函数内可以调用其它的 <code>const</code> 成员函数吗？</h3><p><strong>可以</strong>。</p><p><code>const</code> 成员函数的 <code>this</code> 指针是 <code>const</code> 的，调用其他 <code>const</code> 成员函数不会违反 <code>const</code> 的约束，因为 <code>const</code> 成员函数保证不修改成员变量。</p></blockquote><h2 id="7-取地址及-const-取地址操作符重载"><a href="#7-取地址及-const-取地址操作符重载" class="headerlink" title="7. 取地址及 const 取地址操作符重载"></a>7. 取地址及 <code>const</code> 取地址操作符重载</h2><p>在 C++中，取地址操作符 <code>&amp;</code> 不能被真正重载。但可以通过定义特殊的成员函数来改变其行为。这种实现方式类似于运算符重载，但并非真正的重载。结合 <code>const</code>，它的行为会更有针对性。（取地址操作符 <code>&amp;</code> 不能被重载的原因是，它是一个基础操作符，用于获取对象的地址。如果允许重载，可能会导致地址获取的语义混乱。）</p><h3 id="7-1-取地址操作符-默认行为"><a href="#7-1-取地址操作符-默认行为" class="headerlink" title="7.1 取地址操作符 &amp; 默认行为"></a>7.1 取地址操作符 <code>&amp;</code> 默认行为</h3><p>默认情况下，<code>&amp;</code> 操作符返回对象的内存地址。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>* px = &amp;x; <span class="comment">// px 获取了 x 的地址</span></span><br></pre></td></tr></table></figure><p>在类中，取地址操作符通常也可以被用来获取对象的地址。</p><h3 id="7-2-取地址操作符的重载"><a href="#7-2-取地址操作符的重载" class="headerlink" title="7.2 取地址操作符的重载"></a>7.2 取地址操作符的重载</h3><p>C++中无法重载取地址操作符 <code>&amp;</code>，但可以通过定义成员函数来改变其行为。例如通过返回自定义指针对象，而不是直接返回 <code>this</code>。重载时可以区分：</p><ol><li>普通对象的取地址。</li><li><code>const</code> 对象的取地址。</li></ol><h3 id="7-3-代码示例与解释"><a href="#7-3-代码示例与解释" class="headerlink" title="7.3 代码示例与解释"></a>7.3 代码示例与解释</h3><p>重载取地址操作符的代码，以下是一个简单示例，展示如何通过 <code>const</code> 和非 <code>const</code> 版本的重载来实现不同的行为。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> value) : _value(value) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非 const 版本的取地址操作符重载</span></span><br><span class="line">    MyClass* <span class="keyword">operator</span>&amp;()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;非 const 取地址操作符被调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// const 版本的取地址操作符重载</span></span><br><span class="line">    <span class="type">const</span> MyClass* <span class="keyword">operator</span>&amp;() <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;const 取地址操作符被调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Display</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; _value &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">MyClass <span class="title">obj</span><span class="params">(<span class="number">10</span>)</span></span>;            <span class="comment">// 普通对象</span></span><br><span class="line">    <span class="function"><span class="type">const</span> MyClass <span class="title">constObj</span><span class="params">(<span class="number">20</span>)</span></span>; <span class="comment">// const 对象</span></span><br><span class="line"></span><br><span class="line">    MyClass* addr1 = &amp;obj;          <span class="comment">// 调用非 const 版本的取地址操作符</span></span><br><span class="line">    <span class="type">const</span> MyClass* addr2 = &amp;constObj; <span class="comment">// 调用 const 版本的取地址操作符</span></span><br><span class="line"></span><br><span class="line">    addr1-&gt;<span class="built_in">Display</span>();</span><br><span class="line">    addr2-&gt;<span class="built_in">Display</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Test</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出结果</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">非 const 取地址操作符被调用</span><br><span class="line">const 取地址操作符被调用</span><br><span class="line">Value: 10</span><br><span class="line">Value: 20</span><br></pre></td></tr></table></figure><p><strong>代码解释</strong></p><ol><li><strong>普通对象调用非 <code>const</code> 版本的取地址操作符</strong>：<ul><li>当我们对普通对象 <code>obj</code> 使用 <code>&amp;</code> 时，调用的是 <code>MyClass* operator&amp;()</code>。</li><li>返回类型是一个非 <code>const</code> 指针，即 <code>MyClass*</code>。</li><li>这意味着我们可以通过这个指针修改 <code>obj</code>。</li></ul></li><li><strong><code>const</code> 对象调用 <code>const</code> 版本的取地址操作符</strong>：<ul><li>当我们对 <code>const</code> 对象 <code>constObj</code> 使用 <code>&amp;</code> 时，调用的是 <code>const MyClass* operator&amp;() const</code>。</li><li>返回类型是 <code>const MyClass*</code>，即一个不可修改的指针。</li><li>这保证了通过返回的地址无法修改 <code>constObj</code>。</li></ul></li></ol><blockquote><h2 id="传道解惑"><a href="#传道解惑" class="headerlink" title="传道解惑"></a>传道解惑</h2><h3 id="Q1：两种版本为什么重要？"><a href="#Q1：两种版本为什么重要？" class="headerlink" title="Q1：两种版本为什么重要？"></a>Q1：两种版本为什么重要？</h3><ul><li>如果只有普通的非 <code>const</code> 重载（<code>MyClass* operator&amp;()</code>），<code>const</code> 对象调用时会报错，因为无法确保 <code>const</code> 对象的不可变性。</li><li>如果只有 <code>const</code> 版本重载（<code>const MyClass* operator&amp;() const</code>），普通对象也只能得到一个 <code>const</code> 指针，限制了可操作性。</li></ul><p>因此，同时提供两个版本：</p><ul><li>普通对象取地址时返回普通指针，灵活操作。</li><li><code>const</code> 对象取地址时返回 <code>const</code> 指针，保护不可变性。</li></ul><hr><h3 id="Q2：取地址操作符重载的应用场景？"><a href="#Q2：取地址操作符重载的应用场景？" class="headerlink" title="Q2：取地址操作符重载的应用场景？"></a>Q2：取地址操作符重载的应用场景？</h3><ol><li><strong>调试日志</strong>：可以在取地址时打印出信息，便于调试。</li><li><strong>对象管理</strong>：可以控制对象暴露出去的指针，避免外部直接操作原始地址。</li><li><strong>定制行为</strong>：对于特定的类，可以在取地址时返回自定义指针对象，而不是直接返回 <code>this</code>。</li></ol><hr><h3 id="Q3：为什么需要区分-const-对象的取地址？"><a href="#Q3：为什么需要区分-const-对象的取地址？" class="headerlink" title="Q3：为什么需要区分 const 对象的取地址？"></a>Q3：为什么需要区分 <code>const</code> 对象的取地址？</h3><p>假如我们不区分 <code>const</code> 和非 <code>const</code> 对象取地址操作，就会产生如下问题：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="function"><span class="type">const</span> MyClass <span class="title">constObj</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line">&gt;MyClass* ptr = &amp;constObj; <span class="comment">// 如果没有 const 重载，这会破坏 constObj 的不可变性</span></span><br></pre></td></tr></table></figure><p>通过引入 <code>const</code> 版本的取地址操作符重载，编译器可以在 <code>const</code> 对象中强制返回 <code>const</code> 指针，保护数据安全。</p><ol><li>取地址操作符重载的作用：</li></ol><ul><li>自定义取地址操作符的行为。</li><li>区分普通对象和 <code>const</code> 对象的地址获取方式。</li></ul><ol start="2"><li>注意事项：</li></ol><ul><li>对普通对象，返回普通指针。</li><li>对 <code>const</code> 对象，返回 <code>const</code> 指针，确保不可变性。</li></ul><p>这是一种增强代码灵活性与安全性的手段，同时对复杂场景（如调试或资源管理）非常有用。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>02 类与对象（上）</title>
      <link href="/posts/24103.html"/>
      <url>/posts/24103.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、本节目标"><a href="#一、本节目标" class="headerlink" title="一、本节目标"></a>一、<strong>本节目标</strong></h2><ol><li><strong>面向过程和面向对象初步认识</strong></li><li><strong>类的引入</strong></li><li><strong>类的定义</strong></li><li><strong>类的访问限定符及封装</strong></li><li><strong>类的作用域</strong></li><li><strong>类的实例化</strong></li><li><strong>类的对象大小的计算</strong></li><li><strong>类成员函数的 <code>this</code> 指针</strong></li></ol><h2 id="二、面向过程和面向对象初步认识（过程与面向对象编程）"><a href="#二、面向过程和面向对象初步认识（过程与面向对象编程）" class="headerlink" title="二、面向过程和面向对象初步认识（过程与面向对象编程）"></a>二、面向过程和面向对象初步认识（过程与面向对象编程）</h2><p><strong>面向过程编程（ProceduralProgramming）</strong>：</p><ul><li>关注“<strong>过程</strong>”或“步骤”。</li><li>将问题分解为函数，每个函数执行一个特定的任务。</li><li>主要依赖函数调用，常见于 C 语言。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 面向过程编程: 通过函数处理数据</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">int</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Processing data: %d\n&quot;</span>, data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> data = <span class="number">42</span>;</span><br><span class="line">    <span class="built_in">process</span>(data);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>面向对象编程（Object-OrientedProgramming）</strong>：</p><ul><li>关注“<strong>对象</strong>”，将数据与操作数据的方法结合。</li><li>通过对象之间的交互解决问题，常见于 C++。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Processor</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">int</span> data)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Processing data: &quot;</span> &lt;&lt; data &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Processor p;</span><br><span class="line">    p.<span class="built_in">process</span>(<span class="number">42</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>C 语言是 <strong>面向过程</strong> 的，<strong>关注</strong> 的是 <strong>过程</strong>，分析出求解问题的步骤，通过函数调用逐步解决问题。</li><li>C++是 <strong>基于面向对象</strong> 的，<strong>关注</strong> 的是 <strong>对象</strong>，将一件事情拆分成不同的对象，靠对象之间的交互完成。</li></ul><h2 id="三、类的引入（Introduction-to-Classes）"><a href="#三、类的引入（Introduction-to-Classes）" class="headerlink" title="三、类的引入（Introduction to Classes）"></a>三、类的引入（Introduction to Classes）</h2><p><strong>C 语言结构体中只能定义变量，在 C++中，结构体内不仅可以定义变量，也可以定义函数。</strong> 例如： 之前在数据结构初阶中，用 <strong>C 语言方式实现的栈，结构体中只能定义变量</strong>；但在 C++中，<code>struct</code> 和 <code>class</code> 都可以包含 <strong>变量</strong> 和 <strong>函数</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span> <span class="comment">// for malloc and free</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> DataType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Stack</span></span><br><span class="line">&#123;</span><br><span class="line">    DataType* array;</span><br><span class="line">    <span class="type">size_t</span> capacity;</span><br><span class="line">    <span class="type">size_t</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">(<span class="type">size_t</span> cap)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        array = (DataType*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(DataType) * cap);</span><br><span class="line">        <span class="keyword">if</span> (!array)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;malloc failed&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        capacity = cap;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 压栈操作</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Push</span><span class="params">(<span class="type">const</span> DataType&amp; data)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        array[size++] = data; <span class="comment">// 简化的例子，未考虑扩容</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取栈顶元素</span></span><br><span class="line">    <span class="function">DataType <span class="title">Top</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> array[size - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁栈</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Destroy</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (array)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">free</span>(array);</span><br><span class="line">            array = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Stack s;</span><br><span class="line">    s.<span class="built_in">Init</span>(<span class="number">10</span>);</span><br><span class="line">    s.<span class="built_in">Push</span>(<span class="number">1</span>);</span><br><span class="line">    s.<span class="built_in">Push</span>(<span class="number">2</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Top element: &quot;</span> &lt;&lt; s.<span class="built_in">Top</span>() &lt;&lt; endl;</span><br><span class="line">    s.<span class="built_in">Destroy</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面结构体的定义，<strong>在 C++中更喜欢用 <code>class</code> 来代替</strong>。</p><h2 id="四、类的定义（Defining-a-Class）"><a href="#四、类的定义（Defining-a-Class）" class="headerlink" title="四、类的定义（Defining a Class）"></a>四、类的定义（Defining a Class）</h2><p><strong>类的定义</strong>：<code>class</code> 是定义类的关键字。类是对象的蓝图，包含成员变量（属性）和成员函数（方法）。</p><ul><li><strong>类定义语法</strong>：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ClassName</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 成员变量</span></span><br><span class="line">    <span class="comment">// 成员函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span>为定义类的关键字，ClassName为类的名字，&#123;&#125;中为类的主体，</span><br><span class="line">注意类定义结束时后面分号不能省略。</span><br><span class="line"> </span><br><span class="line">类体中内容称为类的成员：类中的变量称为类的属性或成员变量; </span><br><span class="line">类中的函数称为类的方法或者成员函数。</span><br></pre></td></tr></table></figure><p><strong>两种定义方式</strong>：</p><ol><li><strong>在类体中定义成员函数</strong>：这样的函数可能被编译器视为 <code>inline</code> 内联函数。</li><li><strong>类声明与定义分离</strong>：通常将类的声明放在 <code>.h</code> 文件中，成员函数的定义放在 <code>.cpp</code> 文件中。注意：<strong>成员函数名前需要加类名::</strong></li></ol><p><strong>示例 1：类体中定义所有内容</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">(<span class="type">int</span> year, <span class="type">int</span> month, <span class="type">int</span> day)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _year = year;</span><br><span class="line">        _month = month;</span><br><span class="line">        _day = day;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; _year &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; _month &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; _day &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _year, _month, _day;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Date today;</span><br><span class="line">    today.<span class="built_in">Init</span>(<span class="number">2024</span>, <span class="number">9</span>, <span class="number">22</span>);</span><br><span class="line">    today.<span class="built_in">Print</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例 2：类声明与定义分离</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Date.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">(<span class="type">int</span> year, <span class="type">int</span> month, <span class="type">int</span> day)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _year, _month, _day;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// Date.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Date.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Date::Init</span><span class="params">(<span class="type">int</span> year, <span class="type">int</span> month, <span class="type">int</span> day)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    _year = year;</span><br><span class="line">    _month = month;</span><br><span class="line">    _day = day;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Date::Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; _year &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; _month &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; _day &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Date today;</span><br><span class="line">    today.<span class="built_in">Init</span>(<span class="number">2024</span>, <span class="number">9</span>, <span class="number">22</span>);</span><br><span class="line">    today.<span class="built_in">Print</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五、类的访问限定符及封装（Access-Specifiers-and-Encapsulation）"><a href="#五、类的访问限定符及封装（Access-Specifiers-and-Encapsulation）" class="headerlink" title="五、类的访问限定符及封装（Access Specifiers and Encapsulation）"></a>五、类的访问限定符及封装（Access Specifiers and Encapsulation）</h2><p><strong>访问限定符</strong> 用于控制类的成员是否能够在类外部访问：</p><ul><li><code>public</code>：类外可以访问。</li><li><code>private</code>：类外部不能直接访问，只能通过类的内部方法操作。</li><li><code>protected</code>：类外部无法访问，但在继承中可以访问。</li></ul><p><strong>封装（Encapsulation）</strong>：隐藏类的实现细节，仅对外提供公共接口，保证数据的安全性。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">(<span class="type">int</span> year, <span class="type">int</span> month, <span class="type">int</span> day)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _year = year;</span><br><span class="line">        _month = month;</span><br><span class="line">        _day = day;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; _year &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; _month &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; _day &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _year, _month, _day;  <span class="comment">// 这些变量无法在类外直接访问</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Date today;</span><br><span class="line">    today.<span class="built_in">Init</span>(<span class="number">2024</span>, <span class="number">9</span>, <span class="number">22</span>);</span><br><span class="line">    today.<span class="built_in">Print</span>();  <span class="comment">// 只能通过Print()访问日期信息</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="六、类的作用域（Class-Scope）"><a href="#六、类的作用域（Class-Scope）" class="headerlink" title="六、类的作用域（Class Scope）"></a>六、类的作用域（Class Scope）</h2><p>类的成员定义在类的作用域内，在类外部使用成员函数时，必须用域操作 <code>::</code> 指定该成员属于哪个作用类。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetName</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PrintName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span> _name[<span class="number">20</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类外定义成员函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Person::SetName</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">strcpy</span>(_name, name);  <span class="comment">// 设置名字</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Person::PrintName</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Name: &quot;</span> &lt;&lt; _name &lt;&lt; endl;  <span class="comment">// 打印名字</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Person p;</span><br><span class="line">    p.<span class="built_in">SetName</span>(<span class="string">&quot;Alice&quot;</span>);</span><br><span class="line">    p.<span class="built_in">PrintName</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="七、类的实例化（Instantiation-of-Classes）"><a href="#七、类的实例化（Instantiation-of-Classes）" class="headerlink" title="七、类的实例化（Instantiation of Classes）"></a>七、类的实例化（Instantiation of Classes）</h2><p>类的 <strong>实例化</strong> 是指 <strong>通过类的定义创建对象</strong>，分配实际的内存空间给成员变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetBrand</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* brand)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">strcpy</span>(_brand, brand);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Car brand: &quot;</span> &lt;&lt; _brand &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span> _brand[<span class="number">20</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Car car1, car2;  <span class="comment">// 实例化两个对象</span></span><br><span class="line">    car<span class="number">1.</span><span class="built_in">SetBrand</span>(<span class="string">&quot;Toyota&quot;</span>);</span><br><span class="line">    car<span class="number">2.</span><span class="built_in">SetBrand</span>(<span class="string">&quot;Honda&quot;</span>);</span><br><span class="line"></span><br><span class="line">    car<span class="number">1.</span><span class="built_in">Print</span>();</span><br><span class="line">    car<span class="number">2.</span><span class="built_in">Print</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>类是对对象进行描述的</strong>，是一个 <strong>模型</strong> 一样的东西，限定了类有哪些成员，定义出一个类 <strong>并没有分配实际的内存空间</strong> 来存储它；比如：入学时填写的学生信息表，表格就可以看成是一个类，来描述具体学生信息。</li></ol><p>​类就像谜语一样，对谜底来进行描述，谜底就是谜语的一个实例。</p><p>​谜语：”年纪不大，胡子一把，主人来了，就喊妈妈” 谜底：山羊</p><ol start="2"><li>一个类可以实例化出多个对象，<strong>实例化出的对象 占用实际的物理空间，存储类成员变量</strong></li></ol>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     Person._age = <span class="number">100</span>;   <span class="comment">// 编译失败：error C2059: 语法错误:“.”</span></span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">Person类是没有空间的，只有Person类实例化出的对象才有具体的年龄。</span><br></pre></td></tr></table></figure><ol start="3"><li>做个比方。<strong>类实例化出对象就像现实中使用建筑设计图建造出房子，类就像是设计图</strong>，只设计出需要什么东西，但是并没有实体的建筑存在，同样类也只是一个设计，实例化出的对象才能实际存储数据，占用物理空间</li></ol><h2 id="八、类对象模型（Class-Object-Model）"><a href="#八、类对象模型（Class-Object-Model）" class="headerlink" title="八、类对象模型（Class Object Model）"></a>八、类对象模型（Class Object Model）</h2><p><strong>类对象的大小</strong> 由成员变量的大小决定，成员函数的代码不会占用对象的存储空间。</p><ul><li><strong>空类</strong> 的大小为 1 字节，确保每个对象都有唯一标识。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Empty</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _x;</span><br><span class="line">    <span class="type">char</span> _y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Size of Empty class: &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(Empty) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Size of A: &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(A) &lt;&lt; endl;  <span class="comment">// 由于内存对齐的影响，可能比预期的更大</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结论：一个类的大小，实际就是该类中”成员变量”之和，当然要注意内存对齐。注意空类的大小，空类比较特殊，编译器给了空类一个字节来唯一标识这个类的对象。</strong></p><h3 id="结构体内存对齐规则（Struct-Memory-Alignment-Rules）"><a href="#结构体内存对齐规则（Struct-Memory-Alignment-Rules）" class="headerlink" title="结构体内存对齐规则（Struct Memory Alignment Rules）"></a>结构体内存对齐规则（Struct Memory Alignment Rules）</h3><p><strong>内容对齐</strong> 的规则(<a href="https://blog.csdn.net/Huangcancan666/article/details/140896458?spm=1001.2014.3001.5501">【C 语言】结构体内存布局解析——字节对齐_字节对齐规则-CSDN 博客</a>)：</p><ol><li>第一个成员从偏移量为 0 的位置开始。</li><li>其他成员遵循它们大小的整数倍对齐。</li><li>总大小为最大对齐数的整数倍。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">S1</span> &#123;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">S2</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Size of S1: &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(S1) &lt;&lt; endl;  <span class="comment">// 8字节，内存对齐使得char占4字节</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Size of S2: &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(S2) &lt;&lt; endl;  <span class="comment">// 8字节</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="九、this-指针"><a href="#九、this-指针" class="headerlink" title="九、this 指针"></a>九、this 指针</h2><p>在 C++中，<code>this</code> 指针是一个特殊的指针，用于指向调用成员函数的当前对象（当前对象）。它只在类的非静态成员函数下面可用，是传递方式的。是对 <code>this</code> 指针隐式的详细讲解，包括特性、与 C 语言的对比，以及常见的易错点。</p><h3 id="1-引出：什么是-this-指针？"><a href="#1-引出：什么是-this-指针？" class="headerlink" title="1. 引出：什么是 this 指针？"></a>1. 引出：什么是 <code>this</code> 指针？</h3><p>当一个对象调用其类的非静态成员函数时，编译器会自动传递该对象的地址给函数。<code>this</code> 指针就是该对象的地址的成员函数。它可以用于在成员函数中调用该函数的对象的地址成员。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setValue</span><span class="params">(<span class="type">int</span> value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;value = value;  <span class="comment">// 使用this指针，避免成员变量与参数重名冲突</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="2-特性："><a href="#2-特性：" class="headerlink" title="2. 特性："></a>2. 特性：</h3><ul><li><p><strong>隐式传递</strong>：<code>this</code> 指针不需要显式声明，它在所有非静态成员函数中隐式可用。</p></li><li><p><strong>常量性</strong>：<code>this</code> 指针是常量指针，无法修改其指向的对象。即 <code>this</code> 类型为 <code>MyClass* const</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// this = nullptr; // 错误！无法修改this指针的指向</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>指向当前对象</strong>：<code>this</code> 指向调用该成员函数的当前对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyClass obj;</span><br><span class="line">obj.<span class="built_in">func</span>();  <span class="comment">// this指针指向obj</span></span><br></pre></td></tr></table></figure></li><li><p><strong>在常量成员函数中的 <code>this</code> 指针</strong>：在常量成员函数中，<code>this</code> 指针是指向常量的指针，其类型为 <code>const MyClass* const</code>，表示不能 <code>this</code> 修改对象的数据成员。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// this-&gt;value = 10;  // 错误！无法修改常成员函数中的对象数据</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-与-C-的对比："><a href="#3-与-C-的对比：" class="headerlink" title="3. 与 C 的对比："></a>3. 与 C 的对比：</h3><p>C 语言本身不支持类和对象的概念，因此也不存在 <code>this</code> 指针。在 C 中，要模拟类似的行为，通常需要显式传递结构体指针来访问结构体的成员。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">C++中的<span class="keyword">this</span>指针对应于在C语言中手动传递对象指针给函数的做法：</span><br><span class="line"><span class="comment">// C语言模拟对象方法</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setValue</span><span class="params">(<span class="keyword">struct</span> MyClass* self, <span class="type">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    self-&gt;value = value;</span><br><span class="line">&#125;</span><br><span class="line">在C++中，这种显着式的传递结构指针的方式通过<span class="keyword">this</span>指针抓取方式和自动化，简化了编程。</span><br></pre></td></tr></table></figure><h3 id="4-常见易错点："><a href="#4-常见易错点：" class="headerlink" title="4. 常见易错点："></a>4. 常见易错点：</h3><ul><li><p><strong>修改 <code>this</code> 指针</strong>：<code>this</code> 是常量指针，不能修改其指向对象，错误的代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// this = nullptr; // 错误！无法修改this指针的指向</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>在静态成员函数中使用 <code>this</code></strong>：静态成员函数属于类本身，而不是某个特定对象，因此，静态成员函数中没有 <code>this</code> 指针。如果尝试在静态成员函数中使用 <code>this</code>，会出现编译错误。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">staticFunc</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// this-&gt;value = 10;  // 错误，静态成员函数没有this指针</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>返回 <code>*this</code></strong>：在链式调用时，经常会返回当前对象的引用，返回 <code>*this</code> 是合法的用法。常见的用法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">MyClass&amp; <span class="title">setValue</span><span class="params">(<span class="type">int</span> value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;value = value;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;  <span class="comment">// 返回当前对象的引用，支持链式调用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>在构造函数或解析构造函数中使用 <code>this</code></strong>：在构造函数中使用 <code>this</code> 指针是安全的，但需要注意不要在构造函数中将 <code>this</code> 指针导出出去（比如在构造函数中调用虚函数）。在构造函数中，<code>this</code> 指向即将被关注的对象，因此要小心避免对已关注的资源操作。</p></li></ul><h3 id="5-小结："><a href="#5-小结：" class="headerlink" title="5. 小结："></a>5. 小结：</h3><ul><li><code>this</code> 指针用于指向当前对象，并在非静态成员函数中隐式传递。</li><li>它是一个常量指针，不能修改指向的对象。</li><li>静态成员函数中没有 <code>this</code> 指针。</li><li><code>this</code> 在 C++中简化了对象成员的访问，而在 C 语言中，需要手动传递结构体指针。</li></ul><p>掌握 <code>this</code> 指针有助于理解对象成员的访问方式和 C++类的工作原理。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍了对象编程中的类、对象、封装、作用域、实例化、对象模型、内存定位和 <code>this</code> 指针的详细内容和代码示例。你可以通过编写这些代码加深理解，并尝试修改运行和它们来更好地掌握这些概念。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>obsidian使用</title>
      <link href="/posts/4661.html"/>
      <url>/posts/4661.html</url>
      
        <content type="html"><![CDATA[<p>在 Obsidian 最新版中，正反向链接、标签和属性是核心功能，用于构建知识网络、分类管理及添加</p><h3 id="一、正反向链接"><a href="#一、正反向链接" class="headerlink" title="一、正反向链接"></a><strong>一、正反向链接</strong></h3><h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a><strong>功能</strong></h4><ul><li><strong>正向链接（出链）</strong>：当前笔记中主动引用其他笔记或段落。</li><li><strong>反向链接（入链）</strong>：其他笔记引用当前笔记时自动生成的反向关联。</li><li><strong>作用</strong>：形成双向知识网络，通过链接关系追溯相关内容。</li></ul><h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a><strong>使用方法</strong></h4><ol><li><p><strong>基础语法</strong>：  </p> <figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[[目标笔记名]]                  # 链接到整篇笔记</span><br><span class="line">[[目标笔记名#标题]]             # 链接到特定标题</span><br><span class="line">[[目标笔记名#^段落ID]]          # 链接到具体段落（块）</span><br><span class="line">[[目标笔记名|别名]]             # 使用别名显示链接</span><br></pre></td></tr></table></figure></li><li><p><strong>操作提示</strong>：  </p><ul><li>输入 <code>[[</code> 后，Obsidian 会自动提示可链接的笔记。</li><li>支持嵌入内容（如图片、视频）：<code>![[图片名.png]]</code>。</li><li>段落块 ID 可通过光标悬停段落时点击「复制块链接」获取。</li></ul></li><li><p><strong>查看反向链接</strong>：<br> 在右侧面板或笔记底部查看「反向链接」，显示所有引用当前笔记的位置。</p></li></ol><hr><h3 id="二、标签"><a href="#二、标签" class="headerlink" title="二、标签"></a><strong>二、标签</strong></h3><h4 id="功能-1"><a href="#功能-1" class="headerlink" title="功能"></a><strong>功能</strong></h4><ul><li><strong>分类管理</strong>：通过 <code>#标签</code> 对笔记进行主题或属性标记。</li><li><strong>嵌套标签</strong>：支持层级结构（如 <code>#科研/论文</code>），实现精细分类。</li><li><strong>作用</strong>：快速检索、批量管理相关笔记。</li></ul><h4 id="使用方法-1"><a href="#使用方法-1" class="headerlink" title="使用方法"></a><strong>使用方法</strong></h4><ol><li><p><strong>基础语法</strong>：  </p> <figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">#标签名         # 普通标签</span></span><br><span class="line"><span class="section">#父标签/子标签  # 嵌套标签</span></span><br></pre></td></tr></table></figure></li><li><p><strong>优化实践</strong>：  </p><ul><li><p>将标签置于 YAML front matter 中，避免正文干扰：  </p>  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">tags:</span> [<span class="string">Obsidian</span>, <span class="string">教程</span>]</span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure></li><li><p>使用 <strong>Tag Wrangler 插件</strong>：  </p><ul><li>右键标签批量重命名、创建标签页、拖拽插入标签。</li><li>管理嵌套标签结构，生成标签树。</li></ul></li></ul></li></ol><hr><h3 id="三、属性（YAML-Front-Matter）"><a href="#三、属性（YAML-Front-Matter）" class="headerlink" title="三、属性（YAML Front Matter）"></a><strong>三、属性（YAML Front Matter）</strong></h3><h4 id="功能-2"><a href="#功能-2" class="headerlink" title="功能"></a><strong>功能</strong></h4><ul><li><strong>元数据管理</strong>：为笔记添加结构化信息（如作者、创建时间、进度等）。</li><li><strong>类型支持</strong>：文本、列表、数字、日期等（需手动定义类型）。</li><li><strong>作用</strong>：配合插件（如 Dataview）实现高级查询和自动化管理。</li></ul><h4 id="使用方法-2"><a href="#使用方法-2" class="headerlink" title="使用方法"></a><strong>使用方法</strong></h4><ol><li><p><strong>基础语法</strong>：<br> 在笔记开头添加 YAML 块：  </p> <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">aliases:</span> [<span class="string">别名1</span>, <span class="string">别名2</span>]  <span class="comment"># 别名</span></span><br><span class="line"><span class="attr">tags:</span> <span class="string">标签名</span>             <span class="comment"># 标签</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2023-09-01</span>        <span class="comment"># 日期类型属性</span></span><br><span class="line"><span class="attr">progress:</span> <span class="string">进行中</span>         <span class="comment"># 文本类型属性</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure></li><li><p><strong>类型定义</strong>：  </p><ul><li>属性值默认文本类型，可通过插件或手动标注类型（如 <code>date:: 2023-09-01</code>）。</li></ul></li><li><p><strong>模板自动化</strong>：  </p><ul><li>结合模板插件，自动插入常用属性（如 <code>&#123;&#123;date&#125;&#125;</code> 生成当前日期）。</li></ul></li></ol><hr><h3 id="版本注意事项"><a href="#版本注意事项" class="headerlink" title="版本注意事项"></a><strong>版本注意事项</strong></h3><ul><li><strong>桌面端</strong>：1.4.5+ 支持完整属性功能。</li><li><strong>移动端</strong>：暂不支持属性（截至 2023.09），建议通过桌面端编辑。</li></ul><hr><h3 id="总结：使用场景"><a href="#总结：使用场景" class="headerlink" title="总结：使用场景"></a><strong>总结：使用场景</strong></h3><ol><li><strong>正反向链接</strong>：构建知识关联，推荐用于概念解释、参考文献。</li><li><strong>标签</strong>：快速分类，适合主题标记（如 <code>#待办</code>、<code>#灵感</code>）。</li><li><strong>属性</strong>：结构化元数据，适用于项目管理（如 <code>status: 进行中</code>）。</li></ol><p>通过组合这些功能，Obsidian 可实现高效的知识管理与深度关联。</p>]]></content>
      
      
      <categories>
          
          <category> Obsidian </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Obsidian </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
