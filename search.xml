<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>050 传输层 —— UDP</title>
      <link href="/posts/62772.html"/>
      <url>/posts/62772.html</url>
      
        <content type="html"><![CDATA[<h1 id="传输层-——-UDP"><a href="#传输层-——-UDP" class="headerlink" title="传输层 —— UDP"></a>传输层 —— UDP</h1><h2 id="1-再谈端口号"><a href="#1-再谈端口号" class="headerlink" title="1. 再谈端口号"></a>1. 再谈端口号</h2><h3 id="1-端口号与五元组通信模型"><a href="#1-端口号与五元组通信模型" class="headerlink" title="1. 端口号与五元组通信模型"></a>1. 端口号与五元组通信模型</h3><p>端口号（Port）标识了一个主机上进行通信的不同的应用程序。</p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250909115539543.png" alt="PixPin_2025-09-09_11-55-33"></p><p>在 TCP&#x2F;IP 协议中，一个 <strong>通信连接</strong> 由五元组唯一标识：<strong>(源 IP, 源端口, 目的 IP, 目的端口, 协议号)</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250909115657967.png" alt="PixPin_2025-09-09_11-56-47"></p><p><strong>为什么需要五元组？</strong></p><ul><li>一台主机可以同时与多个远程主机通信。</li><li>同一个远程主机可以同时提供多个服务（如 HTTP + SSH）。</li><li>同一个服务可以被多个本地进程（客户端）访问。</li><li>所以必须用五元组才能 <strong>唯一标识一条连接</strong>。</li></ul><p><strong>查看当前连接：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">netstat -n</span><br><span class="line"><span class="comment"># 或更现代的：</span></span><br><span class="line">ss -n</span><br></pre></td></tr></table></figure><h3 id="2-端口号范围划分"><a href="#2-端口号范围划分" class="headerlink" title="2. 端口号范围划分"></a>2. 端口号范围划分</h3><table><thead><tr><th>范围</th><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>0 - 1023</td><td>知名端口</td><td>系统保留，通常需要 root 权限绑定。如 80(HTTP), 443(HTTPS), 22(SSH) 等。</td></tr><tr><td>1024 - 49151</td><td>注册端口</td><td>用户程序或第三方服务可注册使用（如 MySQL 3306, Redis 6379）</td></tr><tr><td>49152 - 65535</td><td>动态&#x2F;私有端口</td><td>操作系统自动分配给客户端程序的临时端口</td></tr></tbody></table><blockquote><p>注：不同系统对“动态端口”的起始值可能不同（Linux 默认从 32768 开始，可通过 <code>cat /proc/sys/net/ipv4/ip_local_port_range</code> 查看）。在我的主机上运行结果是 <code>3276860999</code>，这就表示 Linux 会随机选择 <strong>32768 到 60999</strong> 之间的端口号给我自己的客户端进程进行分配。</p></blockquote><p><strong>查看知名端口映射：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /etc/services</span><br></pre></td></tr></table></figure><p><strong>编辑（不要随意修改！）：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> vim /etc/services<span class="comment"># cat 不好查看这样的长内容，用 vim 观看体验会好一点，但不要进行修改！！</span></span><br></pre></td></tr></table></figure><p><strong>我们自定义程序端口建议避开 0-1023，最好使用 1024 以上未被占用的端口，从而避开这些知名端口号。</strong></p><h3 id="3-两个关键问题"><a href="#3-两个关键问题" class="headerlink" title="3. 两个关键问题"></a>3. 两个关键问题</h3><h4 id="1-一个进程是否可以-bind-多个端口号？"><a href="#1-一个进程是否可以-bind-多个端口号？" class="headerlink" title="1. 一个进程是否可以 bind 多个端口号？"></a>1. 一个进程是否可以 bind 多个端口号？</h4><p><strong>可以！</strong> 一个进程可以创建多个 socket，分别 bind 到不同的端口。例如：Nginx 可以监听 80 和 443；一个程序可以同时提供 HTTP 和管理 API。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 伪代码示意</span></span><br><span class="line">socket1 = socket(); bind(socket1, port=<span class="number">8080</span>);</span><br><span class="line">socket2 = socket(); bind(socket2, port=<span class="number">8081</span>);</span><br></pre></td></tr></table></figure><h4 id="2-一个端口号是否可以被多个进程-bind？"><a href="#2-一个端口号是否可以被多个进程-bind？" class="headerlink" title="2. 一个端口号是否可以被多个进程 bind？"></a>2. 一个端口号是否可以被多个进程 bind？</h4><p><strong>我们一般接触到的情况都不行！</strong></p><ul><li><strong>操作系统规定</strong>：同一时间，一个端口（如 <code>80</code>）只能有一个进程处于 <strong>LISTENING</strong> 状态。否则无法区分到底该把流量交给哪个进程。</li><li>如果强行 bind，会报错 <code>Address already in use</code>。</li></ul><p><strong>但也存在例外情况（了解）：</strong></p><ul><li>使用 <code>SO_REUSEADDR</code> 或 <code>SO_REUSEPORT</code> 选项时，多个进程&#x2F;线程可以监听同一个端口，但一般用于 <strong>负载均衡</strong>（如 Nginx 多 worker）。</li><li>这种情况下，内核会把新连接分配给其中一个进程。</li></ul><h3 id="4-命令详解：netstat-pidof"><a href="#4-命令详解：netstat-pidof" class="headerlink" title="4. 命令详解：netstat, pidof"></a>4. 命令详解：<code>netstat</code>, <code>pidof</code></h3><h4 id="1-netstat-——-查看网络连接、路由、接口等"><a href="#1-netstat-——-查看网络连接、路由、接口等" class="headerlink" title="1. netstat —— 查看网络连接、路由、接口等"></a>1. <code>netstat</code> —— 查看网络连接、路由、接口等</h4><p><strong>常用选项（<code>netstat -tulnp</code>）：</strong></p><ul><li>-t：仅显示 TCP 相关选项。</li><li>-u：仅显示 UDP 相关选项。</li><li>-l：仅列出有在 Listening（监听中的）服务状态。</li><li>-n：拒绝显示别名，能显示数字的全部转化成数字。</li><li>-p：显示建立相关链接的程序名、进程 PID（<strong>需要 root</strong>）。</li><li>-a（all）：显示所有选项默认不显示 LISTEN 相关。</li></ul><p><strong>示例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">netstat -n      <span class="comment"># 用数字显示，不反查域名/服务名</span></span><br><span class="line">netstat -tlnp   <span class="comment"># 显示 TCP 监听端口 + 进程号</span></span><br><span class="line">netstat -anp    <span class="comment"># 显示所有连接 + 进程号</span></span><br><span class="line">netstat -tulnp | grep :80 <span class="comment"># 查看谁在监听 80 端口</span></span><br><span class="line"></span><br><span class="line">ss -tulnp</span><br><span class="line">ss -tuln   <span class="comment"># 查监听</span></span><br><span class="line">ss -tan    <span class="comment"># 查所有 TCP 连接</span></span><br></pre></td></tr></table></figure><blockquote><p>在较新 Linux 系统中，<code>ss</code>（socket statistics）开始逐渐替代 <code>netstat</code>。</p></blockquote><h4 id="2-pidof-——-通过程序名获取进程-PID"><a href="#2-pidof-——-通过程序名获取进程-PID" class="headerlink" title="2. pidof —— 通过程序名获取进程 PID"></a>2. <code>pidof</code> —— 通过程序名获取进程 PID</h4><p><strong>语法：</strong> <code>pidof [程序名]</code>。</p><p><strong>示例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pidof httpd      <span class="comment"># 查 httpd 的进程号</span></span><br><span class="line">pidof nginx      <span class="comment"># 查 nginx 的进程号</span></span><br></pre></td></tr></table></figure><p><strong>常见用法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pidof httpd</span><br><span class="line"><span class="comment"># 确认无误后再</span></span><br><span class="line">pidof httpd | xargs <span class="built_in">kill</span> -9</span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line"><span class="built_in">kill</span> -9 $(pidof httpd)     <span class="comment"># 杀死所有 httpd 进程</span></span><br></pre></td></tr></table></figure><hr><h4 id="3-命令行参数转化问题"><a href="#3-命令行参数转化问题" class="headerlink" title="3. 命令行参数转化问题"></a>3. 命令行参数转化问题</h4><p><strong>命令行示例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps ajx | <span class="built_in">head</span> -1 &amp;&amp; ps ajx | grep httpd | awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span> | xargs <span class="built_in">kill</span> -9</span><br></pre></td></tr></table></figure><p><strong>命令行本意：</strong></p><ol><li><code>ps ajx | head -1</code> → 打印 <code>ps ajx</code> 的表头（列名），方便对照列号</li><li><code>&amp;&amp;</code> → 表示前面命令成功（退出码 0）才执行后面的命令，这里 <code>head -1</code> 几乎总是成功，所以后面一定会执行。</li><li><code>ps ajx | grep httpd</code> → 找出所有含有 <code>httpd</code> 的进程。</li><li><code>awk &#39;&#123;print $2&#125;&#39;</code> → 取第 2 列（以为这一列就是 PID）。</li><li><code>xargs kill -9</code> → 把 PID 传给 <code>kill -9</code>，强制结束进程。</li></ol><p><strong>目的就是：先看看进程表头 → 再杀掉所有 httpd（这个 <code>d</code> 就表示是守护进程 ） 进程。</strong></p><p><strong>为什么有问题？</strong></p><p><strong>本来只想杀掉 <code>httpd</code>，结果不小心连 <code>grep httpd</code> 这个查找命令自己也一起杀了 —— 虽然它“死得快”，但逻辑是错的，还可能误杀别的！</strong> </p><ul><li><code>grep httpd</code> 会把自己也列出来，把自己运行的查找命令也一起杀掉，虽然 <code>grep</code> 命令通常 0.1 秒就结束了，杀它没实际影响，但 <strong>逻辑错误！不专业！</strong></li><li>如果系统里没有 httpd，命令会报错！</li></ul><p><strong>怎么解决？</strong></p><ol><li>最简单 —— 直接用 <code>pkill</code>，<code>pkill -9 httpd（进程名，非ID）</code> → 系统自带的“精准杀手”，专门干这个活，不会杀自己，找不到也不报错。</li><li>用 <code>pidof</code>，<code>pidof httpd | xargs kill -9</code> → <code>pidof</code> 只找“程序名叫 httpd”的进程，不会找 grep，很干净。</li><li>非要自己写，加个“防自杀”技巧：<code>ps ajx | grep [h]ttpd | awk &#39;&#123;print $2&#125;&#39; | xargs kill -9</code> → <code>[h]ttpd</code> 和 <code>httpd</code> 效果一样，但命令名是 <code>grep [h]ttpd</code>，不会匹配自己（也叫“grep 防自爆写法”）。</li></ol><h4 id="4-关于-iostat"><a href="#4-关于-iostat" class="headerlink" title="4. 关于 iostat"></a>4. 关于 <code>iostat</code></h4><blockquote><ul><li><strong><code>iostat</code></strong>：I&#x2F;O statistics → 磁盘、CPU 使用情况。</li><li><strong><code>netstat</code></strong>：network statistics → 网络、端口情况。</li></ul></blockquote><p>它和网络&#x2F;端口无关，它只是一个 <strong>查看磁盘 I&#x2F;O 统计</strong> 的工具，用于收集 <strong>CPU 使用情况</strong> 和 <strong>块设备（磁盘&#x2F;分区）I&#x2F;O 性能数据</strong>，帮助我们了解系统的 I&#x2F;O 瓶颈。安装命令：<code>sudo yum install sysstat</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iostat  <span class="comment"># 显示 CPU 使用率 + 每个设备的 I/O 概况</span></span><br><span class="line">iostat -x 1    <span class="comment"># 每秒刷新，显示扩展统计（x → 显示扩展统计，更详细）</span></span><br></pre></td></tr></table></figure><p><strong>指标讲解（磁盘部分）：</strong></p><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td><code>r/s</code></td><td>每秒读请求数（读 IOPS）</td></tr><tr><td><code>w/s</code></td><td>每秒写请求数（写 IOPS）</td></tr><tr><td><code>rkB/s</code></td><td>每秒读的 KB 数（读吞吐量）</td></tr><tr><td><code>wkB/s</code></td><td>每秒写的 KB 数（写吞吐量）</td></tr><tr><td><code>await</code></td><td>平均每个 I&#x2F;O 请求的等待时间（毫秒），越小越好</td></tr><tr><td><code>svctm</code></td><td>服务一个 I&#x2F;O 请求的时间（毫秒）</td></tr><tr><td><code>%util</code></td><td>磁盘繁忙程度（100% &#x3D; 跑满了）</td></tr></tbody></table><p><strong>直观判断：</strong></p><ul><li><code>%util</code> 接近 100%，磁盘被打爆了。</li><li><code>await</code> 很大，说明 I&#x2F;O 延迟严重。</li><li>IOPS (<code>r/s</code>+<code>w/s</code>) 很高，但 <code>%util</code> 没满 → 磁盘性能还行。</li></ul><p><strong>CPU 部分指标：</strong></p><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td><code>%user</code></td><td>用户态 CPU 占比（应用程序消耗）</td></tr><tr><td><code>%system</code></td><td>内核态 CPU 占比（系统调用消耗）</td></tr><tr><td><code>%iowait</code></td><td>等待 I&#x2F;O 的时间占比（越高越说明磁盘慢）</td></tr><tr><td><code>%idle</code></td><td>空闲时间</td></tr></tbody></table><p><strong>直观判断：</strong></p><ul><li><code>%iowait</code> 很高，说明 CPU 大部分时间都在等磁盘。</li><li><code>%user</code> 高 → 应用很吃 CPU。</li><li><code>%idle</code> 高 → 系统很闲。</li></ul><h2 id="2-UDP-协议"><a href="#2-UDP-协议" class="headerlink" title="2. UDP 协议"></a>2. UDP 协议</h2><h3 id="1-UDP-协议段格式"><a href="#1-UDP-协议段格式" class="headerlink" title="1. UDP 协议段格式"></a>1. UDP 协议段格式</h3><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250909115838060.png" alt="PixPin_2025-09-09_11-58-32"></p><blockquote><p>16 位指 16 个二进制位，即 0 或 1，8 位等于 1 字节，16 位就是 2 字节。</p><p><a href="https://en.wikipedia.org/wiki/UTF-16">UTF-16</a> 不常用，<a href="https://en.wikipedia.org/wiki/UTF-8">UTF-8</a> 更常用。它是一种变长字符编码，简单且直观的来说就是在 UTF-8 中，一个英文字符就占 1 字节，一个中文字符就占 3 字节，少数生僻字等占 4 字节。</p></blockquote><p>UDP 报头总是 <strong>8 字节（64 bit）</strong>，分成四个 16 位字段，按顺序排放：</p><ol><li><strong>源端口号（16 位）</strong></li><li><strong>目的端口号（16 位）</strong></li><li><strong>UDP 长度（16 位）</strong> —— 包括整个 UDP 数据报（头部 + 数据）的长度。</li><li><strong>校验和（16 位）</strong> —— 校验 UDP 报文在传输中是否出错（发送方用特定算法，将伪首部、UDP 首部和数据部分计算出校验和存于报头。接收方同样计算并对比，若不一致 <strong>通常丢弃数据包</strong>，但也可交给上层并附错误报告 ）。</li></ol><p>紧接着就是 <strong>数据（有效载荷）</strong>，长度由 “UDP 长度”字段减去 8（报头大小）得出。</p><p>在 Linux 下用 C 语言实现时，UDP 报头是一个自定义结构体。具体表现为（<code>cat /usr/include/netinet/udp.h</code>）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">udphdr</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">u_int16_t</span> source;</span><br><span class="line">  <span class="type">u_int16_t</span> dest;</span><br><span class="line">  <span class="type">u_int16_t</span> len;</span><br><span class="line">  <span class="type">u_int16_t</span> check;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// u_int16_t是一种类型定义，本质上是 16 位无符号整数，用来定义 UDP 报头中各字段的数据类型，像源端口号、目的端口号等都是 16 位，就用它来定义。</span></span><br></pre></td></tr></table></figure><h3 id="2-UDP-报文是“矩形”的还是线性的？"><a href="#2-UDP-报文是“矩形”的还是线性的？" class="headerlink" title="2. UDP 报文是“矩形”的还是线性的？"></a>2. UDP 报文是“矩形”的还是线性的？</h3><p>图中“矩形”矩形结构只是一种 <strong>逻辑结构图&#x2F;一种可视化方式</strong>，用来帮助理解字段布局、说明各个字段的位置和大小。实际网络上传输时（物理传输层面），报文是 <strong>一维线性的比特流（字节流）</strong>。换句话说，发送出去的数据包在网线上就是一串 0 和 1，不是二维矩形。</p><p>实际在网络中，UDP 数据报是一个连续的字节序列，按顺序排列如下：<code>[源端口][目的端口][长度][检验和][数据...]</code>，举个例子：假设一个 UDP 数据报有 100 字节数据，则总长度为 8（头部）+ 100 &#x3D; 108 字节。这些字节会依次封装进 IP 包中，通过网络传输。</p><blockquote><p>在协议层面 <strong>面向数据报</strong>，UDP 以数据报为单位处理数据，有独立边界；在物理传输层面，为适配网络介质，数据报要转化为 <strong>比特流（字节流）传输</strong>，一个是逻辑处理方式，一个是实际传输形式 。 </p></blockquote><hr><h3 id="3-报头和有效载荷是如何分离的？"><a href="#3-报头和有效载荷是如何分离的？" class="headerlink" title="3. 报头和有效载荷是如何分离的？"></a>3. 报头和有效载荷是如何分离的？</h3><p>关键点是 <strong>UDP 长度字段</strong>，通过它确定报头后 8 字节的边界，从而分离出有效载荷。接收方先看前 8 字节是报头，再找出 “UDP 长度” 这个信息，从第 9 字节开始，用 “UDP 长度” 减 8 得到的字节数就是有效载荷。或者简单说，先确定 8 字节报头，IP 层把数据给 UDP 后，剩下的就是有效载荷。</p><h3 id="4-有效载荷如何交付给上层？"><a href="#4-有效载荷如何交付给上层？" class="headerlink" title="4. 有效载荷如何交付给上层？"></a>4. 有效载荷如何交付给上层？</h3><p>当 UDP 收到数据报后：</p><ol><li>根据 <strong>目的端口号</strong> 查找对应的应用程序（如 DNS、NTP、游戏等）。</li><li>将有效载荷交给该应用程序处理。</li><li>应用程序通常通过 socket 接口接收数据（例如 <code>recvfrom()</code>）。</li></ol><p>比如在线视频播放时，视频流数据通过 UDP 传输，目的端口号对应视频播放应用程序，UDP 把有效载荷交给它，就能播放视频了。</p><blockquote><p>UDP 不保证送达、不排序、不重传，所以交付是“尽力而为”。</p></blockquote><h3 id="5-UDP-的应用场景有哪些？"><a href="#5-UDP-的应用场景有哪些？" class="headerlink" title="5. UDP 的应用场景有哪些？"></a>5. UDP 的应用场景有哪些？</h3><p><strong>UDP 的特点：简单、无连接、不保证可靠传输、面向数据报，但开销小、延迟低。</strong> 适用于：</p><ul><li>实时通信：语音通话（VoIP）、视频会议、在线游戏（延迟比可靠性更重要）。</li><li>简单查询服务：DNS（域名解析）、SNMP（网络管理）、DHCP（动态主机配置）。</li><li>广播、多播：如局域网内的服务发现。</li></ul><h3 id="6-如果-UDP-数据包太大怎么办？"><a href="#6-如果-UDP-数据包太大怎么办？" class="headerlink" title="6. 如果 UDP 数据包太大怎么办？"></a>6. 如果 UDP 数据包太大怎么办？</h3><blockquote><p>分片就像是把大包裹拆成几个小包裹来寄。UDP 数据包太大时，IP 层会把它拆分。丢包就是这些小包裹在运输（网络传输）过程中丢失了。一旦有小包裹丢了，因为 UDP 不会重新发送，整个数据就用不了。</p></blockquote><p><strong>UDP 没分段机制，数据包大小受 MTU（最大传输单元）限制。</strong> 比如 IPv4 的 MTU 一般 1500 字节，减去 IP 头部（20 字节）和 UDP 头部（8 字节）后就是数据最大长度（<strong>最大 UDP 载荷约为 1472 字节</strong>）。超了就由 IP 层分片，像把大文件拆成小文件。但分片可能丢包，现代设备还可能拒绝分片。应对办法有控制数据大小、用路径 MTU 发现或改用 TCP 协议等。 </p><h3 id="7-UDP-的缓冲区"><a href="#7-UDP-的缓冲区" class="headerlink" title="7. UDP 的缓冲区"></a>7. UDP 的缓冲区</h3><p>UDP 无真正发送缓冲区，sendto 调用后数据直给内核再传网络层。它有接收缓冲区，但不能保证接收顺序与发送一致，若缓冲区满，新到的 UDP 数据会被丢弃。UDP 的 socket 可同时读写，具备全双工特性 。 </p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>049 HTTPS 协议原理</title>
      <link href="/posts/34998.html"/>
      <url>/posts/34998.html</url>
      
        <content type="html"><![CDATA[<h1 id="HTTPS-协议原理"><a href="#HTTPS-协议原理" class="headerlink" title="HTTPS 协议原理"></a>HTTPS 协议原理</h1><blockquote><p><a href="https://blog.csdn.net/weixin_51142926/article/details/143697206">Linux：HTTPS 协议原理 | CSDN（荐）</a></p><p><a href="https://blog.csdn.net/2402_83315537/article/details/147430000">LINUX 网络基础 [六] - HTTPS 协议 | CSDN</a></p></blockquote><p>先简单回顾一下 TCP&#x2F;IP 四层模型（视频剩余部分可作为了解）：<a href="https://www.bilibili.com/video/BV1Wf4y1E7qs/?share_source=copy_web&vd_source=872e5e3ccf44874c39edaf42e30ab0de">http 和 https 有什么区别吗？(SSL 协议) | B 站</a>。</p><h2 id="1-概念准备"><a href="#1-概念准备" class="headerlink" title="1. 概念准备"></a>1. 概念准备</h2><h3 id="1-HTTPS-是什么？"><a href="#1-HTTPS-是什么？" class="headerlink" title="1. HTTPS 是什么？"></a>1. HTTPS 是什么？</h3><p>HTTPS（HyperText Transfer Protocol Secure）是一个 <strong>应用层协议</strong>，可以理解为是 HTTP 协议的“安全版”。</p><ul><li><strong>核心区别</strong>：在 HTTP 协议的基础上引入了一个 <strong>加密层</strong>。</li><li><strong>原因</strong>：标准的 HTTP 协议是 <strong>明文传输</strong> 的，这意味着传输的数据（如账号、密码、个人信息）在经过路由器、运营商等网络设备时，很容易被“劫持”或“篡改”（例如“运营商劫持”下载链接）。</li><li><strong>目的</strong>：通过加密，保证用户的信息安全，防止数据在传输过程中被窃取或篡改。</li></ul><h3 id="2-什么是加密？"><a href="#2-什么是加密？" class="headerlink" title="2. 什么是加密？"></a>2. 什么是加密？</h3><ul><li><strong>加密</strong>：将要传输的原始信息（称为 <strong>明文</strong>）通过一系列数学变换，生成一段不可读的、看似随机的文本（称为 <strong>密文</strong>）的过程。</li><li><strong>解密</strong>：将 <strong>密文</strong> 通过一系列变换，还原成原始 <strong>明文</strong> 的过程。</li><li><strong><a href="https://baike.baidu.com/item/%E5%AF%86%E9%92%A5/101144?fromModule=lemma_inlink">密钥</a></strong>：在加密和解密过程中，需要用到一个或多个关键数据，这个数据就叫做 <strong>密钥</strong>。它是加密算法的核心，决定了加密和解密的具体方式。</li></ul><h3 id="3-为什么要加密？"><a href="#3-为什么要加密？" class="headerlink" title="3. 为什么要加密？"></a>3. 为什么要加密？</h3><p>主要原因是为了应对网络传输中的安全威胁，特别是 <strong>中间人攻击（Man-in-the-Middle Attack, 简称 MITM 攻击）</strong>。</p><ul><li><strong>明文传输的风险</strong>：HTTP 的明文数据在传输过程中会经过多个物理节点（路由器、运营商等）。任何能接触到这些节点的人都可以 <strong>窃取</strong> 我们的隐私信息（如登录密码、支付信息），甚至可以 <strong>篡改</strong> 传输的内容（如将运营商设备篡改下载链接等等）。</li><li><strong>加密的作用</strong>：通过对信息进行加密，即使数据被劫持，黑客看到的也只是无法理解的密文，从而保护了信息的机密性和完整性。</li></ul><h3 id="4-常见的加密方式"><a href="#4-常见的加密方式" class="headerlink" title="4. 常见的加密方式"></a>4. 常见的加密方式</h3><blockquote><p>下面这些视频我认为讲的非常好，虽然标题各式各样的，但是内容和我们要讲的基本一致，超出的知识就当扩展了，<strong>如果后面的文字讲解难懂，建议先看视频</strong> 👉：</p><p><a href="https://www.bilibili.com/video/BV1RT411272Y/?share_source=copy_web&vd_source=872e5e3ccf44874c39edaf42e30ab0de">HTTPS 是什么?原理是什么？用公钥加密为什么不能用公钥解密？ | B 站</a></p><p><a href="https://www.bilibili.com/video/BV1KY411x7Jp/?share_source=copy_web&vd_source=872e5e3ccf44874c39edaf42e30ab0de">HTTPS 是什么？加密原理和证书。SSL&#x2F;TLS 握手过程 | B 站</a></p><p><a href="https://www.bilibili.com/video/BV1P5k3YHEGo/?share_source=copy_web&vd_source=872e5e3ccf44874c39edaf42e30ab0de">HTTPS 真的安全吗，一个动画秒懂！ | B 站</a></p><p><a href="https://www.bilibili.com/video/BV1tAKozuEkd/?share_source=copy_web&vd_source=872e5e3ccf44874c39edaf42e30ab0de">白话 HTTPS，如何在全世界的眼皮子底下安全密谋？ | B 站</a></p><p><a href="https://www.bilibili.com/video/BV1w7ADeLEPE/?share_source=copy_web&vd_source=872e5e3ccf44874c39edaf42e30ab0de">https 真安全么？ 抓包解密 https 的两种原理+实战  开源软件 mitmproxy 与 wireshark 如何抓包 https | B 站</a></p><p><a href="https://www.bilibili.com/video/BV1mj421d7VE/?share_source=copy_web&vd_source=872e5e3ccf44874c39edaf42e30ab0de">数字签名和 CA 数字证书的核心原理和作用 B 站</a></p><p><a href="https://www.bilibili.com/video/BV1FX4y1C76v/?share_source=copy_web&vd_source=872e5e3ccf44874c39edaf42e30ab0de">12 分钟弄懂 HTTPS 概念与原理 &#x2F; HTTPS 入门教程 | B 站</a></p></blockquote><h4 id="1-对称加密"><a href="#1-对称加密" class="headerlink" title="1. 对称加密"></a>1. 对称加密</h4><ul><li><strong>原理</strong>：使用 <strong>同一个密钥</strong> 进行加密和解密。这个密钥必须由通信双方共同持有。</li><li><strong>特点</strong>：<ul><li><strong>优点</strong>：算法公开、计算量小、<strong>加密速度快、效率高</strong>。</li><li><strong>缺点</strong>：最大的问题是 <strong>密钥的分发</strong>。如何安全地把这个“共享密钥”告诉对方？如果通过网络明文传输密钥，那么密钥本身就会被截获，整个加密就形同虚设。</li></ul></li><li><strong>常见算法</strong>：DES、3DES、AES 等。</li><li><strong>简单示例</strong>：按位异或（XOR）操作。用密钥 <code>key</code> 对明文 <code>a</code> 加密得到密文 <code>b</code>（<code>a ^ key = b</code>），再用同一个密钥 <code>key</code> 对密文 <code>b</code> 解密就能得到明文 <code>a</code>（<code>b ^ key = a</code>）。</li></ul><h4 id="2-非对称加密"><a href="#2-非对称加密" class="headerlink" title="2. 非对称加密"></a>2. 非对称加密</h4><ul><li><strong>原理</strong>：使用 <strong>一对</strong> 密钥，一个 **公钥 ** 和一个 <strong>私钥</strong>。公钥和私钥是成对生成的，它们之间有特殊的数学关系。</li><li><strong>工作方式</strong>：<ul><li>用 <strong>公钥</strong> 加密，只能用对应的 <strong>私钥</strong> 解密。</li><li>用 <strong>私钥</strong> 加密（这通常称为“签名”），只能用对应的 <strong>公钥</strong> 解密（这通常称为“验证”）。</li></ul></li><li><strong>特点</strong>：<ul><li><strong>优点</strong>：解决了密钥分发问题。公钥可以公开给任何人，而私钥自己严格保密。即使公钥被截获，没有私钥也无法解密。</li><li><strong>缺点</strong>：算法复杂，<strong>加密和解密速度比对称加密慢很多</strong>。</li></ul></li><li><strong>常见算法</strong>：RSA、DSA、ECDSA 等。</li><li><strong>生活中的例子</strong>：公钥就像一把 <strong>锁</strong>，可以公开分发。任何人想给你发秘密文件，就把文件放进盒子并用这把“锁”锁上。只有你拥有对应的“钥匙”（私钥），才能打开盒子取出文件。</li></ul><h4 id="3-数据摘要-数据指纹"><a href="#3-数据摘要-数据指纹" class="headerlink" title="3. 数据摘要 &amp;&amp; 数据指纹"></a>3. 数据摘要 &amp;&amp; 数据指纹</h4><blockquote><p><strong>摘要</strong> 就是把 <strong>任意长度的数据</strong>，通过 <strong>Hash 函数</strong> 变成一个 <strong>定长的“指纹”或“身份证”（对原始数据进行单向哈希运算后得到的一串固定长度的字符串）</strong>，能用来验证数据完整性；数据指纹类似，也是通过算法提取数据特征，可用于识别和区分不同数据，它们都像数据的独特 “标识”。</p><p><strong>数据摘要的特点：</strong></p><ul><li><strong>不可逆</strong>：从摘要推不回原文。</li><li><strong>雪崩效应</strong>：原文哪怕改 1 个字节，摘要都会完全不同。</li><li><strong>长度固定</strong>：无论原文多大，都能快速生成摘要，摘要结果都是固定长度（比如 256 位）。</li><li><strong>确定性</strong>：相同输入 → 相同输出。</li><li><strong>抗碰撞性</strong>：极难找到两个不同内容生成相同摘要（防伪造）。</li></ul><p><strong>数据摘要可以理解为：原文 &#x3D; 一大堆内容，摘要 &#x3D; “身份证号” 或 “指纹”（唯一标识这个内容，改了就对不上）。</strong></p></blockquote><ul><li><strong>原理</strong>：利用 <strong>单向散列函数</strong>（Hash 函数，如 <a href="https://zh.wikipedia.org/wiki/MD5"><strong>MD5</strong></a>、SHA1、SHA256）对任意长度的数据进行计算，生成一个 <strong>固定长度</strong> 的、唯一的“数字指纹”或“摘要”。</li><li><strong>关键特性</strong>：<ul><li><strong>定长</strong>：无论输入多长，输出的摘要长度是固定的。</li><li><strong>分散</strong>：输入数据哪怕只改变一个比特，生成的摘要也会发生巨大变化。</li><li><strong>不可逆</strong>：无法从摘要反推出原始数据。</li><li><strong>防碰撞</strong>：理论上不同的数据可能产生相同的摘要（碰撞），但概率极低。</li></ul></li><li><strong>用途</strong>：<strong>严格来说，这不是加密</strong>，因为它没有解密过程。它主要用于 <strong>验证数据的完整性</strong>。接收方可以自己计算收到数据的摘要，然后与发送方提供的摘要进行比对。如果一致，说明数据在传输过程中没有被篡改。</li></ul><h4 id="4-数字签名（后面细说）"><a href="#4-数字签名（后面细说）" class="headerlink" title="4. 数字签名（后面细说）"></a>4. 数字签名（后面细说）</h4><ul><li><strong>原理</strong>：数字签名 &#x3D; <strong>数据摘要 + 非对称加密</strong>。<ol><li>对原始数据（明文）计算一个 <strong>数据摘要</strong>。</li><li>使用发送方的 <strong>私钥</strong> 对这个 <strong>摘要</strong> 进行加密，得到的结果就是 <strong>数字签名</strong>。</li></ol></li><li><strong>验证过程</strong>：<ol><li>接收方收到原始数据和数字签名。</li><li>用发送方的 <strong>公钥</strong> 解密数字签名，得到一个摘要值（我们称之为 <code>摘要A</code>）。</li><li>接收方自己用相同的哈希算法对收到的原始数据计算摘要（我们称之为 <code>摘要B</code>）。</li><li>比较 <code>摘要A</code> 和 <code>摘要B</code>。如果相等，则说明：<ul><li><strong>数据完整性</strong>：数据未被篡改（因为摘要匹配）。</li><li><strong>身份认证</strong>：签名确实是由持有对应私钥的人生成的（因为只有他的公钥才能成功解密）。</li></ul></li></ol></li><li><strong>作用</strong>：数字签名解决了“<strong>我是谁</strong>”和“<strong>内容是否被改过</strong>”的问题。</li></ul><hr><h2 id="2-HTTPS-的-5-种方案探究"><a href="#2-HTTPS-的-5-种方案探究" class="headerlink" title="2. HTTPS 的 5 种方案探究"></a>2. HTTPS 的 5 种方案探究</h2><blockquote><ul><li><p><strong>对称加密</strong>：加密和解密使用同一个密钥。速度快，适合大量数据加密。</p></li><li><p><strong>非对称加密</strong>：有一对密钥 —— 公钥（可公开）和私钥（必须保密）。公钥加密的数据，只有私钥能解密；私钥签名的数据，公钥可验证。优点：不怕公钥被截获；缺点：速度慢，不适合大数据加密。</p></li><li><p><strong>中间人攻击（MITM）</strong>：攻击者在通信双方中间截获、篡改、伪造信息。</p></li></ul></blockquote><h3 id="方案-1：只使用对称加密"><a href="#方案-1：只使用对称加密" class="headerlink" title="方案 1：只使用对称加密"></a>方案 1：只使用对称加密</h3><h4 id="1-场景"><a href="#1-场景" class="headerlink" title="1. 场景"></a>1. 场景</h4><p>客户端和服务器约定用同一个密钥（比如 “123456”）来加密通信。</p><h4 id="2-密钥如何传输？"><a href="#2-密钥如何传输？" class="headerlink" title="2. 密钥如何传输？"></a>2. 密钥如何传输？</h4><p>必须提前“共享”密钥。比如：客户端和服务器事先约定好密钥（不现实，互联网用户千千万），或者，客户端第一次访问时，服务器“明文发送”密钥给客户端。</p><h4 id="3-风险在哪里？"><a href="#3-风险在哪里？" class="headerlink" title="3. 风险在哪里？"></a>3. 风险在哪里？</h4><p><strong>密钥在传输过程中被截获！</strong> 比如：客户端请求：“请给我密钥”，服务器回复：“密钥是 123456” ← 被黑客监听到，之后所有通信，黑客用 123456 解密 → <strong>完全裸奔！</strong></p><h4 id="4-产生的问题"><a href="#4-产生的问题" class="headerlink" title="4. 产生的问题"></a>4. 产生的问题</h4><p>密钥无法安全传递（除非物理见面，不现实），每个用户都要不同密钥？服务器怎么管理？一旦密钥泄露，所有通信都暴露。</p><blockquote><p> 就像我们和朋友约好用同一把钥匙开保险箱，但我们必须先把钥匙寄给他 —— 快递员（黑客）偷了钥匙，就能开你的保险箱。</p></blockquote><h3 id="方案-2：只使用非对称加密"><a href="#方案-2：只使用非对称加密" class="headerlink" title="方案 2：只使用非对称加密"></a>方案 2：只使用非对称加密</h3><h4 id="1-场景-1"><a href="#1-场景-1" class="headerlink" title="1. 场景"></a>1. 场景</h4><p>服务器有公钥和私钥。客户端用服务器的公钥加密数据，服务器用自己的私钥解密。</p><h4 id="2-密钥如何传输？-1"><a href="#2-密钥如何传输？-1" class="headerlink" title="2. 密钥如何传输？"></a>2. 密钥如何传输？</h4><p>服务器把自己的 <strong>公钥</strong> 发给客户端（公钥不怕被截获）→ 客户端用公钥加密数据 → 服务器用私钥解密。</p><h4 id="3-风险在哪里？-1"><a href="#3-风险在哪里？-1" class="headerlink" title="3. 风险在哪里？"></a>3. 风险在哪里？</h4><p><strong>性能问题 + 无法双向加密：</strong></p><ol><li><strong>性能极差</strong>：非对称加密计算量大，传个网页都要几秒，用户体验爆炸。</li><li><strong>服务器无法加密发给客户端</strong>：客户端没有私钥，服务器如果想加密数据发给客户端，必须知道客户端的公钥 —— 但客户端没有公私钥对！如果让客户端也生成公私钥，那就变成方案 3 了。</li></ol><blockquote><p>就像每次寄信都要用特制保险箱（非对称加密），寄一封信要花 10 分钟打包，收件人还要花 10 分钟拆 —— 寄 100 封信？系统崩溃！</p></blockquote><h3 id="方案-3：双方都使用非对称加密"><a href="#方案-3：双方都使用非对称加密" class="headerlink" title="方案 3：双方都使用非对称加密"></a>方案 3：双方都使用非对称加密</h3><h4 id="1-场景-2"><a href="#1-场景-2" class="headerlink" title="1. 场景"></a>1. 场景</h4><p>客户端和服务器各自生成自己的公私钥对。互相交换公钥，然后用对方的公钥加密数据发给对方。</p><h4 id="2-密钥如何传输？-2"><a href="#2-密钥如何传输？-2" class="headerlink" title="2. 密钥如何传输？"></a>2. 密钥如何传输？</h4><p>客户端生成公私钥，把公钥发给服务器 → 服务器生成公私钥，把公钥发给客户端 → 双方用对方公钥加密，用自己的私钥解密。</p><h4 id="3-风险在哪里？-2"><a href="#3-风险在哪里？-2" class="headerlink" title="3. 风险在哪里？"></a>3. 风险在哪里？</h4><p><strong>中间人攻击（MITM）！</strong> 黑客可以这样干：</p><ol><li>客户端 → “我要和服务器通信，请给我公钥”。</li><li>黑客截获，伪造自己是服务器，把自己的公钥发给客户端。</li><li>客户端 → 用“假公钥”加密数据 → 黑客收到后用自己的私钥解密 → 再用真服务器的公钥加密转发。</li><li>服务器 → 回复，黑客同样截获 → 用客户端的假公钥加密再发回去。</li></ol><p><strong>客户端和服务器以为在安全通信，其实所有数据都被黑客看到并转发！</strong></p><h4 id="4-产生的问题-1"><a href="#4-产生的问题-1" class="headerlink" title="4. 产生的问题"></a>4. 产生的问题</h4><ul><li>无法确认“公钥是谁的” —— 公钥被掉包都不知道！  </li><li>性能依然差（非对称加密慢）  </li><li>管理复杂（每个会话都要生成密钥对）</li></ul><blockquote><p>就像我们和朋友交换“加密信箱钥匙”，但快递员偷偷把自己的钥匙塞给我们，说“这是我朋友的”。我寄信给他，他全都能看，再模仿我朋友回信 —— 我们完全被蒙在鼓里！</p></blockquote><h3 id="方案-4：非对称加密-对称加密（混合方案）"><a href="#方案-4：非对称加密-对称加密（混合方案）" class="headerlink" title="方案 4：非对称加密 + 对称加密（混合方案）"></a>方案 4：非对称加密 + 对称加密（混合方案）</h3><blockquote><p>方案 4 在 TLS 1.2 里常见，但 TLS 1.3 已经弃用。现在都用 ECDHE（椭圆曲线 Diffie-Hellman Ephemeral） 做 密钥协商，这样即使服务器长期私钥泄露，历史流量也解不开（前向保密）。换句话说：<strong>对称密钥不是传输过来的，而是双方独立算出来的。</strong></p></blockquote><h4 id="1-场景-3"><a href="#1-场景-3" class="headerlink" title="1. 场景"></a>1. 场景</h4><p>用非对称加密来 <strong>安全传递对称密钥</strong>，之后用对称密钥加密通信数据。</p><h4 id="2-密钥如何传输？-3"><a href="#2-密钥如何传输？-3" class="headerlink" title="2. 密钥如何传输？"></a>2. 密钥如何传输？</h4><ol><li>客户端连接服务器，服务器发送自己的 <strong>公钥</strong>（比如通过证书）  </li><li>客户端生成一个随机的 <strong>对称密钥</strong>（如 AES 密钥）  </li><li>客户端用服务器的 <strong>公钥</strong> 加密这个对称密钥 → 发送给服务器  </li><li>服务器用自己的 <strong>私钥</strong> 解密 → 得到对称密钥  </li><li>之后所有通信，都用这个对称密钥加密&#x2F;解密！</li></ol><h4 id="3-风险在哪里？-3"><a href="#3-风险在哪里？-3" class="headerlink" title="3. 风险在哪里？"></a>3. 风险在哪里？</h4><p><strong>如果公钥是假的，对称密钥就会被黑客截获！</strong> 还是中间人攻击：</p><ol><li>黑客伪造服务器，把自己的公钥发给客户端  </li><li>客户端生成对称密钥，用“假公钥”加密 → 黑客用自己的私钥解密 → 得到真实对称密钥  </li><li>黑客再用真服务器的公钥加密对称密钥发给服务器  </li><li>之后所有通信，黑客都能用对称密钥解密！</li></ol><p><strong>问题根源：客户端无法确认收到的公钥是不是真的属于目标服务器！</strong></p><h4 id="4-优缺点"><a href="#4-优缺点" class="headerlink" title="4. 优缺点"></a>4. 优缺点</h4><ol><li><p>优点：</p><ul><li><p>对称加密快，适合大数据  </p></li><li><p>非对称只用于传密钥，计算量小</p></li></ul></li><li><p>缺点：</p><ul><li>公钥真实性无法保证 → 需要“身份认证”</li></ul></li></ol><blockquote><p>就像我们用防弹车（非对称加密）把保险箱钥匙（对称密钥）送到朋友家，但送错了地址（假服务器），钥匙被坏人拿到，之后我们寄的所有东西他都能打开！</p></blockquote><h3 id="方案-5（最终方案）非对称加密-对称加密-数字证书（HTTPS-真实方案）"><a href="#方案-5（最终方案）非对称加密-对称加密-数字证书（HTTPS-真实方案）" class="headerlink" title="方案 5（最终方案）非对称加密 + 对称加密 + 数字证书（HTTPS 真实方案）"></a>方案 5（最终方案）非对称加密 + 对称加密 + 数字证书（HTTPS 真实方案）</h3><h4 id="1-场景-4"><a href="#1-场景-4" class="headerlink" title="1. 场景"></a>1. 场景</h4><p>在方案 4 基础上，加入 <strong>数字证书</strong> 来验证服务器公钥的真实性！</p><h4 id="2-密钥如何传输？-4"><a href="#2-密钥如何传输？-4" class="headerlink" title="2. 密钥如何传输？"></a>2. 密钥如何传输？</h4><ol><li><strong>客户端发起 HTTPS 请求</strong> → 服务器返回 <strong>数字证书</strong>（包含服务器公钥 + 服务器身份信息 + <a href="https://zh.wikipedia.org/wiki/%E8%AF%81%E4%B9%A6%E9%A2%81%E5%8F%91%E6%9C%BA%E6%9E%84">CA</a> 签名）  </li><li><strong>客户端验证证书</strong>：<ul><li>用操作系统&#x2F;浏览器内置的 <strong>CA 公钥</strong> 验证证书签名是否合法  </li><li>检查证书是否过期、域名是否匹配等 → 如果验证失败，浏览器弹出警告</li></ul></li><li><strong>客户端生成随机对称密钥</strong>（如 AES-256）  </li><li><strong>客户端用证书里的服务器公钥加密对称密钥</strong> → 发送给服务器  </li><li><strong>服务器用自己的私钥解密</strong> → 得到对称密钥  </li><li><strong>之后所有通信都用对称密钥加密</strong>（高效、安全）</li></ol><h4 id="3-如何防御中间人攻击？"><a href="#3-如何防御中间人攻击？" class="headerlink" title="3. 如何防御中间人攻击？"></a>3. 如何防御中间人攻击？</h4><p><strong>数字证书由可信第三方（CA）签名</strong>，黑客无法伪造合法证书！黑客即使拦截通信，也无法伪造一个被 CA 签名的证书（除非攻破 CA，极难），客户端会校验证书，发现域名不符或签名无效 → 直接终止连接！</p><h4 id="4-补充安全机制（了解）"><a href="#4-补充安全机制（了解）" class="headerlink" title="4. 补充安全机制（了解）"></a>4. 补充安全机制（了解）</h4><ul><li><strong>前向保密（PFS）</strong>：每次会话生成临时密钥，即使服务器私钥未来泄露，历史会话也无法解密。（通过 ECDHE 等密钥交换算法实现）  </li><li><strong>证书吊销机制（CRL&#x2F;OCSP）</strong>：应对私钥泄露或证书被盗用。</li></ul><hr><h3 id="5-小结"><a href="#5-小结" class="headerlink" title="5. 小结"></a>5. 小结</h3><table><thead><tr><th>方案</th><th>加密方式</th><th>密钥传输方式</th><th>主要风险</th><th>是否可行</th></tr></thead><tbody><tr><td>方案 1</td><td>对称加密</td><td>明文传输或预共享</td><td>密钥被截获 → 全部暴露</td><td>❌ 不可行</td></tr><tr><td>方案 2</td><td>非对称加密</td><td>公钥公开传输</td><td>性能差 + 无法双向加密</td><td>❌ 不实用</td></tr><tr><td>方案 3</td><td>双方非对称</td><td>交换公钥</td><td>中间人攻击（公钥被替换&#x2F;掉包）</td><td>❌ 不安全</td></tr><tr><td>方案 4</td><td>非对称+对称（混合加密）</td><td>用公钥加密对称密钥</td><td>中间人攻击（公钥未认证，MITM 截获）</td><td>⚠️ 有漏洞</td></tr><tr><td>最终方案</td><td>混合 + 证书</td><td>用认证公钥加密对称密钥</td><td>依赖 CA 体系保障（极少数被攻破案例）</td><td>✅ 安全高效</td></tr></tbody></table><blockquote><p>之前看到的一个很形象、易理解的比喻：想象你要和朋友安全通信：</p><ul><li><strong>方案 1</strong>：你俩约好用同一把钥匙，但你得先寄给他 → 快递员偷了钥匙 → 完蛋。  </li><li><strong>方案 2</strong>：每次说话都用特制密码机，太慢 → 聊两句就卡死。  </li><li><strong>方案 3</strong>：你俩交换密码机的“公开使用说明”，但快递员把自己的说明书冒充你朋友的 → 你按他的说明书操作，他在偷听。  </li><li><strong>方案 4</strong>：你寄一把普通钥匙，但用朋友的“防伪密码箱”寄 → 但如果“防伪密码箱”是假的（快递员给的），钥匙还是被偷。  </li><li><strong>最终方案</strong>：朋友的“防伪密码箱”上有 <strong>公安局盖章认证</strong>（CA 证书）→ 你一看盖章是真的，才放心寄钥匙 → 安全！</li></ul></blockquote><h4 id="1-为什么-HTTPS-最终选择这个方案？"><a href="#1-为什么-HTTPS-最终选择这个方案？" class="headerlink" title="1. 为什么 HTTPS 最终选择这个方案？"></a>1. 为什么 HTTPS 最终选择这个方案？</h4><ol><li><strong>效率高</strong>：对称加密处理海量数据。</li><li><strong>安全强</strong>：非对称加密保护密钥传输。</li><li><strong>身份可信</strong>：CA 证书防止公钥被伪造。</li><li><strong>可扩展</strong>：支持前向保密、吊销、多域名等。</li></ol><h4 id="2-附加：密钥被攻击的几种真实场景"><a href="#2-附加：密钥被攻击的几种真实场景" class="headerlink" title="2. 附加：密钥被攻击的几种真实场景"></a>2. 附加：密钥被攻击的几种真实场景</h4><ol><li><strong>私钥泄露</strong>（服务器被入侵）→ 攻击者可解密历史通信（除非启用前向保密）。</li><li><strong>CA 被攻破</strong> → 攻击者可签发任意假证书（极罕见，如 DigiNotar 事件）。</li><li><strong>用户忽略证书警告</strong> → 主动接受假证书 → 中间人攻击成功。</li><li><strong>弱随机数生成器</strong> → 生成的对称密钥可预测 → 被破解。</li></ol><h3 id="6-理解链-承上启下"><a href="#6-理解链-承上启下" class="headerlink" title="6. 理解链 - 承上启下"></a>6. 理解链 - 承上启下</h3><h4 id="1-对-HTTP-进行对称加密，是否能解决数据通信安全的问题？问题是什么？"><a href="#1-对-HTTP-进行对称加密，是否能解决数据通信安全的问题？问题是什么？" class="headerlink" title="1. 对 HTTP 进行对称加密，是否能解决数据通信安全的问题？问题是什么？"></a>1. 对 HTTP 进行对称加密，是否能解决数据通信安全的问题？问题是什么？</h4><p><strong>不能完全解决，核心问题：密钥的分发。</strong></p><p>假设客户端和服务器都用同一个对称密钥来加密通信，这确实能防止第三方窃听。但是，这个密钥是如何从服务器安全地传递给客户端的呢？如果在连接建立之初，服务器直接把密钥明文发给客户端，那么中间人（黑客）同样可以截获这个密钥。一旦密钥泄露，后续所有的“加密”通信对中间人来说就等于没有加密。这就陷入了“<strong>先有鸡还是先有蛋</strong>”的困境：为了安全传输密钥，我们需要一个密钥来加密它，但这个“用来加密密钥的密钥”又该如何安全传输呢？</p><h4 id="2-为何要用非对称加密？"><a href="#2-为何要用非对称加密？" class="headerlink" title="2. 为何要用非对称加密？"></a>2. 为何要用非对称加密？</h4><p><strong>为了解决“密钥分发”问题</strong>。</p><p>非对称加密的特性（公钥加密，私钥解密）完美地解决了这个问题。服务器可以将自己的 <strong>公钥</strong> 通过明文的方式发送给客户端。客户端用这个公钥加密一个 <strong>对称密钥</strong> 后发送给服务器。即使中间人截获了这个加密后的对称密钥，他也无法解密，因为他没有服务器的 <strong>私钥</strong>。只有服务器能用自己的私钥解密，从而安全地获得对称密钥。</p><h4 id="3-为何不全用非对称加密？"><a href="#3-为何不全用非对称加密？" class="headerlink" title="3. 为何不全用非对称加密？"></a>3. 为何不全用非对称加密？</h4><p><strong>主要原因是性能</strong>。</p><p>非对称加密的算法非常复杂，其 <strong>加密和解密的速度远远慢于对称加密</strong>。如果整个 HTTPS 通信过程都使用非对称加密，会极大地消耗服务器和客户端的计算资源，导致网页加载速度变慢，用户体验很差。<strong>因此，最佳实践是结合两者</strong>：使用非对称加密来安全地 <strong>协商</strong> 一个临时的对称密钥，然后在后续的大量数据传输中，使用这个对称密钥进行高效加密。这就是 HTTPS 的核心工作原理。</p><h4 id="4-CA-签名认证-VS-数字证书-VS-数字签名"><a href="#4-CA-签名认证-VS-数字证书-VS-数字签名" class="headerlink" title="4. CA 签名认证 VS 数字证书 VS 数字签名"></a>4. CA 签名认证 VS 数字证书 VS 数字签名</h4><p><strong>数字签名、数字证书、CA 签名认证</strong> 这三样东西经常被混在一起说，但它们 <strong>不是一个东西</strong>，而是三个环环相扣的概念：<strong><code>CA 签名认证  →  产生合法的数字证书  →  证书里面包含数字签名</code>。</strong></p><ol><li><p><strong>数字签名：</strong> 就是“用私钥对一段数据做的签名”，任何人都能用对应的公钥验证签名是否有效。<strong>用途：</strong> 保证数据没有被篡改（完整性）、保证数据确实是“私钥持有者”发的（身份认证）。<strong>简单例子：</strong></p><ul><li>服务器把自己的公钥信息、域名信息打个包 → 用私钥生成一个签名。</li><li>客户端用服务器的公钥验证签名，能验证这份数据确实出自服务器本人。</li><li>类比：数字签名 &#x3D; 手写签名&#x2F;盖章。别人可以看到签名，验证是你签的，但没法伪造。</li></ul></li><li><p><strong>数字证书：</strong> 一份“带身份证明的公钥”，里面包含：服务器的公钥、服务器的域名信息（比如 <code>www.google.com</code>）、有效期、用途等信息、还有一个 <strong>数字签名</strong>（由 CA 生成的）。</p><ul><li><strong>用途：</strong> 客户端拿到证书后，不仅知道“这是公钥”，还知道“这个公钥是属于哪个网站的”，解决了“公钥是谁的”这个问题。</li><li><strong>类比：</strong> 数字证书 &#x3D; 身份证。身份证上写着你的名字（域名）、照片（公钥），还有公安局的盖章（CA 签名）。</li></ul></li><li><p><strong>CA 签名认证：</strong> 就是证书里的“盖章”部分 —— 证书不是服务器自己随便说“这是我的身份证”，而是交给权威机构（CA，证书颁发机构）去验证，然后 <strong>CA 用自己的私钥签名</strong>，证明这份证书是真的。</p><ul><li><p><strong>流程：</strong></p><ol><li>服务器 → 提交公钥 + 域名信息给 CA。</li><li>CA 审核（域名验证、公司验证等）。</li><li>CA 用自己的 <strong>私钥</strong> 对证书做数字签名。</li><li>浏览器内置了各大 CA 的 <strong>公钥</strong> → 可以验证证书签名是否有效。</li></ol></li><li><p><strong>用途：</strong> 确保证书是真的，不是黑客自己伪造的，确认公钥确实属于 <code>www.xxx.com</code>。</p></li></ul><blockquote><p>  类比：CA 签名认证 &#x3D; 公安局给身份证盖章。别人一看章是真的，就知道身份证不是假造的。</p></blockquote></li></ol><h2 id="3-关于-HTTPS-的一些扩展和思考"><a href="#3-关于-HTTPS-的一些扩展和思考" class="headerlink" title="3. 关于 HTTPS 的一些扩展和思考"></a>3. 关于 HTTPS 的一些扩展和思考</h2><h3 id="1-CA-签名流程是不是先做摘要？"><a href="#1-CA-签名流程是不是先做摘要？" class="headerlink" title="1. CA 签名流程是不是先做摘要？"></a>1. CA 签名流程是不是先做摘要？</h3><p><strong>是的。</strong> CA 在给证书签名时，先对证书内容（域名、公钥、有效期等）做 <strong>Hash 得到摘要</strong>，再用 <strong>CA 私钥加密摘要</strong> → 得到 <strong>数字签名</strong> → 把签名 + 原始证书信息一起 <strong>发送</strong> 给客户端。<strong>证书 &#x3D; 明文信息 + 签名，签名 &#x3D; 用私钥加密“数据的摘要”</strong>。浏览器验证时：先用相同算法对证书内容 hash，再用 CA 公钥解密签名得到摘要，两者对比 → 确认证书没被篡改。</p><h3 id="2-为什么数字签名（如-CA-对证书签名）不直接用私钥加密原始数据（如证书或任意文件），而要先对数据做-Hash-生成摘要，再对摘要进行加密签名？"><a href="#2-为什么数字签名（如-CA-对证书签名）不直接用私钥加密原始数据（如证书或任意文件），而要先对数据做-Hash-生成摘要，再对摘要进行加密签名？" class="headerlink" title="2. 为什么数字签名（如 CA 对证书签名）不直接用私钥加密原始数据（如证书或任意文件），而要先对数据做 Hash 生成摘要，再对摘要进行加密签名？"></a>2. 为什么数字签名（如 CA 对证书签名）不直接用私钥加密原始数据（如证书或任意文件），而要先对数据做 Hash 生成摘要，再对摘要进行加密签名？</h3><p>因为直接用私钥加密原始数据 <strong>效率极低</strong> —— 非对称加密计算慢，且受数据长度限制，不适合大文件或频繁操作；而先对数据做 Hash 生成固定长度的“摘要”，再加密摘要，既大幅 <strong>提升签名速度</strong>，又 <strong>保证了安全性</strong>。更重要的是，Hash 摘要具备“雪崩效应”和抗篡改性：哪怕原文改动一个字节，摘要也会彻底改变，接收方通过比对摘要即可验证完整性。同时，先 Hash 还能 <strong>防御</strong>“长度扩展攻击”等密码学漏洞，确保签名机制在各种场景下（如证书、文件、消息）都安全、高效、标准化。</p><p><strong>所以标准流程：原文 → Hash(摘要) → 用私钥加密(签名)。客户端验证时：收到原文 &amp; 签名 → 原文重新 Hash → 用公钥解密签名 &#x3D; 摘要 → 两个摘要比对一致 → 证明原文没改、签名有效。</strong></p><h3 id="3-如何成为中间人（MITM）"><a href="#3-如何成为中间人（MITM）" class="headerlink" title="3. 如何成为中间人（MITM）"></a>3. 如何成为中间人（MITM）</h3><h4 id="1-ARP-欺骗"><a href="#1-ARP-欺骗" class="headerlink" title="1. ARP 欺骗"></a>1. ARP 欺骗</h4><p>局域网里，电脑通信需要知道对方的 MAC 地址。ARP（地址解析协议）就是负责“IP ↔ MAC 地址绑定”。<strong>漏洞</strong>：ARP 没有验证机制，谁说自己是某个 IP 就信。<strong>攻击方法</strong>：黑客冒充别人：</p><ul><li>主机 A 想访问主机 B → 先广播“B 的 MAC 地址谁知道？”</li><li>黑客抢答：“我是 B，我的 MAC 是 xxx”</li><li>结果 A 把流量都发给黑客，黑客再转发给 B → 黑客变中间人。</li></ul><p>就像在班里传纸条，A 想传给 B，黑客插话说“我就是 B，把纸条给我” → 再偷偷看一眼转交给真 B。</p><h4 id="2-ICMP-重定向攻击"><a href="#2-ICMP-重定向攻击" class="headerlink" title="2. ICMP 重定向攻击"></a>2. ICMP 重定向攻击</h4><p>ICMP 协议里有一种“重定向消息”，路由器可以告诉主机：“嘿，这个目标地址，你应该走另一条更好的路”。<strong>漏洞</strong>：ICMP 没验证，谁都能发。<strong>攻击方法</strong>：</p><ul><li>黑客伪造 ICMP 消息，告诉受害者“要访问外网，请经过我这台路由器”。</li><li>结果受害者的所有流量都经过黑客机器。</li></ul><p>就像问路，路人甲（黑客）冒充警察说“你要去市中心？从我家后门穿过去更快” → 结果你绕进了陷阱。</p><h4 id="3-假-WiFi-假网站"><a href="#3-假-WiFi-假网站" class="headerlink" title="3. 假 WiFi &#x2F; 假网站"></a>3. 假 WiFi &#x2F; 假网站</h4><ul><li><strong>假 WiFi（所谓的钓鱼网络）</strong>：黑客开个和真 WiFi 同名的热点，用户连上去后，所有流量都经过黑客电脑 → 可以监控&#x2F;篡改数据。</li><li><strong>假网站</strong>：黑客在局域网或 DNS 劫持，把 <code>www.google.com</code> 映射到自己控制的假服务器 → 用户以为在访问银行，其实是黑客的钓鱼网站。</li></ul><p>就像黑客开了一家“假银行”，外观和真的一样，但柜员全是演员，用户输入账号密码就等于都交给了他。<strong>本质：中间人就是把流量骗到自己手里，再决定是“只偷听”还是“修改后转发”。</strong></p><h4 id="4-HTTPS-中间人（需用户配合或证书漏洞）"><a href="#4-HTTPS-中间人（需用户配合或证书漏洞）" class="headerlink" title="4. HTTPS 中间人（需用户配合或证书漏洞）"></a>4. HTTPS 中间人（需用户配合或证书漏洞）</h4><p><strong>原理：伪造 SSL 证书，骗浏览器信任。</strong> 操作：黑客作为中间人，拦截 HTTPS 请求 伪造一个“假证书”发给客户端（如自签名或盗用 CA），如果用户点击“继续访问（不安全）”，则攻击成功，防御：浏览器会警告“证书不受信任”，我们用户不点“忽略”就攻不破。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>048 HTTP 协议</title>
      <link href="/posts/63840.html"/>
      <url>/posts/63840.html</url>
      
        <content type="html"><![CDATA[<h1 id="HTTP-协议"><a href="#HTTP-协议" class="headerlink" title="HTTP 协议"></a>HTTP 协议</h1><blockquote><p><a href="https://t4dmw.blog.csdn.net/article/details/123313047">HTTP 协议详解 | CSDN</a></p><p><a href="https://blog.csdn.net/loss_rose777/article/details/132919997?spm=1001.2014.3001.5502">HTTP 协议（超级详细） | CSDN</a></p></blockquote><h2 id="1-HTTP-是什么"><a href="#1-HTTP-是什么" class="headerlink" title="1. HTTP 是什么"></a>1. HTTP 是什么</h2><p>虽然我们说应用层协议是我们程序猿自己定的，但实际上，已经有大佬们定义了一些现成的，又非常好用的应用层协议，供我们直接参考使用。HTTP 就是其中之一，HTTP 全称 <strong>HyperText Transfer Protocol（超文本传输协议）</strong>，它是一个 <strong>应用层协议</strong>，专门规定了浏览器和服务器之间怎么对话。简单来说，就是：</p><ul><li>浏览器（客户端）：“我要资源 A。”</li><li>服务器：“好的，给你资源 A。”</li></ul><p>HTTP 负责 <strong>传输规则</strong>，至于你传的是 HTML、图片、视频、JSON，它根本不管。</p><h2 id="2-工作流程"><a href="#2-工作流程" class="headerlink" title="2. 工作流程"></a>2. 工作流程</h2><p>HTTP 基本流程就是 <strong>请求-响应模型</strong>：</p><ol><li>客户端发起请求（Request）。</li><li>服务器返回响应（Response）。</li></ol><p>请求和响应里，都是一堆 <strong>报文</strong>（Headers + Body），有点像两个人通信时带着信封和正文。</p><h2 id="3-认识-URL"><a href="#3-认识-URL" class="headerlink" title="3. 认识 URL"></a>3. 认识 URL</h2><p>URL（统一资源定位符，Uniform Resource Locator）其实就是“网络上的地址”，就像现实生活中的“国家 → 城市 → 街道 → 门牌号”。<br> 它一共有 <strong>7 个部分</strong>，每个部分都有职责。我们用一个例子来拆开看：</p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250822160233435.png" alt="PixPin_2025-08-22_16-02-22"></p><h3 id="1-协议方案名（scheme）"><a href="#1-协议方案名（scheme）" class="headerlink" title="1. 协议方案名（scheme）"></a>1. 协议方案名（scheme）</h3><p><strong>作用</strong>：指定使用哪种协议来访问资源。这是整个 URL 的“开头”，告诉浏览器该用什么方式去获取资源。常见值：</p><ul><li><code>http</code>：超文本传输协议（不加密）。</li><li><code>https</code>：安全的 HTTP（加密）。</li><li><code>ftp</code>：文件传输协议。</li><li><code>mailto</code>：发送邮件。</li><li><code>file</code>：本地文件。</li></ul><h3 id="2-登录信息（认证信息）"><a href="#2-登录信息（认证信息）" class="headerlink" title="2. 登录信息（认证信息）"></a>2. 登录信息（认证信息）</h3><p><strong>作用</strong>：有些协议可以在 URL 中写用户名和密码，用来登录。<strong>格式</strong>：<code>username:password@</code>，比如：<code>http://admin:123456@myserver.com</code>。注意：现在几乎不用了，因为明文暴露账号密码，巨危险。现代认证一般靠 Token、Cookie、OAuth。</p><h3 id="3-服务器地址（host）"><a href="#3-服务器地址（host）" class="headerlink" title="3. 服务器地址（host）"></a>3. 服务器地址（host）</h3><p><strong>作用</strong>：指定目标服务器的域名或 IP 地址。说明：可以是域名（如 <code>www.example.jp</code>），也可以是 IP 地址（如 <code>192.168.1.1</code>），浏览器先通过 <strong>DNS</strong> 把域名解析成 IP，再去找目标机器。例如：<code>www.baidu.com</code> 就是百度的域名。 </p><p>网络通信的关键是 IP 和端口号，所以只要知道某个网站的 <strong>IP 地址</strong> 和它运行服务的 <strong>端口号</strong>（通常是 80 或 443），就可以直接通过这个 IP 访问它。当然也存在不能访问的情况：服务器直接禁止使用 IP 地址访问、端口未开放、需要额外身份验证或配置等。<strong>域名 &#x3D; IP 的“人类友好版本”</strong>，人记不住 <code>39.156.70.37</code> 这样的数字，所以发明了 <strong>域名系统 DNS</strong>，当输入 <code>baidu.com</code> 时，DNS 会自动查出它对应的 IP 地址 → <code>39.156.70.37</code>，这就是所谓的：</p><ul><li><strong>序列化</strong>：把 <code>baidu.com</code> 转成 <code>39.156.70.37</code>（解析）</li><li><strong>反序列化</strong>：把 <code>39.156.70.37</code> 映射回 <code>baidu.com</code>（反向查询）</li></ul><blockquote><p>  但注意：<strong>域名本身不包含端口信息</strong>。端口默认是 80（HTTP）或 443（HTTPS），除非特别指定。 </p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250822162939678.png" alt="PixPin_2025-08-22_16-29-36"></p><h3 id="4-服务器端口号（port）"><a href="#4-服务器端口号（port）" class="headerlink" title="4. 服务器端口号（port）"></a>4. 服务器端口号（port）</h3><p><strong>作用</strong>：指定服务器上监听的端口，一般情况下 URL 里省略不写。<strong>如果省略</strong>，则使用默认端口，HTTP 默认端口是 80，HTTPS 默认端口是 443。如果用了非默认端口，必须写出来，否则无法连接，<strong>格式：</strong> IP 地址：端口号 </p><h3 id="5-文件路径（path）"><a href="#5-文件路径（path）" class="headerlink" title="5. 文件路径（path）"></a>5. 文件路径（path）</h3><p><strong>作用</strong>：指定服务器上资源的具体路径（类似文件夹结构）。说明：大多数情况下路径从根目录开始（以 <code>/</code> 开头），表示要访问的网页、图片、API 接口等，但也可以配置非根目录下。</p><h3 id="6-查询字符串（Query-String）"><a href="#6-查询字符串（Query-String）" class="headerlink" title="6. 查询字符串（Query String）"></a>6. 查询字符串（Query String）</h3><p><strong>作用</strong>：向服务器传递额外参数，常用于搜索、筛选、用户标识等。通常在 <code>GET</code> 请求里用，格式是 <code>key=value</code>，多个参数用 <code>&amp;</code> 连接，例如：<code>?search=Python&amp;page=2</code> 表示搜索 Python 第 2 页。特点：</p><ul><li>参数由 <code>&amp;</code> 分隔</li><li>键值对之间用 <code>=</code> 连接</li><li>会被发送到服务器，但不会保存在页面中（除非显式存储）</li></ul><h3 id="7-片段标识符（fragment）"><a href="#7-片段标识符（fragment）" class="headerlink" title="7. 片段标识符（fragment）"></a>7. 片段标识符（fragment）</h3><p>片段标识符又叫 <strong>锚点，作用：</strong> 表示页面里的某个位置（控制页面滚动位置）。浏览器拿到页面后，会自动滚动到对应的位置（比如某一章节）。注意：片段不会传给服务器，它只在客户端（浏览器）起作用。</p><blockquote><p>所以 URL 的 7 个部分完整结构：<code>协议://登录信息@服务器地址:端口号/路径?查询字符串#片段</code>。</p></blockquote><h2 id="4-urlencode-和-urldecode"><a href="#4-urlencode-和-urldecode" class="headerlink" title="4. urlencode 和 urldecode"></a>4. urlencode 和 urldecode</h2><p><strong><code>urlencode</code> 是把不安全或特殊字符转成 “URL 能安全传输” 的格式；<code>urldecode</code> 是把它还原回来。</strong> </p><p>像 <code>／？：</code> 等这样的字符，已经被 URL 当做特殊意义理解了，因此这些字符不能随意出现，比如某个参数中需要带有这些特殊字符，就必须先对特殊字符进行转义。</p><p>转义的规则如下：将需要转码的字符转为 16 进制，然后从右到左，取 4 位（不足 4 位直接处理），每 2 位做一位，前面加上%，编码成 %XY 格式。</p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250822233626966.png" alt="PixPin_2025-08-22_23-34-41"></p><p>两个工具 <a href="https://tool.chinaz.com/tools/urlencode.aspx">站长之家</a> 或 <a href="https://www.bejson.com/enc/urlencode/">Json 格式化</a> 可观察编码和解码的结果。</p><h2 id="5-HTTP-请求和响应"><a href="#5-HTTP-请求和响应" class="headerlink" title="5. HTTP 请求和响应"></a>5. HTTP 请求和响应</h2><h3 id="1-请求和响应报文的结构"><a href="#1-请求和响应报文的结构" class="headerlink" title="1. 请求和响应报文的结构"></a>1. 请求和响应报文的结构</h3><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250823001147423.png" alt="PixPin_2025-08-23_00-11-41"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">            HTTP 请求报文结构</span><br><span class="line">┌───────────────────────────────────────────┐</span><br><span class="line">│ &lt;method&gt;  &lt;request-target&gt;  &lt;http-version&gt; │ ← 请求行 (Request Line)</span><br><span class="line">├───────────────────────────────────────────┤</span><br><span class="line">│ Header-Name: Header-Value                 │</span><br><span class="line">│ Header-Name: Header-Value                 │ ← 请求头部 (Request Headers)</span><br><span class="line">│ ...                                       │</span><br><span class="line">│ Content-Length: &lt;length&gt;                  │</span><br><span class="line">├───────────────────────────────────────────┤</span><br><span class="line">│                                           │ ← 空行 (CRLF: \r\n)</span><br><span class="line">└───────────────────────────────────────────┘</span><br><span class="line">┌───────────────────────────────────────────┐</span><br><span class="line">│              &lt;request-body&gt;               │ ← 请求体 (可选)</span><br><span class="line">└───────────────────────────────────────────┘</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            HTTP 响应报文结构</span><br><span class="line">┌───────────────────────────────────────────┐</span><br><span class="line">│ &lt;http-version&gt; &lt;status-code&gt; &lt;reason-phrase&gt; │ ← 状态行 (Status Line)</span><br><span class="line">├───────────────────────────────────────────┤</span><br><span class="line">│ Header-Name: Header-Value                 │</span><br><span class="line">│ Header-Name: Header-Value                 │ ← 响应头部 (Response Headers)</span><br><span class="line">│ ...                                       │</span><br><span class="line">│ Content-Length: &lt;length&gt;                  │</span><br><span class="line">├───────────────────────────────────────────┤</span><br><span class="line">│                                           │ ← 空行 (CRLF: \r\n)</span><br><span class="line">└───────────────────────────────────────────┘</span><br><span class="line">┌───────────────────────────────────────────┐</span><br><span class="line">│              &lt;response-body&gt;              │ ← 响应体 (可选)</span><br><span class="line">└───────────────────────────────────────────┘</span><br></pre></td></tr></table></figure><h4 id="1-HTTP-请求报文结构"><a href="#1-HTTP-请求报文结构" class="headerlink" title="1. HTTP 请求报文结构"></a>1. HTTP 请求报文结构</h4><p>整体格式：见上图，共有 <strong>请求行、请求头部、空行、请求正文&#x2F;请求体（可选）</strong> 4 部分。</p><h5 id="1-请求行"><a href="#1-请求行" class="headerlink" title="1. 请求行"></a>1. 请求行</h5><p><strong>格式：</strong> <code>Method  URL  HTTP-Version</code>。</p><ol><li><p><strong>Method（方法）</strong>：请求方法，表示操作类型，说明要对资源做什么操作，常见方法：<code>GET</code>（获取资源）、<code>POST</code>（提交数据）、<code>PUT</code>（更新资源）、<code>DELETE</code>（删除资源）、<code>HEAD</code>（获取头部信息）、<code>OPTIONS</code>（查询支持的方法）等。</p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250823143453428.png" alt="PixPin_2025-08-23_14-34-44"></p></li><li><p><strong>URL（路径）</strong>：请求的目标资源的位置&#x2F;路径，比如 <code>/index.html</code>、<code>/api/user</code>。</p></li><li><p><strong>HTTP-Version（协议版本）</strong>：常见 <code>HTTP/1.0</code>、<code>HTTP/1.1</code>、<code>HTTP/2</code>、<code>HTTP/3</code>。</p></li></ol><blockquote><ul><li><code>HTTP/1.0</code>：早期版本，性能较差。</li><li><code>HTTP/1.1</code>：目前最广泛使用的版本。</li><li><code>HTTP/2</code>：提升性能，支持多路复用。</li><li><code>HTTP/3</code>：基于 UDP，进一步优化延迟”。</li></ul></blockquote><h5 id="2-请求头部"><a href="#2-请求头部" class="headerlink" title="2. 请求头部"></a>2. 请求头部</h5><p>由 <strong>若干个 <code>Key: Value</code> 形式的键值对</strong> 组成，每行一个，描述请求的 <strong>元信息</strong>，用于传递客户端的附加信息。</p><p>常见头部字段：</p><ul><li><code>Host</code>: 指定请求的目标主机名（必须存在）</li><li><code>User-Agent</code>: 标识客户端软件（如浏览器类型）</li><li><code>Content-Type</code>: 指明请求体的媒体类型（如 <code>application/json</code>、<code>application/x-www-form-urlencoded</code>）</li><li><code>Content-Length</code>: 请求体的字节数（若使用 <code>Transfer-Encoding: chunked</code> 可省略）</li><li><code>Authorization</code>: 认证信息（如 Bearer Token）</li><li><code>Cookie</code>: 发送存储在客户端的 Cookie</li></ul><blockquote><p>  头部字段不区分大小写，但通常首字母大写（如 <code>Content-Type</code>） 。</p></blockquote><h5 id="3-空行"><a href="#3-空行" class="headerlink" title="3. 空行"></a>3. 空行</h5><p>用 <code>\r\n</code>（回车 + 换行）表示，<strong>必须存在</strong>，用于分隔请求头和请求体。如果没有空行，服务器无法判断头部结束，会解析出错。 </p><h5 id="4-请求正文-体"><a href="#4-请求正文-体" class="headerlink" title="4. 请求正文&#x2F;体"></a>4. 请求正文&#x2F;体</h5><p>可选，用于存放实际传给服务器的数据。</p><hr><h4 id="2-HTTP-响应报文结构"><a href="#2-HTTP-响应报文结构" class="headerlink" title="2. HTTP 响应报文结构"></a>2. HTTP 响应报文结构</h4><p>整体格式：见上图，有 <strong>状态行、响应头、空行、响应正文&#x2F;响应体</strong> 4 部分。</p><h5 id="1-状态行"><a href="#1-状态行" class="headerlink" title="1. 状态行"></a>1. 状态行</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTTP-Version  Status-Code  Reason-Phrase</span><br></pre></td></tr></table></figure><ol><li><p><strong>HTTP-Version</strong>：同上，常见 <code>HTTP/1.0</code>、<code>HTTP/1.1</code>、<code>HTTP/2</code>、<code>HTTP/3</code>。</p></li><li><p><strong>Status-Code（状态码）</strong>：三位数字，表示处理结果。</p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250823143342110.png" alt="PixPin_2025-08-23_14-33-31"></p><p>常见：<code>200</code> 成功、<code>301</code> 永久重定向、<code>404</code> 未找到资源（客户端错误）、<code>500</code> 服务器内部错误。</p></li><li><p><strong>Reason-Phrase</strong>：状态码的简短文字描述，比如 <code>OK</code>、<code>Not Found</code>。</p></li></ol><blockquote><p><a href="https://www.runoob.com/http/http-status-codes.html">HTTP 状态码 | 菜鸟教程</a></p><p><a href="https://cloud.tencent.com.cn/developer/article/2540361">HTTP 状态码全部完整列表 | 腾讯云</a></p></blockquote><h5 id="2-响应头部"><a href="#2-响应头部" class="headerlink" title="2. 响应头部"></a>2. 响应头部</h5><p>同样是若干个 <code>Key: Value</code> 格式的键值对，描述服务端返回数据的元信息。</p><p>常见字段：</p><ul><li><code>Content-Type</code>: 响应体的媒体类型（如 <code>text/html</code>、<code>application/json</code>）。</li><li><code>Content-Length</code>: 响应体的字节数。</li><li><code>Server</code>: 服务器软件信息（如 Apache、Nginx）。</li><li><code>Set-Cookie</code>: 设置客户端 Cookie。</li><li><code>Location</code>: 重定向地址（配合 3xx 状态码）。</li><li><code>Cache-Control</code>: 缓存策略。</li><li><code>Date</code>: 响应生成时间。</li></ul><h5 id="3-空行-1"><a href="#3-空行-1" class="headerlink" title="3. 空行"></a>3. 空行</h5><p>同样用 <code>\r\n</code> 表示，<strong>必须存在</strong>，用于分隔响应头和响应体。</p><h5 id="4-响应正文-体"><a href="#4-响应正文-体" class="headerlink" title="4. 响应正文&#x2F;体"></a>4. 响应正文&#x2F;体</h5><p>服务器返回的实际内容。类型取决于 <code>Content-Type</code>：</p><ul><li><code>text/html</code> → HTML 页面</li><li><code>application/json</code> → JSON 数据</li><li><code>image/png</code> → 图片二进制</li><li><code>video/mp4</code> → 视频流</li></ul><h3 id="2-网络调试工具"><a href="#2-网络调试工具" class="headerlink" title="2. 网络调试工具"></a>2. 网络调试工具</h3><table><thead><tr><th>工具</th><th>定位</th><th>主要用途</th></tr></thead><tbody><tr><td><strong><a href="https://www.telerik.com/fiddler">Fiddler</a></strong></td><td>专业抓包代理（被动监听&#x2F;拦截）</td><td>捕获流量、调试网络、分析问题</td></tr><tr><td><strong><a href="https://www.postman.com/downloads/">Postman</a></strong></td><td>API 客户端（主动请求）</td><td>构造请求、测试接口、管理 API</td></tr></tbody></table><p>在 Linux 中，<code>telnet</code> 是一个基于 TCP 协议的远程登录与调试工具。简单说来，它就像一个 <strong>万能的 TCP 客户端</strong>，可以用它连接到任意 TCP 服务（HTTP、Redis……），然后手动输入命令。<strong>注意：Telnet 是明文传输，数据不加密，所以要小心使用，我们一般仅用来调试网络服务、测试端口连通性、模拟发送请求。</strong> 安装命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> yum install -y telnet<span class="comment"># -y 表示自动安装，不需要确认</span></span><br><span class="line"><span class="built_in">sudo</span> yum install telnet</span><br></pre></td></tr></table></figure><p>基本语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># telnet [主机名或IP地址] [端口号]，比如：</span></span><br><span class="line">telnet baidu.com 80</span><br><span class="line"><span class="comment"># 连通后的示例输出：</span></span><br><span class="line">Trying 220.181.7.203...</span><br><span class="line">Connected to baidu.com.</span><br><span class="line">Escape character is <span class="string">&#x27;^]&#x27;</span>.</span><br></pre></td></tr></table></figure><p>注意：如果省略端口号，默认连接远程主机的 23 端口（Telnet 服务默认端口）。退出 Telnet 连接： Telnet 交互界面中，按 Ctrl + ] 进入命令模式，然后输入 quit 退出。</p><h3 id="3-一个简单的-HTTP-服务器-Demo"><a href="#3-一个简单的-HTTP-服务器-Demo" class="headerlink" title="3. 一个简单的 HTTP 服务器 Demo"></a>3. 一个简单的 HTTP 服务器 Demo</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Socket.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Log.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">uint16_t</span> default_port = <span class="number">8082</span>;      <span class="comment">// 服务器默认监听端口</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> BUFFER_SIZE = <span class="number">10240</span>;                  <span class="comment">// 缓冲区大小，用于接收 HTTP 请求</span></span><br><span class="line"><span class="type">const</span> std::string wwwroot = <span class="string">&quot;./wwwroot&quot;</span>;        <span class="comment">// Web 根目录，所有静态资源都放在这个文件夹下</span></span><br><span class="line"><span class="type">const</span> std::string home_page = <span class="string">&quot;index.html&quot;</span>;     <span class="comment">// 主页文件名</span></span><br><span class="line"><span class="type">const</span> std::string sep = <span class="string">&quot;\r\n&quot;</span>;                 <span class="comment">// HTTP 请求行和头之间的分隔符</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Thread_Data</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Thread_Data</span>(<span class="type">int</span> fd)                         <span class="comment">// 构造函数：保存客户端 socket 文件描述符</span></span><br><span class="line">    : <span class="built_in">sockfd</span>(fd)</span><br><span class="line">    &#123;&#125;          </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> sockfd;                                 <span class="comment">// 客户端连接的 socket fd</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// HTTP 请求类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HTTP_Request</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::vector&lt;std::string&gt; req_header;</span><br><span class="line">    std::string text;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析结果</span></span><br><span class="line">    std::string method;                         <span class="comment">// 请求方法</span></span><br><span class="line">    std::string url;                            <span class="comment">// 请求 URL</span></span><br><span class="line">    std::string version;                        <span class="comment">// HTTP 版本</span></span><br><span class="line">    std::string file_path;                      <span class="comment">// 请求文件路径</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// HTTP_Request()</span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Deserialize</span><span class="params">(std::string req)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            std::<span class="type">size_t</span> pos = req.<span class="built_in">find</span>(sep);    <span class="comment">// 查找每行的结束位置（\r\n）</span></span><br><span class="line">            <span class="keyword">if</span>(pos == std::string::npos)        <span class="comment">// 找不到</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            std::string temp = req.<span class="built_in">substr</span>(<span class="number">0</span>, pos);          <span class="comment">// 提取当前行</span></span><br><span class="line">            <span class="keyword">if</span>(temp.<span class="built_in">empty</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;                          <span class="comment">// 空行表示请求头结束</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            req_header.<span class="built_in">push_back</span>(temp);</span><br><span class="line">            req = req.<span class="built_in">substr</span>(pos + <span class="number">2</span>);          <span class="comment">// 去掉当前行和分隔符</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        text = req;                             <span class="comment">// 剩余部分是请求正文，可能为空</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Parse</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::stringstream <span class="title">ss</span><span class="params">(req_header[<span class="number">0</span>])</span></span>;    <span class="comment">// 将请求行解析为字符串流</span></span><br><span class="line">        ss &gt;&gt; method &gt;&gt; url &gt;&gt; version;         <span class="comment">// 解析请求行</span></span><br><span class="line"></span><br><span class="line">        file_path = wwwroot;                    <span class="comment">// 默认请求文件路径为 wwwroot</span></span><br><span class="line">        <span class="keyword">if</span>(url == <span class="string">&quot;/&quot;</span> || url == <span class="string">&quot;index.html&quot;</span>)   <span class="comment">// 请求根目录或主页</span></span><br><span class="line">        &#123;</span><br><span class="line">            file_path += (<span class="string">&quot;/&quot;</span> + home_page);     <span class="comment">// 文件路径为 wwwroot/index.html</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            file_path += url;                   <span class="comment">// 请求文件路径为 wwwroot/url</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DebugPrint</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;it : req_header)</span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; it &lt;&lt; <span class="string">&quot;\n\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;method: &quot;</span> &lt;&lt; method &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;url: &quot;</span> &lt;&lt; url &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;version: &quot;</span> &lt;&lt; version &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;text: &quot;</span> &lt;&lt; text &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// HTTP 服务器类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HTTP_Server</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Sock listensock_;                           <span class="comment">// 监听 socket 封装对象</span></span><br><span class="line">    <span class="type">uint16_t</span> port_;                             <span class="comment">// 服务器监听端口号</span></span><br><span class="line">    std::unordered_map&lt;std::string, std::string&gt; content_type; <span class="comment">// MIME 映射表</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">HTTP_Server</span>(<span class="type">uint16_t</span> port = default_port)   <span class="comment">// 构造函数：初始化监听端口</span></span><br><span class="line">        : <span class="built_in">port_</span>(port)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ~<span class="built_in">HTTP_Server</span>()</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动服务器，进入主循环：监听 -&gt; 接收连接 -&gt; 为连接分配线程处理</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Start</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        listensock_.<span class="built_in">Socket</span>();                   <span class="comment">// 创建监听 socket</span></span><br><span class="line">        listensock_.<span class="built_in">Bind</span>(port_);                <span class="comment">// 绑定端口</span></span><br><span class="line">        listensock_.<span class="built_in">Listen</span>();                   <span class="comment">// 开始监听</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;)</span><br><span class="line">        &#123;</span><br><span class="line">            std::string clientip;</span><br><span class="line">            <span class="type">uint16_t</span> clientport;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 接受一个新连接（阻塞等待）</span></span><br><span class="line">            <span class="type">int</span> sockfd = listensock_.<span class="built_in">Accept</span>(&amp;clientip, &amp;clientport);</span><br><span class="line">            <span class="keyword">if</span> (sockfd &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;                       <span class="comment">// 失败则跳过，继续等待下一个连接</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">log_</span>(Info, <span class="string">&quot;get a new connect, sockfd: %d&quot;</span>, sockfd);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 为每个连接分配一个线程进行处理</span></span><br><span class="line">            <span class="type">pthread_t</span> tid;</span><br><span class="line">            Thread_Data* td = <span class="keyword">new</span> <span class="built_in">Thread_Data</span>(sockfd);</span><br><span class="line">            <span class="built_in">pthread_create</span>(&amp;tid, <span class="literal">nullptr</span>, Thread_Run, td);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理 HTTP 请求：读取请求报文，构造并发送 HTTP 响应</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">HandlerHttp1</span><span class="params">(<span class="type">int</span> sockfd)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">char</span> buf[BUFFER_SIZE];</span><br><span class="line">        <span class="type">ssize_t</span> n = <span class="built_in">recv</span>(sockfd, buf, BUFFER_SIZE - <span class="number">1</span>, <span class="number">0</span>);          <span class="comment">// 读取请求数据</span></span><br><span class="line">        <span class="keyword">if</span>(n &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            buf[n] = <span class="string">&#x27;\0&#x27;</span>;                      <span class="comment">// 添加字符串结束符</span></span><br><span class="line">            std::cout &lt;&lt; buf;</span><br><span class="line"></span><br><span class="line">            std::string text =<span class="string">&quot;Hello Linux!&quot;</span>;   <span class="comment">// 响应正文内容</span></span><br><span class="line"></span><br><span class="line">            std::string response_line = <span class="string">&quot;HTTP/1.1 200 OK\r\n&quot;</span>;      <span class="comment">// 状态行</span></span><br><span class="line">            std::string response_header = <span class="string">&quot;Content-Length: &quot;</span>;       <span class="comment">// 响应头</span></span><br><span class="line">            response_header += std::<span class="built_in">to_string</span>(text.<span class="built_in">size</span>());</span><br><span class="line">            response_header += <span class="string">&quot;\r\n&quot;</span>;</span><br><span class="line">            std::string blank_line = <span class="string">&quot;\r\n&quot;</span>;    <span class="comment">// 空行</span></span><br><span class="line"></span><br><span class="line">            std::string response = response_line;</span><br><span class="line">            response += response_header;</span><br><span class="line">            response += blank_line;</span><br><span class="line">            response += text;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">send</span>(sockfd, response.<span class="built_in">c_str</span>(), response.<span class="built_in">size</span>(), <span class="number">0</span>);     <span class="comment">// 发送响应</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">close</span>(sockfd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> std::string <span class="title">Read_Htmlfile</span><span class="params">(<span class="type">const</span> std::string &amp;path)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::ifstream <span class="title">in</span><span class="params">(path)</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(!in.<span class="built_in">is_open</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;404 Not Found&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        std::string content;</span><br><span class="line">        std::string line;</span><br><span class="line">        <span class="keyword">while</span>(std::<span class="built_in">getline</span>(in, line))</span><br><span class="line">        &#123;</span><br><span class="line">            content += line;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        in.<span class="built_in">close</span>();</span><br><span class="line">        <span class="keyword">return</span> content;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">HandlerHttp2</span><span class="params">(<span class="type">int</span> sockfd)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">char</span> buf[BUFFER_SIZE];</span><br><span class="line">        <span class="type">ssize_t</span> n = <span class="built_in">recv</span>(sockfd, buf, BUFFER_SIZE - <span class="number">1</span>, <span class="number">0</span>);          <span class="comment">// 读取请求数据</span></span><br><span class="line">        <span class="keyword">if</span>(n &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            buf[n] = <span class="string">&#x27;\0&#x27;</span>;                      <span class="comment">// 添加字符串结束符</span></span><br><span class="line">            std::cout &lt;&lt; buf;</span><br><span class="line"></span><br><span class="line">            std::string text = <span class="built_in">Read_Htmlfile</span>(<span class="string">&quot;wwwroot/index.html&quot;</span>); <span class="comment">// 读取并构造响应正文内容</span></span><br><span class="line"></span><br><span class="line">            std::string response_line = <span class="string">&quot;HTTP/1.1 200 OK\r\n&quot;</span>;      <span class="comment">// 状态行</span></span><br><span class="line">            std::string response_header = <span class="string">&quot;Content-Length: &quot;</span>;       <span class="comment">// 响应头</span></span><br><span class="line">            response_header += std::<span class="built_in">to_string</span>(text.<span class="built_in">size</span>());</span><br><span class="line">            response_header += <span class="string">&quot;\r\n&quot;</span>;</span><br><span class="line">            std::string blank_line = <span class="string">&quot;\r\n&quot;</span>;    <span class="comment">// 空行</span></span><br><span class="line"></span><br><span class="line">            std::string response = response_line;</span><br><span class="line">            response += response_header;</span><br><span class="line">            response += blank_line;</span><br><span class="line">            response += text;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">send</span>(sockfd, response.<span class="built_in">c_str</span>(), response.<span class="built_in">size</span>(), <span class="number">0</span>);     <span class="comment">// 发送响应</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">close</span>(sockfd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">HandlerHttp3</span><span class="params">(<span class="type">int</span> sockfd)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">char</span> buf[BUFFER_SIZE];</span><br><span class="line">        <span class="type">ssize_t</span> n = <span class="built_in">recv</span>(sockfd, buf, BUFFER_SIZE - <span class="number">1</span>, <span class="number">0</span>);          <span class="comment">// 读取请求数据</span></span><br><span class="line">        <span class="keyword">if</span>(n &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            buf[n] = <span class="string">&#x27;\0&#x27;</span>;                      <span class="comment">// 添加字符串结束符</span></span><br><span class="line">            std::cout &lt;&lt; buf;</span><br><span class="line"></span><br><span class="line">            HTTP_Request req;</span><br><span class="line">            req.<span class="built_in">Deserialize</span>(buf);</span><br><span class="line">            req.<span class="built_in">Parse</span>();</span><br><span class="line">            req.<span class="built_in">DebugPrint</span>();</span><br><span class="line"></span><br><span class="line">            std::string text = <span class="built_in">Read_Htmlfile</span>(req.file_path);        <span class="comment">// 读取并构造响应正文内容</span></span><br><span class="line"></span><br><span class="line">            std::string response_line = <span class="string">&quot;HTTP/1.1 200 OK\r\n&quot;</span>;      <span class="comment">// 状态行</span></span><br><span class="line">            std::string response_header = <span class="string">&quot;Content-Length: &quot;</span>;       <span class="comment">// 响应头</span></span><br><span class="line">            response_header += std::<span class="built_in">to_string</span>(text.<span class="built_in">size</span>());</span><br><span class="line">            response_header += <span class="string">&quot;\r\n&quot;</span>;</span><br><span class="line">            std::string blank_line = <span class="string">&quot;\r\n&quot;</span>;    <span class="comment">// 空行</span></span><br><span class="line"></span><br><span class="line">            std::string response = response_line;</span><br><span class="line">            response += response_header;</span><br><span class="line">            response += blank_line;</span><br><span class="line">            response += text;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">send</span>(sockfd, response.<span class="built_in">c_str</span>(), response.<span class="built_in">size</span>(), <span class="number">0</span>);     <span class="comment">// 发送响应</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">close</span>(sockfd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">HandlerHttp4</span><span class="params">(<span class="type">int</span> sockfd)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">char</span> buf[BUFFER_SIZE];</span><br><span class="line">        <span class="type">ssize_t</span> n = <span class="built_in">recv</span>(sockfd, buf, BUFFER_SIZE - <span class="number">1</span>, <span class="number">0</span>);          <span class="comment">// 读取请求数据</span></span><br><span class="line">        <span class="keyword">if</span>(n &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            buf[n] = <span class="string">&#x27;\0&#x27;</span>;                      <span class="comment">// 添加字符串结束符</span></span><br><span class="line">            std::cout &lt;&lt; buf;</span><br><span class="line"></span><br><span class="line">            HTTP_Request req;</span><br><span class="line">            req.<span class="built_in">Deserialize</span>(buf);</span><br><span class="line">            req.<span class="built_in">Parse</span>();</span><br><span class="line">            req.<span class="built_in">DebugPrint</span>();</span><br><span class="line"></span><br><span class="line">            <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">            std::string text = <span class="built_in">Read_Htmlfile</span>(req.file_path);        <span class="comment">// 读取并构造响应正文内容</span></span><br><span class="line">            <span class="keyword">if</span>(text.<span class="built_in">empty</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                std::string err_thml = wwwroot + <span class="string">&quot;/err.html&quot;</span>;</span><br><span class="line">                text = <span class="built_in">Read_Htmlfile</span>(err_thml);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            std::string response_line;          <span class="comment">// 状态行</span></span><br><span class="line">            <span class="keyword">if</span>(flag)</span><br><span class="line">            &#123;</span><br><span class="line">                response_line = <span class="string">&quot;HTTP/1.1 200 OK\r\n&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                response_line = <span class="string">&quot;HTTP/1.1 404 Not Found\r\n&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            std::string response_header = <span class="string">&quot;Content-Length: &quot;</span>;       <span class="comment">// 响应头</span></span><br><span class="line">            response_header += std::<span class="built_in">to_string</span>(text.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 示例：重定向（可取消注释使用）</span></span><br><span class="line">            <span class="comment">//response_header += &quot;Location: https://minbit.top\r\n&quot;;</span></span><br><span class="line"></span><br><span class="line">            response_header += <span class="string">&quot;\r\n&quot;</span>;</span><br><span class="line">            std::string blank_line = <span class="string">&quot;\r\n&quot;</span>;    <span class="comment">// 空行</span></span><br><span class="line"></span><br><span class="line">            std::string response = response_line;</span><br><span class="line">            response += response_header;</span><br><span class="line">            response += blank_line;</span><br><span class="line">            response += text;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">send</span>(sockfd, response.<span class="built_in">c_str</span>(), response.<span class="built_in">size</span>(), <span class="number">0</span>);     <span class="comment">// 发送响应</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">close</span>(sockfd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程运行函数：分离线程 -&gt; 调用处理函数 -&gt; 清理资源</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="title">Thread_Run</span><span class="params">(<span class="type">void</span>* args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">pthread_detach</span>(<span class="built_in">pthread_self</span>());         <span class="comment">// 分离线程，自动回收资源</span></span><br><span class="line">        Thread_Data* td = <span class="built_in">static_cast</span>&lt;Thread_Data*&gt;(args);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用服务器请求处理函数，这里可以选择HandlerHttp1、HandlerHttp2、HandlerHttp3、HandlerHttp4进行不同处理</span></span><br><span class="line">        <span class="comment">// 然而，这些方法并不能使网页上的图片进行显示，原因是图片的Content-Type类型并没有被设置，因此需要在 HTTP 响应头中添加 Content-Type 字段</span></span><br><span class="line">        <span class="comment">// 于是我创建了HTTP_Server_image.hpp对图片（二进制）的处理，并在HTTP_Server_image.cc中调用HTTP_Server_image.hpp的处理函数</span></span><br><span class="line">        <span class="built_in">HandlerHttp4</span>(td-&gt;sockfd);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">delete</span> td;                              <span class="comment">// 释放申请的 Thread_Data</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>由于文件较多，不便展示，这里仅展示关键代码，完整代码详见 <a href="https://github.com/huangcancan-xbc/Linux/tree/master/coding/network/HTTP">GitHub</a>。食用方法：浏览器输入对应的 IP 和端口（示例：主机 IP：端口号），可选访问的路径，但是路径不存在就无法访问。👉 <a href="https://www.bilibili.com/video/BV16MexzkE8P/?share_source=copy_web&vd_source=872e5e3ccf44874c39edaf42e30ab0de">简单的 HTTP 服务器 Demo 演示 | B 站演示</a>。下面简单了解一下 HTTP 请求的请求头：</p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250824231803892.png" alt="PixPin_2025-08-24_23-17-53"></p><blockquote><p>User-Agent（用户代理）是服务器判断客户端身份的关键依据：一方面，爬虫可以通过伪装成真实浏览器的 User-Agent（如 Chrome、Edge 等）来绕过反爬虫机制，避免被封禁；另一方面，网站会根据 User-Agent 中包含的操作系统（如 Windows、Android）和设备类型，在浏览器中会自动推送对应版本的下载链接或适配页面，实现“你用什么设备访问，就给你什么内容”。</p></blockquote><h2 id="6-Cookie-和-Session"><a href="#6-Cookie-和-Session" class="headerlink" title="6. Cookie 和 Session"></a>6. Cookie 和 Session</h2><blockquote><p><a href="https://blog.csdn.net/m0_61832361/article/details/133021177">【HTTP】Cookie 和 Session 详解 | CSDN</a></p><p><a href="https://blog.csdn.net/chenlong_cxy/article/details/124787316">应用层协议 ——— HTTP 协议 | CSDN</a></p><p><a href="https://www.bilibili.com/video/BV1ob4y1Y7Ep/?share_source=copy_web&vd_source=872e5e3ccf44874c39edaf42e30ab0de">Cookie、Session、Token 究竟区别在哪？如何进行身份认证，保持用户登录状态？ | B 站</a></p><p><a href="https://www.bilibili.com/video/BV1eHoqYkEsA/?share_source=copy_web&vd_source=872e5e3ccf44874c39edaf42e30ab0de">浏览器是如何既保护又泄漏你的隐私？ | 从 Cookie、第三方 Cookie 到浏览器指纹 | B 站</a></p><p><a href="https://www.bilibili.com/video/BV1FsSoYdEUG/?share_source=copy_web&vd_source=872e5e3ccf44874c39edaf42e30ab0de">【白】竟然有这么多人不知道 cookie 是什么？雷普了！ | B 站</a></p><p><a href="https://www.bilibili.com/video/BV1tYgazjENg/?share_source=copy_web&vd_source=872e5e3ccf44874c39edaf42e30ab0de">程序员必看：cookie session token 这三者的区别与用途是什么？讲的最通透的一次！ | B 站</a></p><p><a href="https://www.bilibili.com/video/BV1a5411b7HU/?share_source=copy_web&vd_source=872e5e3ccf44874c39edaf42e30ab0de">【前端知识大科普】cookie 到底是什么？ | B 站</a></p></blockquote><blockquote><p>  [!TIP]</p><p>  <strong>上面的视频讲解非常详细，强烈建议观看，下面直接给结论，就不解释原因了。</strong></p></blockquote><h3 id="1-Cookie-基础"><a href="#1-Cookie-基础" class="headerlink" title="1. Cookie 基础"></a>1. Cookie 基础</h3><ol><li><strong>本质</strong>：存放在浏览器端的小型文本数据（<code>key = value</code> 格式），随请求头自动带到服务端。</li><li><strong>用途</strong>：<ul><li>记录用户身份（保持登录状态）。</li><li>存储用户偏好（语言、主题）。</li><li>实现统计&#x2F;追踪（广告、分析）。</li></ul></li><li><strong>分类</strong>：<ul><li><strong>会话 Cookie</strong>（内存级）：存放在内存中，关闭浏览器就没了。</li><li><strong>持久 Cookie</strong>（文件级）：写到磁盘里，有过期时间，可以长期保存。</li></ul></li><li><strong>重要属性</strong>：<ul><li><code>Expires/Max-Age</code>：过期时间。</li><li><code>HttpOnly</code>：JS 不能访问，防止 XSS。</li><li><code>Secure</code>：只能在 HTTPS 传输。</li><li><code>SameSite</code>：防止 CSRF 攻击。</li></ul></li></ol><h3 id="2-Session-基础"><a href="#2-Session-基础" class="headerlink" title="2. Session 基础"></a>2. Session 基础</h3><ol><li><strong>本质</strong>：存在 <strong>服务器端</strong> 的一份用户状态数据，通常用来保存登录信息、购物车等。</li><li><strong>关联方式</strong>：服务端会生成一个 <code>session_id</code>，通过 Cookie（或 URL 参数）传给浏览器。下次请求时，浏览器带上 <code>session_id</code>，服务端根据它找到该用户对应的 Session 数据。</li><li><strong>特点</strong>：<ul><li>更安全（数据不在客户端存，只保存一个 ID）。</li><li>存储空间大（由服务器控制，不受 Cookie 4KB 限制）。</li><li>需要服务器内存&#x2F;数据库支持。</li></ul></li></ol><h3 id="3-Cookie-vs-Session"><a href="#3-Cookie-vs-Session" class="headerlink" title="3. Cookie vs Session"></a>3. Cookie vs Session</h3><table><thead><tr><th>特点</th><th>Cookie (客户端存)</th><th>Session (服务端存)</th></tr></thead><tbody><tr><td>存储位置</td><td>浏览器</td><td>服务器</td></tr><tr><td>存储容量</td><td>单个 4KB，数量有限</td><td>理论无限，取决于服务器资源</td></tr><tr><td>安全性</td><td>容易被窃取&#x2F;篡改，需要加密</td><td>更安全，客户端只保存一个 ID</td></tr><tr><td>生命周期</td><td>由过期时间控制</td><td>一般随会话&#x2F;服务器配置而定</td></tr><tr><td>常见用途</td><td>记住登录状态、个性化配置</td><td>登录态验证、购物车、权限控制</td></tr></tbody></table><h3 id="4-扩展"><a href="#4-扩展" class="headerlink" title="4. 扩展"></a>4. 扩展</h3><ol><li><strong>为什么需要 Session，不能只靠 Cookie？</strong><ul><li>Cookie 存储在客户端，容易篡改、不安全，且存储空间有限；Session 更适合保存关键业务数据。</li></ul></li><li><strong>Session 的实现原理？</strong><ul><li>服务端维护一个 <code>session_id -&gt; 数据</code> 的映射表。客户端每次请求时带上 <code>session_id</code>（通常在 Cookie 里），服务端根据这个 ID 找回对应数据。</li></ul></li><li><strong>Cookie 被禁用了怎么办？</strong><ul><li>可以把 <code>session_id</code> 放到 URL 参数里，但安全性差，一般结合其他手段。</li></ul></li><li><strong>分布式部署时 Session 怎么保持一致？</strong><ul><li>需要做 <strong>Session 共享&#x2F;持久化</strong>，常用方法是把 Session 存在 Redis、数据库里，所有服务器共享。</li></ul></li><li><strong>Token（JWT）和 Session 的区别？</strong><ul><li>Session：状态保存在服务器。</li><li>Token（JWT）：状态保存在客户端（自包含），服务端只做校验，不保存状态，更适合分布式&#x2F;无状态架构。</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>047 网络传输基础：TCP 连接建立与数据序列化</title>
      <link href="/posts/38905.html"/>
      <url>/posts/38905.html</url>
      
        <content type="html"><![CDATA[<h1 id="网络传输基础：TCP-连接建立与数据序列化"><a href="#网络传输基础：TCP-连接建立与数据序列化" class="headerlink" title="网络传输基础：TCP 连接建立与数据序列化"></a>网络传输基础：TCP 连接建立与数据序列化</h1><h2 id="1-TCP-协议通信流程"><a href="#1-TCP-协议通信流程" class="headerlink" title="1. TCP 协议通信流程"></a>1. TCP 协议通信流程</h2><blockquote><p><a href="https://www.bilibili.com/video/BV1kV411j7hA/?share_source=copy_web&vd_source=872e5e3ccf44874c39edaf42e30ab0de">一条视频讲清楚 TCP 协议与 UDP 协议-什么是三次握手与四次挥手 | B 站</a></p><p><a href="https://www.bilibili.com/video/BV18h41187Ep/?share_source=copy_web&vd_source=872e5e3ccf44874c39edaf42e30ab0de">TCP 三次握手和四次挥手 | B 站</a></p><p><a href="https://www.bilibili.com/video/BV1e74dzYEM3/?share_source=copy_web&vd_source=872e5e3ccf44874c39edaf42e30ab0de">为什么 TCP 是三次握手四次挥手，其他次数不行吗 | B 站</a></p></blockquote><h3 id="1-通讯流程总览"><a href="#1-通讯流程总览" class="headerlink" title="1. 通讯流程总览"></a>1. 通讯流程总览</h3><p>下图是基于 TCP 协议的客户端&#x2F;服务器程序的一般流程：</p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250820001956049.png" alt="PixPin_2025-08-20_00-19-52"></p><h3 id="2-TCP-的“三次握手”和“四次挥手”"><a href="#2-TCP-的“三次握手”和“四次挥手”" class="headerlink" title="2. TCP 的“三次握手”和“四次挥手”"></a>2. TCP 的“三次握手”和“四次挥手”</h3><h4 id="1-三次握手——建立连接"><a href="#1-三次握手——建立连接" class="headerlink" title="1. 三次握手——建立连接"></a>1. 三次握手——建立连接</h4><p><strong>目的：确保客户端和服务器都能正常收发数据，建立双向通信连接。</strong></p><h5 id="1-过程描述"><a href="#1-过程描述" class="headerlink" title="1. 过程描述"></a>1. 过程描述</h5><ol><li><p><strong>第一次握手（SYN）</strong>  </p><ul><li>客户端发送一个 SYN 报文：SYN &#x3D; 1（同步序列号），挑个初始序号 seq &#x3D; x 给服务器。</li><li>表示“我想建立连接”，这边的起始序号是 x。</li><li>客户端进入 <code>SYN_SENT</code> 状态。</li></ul></li><li><p><strong>第二次握手（SYN+ACK）</strong>  </p><ul><li>服务器收到 SYN 后，回复一个 SYN+ACK 报文（SYN &#x3D; 1, ACK &#x3D; 1, 确认号 ack &#x3D; x+1，挑个自己的序号 seq &#x3D; y）。</li><li>表示“我收到了你的请求，我也准备好了”。</li><li>服务器进入 <code>SYN_RECEIVED</code> 状态。</li></ul></li><li><p><strong>第三次握手（ACK）</strong>  </p><ul><li>客户端收到 SYN+ACK 后，发送一个 ACK 报文（ACK &#x3D; 1, seq &#x3D; x+1, 确认号 ack &#x3D; y+1）。</li><li>表示“我也确认你的准备就绪”。</li><li>客户端进入 <code>ESTABLISHED</code> 状态。</li><li>服务器收到 ACK 后，也进入 <code>ESTABLISHED</code> 状态。</li></ul></li></ol><p>此时，连接建立完成，双方可以开始传输数据。</p><h5 id="2-为什么需要三次握手？（为什么不能两次？）"><a href="#2-为什么需要三次握手？（为什么不能两次？）" class="headerlink" title="2. 为什么需要三次握手？（为什么不能两次？）"></a>2. 为什么需要三次握手？（为什么不能两次？）</h5><p>举个生活例子（打电话）：想象你和朋友打电话：</p><ol><li>你打电话过去：<strong>“喂，听得到吗？”</strong>（第一次：SYN）</li><li>朋友说：<strong>“听得到！你听得到我吗？”</strong>（第二次：SYN+ACK）</li><li>你说：<strong>“听得到，开始说正事！”</strong>（第三次：ACK）</li></ol><p>这时候，双方都确认了：</p><ul><li>我能说话（能发）</li><li>我能听到（能收）</li><li>对方也能说话、也能听</li></ul><p><strong>如果只有两次握手会怎样？</strong></p><p>一个迟到的连接请求（SYN）到达服务器后，服务器会误以为是新请求，立即建立连接并分配资源，但客户端早已放弃，导致服务器白白等待、浪费资源。三次握手通过客户端的最后一次确认（ACK），确保只有真正的有效连接才能建立——如果请求过时，客户端不会回应，连接就不会完成。这就是为什么必须三次，不能两次。</p><blockquote><p><strong>所以：如果只有两次，客户端确认了服务端，但服务端还不确定客户端能否接收消息。三次握手是为了同步初始序列号、避免历史连接干扰、<span style="color:#FF0000;">确保双向</span>通信能力。</strong></p></blockquote><h4 id="2-四次挥手——断开连接"><a href="#2-四次挥手——断开连接" class="headerlink" title="2. 四次挥手——断开连接"></a>2. 四次挥手——断开连接</h4><p><strong>目的：安全、可靠地关闭双向连接。</strong></p><p>TCP 是全双工（两边能同时收发）的，断开时需要 <strong>分别关闭</strong> 发送方向。就像打电话，挂断要双方都说“我说完了”，否则可能有话丢失。因此，关闭连接时，每个方向都需要单独关闭。</p><blockquote><p><strong>简单理解：</strong></p><ul><li><strong>全双工：</strong> 通信双方都能随时收和发数据，互不影响。好比一条双向车道，车辆可以同时从两个方向行驶。</li><li>非全双工：</li><li><strong>半双工：</strong> 能双向通信，但不能同时，就像对讲机，一方说完另一方才能说。</li><li><strong>单工：</strong> 只能单向传数据，比如收音机接收广播信号，只能收不能发。</li></ul></blockquote><h5 id="1-过程描述-1"><a href="#1-过程描述-1" class="headerlink" title="1. 过程描述"></a>1. 过程描述</h5><ol><li><p><strong>第一次挥手（FIN）</strong>  </p><ul><li>客户端（主动关闭方）发送 FIN 报文（FIN &#x3D; 1, seq &#x3D; u）。</li><li>表示“我说完了，不想发数据了，但还能收”。</li><li>客户端进入 <code>FIN_WAIT_1</code> 状态。</li></ul></li><li><p><strong>第二次挥手（ACK）</strong>  </p><ul><li>服务器收到 FIN 后，发送 ACK 报文（ACK &#x3D; 1, seq &#x3D; v, ack &#x3D; u+1）。</li><li>表示“收到，你不发就不发吧，但我这边可能还有话要说”。</li><li>服务器进入 <code>CLOSE_WAIT</code> 状态。</li><li>客户端收到后，进入 <code>FIN_WAIT_2</code> 状态。</li><li>此时，<strong>客户端到服务器方向关闭</strong>，但服务器还可以继续发送数据。</li></ul></li><li><p><strong>第三次挥手（FIN）</strong>  </p><ul><li>服务器说完了（处理完剩余数据后），发送自己的 FIN 报文（FIN &#x3D; 1, ACK &#x3D; 1, seq &#x3D; w, ack &#x3D; u+1）。</li><li>表示“我也发完了，不发数据了，可以关闭了”。</li><li>服务器进入 <code>LAST_ACK</code> 状态。</li></ul></li><li><p><strong>第四次挥手（ACK）</strong>  </p><ul><li>客户端收到服务器的 FIN 后，发送 ACK 报文（ACK &#x3D; 1, seq &#x3D; u+1, ack &#x3D; w+1）。</li><li>表示：“收到，你也说完了”。</li><li>进入 <code>TIME_WAIT</code> 状态，等待 2MSL 后关闭。</li><li>服务器收到 ACK 后，进入 <code>CLOSED</code> 状态。</li></ul></li></ol><p>此时连接彻底关闭。</p><h5 id="2-为什么需要四次挥手？"><a href="#2-为什么需要四次挥手？" class="headerlink" title="2. 为什么需要四次挥手？"></a>2. 为什么需要四次挥手？</h5><p>因为 TCP 是 <strong>全双工</strong> 的，连接的两个方向是独立的。4 个方向要单独处理关闭，得四次挥手来确保数据完整传输。简单理解：就像下面这张图一样，4 个方向独立，每一次挥手关闭一条单向箭头，直到彻底关闭，当然关闭有一定的顺序，只是图中没有体现。</p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250820131906689.png" alt="PixPin_2025-08-20_13-18-54"></p><h5 id="3-为什么客户端要等待-2MSL？"><a href="#3-为什么客户端要等待-2MSL？" class="headerlink" title="3. 为什么客户端要等待 2MSL？"></a>3. 为什么客户端要等待 2MSL？</h5><ol><li><strong>确保最后一个 ACK 能到达服务器：</strong> 如果 ACK 丢失，服务器会重发 FIN，客户端必须能重发 ACK。</li><li><strong>让旧连接的报文在网络中消失：</strong> 防止旧连接的延迟报文干扰新连接（MSL 是报文在网络中存活的最长时间）。</li></ol><blockquote><p><strong>所以：四次挥手是为了<span style="color:#FF0000;">安全关闭双向连接</span>，保证数据不丢失，连接状态彻底清理。</strong></p></blockquote><hr><h3 id="3-形象理解"><a href="#3-形象理解" class="headerlink" title="3. 形象理解"></a>3. 形象理解</h3><ol><li><strong>三次握手</strong> → 像打电话：</li></ol><ul><li>A：“喂，你能听到吗？”（SYN）</li><li>B：“能听到，你能听到我吗？”（SYN+ACK）</li><li>A：“能听到，开始说吧。”（ACK）</li><li>→ 开始通话。</li></ul><ol start="2"><li><strong>四次挥手</strong> → 挂电话：</li></ol><ul><li>A：“我说完了，要挂了。”（FIN）</li><li>B：“我知道了，我还有话说。”（ACK）</li><li>（B 继续说）</li><li>B：“我也说完了，可以挂了。”（FIN）</li><li>A：“收到，拜拜。”（ACK）</li><li>→ 挂断。</li></ul><p>之前看到一个评论，分享给大家：</p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250820132734846.png" alt="PixPin_2025-08-20_13-27-12"></p><hr><h2 id="2-序列化和反序列化"><a href="#2-序列化和反序列化" class="headerlink" title="2. 序列化和反序列化"></a>2. 序列化和反序列化</h2><h3 id="1-反序列化就是“打包”和“解包”？"><a href="#1-反序列化就是“打包”和“解包”？" class="headerlink" title="1. 反序列化就是“打包”和“解包”？"></a>1. 反序列化就是“打包”和“解包”？</h3><ul><li><strong>序列化</strong>：把内存中的“数据”变成能保存或传输的“字符串或字节流”。类比把东西打包进箱子（变成能传输的格式）。</li><li><strong>反序列化</strong>：把“字符串或字节流”还原成程序能用的“数据”。对方拆箱，取出原物（还原成程序能用的数据）。</li></ul><p>想象你要寄一个玻璃花瓶：花瓶 &#x3D; 程序里的数据（比如一个对象，结构体），直接寄？会碎！所以要：<strong>打包 → 塞泡沫 → 装箱</strong>（这就是 <strong>序列化</strong>）；对方收到后：<strong>拆箱 → 拿出花瓶</strong>（这就是 <strong>反序列化</strong>）。一个简单的例子，直观感受一下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 序列化 = 把结构体“拍平”成一串字节</span></span><br><span class="line"><span class="comment">// 反序列化 = 按原样“重建”结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];  <span class="comment">// 姓名（固定长度）</span></span><br><span class="line">    <span class="type">int</span> age;        <span class="comment">// 年龄</span></span><br><span class="line">    <span class="type">float</span> height;   <span class="comment">// 身高</span></span><br><span class="line">    <span class="type">bool</span> isStudent; <span class="comment">// 是否学生</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原始数据</span></span><br><span class="line">Person p = &#123;<span class="string">&quot;Alice&quot;</span>, <span class="number">25</span>, <span class="number">1.65f</span>, <span class="literal">false</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 序列化：把结构体按内存布局转为字节流（简化示例表示）</span></span><br><span class="line"><span class="comment">// 实际字节流（十六进制近似）：</span></span><br><span class="line"><span class="comment">// 41 6C 69 63 65 00 ... [15字节补0] ... 19 00 00 00 3F 4A 00 00 00</span></span><br><span class="line"><span class="comment">// &quot;Alice\0&quot; + 填充 + age(25) + height(1.65) + isStudent(0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 反序列化：从字节流中按相同结构读取</span></span><br><span class="line">Person p2;</span><br><span class="line"><span class="comment">// 读 name → 读 age → 读 height → 读 isStudent</span></span><br><span class="line"><span class="comment">// 结果：p2 和 p 完全一样，成功还原！</span></span><br></pre></td></tr></table></figure><hr><h3 id="2-在网络传输中，是否一定需要序列化和反序列化？"><a href="#2-在网络传输中，是否一定需要序列化和反序列化？" class="headerlink" title="2. 在网络传输中，是否一定需要序列化和反序列化？"></a>2. 在网络传输中，是否一定需要序列化和反序列化？</h3><p><strong>几乎一定需要，</strong> 因为：内存中的数据（对象、结构体、类实例）是 <strong>程序内部格式</strong>，不能直接通过网络发送。网络只能传输 <strong>字节流</strong>，比如一串 0 和 1。所以必须先把数据“翻译”成字节流 → <strong>序列化</strong>，接收方再“翻译”回来 → <strong>反序列化</strong>。</p><p>如果只是传一个整数、一个字符串，直接 <code>send()</code>&#x2F;<code>recv()</code> 就能搞定，甚至用 <code>memcpy</code> 把结构体转成字节流也能传。像这种小 demo、进程间通信，这种“裸字节”就够了。但在绝大多数的情况，要完成复杂的网络通信时，<strong>所有跨进程、跨机器的数据传输，都绕不开序列化。</strong></p><h3 id="3-序列化和大小端有关系吗？"><a href="#3-序列化和大小端有关系吗？" class="headerlink" title="3. 序列化和大小端有关系吗？"></a>3. 序列化和大小端有关系吗？</h3><p><strong>有关系，但只在特定格式下才需要关心。</strong></p><p>在内存里，一个 <code>int=0x12345678</code>，在 <strong>小端机器</strong> 上存储是 <code>78 56 34 12</code>，在 <strong>大端机器</strong> 上存储是 <code>12 34 56 78</code>。如果直接把 <code>int</code> 的内存发过去，接收方解析时字节顺序不同，值就错了。所以序列化要么：</p><ol><li>明确规定用 <strong>网络字节序（大端）</strong>（像 TCP&#x2F;IP 协议族就是这样）。</li><li>或者用高层格式（比如 JSON、Protobuf），里面数字都用字符串&#x2F;标准二进制编码，不依赖机器字节序（以后详解）。</li></ol><p><strong>结论：序列化的意义之一就是屏蔽大小端差异，保证不同机器都能正确解读。还有一个优点：即使不同系统、语言之间，只要遵循相同序列化协议，也能准确交换数据。</strong></p><blockquote><p>网络传输中，TCP&#x2F;UDP 虽规定整数需用大端字节序（网络字节序），但这只解决多字节整数的字节顺序问题；而序列化是将复杂数据结构（如结构体、字符串、浮点数等）转换为可传输的字节流的完整过程，包括字段顺序、类型表示、对齐处理等，网络字节序只是序列化中的一个环节。两者不是一回事，网络字节序解决的是“传输层的整数格式统一”，序列化解决的是“应用层数据结构的描述和还原”。</p></blockquote><h3 id="4-序列化的格式是自定义的，还是有标准？"><a href="#4-序列化的格式是自定义的，还是有标准？" class="headerlink" title="4. 序列化的格式是自定义的，还是有标准？"></a>4. 序列化的格式是自定义的，还是有标准？</h3><p><strong>两者都有，一般强烈建议用标准格式。</strong> 标准格式有很多，优点：跨语言、有库、安全、性能好。这部分以后再说。自定义格式不推荐，一般适用于我们的 demo。比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name:zhangsan|age:25|city:beijing</span><br><span class="line">name:zhangsan\nage:25\ncity:beijing</span><br></pre></td></tr></table></figure><p>用一些特殊字符&#x2F;手段进行分割，然后自己再按照特定的格式进行解析。</p><hr><h3 id="5-网络计算器"><a href="#5-网络计算器" class="headerlink" title="5. 网络计算器"></a>5. 网络计算器</h3><blockquote><p><a href="https://blog.csdn.net/chenlong_cxy/article/details/124751991">认识“协议” | CSDN</a></p><p><a href="https://blog.csdn.net/m0_74774759/article/details/136155128?spm=1001.2014.3001.5502">【Linux】简单的网络计算器的实现（自定义协议，序列化，反序列化）| CSDN</a></p><p><a href="https://classmate-han.blog.csdn.net/article/details/137719408?spm=1001.2014.3001.5502">Linux 序列化、反序列化、实现网络版计算器 | CSDN</a></p></blockquote><p>这部分文件较多，代码较长，感兴趣可移步至 <a href="https://github.com/huangcancan-xbc/Linux/tree/master/coding/network/Network%20Calculator">GitHub</a> 观看。</p><h3 id="6-使用-json-进行序列化和反序列化"><a href="#6-使用-json-进行序列化和反序列化" class="headerlink" title="6. 使用 json 进行序列化和反序列化"></a>6. 使用 json 进行序列化和反序列化</h3><blockquote><p>JSON 和这个 protocol 在进行序列化和反序列化当中非常广泛，通常不需要我们自定义序列化的格式，通常只有在数据结构复杂、高性能的场景下才会使用自定义其格式，比如游戏行业、工业控制领域、对性能要求极高的系统间通信。</p></blockquote><p><strong>jsoncpp</strong> 库是一个非常成熟和经典的 C++ JSON 库，在许多 Linux 发行版中都是默认的 JSON 库选择。</p><h4 id="1-安装-JsonCpp（使用-yum）"><a href="#1-安装-JsonCpp（使用-yum）" class="headerlink" title="1. 安装 JsonCpp（使用 yum）"></a>1. 安装 JsonCpp（使用 yum）</h4><h5 id="1-安装命令"><a href="#1-安装命令" class="headerlink" title="1. 安装命令"></a>1. 安装命令</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> yum install jsoncpp-devel</span><br></pre></td></tr></table></figure><h5 id="2-验证是否安装成功"><a href="#2-验证是否安装成功" class="headerlink" title="2. 验证是否安装成功"></a>2. 验证是否安装成功</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> /usr/include/jsoncpp/json<span class="comment"># 检查头文件</span></span><br><span class="line"><span class="built_in">ls</span> /usr/lib64/libjsoncpp*<span class="comment"># 检查库文件位置</span></span><br></pre></td></tr></table></figure><h4 id="2-JsonCpp-简单的使用（序列化-反序列化）"><a href="#2-JsonCpp-简单的使用（序列化-反序列化）" class="headerlink" title="2. JsonCpp 简单的使用（序列化 &amp; 反序列化）"></a>2. JsonCpp 简单的使用（序列化 &amp; 反序列化）</h4><table><thead><tr><th align="left">场景</th><th align="left">代码</th></tr></thead><tbody><tr><td align="left"><strong>定义</strong></td><td align="left"><code>Json::Value v;</code></td></tr><tr><td align="left"><strong>赋值</strong></td><td align="left"><code>v[&quot;key&quot;] = value;</code></td></tr><tr><td align="left"><strong>数组添加</strong></td><td align="left"><code>v.append(item);</code></td></tr><tr><td align="left"><strong>转字符串</strong></td><td align="left"><code>Json::writeString(builder, v)</code></td></tr><tr><td align="left"><strong>解析字符串</strong></td><td align="left"><code>parseFromStream(builder, iss, &amp;v, &amp;err)</code></td></tr><tr><td align="left"><strong>取字符串</strong></td><td align="left"><code>v[&quot;key&quot;].asString()</code></td></tr><tr><td align="left"><strong>取整数</strong></td><td align="left"><code>v[&quot;key&quot;].asInt()</code></td></tr><tr><td align="left"><strong>判断是否存在</strong></td><td align="left"><code>v.isMember(&quot;key&quot;)</code></td></tr><tr><td align="left"><strong>遍历数组</strong></td><td align="left"><code>for (auto&amp; item : array)</code></td></tr><tr><td align="left"><strong>遍历对象</strong></td><td align="left"><code>for (auto it = obj.begin(); it != obj.end(); ++it)</code>，用 <code>it.name()</code> 取键</td></tr></tbody></table><p><code>Json::Value</code> 是核心数据类型，所有 JSON 数据都用 <code>Json::Value</code> 表示，可存储对象、数组、字符串、数字、布尔等。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;jsoncpp/json/json.h&gt;</span><span class="comment">// 头文件</span></span></span><br><span class="line"><span class="keyword">using</span> Json::Value;</span><br><span class="line"><span class="comment">// 编译需链接：-ljsoncpp，C++11 及以上标准示例：</span></span><br><span class="line">g++ -std=c+<span class="number">+11</span> temp.cpp -ljsoncpp -o a.out</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;jsoncpp/json/json.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 序列化示例</span></span><br><span class="line">    Json::Value data;</span><br><span class="line">    data[<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">    data[<span class="string">&quot;age&quot;</span>] = <span class="number">18</span>;</span><br><span class="line">    </span><br><span class="line">    Json::Value skills;</span><br><span class="line">    skills.<span class="built_in">append</span>(<span class="string">&quot;C++&quot;</span>);</span><br><span class="line">    skills.<span class="built_in">append</span>(<span class="string">&quot;Python&quot;</span>);</span><br><span class="line">    skills.<span class="built_in">append</span>(<span class="string">&quot;Linux&quot;</span>);</span><br><span class="line">    data[<span class="string">&quot;skills&quot;</span>] = skills;</span><br><span class="line">    </span><br><span class="line">    Json::FastWriter writer;</span><br><span class="line">    std::string jsonStr = writer.<span class="built_in">write</span>(data);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;生成的JSON: &quot;</span> &lt;&lt; jsonStr &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 反序列化示例</span></span><br><span class="line">    Json::Value parsedData;</span><br><span class="line">    Json::Reader reader;</span><br><span class="line">    <span class="keyword">if</span> (reader.<span class="built_in">parse</span>(jsonStr, parsedData))</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;解析出的姓名: &quot;</span> &lt;&lt; parsedData[<span class="string">&quot;name&quot;</span>].<span class="built_in">asString</span>() &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;技能列表: &quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; skill : parsedData[<span class="string">&quot;skills&quot;</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; skill.<span class="built_in">asString</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>046 网络编程套接字</title>
      <link href="/posts/40348.html"/>
      <url>/posts/40348.html</url>
      
        <content type="html"><![CDATA[<h1 id="网络编程套接字"><a href="#网络编程套接字" class="headerlink" title="网络编程套接字"></a>网络编程套接字</h1><h2 id="1-预备知识"><a href="#1-预备知识" class="headerlink" title="1. 预备知识"></a>1. 预备知识</h2><h3 id="1-源-IP-地址-目的-IP-地址"><a href="#1-源-IP-地址-目的-IP-地址" class="headerlink" title="1. 源 IP 地址 &amp; 目的 IP 地址"></a>1. 源 IP 地址 &amp; 目的 IP 地址</h3><ol><li><strong>是什么</strong>：<ul><li>负责 <strong>跨网络</strong> 的全球寻址，由 <strong>路由器</strong> 使用。</li><li><strong>源 IP</strong>：发件人所在的“城市 + 街道”的网络位置。</li><li><strong>目的 IP</strong>：收件人所在的网络位置。</li></ul></li><li><strong>理解</strong>：<ul><li>在互联网中，IP 就是定位“哪台主机”。</li><li>源 IP 说的是 <strong>“我是从哪里发的”</strong>，目的 IP 说的是 <strong>“我要送到哪去”</strong>。</li></ul></li></ol><h3 id="2-源-MAC-地址-目的-MAC-地址"><a href="#2-源-MAC-地址-目的-MAC-地址" class="headerlink" title="2. 源 MAC 地址 &amp; 目的 MAC 地址"></a>2. 源 MAC 地址 &amp; 目的 MAC 地址</h3><ol><li><strong>是什么</strong>：<ul><li><strong>MAC</strong> 是网卡的身份证，唯一标识一块网卡。负责 <strong>局域网内</strong> 的设备寻址，由 <strong>交换机</strong> 使用。</li><li><strong>源 MAC</strong>：是当前发出这个数据帧的设备（比如你家的路由器或你的电脑）的网卡物理地址。</li><li><strong>目的 MAC</strong>：是 <strong>当前这一跳</strong> 要送达的设备（比如你家的路由器，或者下一个网络的交换机）的网卡物理地址。</li></ul></li><li><strong>理解</strong>：<ul><li>MAC 负责在 <strong>同一个局域网</strong> 里找到对方机器。即使两个设备的 IP 地址在不同网段，中间的路由器也会逐跳修改 MAC 地址来转发数据。</li><li><strong>示例</strong>：MAC 地址只在“本地”有效。就像快递从你家送到小区快递站，靠的是小区内部的三轮车（车牌号 A），这时“目的 MAC”是快递站；当快递从上海发往北京时，负责这段运输的是一辆大货车（车牌号 B），这时“目的 MAC”就是北京的中转仓库。<strong>IP 地址不变（收件人始终是北京的朋友），但每一段路的“运输车”（MAC 地址）都在变。</strong></li></ul></li></ol><h3 id="3-源端口号-目的端口号"><a href="#3-源端口号-目的端口号" class="headerlink" title="3. 源端口号 &amp; 目的端口号"></a>3. 源端口号 &amp; 目的端口号</h3><ol><li><strong>是什么</strong>：<ul><li>负责 <strong>主机内部</strong> 的应用程序寻址，由 <strong>操作系统</strong> 使用。</li><li><strong>目的端口号</strong>：是服务的“电话号码”。比如你想访问网页，就打 80 号（HTTP）；想传文件，就打 21 号（FTP）。它告诉目标主机：“我要找你家哪个应用程序！”</li><li><strong>源端口号</strong>：是你这边临时生成的一个“回拨号码”。比如你的电脑随机选了个 50000 号。它告诉对方：“我找你家的 21 号（FTP），你回复我的话，请打 50000 号。”</li></ul></li><li><strong>理解</strong>：<ul><li><strong>示例</strong>：一台电脑上可能同时有微信、浏览器、游戏等多个程序在上网。IP 地址只能把包裹送到“这台电脑”，而 <strong>端口号决定了这个包裹具体是给微信、还是给浏览器的</strong>。它实现了“一台主机，多程序同时通信”。</li></ul></li></ol><blockquote><p>  [!NOTE]</p><h3 id="为什么引入“端口”而不是直接使用进程-PID？"><a href="#为什么引入“端口”而不是直接使用进程-PID？" class="headerlink" title="为什么引入“端口”而不是直接使用进程 PID？"></a>为什么引入“端口”而不是直接使用进程 PID？</h3><p>  我们发现端口和进程的 pid 十分相似，都能用于标识程序（进程）的唯一，那么为什么引入“端口”而不是直接使用进程 PID？</p><h4 id="1-端口-≠-PID"><a href="#1-端口-≠-PID" class="headerlink" title="1. 端口 ≠ PID"></a>1. 端口 ≠ PID</h4><ul><li><strong>PID（进程 ID）</strong>：操作系统内部标识某个正在运行的进程，只在本机有效，并且随 OS 调度，每次执行的 pid 都不同。</li><li><strong>端口号</strong>：网络通信里的标识符，用来告诉 <strong>接收到的数据包应该交给哪一个程序</strong>。它必须有几个特点：<ol><li><strong>跨主机一致性</strong>：同一个端口号在不同机器上也能表示同类服务（比如 HTTP 默认端口 80）。</li><li><strong>协议无关</strong>：端口号只和 TCP&#x2F;UDP 协议挂钩，不依赖操作系统的 PID 管理。</li><li><strong>隔离与安全</strong>：用户程序不能直接访问其他进程的 PID，而端口号可通过系统分配公开给网络层使用。</li></ol></li></ul><h4 id="2-为什么不直接用-PID？"><a href="#2-为什么不直接用-PID？" class="headerlink" title="2. 为什么不直接用 PID？"></a>2. 为什么不直接用 PID？</h4><ol><li><strong>解决跨主机问题</strong>：PID 是本地可变的，<strong>不同主机 PID 没意义</strong>，网络发包会搞不清楚收件程序是谁，而端口是网络通用的。</li><li><strong>实现服务抽象</strong>：端口号提供抽象层，让网络层只关心“哪条程序逻辑要接收数据”，不关心 OS 如何调度进程。端口标识服务类型（如 Web、邮件），而不是具体的进程实例。</li><li><strong>降低耦合性</strong>：传输层协议只依赖端口，不依赖操作系统的 PID，实现了协议栈的分层和解耦。</li><li><strong>标准化服务</strong>：一些端口号有固定含义（如 HTTP 80，HTTPS 443），不同机器、不同系统都能互相理解，服务可以更换软件、重启，只要端口不变，对外服务就不中断，而 PID 没法做到这一点。</li></ol><hr><p>  所以：</p><ul><li><strong>PID</strong> &#x3D; 家里某个家庭成员的身份证号 → 对邮局毫无意义。</li><li><strong>端口号</strong> &#x3D; 房间号 → 邮递员知道把信送到哪个房间，不管家庭成员是谁。</li></ul><p>  端口号把“进程内部细节”和“网络通信”隔离开，保证协议跨主机可用，降低耦合。</p></blockquote><blockquote><p>所以他们的关系就像送快递：</p><ul><li><strong>IP 地址</strong> &#x3D; 总快递单 → 从发货到收货，全程都指向同一个目的地（不变）。</li><li><strong>MAC 地址</strong> &#x3D; 中转贴纸 → 每经过一站，都会换成下一站的发件人&#x2F;收件人（一直变化：Mac 地址出局域网之后，源和目都要被丢弃，让路由器重新封装）。</li><li><strong>端口号</strong> &#x3D; 楼里具体的房间号（找准哪个程序收）。</li></ul></blockquote><hr><h3 id="4-TCP-VS-UDP（直观认识，后面详细讨论）"><a href="#4-TCP-VS-UDP（直观认识，后面详细讨论）" class="headerlink" title="4. TCP VS UDP（直观认识，后面详细讨论）"></a>4. TCP VS UDP（直观认识，后面详细讨论）</h3><h4 id="1-TCP：像“打电话”或“挂号快递”"><a href="#1-TCP：像“打电话”或“挂号快递”" class="headerlink" title="1. TCP：像“打电话”或“挂号快递”"></a>1. TCP：像“打电话”或“挂号快递”</h4><ul><li><strong>有连接</strong>：就像打电话，你必须先拨号（建立连接），等对方说“喂，你好”（连接确认）之后，你们才能开始说话。通信结束时，还要说“再见”（断开连接）。</li><li><strong>传输可靠</strong>：就像寄挂号快递。快递公司会确保包裹（数据）一定能送到，并且是完整无损的。如果路上丢了，他们会帮你找回或重寄。在 TCP 中，数据发送后，接收方必须回复“我收到了”（确认应答），如果没收到回复，发送方就会重发。</li><li><strong>面向字节流</strong>：就像你们在电话里连续不断地说话，没有明确的“段落”划分。TCP 把数据看作一个连续的、没有固定边界的“字节流”。你发了“你好”和“世界”，接收方可能收到“你好世”和“界”，也可能收到“你好世界”，它需要自己判断消息的边界（这叫“粘包”问题，需要应用层自己解决）。</li></ul><blockquote><p><strong>TCP</strong>：<strong>可靠、有序、有连接</strong>。适合对数据准确性要求高的场景，比如：网页浏览（HTTP&#x2F;HTTPS）、文件下载、发送邮件。</p></blockquote><h4 id="2-UDP：像“发短信”或“普通平邮”"><a href="#2-UDP：像“发短信”或“普通平邮”" class="headerlink" title="2. UDP：像“发短信”或“普通平邮”"></a>2. UDP：像“发短信”或“普通平邮”</h4><ul><li><strong>无连接</strong>：就像发短信，你不需要先打电话确认对方开机，直接输入内容发送就行。UDP 发送数据前，不需要和对方建立任何连接。</li><li><strong>传输不可靠</strong>：就像发普通平邮。你把信（数据包）投进邮筒就完事了，至于信会不会丢、会不会被撕坏、会不会晚到，邮局（网络）不保证。UDP 发送数据后，不会管对方有没有收到。</li><li><strong>面向数据报</strong>：就像每条短信都是一个独立的“数据包”。你发一条“你好”，就是一条完整的信息；再发一条“世界”，是另一条独立的信息。接收方收到的就是一个个完整、有明确边界的“数据报”，不会出现“粘包”或“拆包”的问题。</li></ul><blockquote><p><strong>UDP</strong>：<strong>快速、简单、无连接、不保证可靠</strong>。适合对速度要求高、能容忍少量丢失的场景，比如：在线视频&#x2F;语音通话（QQ、微信）、直播、网络游戏、DNS 查询。</p></blockquote><blockquote><p>  [!IMPORTANT]</p><ul><li><strong>TCP</strong>：追求“<strong>必须送到，且顺序正确</strong>”，所以慢但稳。</li><li><strong>UDP</strong>：追求“<strong>快，立刻发出去</strong>”，所以快但可能丢。</li></ul></blockquote><hr><h3 id="5-网络字节序"><a href="#5-网络字节序" class="headerlink" title="5. 网络字节序"></a>5. 网络字节序</h3><h4 id="1-发展与由来"><a href="#1-发展与由来" class="headerlink" title="1. 发展与由来"></a>1. 发展与由来</h4><ol><li><strong>大小端的起源</strong>：大小端源于计算机内部多字节数据（如整数）在内存中的存储方式差异。这种 <strong>多字节数据在内存中存放顺序</strong> 差异源于早期 CPU 架构设计，并无绝对优劣，CPU 在内部处理数据时，按自己的方式最方便，高效，却也导致不同硬件平台存在分歧。<ul><li><strong>大端</strong>：数据的 <strong>高位字节</strong> 存储在 <strong>低内存地址</strong>，低位字节存储在高地址（类似人书写数字的顺序，如 <code>0x1234</code> 存储为 <code>12 34</code>）。</li><li><strong>小端</strong>：数据的 <strong>低位字节</strong> 存储在 <strong>低内存地址</strong>，高位字节存储在高地址（如 <code>0x1234</code> 存储为 <code>34 12</code>）。</li></ul></li><li><strong>网络字节序的诞生</strong>：当不同大小端的机器需要跨网络通信时，若直接发送原始字节流，接收方可能解析错误（例如小端机发送的 <code>34 12</code> 被大端机解读为 <code>0x3412</code> 而非 <code>0x1234</code>）。为解决此问题，<strong>TCP&#x2F;IP 协议强制规定网络字节序统一为大端</strong>（也称“<strong>网络序</strong>”），确保所有设备在传输层达成一致。</li></ol><h4 id="2-为何没有统一解决？"><a href="#2-为何没有统一解决？" class="headerlink" title="2. 为何没有统一解决？"></a>2. 为何没有统一解决？</h4><ul><li><strong>硬件设计的多样性</strong>：大小端的选择涉及 CPU 架构、性能优化和兼容性，历史上不同厂商有不同架构，没办法强制统一。</li><li><strong>向后兼容性</strong>：改变现有系统的字节序会导致海量软件失效，成本过高。因此，只能通过协议层（如 TCP&#x2F;IP）在传输时进行转换，而非根除底层差异。</li></ul><h4 id="3-发送和接收"><a href="#3-发送和接收" class="headerlink" title="3. 发送和接收"></a>3. 发送和接收</h4><p>为了在不同 CPU 架构通信时，保证数字解释一致。<strong>网络协议规定统一字节序</strong>：TCP&#x2F;IP 定义 <strong>大端字节序</strong>（最高有效字节在最前面），从而屏蔽了硬件差异。即：<strong>不管本机是大端还是小端，都要转换成大端再发送。</strong></p><ol><li><strong>发送端</strong>：<ul><li>大端机 → 直接发送。</li><li>小端机 → 先把数据转成大端再发。</li></ul></li><li><strong>接收端</strong>：<ul><li>收到数据 → 如果本机是小端机，再把数据转成小端处理。</li></ul></li></ol><blockquote><p>执行以下代码，进行内存测试即可验证自己机器的大小端。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">&gt;<span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">&gt;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">&gt;</span>&#123;</span><br><span class="line">   <span class="type">unsigned</span> <span class="type">int</span> x = <span class="number">0x12345678</span>;</span><br><span class="line">   <span class="type">unsigned</span> <span class="type">char</span>* p = (<span class="type">unsigned</span> <span class="type">char</span>*)&amp;x;</span><br><span class="line">   <span class="keyword">if</span> (p[<span class="number">0</span>] == <span class="number">0x12</span>)</span><br><span class="line">   &#123;</span><br><span class="line">       cout &lt;&lt; <span class="string">&quot;大端&quot;</span> &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line">       cout &lt;&lt; <span class="string">&quot;小端&quot;</span> &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure></blockquote><h2 id="2-socket-编程接口"><a href="#2-socket-编程接口" class="headerlink" title="2. socket 编程接口"></a>2. socket 编程接口</h2><blockquote><p><a href="https://blog.csdn.net/chenlong_cxy/article/details/124533429">网络编程套接字（一） | CSDN（荐）</a></p><p><a href="https://www.bilibili.com/video/BV12A411X7gY/?share_source=copy_web&vd_source=872e5e3ccf44874c39edaf42e30ab0de">socket 到底是什么? | B 站</a></p></blockquote><blockquote><p><strong>套接字就是操作系统给程序和网络接口之间的一层统一抽象。</strong></p></blockquote><h3 id="1-为什么要抽象套接字"><a href="#1-为什么要抽象套接字" class="headerlink" title="1. 为什么要抽象套接字"></a>1. 为什么要抽象套接字</h3><p>套接字是操作系统提供的一个编程接口（API），用于实现不同场景下的通信。根据通信范围和需求，主要分为三类：</p><ol><li><strong>域间套接字</strong>：用于同一台主机内部的进程间通信（IPC）。不走网络协议栈，通过文件系统中的一个特殊文件作为通信端点，效率远高于网络套接字。</li><li><strong>网络套接字：</strong> 用于不同主机之间的网络通信，比如个人电脑和百度服务器，使用 <strong>IP 地址 + 端口号</strong> 来定位目标（常见、广泛）。</li><li><strong>原始套接字：</strong> 允许程序直接访问底层网络协议（如 IP、ICMP），通常用于开发网络工具（如 <code>ping</code>）或需要自定义协议头的场景。它绕过了传输层（TCP&#x2F;UDP）。</li></ol><p>系统调用希望 <strong>函数原型统一</strong>，而不是每种地址类型写一个不同函数。因此套接字提供了 <code>sockaddr_in</code> 结构体和 <code>sockaddr_un</code> 结构体，其中 <code>sockaddr_in</code> 结构体是用于跨网络通信的，而 <code>sockaddr_un</code> 结构体是用于本地通信的。</p><p>为了让套接字的网络通信和本地通信能够使用同一套函数接口，于是就出现了 <code>sockeaddr</code> 结构体，它跟 <code>sockaddr_in</code>、<code>sockaddr_un</code> 的结构都不相同，但这三个结构体头部的 16 个比特位都是一样的，这个字段叫做协议家族。</p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250814223024612.png" alt="PixPin_2025-08-14_22-30-08"></p><h3 id="2-socket-——-创建套接字"><a href="#2-socket-——-创建套接字" class="headerlink" title="2. socket —— 创建套接字"></a>2. <code>socket</code> —— 创建套接字</h3><p><strong>函数原型：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span>;</span><br></pre></td></tr></table></figure><p><strong>参数</strong>：</p><ul><li><code>domain</code>：地址族，<strong>常用 <code>AF_INET</code>（IPv4）、<code>AF_INET6</code>（IPv6） 、<code>AF_UNIX</code>（本地）。</strong></li><li><code>type</code>：套接字类型，<strong>常用 <code>SOCK_STREAM</code>（TCP）、<code>SOCK_DGRAM</code>（UDP）。</strong></li><li><code>protocol</code>：协议，通常设为 <strong>0（自动选择）</strong>。</li></ul><p><strong>返回值</strong>：成功返回套接字描述符（文件描述符，<strong>非负整数</strong>），<strong>失败 <code>-1</code></strong>（需检查 <code>errno</code>）。</p><h3 id="3-struct-sockaddr-in-——-IPv4-地址结构体"><a href="#3-struct-sockaddr-in-——-IPv4-地址结构体" class="headerlink" title="3. struct sockaddr_in —— IPv4 地址结构体"></a>3. <code>struct sockaddr_in</code> —— IPv4 地址结构体</h3><blockquote><p>struct sockaddr_in 可以使用 <code>man 7 ip</code> 命令进行查询。</p></blockquote><p><strong>结构体原型：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">sa_family_t</span>    sin_family;   <span class="comment">// 地址族，必须是AF_INET</span></span><br><span class="line">    <span class="type">in_port_t</span>      sin_port;     <span class="comment">// 16位端口号(网络字节序)，需用htons()转换</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span>     <span class="comment">// 32位IP地址(网络字节序)</span></span><br><span class="line">    <span class="comment">// unsigned char sin_zero[8];   // 通常不用，填充为0，使结构大小与sockaddr一致</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint32_t</span>       s_addr;       <span class="comment">// 32位整数表示的IP地址(网络字节序)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong><span style="color:#FF0000;">简化理解：</span></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span>          <span class="comment">// IPv4 的地址结构体</span></span><br><span class="line">    ├── sin_family          <span class="comment">// 地址族，AF_INET</span></span><br><span class="line">    ├── sin_port            <span class="comment">// 端口号</span></span><br><span class="line">    ├── sin_addr            <span class="comment">// IP 的结构体</span></span><br><span class="line">    ├── s_addr              <span class="comment">// 实际 IP 地址</span></span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ol><li><code>sin_family</code> 固定为 <strong>AF_INET</strong>。</li><li><code>sin_port</code>：范围为 0~65535，<strong>通常选择 1024 及以上</strong>，原因：<ul><li><code>0~1023</code> 是 <strong>知名端口</strong>（如 HTTP 的 80、FTP 的 21），属于系统内定的端口号，一般有固定的应用层协议使用，通常需要 root 权限才能绑定。</li><li><code>1024~49151</code> 是 <strong>注册端口</strong>，用于特定服务（如 MySQL 的 3306）。</li><li><code>49152~65535</code> 是 <strong>动态 &#x2F; 临时端口</strong>，通常用于客户端随机分配。</li></ul></li><li><code>struct in_addr</code> 内部包含一个 32 位无符号整数 <code>s_addr</code>，表示 IPv4 地址（网络字节序）。<ul><li><strong><code>INADDR_ANY</code>（<code>0.0.0.0</code> 网络字节序，无需额外转）：</strong> 表示绑定任意本地地址，监听所有本地 IP。</li><li><strong>具体 IPv4 地址</strong>（如 <code>192.168.1.100</code>），需要通过 <code>inet_addr()</code> 或 <code>inet_pton()</code> 将字符串格式的 IP 转换为网络字节序：<ul><li><code>inet_addr(&quot;192.168.1.100&quot;)</code>：直接返回网络字节序的 32 位地址。</li><li><code>inet_pton(AF_INET, &quot;192.168.1.100&quot;, &amp;sin_addr)</code>：更推荐的现代方法（支持 IPv6）。</li></ul></li><li><code>INADDR_LOOPBACK</code>（不常用）表示本地回环地址，用于本地进程间通信。</li></ul></li></ol><p><strong>注意：使用时需先初始化（用 <code>bzero()</code> 或 <code>memset()</code> 清零），避免随机值导致错误。初始化示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> addr;</span><br><span class="line"><span class="built_in">bzero</span>(&amp;addr, <span class="built_in">sizeof</span>(addr));          <span class="comment">// 清零结构体</span></span><br><span class="line">addr.sin_family = AF_INET;           <span class="comment">// IPv4</span></span><br><span class="line">addr.sin_port = <span class="built_in">htons</span>(<span class="number">8080</span>);         <span class="comment">// 端口号(主机字节序转网络字节序)</span></span><br><span class="line">addr.sin_addr.s_addr = INADDR_ANY;   <span class="comment">// 任意本地IP(0.0.0.0)</span></span><br><span class="line"><span class="comment">// 或指定IP: addr.sin_addr.s_addr = inet_addr(&quot;192.168.1.100&quot;);</span></span><br></pre></td></tr></table></figure><h3 id="4-bzero-memset-——-清零结构体内存"><a href="#4-bzero-memset-——-清零结构体内存" class="headerlink" title="4. bzero / memset —— 清零结构体内存"></a>4. <code>bzero / memset</code> —— 清零结构体内存</h3><p><strong>函数原型：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;strings.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">bzero</span><span class="params">(<span class="type">void</span> *s, <span class="type">size_t</span> n)</span>;    <span class="comment">// POSIX 接口，初始化 sockaddr_in</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">memset</span><span class="params">(<span class="type">void</span> *s, <span class="type">int</span> c, <span class="type">size_t</span> n)</span>; <span class="comment">// 推荐</span></span><br></pre></td></tr></table></figure><p><strong>使用示例（将内存块清零）：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> addr;</span><br><span class="line"><span class="built_in">bzero</span>(&amp;addr, <span class="built_in">sizeof</span>(addr));</span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;addr, <span class="number">0</span>, <span class="built_in">sizeof</span>(addr));</span><br></pre></td></tr></table></figure><h3 id="5-htons-htonl-ntohs-ntohl-——-字节序转换函数（保证大小端传输-解析）"><a href="#5-htons-htonl-ntohs-ntohl-——-字节序转换函数（保证大小端传输-解析）" class="headerlink" title="5. htons/htonl/ntohs/ntohl —— 字节序转换函数（保证大小端传输&#x2F;解析）"></a>5. <code>htons/htonl/ntohs/ntohl</code> —— 字节序转换函数（保证大小端传输&#x2F;解析）</h3><p><strong>函数原型：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">uint16_t</span> <span class="title">htons</span><span class="params">(<span class="type">uint16_t</span> hostshort)</span></span>;  <span class="comment">// 主机short(字节序) → 网络short(字节序，端口用，短整型）</span></span><br><span class="line"><span class="function"><span class="type">uint32_t</span> <span class="title">htonl</span><span class="params">(<span class="type">uint32_t</span> hostlong)</span></span>;   <span class="comment">// 主机long(字节序) → 网络long(字节序，IP用，长整型）</span></span><br><span class="line"><span class="function"><span class="type">uint16_t</span> <span class="title">ntohs</span><span class="params">(<span class="type">uint16_t</span> netshort)</span></span>;   <span class="comment">// 网络short(字节序) → 主机short(字节序，短整型)</span></span><br><span class="line"><span class="function"><span class="type">uint32_t</span> <span class="title">ntohl</span><span class="params">(<span class="type">uint32_t</span> netlong)</span></span>;    <span class="comment">// 网络long(字节序) → 主机long(字节序，长整型)</span></span><br></pre></td></tr></table></figure><p><strong>要点：参数就是所谓的端口号</strong>，端口用 <code>htons(port)</code>；IPv4 32 位值用 <code>htonl(x)</code> 或 <code>inet_addr()</code>。</p><h3 id="6-inet-addr-inet-aton-inet-ntoa-inet-pton-inet-ntop-——-IP-地址转换函数"><a href="#6-inet-addr-inet-aton-inet-ntoa-inet-pton-inet-ntop-——-IP-地址转换函数" class="headerlink" title="6. inet_addr / inet_aton / inet_ntoa / inet_pton / inet_ntop —— IP 地址转换函数"></a>6. <code>inet_addr / inet_aton / inet_ntoa / inet_pton / inet_ntop</code> —— IP 地址转换函数</h3><blockquote><p>不使用函数，手动实现（推荐：结构体）：<a href="https://blog.csdn.net/chenlong_cxy/article/details/124533429">网络编程套接字（一） | CSDN（荐）</a></p></blockquote><p><strong>函数原型：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="comment">// 注意：使用 struct sockaddr_in 结构体时，要注意对应的转型！！</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// IPv4：字符串 → 32位网络字节序IP</span></span><br><span class="line"><span class="type">in_addr_t</span> <span class="title function_">inet_addr</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* cp)</span>;                    <span class="comment">// 参数：IP 字符串(192.168.1.1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// IPv4：字符串 → in_addr 结构（推荐替代 inet_addr）</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">inet_aton</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* cp, <span class="keyword">struct</span> in_addr* inp)</span>;     <span class="comment">// 第二个参数就是 IP 的结构体（struct in_addr*）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// IPv4：网络字节序 in_addr → 字符串</span></span><br><span class="line"><span class="type">char</span>* <span class="title function_">inet_ntoa</span><span class="params">(<span class="keyword">struct</span> in_addr in)</span>;                     <span class="comment">// 参数：IP 的结构体（struct in_addr）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通用（推荐）：字符串 → 地址结构（IPv4/IPv6）</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">inet_pton</span><span class="params">(<span class="type">int</span> af, <span class="type">const</span> <span class="type">char</span>* src, <span class="type">void</span>* dst)</span>;      <span class="comment">// 参数依次是：地址族，IP 字符串，一个外部的缓冲区地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通用（推荐）：地址结构 → 字符串（IPv4/IPv6）</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* <span class="title function_">inet_ntop</span><span class="params">(<span class="type">int</span> af, <span class="type">const</span> <span class="type">void</span>* src, <span class="type">char</span>* dst, <span class="type">socklen_t</span> size)</span>;</span><br><span class="line"><span class="comment">// 参数依次是：地址族，IP 的结构体，一个外部的缓冲区地址，缓冲区大小</span></span><br><span class="line"></span><br><span class="line">----------------------------------------------------------------------------------------------------------------------</span><br><span class="line"><span class="comment">// 使用示例：</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">ip</span>;</span></span><br><span class="line"><span class="type">char</span> buffer[<span class="number">16</span>];</span><br><span class="line">bzero(&amp;addr, <span class="keyword">sizeof</span>(addr));                          <span class="comment">// 清空结构体</span></span><br><span class="line">addr.sin_family = AF_INET;                           <span class="comment">// IPv4协议</span></span><br><span class="line">addr.sin_port = htons(<span class="number">8080</span>);                         <span class="comment">// 设置端口（转网络字节序）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. inet_addr: 字符串IP → 网络字节序整数（32位）</span></span><br><span class="line">addr.sin_addr.s_addr = inet_addr(<span class="string">&quot;192.168.1.100&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. inet_aton: 字符串IP → in_addr结构（更安全）</span></span><br><span class="line">inet_aton(<span class="string">&quot;192.168.1.100&quot;</span>, &amp;addr.sin_addr);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. inet_ntoa: in_addr → 字符串IP（注意：返回静态缓冲区）</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;IP: %s\n&quot;</span>, inet_ntoa(addr.sin_addr));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. inet_pton: 字符串 → 二进制IP（推荐，支持IPv6）</span></span><br><span class="line">inet_pton(AF_INET, <span class="string">&quot;192.168.1.100&quot;</span>, &amp;addr.sin_addr);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. inet_ntop: 二进制IP → 字符串（推荐，线程安全）</span></span><br><span class="line">inet_ntop(AF_INET, &amp;addr.sin_addr, buffer, <span class="keyword">sizeof</span>(buffer));</span><br></pre></td></tr></table></figure><p><strong>简短实用：</strong></p><ol><li><strong>转 IP → 网络字节序（二进制）</strong><ul><li><strong>IPv4：<code>inet_aton()</code> ✅</strong></li><li><strong>IPv4&#x2F;IPv6：<code>inet_pton()</code> ✅（推荐）</strong></li><li>一般不建议：<code>inet_addr()</code>（出错返回值和合法地址可能混淆）</li></ul></li><li><strong>转 网络字节序（二进制） → 字符串</strong><ul><li><strong>IPv4：<code>inet_ntoa()</code>（返回静态区指针，非线程安全）</strong></li><li><strong>IPv4&#x2F;IPv6：<code>inet_ntop()</code> ✅（推荐，线程安全）</strong></li></ul></li><li><strong><code>af</code> 参数：</strong><ul><li><code>AF_INET</code>  → IPv4。</li><li><code>AF_INET6</code> → IPv6。</li></ul></li></ol><blockquote><ul><li>IPv4 简单写：<code>inet_aton / inet_ntoa</code>。</li><li>兼容 IPv4&#x2F;IPv6、线程安全：<strong>优先用 <code>inet_pton / inet_ntop</code></strong>。</li></ul></blockquote><h3 id="7-bind-——-绑定套接字与地址（服务器必做）"><a href="#7-bind-——-绑定套接字与地址（服务器必做）" class="headerlink" title="7. bind —— 绑定套接字与地址（服务器必做）"></a>7. <code>bind</code> —— 绑定套接字与地址（服务器必做）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">bind</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span>;</span><br></pre></td></tr></table></figure><p><strong>参数：</strong></p><ul><li><code>sockfd</code>：<code>socket()</code> 返回的套接字描述符。</li><li><code>addr</code>：指向地址结构体的指针（通常传入 <code>sockaddr_in</code> 并强制转换为 <code>sockaddr*</code>）。</li><li><code>addrlen</code>：地址结构体的长度&#x2F;大小（<code>sizeof(struct sockaddr_in)</code>）。</li></ul><p><strong>返回值</strong>：成功返回 <code>0</code>，失败返回 <code>-1</code>。</p><p><strong>注意：服务器必须</strong> 绑定固定端口，客户端通常不需要（系统自动分配临时端口）。</p><hr><blockquote><p><span style="color:#FF0000;"><strong>1-7 的接口属于 TCP 和 UDP 共用，8-10 算是 TCP 的专用函数了。</strong></span></p></blockquote><blockquote><h3 id="8-listen-——-服务器监听"><a href="#8-listen-——-服务器监听" class="headerlink" title="8. listen —— 服务器监听"></a>8. <code>listen</code> —— 服务器监听</h3><p><strong>函数原型：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line">&gt;<span class="type">int</span> <span class="title function_">listen</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> backlog)</span>;</span><br></pre></td></tr></table></figure><p><strong>参数：</strong></p><ul><li><code>sockfd</code>：已绑定的 TCP 套接字。</li><li><code>backlog</code>：等待连接队列的最大长度，通常设为 5-10（超过则新连接被拒绝）。</li></ul><p><strong>返回值</strong>：成功返回 <code>0</code>，失败返回 <code>-1</code>。</p><h3 id="9-accept-——-服务器接受连接"><a href="#9-accept-——-服务器接受连接" class="headerlink" title="9. accept —— 服务器接受连接"></a>9. <code>accept</code> —— 服务器接受连接</h3><p><strong>函数原型：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line">&gt;<span class="type">int</span> <span class="title function_">accept</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> *addrlen)</span>;</span><br></pre></td></tr></table></figure><p><strong>参数：</strong></p><ul><li><code>sockfd</code>：<code>listen()</code> 监听的套接字。</li><li><code>addr</code>：输出参数，存储客户端地址（需预先分配空间）。</li><li><code>addrlen</code>：输入输出参数，传入 <code>addr</code> 大小，返回实际地址长度。</li></ul><p><strong>返回值</strong>：成功返回 <strong>新的套接字描述符</strong>（专门用于与该客户端通信），失败返回 <code>-1</code>。</p><p><strong>注意</strong>：阻塞函数，若无连接则一直等待。</p><h3 id="10-connect-——-客户端连接服务器"><a href="#10-connect-——-客户端连接服务器" class="headerlink" title="10. connect —— 客户端连接服务器"></a>10. <code>connect</code> —— 客户端连接服务器</h3><p><strong>函数原型：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line">&gt;<span class="type">int</span> <span class="title function_">connect</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span>;</span><br><span class="line">&gt;<span class="comment">// 参数：要连接的服务器地址，端口号，超时时间（用来设置连接尝试的最长时间）</span></span><br></pre></td></tr></table></figure><p><strong>参数</strong>：与 <code>bind()</code> 类似，但 <code>addr</code> 是服务器的地址。</p><p><strong>返回值</strong>：成功返回 <code>0</code>，失败返回 <code>-1</code>。</p></blockquote><hr><h3 id="11-数据传输函数-send-recv-——-TCP-收发"><a href="#11-数据传输函数-send-recv-——-TCP-收发" class="headerlink" title="11. 数据传输函数 send/recv —— TCP 收发"></a>11. 数据传输函数 <code>send/recv</code> —— TCP 收发</h3><p><strong>函数原型：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">send</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">recv</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags)</span>;</span><br></pre></td></tr></table></figure><ul><li><code>send</code> → 我要把这段数据，<strong>发</strong> 给已经连接的对方。</li><li><code>recv</code> → 我要从已经连接的对方那里 <strong>接收</strong> 一段数据。</li></ul><p><strong>参数对比：</strong></p><table><thead><tr><th>参数</th><th><code>send</code> 参数</th><th><code>recv</code> 参数</th><th>相同点</th><th>不同点</th></tr></thead><tbody><tr><td><strong>1. socket 文件描述符</strong></td><td><code>int sockfd</code></td><td><code>int sockfd</code></td><td>都是已连接的套接字（由 <code>accept()</code> 或 <code>connect()</code> 得到）</td><td>无</td></tr><tr><td><strong>2. 数据缓冲区</strong></td><td><code>const void *buf</code></td><td><code>void *buf</code></td><td>都是存放数据的内存区域</td><td><code>send</code> 的数据是 <strong>只读</strong> 的（要发出去），<code>recv</code> 的数据是 <strong>可写</strong> 的（接收进来）</td></tr><tr><td><strong>3. 缓冲区长度&#x2F;大小（字节数）</strong></td><td><code>size_t len</code></td><td><code>size_t len</code></td><td>都表示操作的数据字节数</td><td>无</td></tr><tr><td><strong>4. 标志位（一般为 0）</strong></td><td><code>int flags</code></td><td><code>int flags</code></td><td>都可设置特殊行为（如非阻塞、等待模式）</td><td>一般用 <code>0</code>，也可指定 <code>MSG_NOSIGNAL</code>（<code>send</code> 阻止 SIGPIPE）或 <code>MSG_WAITALL</code>（<code>recv</code> 等到缓冲区填满才返回）</td></tr></tbody></table><p><strong>返回值：</strong></p><ol><li><code>send()</code>：<ul><li>成功：返回实际发送的字节数（可能 <strong>小于请求长度</strong>，应用层需要循环 <code>send</code>）。</li><li>失败：返回 <code>-1</code> 并设置 <code>errno</code>（如 <code>EPIPE</code> 表示对方已关闭连接）。</li></ul></li><li><code>recv()</code>：<ul><li>成功：返回实际接收的字节数。</li><li>返回 <code>0</code>：表示对方已正常关闭连接（EOF）。</li><li>失败：返回 <code>-1</code> 并设置 <code>errno</code>（如 <code>ECONNRESET</code> 表示连接被对方重置）。</li></ul></li></ol><blockquote><p>  TCP 是 <strong>字节流</strong>：一次 <code>send</code> 不保证对方一次 <code>recv</code> 就读满，注意循环收发。</p></blockquote><h3 id="12-数据传输函数-sendto-recvfrom-——-UDP-收发"><a href="#12-数据传输函数-sendto-recvfrom-——-UDP-收发" class="headerlink" title="12. 数据传输函数 sendto/recvfrom —— UDP 收发"></a>12. 数据传输函数 <code>sendto/recvfrom</code> —— UDP 收发</h3><p><strong>函数原型：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">sendto</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *dest_addr, <span class="type">socklen_t</span> addrlen)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">recvfrom</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags, <span class="keyword">struct</span> sockaddr *src_addr, <span class="type">socklen_t</span> *addrlen)</span>;</span><br></pre></td></tr></table></figure><ul><li><code>sendto</code> → 我要把这段数据，<strong>发</strong> 给某个地址。</li><li><code>recvfrom</code> → 我要接 <strong>收</strong> 一段数据，同时想知道它是从哪来的。</li></ul><p><strong>参数：</strong></p><table><thead><tr><th>参数</th><th><code>sendto</code> 参数</th><th><code>recvfrom</code> 参数</th><th>相同点</th><th>不同点</th></tr></thead><tbody><tr><td><strong>1. socket 文件描述符</strong></td><td><code>int sockfd</code></td><td><code>int sockfd</code></td><td>都是由 <code>socket()</code> 创建的套接字，指明操作的对象</td><td>无</td></tr><tr><td><strong>2. 数据缓冲区</strong></td><td><code>const void *buf</code></td><td><code>void *buf</code></td><td>都是存放数据的内存区域</td><td><code>sendto</code> 的数据是 <strong>只读</strong> 的（要发出去），<code>recvfrom</code> 的数据是 <strong>可写</strong> 的（接收进来）</td></tr><tr><td><strong>3. 缓冲区长度&#x2F;大小（字节数）</strong></td><td><code>size_t len</code></td><td><code>size_t len</code></td><td>都表示操作的数据字节数</td><td>无</td></tr><tr><td><strong>4. 标志位（一般为 0）</strong></td><td><code>int flags</code></td><td><code>int flags</code></td><td>都可设置特殊行为（如非阻塞、等待模式）</td><td>通常 <code>sendto</code> 默认用 <code>0</code>，<code>recvfrom</code> 可能会用 <code>MSG_WAITALL</code> 等</td></tr><tr><td><strong>5. 地址结构（需要转型）</strong></td><td><code>const struct sockaddr *dest_addr</code></td><td><code>struct sockaddr *src_addr</code></td><td>都是 <code>struct sockaddr*</code> 类型，用来描述网络地址</td><td><code>sendto</code> 需要指定 <strong>目标地址</strong>（发给谁），<code>recvfrom</code> 获取 <strong>对方地址</strong>（谁发来的）</td></tr><tr><td><strong>6. 地址结构大小</strong></td><td><code>socklen_t addrlen</code></td><td><code>socklen_t *addrlen</code></td><td>都与地址结构体长度相关</td><td><code>sendto</code> 传值（只读，告诉内核目标地址长度），<code>recvfrom</code> 传指针（可写，内核回填实际地址长度）</td></tr></tbody></table><p><strong>相同的返回值：</strong></p><ul><li><strong>成功：</strong> 返回实际发送&#x2F;接收的字节数（<code>ssize_t</code> 类型，正整数）；</li><li><strong>失败：</strong> 返回 <code>-1</code> 并设置 <code>errno</code>（常见如：<code>EINVAL</code> 参数无效，<code>EAGAIN</code> 非阻塞模式下暂时无数据，<code>ECONNREFUSED</code> 目标不可达等）。</li></ul><blockquote><p>  UDP 是 <strong>报文</strong>：一发一收，天然有包界；长度超 MTU 可能被分片&#x2F;丢弃。</p></blockquote><h3 id="13-close-——-关闭套接字"><a href="#13-close-——-关闭套接字" class="headerlink" title="13. close() —— 关闭套接字"></a>13. <code>close()</code> —— 关闭套接字</h3><p><strong>函数原型：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">close</span><span class="params">(<span class="type">int</span> fd)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>作用</strong>：关闭套接字描述符，释放资源。</p><p><strong>返回值</strong>：成功返回 <code>0</code>，失败返回 <code>-1</code>。</p><hr><h2 id="3-理解协议与对应的服务器和客户端通信流程"><a href="#3-理解协议与对应的服务器和客户端通信流程" class="headerlink" title="3. 理解协议与对应的服务器和客户端通信流程"></a>3. 理解协议与对应的服务器和客户端通信流程</h2><h3 id="1-UDP"><a href="#1-UDP" class="headerlink" title="1. UDP"></a>1. UDP</h3><h4 id="1-UDP-服务器-Server"><a href="#1-UDP-服务器-Server" class="headerlink" title="1. UDP 服务器 (Server)"></a>1. UDP 服务器 (Server)</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── <span class="built_in">socket</span>()<span class="comment">// 1. 创建一个UDP套接字</span></span><br><span class="line">├── 配置服务器地址(sockaddr_in)<span class="comment">// 2. 准备自己的地址信息</span></span><br><span class="line">│   ├── bzero / memset<span class="comment">// - 清零结构体</span></span><br><span class="line">│   ├── serv_addr.sin_family<span class="comment">// - 指定IPv4</span></span><br><span class="line">│   ├── serv_addr.sin_port<span class="comment">// - 指定端口号</span></span><br><span class="line">│   └── serv_addr.sin_addr.s_addr<span class="comment">// - 指定IP地址</span></span><br><span class="line">├── <span class="built_in">bind</span>()<span class="comment">// 3. 将套接字与地址绑定 (正式“调频道”)</span></span><br><span class="line">├── <span class="built_in">recvfrom</span>()<span class="comment">// 4. 等待并接收客户端消息</span></span><br><span class="line">│   ├── 参数中会返回客户端地址(cli_addr)<span class="comment">// - 知道是谁发来的</span></span><br><span class="line">│   └── 参数中会返回消息内容(buffer)<span class="comment">// - 得到消息内容</span></span><br><span class="line">├── <span class="built_in">sendto</span>()<span class="comment">// 5. 给客户端发送回复</span></span><br><span class="line">│   ├── 指定目标地址(cli_addr)<span class="comment">// - 回复给刚才发消息的客户端</span></span><br><span class="line">│   └── 发送回复内容</span><br><span class="line">└── <span class="built_in">close</span>()<span class="comment">// 6. 关闭套接字</span></span><br></pre></td></tr></table></figure><h4 id="2-UDP-客户端-Client"><a href="#2-UDP-客户端-Client" class="headerlink" title="2. UDP 客户端 (Client)"></a>2. UDP 客户端 (Client)</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── <span class="built_in">socket</span>()<span class="comment">// 1. 创建一个UDP套接字</span></span><br><span class="line">├── 配置服务器地址(sockaddr_in)<span class="comment">// 2. 准备要发往的服务器地址</span></span><br><span class="line">│   ├── bzero / <span class="built_in">memset</span>()<span class="comment">// - 清零结构体</span></span><br><span class="line">│   ├── serv_addr.sin_family<span class="comment">// - 指定IPv4</span></span><br><span class="line">│   ├── serv_addr.sin_port<span class="comment">// - 服务器端口</span></span><br><span class="line">│   └── serv_addr.sin_addr.s_addr<span class="comment">// - 服务器IP</span></span><br><span class="line">├──(可选) 配置客户端地址<span class="comment">// 3. 如果需要，可以显式绑定客户端端口</span></span><br><span class="line">│   ├── bzero / <span class="built_in">memset</span>()</span><br><span class="line">│   ├── cli_addr.sin_family</span><br><span class="line">│   ├── cli_addr.sin_port<span class="comment">// 指定一个固定端口，或让系统自动分配</span></span><br><span class="line">│   └── cli_addr.sin_addr.s_addr<span class="comment">// 通常用任意IP</span></span><br><span class="line">├──(可选) <span class="built_in">bind</span>()<span class="comment">// 4. 显式绑定客户端端口 (如果第3步配置了)，可以不需要，系统会自动分配一个临时端口</span></span><br><span class="line">├── <span class="built_in">sendto</span>()<span class="comment">// 5. 给服务器发送请求</span></span><br><span class="line">├── <span class="built_in">recvfrom</span>()<span class="comment">// 6. 等待并接收服务器的回复</span></span><br><span class="line">│   ├── 参数中会返回服务器地址(serv_addr)<span class="comment">// - 确认是预期的服务器回复</span></span><br><span class="line">│   └── 参数中会返回回复内容(buffer)</span><br><span class="line">└── <span class="built_in">close</span>()<span class="comment">// 7. 关闭套接字</span></span><br></pre></td></tr></table></figure><h4 id="3-UDP-就像“发微信语音消息”"><a href="#3-UDP-就像“发微信语音消息”" class="headerlink" title="3. UDP 就像“发微信语音消息”"></a>3. UDP 就像“发微信语音消息”</h4><p>你和朋友在不同的地方，你录了一段语音：“我在东门等你！”，然后发给了他的微信号。</p><ol><li><strong>socket()</strong>：你们都装了微信（通信工具准备好了）。</li><li><strong>bind()</strong>：你注册了微信号（相当于绑定 IP 和端口），别人能通过这个号找到你。</li><li><strong>sendto()</strong>：你发送语音，指定了发给“朋友的微信号”（目标 IP+端口）。</li><li><strong>recvfrom()</strong>：朋友的微信收到了消息，他知道是你发的，也听到了内容。</li></ol><p><strong>特点</strong>：</p><ul><li>你发完就不管了，<strong>不确认他有没有收到</strong>（不可靠）。</li><li>如果网络卡了，语音可能 <strong>丢了、乱了、重复了</strong>，你也不知道。</li><li>但 <strong>速度快</strong>，适合直播、语音通话等实时场景。</li></ul><blockquote><p>UDP：<strong>无连接、不保证送达、速度快</strong>，像“广播喊话”或“发语音”。</p></blockquote><hr><h3 id="2-TCP"><a href="#2-TCP" class="headerlink" title="2. TCP"></a>2. TCP</h3><h4 id="1-TCP-服务器-Server"><a href="#1-TCP-服务器-Server" class="headerlink" title="1. TCP 服务器 (Server)"></a>1. TCP 服务器 (Server)</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── <span class="built_in">socket</span>()<span class="comment">// 1. 创建一个TCP套接字 (SOCK_STREAM)</span></span><br><span class="line">├── 配置服务器地址 (sockaddr_in)<span class="comment">// 2. 准备自己的地址信息</span></span><br><span class="line">│   ├── bzero / <span class="built_in">memset</span>()<span class="comment">// - 清零结构体</span></span><br><span class="line">│   ├── serv_addr.sin_family = AF_INET<span class="comment">// - IPv4</span></span><br><span class="line">│   ├── serv_addr.sin_port = <span class="built_in">htons</span>(PORT)<span class="comment">// - 绑定端口</span></span><br><span class="line">│   └── serv_addr.sin_addr.s_addr = INADDR_ANY<span class="comment">// - 监听所有网卡</span></span><br><span class="line">├── <span class="built_in">bind</span>()<span class="comment">// 3. 将套接字绑定到地址上</span></span><br><span class="line">├── <span class="built_in">listen</span>()<span class="comment">// 4. 开始监听连接请求（进入“待接电话”状态）</span></span><br><span class="line">│   └── 设置 backlog 队列（等待 accept 的连接数）</span><br><span class="line">│</span><br><span class="line">├── <span class="built_in">accept</span>()<span class="comment">// 5. 阻塞等待客户端连接到来</span></span><br><span class="line">│   ├── 成功后返回一个新的连接套接字 (connfd)<span class="comment">// - 用于与该客户端通信</span></span><br><span class="line">│   └── 客户端地址信息 (cli_addr) 被填充<span class="comment">// - 知道是谁连进来了</span></span><br><span class="line">│</span><br><span class="line">├── <span class="built_in">recv</span>()<span class="comment">// 6. 使用 connfd 接收数据</span></span><br><span class="line">│   └── 从客户端读取消息内容 (buffer)</span><br><span class="line">│</span><br><span class="line">├── <span class="built_in">send</span>()<span class="comment">// 7. 使用 connfd 发送回复</span></span><br><span class="line">│   └── 向客户端发送响应数据</span><br><span class="line">│</span><br><span class="line">├── <span class="built_in">close</span>(connfd)<span class="comment">// 8. 关闭连接套接字（通信结束）</span></span><br><span class="line">│</span><br><span class="line">└── <span class="built_in">close</span>(sockfd)<span class="comment">// 9. 最后关闭监听套接字（程序退出时）</span></span><br></pre></td></tr></table></figure><h4 id="2-TCP-客户端-Client"><a href="#2-TCP-客户端-Client" class="headerlink" title="2. TCP 客户端 (Client)"></a>2. TCP 客户端 (Client)</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── <span class="built_in">socket</span>()<span class="comment">// 1. 创建一个TCP套接字 (SOCK_STREAM)</span></span><br><span class="line">├── 配置目标服务器地址 (sockaddr_in)<span class="comment">// 2. 指定要连接的服务器</span></span><br><span class="line">│   ├── bzero / <span class="built_in">memset</span>()<span class="comment">// - 清零结构体</span></span><br><span class="line">│   ├── serv_addr.sin_family = AF_INET<span class="comment">// - IPv4</span></span><br><span class="line">│   ├── serv_addr.sin_port = <span class="built_in">htons</span>(PORT)<span class="comment">// - 服务器端口</span></span><br><span class="line">│   └── serv_addr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;IP&quot;</span>)<span class="comment">// - 服务器IP地址</span></span><br><span class="line">│</span><br><span class="line">├── <span class="built_in">connect</span>()<span class="comment">// 3. 发起连接请求（触发三次握手）</span></span><br><span class="line">│   └── 成功则表示连接建立完成</span><br><span class="line">│</span><br><span class="line">├── <span class="built_in">send</span>()<span class="comment">// 4. 发送请求数据到服务器</span></span><br><span class="line">│   └── 通过已连接的套接字发送消息</span><br><span class="line">│</span><br><span class="line">├── <span class="built_in">recv</span>()<span class="comment">// 5. 接收服务器的回复</span></span><br><span class="line">│   └── 读取返回的数据</span><br><span class="line">│</span><br><span class="line">├── <span class="built_in">close</span>()<span class="comment">// 6. 关闭连接（触发四次挥手）</span></span><br></pre></td></tr></table></figure><h4 id="3-TCP-就像“打电话”"><a href="#3-TCP-就像“打电话”" class="headerlink" title="3. TCP 就像“打电话”"></a>3. TCP 就像“打电话”</h4><p>你拿出手机，拨通朋友的号码。</p><ol><li><strong>socket()</strong>：你们都有手机（通信工具）。</li><li><strong>bind()</strong>：你的手机有号码（IP+端口），别人可以打给你。</li><li><strong>connect()</strong>：你拨号，他接听——<strong>建立连接</strong>（三次握手）。</li><li><strong>send()&#x2F;recv()</strong>：你们开始通话。你说一句，他“嗯”一声表示听到了；如果信号不好没听清，他会说“再说一遍”，你就会 <strong>重说</strong>。</li><li><strong>close()</strong>：聊完后，互相说“拜拜”才挂电话（四次挥手）。</li></ol><p><strong>关键特点</strong>：</p><ul><li>通话前必须 <strong>先建立连接</strong>。</li><li>数据 <strong>不会丢、不会乱序</strong>，发出去就得确认收到。</li><li>如果网络差，通话会卡，但内容 <strong>绝对准确</strong>。</li></ul><blockquote><p>TCP：<strong>有连接、可靠传输、保证顺序</strong>，像“打电话”一样稳。</p></blockquote><h2 id="4-UDP-服务器和客户端-Demo"><a href="#4-UDP-服务器和客户端-Demo" class="headerlink" title="4. UDP 服务器和客户端 Demo"></a>4. UDP 服务器和客户端 Demo</h2><h3 id="1-UDP-Server-hpp"><a href="#1-UDP-Server-hpp" class="headerlink" title="1. UDP_Server.hpp"></a>1. UDP_Server.hpp</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Log.hpp&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误码定义</span></span><br><span class="line"><span class="keyword">enum</span></span><br><span class="line">&#123;</span><br><span class="line">    SOCKET_ERR = <span class="number">1</span>,                                             <span class="comment">// 创建 socket 失败</span></span><br><span class="line">    BIND_ERR                                                    <span class="comment">// bind 失败</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认端口和 IP 地址</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">uint16_t</span> defaultport = <span class="number">8080</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> string defaultip = <span class="string">&quot;0.0.0.0&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> BUFFER_SIZE = <span class="number">1024</span>;                            <span class="comment">// 接收缓冲区大小</span></span><br><span class="line"><span class="comment">// 定义回调函数类型：接收一个字符串请求，返回一个字符串响应</span></span><br><span class="line"><span class="keyword">typedef</span> function&lt;string(<span class="type">const</span> string&amp;)&gt; <span class="type">func_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UDP_Server</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">UDP_Server</span>(<span class="type">const</span> <span class="type">uint16_t</span> &amp;port = defaultport, <span class="type">const</span> string &amp;ip = defaultip,</span><br><span class="line">              <span class="type">int</span> enable_log = <span class="number">1</span>,</span><br><span class="line">              <span class="type">int</span> classification = <span class="number">1</span>,</span><br><span class="line">              <span class="type">const</span> string &amp;log_path = <span class="string">&quot;./log.txt&quot;</span>,</span><br><span class="line">              <span class="type">int</span> console_out = <span class="number">1</span>)</span><br><span class="line">        : <span class="built_in">sockfd_</span>(<span class="number">0</span>), <span class="built_in">port_</span>(port), <span class="built_in">ip_</span>(ip), <span class="built_in">isrunning_</span>(<span class="literal">false</span>),</span><br><span class="line">          <span class="built_in">log_</span>(enable_log, classification, log_path, console_out) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">UDP_Server</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(sockfd_ &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">close</span>(sockfd_);                                     <span class="comment">// 关闭 socket 文件描述符</span></span><br><span class="line">            <span class="built_in">log_</span>(Info, <span class="string">&quot;UDP 服务器套接字已关闭&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 创建 UDP socket</span></span><br><span class="line">        sockfd_ = <span class="built_in">socket</span>(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(sockfd_ &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">log_</span>(Fatal, <span class="string">&quot;套接字创建错误，sockfd: %d&quot;</span>, sockfd_);</span><br><span class="line">            <span class="built_in">exit</span>(SOCKET_ERR);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">log_</span>(Info, <span class="string">&quot;套接字创建成功，sockfd: %d&quot;</span>, sockfd_);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 设置 IPv4 地址结构</span></span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> local;</span><br><span class="line">        <span class="built_in">bzero</span>(&amp;local, <span class="built_in">sizeof</span>(local));                            <span class="comment">// 内存清零</span></span><br><span class="line">        local.sin_family = AF_INET;                              <span class="comment">// IPv4</span></span><br><span class="line">        local.sin_port = <span class="built_in">htons</span>(port_);                           <span class="comment">// 端口号转换为网络字节序</span></span><br><span class="line">        local.sin_addr.s_addr = <span class="built_in">inet_addr</span>(ip_.<span class="built_in">c_str</span>());          <span class="comment">// 将字符串 IP 转换为网络字节序整数</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 绑定 socket 到本地地址</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">bind</span>(sockfd_, (<span class="type">const</span> <span class="keyword">struct</span> sockaddr *)&amp;local, <span class="built_in">sizeof</span>(local)) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">log_</span>(Fatal, <span class="string">&quot;绑定套接字错误，errno: %d，错误字符串: %s&quot;</span>, errno, <span class="built_in">strerror</span>(errno));</span><br><span class="line">            <span class="built_in">exit</span>(BIND_ERR);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">log_</span>(Info, <span class="string">&quot;绑定套接字成功，本地地址: %s:%d&quot;</span>, ip_.<span class="built_in">c_str</span>(), port_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Run</span><span class="params">(<span class="type">func_t</span> func)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        isrunning_ = <span class="literal">true</span>;</span><br><span class="line">        <span class="type">char</span> buffer[BUFFER_SIZE];                               <span class="comment">// 接收缓冲区</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (isrunning_)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> client;                          <span class="comment">// 客户端地址信息</span></span><br><span class="line">            <span class="type">socklen_t</span> len = <span class="built_in">sizeof</span>(client);                     <span class="comment">// 必须初始化长度</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 接收客户端数据</span></span><br><span class="line">            <span class="type">ssize_t</span> n = <span class="built_in">recvfrom</span>(sockfd_, buffer, <span class="built_in">sizeof</span>(buffer) - <span class="number">1</span>, <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;client, &amp;len);</span><br><span class="line">            <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">log_</span>(Warning, <span class="string">&quot;recvfrom error, errno: %d, err string: %s&quot;</span>, errno, <span class="built_in">strerror</span>(errno));</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            buffer[n] = <span class="string">&#x27;\0&#x27;</span>;                                   <span class="comment">// 添加字符串结束符</span></span><br><span class="line">            <span class="function">string <span class="title">request</span><span class="params">(buffer)</span></span>;                             <span class="comment">// 构造请求字符串</span></span><br><span class="line"></span><br><span class="line">            string response = <span class="built_in">func</span>(request);                    <span class="comment">// 调用用户自定义处理函数生成响应</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 发送响应回客户端</span></span><br><span class="line">            <span class="built_in">sendto</span>(sockfd_, response.<span class="built_in">c_str</span>(), response.<span class="built_in">size</span>(), <span class="number">0</span>, (<span class="type">const</span> <span class="keyword">struct</span> sockaddr*)&amp;client, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> sockfd_;         <span class="comment">// socket 文件描述符</span></span><br><span class="line">    string ip_;          <span class="comment">// 服务器绑定的 IP 地址</span></span><br><span class="line">    <span class="type">uint16_t</span> port_;      <span class="comment">// 服务器监听的端口号</span></span><br><span class="line">    <span class="type">bool</span> isrunning_;     <span class="comment">// 服务运行状态标志</span></span><br><span class="line">    Log log_;            <span class="comment">// 日志对象成员</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="2-Log-hpp"><a href="#2-Log-hpp" class="headerlink" title="2. Log.hpp"></a>2. Log.hpp</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>                                      <span class="comment">// exit, perror</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>                                      <span class="comment">// read, write, close</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span>                                   <span class="comment">// open, close, read, write, lseek</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span>                                    <span class="comment">// mkdir</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span>                                       <span class="comment">// open, O_RDONLY, O_WRONLY, O_CREAT, O_APPEND</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span>                                       <span class="comment">// errno</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span>                                    <span class="comment">// gettimeofday, struct timeval</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span>                                         <span class="comment">// localtime_r, struct tm</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdarg&gt;</span>                                       <span class="comment">// va_list, va_start, va_end</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 管道错误码</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">FIFO_ERROR_CODE</span></span><br><span class="line">&#123;</span><br><span class="line">    FIFO_CREATE_ERR = <span class="number">1</span>,                                 <span class="comment">// 这是创建管道文件失败的错误码</span></span><br><span class="line">    FIFO_DELETE_ERR = <span class="number">2</span>,                                 <span class="comment">// 这是删除管道文件失败的错误码</span></span><br><span class="line">    FIFO_OPEN_ERR                                        <span class="comment">// 这是打开管道文件失败的错误码（枚举会自动赋值为3）</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 日志等级</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Log_Level</span></span><br><span class="line">&#123;</span><br><span class="line">    Fatal,                                               <span class="comment">// 最严重级别</span></span><br><span class="line">    Error,                                               <span class="comment">// 严重错误</span></span><br><span class="line">    Warning,                                             <span class="comment">// 警告</span></span><br><span class="line">    Debug,                                               <span class="comment">// 调试信息</span></span><br><span class="line">    Info                                                 <span class="comment">// 普通信息</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Log</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span>  enable = <span class="number">1</span>;                                     <span class="comment">// 是否启用日志</span></span><br><span class="line">    <span class="type">int</span>  classification = <span class="number">1</span>;                             <span class="comment">// 是否分类</span></span><br><span class="line">    string log_path = <span class="string">&quot;./log.txt&quot;</span>;                       <span class="comment">// 日志存放路径</span></span><br><span class="line">    <span class="type">int</span>  console_out = <span class="number">1</span>;                                <span class="comment">// 是否输出到终端</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 日志等级转换成字符串</span></span><br><span class="line">    <span class="function">string <span class="title">level_to_string</span><span class="params">(<span class="type">int</span> level)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (level)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> Fatal:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;Fatal&quot;</span>;</span><br><span class="line">            <span class="keyword">case</span> Error:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;Error&quot;</span>;</span><br><span class="line">            <span class="keyword">case</span> Warning:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;Warning&quot;</span>;</span><br><span class="line">            <span class="keyword">case</span> Debug:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;Debug&quot;</span>;</span><br><span class="line">            <span class="keyword">case</span> Info:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;Info&quot;</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;None&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前计算机的时间，返回格式：YYYY-MM-DD HH:MM:SS.UUUUUU （含微秒）</span></span><br><span class="line">    <span class="function">string <span class="title">get_current_time</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">timeval</span> tv;                               <span class="comment">// timeval：包含秒和微秒</span></span><br><span class="line">        <span class="built_in">gettimeofday</span>(&amp;tv, <span class="literal">nullptr</span>);                      <span class="comment">// 系统调用：获取当前时间（精确到微秒）</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">tm</span> t;                                     <span class="comment">// tm：分解时间，转格式（年、月、日、时、分、秒）</span></span><br><span class="line">        <span class="built_in">localtime_r</span>(&amp;tv.tv_sec, &amp;t);                     <span class="comment">// 把秒转换成年月日时分秒（本地时区）</span></span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> buffer[<span class="number">64</span>];                                 <span class="comment">// 定义字符数组作为格式化输出的缓冲区</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">snprintf</span>(buffer, <span class="built_in">sizeof</span>(buffer),</span><br><span class="line">                <span class="string">&quot;%04d-%02d-%02d %02d:%02d:%02d.%06ld&quot;</span>,</span><br><span class="line">                t.tm_year + <span class="number">1900</span>,                        <span class="comment">// 年：tm_year 从 1900 开始计数</span></span><br><span class="line">                t.tm_mon + <span class="number">1</span>,                            <span class="comment">// 月：tm_mon 从 0 开始，0 表示 1 月</span></span><br><span class="line">                t.tm_mday,                               <span class="comment">// 日</span></span><br><span class="line">                t.tm_hour,                               <span class="comment">// 时</span></span><br><span class="line">                t.tm_min,                                <span class="comment">// 分</span></span><br><span class="line">                t.tm_sec,                                <span class="comment">// 秒</span></span><br><span class="line">                tv.tv_usec);                             <span class="comment">// 微秒部分，取自 gettimeofday</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">string</span>(buffer);                           <span class="comment">// 转换成 string 返回</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Log</span>() = <span class="keyword">default</span>;                                     <span class="comment">// 使用默认构造</span></span><br><span class="line">    <span class="built_in">Log</span>(<span class="type">int</span> enable, <span class="type">int</span> classification, string log_path, <span class="type">int</span> console_out)</span><br><span class="line">        : <span class="built_in">enable</span>(enable),</span><br><span class="line">        <span class="built_in">classification</span>(classification),</span><br><span class="line">        <span class="built_in">log_path</span>(log_path),</span><br><span class="line">        <span class="built_in">console_out</span>(console_out)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 重载函数调用运算符</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> level, <span class="type">const</span> string&amp; format, ...)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (enable == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;                                      <span class="comment">// 日志未启用</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        va_list args;</span><br><span class="line">        <span class="built_in">va_start</span>(args, format);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 计算需要的缓冲区大小</span></span><br><span class="line">        <span class="type">int</span> size = <span class="built_in">vsnprintf</span>(<span class="literal">nullptr</span>, <span class="number">0</span>, format.<span class="built_in">c_str</span>(), args) + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">va_end</span>(args);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (size &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;                                      <span class="comment">// 格式化失败</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 分配缓冲区并格式化字符串</span></span><br><span class="line">        <span class="type">char</span>* buffer = <span class="keyword">new</span> <span class="type">char</span>[size];</span><br><span class="line">        <span class="built_in">va_start</span>(args, format);</span><br><span class="line">        <span class="built_in">vsnprintf</span>(buffer, size, format.<span class="built_in">c_str</span>(), args);</span><br><span class="line">        <span class="built_in">va_end</span>(args);</span><br><span class="line">        </span><br><span class="line">        <span class="function">string <span class="title">content</span><span class="params">(buffer)</span></span>;</span><br><span class="line">        <span class="keyword">delete</span>[] buffer;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 调用原有的处理逻辑</span></span><br><span class="line">        string level_str = <span class="string">&quot;[&quot;</span> + <span class="built_in">level_to_string</span>(level) + <span class="string">&quot;] &quot;</span>;</span><br><span class="line">        string log_message;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (classification == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            log_message = level_str + <span class="string">&quot;[&quot;</span> + <span class="built_in">get_current_time</span>() + <span class="string">&quot;] &quot;</span> + content + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (classification == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            log_message = <span class="string">&quot;[&quot;</span> + <span class="built_in">get_current_time</span>() + <span class="string">&quot;] &quot;</span> + content + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;传入的分类参数错误！\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (console_out == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; log_message;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">log_to_file</span>(level, log_message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 文件路径的后缀处理函数：当按照日志等级分类存储并且文件路径是 &quot;./log.txt&quot; 这种有文件扩展名时的处理方法</span></span><br><span class="line">    <span class="function">string <span class="title">Suffix_processing</span><span class="params">(<span class="type">int</span> level, string log_path)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        string Path;</span><br><span class="line">        <span class="keyword">if</span> (log_path.<span class="built_in">back</span>() == <span class="string">&#x27;/&#x27;</span>)                      <span class="comment">// 如果是一个目录的路径，比如 &quot;./log/&quot;，则最终文件名为 &quot;log_等级名.txt&quot;</span></span><br><span class="line">        &#123;</span><br><span class="line">            Path = log_path + <span class="string">&quot;log_&quot;</span> + <span class="built_in">level_to_string</span>(level) + <span class="string">&quot;.txt&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>                                             <span class="comment">// 如果是一个文件路径，比如 &quot;./log.txt&quot;，则最终文件名为 &quot;log_等级名.txt&quot;</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">size_t</span> pos = log_path.<span class="built_in">find_last_of</span>(<span class="string">&#x27;.&#x27;</span>);     <span class="comment">// 从后往前找到第一个 &#x27;.&#x27; 的位置，即最后一次出现的 &#x27;.&#x27; 的位置</span></span><br><span class="line">            <span class="keyword">if</span> (pos != string::npos)</span><br><span class="line">            &#123;</span><br><span class="line">                string left = log_path.<span class="built_in">substr</span>(<span class="number">0</span>, pos);   <span class="comment">// 去掉后缀，即我所需要的有效的前部分路径</span></span><br><span class="line">                string right = log_path.<span class="built_in">substr</span>(pos);     <span class="comment">// 保留后缀，即有效的文件扩展名</span></span><br><span class="line">                Path = left + <span class="string">&quot;_&quot;</span> + <span class="built_in">level_to_string</span>(level) + right;         <span class="comment">// 组合成新的文件名</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>                                         <span class="comment">// 如果没有文件扩展名（比如 &quot;./log&quot;），则直接在文件名后面加上 &quot;_等级名.txt&quot;</span></span><br><span class="line">            &#123;</span><br><span class="line">                Path = log_path + <span class="string">&quot;_&quot;</span> + <span class="built_in">level_to_string</span>(level) + <span class="string">&quot;.txt&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Path;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 核心写文件函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">log_to_file</span><span class="params">(<span class="type">int</span> level, <span class="type">const</span> string&amp; log_content)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        string Path;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (classification == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Path = <span class="built_in">Suffix_processing</span>(level, log_path);   <span class="comment">// 按照日志等级分类存储</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (classification == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Path = log_path;                             <span class="comment">// 不分类直接使用传入的 log_path</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 追加写入，文件不存在则创建，权限 0644</span></span><br><span class="line">        <span class="type">int</span> fd = <span class="built_in">open</span>(Path.<span class="built_in">c_str</span>(), O_WRONLY | O_CREAT | O_APPEND, <span class="number">0644</span>);</span><br><span class="line">        <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(FIFO_OPEN_ERR);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">write</span>(fd, log_content.<span class="built_in">c_str</span>(), log_content.<span class="built_in">size</span>());</span><br><span class="line">        <span class="built_in">close</span>(fd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="3-UDP-Client-cc"><a href="#3-UDP-Client-cc" class="headerlink" title="3. UDP_Client.cc"></a>3. UDP_Client.cc</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> BUFSIZE = <span class="number">1024</span>;                                  <span class="comment">// 接收服务器响应的缓冲区大小</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Usage</span><span class="params">(string proc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n\r用法: &quot;</span> &lt;&lt; proc &lt;&lt; <span class="string">&quot; 服务器IP 服务器端口号\n&quot;</span> &lt;&lt; <span class="string">&quot;例如: &quot;</span> &lt;&lt; proc &lt;&lt; <span class="string">&quot; 127.0.0.1 8080\n&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 检查命令行参数数量，argc != 3 的原因：</span></span><br><span class="line">    <span class="comment">// argv[0]: 程序名称（如 &quot;./udpclient&quot;），argv[1]: 服务器IP地址（如 &quot;127.0.0.1&quot;），argv[2]: 服务器端口号（如 &quot;8080&quot;）</span></span><br><span class="line">    <span class="keyword">if</span>(argc != <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">Usage</span>(argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 解析命令行参数获取服务器IP和端口</span></span><br><span class="line">    string serverip = argv[<span class="number">1</span>];                              <span class="comment">// 获取服务器IP地址</span></span><br><span class="line">    <span class="type">uint16_t</span> serverport = <span class="built_in">stoi</span>(argv[<span class="number">2</span>]);                    <span class="comment">// 将端口号字符串转换为整数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 构造服务器地址结构</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> server;</span><br><span class="line">    <span class="built_in">bzero</span>(&amp;server, <span class="built_in">sizeof</span>(server));                         <span class="comment">// 内存清零</span></span><br><span class="line">    server.sin_family = AF_INET;                            <span class="comment">// 设置地址族为IPv4</span></span><br><span class="line">    server.sin_port = <span class="built_in">htons</span>(serverport);                    <span class="comment">// 端口号转换为网络字节序</span></span><br><span class="line">    server.sin_addr.s_addr = <span class="built_in">inet_addr</span>(serverip.<span class="built_in">c_str</span>());   <span class="comment">// IP地址转换为网络字节序</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 创建套接字</span></span><br><span class="line">    <span class="type">int</span> sockfd = <span class="built_in">socket</span>(AF_INET, SOCK_DGRAM, <span class="number">0</span>);             <span class="comment">// 创建UDP套接字</span></span><br><span class="line">    <span class="keyword">if</span>(sockfd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;创建套接字失败！&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; &quot;创建套接字成功！&quot; &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 客户端通常不需要显式调用bind函数！</span></span><br><span class="line">    <span class="comment">// 原因：</span></span><br><span class="line">    <span class="comment">// 1. 一个端口号只能被一个进程bind，对server是如此，对于client也是如此</span></span><br><span class="line">    <span class="comment">// 2. 客户端的端口号其实不重要，只要能保证主机上的唯一性就可以</span></span><br><span class="line">    <span class="comment">// 3. 系统会在首次发送数据时自动为客户端分配一个随机端口号（隐式bind）</span></span><br><span class="line">    <span class="comment">// 4. 这样可以避免端口冲突，简化客户端编程</span></span><br><span class="line"></span><br><span class="line">    <span class="type">socklen_t</span> server_len = <span class="built_in">sizeof</span>(server);                   <span class="comment">// 获取地址结构大小，用于后续的sendto和recvfrom函数</span></span><br><span class="line">    string message;                                          <span class="comment">// 存储用户输入的消息</span></span><br><span class="line">    <span class="type">char</span> buffer[BUFSIZE];                                    <span class="comment">// 接收服务器响应的缓冲区</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 循环发送消息并接收服务器响应</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;请输入您要发送的消息@ &quot;</span>;</span><br><span class="line">        <span class="built_in">getline</span>(cin, message);                               <span class="comment">// 读取用户输入的消息</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(message == <span class="string">&quot;q&quot;</span> || message == <span class="string">&quot;exit&quot;</span> || message == <span class="string">&quot;quit&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;客户端退出！&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 发送消息</span></span><br><span class="line">        <span class="comment">// sendto参数说明：sockfd: socket文件描述符，message.c_str(): 要发送的数据，message.size(): 数据长度，</span></span><br><span class="line">        <span class="comment">// 0: 标志位（一般为0），(struct sockaddr *)&amp;server: 目标地址结构，server_len: 地址结构大小</span></span><br><span class="line">        <span class="type">ssize_t</span> send_bytes = <span class="built_in">sendto</span>(sockfd, message.<span class="built_in">c_str</span>(), message.<span class="built_in">size</span>(), <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp; server, server_len);</span><br><span class="line">        <span class="keyword">if</span>(send_bytes &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;发送消息失败！&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; &quot;发送消息成功！&quot; &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6. 接收服务器响应</span></span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> server_response;                   <span class="comment">// 服务器响应的地址结构</span></span><br><span class="line">        <span class="type">socklen_t</span> server_response_len = <span class="built_in">sizeof</span>(server_response);     <span class="comment">// 服务器响应的地址结构大小</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// recvfrom参数说明：socket文件描述符，buffer: 接收缓冲区，缓冲区大小（留一个字节给&#x27;\0&#x27;），标志位（一般为0），发送方地址结构，地址结构大小（传入时是sizeof，返回时是实际大小）</span></span><br><span class="line">        <span class="type">ssize_t</span> recv_bytes = <span class="built_in">recvfrom</span>(sockfd, buffer, <span class="built_in">sizeof</span>(buffer) - <span class="number">1</span>, <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp; server_response, &amp;server_response_len);</span><br><span class="line">        <span class="keyword">if</span> (recv_bytes &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            buffer[recv_bytes] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">// 添加字符串结束符</span></span><br><span class="line">            <span class="comment">//cout &lt;&lt; &quot;收到服务器响应 (&quot; &lt;&lt; recv_bytes &lt;&lt; &quot; 字节): &quot; &lt;&lt; buffer &lt;&lt; endl;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (recv_bytes == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;服务器关闭连接&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;接收数据失败&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7. 关闭套接字</span></span><br><span class="line">    <span class="built_in">close</span>(sockfd);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;客户端socket已关闭&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-Main-cc"><a href="#4-Main-cc" class="headerlink" title="4. Main.cc"></a>4. Main.cc</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;UDP_Server.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Usage</span><span class="params">(string proc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n\r用法: &quot;</span> &lt;&lt; proc &lt;&lt; <span class="string">&quot; 端口号[1024+]\n&quot;</span> &lt;&lt; <span class="string">&quot;说明: 端口号建议使用1024以上的端口，避免与系统保留端口冲突\n&quot;</span> &lt;&lt; <span class="string">&quot;示例: &quot;</span> &lt;&lt; proc &lt;&lt; <span class="string">&quot; 8080\n&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对命令进行安全检查</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SafeCheck</span><span class="params">(<span class="type">const</span> string&amp; cmd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 可能不安全的命令，可自行添加</span></span><br><span class="line">    vector&lt;string&gt; unsafe = &#123;</span><br><span class="line">        <span class="string">&quot;rm&quot;</span>,</span><br><span class="line">        <span class="string">&quot;mv&quot;</span>,</span><br><span class="line">        <span class="string">&quot;cp&quot;</span>,</span><br><span class="line">        <span class="string">&quot;kill&quot;</span>,</span><br><span class="line">        <span class="string">&quot;sudo&quot;</span>,</span><br><span class="line">        <span class="string">&quot;unlink&quot;</span>,</span><br><span class="line">        <span class="string">&quot;uninstall&quot;</span>,</span><br><span class="line">        <span class="string">&quot;yum&quot;</span>,</span><br><span class="line">        <span class="string">&quot;top&quot;</span>,</span><br><span class="line">        <span class="string">&quot;while&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span>&amp; danger_cmd : unsafe)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 检查命令中是否包含危险命令</span></span><br><span class="line">        <span class="keyword">if</span>(cmd.<span class="built_in">find</span>(danger_cmd) != string::npos)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 找到危险命令，返回false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理收到的消息</span></span><br><span class="line"><span class="function">string <span class="title">Handler</span><span class="params">(<span class="type">const</span> string&amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string ret = <span class="string">&quot;服务器收到一条消息: &quot;</span>;</span><br><span class="line">    ret += s;</span><br><span class="line">    cout &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以直接执行命令的函数</span></span><br><span class="line"><span class="function">string <span class="title">ExcuteCommand</span><span class="params">(<span class="type">const</span> string&amp; cmd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;获取一个请求命令: &quot;</span> &lt;&lt; cmd &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">SafeCheck</span>(cmd))</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;这是一个不安全的命令，已经发现，并且拒绝执行！&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Unsafe commands!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// popen 用于创建管道并读取命令，参数：要执行的命令，打开管道的模式（&quot;r&quot;：读）</span></span><br><span class="line">    FILE *fp = <span class="built_in">popen</span>(cmd.<span class="built_in">c_str</span>(), <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">nullptr</span> == fp)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;popen&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;error&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string ret;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">4096</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> *ok = <span class="built_in">fgets</span>(buffer, <span class="built_in">sizeof</span>(buffer), fp);</span><br><span class="line">        <span class="keyword">if</span>(ok == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ret += buffer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pclose</span>(fp);                                                 <span class="comment">// 关闭管道</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 检查命令行参数数量，argc != 2 的原因：</span></span><br><span class="line">    <span class="comment">// argv[0]: 程序名称（如 &quot;./udpserver&quot;），argv[1]: 监听端口号（如 &quot;8080&quot;）</span></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">Usage</span>(argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析端口号参数</span></span><br><span class="line">    <span class="type">uint16_t</span> port = std::<span class="built_in">stoi</span>(argv[<span class="number">1</span>]);                         <span class="comment">// 将字符串端口号转换为整数</span></span><br><span class="line"></span><br><span class="line">    <span class="function">unique_ptr&lt;UDP_Server&gt; <span class="title">svr</span><span class="params">(<span class="keyword">new</span> UDP_Server(port))</span></span>;           <span class="comment">// 使用智能指针创建UDP服务器对象,自动内存管理，避免内存泄漏</span></span><br><span class="line">    svr-&gt;<span class="built_in">Init</span>();                                                <span class="comment">// 初始化服务器</span></span><br><span class="line">    svr-&gt;<span class="built_in">Run</span>(Handler);                                          <span class="comment">// 启动服务器，可选择的函数：Handler、ExcuteCommand</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-TCP-服务器和客户端-Demo"><a href="#5-TCP-服务器和客户端-Demo" class="headerlink" title="5. TCP 服务器和客户端 Demo"></a>5. TCP 服务器和客户端 Demo</h2><p>这部分的代码和文件较多，不便展示，可前往 GitHub 查看 <a href="https://github.com/huangcancan-xbc/Linux/tree/master/coding/network/TCP">TCP 服务器和客户端 Demo</a>。</p><blockquote><p><a href="https://blog.csdn.net/chenlong_cxy/article/details/124650187">网络编程套接字（二） | CSDN</a></p><p><a href="https://developer.aliyun.com/article/1560275?spm=5176.26934562.main.6.4933223ecWBbBg">【网络编程入门】TCP 与 UDP 通信实战：从零构建服务器与客户端对话（附简易源码，新手友好！） | 阿里云</a></p></blockquote><h2 id="6-守护进程"><a href="#6-守护进程" class="headerlink" title="6. 守护进程"></a>6. 守护进程</h2><h3 id="1-什么是会话（Session）？"><a href="#1-什么是会话（Session）？" class="headerlink" title="1. 什么是会话（Session）？"></a>1. 什么是会话（Session）？</h3><p>会话是 Linux 中进程管理的一个逻辑单位，对应一次 “登录会话”，<strong>一次登录（通过 SSH 登录到服务器）就创建了一个“会话”</strong>。这个“会话”在 Linux 中对应的是一个 <strong>shell 进程</strong>（如 bash），这是我们与 OS 交互的入口。一个会话包含：</p><ul><li>一个 <strong>控制终端</strong>（在 Xshell 中看到的命令行界面）；</li><li><strong>多个进程</strong>，然而一些进程之间又有关联，进而形成多个 <strong>进程组</strong>，但同一时间 <strong>只有一个进程组能成为前台进程组</strong>，其余均为后台进程组。</li></ul><blockquote><p><strong>进程组</strong> 是一组相关进程的集合（比如一个程序启动的主进程和它的子进程），共享同一个 <strong>进程组 ID（PGID）</strong>，由进程组首进程（创建该组的进程）的 PID 决定。</p></blockquote><p><strong>会话的生命周期与你的登录状态绑定：</strong> 当退出登录（关闭 Xshell 窗口或执行 <code>exit</code>），会话会终止，默认会向会话内的所有进程发送终止信号 <strong>SIGHUP</strong>（挂断信号，信号 1），除非它们被“脱离”了会话（如使用 <code>nohup</code> 或 <code>disown</code>）。</p><h3 id="2-前台进程-vs-后台进程"><a href="#2-前台进程-vs-后台进程" class="headerlink" title="2. 前台进程 vs 后台进程"></a>2. 前台进程 vs 后台进程</h3><ol><li><strong>前台进程：</strong> 占据终端，可以接收键盘输入（如 Ctrl+C、Ctrl+Z），一次只能有一个前台进程，在终端输入命令后直接执行的程序默认是前台进程。</li><li><strong>后台进程：</strong> 不占用终端，不能直接接收键盘输入，可以同时运行多个进程（任务），输出仍可能打印到终端（除非重定向）。</li></ol><blockquote><p><strong>前、后台进程也称作前、后台任务，一个会话只能有一个前台进程，键盘信号只能发给前台进程！</strong></p></blockquote><hr><h3 id="3-作业号-vs-进程-ID（PID）"><a href="#3-作业号-vs-进程-ID（PID）" class="headerlink" title="3. 作业号 vs 进程 ID（PID）"></a>3. 作业号 vs 进程 ID（PID）</h3><p><code>jobs</code> 显示的是 <strong>作业号</strong>（如 <code>%1</code>），是 shell 内部编号。<code>ps</code> 命令显示的是 <strong>进程 ID（PID）</strong>，是系统级唯一标识。可以用 <code>%1</code> 来引用作业，如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> %1        <span class="comment"># 终止作业1</span></span><br><span class="line"><span class="built_in">fg</span> %1          <span class="comment"># 前台恢复作业1</span></span><br><span class="line"><span class="built_in">bg</span> %1          <span class="comment"># 后台恢复作业1</span></span><br></pre></td></tr></table></figure><p><code>ps ajx | head -n 1; ps ajx | grep a.out</code> 查看示例进程的相关信息：</p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250819135425291.png" alt="PixPin_2025-08-19_13-54-00"></p><h3 id="4-作业控制命令"><a href="#4-作业控制命令" class="headerlink" title="4. 作业控制命令"></a>4. 作业控制命令</h3><p>Linux shell（如 bash）支持“作业控制”，允许管理前台&#x2F;后台任务。用一个简单的代码示例并编译成 a.out 可执行程序，来体会作业控制：</p><ul><li><p><code>&amp;</code>：在命令末尾添加 <code>&amp;</code>，表示 “启动该命令后立即将其放入后台运行”，终端不等待命令执行完成，直接返回提示符，允许你继续输入其他命令。示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./a.out &gt;&gt; log.txt &amp;  <span class="comment"># 将a.out放入后台，输出重定向到log.txt</span></span><br><span class="line"><span class="built_in">sleep</span> 100 &amp;           <span class="comment"># 后台休眠100秒</span></span><br></pre></td></tr></table></figure><ul><li><strong>区分 <code>&amp;</code> 用法的核心原则在于位置判断：</strong><ul><li>若 <code>&amp;</code> 在 <strong>命令末尾</strong>，且不是条件表达式的一部分 → 后台运行命令。</li><li>若 <code>&amp;</code> 在 <strong>两个命令之间</strong> → 并行启动两个后台命令。</li><li>若 <code>&amp;</code> 在 **<code>[[ ]]</code> 或 <code>$(( ))</code> 内部 ** → 按位与运算。</li></ul></li></ul></li><li><p><code>jobs</code>：查看当前会话中所有 <strong>后台进程（任务）的状态</strong>。<strong><code>[1]</code> 是作业号（Job ID），<code>+</code> 表示默认作业</strong>。示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1]+  Running                 ./a.out &gt;&gt; log.txt &amp;</span><br></pre></td></tr></table></figure></li><li><p><code>fg</code>：将一个后台（或暂停）的作业调到 <strong>前台（SIGCONT）继续运行</strong>。示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">fg</span> %1</span><br><span class="line">./a.out          <span class="comment"># 现在在前台运行，可接收 Ctrl+C</span></span><br></pre></td></tr></table></figure></li><li><p><code>Ctrl+Z</code>：给 <strong>前台</strong> 进程组发 <strong>SIGTSTP（19 号信号）</strong>，把它“<strong>暂停</strong>”成可后台继续的作业（<code>T</code> 状态）。<code>a.out</code> 被暂停，不再运行，但未退出，示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ./a.out        <span class="comment"># 前台运行</span></span><br><span class="line">^Z               <span class="comment"># 按 Ctrl+Z</span></span><br><span class="line">[1]+  Stopped     ./a.out</span><br></pre></td></tr></table></figure></li><li><p><code>bg</code>：让一个被暂停的作业在后台 <strong>继续运行</strong>。示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">bg</span> %1          <span class="comment"># 或直接 bg（作用于默认作业）</span></span><br><span class="line">[1]+ ./a.out &gt;&gt; log.txt &amp;</span><br></pre></td></tr></table></figure></li><li><p><code>kill -SIGTERM %1</code> &#x2F; <code>kill -9 %1</code>：给作业发信号（<code>%1</code> 是作业号，和 PID 不同）。</p></li><li><p><code>disown -h %1</code>：把作业从当前 shell 的作业表 <strong>剥离</strong>，不再受 SIGHUP 影响。示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./a.out &gt;&gt; log.txt &amp;</span><br><span class="line"><span class="built_in">disown</span> %1</span><br></pre></td></tr></table></figure></li><li><p><code>nohup</code>：让进程 <strong>忽略 SIGHUP</strong>，常配合重定向使用，退出登录，进程仍运行：<code>nohup ./a.out &gt;&gt; log.txt &amp;</code>。</p></li></ul><hr><h3 id="5-守护进程"><a href="#5-守护进程" class="headerlink" title="5. 守护进程"></a>5. 守护进程</h3><blockquote><p><a href="https://www.bilibili.com/video/BV1EG4y1d7rp/?share_source=copy_web&vd_source=872e5e3ccf44874c39edaf42e30ab0de">【linux 操作系统技巧】Linux: 守护进程介绍快来看看吧 | B 站</a></p></blockquote><h4 id="1-什么是守护进程？"><a href="#1-什么是守护进程？" class="headerlink" title="1. 什么是守护进程？"></a>1. 什么是守护进程？</h4><p><strong>守护进程（Daemon）</strong> 是一种长期运行的后台进程，<strong>不依赖于任何终端或用户会话</strong>。它们通常在系统启动时启动，直到系统关闭才停止。常见例子：<code>sshd</code>（SSH 服务）、<code>httpd</code>（Web 服务）、<code>crond</code>（定时任务）。</p><h4 id="2-守护进程的特点"><a href="#2-守护进程的特点" class="headerlink" title="2. 守护进程的特点"></a>2. 守护进程的特点</h4><ol><li><strong>脱离终端与会话</strong>：通常是会话领导者，避免被 SIGHUP 杀死。</li><li><strong>双 fork 技术</strong>：创建守护进程时通常 fork 两次，确保不成为进程组领导者。</li><li><strong>重定向标准流</strong>：将 stdin、stdout、stderr 重定向到 <code>/dev/null</code> 或日志文件。</li><li><strong>工作目录</strong>：通常切换到 <code>/</code> 或固定目录，避免阻塞文件系统卸载。</li></ol><h3 id="6-dev-null-是什么？"><a href="#6-dev-null-是什么？" class="headerlink" title="6. /dev/null 是什么？"></a>6. <code>/dev/null</code> 是什么？</h3><p><strong>本质</strong>：<code>/dev/null</code> 是一个特殊的字符设备文件，被称为 <strong>黑洞设备</strong>，也叫“<strong>空设备</strong>”，我们只要把它当作垃圾桶就好。</p><p><strong>行为</strong>：</p><ul><li>往它里面写任何东西，<strong>直接丢弃</strong>，就像写到空气里。</li><li>从它里面读，总是 <strong>立刻返回 EOF</strong>（表示空文件，没数据）。</li></ul><p>所以很多守护进程会把 <strong>标准输入&#x2F;输出&#x2F;错误</strong> 重定向到 <code>/dev/null</code>，避免占用终端。那么它到底有什么用？</p><p>在守护进程中，标准输入（stdin）、标准输出（stdout）、标准错误（stderr）必须被重定向，否则：</p><ul><li>如果进程尝试读 stdin → 会出错（因为没有终端）。</li><li>如果写 stdout&#x2F;stderr → 输出无处可去，可能引发异常或写入旧终端。</li></ul><p><strong>所以，把这三个标准流重定向到 <code>/dev/null</code> 是一种安全兜底措施，确保：不会因为读写标准流而崩溃、不会干扰原终端或产生混乱输出。</strong></p><hr><h3 id="7-setsid-函数原型"><a href="#7-setsid-函数原型" class="headerlink" title="7. setsid() 函数原型"></a>7. <code>setsid()</code> 函数原型</h3><ol><li><p><strong>作用：</strong> 创建一个新的 <strong>会话</strong>，并成为该会话的会话首进程，同时成为新的 <strong>进程组组长</strong>，脱离当前控制终端，不再受键盘信号影响。</p></li><li><p><strong>函数原型</strong></p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">setsid</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><ol start="3"><li><p><strong>使用条件（fork 一次 + setsid 的经典组合）：</strong></p><ul><li><p>调用 <code>setsid()</code> 的进程 <strong>不能</strong> 是进程组组长，否则会失败返回 <code>-1</code>。</p></li><li><p>所以通常先 <code>fork()</code> 一次，让子进程保证不是组长，再在子进程里 <code>setsid()</code>。</p></li></ul></li><li><p>代码示例：</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> string nullfile = <span class="string">&quot;/dev/null&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Daemon</span><span class="params">(<span class="type">const</span> string &amp;cwd = <span class="string">&quot;&quot;</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1. 忽略其他异常信号</span></span><br><span class="line">    <span class="built_in">signal</span>(SIGCLD, SIG_IGN);</span><br><span class="line">    <span class="built_in">signal</span>(SIGPIPE, SIG_IGN);</span><br><span class="line">    <span class="comment">// signal(SIGSTOP, SIG_IGN);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 将自己变成独立的会话</span></span><br><span class="line">    <span class="keyword">if</span> (fork() &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">setsid</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 更改当前调用进程的工作目录</span></span><br><span class="line">    <span class="keyword">if</span> (!cwd.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">chdir</span>(cwd.<span class="built_in">c_str</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 标准输入，标准输出，标准错误重定向至/dev/null</span></span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">open</span>(nullfile.<span class="built_in">c_str</span>(), O_RDWR);</span><br><span class="line">    <span class="keyword">if</span>(fd &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">dup2</span>(fd, STDIN_FILENO);   <span class="comment">// stdin 重定向，防止后台读键盘阻塞</span></span><br><span class="line">        <span class="built_in">dup2</span>(fd, STDOUT_FILENO);  <span class="comment">// stdout 重定向，不在终端打印</span></span><br><span class="line">        <span class="built_in">dup2</span>(fd, STDERR_FILENO);  <span class="comment">// stderr 重定向，错误也不污染终端</span></span><br><span class="line">        <span class="built_in">close</span>(fd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>守护进程的本质也是孤儿进程！</strong></p></blockquote><h3 id="8-daemon-方法（glibc-提供的简便函数）"><a href="#8-daemon-方法（glibc-提供的简便函数）" class="headerlink" title="8. daemon() 方法（glibc 提供的简便函数）"></a>8. <code>daemon()</code> 方法（glibc 提供的简便函数）</h3><p>Linux glibc 提供了一个库函数 <strong><code>daemon()</code></strong>，可以 <strong>自动</strong> 完成守护进程化，这会简化守护进程，方便我们的编码。</p><ol><li><strong>函数原型</strong></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">daemon</span><span class="params">(<span class="type">int</span> nochdir, <span class="type">int</span> noclose)</span>;</span><br></pre></td></tr></table></figure><ol start="2"><li><p><strong>参数</strong>：</p><ul><li><p><code>nochdir = 0</code> → 把工作目录切换到根目录 <code>/</code>；</p></li><li><p><code>noclose = 0</code> → 把 <code>stdin/stdout/stderr</code> 重定向到 <code>/dev/null</code>。</p></li></ul></li><li><p><strong>返回值</strong>：成功返回 <code>0</code>，失败返回 <code>-1</code>。</p></li><li><p><strong>代码示例</strong>：</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建守护进程</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">daemon</span>(<span class="number">0</span>, <span class="number">0</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;daemon&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 守护进程的主循环</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 写日志或者处理任务</span></span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>daemon()</code> 内部其实就做了手写的那些步骤：<code>fork</code>、<code>setsid</code>、<code>chdir</code>、<code>dup2</code> 到 <code>/dev/null</code>，所以用起来更方便。需要注意的是：<code>daemon()</code> 没有做 <strong>双重 fork</strong>、也不处理 <code>umask</code>，所以 <strong>严格场景</strong> 下（比如写系统级服务），还是建议手写模板或用 <strong>systemd</strong> 管理。</p></blockquote><h2 id="7-配置安全组规则"><a href="#7-配置安全组规则" class="headerlink" title="7. 配置安全组规则"></a>7. 配置安全组规则</h2><p>安全组就像是一个虚拟防火墙，用于控制云服务器的入站和出站流量。默认情况下，安全组拒绝所有来自外部的入站请求。以我的华为云 Flexus 应用服务器 L 实例为例，在安全组中开放 3000-20000 端口（个人自定义范围）后，就相当于在防火墙上开了一个 “口子”，这样就允许外部设备通过这些端口与云服务器上的服务进行通信了，将自己的客户端发给朋友运行，本机的服务器就可以开始通信了。</p><p>不同厂商的配置大同小异，因为这部分配置比较简单，就不演示了，实在不会，B 站的教程相当多，这里仅提供示例配置：</p><ul><li>优先级：1</li><li>策略：允许</li><li>类型：IPv4</li><li>协议端口：TCP : 3000-20000</li><li>源地址：0.0.0.0</li></ul><p><strong>隐私安全考虑：</strong></p><ol><li><strong>及时关闭不必要规则</strong>：在演示完成后，如果这些开放的安全组规则不再需要，应及时将其关闭。否则，服务器可能会面临潜在的安全风险，比如恶意攻击者可能会利用开放的端口尝试进行入侵、扫描或其他非法操作。</li><li><strong>最小权限原则</strong>：在配置安全组规则时就应遵循最小权限原则，即只开放那些确实需要用于演示通信的端口和协议，有需要可以限制来源 IP 范围。</li><li><strong>数据隐私方面</strong>：除了端口规则外，还要注意通信过程中涉及的数据是否包含敏感信息。如果有，需要确保数据在传输（如采用加密协议）和存储过程中的安全性，避免隐私数据泄露。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>045 网络基础</title>
      <link href="/posts/47537.html"/>
      <url>/posts/47537.html</url>
      
        <content type="html"><![CDATA[<h1 id="网络基础"><a href="#网络基础" class="headerlink" title="网络基础"></a>网络基础</h1><blockquote><p><a href="https://www.cnblogs.com/yuanyuzhou/p/16195954.html">网络入门基础 | 博客园</a></p></blockquote><h2 id="1-计算机网络背景"><a href="#1-计算机网络背景" class="headerlink" title="1. 计算机网络背景"></a>1. 计算机网络背景</h2><h3 id="1-网络发展"><a href="#1-网络发展" class="headerlink" title="1. 网络发展"></a>1. 网络发展</h3><p>计算机网络的发展是技术迭代与需求驱动共同作用出的历史必然结果，据搜索：可大致分为以下 5 个关键阶段：</p><h4 id="1-起源：军事科研的-“抗毁通信”-需求（20-世纪-60-年代末）"><a href="#1-起源：军事科研的-“抗毁通信”-需求（20-世纪-60-年代末）" class="headerlink" title="1. 起源：军事科研的 “抗毁通信” 需求（20 世纪 60 年代末）"></a>1. 起源：军事科研的 “抗毁通信” 需求（20 世纪 60 年代末）</h4><ul><li><strong>核心事件</strong>：1969 年，美国国防部高级研究计划局（ARPA）启动了 ARPANET（阿帕网）项目。当时正值冷战，美国军方需要一种 “去中心化” 的通信网络 —— 即使部分节点被摧毁，其余节点仍能正常通信。</li><li><strong>技术特点</strong>：ARPANET 最初仅连接了加州大学洛杉矶分校、斯坦福研究院等 4 个节点，采用 “分组交换” 技术（将数据拆分成小数据包传输，提高效率和抗毁性），这是现代网络的核心底层逻辑雏形。</li></ul><h4 id="2-互联基础：TCP-IP-协议的诞生（20-世纪-70-年代）"><a href="#2-互联基础：TCP-IP-协议的诞生（20-世纪-70-年代）" class="headerlink" title="2. 互联基础：TCP&#x2F;IP 协议的诞生（20 世纪 70 年代）"></a>2. 互联基础：TCP&#x2F;IP 协议的诞生（20 世纪 70 年代）</h4><ul><li><strong>核心问题</strong>：随着网络节点增多，不同网络（如 ARPANET 与其他科研网络）因 “语言不通” 无法互通。</li><li><strong>关键突破</strong>：1974 年，文顿 ・ 瑟夫（Vinton Cerf）和罗伯特 ・ 卡恩（Robert Kahn）提出了 <strong>TCP&#x2F;IP 协议族</strong>（传输控制协议 &#x2F; 网际协议）。其中，IP 协议负责 “定位” 网络中的设备（类似地址），TCP 协议负责 “可靠传输” 数据（确保数据完整、有序到达）。</li><li><strong>意义</strong>：TCP&#x2F;IP 协议解决了 “不同网络如何互联” 的问题，成为全球网络的 “通用语言”，为互联网的全球化奠定了基础。</li></ul><h4 id="3-扩张：从军事到学术的开放（20-世纪-80-年代）"><a href="#3-扩张：从军事到学术的开放（20-世纪-80-年代）" class="headerlink" title="3. 扩张：从军事到学术的开放（20 世纪 80 年代）"></a>3. 扩张：从军事到学术的开放（20 世纪 80 年代）</h4><ul><li><strong>核心事件</strong>：1986 年，美国国家科学基金会（NSF）建立了 NSFNET（国家科学基金会网络），将全美高校和科研机构的网络连接起来，并开放了 TCP&#x2F;IP 协议的使用权限。</li><li><strong>变化</strong>：网络用途从军事转向学术研究，科学家、教授可以通过网络共享数据、协作研究，网络规模快速扩大，节点数从数百增长到数万。</li></ul><h4 id="4-普及：万维网与浏览器让互联网-“触手可及”（20-世纪-90-年代）"><a href="#4-普及：万维网与浏览器让互联网-“触手可及”（20-世纪-90-年代）" class="headerlink" title="4. 普及：万维网与浏览器让互联网 “触手可及”（20 世纪 90 年代）"></a>4. 普及：万维网与浏览器让互联网 “触手可及”（20 世纪 90 年代）</h4><ul><li><strong>核心突破</strong>：1989 年，英国科学家蒂姆 ・ 伯纳斯 - 李（Tim Berners-Lee）在欧洲核子研究中心（CERN）提出 “万维网（WWW）” 构想，通过 “超文本传输协议（HTTP）” 和 “统一资源定位符（URL）” 实现文本、图片等内容的跨网络链接；1993 年，Mosaic 浏览器（首款图形化浏览器）诞生，普通人无需专业知识即可上网。</li><li><strong>意义</strong>：互联网从 “科研工具” 转变为大众可使用的信息平台，网页、电子邮件、早期搜索引擎（如 Yahoo）开始普及，标志着 “互联网时代” 正式到来。</li></ul><h4 id="5-爆发：移动化、智能化与全场景渗透（21-世纪至今）"><a href="#5-爆发：移动化、智能化与全场景渗透（21-世纪至今）" class="headerlink" title="5. 爆发：移动化、智能化与全场景渗透（21 世纪至今）"></a>5. 爆发：移动化、智能化与全场景渗透（21 世纪至今）</h4><ul><li><strong>技术驱动</strong>：宽带网络（提高传输速度）、移动互联网（3G&#x2F;4G&#x2F;5G 让网络摆脱有线束缚）、社交媒体（如 Facebook、微信）、云计算（远程存储与算力共享）、物联网（设备互联）等技术持续突破。</li><li><strong>现状</strong>：互联网从 “信息传递工具” 升级为 “社会基础设施”，渗透到购物、办公、教育、医疗等几乎所有领域，形成了 “万物互联” 的数字生态。</li></ul><h3 id="2-网络连接形态演进"><a href="#2-网络连接形态演进" class="headerlink" title="2. 网络连接形态演进"></a>2. 网络连接形态演进</h3><h4 id="1-独立模式-——-计算机之间相互独立，数据封闭"><a href="#1-独立模式-——-计算机之间相互独立，数据封闭" class="headerlink" title="1. 独立模式 —— 计算机之间相互独立，数据封闭"></a>1. 独立模式 —— 计算机之间相互独立，数据封闭</h4><p>这是网络发展最原始的状态 —— 计算机相互独立，数据、业务完全本地化。</p><ul><li><strong>特点</strong>：每个终端（A&#x2F;B&#x2F;C）“各自为战”，业务 ①&#x2F;②&#x2F;③ 的数据只存在于对应终端；人（小松、小竹、小梅 ）要切换业务，必须 “物理移动” 到对应终端前，且需等待前一个人用完（串行处理）。</li><li><strong>本质</strong>：没有网络连接，设备间无法协同，资源（数据、算力）无法共享，效率极低。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250808002036571.png"></p><h4 id="2-网络互联-——-多台计算机连接在一起，完成数据共享"><a href="#2-网络互联-——-多台计算机连接在一起，完成数据共享" class="headerlink" title="2. 网络互联 —— 多台计算机连接在一起，完成数据共享"></a>2. 网络互联 —— 多台计算机连接在一起，完成数据共享</h4><p>随着需求升级，“多机互联 + 服务器集中管理” 的模式出现，解决独立模式的低效问题。</p><ul><li><strong>特点</strong>：引入 “服务器” 作为 “数据中心”，小松、小竹、小梅有了 <strong>专属计算机</strong>，业务 ①&#x2F;②&#x2F;③ 的数据不再分散在终端，而是统一存在服务器里；人无需物理移动，通过专属计算机就能自由切换业务（并行处理）。</li><li><strong>本质</strong>：网络开始发挥 “连接与共享” 价值 —— 通过服务器集中管理数据，多设备可协同，资源利用效率大幅提升。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250808002300554.png"></p><h4 id="3-局域网（LAN）-——-规模扩大，设备分层连接"><a href="#3-局域网（LAN）-——-规模扩大，设备分层连接" class="headerlink" title="3. 局域网（LAN） —— 规模扩大，设备分层连接"></a>3. 局域网（LAN） —— 规模扩大，设备分层连接</h4><p>当用户、设备数量进一步增加，“交换机 + 路由器” 组成的局域网架构出现，解决 <strong>多设备高效组网</strong> 问题。</p><ul><li><strong>特点</strong>：用交换机连接 “同一区域内的设备”（如一个办公室 &#x2F; 楼层），再通过路由器实现 “不同交换机间的连接”；设备数量突破 “几台” 的限制，形成 <strong>小规模、本地化的网络集群</strong>。</li><li><strong>本质</strong>：通过 “分层设备（交换机负责内网，路由器负责跨网段）”，让更多设备有序连接，支持更复杂的本地组网需求（比如企业内部、校园网络 ）。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250808002835147.png"></p><h4 id="4-广域网（WAN）-——-打破地域，全局互联"><a href="#4-广域网（WAN）-——-打破地域，全局互联" class="headerlink" title="4. 广域网（WAN） —— 打破地域，全局互联"></a>4. 广域网（WAN） —— 打破地域，全局互联</h4><p>最终，网络突破 “本地” 限制，走向广域互联，将远隔干里的计算机都连在一起。</p><ul><li><strong>特点</strong>：用路由器连接 “不同地域的局域网”（如大阪、东京、洛杉矶的 LAN），形成跨城市、跨国家的 <strong>广域网络</strong>；“局域网” 和 “广域网” 的边界被模糊（本质是 “更大范围的连接”）。</li><li><strong>本质</strong>：网络从 “本地化协同” 升级为 “全球化互联”，支持跨地域的数据传输、资源共享（比如你在上海访问美国服务器的内容 ）。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250808003003883.png"></p><p><strong>所谓 “局域网” 和 “广域网” 只是一个相对的概念，还有 “天朝特色” 的城域网，城域网是 介于局域网和广域网之间，以城市为主要覆盖范围的专用 &#x2F; 公用网络 ，它的本质是 局域网技术在城市规模上的应用拓展 ，我们只需要将其看做一个比较大的局域网即可。</strong></p><h2 id="2-认识协议"><a href="#2-认识协议" class="headerlink" title="2. 认识协议"></a>2. 认识协议</h2><h3 id="1-协议的本质"><a href="#1-协议的本质" class="headerlink" title="1. 协议的本质"></a>1. 协议的本质</h3><p><strong>网络协议本质就是一种约定</strong>。它规定了网络中设备如何通信、数据怎么传输之类的。就好比大家都说同一种语言才能交流，网络协议就是网络设备之间交流的“语言”，像 TCP&#x2F;IP 协议就是很常用的，它保证了全球的网络能有序联通。</p><p>打个比方，就像我们在路上开车，得遵守交通规则，红灯停绿灯行，大家都这么做，交通才能顺畅。网络协议也是，它规定了数据在网络里怎么打包、传输、接收和处理。不同的网络设备，像电脑、手机、服务器等，只有都按照这些协议来“行事”，数据才能准确无误地在它们之间传递，这样我们才能正常上网冲浪、收发邮件什么的，所以说它就是一种大家都得遵守的约定。</p><h3 id="2-计算机中协议的理解"><a href="#2-计算机中协议的理解" class="headerlink" title="2. 计算机中协议的理解"></a>2. 计算机中协议的理解</h3><ul><li><strong>协议的生活类比</strong>：快递盒子上的快递单就类似协议，只有双方按格式填写，寄件人和收件人才能达成协议&#x2F;约定完成“联通”。同样的，收快递时收件人不只是收到了快递，还收到了快递单的信息，在实际计算机中也是如此，当我们收到信息时，同时也收到了协议报头等信息。</li><li><strong>计算机协议理解：</strong><ul><li>协议用结构体表示成二进制数据，添加报头后传输。</li><li>同一网络下，双方用相同源代码可认识协议结构体。</li><li>协议本质是二进制约定，用结构体定义公共数据类型。</li></ul></li><li><strong>光电信号含义</strong>：计算机传光电信号，其含义由协议遵守的源代码解释。</li></ul><h3 id="3-网络协议的标准"><a href="#3-网络协议的标准" class="headerlink" title="3. 网络协议的标准"></a>3. 网络协议的标准</h3><ul><li><strong>网络标准定制</strong>：网络通信需统一标准，含软硬件多方面，常由顶级团队定制并推广。</li><li><strong>标准推动因素</strong>：各厂商需要标准协议，否则无法进行连通，典型的有各手机厂商他们的充电协议、适配苹果等。标准被接受的驱动力是创造价值，吸引他人参与，一般推翻较难。</li><li><strong>技术落地关键</strong>：技术要找应用场景，创造价值，才能获广泛使用，改变世界。</li><li><strong>网络协议分层</strong>：网络协议分层是因传送问题复杂，需逐个解决。</li></ul><blockquote><p>一旦某种协议落地，想要推翻其实很难，就像微信用户如此庞大，即使做一个仿微信 APP 也很难受众。像如今 AI 竞争如此激烈，本质上也存在各国之间想要制定一种协议，拿到话语权。</p></blockquote><h2 id="3-分层概念"><a href="#3-分层概念" class="headerlink" title="3. 分层概念"></a>3. 分层概念</h2><h3 id="1-软件分层概念"><a href="#1-软件分层概念" class="headerlink" title="1. 软件分层概念"></a>1. 软件分层概念</h3><p><strong>核心意思</strong>：把复杂的软件系统按功能切成一层一层，每层只关心自己的事情，并且只通过明确的接口与上下层交互。例子：</p><ul><li><strong>C++ 继承 + 多态：</strong> 子类（下层）实现细节变化，不会影响父类（上层）的使用。</li><li><strong>虚拟文件系统（VFS）：</strong> 通过函数指针和统一的数据结构，在用户和硬件驱动之间插入“中间层”，用户不用关心底层硬件细节。</li></ul><h3 id="2-软件分层的原因-维护原则"><a href="#2-软件分层的原因-维护原则" class="headerlink" title="2. 软件分层的原因 &amp; 维护原则"></a>2. 软件分层的原因 &amp; 维护原则</h3><p><strong>为什么要分层？</strong></p><ul><li><strong>降低耦合度</strong>：上层不必依赖下层的具体实现</li><li><strong>便于维护</strong>：大项目拆成小模块，出问题时只修对应的层</li></ul><p><strong>维护原则：</strong></p><ol><li><strong>低耦合</strong>：层与层之间的接口尽量简单、轻量</li><li><strong>高内聚</strong>：同一层的代码、逻辑、数据要紧密相关</li></ol><blockquote><p>  理想设计 &#x3D; <strong>高内聚 + 低耦合</strong></p></blockquote><h3 id="3-网络协议分层的原因"><a href="#3-网络协议分层的原因" class="headerlink" title="3. 网络协议分层的原因"></a>3. 网络协议分层的原因</h3><p>网络通信特别复杂，必须分层：</p><ul><li><strong>技术原因</strong>：模块化管理，方便团队开发、调试和扩展。</li><li><strong>问题本身呈层次性</strong>：<ol><li>主机和相邻设备如何通信（物理&#x2F;链路层问题）</li><li>如何找到目标主机（网络层问题）</li><li>如何保证数据可靠传输（传输层问题）</li></ol></li></ul><h3 id="4-分层结构的类比（电话通信）"><a href="#4-分层结构的类比（电话通信）" class="headerlink" title="4. 分层结构的类比（电话通信）"></a>4. 分层结构的类比（电话通信）</h3><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250808144205310.png"></p><p>打电话时，你觉得自己直接和对方说话，实际上，你是在跟 <strong>电话设备</strong> 交互，信号会经过一系列处理和传输。分为：</p><ul><li><strong>语言层</strong>（人和电话之间的交流协议）</li><li><strong>设备层</strong>（电话设备与通信网络的协议）</li></ul><p>这样做的好处：某一层出问题，不会影响其他层 → 降低维护成本</p><blockquote><p>  分层就是“楼房结构”——每层有自己的功能和规则，楼层之间只通过楼梯&#x2F;电梯（接口）连接，改一层不必拆整栋楼。软件分层如此，网络分层也是如此。</p></blockquote><h2 id="4-OSI-七层模型"><a href="#4-OSI-七层模型" class="headerlink" title="4. OSI 七层模型"></a>4. OSI 七层模型</h2><p>虽 OSI 模型完善，不过因分得过细，工程实践中网络协议层状结构划分为五层协议。</p><table><thead><tr><th>自顶向下层数</th><th>分层名称</th><th>功能</th><th>每层功能概览</th></tr></thead><tbody><tr><td>7</td><td>应用层</td><td>针对特定应用的协议</td><td><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250808132236390.png" alt="PixPin_2025-08-08_13-22-30"></td></tr><tr><td>6</td><td>表示层</td><td>设备固有数据格式和网络标准数据格式的转换</td><td><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250808132319164.png" alt="PixPin_2025-08-08_13-23-13"></td></tr><tr><td>5</td><td>会话层</td><td>通信管理。负责建立和断开通信连接（数据流动的逻辑通路）。管理传输层以下的分层</td><td><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250808132425218.png" alt="PixPin_2025-08-08_13-24-22"></td></tr><tr><td>4</td><td>传输层</td><td>管理两个节点之间的数据传输。负责可靠传输（确保数据被可靠地传送到目标地址）</td><td><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250808132459610.png" alt="PixPin_2025-08-08_13-24-52"></td></tr><tr><td>3</td><td>网络层</td><td>地址管理与路由选择</td><td><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250808132544616.png" alt="PixPin_2025-08-08_13-25-40"></td></tr><tr><td>2</td><td>数据链路层</td><td>互连设备之间传送和识别数据帧</td><td><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250808132649838.png" alt="PixPin_2025-08-08_13-26-47"></td></tr><tr><td>1</td><td>物理层</td><td>以“0”、”1” 代表电压的高低、灯光的闪灭。界定连接器和网线的规格</td><td><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250808132729788.png" alt="PixPin_2025-08-08_13-27-25"></td></tr></tbody></table><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250808134907486.png" alt="PixPin_2025-08-08_13-48-56"></p><hr><h2 id="5-TCP-IP-五层（或四层）模型"><a href="#5-TCP-IP-五层（或四层）模型" class="headerlink" title="5. TCP&#x2F;IP 五层（或四层）模型"></a>5. TCP&#x2F;IP 五层（或四层）模型</h2><p>TCP&#x2F;IP 是一组协议的代名词，它还包括许多协议，共同组成了 TCP&#x2F;IP 协议簇。TCP&#x2F;IP 通讯协议采用了五层的层级结构，每一层都呼叫它的下一层所提供的网络来完成自己的需求。</p><ul><li><strong>物理层：</strong> 负责光&#x2F;电信号的传递方式。比如现在以太网通用的网线（双绞线）、早期以太网采用的同轴电缆（现在主要用于有线电视）、光纤，现在的 WiFi 无线网使用的电磁波等都属于物理层的概念。物理层的能力决定了最大传输速率、传输距离、抗干扰性等。[集线器](<a href="https://www.bing.com/images/search?q=%E9%9B%86%E7%BA%BF%E5%99%A8&form=HDRSC2&first=1">集线器 - Search Images</a>)（Hub）就是工作在物理层的。</li><li><strong>数据链路层：</strong> 负责设备之间的数据帧的传送和识别。例如网卡设备的驱动、帧同步、冲突检测（如果检测到冲突就自动重发）、数据差错校验等工作。数据链路层底层的网络通信标准有很多，如以太网、令牌环网、无线 LAN 等。交换机（Switch）就是工作在数据链路层的。</li><li><strong>网络层：</strong> 负责地址管理和路由选择。例如在 IP 协议中，通过 IP 地址来标识一台主机，并通过路由表的方式规划出两台主机之间数据传输的线路（路由）。路由器（Router）就是工作在网络层的。</li><li><strong>传输层：</strong> 负责两台主机之间的数据传输。例如传输控制协议（TCP），能够确保数据可靠的从源主机发送到目标主机。</li><li><strong>应用层：</strong> 负责应用程序间沟通。比如简单电子邮件传输（SMTP）、文件传输协议（FTP）、网络远程访问协议（Telnet）等。我们的网络编程主要就是针对应用层的。</li></ul><p><strong>标准虽好，但工程中会话和表示层交给应用层完成。网络通信里网络层和传输层最重要，代表性协议分别是 IP 和 TCP。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250808135840129.png" alt="PixPin_2025-08-08_13-58-36"></p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250808135934065.png" alt="PixPin_2025-08-08_13-59-29"></p><p>物理层我们考虑的比较少，因此很多时候也可以称为 TCP&#x2F;IP 四层模型，一般而言：</p><ul><li>对于一台主机，它的操作系统内核实现了从传输层到物理层的内容。</li><li>对于一台路由器，它实现了从网络层到物理层的内容。</li><li>对于一台交换机，它实现了从数据链路层到物理层的内容。</li><li>对于集线器，它只实现了物理层的内容。</li></ul><p>但这并不是绝对的，比如很多交换机也实现了网络层的转发，很多路由器也实现了部分传输层的内容（比如端口转发）。</p><blockquote><p><a href="https://blog.csdn.net/superjunjin/article/details/7841099">TCP&#x2F;IP 四层模型和 OSI 七层模型的概念 | CSDN</a></p></blockquote><hr><h2 id="6-网络传输"><a href="#6-网络传输" class="headerlink" title="6. 网络传输"></a>6. 网络传输</h2><p>以两台主机进行文件传输为例，此时各层对应的协议如下：</p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250808145030202.png" alt="PixPin_2025-08-08_14-50-12"></p><p>首先需要明确的是，同一个局域网内的主机是能够直接进行通信的，因为最初局域网设计的目的，就是为了让局域网内的主机能够进行通信。</p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250808151435992.png" alt="PixPin_2025-08-08_15-12-53"></p><blockquote><p>分用思想：</p><ul><li>几乎任何层的协议，都要提供一种能力，将报头和有效载荷分离的能力。</li><li>几乎任何层的协议，都要在报头中提供，决定将自己的有效载荷交付给上层的哪一个协议的能力一。</li></ul><p>有效载荷：</p><ul><li><strong>在应用层看</strong>：有效载荷就是用户的实际数据（比如聊天文字、图片）。</li><li><strong>在某一协议层看</strong>：有效载荷是来自 <strong>上一层的整个报文</strong>（包括上层的报头和上层的用户数据）。</li></ul></blockquote><p>从下到上分 <strong>链路层、网络层、传输层、应用层</strong>，每层有 “对等协议”（如应用层 FTP、传输层 TCP、网络层 IP ），发数据时上层依赖下层服务，收数据时下层为上层 “解包”，实现 <strong>“逻辑上的端到端通信”</strong>（比如用户 1 和用户 2 的 FTP，看似直接交互，实际依赖各层协议协作）。</p><h3 id="1-数据封装：“加头”-传递，层层打包"><a href="#1-数据封装：“加头”-传递，层层打包" class="headerlink" title="1. 数据封装：“加头” 传递，层层打包"></a>1. 数据封装：“加头” 传递，层层打包</h3><ol><li><p><strong>应用层：</strong> 用户进程生成数据（如“你好”），传递给应用层协议（如 FTP）。应用层协议可能添加一些信息（如“V1”）。</p></li><li><p><strong>传输层：</strong> 数据传递到传输层，传输层协议（如 TCP）对其进行封装。TCP 添加序列号、确认号等控制信息，形成 TCP 段（数据段、数据报）。例如：“序号 V1 你好”。</p></li><li><p><strong>网络层：</strong> 数据传递到网络层，网络层协议（如 IP）添加源 IP 地址和目的 IP 地址等头部信息，标识 “主机位置”，形成 IP <strong>数据包</strong>。例如：“src, dst 序号 V1 你好”。</p></li><li><p><strong>链路层：</strong> 数据传递到链路层，链路层协议（如以太网）添加源 MAC 地址和目的 MAC 地址等头部信息，标识 “局域网设备”，形成 <strong>以太帧</strong>。例如：“src mac dst mac src, dst 序号 V1 你好”。</p></li><li><p><strong>物理层：</strong> 最终，数据被转换为二进制信号，通过物理介质（如以太网电缆）发送出去。</p></li></ol><h3 id="2-解包：“拆头”-还原，层层上交"><a href="#2-解包：“拆头”-还原，层层上交" class="headerlink" title="2. 解包：“拆头” 还原，层层上交"></a>2. 解包：“拆头” 还原，层层上交</h3><p>接收方相反：链路层先拆 “以太网头”，交给网络层；网络层拆 “IP 头”，交给传输层；传输层拆 “TCP 头”，还原出应用层数据，最终交给用户（如 FTP 服务器收到 “V1 你好” ）。</p><h3 id="3-放大网络传输过程"><a href="#3-放大网络传输过程" class="headerlink" title="3. 放大网络传输过程"></a>3. 放大网络传输过程</h3><p>数据 <strong>封装</strong> 的过程：</p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250808153856672.png" alt="PixPin_2025-08-08_15-38-41"></p><p>数据 <strong>分用</strong> 的过程：</p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250808153953492.png" alt="PixPin_2025-08-08_15-39-44"></p><h2 id="7-以太网通信"><a href="#7-以太网通信" class="headerlink" title="7. 以太网通信"></a>7. 以太网通信</h2><h3 id="1-以太网命名的由来"><a href="#1-以太网命名的由来" class="headerlink" title="1. 以太网命名的由来"></a>1. 以太网命名的由来</h3><p>19 世纪，物理学家假设宇宙中充满 “以太”，认为它是光传播的介质。虽然后来实验证明以太并不存在，但这个词却留在了科学史上，带着一点浪漫色彩和遗憾意味。1973 年，美国施乐公司罗伯特·梅特卡夫正在研究一种局域网技术。它的特点是信息可以像广播一样传到网络中的所有节点。梅特卡夫灵机一动：这不就像当年物理学家设想的“以太”吗？虽然在物理世界里它是虚构的，但在计算机世界里，我真的做出了这样一个“传送信息的介质”！于是，他将这种技术命名为 <strong>Ethernet（以太网）</strong>。他把数据比作在 “无形的介质” 中流动，就像 “以太” 曾被认为是光传播的介质一样，虽然现实中不需要以太，但网络中的设备通过电缆（或无线）互相连接，数据在其中自由传输，如同 “以太” 无处不在。所以以太网命名是为了比喻数据在网络中如同在 “无形介质” 中传输，是对其传输特性的一种形象类比，也是对早期科学概念的一种借鉴与致敬，既借用了物理学的浪漫，也暗示了网络的广播特性。这个名字从此流传下来，成为计算机世界最重要的基础技术之一。</p><h3 id="2-局域网（LAN）通信原理"><a href="#2-局域网（LAN）通信原理" class="headerlink" title="2. 局域网（LAN）通信原理"></a>2. 局域网（LAN）通信原理</h3><ul><li><strong>局域网（LAN）：</strong> 类比 “教室”，是多台设备（主机）共享的通信空间。</li><li><strong>主机（电脑、打印机等）：</strong> 类比 “每位同学”，是局域网内的通信主体。</li><li><strong>MAC 地址：</strong> 类比 “同学的名字 &#x2F; 学号”，是主机的全球唯一硬件标识（由网卡出厂时固化，48 比特长度）。其核心作用是在局域网内区分不同主机，确保唯一性（但实际上只需保证在同一局域网内唯一即可））。</li></ul><p>局域网内数据传递需经过 “<strong>封装 - 广播 - 筛选 - 处理</strong>” 四步，具体如下：</p><ul><li><strong>数据帧封装：</strong> 发送主机将数据打包为 “数据帧”，帧中包含 <strong>源 MAC 地址</strong>（发送方身份）和 <strong>目标 MAC 地址</strong>（接收方身份），类似信件上的 “寄件人” 和 “收件人” 信息。</li><li><strong>广播传递：</strong> 数据帧通过物理介质（网线、无线信号）发送到局域网后，会被 <strong>同一碰撞域内的所有主机网卡接收</strong>（类似老师在教室说话，所有同学都能听到）。</li><li><strong>地址筛选：</strong> 每台主机在数据链路层（驱动层）解析数据帧，对比帧中的 “目标 MAC 地址” 与自身 MAC 地址：<ul><li>若地址匹配（如 “被老师叫到名字的同学做出回应”），则保留数据并向上层交付处理；</li><li>若地址不匹配（如 “未被叫到的同学选择忽略”），则直接丢弃数据帧，不占用上层资源。</li></ul></li></ul><h3 id="3-小结"><a href="#3-小结" class="headerlink" title="3. 小结"></a>3. 小结</h3><p><strong>同一局域网内的主机通过数据帧中的 MAC 地址实现通信。数据帧包含源 MAC 地址（发送主机标识）和目标 MAC 地址（接收主机标识），发送后会被局域网内所有主机的网卡接收。但在正常模式下，只有目标 MAC 地址与自身匹配的主机会解析并处理该数据帧，从而拿到数据本身；其他主机检测到目标 MAC 地址不匹配后，会直接丢弃数据帧，不做进一步处理。</strong></p><p>而 “网卡混杂模式” 是一种特殊工作状态，开启后网卡会接收局域网内所有数据帧，无论其目标 MAC 地址是否为自身，这使得其他主机的通信数据可被抓取（即 “数据裸奔”）。但正常情况下，网卡默认仅处理目标为自身的帧，混杂模式需手动开启，常被用于网络调试或潜在安全风险场景。局域网的广播特性导致数据在信道中 “半公开传递”，存在被窃取的风险，尽管底层数据可被捕获，对 <strong>应用层加密</strong> 仍能保障数据安全：</p><ul><li>以太网底层协议（数据链路层、网络层）逻辑公开（如 Linux 内核开源），但应用层可通过加密算法（如 HTTPS）对数据加密；</li><li>即使数据被抓取，未掌握密钥的攻击者也无法解读内容（类似对话时用暗号交流，偷听者无法理解）。</li></ul><blockquote><p>大部分的抓包软件的原理其实就是使用了网卡的混杂模式，对于局域网内传递的信息不做比对丢弃，而是全部拿到手。</p></blockquote><h2 id="8-数据碰撞问题：多设备共享信道的-“冲突与协调”"><a href="#8-数据碰撞问题：多设备共享信道的-“冲突与协调”" class="headerlink" title="8. 数据碰撞问题：多设备共享信道的 “冲突与协调”"></a>8. 数据碰撞问题：多设备共享信道的 “冲突与协调”</h2><p>局域网本质是 “多主机共享物理信道” 的网络，多设备同时发送数据会导致信号干扰，即 “数据碰撞”，类似教室中多人同时说话导致的混乱。</p><h3 id="1-碰撞原因与表现"><a href="#1-碰撞原因与表现" class="headerlink" title="1. 碰撞原因与表现"></a>1. 碰撞原因与表现</h3><ul><li><strong>原因</strong>：多台主机同时向信道发送数据时，光电信号在物理介质中叠加干扰，导致数据帧损坏失效（类似多人说话声音混杂，无法分辨内容）。</li><li><strong>表现</strong>：数据传输失败、网络卡顿（如宿舍多人同时上网时网速变慢）；极端情况下，恶意发送大量垃圾数据可直接瘫痪局域网（“杀敌一千自损八百” 的攻击逻辑）。</li></ul><h3 id="2-碰撞避免机制"><a href="#2-碰撞避免机制" class="headerlink" title="2. 碰撞避免机制"></a>2. 碰撞避免机制</h3><p>为解决碰撞，以太网通过 “随机延迟重发算法” 协调主机发送时机：</p><ul><li>主机发送数据前检测信道是否空闲，空闲则发送；</li><li>若检测到碰撞（发送方会收到自身信号与干扰信号的叠加），立即停止发送，并 <strong>随机等待一段时间后重试</strong>；</li><li>随机延迟通过算法生成，大幅降低多主机再次碰撞的概率（类似说话冲突后，大家随机等待一会儿再开口，减少重复抢话）。</li></ul><h3 id="3-碰撞域划分：交换机的-“分区优化”"><a href="#3-碰撞域划分：交换机的-“分区优化”" class="headerlink" title="3. 碰撞域划分：交换机的 “分区优化”"></a>3. 碰撞域划分：交换机的 “分区优化”</h3><p>局域网内主机越多，同时发送数据的概率越高，碰撞风险越大。为缓解这一问题，便可引入 <strong>交换机</strong> 设备：</p><ul><li><strong>核心作用</strong>：通过记录 “端口与 MAC 地址对应关系”，将局域网划分为多个 <strong>碰撞域</strong>（类似将大教室拆分为多个小教室）。</li><li><strong>优化逻辑</strong>：当主机 A 向主机 B 发送数据时，交换机仅将数据转发到主机 B 所在的端口，而非广播到整个网络，减少无效数据传播，降低碰撞概率。</li><li><strong>注意</strong>：交换机划分碰撞域后，局域网仍是统一网络，主机间仍可正常通信（如小教室间同学仍能通过老师传递消息）。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250808214531993.png" alt="PixPin_2025-08-08_21-45-18"></p><h3 id="4-本质总结：临界资源的-“有序访问”"><a href="#4-本质总结：临界资源的-“有序访问”" class="headerlink" title="4. 本质总结：临界资源的 “有序访问”"></a>4. 本质总结：临界资源的 “有序访问”</h3><p>局域网通信的本质是 <strong>多进程对共享临界资源（通信信道）的有序访问</strong>：</p><ul><li>局域网作为 “临界资源”，需通过碰撞检测、延迟重发等机制保证 “互斥访问”，避免数据冲突；</li><li>每台主机的通信行为由进程驱动（如淘宝客户端、迅雷下载），网络问题本质是进程对共享资源的协调问题 ——“系统与网络不分家”。</li></ul><p>通过 MAC 地址实现定向传递、通过算法与交换机减少碰撞、通过应用层加密保障安全，局域网通信机制最终实现了 “共享信道上的高效、准确、相对安全的数据交互”，是构建复杂网络的基础。</p><hr><h2 id="9-网络中的地址管理"><a href="#9-网络中的地址管理" class="headerlink" title="9. 网络中的地址管理"></a>9. 网络中的地址管理</h2><h3 id="1-IP-与-MAC-的关系与区别"><a href="#1-IP-与-MAC-的关系与区别" class="headerlink" title="1. IP 与 MAC 的关系与区别"></a>1. IP 与 MAC 的关系与区别</h3><table><thead><tr><th>对比</th><th>IP 地址</th><th>MAC 地址</th></tr></thead><tbody><tr><td>所属层</td><td>网络层（IP 协议）</td><td>数据链路层（以太网协议）</td></tr><tr><td>长度</td><td>IPv4：32 位（4 字节），总数约 43 亿个，目前面临地址枯竭问题。<br>IPv6：128 位（16 字节），极大地扩展了地址空间，解决 IPv4 不足问题。</td><td>48 位（6 字节）</td></tr><tr><td>表示形式</td><td>IPv4 常见为 <strong>点分十进制</strong>（192.168.0.1）<br>IPv6 为冒号分隔的 16 进制（fe80:: 1）</td><td>冒号或连字符分隔的 16 进制（08:00:27:03:fb: 19）</td></tr><tr><td>谁分配的</td><td>网络管理员或 DHCP 服务器分配</td><td>硬件地址，生产网卡时由厂商烧录（全球唯一，虚拟机中的 mac 地址不是真实的 mac 地址，可能会冲突）</td></tr><tr><td>是否可变</td><td>可变（临时或永久）</td><td>大多数情况不变，但部分网卡可手动修改</td></tr><tr><td>作用</td><td>标识网络中的“位置”</td><td>标识物理设备的“身份”</td></tr><tr><td>类比</td><td>家庭地址（你在哪个城市哪条街）</td><td>身份证号（唯一标识这个人）</td></tr></tbody></table><blockquote><p>  <strong>关键</strong>：</p><ul><li><strong>MAC 地址</strong> 是物理设备唯一 ID，不随位置变化而变。</li><li><strong>IP 地址</strong> 是你在网络中的位置标识，可能会变（比如换网络、重启路由器）。</li><li>在通信中，IP 决定找谁，MAC 决定送给谁。</li></ul></blockquote><h3 id="2-ifconfig"><a href="#2-ifconfig" class="headerlink" title="2. ifconfig"></a>2. ifconfig</h3><p>Linux 下可以使用 ifconfig 命令用于查看、配置和管理网络接口（Windows 用 ipconfig），几个关键的含义如下：</p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250813132749254.png" alt="PixPin_2025-08-13_13-27-21"></p><blockquote><p>回环接口其实就是一张 <strong>虚拟的网卡</strong>，它只存在于操作系统内部，不连接任何物理网络设备。</p></blockquote><hr><h3 id="3-FTP-客户端与服务器之间的通信过程"><a href="#3-FTP-客户端与服务器之间的通信过程" class="headerlink" title="3. FTP 客户端与服务器之间的通信过程"></a>3. FTP 客户端与服务器之间的通信过程</h3><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250813134505911.png" alt="PixPin_2025-08-13_13-44-56"></p><p>当你从一台电脑（FTP 客户端）通过网络传文件到另一台电脑（FTP 服务器）时，数据要经过多个“层次”和不同类型的网络（比如以太网和令牌环网）。IP 协议就像“导航系统”，负责给数据包写上源地址和目标地址，决定它该往哪走；路由器就像是“交通警察”，根据 IP 地址把数据包从一个网络（比如以太网）转发到另一个网络（比如令牌环网）。而以太网驱动和令牌环驱动，就像是两种不同的“交通工具”——一个适用于以太网，一个适用于令牌环网，它们负责把 IP 数据包“打包”成对应网络能识别的格式。令牌环网直观上就像一群人围成一圈，只有拿到“令牌”（通行令牌）的人才能说话（发数据），避免大家同时说话造成混乱，保证了通信有序、不冲突。</p><blockquote><p>IP 协议就像全球通信的“通用语言”，它给每台主机一个逻辑地址（IP 地址），而路由器作为“翻译官”和“导航员”，工作在 IP 层，根据 IP 地址将数据包从一个网络（如以太网）转发到另一个网络（如令牌环网）。无论底层是哪种物理网络，数据在传输过程中都被封装成 IP 报文。这样，IP 协议屏蔽了以太网、令牌环网等底层技术的差异，构建了一个统一的、虚拟的全球网络层，实现了“一切皆是 IP 报文”的互联互通。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>044 深入线程安全：单例、智能指针与同步原语</title>
      <link href="/posts/57900.html"/>
      <url>/posts/57900.html</url>
      
        <content type="html"><![CDATA[<h1 id="深入线程安全：单例、智能指针与同步原语"><a href="#深入线程安全：单例、智能指针与同步原语" class="headerlink" title="深入线程安全：单例、智能指针与同步原语"></a>深入线程安全：单例、智能指针与同步原语</h1><h2 id="1-线程安全的单例模式"><a href="#1-线程安全的单例模式" class="headerlink" title="1. 线程安全的单例模式"></a>1. 线程安全的单例模式</h2><h3 id="1-什么是设计模式？"><a href="#1-什么是设计模式？" class="headerlink" title="1. 什么是设计模式？"></a>1. 什么是设计模式？</h3><blockquote><p><a href="https://www.bilibili.com/video/BV1J7GtzZEH3/?share_source=copy_web&vd_source=872e5e3ccf44874c39edaf42e30ab0de">设计模式详解：单例、线程安全、反模式 | B 站</a></p></blockquote><p><strong>设计模式</strong> 是一套经过总结、优化的 <strong>代码设计经验</strong>，它解决的是软件中 <strong>可复用性、可维护性、可扩展性</strong> 问题。需要注意的是：它不是具体代码，而是解决特定问题的通用模板。</p><p>设计模式分为三类：</p><table><thead><tr><th align="center">分类</th><th>说明</th><th>举例</th></tr></thead><tbody><tr><td align="center">创建型</td><td>处理对象创建</td><td>单例、工厂、建造者</td></tr><tr><td align="center">结构型</td><td>处理类&#x2F;对象组合</td><td>适配器、装饰器、组合、代理</td></tr><tr><td align="center">行为型</td><td>处理对象交互</td><td>观察者、策略、状态机、职责链等</td></tr></tbody></table><h3 id="2-什么是单例模式"><a href="#2-什么是单例模式" class="headerlink" title="2. 什么是单例模式"></a>2. 什么是单例模式</h3><p><strong>定义：</strong> 单例模式是一种 <strong>创建型设计模式</strong>，它保证 <strong>某个类在整个程序运行过程中只有一个实例</strong>，并提供全局访问点。<strong>其核心思想是：</strong> 通过私有构造函数和静态实例控制对象创建。</p><blockquote><p>  例如：数据库连接池、配置管理类、线程池、日志管理器等，通常用单例实现。</p></blockquote><h3 id="3-单例模式的特点"><a href="#3-单例模式的特点" class="headerlink" title="3. 单例模式的特点"></a>3. 单例模式的特点</h3><ul><li><strong>唯一性</strong>：类只能有一个实例。</li><li><strong>全局访问</strong>：提供统一的访问接口，无需重复创建对象。</li><li><strong>自行实例化</strong>：单例类自己负责创建唯一实例。</li></ul><h3 id="4-饿汉-VS-懒汉（实现方式）"><a href="#4-饿汉-VS-懒汉（实现方式）" class="headerlink" title="4. 饿汉 VS 懒汉（实现方式）"></a>4. 饿汉 VS 懒汉（实现方式）</h3><ul><li>吃完饭，立刻洗碗，这种就是饿汉方式。因为下一顿吃的时候可以立刻拿着碗就能吃饭。</li><li>吃完饭，先把碗放下，然后下一顿饭用到这个碗了再洗碗，就是懒汉方式。</li></ul><p><strong>懒汉方式最核心的思想是 “延时加载”，从而能够优化服务器的启动速度。</strong></p><h4 id="1-饿汉式"><a href="#1-饿汉式" class="headerlink" title="1. 饿汉式"></a>1. 饿汉式</h4><p><strong>思路：</strong> 在程序启动时，<strong>就直接创建好唯一实例</strong>，不管后面用不用，先占好位置。</p><p><strong>特点：</strong></p><ul><li>简单，线程安全（因为实例在程序启动时就构造完毕）</li><li>缺点：如果创建成本高但很少用，会造成浪费</li></ul><p><strong>伪代码示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>() &#123;&#125;                      <span class="comment">// 构造函数私有化</span></span><br><span class="line">    <span class="type">static</span> Singleton instance;          <span class="comment">// 静态成员，程序启动就初始化</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton&amp; <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;                <span class="comment">// 直接返回静态对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Singleton Singleton::instance;          <span class="comment">// 静态成员初始化（程序启动就创建）</span></span><br></pre></td></tr></table></figure><h4 id="2-懒汉式"><a href="#2-懒汉式" class="headerlink" title="2. 懒汉式"></a>2. 懒汉式</h4><p><strong>思路：</strong> 实例在 <strong>第一次调用 getInstance() 时才创建</strong>，实现“延迟加载”。</p><p><strong>问题：</strong> 多线程下不安全，两个线程可能同时进入 <code>if (instance == nullptr)</code>，最终创建两个对象。</p><p><strong>线程不安全版本（仅演示）：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>() &#123;&#125;</span><br><span class="line">    <span class="type">static</span> Singleton* instance;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();     <span class="comment">// 线程不安全</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Singleton* Singleton::instance = <span class="literal">nullptr</span>;   <span class="comment">// 初始化为 nullptr</span></span><br></pre></td></tr></table></figure><hr><h4 id="3-懒汉式（线程安全版本，重点）"><a href="#3-懒汉式（线程安全版本，重点）" class="headerlink" title="3. 懒汉式（线程安全版本，重点）"></a>3. 懒汉式（线程安全版本，重点）</h4><p><strong>方式一：使用 <code>pthread_mutex_t</code> 加锁（适合 C++11 以下版本）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>() &#123;&#125;                              <span class="comment">// 私有构造函数，禁止外部创建对象</span></span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> Singleton* instance;                 <span class="comment">// 静态成员指针，用于保存唯一实例</span></span><br><span class="line">    <span class="type">static</span> <span class="type">pthread_mutex_t</span> lock;                <span class="comment">// 互斥锁，保证线程安全</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 获取单例实例的静态方法</span></span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 第一次判断，避免每次都加锁（提高性能）</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">pthread_mutex_lock</span>(&amp;lock);          <span class="comment">// 加锁，防止多个线程同时进入创建逻辑</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 第二次判断，防止多线程创建多个实例</span></span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();     <span class="comment">// 只在第一次真正创建对象</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">pthread_mutex_unlock</span>(&amp;lock);        <span class="comment">// 解锁</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;                        <span class="comment">// 返回唯一实例指针</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态成员初始化</span></span><br><span class="line">Singleton* Singleton::instance = <span class="literal">nullptr</span>;       <span class="comment">// 初始为空指针</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> Singleton::lock = PTHREAD_MUTEX_INITIALIZER;  <span class="comment">// 初始化互斥锁</span></span><br></pre></td></tr></table></figure><p><strong>方式二：C++11 之后的写法（推荐），使用局部静态变量（C++11 起线程安全）：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton&amp; <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">static</span> Singleton instance;   <span class="comment">// C++11 之后线程安全</span></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>  推荐写法：这种方式最简单、性能好、安全，不需要手动加锁，是现代 C++ 推荐写法。</p></blockquote><hr><h3 id="5-小结"><a href="#5-小结" class="headerlink" title="5. 小结"></a>5. 小结</h3><table><thead><tr><th>实现方式</th><th>是否线程安全</th><th>是否延迟加载</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>饿汉式</td><td>✅ 是</td><td>❌ 否</td><td>简单，天然线程安全</td><td>占内存，不灵活</td></tr><tr><td>懒汉式（非线程安全）</td><td>❌ 否</td><td>✅ 是</td><td>按需创建，节省资源</td><td>多线程不安全</td></tr><tr><td>懒汉式 + 加锁</td><td>✅ 是</td><td>✅ 是</td><td>安全 + 延迟加载</td><td>加锁有开销</td></tr><tr><td>C++11 局部静态法</td><td>✅ 是</td><td>✅ 是</td><td>安全、性能好</td><td>编译器需支持 C++11 及以上</td></tr></tbody></table><hr><h2 id="2-STL-容器、智能指针与线程安全"><a href="#2-STL-容器、智能指针与线程安全" class="headerlink" title="2. STL 容器、智能指针与线程安全"></a>2. STL 容器、智能指针与线程安全</h2><h3 id="1-STL-容器是否是线程安全的？"><a href="#1-STL-容器是否是线程安全的？" class="headerlink" title="1. STL 容器是否是线程安全的？"></a>1. STL 容器是否是线程安全的？</h3><p><strong>结论：不是。</strong></p><ul><li><strong>原因</strong>：<ul><li>STL 的设计目标是追求 <strong>高性能</strong>，而加锁保证线程安全会显著降低性能。</li><li>不同容器的加锁方式不同，可能导致性能差异（例如 <code>hash</code> 表的锁表和锁桶）。</li></ul></li><li><strong>解决方案</strong>：<ul><li>如果需要在多线程环境中使用 STL 容器，我们调用者需要自行保证线程安全（如手动加锁）。</li></ul></li></ul><h3 id="2-智能指针是否是线程安全的？"><a href="#2-智能指针是否是线程安全的？" class="headerlink" title="2. 智能指针是否是线程安全的？"></a>2. 智能指针是否是线程安全的？</h3><ol><li><strong>unique_ptr</strong>：</li></ol><ul><li><strong>特点</strong>：<code>unique_ptr</code> 是独占所有权的智能指针，仅在当前代码块范围内生效。</li><li><strong>线程安全性</strong>：由于其独占性，<strong>不涉及线程安全问题。</strong></li></ul><ol start="2"><li><strong>shared_ptr</strong>：</li></ol><ul><li><strong>特点</strong>：<code>shared_ptr</code> 支持多个对象共享同一资源，通过引用计数管理。</li><li><strong>线程安全性</strong>：<ul><li><strong>存在线程安全问题</strong>，因为多个对象可能同时操作引用计数。</li><li>C++ 标准库实现时考虑了这个问题，使用 <strong>原子操作</strong> 来高效地管理引用计数，确保线程安全。</li></ul></li></ul><hr><h2 id="3-其他常见的锁"><a href="#3-其他常见的锁" class="headerlink" title="3. 其他常见的锁"></a>3. 其他常见的锁</h2><h3 id="1-悲观锁-——-“凡事往坏处想”"><a href="#1-悲观锁-——-“凡事往坏处想”" class="headerlink" title="1. 悲观锁 —— “凡事往坏处想”"></a>1. 悲观锁 —— “凡事往坏处想”</h3><ul><li><strong>想法</strong>：总觉得别人会抢我东西，先锁住再说。</li><li><strong>做法</strong>：操作数据前，先加锁（比如互斥锁 <code>mutex</code>），别人想动？等我用完！</li><li><strong>现实比喻</strong>：去图书馆占座，一坐下就放书包：“别动，我占了！”</li><li><strong>适用</strong>：写操作多、冲突频繁的场景（如银行转账）。</li></ul><h3 id="2-乐观锁-——-“我相信世界很和平”"><a href="#2-乐观锁-——-“我相信世界很和平”" class="headerlink" title="2. 乐观锁 —— “我相信世界很和平”"></a>2. 乐观锁 —— “我相信世界很和平”</h3><ul><li><strong>想法</strong>：大家不会乱改我的数据，我不锁，直接干。</li><li><strong>关键</strong>：更新数据前，得 “检查” 下数据有没有被改动过（毕竟乐观只是假设，得验证 ）。常用两种办法：<ul><li><strong>版本号</strong>：数据带个“版本”，你改一次+1。我更新时发现版本对得上才提交，否则重来。</li><li><strong>CAS</strong>：见下文。</li></ul></li><li><strong>现实比喻</strong>：编辑一个在线文档，提交时系统提示：“别人改过了，请刷新再试。”</li><li><strong>适用</strong>：读多写少（如商品库存查询）。</li></ul><h3 id="3-CAS（Compare-and-Swap）——-无锁的“原子校验”"><a href="#3-CAS（Compare-and-Swap）——-无锁的“原子校验”" class="headerlink" title="3. CAS（Compare-and-Swap）—— 无锁的“原子校验”"></a>3. CAS（Compare-and-Swap）—— 无锁的“原子校验”</h3><ul><li><p><strong>本质</strong>：更新数据时，保证 “数据没被改” 才更新，是个 <strong>原子操作</strong>（简单说，操作过程不会被其他线程打断 ）。</p></li><li><p><strong>流程</strong>：假设要更新变量 <code>value</code>，线程先记下旧值 <code>oldValue</code>，计算出新值 <code>newValue</code>。真正更新时，对比当前内存里 <code>value</code> 和 <code>oldValue</code>：</p><ul><li>相等，说明没被改，用 <code>newValue</code> 替换 <code>value</code>，成功。</li><li>不相等，说明被其他线程改过，更新失败，一般会重新尝试（自旋 ），直到成功或者达到重试次数。</li></ul></li><li><p><strong>问题</strong>：可能“ABA 问题”（值变回 A，看似没变，其实动过），可用带版本号的 <code>AtomicStampedReference</code> 解决。</p></li><li><p><strong>应用</strong>：<code>shared_ptr</code> 引用计数、无锁队列。</p></li></ul><h3 id="4-自旋锁（重点详解）——-“我不睡，我就等！”"><a href="#4-自旋锁（重点详解）——-“我不睡，我就等！”" class="headerlink" title="4. 自旋锁（重点详解）—— “我不睡，我就等！”"></a>4. 自旋锁（重点详解）—— “我不睡，我就等！”</h3><blockquote><p><strong>一句话：自旋锁的效率和适用性取决于其他线程执行临界区的时长。拿不到锁，我不挂起，我循环检查——“转圈圈”。</strong></p></blockquote><p><strong>工作方式：</strong> 线程尝试获取锁，如果锁被别人占着，它 <strong>不进入睡眠状态</strong>，而是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (锁 != 空闲)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 空循环，持续检查锁是否释放</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一旦锁释放，立刻抢到手，继续执行。</p><p><strong>生活例子：</strong> 你去银行办事，窗口写着“请等待叫号”。但你不想听广播，于是你：站在窗口前盯着工作人员，一直问：“好了没？好了没？”虽然烦人，但如果对方 <strong>3 秒就办完</strong>，你省了“坐下 → 等待 → 被叫 → 起身”的时间。这就是 <strong>自旋锁的思想</strong>：<strong>牺牲一点 CPU，换响应速度</strong>。</p><ol><li><p>优点：</p><ul><li><p><strong>无上下文切换开销</strong>：线程不挂起、不唤醒，避免操作系统调度开销。</p></li><li><p><strong>适合锁持有时间极短的场景</strong>：比如保护一个计数器的加减。</p></li></ul></li><li><p>缺点：</p><ul><li><p><strong>浪费 CPU</strong>：如果锁被长时间占用，线程白白“空转”，消耗 CPU 资源。</p></li><li><p><strong>可能引发性能下降</strong>：多核还好，单核上自旋线程会一直占着 CPU，其他线程无法运行。</p></li></ul></li></ol><p><strong>适用场景：</strong></p><ul><li>锁的持有时间 <strong>非常短</strong>（微秒级）。</li><li>多核 CPU 环境（一个核自旋，其他核可以释放锁）。</li><li>高频、轻量级的同步操作（如原子变量、内核级同步）。</li></ul><hr><h3 id="5-公平锁-vs-非公平锁"><a href="#5-公平锁-vs-非公平锁" class="headerlink" title="5. 公平锁 vs 非公平锁"></a>5. 公平锁 vs 非公平锁</h3><table><thead><tr><th>类型</th><th>规则</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td><strong>公平锁</strong></td><td>先到先得，排队领号</td><td>不会饿死，公平</td><td>效率低，频繁切换线程</td></tr><tr><td><strong>非公平锁</strong></td><td>不排队，谁抢到算谁的</td><td>效率高，减少等待</td><td>可能有线程一直抢不到（饿死）</td></tr></tbody></table><ul><li>公平锁：医院挂号，叫号制。</li><li>非公平锁：菜市场抢特价菜，谁手快谁拿。</li></ul><hr><h2 id="4-读者写者问题（了解）"><a href="#4-读者写者问题（了解）" class="headerlink" title="4. 读者写者问题（了解）"></a>4. 读者写者问题（了解）</h2><p>在编写多线程的时候，有一种情况是十分常见的。那就是，有些公共数据修改的机会比较少。相比较改写，它们读的机会反而高的多。通常而言，在读的过程中，往往伴随着查找的操作，中间耗时很长。给这种代码段加锁，会极大地降低我们程序的效率。那么有没有一种方法，可以专门处理这种 <strong>多读少写</strong> 的情况呢？有，那就是 <strong>读写锁</strong>。它具备以下特性：</p><ul><li><strong>多个读操作可以同时进行（并发）</strong>，互不干扰。</li><li><strong>写操作必须独占资源</strong>，不能同时有读或写操作。</li><li><strong>读写互斥</strong>，读时不允许写，写时也不允许读。</li></ul><p>相比普通互斥锁，读写锁可以在 <strong>多线程读操作场景下显著提升并发性能</strong>，非常适用于“读多写少”的情况。</p><h3 id="2-函数调用"><a href="#2-函数调用" class="headerlink" title="2. 函数调用"></a>2. 函数调用</h3><p>同样的，这部分函数和之前的非常相似，类比使用即可。</p><table><thead><tr><th>接口</th><th>作用</th><th>使用场景</th><th>返回值</th></tr></thead><tbody><tr><td><code>pthread_rwlock_t</code></td><td>定义读写锁变量</td><td>全局或局部声明读写锁</td><td>类型定义，无返回值</td></tr><tr><td><code>pthread_rwlock_init(&amp;rwlock, &amp;attr)</code></td><td>动态初始化读写锁（可指定属性）</td><td>初始化锁时，可通过 attr 设置共享属性等</td><td>成功返回 0；失败返回错误码</td></tr><tr><td><code>pthread_rwlock_rdlock(&amp;rwlock)</code></td><td>获取 <strong>读锁</strong>（读者加锁）</td><td>线程需要读取共享资源时调用</td><td>成功返回 0；失败返回错误码</td></tr><tr><td><code>pthread_rwlock_wrlock(&amp;rwlock)</code></td><td>获取 <strong>写锁</strong>（写者加锁）</td><td>线程需要修改共享资源时调用</td><td>成功返回 0；失败返回错误码</td></tr><tr><td><code>pthread_rwlock_unlock(&amp;rwlock)</code></td><td>释放锁（读锁 &#x2F; 写锁通用）</td><td>线程完成读写操作后，释放锁供其他线程使用</td><td>成功返回 0；失败返回错误码</td></tr><tr><td><code>pthread_rwlock_destroy(&amp;rwlock)</code></td><td>销毁读写锁，释放资源</td><td>不再使用锁时调用，避免资源泄漏</td><td>成功返回 0；失败返回错误码</td></tr></tbody></table><h3 id="2-读写锁的两种策略对比：读者优先-vs-写者优先"><a href="#2-读写锁的两种策略对比：读者优先-vs-写者优先" class="headerlink" title="2. 读写锁的两种策略对比：读者优先 vs 写者优先"></a>2. 读写锁的两种策略对比：读者优先 vs 写者优先</h3><table><thead><tr><th>项目</th><th>读者优先</th><th>写者优先</th></tr></thead><tbody><tr><td>核心目标</td><td>让读操作尽可能并发、不被阻塞</td><td>避免写操作长期等待（防止写饥饿）</td></tr><tr><td>锁的策略</td><td>第一个读者锁住写锁，后续读者并发</td><td>新写者到来时，阻止新读者进入</td></tr><tr><td>读者行为</td><td>多个读者可并发访问，互不阻塞</td><td>如果已有写者等锁，新读者需等待</td></tr><tr><td>写者行为</td><td>写者需等所有读者读完才能进入</td><td>一旦有写者等锁，写者优先处理</td></tr><tr><td>潜在问题</td><td>写者可能“饿死”，一直等不到机会</td><td>读者可能“饿死”，持续被写者打断</td></tr><tr><td>实现难点</td><td>控制第一个读者加锁 &#x2F; 最后一个解锁</td><td>控制写等待状态，禁止新读者抢占锁</td></tr><tr><td>常见适用场景</td><td>读操作频繁、实时性要求低的写操作</td><td>写操作频繁、写实时性要求较高</td></tr></tbody></table><p>总的来说就是：</p><ul><li><strong>读者优先</strong>：有读我就先读，写操作慢慢等。</li><li><strong>写者优先</strong>：只要有写要来，先暂停读，等我写完再说。</li></ul><p><strong>读者优先的伪代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> reader_count = <span class="number">0</span>;</span><br><span class="line"><span class="type">mutex_t</span> r_lock, w_lock;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读者加锁</span></span><br><span class="line"><span class="built_in">lock</span>(r_lock);</span><br><span class="line">reader_count++;</span><br><span class="line"><span class="keyword">if</span> (reader_count == <span class="number">1</span>) <span class="built_in">lock</span>(w_lock);  <span class="comment">// 首个读者阻写</span></span><br><span class="line"><span class="built_in">unlock</span>(r_lock);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读者解锁</span></span><br><span class="line"><span class="built_in">lock</span>(r_lock);</span><br><span class="line">reader_count--;</span><br><span class="line"><span class="keyword">if</span> (reader_count == <span class="number">0</span>) <span class="built_in">unlock</span>(w_lock); <span class="comment">// 最后读者放写</span></span><br><span class="line"><span class="built_in">unlock</span>(r_lock);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写者加锁/解锁</span></span><br><span class="line"><span class="built_in">lock</span>(w_lock);  <span class="comment">// 被读者阻塞</span></span><br><span class="line"><span class="comment">// 写操作</span></span><br><span class="line"><span class="built_in">unlock</span>(w_lock);</span><br></pre></td></tr></table></figure><p>写者优先的伪代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> reader_count = <span class="number">0</span>, writer_wait = <span class="number">0</span>;</span><br><span class="line"><span class="type">mutex_t</span> r_lock, w_lock, q_lock;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读者加锁</span></span><br><span class="line"><span class="built_in">lock</span>(q_lock);  <span class="comment">// 检查写者等待</span></span><br><span class="line"><span class="built_in">lock</span>(r_lock);</span><br><span class="line">reader_count++;</span><br><span class="line"><span class="keyword">if</span> (reader_count == <span class="number">1</span>) <span class="built_in">lock</span>(w_lock);</span><br><span class="line"><span class="built_in">unlock</span>(r_lock);</span><br><span class="line"><span class="built_in">unlock</span>(q_lock);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读者解锁（同读者优先）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 写者加锁</span></span><br><span class="line"><span class="built_in">lock</span>(q_lock);  <span class="comment">// 阻止新读者</span></span><br><span class="line">writer_wait++;</span><br><span class="line"><span class="built_in">lock</span>(w_lock);  <span class="comment">// 等当前读者</span></span><br><span class="line">writer_wait--;</span><br><span class="line"><span class="built_in">unlock</span>(q_lock);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写者解锁</span></span><br><span class="line"><span class="built_in">unlock</span>(w_lock);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>043 线程池与线程封装</title>
      <link href="/posts/64232.html"/>
      <url>/posts/64232.html</url>
      
        <content type="html"><![CDATA[<h1 id="线程池与线程封装"><a href="#线程池与线程封装" class="headerlink" title="线程池与线程封装"></a>线程池与线程封装</h1><h2 id="1-线程池"><a href="#1-线程池" class="headerlink" title="1. 线程池"></a>1. 线程池</h2><h3 id="1-ThreadPool-hpp"><a href="#1-ThreadPool-hpp" class="headerlink" title="1. ThreadPool.hpp"></a>1. ThreadPool.hpp</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程信息结构体：保存每个线程的基本信息</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ThreadInfo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid;                                                   <span class="comment">// 线程ID</span></span><br><span class="line">    string name;                                                     <span class="comment">// 线程名称</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> default_num = <span class="number">5</span>;                                    <span class="comment">// 默认线程数量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPool</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 加锁操作：保护共享资源不被多个线程同时访问</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Lock</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mutex_);                                 <span class="comment">// 获取互斥锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 解锁操作：释放互斥锁，让其他线程可以访问共享资源</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Unlock</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex_);                               <span class="comment">// 释放互斥锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 唤醒一个等待的线程：当有新任务时唤醒空闲的线程</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Wakeup</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">pthread_cond_signal</span>(&amp;cond_);                                 <span class="comment">// 唤醒一个等待的线程</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 线程睡眠等待：让线程进入等待状态，节省CPU资源</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ThreadSleep</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">pthread_cond_wait</span>(&amp;cond_, &amp;mutex_);                          <span class="comment">// 等待条件变量，会自动释放锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断任务队列是否为空</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">IsQueueEmpty</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tasks_.<span class="built_in">empty</span>();                                       <span class="comment">// 返回任务队列是否为空</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据线程ID获取线程名称：用于日志输出，知道是哪个线程在工作</span></span><br><span class="line">    <span class="function">string <span class="title">GetThreadName</span><span class="params">(<span class="type">pthread_t</span> tid)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;ti : threads_)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (ti.tid == tid)</span><br><span class="line">                <span class="keyword">return</span> ti.name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Unknown&quot;</span>;                                            <span class="comment">// 找不到返回未知</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 线程执行函数：每个工作线程都会执行这个函数</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> *<span class="title">HandlerTask</span><span class="params">(<span class="type">void</span> *args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ThreadPool&lt;T&gt; *tp = <span class="keyword">static_cast</span>&lt;ThreadPool&lt;T&gt; *&gt;(args);      <span class="comment">// 获取线程池对象指针</span></span><br><span class="line">        string name = tp-&gt;<span class="built_in">GetThreadName</span>(<span class="built_in">pthread_self</span>());             <span class="comment">// 获取当前线程的名字</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)                                                 <span class="comment">// 线程一直运行，不会退出</span></span><br><span class="line">        &#123;</span><br><span class="line">            tp-&gt;<span class="built_in">Lock</span>();                                              <span class="comment">// 加锁保护任务队列</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 等待任务：如果任务队列为空，线程就睡觉等待</span></span><br><span class="line">            <span class="keyword">while</span> (tp-&gt;<span class="built_in">IsQueueEmpty</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; name &lt;&lt; <span class="string">&quot; 等待任务...&quot;</span> &lt;&lt; endl;</span><br><span class="line">                tp-&gt;<span class="built_in">ThreadSleep</span>();                                   <span class="comment">// 睡觉等待新任务</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            T t = tp-&gt;<span class="built_in">Pop</span>();                                         <span class="comment">// 从队列取出一个任务</span></span><br><span class="line">            tp-&gt;<span class="built_in">Unlock</span>();                                            <span class="comment">// 解锁，让其他线程可以访问队列</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">t</span>();                                                     <span class="comment">// 执行任务（调用任务的operator()）</span></span><br><span class="line">            cout &lt;&lt; name &lt;&lt; <span class="string">&quot; 运行任务，结果是：&quot;</span> &lt;&lt; t.<span class="built_in">get_result</span>() &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 启动线程池：创建所有的工作线程</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Start</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> num = threads_.<span class="built_in">size</span>();                                   <span class="comment">// 获取要创建的线程数量</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;启动 &quot;</span> &lt;&lt; num &lt;&lt; <span class="string">&quot; 个线程...&quot;</span> &lt;&lt; endl;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            threads_[i].name = <span class="string">&quot;[线程 &quot;</span> + <span class="built_in">to_string</span>(i + <span class="number">1</span>) + <span class="string">&quot;]&quot;</span>;    <span class="comment">// 给每个线程起名字</span></span><br><span class="line">            <span class="comment">// 创建线程：&amp;threads_[i].tid保存线程ID，HandlerTask是线程要执行的函数，this是传给函数的参数</span></span><br><span class="line">            <span class="built_in">pthread_create</span>(&amp;(threads_[i].tid), <span class="literal">nullptr</span>, HandlerTask, <span class="keyword">this</span>);</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;创建线程 &quot;</span> &lt;&lt; threads_[i].name &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从任务队列取出任务</span></span><br><span class="line">    <span class="function">T <span class="title">Pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        T t = tasks_.<span class="built_in">front</span>();                                        <span class="comment">// 取出队列第一个任务</span></span><br><span class="line">        tasks_.<span class="built_in">pop</span>();                                                <span class="comment">// 从队列中删除这个任务</span></span><br><span class="line">        <span class="keyword">return</span> t;                                                    <span class="comment">// 返回任务</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 向任务队列添加任务：外部程序调用这个函数来提交任务</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Push</span><span class="params">(<span class="type">const</span> T &amp;t)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">Lock</span>();                                                      <span class="comment">// 加锁</span></span><br><span class="line">        tasks_.<span class="built_in">push</span>(t);                                              <span class="comment">// 把新任务加入队列</span></span><br><span class="line">        <span class="built_in">Wakeup</span>();                                                    <span class="comment">// 唤醒一个睡觉的线程来处理任务</span></span><br><span class="line">        <span class="built_in">Unlock</span>();                                                    <span class="comment">// 解锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取线程池单例实例：保证整个程序只有一个线程池对象</span></span><br><span class="line">    <span class="function"><span class="type">static</span> ThreadPool&lt;T&gt; *<span class="title">GetInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 第一次检查：如果已经创建了实例，就直接返回（不需要加锁，提高性能）</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">nullptr</span> == tp_)                                          </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">pthread_mutex_lock</span>(&amp;lock_);                              <span class="comment">// 加锁：防止多个线程同时创建实例</span></span><br><span class="line">            <span class="comment">// 第二次检查：再次确认还没有创建实例（防止在等待锁的时候其他线程已经创建了）</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="literal">nullptr</span> == tp_)                                      </span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;log：单例线程池首次创建完成！&quot;</span> &lt;&lt; endl;</span><br><span class="line">                tp_ = <span class="keyword">new</span> <span class="built_in">ThreadPool</span>&lt;T&gt;();                           <span class="comment">// 创建唯一的线程池实例</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">pthread_mutex_unlock</span>(&amp;lock_);                            <span class="comment">// 解锁</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> tp_;                                                  <span class="comment">// 返回线程池实例</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 私有构造函数：防止外部直接创建对象，只能通过GetInstance获取</span></span><br><span class="line">    <span class="built_in">ThreadPool</span>(<span class="type">int</span> num = default_num) : <span class="built_in">threads_</span>(num)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_init</span>(&amp;mutex_, <span class="literal">nullptr</span>);                        <span class="comment">// 初始化互斥锁</span></span><br><span class="line">        <span class="built_in">pthread_cond_init</span>(&amp;cond_, <span class="literal">nullptr</span>);                          <span class="comment">// 初始化条件变量</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 私有析构函数：防止外部随意销毁线程池</span></span><br><span class="line">    ~<span class="built_in">ThreadPool</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_destroy</span>(&amp;mutex_);                              <span class="comment">// 销毁互斥锁</span></span><br><span class="line">        <span class="built_in">pthread_cond_destroy</span>(&amp;cond_);                                <span class="comment">// 销毁条件变量</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 禁用拷贝构造函数：防止线程池对象被复制（因为线程不能被复制）</span></span><br><span class="line">    <span class="comment">// ThreadPool tp1; ThreadPool tp2 = tp1; // 这样就不允许</span></span><br><span class="line">    <span class="built_in">ThreadPool</span>(<span class="type">const</span> ThreadPool&lt;T&gt; &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 禁用赋值操作符：防止线程池对象被赋值（因为线程不能被赋值）</span></span><br><span class="line">    <span class="comment">// ThreadPool tp1, tp2; tp2 = tp1; // 这样就不允许</span></span><br><span class="line">    <span class="type">const</span> ThreadPool&lt;T&gt; &amp;<span class="keyword">operator</span>=(<span class="type">const</span> ThreadPool&lt;T&gt; &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;ThreadInfo&gt; threads_;                                     <span class="comment">// 保存所有工作线程的信息</span></span><br><span class="line">    queue&lt;T&gt; tasks_;                                                 <span class="comment">// 任务队列：存放等待执行的任务</span></span><br><span class="line"></span><br><span class="line">    <span class="type">pthread_mutex_t</span> mutex_;                                          <span class="comment">// 互斥锁：保护任务队列不被多个线程同时修改</span></span><br><span class="line">    <span class="type">pthread_cond_t</span> cond_;                                            <span class="comment">// 条件变量：用于线程间的等待和唤醒</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 单例指针：指向唯一的线程池实例</span></span><br><span class="line">    <span class="comment">// static修饰：这个变量属于类本身，不属于任何对象，所有对象共享这一个变量</span></span><br><span class="line">    <span class="type">static</span> ThreadPool&lt;T&gt; *tp_;                                       </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 单例保护锁：保护创建单例实例的过程，防止多个线程同时创建</span></span><br><span class="line">    <span class="comment">// static修饰：这个锁属于类本身，用于保护静态成员变量tp_</span></span><br><span class="line">    <span class="type">static</span> <span class="type">pthread_mutex_t</span> lock_;                                    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面是静态成员变量定义：必须在类外单独定义，这些变量在程序启动时就存在，不依赖于任何对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 开始时为空，第一次调用GetInstance时才会创建</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">ThreadPool&lt;T&gt; *ThreadPool&lt;T&gt;::tp_ = <span class="literal">nullptr</span>;                         </span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用PTHREAD_MUTEX_INITIALIZER初始化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">pthread_mutex_t</span> ThreadPool&lt;T&gt;::lock_ = PTHREAD_MUTEX_INITIALIZER;    </span><br></pre></td></tr></table></figure><h3 id="2-Task-hpp"><a href="#2-Task-hpp" class="headerlink" title="2. Task.hpp"></a>2. Task.hpp</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> string opers = <span class="string">&quot;+-*/%&quot;</span>;                                        <span class="comment">// 支持的操作符集合</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误代码枚举定义</span></span><br><span class="line"><span class="keyword">enum</span></span><br><span class="line">&#123;</span><br><span class="line">    SUCCESS = <span class="number">0</span>,                                                     <span class="comment">// 成功</span></span><br><span class="line">    DIV_ERROR = <span class="number">1</span>,                                                   <span class="comment">// 除零错误</span></span><br><span class="line">    MOD_ERROR = <span class="number">2</span>,                                                   <span class="comment">// 取模零错误</span></span><br><span class="line">    UNKNOWN_ERROR = <span class="number">3</span>                                                <span class="comment">// 未知操作符错误</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Task</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 默认构造函数</span></span><br><span class="line">    <span class="built_in">Task</span>()</span><br><span class="line">        :_x(<span class="number">0</span>), _y(<span class="number">0</span>), _op(<span class="string">&#x27;+&#x27;</span>), _ret(<span class="number">0</span>), _code(SUCCESS)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 带参数构造函数：初始化任务参数</span></span><br><span class="line">    <span class="built_in">Task</span>(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">char</span> op = <span class="string">&#x27;+&#x27;</span>)</span><br><span class="line">        :_x(x),</span><br><span class="line">        _y(y),</span><br><span class="line">        _op(op),</span><br><span class="line">        _ret(<span class="number">0</span>),</span><br><span class="line">        _code(SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 验证操作符是否合法</span></span><br><span class="line">        <span class="keyword">if</span>(op != <span class="string">&#x27;+&#x27;</span> &amp;&amp; op != <span class="string">&#x27;-&#x27;</span> &amp;&amp; op != <span class="string">&#x27;*&#x27;</span> &amp;&amp; op != <span class="string">&#x27;/&#x27;</span> &amp;&amp; op != <span class="string">&#x27;%&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            _op = <span class="string">&#x27;+&#x27;</span>;                                               <span class="comment">// 默认为加法</span></span><br><span class="line">            _code = UNKNOWN_ERROR;                                   <span class="comment">// 设置错误码</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行运算任务</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 重置结果和错误码（避免重复调用时的问题）</span></span><br><span class="line">        _ret = <span class="number">0</span>;</span><br><span class="line">        _code = SUCCESS;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">switch</span>(_op)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                _ret = _x + _y;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                _ret = _x - _y;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                _ret = _x * _y;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span>(_y == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    _code = DIV_ERROR;                               <span class="comment">// 除零错误</span></span><br><span class="line">                    _ret = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    _ret = _x / _y;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;%&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span>(_y == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    _code = MOD_ERROR;                               <span class="comment">// 取模零错误</span></span><br><span class="line">                    _ret = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    _ret = _x % _y;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                _code = UNKNOWN_ERROR;                               <span class="comment">// 未知操作符错误</span></span><br><span class="line">                _ret = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载函数调用操作符，使Task对象可以像函数一样调用</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">run</span>();                                                       <span class="comment">// 执行运算</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取任务描述字符串</span></span><br><span class="line">    <span class="function">string <span class="title">get_task</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">to_string</span>(_x) + _op + <span class="built_in">to_string</span>(_y) + <span class="string">&quot;= ???&quot;</span>;        <span class="comment">// 格式：x op y = ???</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取运算结果字符串</span></span><br><span class="line">    <span class="function">string <span class="title">get_ret</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        string ret = <span class="built_in">to_string</span>(_x) + _op + <span class="built_in">to_string</span>(_y) + <span class="string">&quot;=&quot;</span> + <span class="built_in">to_string</span>(_ret) + </span><br><span class="line">                     <span class="string">&quot; [错误代码：&quot;</span> + <span class="built_in">to_string</span>(_code) + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取操作符</span></span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">get_operator</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _op;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取第一个操作数</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_first_operand</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取第二个操作数</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_second_operand</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取运算结果</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_result</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取错误代码</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_error_code</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">Task</span>()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _x, _y;                                                      <span class="comment">// 两个操作数</span></span><br><span class="line">    <span class="type">int</span> _ret;                                                        <span class="comment">// 运算结果</span></span><br><span class="line">    <span class="type">char</span> _op;                                                        <span class="comment">// 操作符</span></span><br><span class="line">    <span class="type">int</span> _code;                                                       <span class="comment">// 错误代码</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="3-Main-cc"><a href="#3-Main-cc" class="headerlink" title="3. Main.cc"></a>3. Main.cc</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ThreadPool.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Task.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// pthread_spinlock_t slock;                                    // 全局自旋锁</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">bool</span> running = <span class="literal">true</span>;                                   <span class="comment">// 信号处理标志，用于优雅退出</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 信号处理函数：捕获Ctrl+C等退出信号</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">signalHandler</span><span class="params">(<span class="type">int</span> signum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n接收到信号 &quot;</span> &lt;&lt; signum &lt;&lt; <span class="string">&quot;，正在退出...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    running = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 注册信号处理函数，捕获Ctrl+C (SIGINT) 和终止信号 (SIGTERM)</span></span><br><span class="line">    <span class="built_in">signal</span>(SIGINT, signalHandler);</span><br><span class="line">    <span class="built_in">signal</span>(SIGTERM, signalHandler);</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;线程池启动中...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    ThreadPool&lt;Task&gt;* tp = ThreadPool&lt;Task&gt;::<span class="built_in">GetInstance</span>();      <span class="comment">// 获取线程池单例实例并启动线程池</span></span><br><span class="line">    tp-&gt;<span class="built_in">Start</span>();  <span class="comment">// 启动工作线程</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">nullptr</span>) ^ <span class="built_in">getpid</span>());                             <span class="comment">// 设置随机种子</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(running)                                               <span class="comment">// 持续生成任务</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 1. 构建随机任务</span></span><br><span class="line">        <span class="type">int</span> x = <span class="built_in">rand</span>() % <span class="number">20</span> + <span class="number">1</span>;                                 <span class="comment">// 生成[1,20]的随机数</span></span><br><span class="line">        <span class="built_in">usleep</span>(<span class="number">10</span>);                                              <span class="comment">// 微秒延迟，增加随机性</span></span><br><span class="line">        <span class="type">int</span> y = <span class="built_in">rand</span>() % <span class="number">10</span>;                                     <span class="comment">// 生成[0,9]的随机数</span></span><br><span class="line">        <span class="type">char</span> op = opers[<span class="built_in">rand</span>() % opers.<span class="built_in">size</span>()];                  <span class="comment">// 随机选择操作符</span></span><br><span class="line"></span><br><span class="line">        <span class="function">Task <span class="title">t</span><span class="params">(x, y, op)</span></span>;                                        <span class="comment">// 创建任务对象</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 将任务提交给线程池处理</span></span><br><span class="line">        tp-&gt;<span class="built_in">Push</span>(t);                                             <span class="comment">// 添加任务到线程池</span></span><br><span class="line">        </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;[主线程] 创建任务: &quot;</span> &lt;&lt; t.<span class="built_in">get_task</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);                                                <span class="comment">// 每1秒生成一个任务</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;程序正常退出&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-C-语言层面上的线程封装-demo（简易）"><a href="#2-C-语言层面上的线程封装-demo（简易）" class="headerlink" title="2. C++ 语言层面上的线程封装 demo（简易）"></a>2. C++ 语言层面上的线程封装 demo（简易）</h2><h3 id="MyThread-hpp"><a href="#MyThread-hpp" class="headerlink" title="MyThread.hpp"></a>MyThread.hpp</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="type">callback_t</span>)</span><span class="params">()</span></span>;                                        <span class="comment">// 无参数无返回值的函数指针</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> thread_num = <span class="number">0</span>;                                           <span class="comment">// 全局线程编号计数器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Thread</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="title">thread_func</span><span class="params">(<span class="type">void</span>* arg)</span>                              <span class="comment">// 线程函数</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Thread* thread = <span class="built_in">static_cast</span>&lt;Thread*&gt;(arg);                  <span class="comment">// 转换为线程指针</span></span><br><span class="line">        thread-&gt;<span class="built_in">Enter_callback</span>();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Thread</span>(<span class="type">callback_t</span> cb)</span><br><span class="line">        :<span class="built_in">tid_</span>(<span class="number">0</span>),                                                    <span class="comment">// 初始化线程ID为0</span></span><br><span class="line">        <span class="built_in">name_</span>(<span class="string">&quot;&quot;</span>),                                                   <span class="comment">// 初始化线程名称为空</span></span><br><span class="line">        <span class="built_in">start_timestamp_</span>(<span class="number">0</span>),                                         <span class="comment">// 初始化启动时间戳为0</span></span><br><span class="line">        <span class="built_in">isrunning_</span>(<span class="literal">false</span>),                                           <span class="comment">// 初始化运行状态为false</span></span><br><span class="line">        <span class="built_in">cb_</span>(cb)                                                      <span class="comment">// 保存回调函数</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Thread</span>()                                                        <span class="comment">// 析构函数</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span>                                                       <span class="comment">// 启动线程</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        name_ = <span class="string">&quot;thread-&quot;</span> + <span class="built_in">to_string</span>(thread_num++);                 <span class="comment">// 设置线程名称</span></span><br><span class="line">        start_timestamp_ = <span class="built_in">time</span>(<span class="literal">nullptr</span>);                            <span class="comment">// 记录启动时间戳</span></span><br><span class="line">        isrunning_ = <span class="literal">true</span>;                                           <span class="comment">// 设置运行状态为true</span></span><br><span class="line">        <span class="built_in">pthread_create</span>(&amp;tid_, <span class="literal">nullptr</span>, thread_func, <span class="keyword">this</span>);           <span class="comment">// 创建线程</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Enter_callback</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cb_</span>();                                                       <span class="comment">// 执行回调函数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">is_runing</span><span class="params">()</span>                                                 <span class="comment">// 判断线程是否运行</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isrunning_;                                           <span class="comment">// 返回运行状态</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">uint64_t</span> <span class="title">start_timestamp</span><span class="params">()</span>                                       <span class="comment">// 获取启动时间戳</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> start_timestamp_;                                     <span class="comment">// 返回启动时间戳</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">name</span><span class="params">()</span>                                                    <span class="comment">// 获取线程名称</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name_;                                                <span class="comment">// 返回线程名称</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">join</span><span class="params">()</span>                                                      <span class="comment">// 等待线程结束</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">pthread_join</span>(tid_, <span class="literal">nullptr</span>);                                 <span class="comment">// 等待线程结束</span></span><br><span class="line">        isrunning_ = <span class="literal">false</span>;                                          <span class="comment">// 设置运行状态为false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">pthread_t</span> tid_;                                                  <span class="comment">// 线程ID</span></span><br><span class="line">    string name_;                                                    <span class="comment">// 线程名称</span></span><br><span class="line">    <span class="type">uint64_t</span> start_timestamp_;                                       <span class="comment">// 启动时间戳</span></span><br><span class="line">    <span class="type">bool</span> isrunning_;                                                 <span class="comment">// 运行状态标志</span></span><br><span class="line"></span><br><span class="line">    <span class="type">callback_t</span> cb_;                                                  <span class="comment">// 回调函数指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="2-Main-cc"><a href="#2-Main-cc" class="headerlink" title="2. Main.cc"></a>2. Main.cc</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyThread.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> threads_num = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(count &lt; threads_num)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;我是一个 C++ 语言层面上封装的线程！&quot;</span> &lt;&lt; <span class="string">&quot;代号是：&quot;</span> &lt;&lt; count++ &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;所有线程都结束了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;Thread&gt; threads;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; threads_num; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        threads.<span class="built_in">push_back</span>(<span class="built_in">Thread</span>(print));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;开始启动所有线程喽~&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x : threads)</span><br><span class="line">    &#123;</span><br><span class="line">        x.<span class="built_in">run</span>();</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;线程 &quot;</span> &lt;&lt; x.<span class="built_in">name</span>() &lt;&lt; <span class="string">&quot; 启动成功！其时间戳的值是：&quot;</span> &lt;&lt; x.<span class="built_in">start_timestamp</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x : threads)</span><br><span class="line">    &#123;</span><br><span class="line">        x.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;所有线程都结束了！&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，这个 demo 仅实现了两个函数的封装，也没有进行加锁，会导致数据竞争，整体来说并不完美，仅为了展示如何实现底层封装。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>042 生产者 - 消费者模型</title>
      <link href="/posts/46846.html"/>
      <url>/posts/46846.html</url>
      
        <content type="html"><![CDATA[<h1 id="生产者-消费者模型（CP-问题）"><a href="#生产者-消费者模型（CP-问题）" class="headerlink" title="生产者 - 消费者模型（CP 问题）"></a>生产者 - 消费者模型（CP 问题）</h1><h2 id="1-生产者-消费者模型（CP-问题）是什么？"><a href="#1-生产者-消费者模型（CP-问题）是什么？" class="headerlink" title="1. 生产者-消费者模型（CP 问题）是什么？"></a>1. 生产者-消费者模型（CP 问题）是什么？</h2><p>这是并发编程中最经典的问题之一，主要描述 <strong>两个线程&#x2F;进程之间的数据交换协作问题</strong>：</p><ul><li><strong>生产者</strong>：不断生产数据，放入缓冲区（仓库、通道）。</li><li><strong>消费者</strong>：不断从缓冲区中取出数据进行处理。</li></ul><p>但问题在于：</p><ol><li>缓冲区有 <strong>容量限制</strong>。</li><li>多线程并发会导致 <strong>竞争访问资源</strong>。</li></ol><p>所以需要设计好 <strong>同步机制</strong>（比如互斥锁、条件变量、信号量等）保证：</p><ul><li>生产者不能在缓冲区满的时候继续放；</li><li>消费者不能在缓冲区空的时候继续取；</li><li>多个线程操作共享资源不会冲突。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250803204315930.png" alt="image-20250803204315786"></p><h2 id="2-什么是“解耦”？为什么要解耦？"><a href="#2-什么是“解耦”？为什么要解耦？" class="headerlink" title="2. 什么是“解耦”？为什么要解耦？"></a>2. 什么是“解耦”？为什么要解耦？</h2><h3 id="1-解耦的本质"><a href="#1-解耦的本质" class="headerlink" title="1. 解耦的本质"></a>1. 解耦的本质</h3><p>解耦指的是将系统中的不同组件或模块之间的依赖关系降低，使它们能够独立地进行开发、修改和维护。在生产者 - 消费者模型中，解耦就是要让生产者和消费者之间的直接关联尽可能减少，各自可以独立地运行和变化，而不会因为一方的改变对另一方造成过大的影响。简单来说 <strong>解耦就是降低模块之间的依赖性，提高系统的可扩展性和灵活性</strong>。</p><blockquote><p>  在 CP 问题中，供货商和消费者通过缓冲区（超市）进行 <strong>间接通信</strong>，实现了解耦。</p></blockquote><h3 id="2-为什么要解耦？"><a href="#2-为什么要解耦？" class="headerlink" title="2. 为什么要解耦？"></a>2. 为什么要解耦？</h3><ul><li><strong>不解耦的弊端</strong>：供货商得知道哪个消费者要什么、什么时候要，耦合性太强，代码难维护。</li><li><strong>解耦后的优势</strong>：<ul><li>可以任意增加&#x2F;减少生产者或消费者数量（线程扩展方便）。</li><li>各自只关心“缓冲区的状态”，不需要处理对方的逻辑。</li><li>模块职责清晰，便于调试、优化和扩展。</li></ul></li></ul><hr><h2 id="3-现实类比：供应链的“供货商-超市-消费者”"><a href="#3-现实类比：供应链的“供货商-超市-消费者”" class="headerlink" title="3. 现实类比：供应链的“供货商 - 超市 - 消费者”"></a>3. 现实类比：供应链的“供货商 - 超市 - 消费者”</h2><h3 id="1-现实类比"><a href="#1-现实类比" class="headerlink" title="1. 现实类比"></a>1. 现实类比</h3><table><thead><tr><th>角色</th><th>类比</th><th>现实意义</th></tr></thead><tbody><tr><td>供货商</td><td><strong>生产者</strong></td><td>批量生产商品的人</td></tr><tr><td>超市</td><td><strong>缓冲区 Buffer &#x2F; 仓库</strong></td><td>商品流通的中转站，有货架&#x2F;仓库</td></tr><tr><td>消费者</td><td><strong>消费者</strong></td><td>前来购物的顾客</td></tr></tbody></table><h3 id="2-“321-原则”-理解-CP-问题"><a href="#2-“321-原则”-理解-CP-问题" class="headerlink" title="2. “321 原则” 理解 CP 问题"></a>2. “321 原则” 理解 CP 问题</h3><hr><h4 id="1-“3-种关系”"><a href="#1-“3-种关系”" class="headerlink" title="1. “3 种关系”"></a>1. “3 种关系”</h4><ul><li><strong>生产者 vs 生产者（互斥）</strong>：不同的供货商之间存在竞争关系。例如，两家不同品牌的饮料供货商，他们都希望自己的产品能够在超市中占据更多的货架空间，获得更高的销量。为了实现这一目标，他们会在产品质量、价格、营销策略等方面展开竞争，这种竞争关系就是互斥的，因为在一定的市场份额下，一家供货商销量的增加往往意味着其他供货商销量的减少。</li><li><strong>消费者 vs 消费者（互斥）</strong>：消费者之间也存在一定的互斥关系。比如在超市进行促销活动时，某些热门商品的数量有限，消费者之间就会为了抢购这些商品而产生竞争。例如，限量版的鞋子、热门的电子产品等，先到的消费者有更大的机会购买到，而后到的消费者可能就会错失购买机会。</li><li><strong>生产者 vs 消费者（互斥、同步）：</strong><ul><li><strong>互斥</strong>：供货商希望以较高的价格出售商品以获取更多利润，而消费者则希望以较低的价格购买到心仪的商品，双方在价格方面存在利益冲突，这是互斥的表现。</li><li><strong>同步</strong>：供货商需要根据消费者的需求来生产商品，如果生产的商品不符合消费者的需求，就会造成库存积压。而消费者的购买行为也会影响供货商的生产计划，例如当某种商品的销量大增时，供货商可能会增加该商品的生产。所以生产者和消费者之间需要保持一定的同步关系，以维持市场的供需平衡。</li></ul></li></ul><blockquote><p>供货商与消费者 <strong>不需要彼此知道对方是谁</strong>，通过中间的缓冲区（超市）就能协作完成“商品流转” —— 这就是 <strong>解耦</strong>。</p></blockquote><h4 id="2-“2-种角色”"><a href="#2-“2-种角色”" class="headerlink" title="2. “2 种角色”"></a>2. “2 种角色”</h4><table><thead><tr><th>角色</th><th>行为</th></tr></thead><tbody><tr><td>生产者（供货商）</td><td>负责生成产品，放入缓冲区</td></tr><tr><td>消费者（顾客）</td><td>负责从缓冲区获取产品，进行消费</td></tr></tbody></table><p>注意：</p><ul><li>二者不直接通信，不依赖对方的状态；</li><li>只是“对缓冲区”的操作要同步协调。</li></ul><h4 id="3-“1-个交易场所”"><a href="#3-“1-个交易场所”" class="headerlink" title="3. “1 个交易场所”"></a>3. “1 个交易场所”</h4><blockquote><p>  缓冲区就像是“交易中转站”，相当于现实生活的“<strong>超市</strong>”。</p></blockquote><p><strong>1 个交易场所</strong>：超市就是生产者（供货商）和消费者进行交易的场所。超市为供货商提供了销售渠道，将众多供货商的商品集中展示，方便消费者进行选购。</p><p>特点：</p><ul><li>有容量上限：超市货架就这么大，不能无限放。</li><li>是中间角色：解耦了供货商和消费者之间的依赖。</li></ul><hr><h2 id="4-代码示例-——-基于-BlockingQueue-的生产者消费者模型"><a href="#4-代码示例-——-基于-BlockingQueue-的生产者消费者模型" class="headerlink" title="4. 代码示例 —— 基于 BlockingQueue 的生产者消费者模型"></a>4. 代码示例 —— 基于 BlockingQueue 的生产者消费者模型</h2><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250803204513839.png" alt="image-20250803204513691"></p><h3 id="1-BlockingQueue-hpp"><a href="#1-BlockingQueue-hpp" class="headerlink" title="1. BlockingQueue.hpp"></a>1. BlockingQueue.hpp</h3><p>阻塞队列类模板，提供线程安全的任务存储和同步机制。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BlockingQueue</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    queue&lt;T&gt; q_;                                                     <span class="comment">// STL队列，存储实际数据</span></span><br><span class="line">    <span class="type">int</span> max_capacity;                                                <span class="comment">// 队列最大容量</span></span><br><span class="line">    <span class="type">pthread_mutex_t</span> mutex_;                                          <span class="comment">// 互斥锁，保护共享资源</span></span><br><span class="line">    <span class="type">pthread_cond_t</span> not_empty_;                                       <span class="comment">// 非空条件变量，消费者等待</span></span><br><span class="line">    <span class="type">pthread_cond_t</span> not_full_;                                        <span class="comment">// 非满条件变量，生产者等待</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> DEFAULT_MAX_CAPACITY = <span class="number">10</span>;                      <span class="comment">// 队列默认初始容量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数：初始化队列和同步变量</span></span><br><span class="line">    <span class="built_in">BlockingQueue</span>(<span class="type">int</span> max_capacity = DEFAULT_MAX_CAPACITY)</span><br><span class="line">        :<span class="built_in">max_capacity</span>(max_capacity)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_init</span>(&amp;mutex_, <span class="literal">nullptr</span>);                        <span class="comment">// 初始化互斥锁</span></span><br><span class="line">        <span class="built_in">pthread_cond_init</span>(&amp;not_empty_, <span class="literal">nullptr</span>);                     <span class="comment">// 初始化非空条件变量</span></span><br><span class="line">        <span class="built_in">pthread_cond_init</span>(&amp;not_full_, <span class="literal">nullptr</span>);                      <span class="comment">// 初始化非满条件变量</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数：清理资源</span></span><br><span class="line">    ~<span class="built_in">BlockingQueue</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_destroy</span>(&amp;mutex_);                              <span class="comment">// 销毁互斥锁</span></span><br><span class="line">        <span class="built_in">pthread_cond_destroy</span>(&amp;not_empty_);                           <span class="comment">// 销毁非空条件变量</span></span><br><span class="line">        <span class="built_in">pthread_cond_destroy</span>(&amp;not_full_);                            <span class="comment">// 销毁非满条件变量</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 生产者添加元素进行入队</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> T&amp; item)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mutex_);                                 <span class="comment">// 加锁，保护共享资源</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 队列已满，等待非满条件变量</span></span><br><span class="line">        <span class="comment">// 使用while防止虚假唤醒</span></span><br><span class="line">        <span class="keyword">while</span> (q_.<span class="built_in">size</span>() &gt;= max_capacity)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">pthread_cond_wait</span>(&amp;not_full_, &amp;mutex_);                  <span class="comment">// 等待队列有空间</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        q_.<span class="built_in">push</span>(item);                                               <span class="comment">// 入队</span></span><br><span class="line">        <span class="built_in">pthread_cond_signal</span>(&amp;not_empty_);                            <span class="comment">// 唤醒等待的消费者线程</span></span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex_);                               <span class="comment">// 解锁</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消费者取出元素进行出队</span></span><br><span class="line">    <span class="function">T <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mutex_);                                 <span class="comment">// 加锁</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 队列空则等待</span></span><br><span class="line">        <span class="comment">// 使用while防止虚假唤醒</span></span><br><span class="line">        <span class="keyword">while</span> (q_.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">pthread_cond_wait</span>(&amp;not_empty_, &amp;mutex_);                 <span class="comment">// 等待队列有数据</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        T item = q_.<span class="built_in">front</span>();                                         <span class="comment">// 获取队首元素</span></span><br><span class="line">        q_.<span class="built_in">pop</span>();                                                    <span class="comment">// 出队</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">pthread_cond_signal</span>(&amp;not_full_);                             <span class="comment">// 唤醒等待的生产者线程</span></span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex_);                               <span class="comment">// 解锁</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> item;                                                 <span class="comment">// 返回元素</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="2-Task-hpp"><a href="#2-Task-hpp" class="headerlink" title="2. Task.hpp"></a>2. Task.hpp</h3><p>任务类，封装数学运算任务的执行和结果处理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误代码枚举</span></span><br><span class="line"><span class="keyword">enum</span></span><br><span class="line">&#123;</span><br><span class="line">    SUCCESS = <span class="number">0</span>,                                                     <span class="comment">// 成功</span></span><br><span class="line">    DIV_ERROR = <span class="number">1</span>,                                                   <span class="comment">// 除零错误</span></span><br><span class="line">    MOD_ERROR = <span class="number">2</span>,                                                   <span class="comment">// 取模零错误</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Task</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _x, _y;                                                      <span class="comment">// 两个操作数</span></span><br><span class="line">    <span class="type">int</span> _ret;                                                        <span class="comment">// 运算结果</span></span><br><span class="line">    <span class="type">char</span> _op;                                                        <span class="comment">// 操作符</span></span><br><span class="line">    <span class="type">int</span> _code;                                                       <span class="comment">// 错误代码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数：初始化任务参数</span></span><br><span class="line">    <span class="built_in">Task</span>(<span class="type">int</span> x = <span class="number">0</span>, <span class="type">int</span> y = <span class="number">0</span>, <span class="type">char</span> op = <span class="string">&#x27;+&#x27;</span>)</span><br><span class="line">        :_x(x),</span><br><span class="line">        _y(y),</span><br><span class="line">        _op(op),</span><br><span class="line">        _ret(<span class="number">0</span>),</span><br><span class="line">        _code(SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行运算任务</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span>(_op)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                _ret = _x + _y;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                _ret = _x - _y;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                _ret = _x * _y;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span>(_y == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    _code = DIV_ERROR;                               <span class="comment">// 除零错误</span></span><br><span class="line">                    _ret = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    _ret = _x / _y;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;%&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span>(_y == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    _code = MOD_ERROR;                               <span class="comment">// 取模零错误</span></span><br><span class="line">                    _ret = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    _ret = _x % _y;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                _code = MOD_ERROR;                                   <span class="comment">// 未知操作符错误</span></span><br><span class="line">                _ret = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载函数调用操作符，使Task对象可以像函数一样调用</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">run</span>();                                                       <span class="comment">// 执行运算</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取任务描述字符串</span></span><br><span class="line">    <span class="function">string <span class="title">get_task</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">to_string</span>(_x) + _op + <span class="built_in">to_string</span>(_y) + <span class="string">&quot;= ???&quot;</span>;        <span class="comment">// 格式：x op y = ???</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取运算结果字符串</span></span><br><span class="line">    <span class="function">string <span class="title">get_ret</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        string ret = <span class="built_in">to_string</span>(_x) + _op + <span class="built_in">to_string</span>(_y) + <span class="string">&quot;=&quot;</span> + <span class="built_in">to_string</span>(_ret) + </span><br><span class="line">                     <span class="string">&quot; [错误代码]：&quot;</span> + <span class="built_in">to_string</span>(_code);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="3-main-cpp"><a href="#3-main-cpp" class="headerlink" title="3. main.cpp"></a>3. main.cpp</h3><p>主程序，创建多个生产者线程生成随机任务，多个消费者线程处理任务并输出结果。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;BlockingQueue.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Task.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> string ops = <span class="string">&quot;+-*/%&quot;</span>;                                          <span class="comment">// 操作符</span></span><br><span class="line">BlockingQueue&lt;Task&gt;* TaskQueue;                                      <span class="comment">// 全局任务队列指针</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> g_print_mutex = PTHREAD_MUTEX_INITIALIZER;           <span class="comment">// 全局打印互斥锁，确保输出尽量不交错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前时间戳（毫秒），用于标识消息的产生时间</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">get_timestamp</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">timeval</span> tv;                                               <span class="comment">// 时间结构体</span></span><br><span class="line">    <span class="built_in">gettimeofday</span>(&amp;tv, <span class="literal">nullptr</span>);                                      <span class="comment">// 获取当前时间</span></span><br><span class="line">    <span class="keyword">return</span> tv.tv_sec * <span class="number">1000</span> + tv.tv_usec / <span class="number">1000</span>;                     <span class="comment">// 转换为毫秒时间戳</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程安全的打印函数，添加时间戳便于观察执行顺序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">safe_print</span><span class="params">(<span class="type">const</span> string&amp; message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;g_print_mutex);                              <span class="comment">// 加锁，防止输出交错</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;[&quot;</span> &lt;&lt; <span class="built_in">get_timestamp</span>() &lt;&lt; <span class="string">&quot;] &quot;</span> &lt;&lt; message &lt;&lt; endl;       <span class="comment">// 带时间戳的输出</span></span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;g_print_mutex);                            <span class="comment">// 解锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者线程函数</span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">consumer</span><span class="params">(<span class="type">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> id = *(<span class="type">int</span>*)arg;                                             <span class="comment">// 获取线程ID</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)                                                      <span class="comment">// 持续消费</span></span><br><span class="line">    &#123;</span><br><span class="line">        Task task = TaskQueue-&gt;<span class="built_in">pop</span>();                                <span class="comment">// 从队列取出任务（可能阻塞等待）</span></span><br><span class="line">        <span class="built_in">task</span>();                                                      <span class="comment">// 执行任务运算</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 构造消费完成的消息</span></span><br><span class="line">        string s = <span class="string">&quot;[消费者 &quot;</span> + <span class="built_in">to_string</span>(id) + <span class="string">&quot;] 完成了任务：&quot;</span> + task.<span class="built_in">get_task</span>() + <span class="string">&quot;，结果为：&quot;</span> + task.<span class="built_in">get_ret</span>();</span><br><span class="line">        <span class="built_in">safe_print</span>(s);                                               <span class="comment">// 线程安全的打印，带时间戳</span></span><br><span class="line">        <span class="built_in">usleep</span>(<span class="number">500000</span>);                                              <span class="comment">// 500ms延迟，控制消费速度</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_exit</span>(<span class="literal">nullptr</span>);                                           <span class="comment">// 线程退出</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者线程函数</span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">producer</span><span class="params">(<span class="type">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> id = *(<span class="type">int</span>*)arg;                                             <span class="comment">// 获取线程ID</span></span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">nullptr</span>) + id * <span class="number">1000</span>);                                <span class="comment">// 设置随机种子，避免重复</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)                                                      <span class="comment">// 持续生产</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x = <span class="built_in">rand</span>() % <span class="number">50</span> + <span class="number">1</span>;                                     <span class="comment">// 生成随机数 [1, 50]，范围更小便于观察</span></span><br><span class="line">        <span class="type">int</span> y = <span class="built_in">rand</span>() % <span class="number">50</span> + <span class="number">1</span>;                                     <span class="comment">// 生成随机数 [1, 50]</span></span><br><span class="line">        <span class="type">char</span> op = ops[<span class="built_in">rand</span>() % ops.<span class="built_in">size</span>()];                          <span class="comment">// 随机选择操作符</span></span><br><span class="line"></span><br><span class="line">        <span class="function">Task <span class="title">task</span><span class="params">(x, y, op)</span></span>;                                         <span class="comment">// 创建任务对象</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先打印生产消息，再放入队列</span></span><br><span class="line">        string s = <span class="string">&quot;[生产者 &quot;</span> + <span class="built_in">to_string</span>(id) + <span class="string">&quot;] 生产了任务：&quot;</span> + task.<span class="built_in">get_task</span>();</span><br><span class="line">        <span class="built_in">safe_print</span>(s);                                               <span class="comment">// 线程安全的打印，带时间戳</span></span><br><span class="line">        </span><br><span class="line">        TaskQueue-&gt;<span class="built_in">push</span>(task);                                       <span class="comment">// 将任务放入队列（可能阻塞等待）</span></span><br><span class="line">        <span class="built_in">usleep</span>(<span class="number">1000000</span>);                                             <span class="comment">// 1秒延迟，控制生产速度</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_exit</span>(<span class="literal">nullptr</span>);                                           <span class="comment">// 线程退出</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TaskQueue = <span class="keyword">new</span> <span class="built_in">BlockingQueue</span>&lt;Task&gt;(<span class="number">5</span>);                          <span class="comment">// 创建容量为5的阻塞队列</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ids[<span class="number">5</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;                                  <span class="comment">// 线程ID数组</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建2个消费者线程</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;创建 2 个消费者线程&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="type">pthread_t</span> Consumers[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_create</span>(&amp;Consumers[i], <span class="literal">nullptr</span>, consumer, &amp;ids[i]);   <span class="comment">// 创建消费者线程</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建3个生产者线程</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;创建 3 个生产者线程&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="type">pthread_t</span> Producers[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_create</span>(&amp;Producers[i], <span class="literal">nullptr</span>, producer, &amp;ids[i<span class="number">+2</span>]); <span class="comment">// 创建生产者线程</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 等待所有线程结束（实际程序不会退出）</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_join</span>(Consumers[i], <span class="literal">nullptr</span>);                         <span class="comment">// 等待消费者线程</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_join</span>(Producers[i], <span class="literal">nullptr</span>);                         <span class="comment">// 等待生产者线程</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">delete</span> TaskQueue;                                                <span class="comment">// 释放队列内存</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="5-POSIX-信号量"><a href="#5-POSIX-信号量" class="headerlink" title="5. POSIX 信号量"></a>5. POSIX 信号量</h2><h3 id="1-什么是-POSIX-信号量？有什么用？"><a href="#1-什么是-POSIX-信号量？有什么用？" class="headerlink" title="1. 什么是 POSIX 信号量？有什么用？"></a>1. 什么是 POSIX 信号量？有什么用？</h3><p>POSIX 信号量和 SystemV 信号量作用相同，都是用于同步操作，达到无冲突的访问共享资源目的。 但 POSIX 可以用于线程间同步，属于 POSIX 标准的一部分（定义在 <code>&lt;semaphore.h&gt;</code> 头文件中），主要用于控制对共享资源的访问，避免竞争条件，实现互斥与同步。</p><h3 id="2-POSIX-信号量函数"><a href="#2-POSIX-信号量函数" class="headerlink" title="2. POSIX 信号量函数"></a>2. POSIX 信号量函数</h3><p>同样的，这部分函数和之前的 <code>pthread_mutex_init</code> 系列函数十分相似，这里就不详细讲解了，类比使用即可。<strong>注意头文件是 <code>&lt;semaphore.h&gt;</code>。</strong></p><table><thead><tr><th>作用</th><th>函数原型</th><th>参数说明</th><th>返回值</th></tr></thead><tbody><tr><td><strong>初始化</strong> 信号量</td><td><code>int sem_init(sem_t *sem, int pshared, unsigned int value);</code></td><td><code>sem</code>：信号量指针 <br><code>pshared</code>：0 表示用于线程间共享；非 0 表示进程间共享<br><code>value</code>：初始值，表示资源初始数量</td><td>0 表示成功，非 0 表示失败（可用 <code>errno</code> 获取错误）</td></tr><tr><td><strong>销毁</strong> 信号量</td><td><code>int sem_destroy(sem_t *sem);</code></td><td><code>sem</code>：信号量指针</td><td>0 成功，非 0 失败</td></tr><tr><td><strong>等待</strong>（P 操作）</td><td><code>int sem_wait(sem_t *sem);</code></td><td><code>sem</code>：信号量指，如果 <code>sem &gt; 0</code>，则减一并继续执行；值为 0，则阻塞等待</td><td>0 成功，-1 失败</td></tr><tr><td>非阻塞等待</td><td><code>int sem_trywait(sem_t *sem);</code></td><td><code>sem</code>：信号量指针   如果资源不足，不会阻塞，而是立即返回错误（适合用于非阻塞检测场景）</td><td>0 成功，-1 失败</td></tr><tr><td><strong>发布</strong>（增加）信号量（V 操作）</td><td><code>int sem_post(sem_t *sem);</code></td><td><code>sem</code>：信号量指针   将信号量值加 1，如果有等待线程，将唤醒其中一个</td><td>0 成功，-1 失败</td></tr></tbody></table><p>这里把信号量的工作流程（P&#x2F;V 操作）单拎出来进行强调：</p><table><thead><tr><th>操作</th><th>含义</th><th>行为描述</th></tr></thead><tbody><tr><td><code>sem_wait()</code></td><td><strong>P 操作</strong>（wait）</td><td>当前线程尝试获取资源： 若信号量值 &gt; 0，获取成功（减 1） 若 &#x3D; 0，则阻塞等待</td></tr><tr><td><code>sem_post()</code></td><td><strong>V 操作</strong>（signal）</td><td>当前线程释放资源： 信号量值 +1，若有等待线程，唤醒一个</td></tr></tbody></table><h3 id="3-代码示例"><a href="#3-代码示例" class="headerlink" title="3. 代码示例"></a>3. 代码示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">sem_t</span> sem;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">worker</span><span class="params">(<span class="type">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> id = *(<span class="type">int</span>*)arg;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sem_wait</span>(&amp;sem);                        <span class="comment">// 请求信号量（如果值为0，则阻塞等待）</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Thread：&quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; 获取到了信号量&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">1</span>);                              <span class="comment">// 模拟工作</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">sem_post</span>(&amp;sem);                        <span class="comment">// 释放信号量</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Thread：&quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; 释放了信号量&quot;</span> &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">sem_init</span>(&amp;sem, <span class="number">0</span>, <span class="number">3</span>);                   <span class="comment">// 初始化信号量，最多允许3个线程同时进入</span></span><br><span class="line"></span><br><span class="line">    <span class="type">pthread_t</span> threads[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span> ids[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ids[i] = i;</span><br><span class="line">        <span class="built_in">pthread_create</span>(&amp;threads[i], <span class="literal">nullptr</span>, worker, &amp;ids[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_join</span>(threads[i], <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sem_destroy</span>(&amp;sem);                      <span class="comment">// 清理资源</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="6-基于环形队列的生产消费模型"><a href="#6-基于环形队列的生产消费模型" class="headerlink" title="6. 基于环形队列的生产消费模型"></a>6. 基于环形队列的生产消费模型</h2><h3 id="1-什么是环形队列生产消费模型？"><a href="#1-什么是环形队列生产消费模型？" class="headerlink" title="1. 什么是环形队列生产消费模型？"></a>1. 什么是环形队列生产消费模型？</h3><p><strong>基于环形队列的生产者-消费者模型</strong> 也是一种常见的并发编程设计，其核心是通过环形队列（循环队列）作为缓冲区，协调 “生产者” 和 “消费者” 两个角色的工作：生产者负责生成数据并放入队列，消费者负责从队列中取出数据并处理。从而实现生产者与消费者之间的数据传递和解耦。需要注意的是双方互不直接通信，而是通过队列进行 <strong>异步协作</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250803203650401.png" alt="image-20250803203650239"></p><h3 id="2-特点"><a href="#2-特点" class="headerlink" title="2. 特点"></a>2. 特点</h3><ul><li>环形队列是一个 <strong>固定容量、首尾相接的循环缓冲区</strong>。</li><li>使用两个指针：<ul><li><code>head</code> &#x2F; <code>front</code> → 消费者读取位置。</li><li><code>tail</code> &#x2F; <code>rear</code> → 生产者写入位置。</li></ul></li><li>每次写或读都会环形移动（取模）。</li></ul><h3 id="3-环形队列中判空-判满的处理（重点）"><a href="#3-环形队列中判空-判满的处理（重点）" class="headerlink" title="3. 环形队列中判空 &#x2F; 判满的处理（重点）"></a>3. 环形队列中判空 &#x2F; 判满的处理（重点）</h3><p>由于 <code>front</code> 和 <code>rear</code> 都在循环移动，<strong>当队列为空或为满时，都会出现 <code>front == rear</code> 的情况</strong>，因此环形队列最关键的难点就是 <strong>如何区分“队列空”与“队列满”</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250803203221278.png" alt="image-20250803203221100"></p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250803203514519.png" alt="image-20250803203514374"></p><h3 id="4-常见解决方案"><a href="#4-常见解决方案" class="headerlink" title="4. 常见解决方案"></a>4. 常见解决方案</h3><table><thead><tr><th>方法</th><th>原理</th><th>判空条件</th><th>判满条件</th><th>优缺点</th></tr></thead><tbody><tr><td><strong>1. 多空一法（保留一个空位，即浪费一个存储单元</strong></td><td>规定队列容量为 <code>N</code> 时，最多存 <code>N-1</code> 个元素。</td><td><code>head == tail</code></td><td><code>(tail + 1) % size == head</code></td><td>✅ 简单高效，逻辑清晰，边界状态安全<br>❌ 实际可用容量为 <code>size - 1</code>，浪费一个单元空间</td></tr><tr><td><strong>2. 引入计数器 <code>count</code></strong></td><td>使用一个 <code>int count</code> 变量单独记录当前队列中元素数量。</td><td><code>count == 0</code></td><td><code>count == size</code></td><td>✅ 空间完全利用<br>❌ 需要额外同步 <code>count</code> 变量，线程并发时处理更复杂</td></tr><tr><td><strong>3. 标志（记）位法（flag）</strong></td><td>设置一个标志位 <code>bool full</code> 来判断当前状态。</td><td><code>head == tail &amp;&amp; !full</code></td><td><code>head == tail &amp;&amp; full</code></td><td>✅ 读写位置逻辑简洁清晰<br>❌ 实现复杂，易出错</td></tr></tbody></table><hr><h3 id="5-代码示例"><a href="#5-代码示例" class="headerlink" title="5. 代码示例"></a>5. 代码示例</h3><h4 id="1-RingQueue-hpp"><a href="#1-RingQueue-hpp" class="headerlink" title="1. RingQueue.hpp"></a>1. RingQueue.hpp</h4><p>基于信号量和互斥锁实现的线程安全环形队列模板类，使用两个信号量分别控制数据资源和空间资源，两个互斥锁保护生产者和消费者的并发访问位置。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">static</span> <span class="type">int</span> default_capacity = <span class="number">5</span>;                               <span class="comment">// 环形队列默认容量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RingQueue</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// P操作：等待信号量（资源减少）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">P</span><span class="params">(<span class="type">sem_t</span>&amp; sem)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">sem_wait</span>(&amp;sem);                                              <span class="comment">// 等待信号量，原子操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// V操作：释放信号量（资源增加）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">V</span><span class="params">(<span class="type">sem_t</span>&amp; sem)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">sem_post</span>(&amp;sem);                                              <span class="comment">// 释放信号量，原子操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加锁操作</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Lock</span><span class="params">(<span class="type">pthread_mutex_t</span>&amp; mutex)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);                                  <span class="comment">// 加锁（获取互斥锁），原子操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解锁操作</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Unlock</span><span class="params">(<span class="type">pthread_mutex_t</span>&amp; mutex)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);                                <span class="comment">// 解锁（释放互斥锁），原子操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">RingQueue</span>(<span class="type">int</span> capacity = default_capacity)</span><br><span class="line">        :<span class="built_in">ringqueue_</span>(capacity),</span><br><span class="line">        <span class="built_in">capacity_</span>(capacity),</span><br><span class="line">        <span class="built_in">c_index_</span>(<span class="number">0</span>),</span><br><span class="line">        <span class="built_in">p_index_</span>(<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sem_init</span>(&amp;cdata_sem_, <span class="number">0</span>, <span class="number">0</span>);                                 <span class="comment">// 初始化消费者数据信号量为0（初始无数据）</span></span><br><span class="line">        <span class="built_in">sem_init</span>(&amp;pspace_sem_, <span class="number">0</span>, capacity_);                        <span class="comment">// 初始化生产者空间信号量为cap（初始全部空间）</span></span><br><span class="line">    </span><br><span class="line">        <span class="built_in">pthread_mutex_init</span>(&amp;c_mutex_, <span class="literal">nullptr</span>);                      <span class="comment">// 初始化消费者互斥锁</span></span><br><span class="line">        <span class="built_in">pthread_mutex_init</span>(&amp;p_mutex_, <span class="literal">nullptr</span>);                      <span class="comment">// 初始化生产者互斥锁</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">RingQueue</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sem_destroy</span>(&amp;cdata_sem_);                                    <span class="comment">// 销毁消费者数据信号量</span></span><br><span class="line">        <span class="built_in">sem_destroy</span>(&amp;pspace_sem_);                                   <span class="comment">// 销毁生产者空间信号量</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">pthread_mutex_destroy</span>(&amp;c_mutex_);                            <span class="comment">// 销毁消费者互斥锁</span></span><br><span class="line">        <span class="built_in">pthread_mutex_destroy</span>(&amp;p_mutex_);                            <span class="comment">// 销毁生产者互斥锁</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生产者：向环形队列添加元素</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Push</span><span class="params">(<span class="type">const</span> T&amp; in)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">P</span>(pspace_sem_);                                              <span class="comment">// 等待可用空间（空间资源-1）</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">Lock</span>(p_mutex_);                                              <span class="comment">// 加锁保护生产者写入位置</span></span><br><span class="line">        ringqueue_[p_index_] = in;                                   <span class="comment">// 在生产者位置写入数据</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 位置后移，维持环形特性</span></span><br><span class="line">        p_index_++;                                                  <span class="comment">// 生产者下标后移</span></span><br><span class="line">        p_index_ %= capacity_;                                       <span class="comment">// 取模实现环形</span></span><br><span class="line">        <span class="built_in">Unlock</span>(p_mutex_);                                            <span class="comment">// 解锁</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">V</span>(cdata_sem_);                                               <span class="comment">// 增加数据资源（唤醒消费者）</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消费者：从环形队列取出元素</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Pop</span><span class="params">(T* out)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">P</span>(cdata_sem_);                                               <span class="comment">// 等待可用数据（数据资源-1）</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">Lock</span>(c_mutex_);                                              <span class="comment">// 加锁保护消费者读取位置</span></span><br><span class="line">        *out = ringqueue_[c_index_];                                 <span class="comment">// 从消费者位置读取数据</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 位置后移，维持环形特性</span></span><br><span class="line">        c_index_++;                                                  <span class="comment">// 消费者下标后移</span></span><br><span class="line">        c_index_ %= capacity_;                                       <span class="comment">// 取模实现环形</span></span><br><span class="line">        <span class="built_in">Unlock</span>(c_mutex_);                                            <span class="comment">// 解锁</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">V</span>(pspace_sem_);                                              <span class="comment">// 增加空间资源（唤醒生产者）</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;T&gt; ringqueue_;                                            <span class="comment">// 存储数据的环形数组</span></span><br><span class="line">    <span class="type">int</span> capacity_;                                                   <span class="comment">// 队列容量</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> c_index_;                                                    <span class="comment">// 消费者当前位置下标</span></span><br><span class="line">    <span class="type">int</span> p_index_;                                                    <span class="comment">// 生产者当前位置下标</span></span><br><span class="line"></span><br><span class="line">    <span class="type">sem_t</span> cdata_sem_;                                                <span class="comment">// 消费者关注的数据资源信号量（有多少数据可消费）</span></span><br><span class="line">    <span class="type">sem_t</span> pspace_sem_;                                               <span class="comment">// 生产者关注的空间资源信号量（有多少空间可生产）</span></span><br><span class="line"></span><br><span class="line">    <span class="type">pthread_mutex_t</span> c_mutex_;                                        <span class="comment">// 消费者互斥锁，保护消费者位置</span></span><br><span class="line">    <span class="type">pthread_mutex_t</span> p_mutex_;                                        <span class="comment">// 生产者互斥锁，保护生产者位置</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="2-Task-hpp-1"><a href="#2-Task-hpp-1" class="headerlink" title="2. Task.hpp"></a>2. Task.hpp</h4><p>封装数学运算任务的类，支持加减乘除取模五种运算，包含错误处理机制，提供任务执行和结果获取功能。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> string opers = <span class="string">&quot;+-*/%&quot;</span>;                                        <span class="comment">// 支持的操作符集合</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误代码枚举定义</span></span><br><span class="line"><span class="keyword">enum</span></span><br><span class="line">&#123;</span><br><span class="line">    SUCCESS = <span class="number">0</span>,                                                     <span class="comment">// 成功</span></span><br><span class="line">    DIV_ERROR = <span class="number">1</span>,                                                   <span class="comment">// 除零错误</span></span><br><span class="line">    MOD_ERROR = <span class="number">2</span>,                                                   <span class="comment">// 取模零错误</span></span><br><span class="line">    UNKNOWN_ERROR = <span class="number">3</span>                                                <span class="comment">// 未知操作符错误</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Task</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 默认构造函数</span></span><br><span class="line">    <span class="built_in">Task</span>()</span><br><span class="line">        :_x(<span class="number">0</span>), _y(<span class="number">0</span>), _op(<span class="string">&#x27;+&#x27;</span>), _ret(<span class="number">0</span>), _code(SUCCESS)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 带参数构造函数：初始化任务参数</span></span><br><span class="line">    <span class="built_in">Task</span>(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">char</span> op = <span class="string">&#x27;+&#x27;</span>)</span><br><span class="line">        :_x(x),</span><br><span class="line">        _y(y),</span><br><span class="line">        _op(op),</span><br><span class="line">        _ret(<span class="number">0</span>),</span><br><span class="line">        _code(SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 验证操作符是否合法</span></span><br><span class="line">        <span class="keyword">if</span>(op != <span class="string">&#x27;+&#x27;</span> &amp;&amp; op != <span class="string">&#x27;-&#x27;</span> &amp;&amp; op != <span class="string">&#x27;*&#x27;</span> &amp;&amp; op != <span class="string">&#x27;/&#x27;</span> &amp;&amp; op != <span class="string">&#x27;%&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            _op = <span class="string">&#x27;+&#x27;</span>;                                               <span class="comment">// 默认为加法</span></span><br><span class="line">            _code = UNKNOWN_ERROR;                                   <span class="comment">// 设置错误码</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行运算任务</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 重置结果和错误码（避免重复调用时的问题）</span></span><br><span class="line">        _ret = <span class="number">0</span>;</span><br><span class="line">        _code = SUCCESS;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">switch</span>(_op)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                _ret = _x + _y;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                _ret = _x - _y;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                _ret = _x * _y;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span>(_y == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    _code = DIV_ERROR;                               <span class="comment">// 除零错误</span></span><br><span class="line">                    _ret = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    _ret = _x / _y;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;%&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span>(_y == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    _code = MOD_ERROR;                               <span class="comment">// 取模零错误</span></span><br><span class="line">                    _ret = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    _ret = _x % _y;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                _code = UNKNOWN_ERROR;                               <span class="comment">// 未知操作符错误</span></span><br><span class="line">                _ret = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载函数调用操作符，使Task对象可以像函数一样调用</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">run</span>();                                                       <span class="comment">// 执行运算</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取任务描述字符串</span></span><br><span class="line">    <span class="function">string <span class="title">get_task</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">to_string</span>(_x) + _op + <span class="built_in">to_string</span>(_y) + <span class="string">&quot;= ???&quot;</span>;        <span class="comment">// 格式：x op y = ???</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取运算结果字符串</span></span><br><span class="line">    <span class="function">string <span class="title">get_ret</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        string ret = <span class="built_in">to_string</span>(_x) + _op + <span class="built_in">to_string</span>(_y) + <span class="string">&quot;=&quot;</span> + <span class="built_in">to_string</span>(_ret) + </span><br><span class="line">                     <span class="string">&quot; [错误代码：&quot;</span> + <span class="built_in">to_string</span>(_code) + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取操作符</span></span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">get_operator</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _op;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取第一个操作数</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_first_operand</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取第二个操作数</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_second_operand</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取运算结果</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_result</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取错误代码</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_error_code</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">Task</span>()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _x, _y;                                                      <span class="comment">// 两个操作数</span></span><br><span class="line">    <span class="type">int</span> _ret;                                                        <span class="comment">// 运算结果</span></span><br><span class="line">    <span class="type">char</span> _op;                                                        <span class="comment">// 操作符</span></span><br><span class="line">    <span class="type">int</span> _code;                                                       <span class="comment">// 错误代码</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="3-Main-cc"><a href="#3-Main-cc" class="headerlink" title="3. Main.cc"></a>3. Main.cc</h4><p>创建多个生产者和消费者线程，生产者生成随机运算任务放入环形队列，消费者从队列取出任务并执行计算，演示多线程协作的生产消费模型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;RingQueue.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Task.hpp&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程数据结构，传递给线程函数</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ThreadData</span></span><br><span class="line">&#123;</span><br><span class="line">    RingQueue&lt;Task&gt; *rq;                                             <span class="comment">// 环形队列指针</span></span><br><span class="line">    string threadname;                                               <span class="comment">// 线程名称</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者线程函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">Productor</span><span class="params">(<span class="type">void</span> *args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ThreadData *td = <span class="built_in">static_cast</span>&lt;ThreadData*&gt;(args);                 <span class="comment">// 获取线程数据</span></span><br><span class="line">    RingQueue&lt;Task&gt; *rq = td-&gt;rq;                                    <span class="comment">// 获取环形队列</span></span><br><span class="line">    string name = td-&gt;threadname;                                    <span class="comment">// 获取线程名称</span></span><br><span class="line">    <span class="type">int</span> len = opers.<span class="built_in">size</span>();                                          <span class="comment">// 操作符个数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)                                                     <span class="comment">// 持续生产</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 1. 获取数据：生成随机任务</span></span><br><span class="line">        <span class="type">int</span> data1 = <span class="built_in">rand</span>() % <span class="number">10</span> + <span class="number">1</span>;                                 <span class="comment">// 生成[1,10]随机数</span></span><br><span class="line">        <span class="built_in">usleep</span>(<span class="number">10</span>);                                                  <span class="comment">// 微秒延迟</span></span><br><span class="line">        <span class="type">int</span> data2 = <span class="built_in">rand</span>() % <span class="number">10</span>;                                     <span class="comment">// 生成[0,9]随机数</span></span><br><span class="line">        <span class="type">char</span> op = opers[<span class="built_in">rand</span>() % len];                               <span class="comment">// 随机选择操作符</span></span><br><span class="line">        <span class="function">Task <span class="title">t</span><span class="params">(data1, data2, op)</span></span>;                                    <span class="comment">// 创建任务对象</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 生产数据：将任务放入环形队列</span></span><br><span class="line">        rq-&gt;<span class="built_in">Push</span>(t);                                                 <span class="comment">// 生产任务</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 修复打印格式，添加换行符使输出更清晰</span></span><br><span class="line">        cout &lt;&lt; name &lt;&lt; <span class="string">&quot; 生产任务：&quot;</span> &lt;&lt; t.<span class="built_in">get_task</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);                                                    <span class="comment">// 1秒生产间隔</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者线程函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">Consumer</span><span class="params">(<span class="type">void</span> *args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ThreadData *td = <span class="built_in">static_cast</span>&lt;ThreadData*&gt;(args);                 <span class="comment">// 获取线程数据</span></span><br><span class="line">    RingQueue&lt;Task&gt; *rq = td-&gt;rq;                                    <span class="comment">// 获取环形队列</span></span><br><span class="line">    string name = td-&gt;threadname;                                    <span class="comment">// 获取线程名称</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)                                                     <span class="comment">// 持续消费</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 1. 消费数据：从环形队列取出任务</span></span><br><span class="line">        Task t;                                                      <span class="comment">// 创建任务对象</span></span><br><span class="line">        rq-&gt;<span class="built_in">Pop</span>(&amp;t);                                                 <span class="comment">// 消费任务（阻塞等待）</span></span><br><span class="line">       </span><br><span class="line">        <span class="comment">// 2. 处理数据：执行任务并输出结果</span></span><br><span class="line">        <span class="built_in">t</span>();                                                         <span class="comment">// 执行运算</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 修复打印格式，添加换行符使输出更清晰</span></span><br><span class="line">        cout &lt;&lt; name &lt;&lt; <span class="string">&quot; 消费任务：&quot;</span> &lt;&lt; t.<span class="built_in">get_task</span>() &lt;&lt; <span class="string">&quot; 结果：&quot;</span> &lt;&lt; t.<span class="built_in">get_ret</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;=== 环形队列生产者-消费者模型 ===&quot;</span> &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">nullptr</span>) ^ <span class="built_in">getpid</span>());                                 <span class="comment">// 设置随机种子</span></span><br><span class="line">    RingQueue&lt;Task&gt; *rq = <span class="keyword">new</span> <span class="built_in">RingQueue</span>&lt;Task&gt;(<span class="number">10</span>);                   <span class="comment">// 创建容量为10的环形队列（小一点便于测试）</span></span><br><span class="line"></span><br><span class="line">    <span class="type">pthread_t</span> consumers[<span class="number">3</span>], producers[<span class="number">2</span>];                            <span class="comment">// 创建多个消费者和生产者</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建2个生产者线程</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;创建 2 个生产者线程...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ThreadData *td = <span class="keyword">new</span> <span class="built_in">ThreadData</span>();                           <span class="comment">// 创建线程数据</span></span><br><span class="line">        td-&gt;rq = rq;                                                 <span class="comment">// 设置环形队列</span></span><br><span class="line">        td-&gt;threadname = <span class="string">&quot;[生产者-&quot;</span> + <span class="built_in">to_string</span>(i) + <span class="string">&quot;]&quot;</span>;            <span class="comment">// 设置线程名称</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">pthread_create</span>(&amp;producers[i], <span class="literal">nullptr</span>, Productor, td);       <span class="comment">// 创建生产者线程</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建3个消费者线程</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;创建 3 个消费者线程...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ThreadData *td = <span class="keyword">new</span> <span class="built_in">ThreadData</span>();                           <span class="comment">// 创建线程数据</span></span><br><span class="line">        td-&gt;rq = rq;                                                 <span class="comment">// 设置环形队列</span></span><br><span class="line">        td-&gt;threadname = <span class="string">&quot;[消费者-&quot;</span> + <span class="built_in">to_string</span>(i) + <span class="string">&quot;]&quot;</span>;             <span class="comment">// 设置线程名称</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">pthread_create</span>(&amp;consumers[i], <span class="literal">nullptr</span>, Consumer, td);        <span class="comment">// 创建消费者线程</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 等待线程结束（实际程序不会退出）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_join</span>(producers[i], <span class="literal">nullptr</span>);                         <span class="comment">// 等待生产者线程</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_join</span>(consumers[i], <span class="literal">nullptr</span>);                         <span class="comment">// 等待消费者线程</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> rq;                                                       <span class="comment">// 释放内存</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>041 深入理解线程间同步与互斥</title>
      <link href="/posts/17300.html"/>
      <url>/posts/17300.html</url>
      
        <content type="html"><![CDATA[<h1 id="深入理解线程间同步与互斥"><a href="#深入理解线程间同步与互斥" class="headerlink" title="深入理解线程间同步与互斥"></a>深入理解线程间同步与互斥</h1><h2 id="1-什么是线程互斥？"><a href="#1-什么是线程互斥？" class="headerlink" title="1. 什么是线程互斥？"></a>1. 什么是线程互斥？</h2><blockquote><p>简单来说，线程互斥就是当一个线程在访问某个共享资源时，其他线程不能同时访问。就好像多个线程都想去用一台打印机，为了避免打印乱套，得保证同一时间只有一个线程能使用，这就是互斥。</p></blockquote><p><strong>线程互斥</strong> 就是为了防止多个线程 <strong>同时访问某个共享资源</strong>（如变量、文件、临界区），<strong>导致数据错误或冲突</strong>。</p><p>先来看一段代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NUM 5                                              <span class="comment">// 定义线程数量</span></span></span><br><span class="line"><span class="type">int</span> tickets = <span class="number">100</span>;                                         <span class="comment">// 全局共享变量：票数（多个线程将同时访问这个变量，临界资源）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">thread_data</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">thread_data</span>(<span class="type">int</span> number)                                <span class="comment">// 构造函数：根据线程编号初始化线程名称</span></span><br><span class="line">    &#123;</span><br><span class="line">        thread_name = <span class="string">&quot;线程&quot;</span> + <span class="built_in">to_string</span>(number);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string thread_name;                                    <span class="comment">// 线程名称</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">getticket</span><span class="params">(<span class="type">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    thread_data* data = <span class="built_in">static_cast</span>&lt;thread_data*&gt;(arg);    <span class="comment">// 将传入的参数转换为 threadData 类型指针</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* name = data-&gt;thread_name.<span class="built_in">c_str</span>();          <span class="comment">// 获取线程名称</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)                                            <span class="comment">// 无限循环买票，竞态条件发生在这里！</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(tickets &gt; <span class="number">0</span>)                                    <span class="comment">// 票数大于 0 时，买票</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">usleep</span>(<span class="number">1000</span>);                                  <span class="comment">// 模拟票务系统延时</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s 获得 1 张票，剩余 %d 张票\n&quot;</span>, name, tickets);    <span class="comment">// 打印票数信息</span></span><br><span class="line">            tickets--;                                     <span class="comment">// 票数减 1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>                                               <span class="comment">// 票数不足时，跳出循环</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;线程&quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;执行结束！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">pthread_t</span>&gt; tids;                                <span class="comment">// 存储线程 ID 的向量容器</span></span><br><span class="line">    vector&lt;thread_data*&gt; thread_datas;                     <span class="comment">// 存储线程数据的向量容器</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;多线程买票演示程序&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;总票数: &quot;</span> &lt;&lt; tickets &lt;&lt; <span class="string">&quot; 张&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;创建 &quot;</span> &lt;&lt; NUM &lt;&lt; <span class="string">&quot; 个线程同时买票...&quot;</span> &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">pthread_t</span> tid;                                      <span class="comment">// 线程 ID 变量</span></span><br><span class="line">        thread_data* data = <span class="keyword">new</span> <span class="built_in">thread_data</span>(i);             <span class="comment">// 为每个线程创建独立的数据对象</span></span><br><span class="line">        thread_datas.<span class="built_in">push_back</span>(data);                       <span class="comment">// 保存数据对象指针</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">pthread_create</span>(&amp;tid, <span class="literal">nullptr</span>, getticket, data);     <span class="comment">// 创建线程，传入参数为线程数据对象指针</span></span><br><span class="line">        tids.<span class="built_in">push_back</span>(tid);                                <span class="comment">// 保存线程 ID</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;所有线程创建完成，开始并发买票...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">3</span>);                                               <span class="comment">// 等待 3 秒，让主进程等待子进程结束</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> data : thread_datas)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> data;                                        <span class="comment">// 释放每个线程的数据对象</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果示例（运行结果不唯一）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">……</span><br><span class="line">线程1 获得 1 张票，剩余 9 张票</span><br><span class="line">线程2 获得 1 张票，剩余 8 张票</span><br><span class="line">线程3 获得 1 张票，剩余 7 张票</span><br><span class="line">线程4 获得 1 张票，剩余 6 张票</span><br><span class="line">线程0 获得 1 张票，剩余 5 张票</span><br><span class="line">线程2 获得 1 张票，剩余 4 张票</span><br><span class="line">线程3 获得 1 张票，剩余 3 张票</span><br><span class="line">线程1 获得 1 张票，剩余 2 张票</span><br><span class="line">线程4 获得 1 张票，剩余 1 张票</span><br><span class="line">线程线程4执行结束！</span><br><span class="line">线程0 获得 1 张票，剩余 0 张票</span><br><span class="line">线程线程0执行结束！</span><br><span class="line">线程3 获得 1 张票，剩余 -1 张票</span><br><span class="line">线程线程3执行结束！</span><br><span class="line">线程2 获得 1 张票，剩余 -2 张票</span><br><span class="line">线程线程2执行结束！</span><br><span class="line">线程1 获得 1 张票，剩余 -3 张票</span><br><span class="line">线程线程1执行结束！</span><br><span class="line">[hcc@hcss-ecs-be68 Synchronization and Mutex]$ </span><br></pre></td></tr></table></figure><p>从运行结果看，总票数 100 张，由 5 个线程并发抢票。正常情况下票数不应为负，但结果出现 -1、 -2 和 -3 ，说明存在线程安全问题。多个线程同时访问和修改票数这一共享资源时，没有进行有效的同步控制，导致数据不一致，出现超卖现象，即没有实现线程互斥来保证操作的原子性 。</p><hr><h2 id="2-临界资源-VS-临界区"><a href="#2-临界资源-VS-临界区" class="headerlink" title="2. 临界资源 VS 临界区"></a>2. 临界资源 VS 临界区</h2><p><strong>临界资源是指多个进程或线程共享的资源</strong>，像共享内存、文件、打印机等硬件设备，还有消息队列、变量、数组等软件资源。当多个进程或线程要访问或修改同一临界资源时，得进行同步，不然就会出现数据损坏或不一致的问题。比如上面代码中的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> tickets = <span class="number">100</span>; <span class="comment">// 多个线程同时抢票，这个变量是“临界资源”</span></span><br></pre></td></tr></table></figure><p>为什么是“临界”的：多个线程同时读写这个变量，就会发生数据竞争，导致错误票号、重复票、甚至崩溃。</p><p><strong>临界区是指访问临界资源的代码段，即进程或线程中访问临界资源的那部分代码。</strong> 为确保并发程序正确运行，要使用同步机制保护临界区，避免多个进程或线程同时进入，造成数据混乱，所以这个区域是 <strong>必须加锁的重点部分</strong>。比如上面代码中的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 临界资源：tickets 是共享变量</span></span><br><span class="line"><span class="keyword">if</span>(tickets &gt; <span class="number">0</span>)                                    <span class="comment">// 票数大于 0 时，买票</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">usleep</span>(<span class="number">1000</span>);                                  <span class="comment">// 模拟票务系统延时</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s 获得 1 张票，剩余 %d 张票\n&quot;</span>, name, tickets);    <span class="comment">// 打印票数信息</span></span><br><span class="line">    tickets--;                                     <span class="comment">// 票数减 1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 上面这段就是临界区（但没有保护它）</span></span><br><span class="line"><span class="comment">// 这种写法在高并发下肯定会乱套，因为多个线程可以 同时进入临界区，造成冲突。</span></span><br></pre></td></tr></table></figure><hr><blockquote><p>所以，临界资源是 <strong>必须保护的变量&#x2F;资源</strong>，临界区是 <strong>保护它的代码范围</strong>，必须用锁机制确保同一时刻只能有一个线程进入临界区，从而保护临界资源的正确性。</p></blockquote><table><thead><tr><th>概念</th><th>说明</th><th>类比（洗手间排队）</th></tr></thead><tbody><tr><td>临界资源</td><td>多个进程或线程共享的资源</td><td>一个洗手间（一个资源，不能同时进两人）</td></tr><tr><td>临界区</td><td>进程或线程中访问临界资源的那部分代码</td><td>进入洗手间的这段操作（占用了这个资源的代码）</td></tr></tbody></table><blockquote><ul><li>如何确定哪些代码是临界区？（答：确定临界区得看代码访问共享资源的情况，像读写全局变量、共享数据结构的代码通常就是）</li><li>临界区越小越好还是越大越好？（答：大多数情况下越小越好，小了能减少竞争&#x2F;锁冲突，提高并发效率，但太小可能把相关操作拆开，增加同步开销）</li><li>STL 容器是线程安全的吗？（答：大多数不是，使用时要保护）</li></ul></blockquote><h2 id="3-互斥量-VS-互斥锁"><a href="#3-互斥量-VS-互斥锁" class="headerlink" title="3. 互斥量 VS 互斥锁"></a>3. 互斥量 VS 互斥锁</h2><blockquote><p><strong>互斥量（mutex）是一个数据结构或变量，代表“锁的实体”；互斥锁（mutex lock）是一个行为，表示“加锁&#x2F;解锁”操作。</strong></p><p>它们关系很紧密，在很多情况下可以看成是一回事，但严格来说也有点小区别。互斥锁是一种概念，用于确保共享资源在某一时刻只能被一个线程访问。而互斥量是实现互斥锁的一种具体技术或数据结构。可以把互斥锁想象成一个抽象的锁的概念，互斥量则是实际的那把锁。</p></blockquote><p><strong>所以，互斥量是互斥锁的一种实现方式，通过它来保证在同一时刻只有一个线程能访问共享资源，就像一把钥匙，同一时间只能有一个线程拿着它去打开资源的 “门”。</strong></p><p>可以简单理解成：</p><table><thead><tr><th>名称</th><th>类比</th><th>含义</th></tr></thead><tbody><tr><td><strong>互斥量</strong></td><td>“门锁本身”</td><td>是一个数据结构&#x2F;变量，用于控制访问</td></tr><tr><td><strong>互斥锁</strong></td><td>“上锁&#x2F;解锁动作”</td><td>是对互斥量的加锁&#x2F;解锁行为</td></tr></tbody></table><blockquote><p>  我们通过“加锁”来 <strong>互斥访问</strong>，做到“一个线程进来了，其他线程就得等”。把多个线程比作“人”，共享资源比作“厕所”，互斥锁就是“门锁”：</p><ul><li>没加锁：几个人同时冲进厕所，尴尬出问题</li><li>加了锁：进一个人锁门，别人必须等他出来再进</li><li>正确加锁解锁 &#x3D; 文明如厕</li></ul></blockquote><hr><h2 id="4-原子操作的底层原理"><a href="#4-原子操作的底层原理" class="headerlink" title="4. 原子操作的底层原理"></a>4. 原子操作的底层原理</h2><blockquote><p><a href="https://www.bilibili.com/video/BV1Sp4y1h7bu/?share_source=copy_web&vd_source=872e5e3ccf44874c39edaf42e30ab0de">（10min 理解）锁、原子操作和 CAS | B 站</a></p><p><strong><a href="https://www.bilibili.com/video/BV14u4y1R7ya/?share_source=copy_web&vd_source=872e5e3ccf44874c39edaf42e30ab0de">CPU 眼里的：Atomic | 原子操作 | B 站（荐）</a></strong></p><p><a href="https://blog.csdn.net/chenlong_cxy/article/details/122657542">Linux 线程安全 | CSDN</a></p><p><a href="https://developer.aliyun.com/article/1419580">C&#x2F;C++原子操作与 atomic CAS 底层实现原理 | 阿里云</a>    <a href="https://blog.csdn.net/paradox_1_0/article/details/103532103">原子操作 . 原理与底层实现 | CSDN</a>    <a href="https://www.sahaj.ai/atomic-operations-explained-from-hardware-to-high-level-code-using-go/">原子操作解释：从硬件到高级代码（使用 Go） | sahaj</a>    <a href="https://www.geeksforgeeks.org/operating-systems/atomic-operations-in-os/">操作系统中的原子操作 | geeksforgeeks</a></p></blockquote><h3 id="1-什么是原子操作？"><a href="#1-什么是原子操作？" class="headerlink" title="1. 什么是原子操作？"></a>1. 什么是原子操作？</h3><p><strong>原子操作</strong> 是指不可分割、不可中断的操作 —— 要么完全执行，要么完全不执行，不存在中间状态。</p><p>核心特征：</p><ul><li>不可分割性：操作过程无法拆分</li><li>不可中断性：执行中不会被线程调度打断</li><li>结果可见性：操作完成后，所有线程立即看到最新结果</li></ul><h3 id="2-为什么普通操作不是原子的？"><a href="#2-为什么普通操作不是原子的？" class="headerlink" title="2. 为什么普通操作不是原子的？"></a>2. 为什么普通操作不是原子的？</h3><p>以 <code>tickets--</code> 为例，看似简单的一行代码，实则分解为三步：</p><ol><li><strong>Load</strong>：从内存读取 <code>tickets</code> 到 CPU 寄存器。</li><li><strong>Update</strong>：寄存器中执行减 1 运算。</li><li><strong>Store</strong>：将结果写回内存。</li></ol><p>对应三条汇编指令：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">movl tickets(%rip), %eax  ; 加载</span><br><span class="line">subl $1, %eax             ; 更新</span><br><span class="line">movl %eax, tickets(%rip)  ; 存储</span><br></pre></td></tr></table></figure><p>多线程环境下，线程可能在这三步之间被切换，导致数据混乱。比如：</p><ul><li>线程 1 加载 <code>tickets=1000</code> 后被挂起。</li><li>线程 2 连续减 100 次，使 <code>tickets=900</code>。</li><li>线程 1 恢复后，基于旧值 1000 继续操作，最终写回 999。</li><li>结果：实际多减了 100 张票，数据严重不一致。</li></ul><h3 id="3-原子操作的底层实现（硬件-汇编）"><a href="#3-原子操作的底层实现（硬件-汇编）" class="headerlink" title="3. 原子操作的底层实现（硬件 + 汇编）"></a>3. 原子操作的底层实现（硬件 + 汇编）</h3><p>原子操作的核心是 <strong>硬件支持的单条汇编指令</strong>，配合 CPU 机制保证不可分割性：</p><ol><li><p><strong>特殊原子指令</strong></p><p>CPU 提供原子指令（如 <code>xchg</code> 交换指令），单条指令完成 “读取 - 修改 - 写回” 全流程，例如：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lock dec dword ptr [tickets]  ; 原子自减指令</span><br></pre></td></tr></table></figure></li><li><p><strong>硬件级保障</strong></p><ul><li><p><strong>总线锁定</strong>：执行原子指令时，CPU 锁定系统总线，阻止其他核心访问内存。</p></li><li><p><strong>缓存一致性</strong>：通过 MESI 协议，在多核环境下保证数据同步。</p></li><li><p><strong>指令不可中断</strong>：单条汇编指令执行期间，不会被任何调度机制打断。</p></li></ul></li></ol><blockquote><p>  [!IMPORTANT]</p><p>  <span style="color:#FF0000;"><strong>所以：原子操作的核心是由硬件支持的单条汇编指令，配合总线或缓存锁定机制，确保 “读取 - 修改 - 写回” 全流程不可分割、不被中断，这正是解决多线程数据竞争的底层方案 —— 因为多线程数据竞争的根源在于操作的非原子性，比如高级语言中看似简单的<code>++</code>&#x2F;<code>--</code>语句，实际会被拆分为多条汇编指令，执行过程中可能因线程切换导致数据混乱；而互斥锁等同步机制底层依赖原子指令实现，高级语言的原子类则是对这些底层机制的封装。</strong></span></p></blockquote><hr><h2 id="5-函数调用"><a href="#5-函数调用" class="headerlink" title="5. 函数调用"></a>5. 函数调用</h2><h3 id="1-pthread-mutex-init-——-初始化"><a href="#1-pthread-mutex-init-——-初始化" class="headerlink" title="1. pthread_mutex_init —— 初始化"></a>1. <code>pthread_mutex_init</code> —— 初始化</h3><h4 id="1-功能"><a href="#1-功能" class="headerlink" title="1. 功能"></a>1. 功能</h4><p><strong>初始化一个静态或动态定义的互斥量</strong>（<code>pthread_mutex_t</code>），使其可以用于后续加锁和解锁操作。</p><h4 id="2-函数原型"><a href="#2-函数原型" class="headerlink" title="2. 函数原型"></a>2. 函数原型</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutex_init</span><span class="params">(<span class="type">pthread_mutex_t</span>* mutex, <span class="type">const</span> <span class="type">pthread_mutexattr_t</span>* attr)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="3-参数详解"><a href="#3-参数详解" class="headerlink" title="3. 参数详解"></a>3. 参数详解</h4><ul><li><strong><code>pthread_mutex_t* mutex</code>：</strong> 指向互斥量的指针（锁实体）。</li><li><strong><code>const pthread_mutexattr_t* attr</code>：</strong><ul><li><code>NULL/nullptr</code>：使用默认属性。</li><li>非 NULL：指向 <code>pthread_mutexattr_t</code> 结构，用于设置自定义属性。</li></ul></li></ul><blockquote><table><thead><tr><th>初始化方式</th><th>宏&#x2F;函数名</th><th>使用场景</th><th>是否传入属性</th></tr></thead><tbody><tr><td><strong>静态初始化</strong></td><td><code>PTHREAD_MUTEX_INITIALIZER</code></td><td>定义互斥量时立即初始化（常量宏）</td><td>不支持</td></tr><tr><td><strong>动态初始化</strong></td><td><code>pthread_mutex_init()</code></td><td>运行时初始化，可定制属性</td><td>支持</td></tr></tbody></table><p><strong>方式一：动态初始化（运行时）</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line">&gt;<span class="built_in">pthread_mutex_init</span>(&amp;mutex, <span class="literal">NULL</span>);  <span class="comment">// NULL 表示默认属性</span></span><br></pre></td></tr></table></figure><p><strong>方式二：静态初始化（编译时）</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 全局互斥锁 - 提前装好</span></span><br><span class="line">&gt;<span class="type">pthread_mutex_t</span> ticket_mutex = PTHREAD_MUTEX_INITIALIZER;<span class="comment">// 仅适用于默认属性</span></span><br><span class="line">&gt;<span class="type">int</span> tickets = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">&gt;<span class="function"><span class="type">void</span>* <span class="title">sell_ticket</span><span class="params">(<span class="type">void</span>* arg)</span></span></span><br><span class="line"><span class="function">&gt;</span>&#123;</span><br><span class="line">   <span class="built_in">pthread_mutex_lock</span>(&amp;ticket_mutex);</span><br><span class="line">   <span class="keyword">if</span> (tickets &gt; <span class="number">0</span>)</span><br><span class="line">   &#123;</span><br><span class="line">       tickets--;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">pthread_mutex_unlock</span>(&amp;ticket_mutex);</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>注意：不能对已初始化的互斥锁再次调用 <code>pthread_mutex_init</code>，否则会导致未定义行为。 这就像：已经装好了一把锁，现在又强行往同一个锁孔里塞第二把锁 —— 结果可能是锁坏了，门打不开了！ </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="type">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line">&gt;<span class="comment">// ❌ 错误：不能对已初始化的锁再次 init</span></span><br><span class="line">&gt;<span class="built_in">pthread_mutex_init</span>(&amp;mutex, <span class="literal">NULL</span>);  <span class="comment">// 未定义行为！</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>特性</th><th>动态初始化</th><th>静态初始化</th></tr></thead><tbody><tr><td>初始化时机</td><td>运行时</td><td>编译时</td></tr><tr><td>语法</td><td><code>pthread_mutex_init()</code></td><td><code>= PTHREAD_MUTEX_INITIALIZER</code></td></tr><tr><td>是否需要销毁</td><td><strong>必须</strong> <code>pthread_mutex_destroy</code></td><td>不需要（但也可以 destroy）</td></tr><tr><td>适用变量</td><td>任何（包括局部、动态分配）</td><td>全局、静态</td></tr><tr><td>灵活性</td><td>高（可设置属性）</td><td>低（只能默认属性）</td></tr><tr><td>安全性</td><td>需小心避免重复 init</td><td>高（不会重复初始化）</td></tr></tbody></table></blockquote><h4 id="4-返回值"><a href="#4-返回值" class="headerlink" title="4. 返回值"></a>4. 返回值</h4><ul><li><strong>0：</strong> 初始化成功。</li><li><strong>非 0：</strong> 初始化失败（返回错误码）。</li></ul><h4 id="5-代码示例"><a href="#5-代码示例" class="headerlink" title="5. 代码示例"></a>5. 代码示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">pthread_mutex_t</span> lock;                         <span class="comment">// 声明互斥量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">pthread_mutex_init</span>(&amp;lock, <span class="literal">nullptr</span>) != <span class="number">0</span>)  <span class="comment">// 初始化互斥量</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;mutex init failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_mutex_destroy</span>(&amp;lock);                 <span class="comment">// 使用完后销毁互斥量</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="2-pthread-mutex-destroy-——-删除-销毁"><a href="#2-pthread-mutex-destroy-——-删除-销毁" class="headerlink" title="2. pthread_mutex_destroy —— 删除&#x2F;销毁"></a>2. <code>pthread_mutex_destroy</code> —— 删除&#x2F;销毁</h3><h4 id="1-功能-1"><a href="#1-功能-1" class="headerlink" title="1. 功能"></a>1. 功能</h4><p><strong>销毁互斥量，释放其占用的资源。注意：只能在没有线程占用锁时销毁！</strong></p><h4 id="2-函数原型-1"><a href="#2-函数原型-1" class="headerlink" title="2. 函数原型"></a>2. 函数原型</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutex_destroy</span><span class="params">(<span class="type">pthread_mutex_t</span>* mutex)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="3-参数详解-1"><a href="#3-参数详解-1" class="headerlink" title="3. 参数详解"></a>3. 参数详解</h4><p><code>mutex</code>：要销毁的互斥量指针。</p><h4 id="4-返回值-1"><a href="#4-返回值-1" class="headerlink" title="4. 返回值"></a>4. 返回值</h4><ul><li><strong>0：</strong> 销毁成功。</li><li><strong>EBUSY：</strong> 互斥量当前被加锁，不能销毁。</li><li><strong>EINVAL：</strong> 互斥量未初始化或非法。</li></ul><hr><h3 id="3-pthread-mutex-lock-——-加锁"><a href="#3-pthread-mutex-lock-——-加锁" class="headerlink" title="3. pthread_mutex_lock —— 加锁"></a>3. <code>pthread_mutex_lock</code> —— 加锁</h3><h4 id="1-功能-2"><a href="#1-功能-2" class="headerlink" title="1. 功能"></a>1. 功能</h4><p><strong>对互斥量加锁</strong>，如果锁已被其他线程持有，则阻塞等待，直到锁可用。</p><h4 id="2-函数原型-2"><a href="#2-函数原型-2" class="headerlink" title="2. 函数原型"></a>2. 函数原型</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutex_lock</span><span class="params">(<span class="type">pthread_mutex_t</span>* mutex)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="3-参数详解-2"><a href="#3-参数详解-2" class="headerlink" title="3. 参数详解"></a>3. 参数详解</h4><p><code>mutex</code>：要加锁的互斥量指针。</p><h4 id="4-返回值-2"><a href="#4-返回值-2" class="headerlink" title="4. 返回值"></a>4. 返回值</h4><ul><li><strong>0：</strong> 加锁成功。</li><li><strong>EINVAL：</strong> 互斥量未初始化或非法。</li><li><strong>EDEADLK：</strong> 当前线程已持有此锁（非递归锁会导致死锁）。</li></ul><hr><h3 id="4-pthread-mutex-unlock-——-解锁"><a href="#4-pthread-mutex-unlock-——-解锁" class="headerlink" title="4. pthread_mutex_unlock —— 解锁"></a>4. <code>pthread_mutex_unlock</code> —— 解锁</h3><h4 id="1-功能-3"><a href="#1-功能-3" class="headerlink" title="1. 功能"></a>1. 功能</h4><p><strong>对互斥量解锁</strong>，释放资源，允许其他线程进入临界区。</p><h4 id="2-函数原型-3"><a href="#2-函数原型-3" class="headerlink" title="2. 函数原型"></a>2. 函数原型</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutex_unlock</span><span class="params">(<span class="type">pthread_mutex_t</span>* mutex)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="3-参数详解-3"><a href="#3-参数详解-3" class="headerlink" title="3. 参数详解"></a>3. 参数详解</h4><p><code>mutex</code>：要解锁的互斥量指针。</p><h4 id="4-返回值-3"><a href="#4-返回值-3" class="headerlink" title="4. 返回值"></a>4. 返回值</h4><ul><li><strong>0：</strong> 解锁成功。</li><li><strong>EPERM：</strong> 当前线程并未持有该锁，无法解锁。</li></ul><hr><h3 id="5-小结"><a href="#5-小结" class="headerlink" title="5. 小结"></a>5. 小结</h3><table><thead><tr><th>函数名</th><th>作用</th><th>是否阻塞</th><th>常用配合</th></tr></thead><tbody><tr><td><code>pthread_mutex_init</code></td><td>初始化互斥量</td><td>否</td><td>通常在主线程中做一次</td></tr><tr><td><code>pthread_mutex_destroy</code></td><td>销毁互斥量</td><td>否</td><td>在线程退出或程序结束时销毁</td></tr><tr><td><code>pthread_mutex_lock</code></td><td>加锁（进入临界区）</td><td>是</td><td>如果已加锁，当前线程会阻塞等待</td></tr><tr><td><code>pthread_mutex_unlock</code></td><td>解锁（退出临界区）</td><td>否</td><td>必须由加锁线程来解锁</td></tr></tbody></table><h3 id="6-代码示例"><a href="#6-代码示例" class="headerlink" title="6. 代码示例"></a>6. 代码示例</h3><p>makefile 的小知识：</p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250728231930911.png" alt="PixPin_2025-07-28_23-19-15"></p><h4 id="1-静态互斥锁"><a href="#1-静态互斥锁" class="headerlink" title="1. 静态互斥锁"></a>1. 静态互斥锁</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NUM 5                                              <span class="comment">// 定义线程数量</span></span></span><br><span class="line"><span class="type">int</span> tickets = <span class="number">10000</span>;                                       <span class="comment">// 全局共享变量：票数（多个线程将同时访问这个变量）</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> ticket_mutex = PTHREAD_MUTEX_INITIALIZER;  <span class="comment">// 互斥锁（全局）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">thread_data</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">thread_data</span>(<span class="type">int</span> number)                                <span class="comment">// 构造函数：根据线程编号初始化线程名称</span></span><br><span class="line">    &#123;</span><br><span class="line">        thread_name = <span class="string">&quot;线程&quot;</span> + <span class="built_in">to_string</span>(number);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string thread_name;                                    <span class="comment">// 线程名称</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">getticket</span><span class="params">(<span class="type">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    thread_data* data = <span class="built_in">static_cast</span>&lt;thread_data*&gt;(arg);    <span class="comment">// 将传入的参数转换为 threadData 类型指针</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* name = data-&gt;thread_name.<span class="built_in">c_str</span>();          <span class="comment">// 获取线程名称</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)                                            <span class="comment">// 无限循环买票，竞态条件发生在这里！</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;ticket_mutex);                 <span class="comment">// 加锁，进入临界区</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(tickets &gt; <span class="number">0</span>)                                    <span class="comment">// 票数大于 0 时，买票</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">usleep</span>(<span class="number">1000</span>);                                  <span class="comment">// 模拟票务系统延时</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s 获得 1 张票，剩余 %d 张票\n&quot;</span>, name, tickets);    <span class="comment">// 打印票数信息</span></span><br><span class="line">            tickets--;                                     <span class="comment">// 票数减 1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>                                               <span class="comment">// 票数不足时，跳出循环</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">pthread_mutex_unlock</span>(&amp;ticket_mutex);           <span class="comment">// 解锁，防止死锁</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;ticket_mutex);               <span class="comment">// 解锁，退出临界区</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; data-&gt;thread_name &lt;&lt; <span class="string">&quot;执行结束！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">pthread_t</span>&gt; tids;                                <span class="comment">// 存储线程 ID 的向量容器</span></span><br><span class="line">    vector&lt;thread_data*&gt; thread_datas;                     <span class="comment">// 存储线程数据的向量容器</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;多线程买票演示程序&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;总票数: &quot;</span> &lt;&lt; tickets &lt;&lt; <span class="string">&quot; 张&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;创建 &quot;</span> &lt;&lt; NUM &lt;&lt; <span class="string">&quot; 个线程同时买票...&quot;</span> &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">pthread_t</span> tid;                                      <span class="comment">// 线程 ID 变量</span></span><br><span class="line">        thread_data* data = <span class="keyword">new</span> <span class="built_in">thread_data</span>(i);             <span class="comment">// 为每个线程创建独立的数据对象</span></span><br><span class="line">        thread_datas.<span class="built_in">push_back</span>(data);                       <span class="comment">// 保存数据对象指针</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">pthread_create</span>(&amp;tid, <span class="literal">nullptr</span>, getticket, data);     <span class="comment">// 创建线程，传入参数为线程数据对象指针</span></span><br><span class="line">        tids.<span class="built_in">push_back</span>(tid);                                <span class="comment">// 保存线程 ID</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;所有线程创建完成，开始并发买票...&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_join</span>(tids[i], <span class="literal">nullptr</span>);                     <span class="comment">// 等待第 i 个线程执行完毕</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> data : thread_datas)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> data;                                        <span class="comment">// 释放每个线程的数据对象</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-动态互斥锁"><a href="#2-动态互斥锁" class="headerlink" title="2. 动态互斥锁"></a>2. 动态互斥锁</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NUM 5                                              <span class="comment">// 定义线程数量</span></span></span><br><span class="line"><span class="type">int</span> tickets = <span class="number">10000</span>;                                       <span class="comment">// 全局共享变量：票数</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> ticket_mutex;                              <span class="comment">// 动态互斥锁（全局）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">thread_data</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">thread_data</span>(<span class="type">int</span> number)                                <span class="comment">// 构造函数</span></span><br><span class="line">    &#123;</span><br><span class="line">        thread_name = <span class="string">&quot;线程&quot;</span> + <span class="built_in">to_string</span>(number);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string thread_name;                                    <span class="comment">// 线程名称</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">getticket</span><span class="params">(<span class="type">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    thread_data* data = <span class="built_in">static_cast</span>&lt;thread_data*&gt;(arg);</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* name = data-&gt;thread_name.<span class="built_in">c_str</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;ticket_mutex);                 <span class="comment">// 加锁</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(tickets &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">usleep</span>(<span class="number">1000</span>);                                  <span class="comment">// 模拟延时</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 为了减少输出量，只显示关键信息</span></span><br><span class="line">            <span class="keyword">if</span>(tickets % <span class="number">1000</span> == <span class="number">0</span> || tickets &lt;= <span class="number">10</span>)       <span class="comment">// 每 1000 张票或最后 10 张票时显示</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%s 获得 1 张票，剩余 %d 张票\n&quot;</span>, name, tickets);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            tickets--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">pthread_mutex_unlock</span>(&amp;ticket_mutex);           <span class="comment">// 解锁防止死锁</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;ticket_mutex);               <span class="comment">// 解锁</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; data-&gt;thread_name &lt;&lt; <span class="string">&quot;执行结束！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化动态互斥锁（不使用属性）</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">pthread_mutex_init</span>(&amp;ticket_mutex, <span class="literal">nullptr</span>) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;互斥锁初始化失败！&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">pthread_t</span>&gt; tids;</span><br><span class="line">    vector&lt;thread_data*&gt; thread_datas;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;多线程买票演示程序&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;总票数: &quot;</span> &lt;&lt; tickets &lt;&lt; <span class="string">&quot; 张&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;创建 &quot;</span> &lt;&lt; NUM &lt;&lt; <span class="string">&quot; 个线程同时买票...&quot;</span> &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">pthread_t</span> tid;</span><br><span class="line">        thread_data* data = <span class="keyword">new</span> <span class="built_in">thread_data</span>(i);</span><br><span class="line">        thread_datas.<span class="built_in">push_back</span>(data);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">pthread_create</span>(&amp;tid, <span class="literal">nullptr</span>, getticket, data) != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cerr &lt;&lt; <span class="string">&quot;线程创建失败：&quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">delete</span> data;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        tids.<span class="built_in">push_back</span>(tid);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;所有线程创建完成，开始并发买票...&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待所有线程执行完毕</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; tids.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">pthread_join</span>(tids[i], <span class="literal">nullptr</span>) != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cerr &lt;&lt; <span class="string">&quot;等待线程 &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; 失败！&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n最终剩余票数: &quot;</span> &lt;&lt; tickets &lt;&lt; <span class="string">&quot; 张&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;买票结束！&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放线程数据内存</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> data : thread_datas)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁互斥锁</span></span><br><span class="line">    <span class="built_in">pthread_mutex_destroy</span>(&amp;ticket_mutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>  [!NOTE]</p><p>  这两个代码的数据量比较大是为了更好的观察多线程并发抢票的效果，如果数据量小，那么大概率只能观察到：</p>  <figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">线程0 获得 1 张票，剩余 10000 张票</span><br><span class="line">线程0 获得 1 张票，剩余 9999 张票</span><br><span class="line">线程0 获得 1 张票，剩余 9998 张票</span><br><span class="line">线程0 获得 1 张票，剩余 9997 张票</span><br><span class="line">线程0 获得 1 张票，剩余 9996 张票</span><br><span class="line">线程0 获得 1 张票，剩余 9995 张票</span><br><span class="line">……</span><br></pre></td></tr></table></figure><p>  发现好像只有一个线程在工作，这个的主要的原因是 CPU 太快，导致还没执行到下一个线程就把代码跑完了，但是由于数据量太大，打印数据太多，shell 中和这里又不方便展示，可以重定向到一个文件中进行观察，下面是运行结果的部分展示：</p><p>  <img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250730002516469.png" alt="image-20250730002516300"></p></blockquote><hr><h2 id="6-深入理解锁"><a href="#6-深入理解锁" class="headerlink" title="6. 深入理解锁"></a>6. 深入理解锁</h2><blockquote><ul><li><strong>锁是为了保证临界区串行化执行，解决数据竞争问题。</strong></li><li><strong>核心：用原子指令修改“锁变量”来控制资源的独占访问。</strong></li><li><strong>加锁与解锁要成对、尽量小范围、尽快完成，避免性能问题和死锁。</strong></li></ul></blockquote><h3 id="1-锁的本质与核心原则"><a href="#1-锁的本质与核心原则" class="headerlink" title="1. 锁的本质与核心原则"></a>1. 锁的本质与核心原则</h3><h4 id="1-本质：用时间换安全"><a href="#1-本质：用时间换安全" class="headerlink" title="1. 本质：用时间换安全"></a>1. 本质：用时间换安全</h4><ul><li>多线程访问共享资源时，会出现 <strong>数据竞争</strong>。</li><li>锁通过 <strong>让线程串行化</strong> 访问临界区代码，避免数据不一致。</li><li>换句话说：<strong>牺牲部分性能（等待）换取正确性</strong>。</li></ul><h4 id="2-原则：越小越好（大多数情况）-原子性"><a href="#2-原则：越小越好（大多数情况）-原子性" class="headerlink" title="2. 原则：越小越好（大多数情况） + 原子性"></a>2. 原则：越小越好（大多数情况） + 原子性</h4><ol><li><strong>尽量减少临界区范围</strong><ul><li>临界区代码执行越多，锁持有时间越长，线程阻塞越多，性能越差。</li><li>应该只保护 <strong>真正会引发数据竞争的代码</strong>，不要多写一行。</li></ul></li><li><strong>加锁&#x2F;解锁必须是原子操作</strong><ul><li>锁本身的操作必须不可被打断，否则会导致多个线程同时认为自己获取了锁 → 失效。</li></ul></li></ol><blockquote><p>  比喻：多个线程想上厕所（共享资源），锁就是门锁：</p><ul><li>门锁加锁和开锁的动作必须瞬间完成，不能“半锁半开”。</li><li>厕所里的时间越短，大家等的时间越少。</li></ul></blockquote><h3 id="2-互斥锁的特性与规则"><a href="#2-互斥锁的特性与规则" class="headerlink" title="2. 互斥锁的特性与规则"></a>2. 互斥锁的特性与规则</h3><h4 id="1-特性"><a href="#1-特性" class="headerlink" title="1. 特性"></a>1. 特性</h4><ol><li><strong>原子性</strong>：锁的获取和释放操作本身是原子的，保证“要么成功获取，要么失败重试”，不会出现“多个线程同时获得锁”。</li><li><strong>独占性（互斥性）</strong>：同一时刻，最多一个线程能持有锁。其他线程必须等待。</li><li><strong>非重入性（默认特性）</strong>：<ul><li>一个线程如果已经加锁，再次调用 <code>pthread_mutex_lock</code> 会造成 <strong>死锁</strong>，因为自己在等待自己释放。</li><li>如果需要支持重入，必须使用 <strong>递归锁</strong>（<code>PTHREAD_MUTEX_RECURSIVE</code>）。</li></ul></li></ol><h4 id="2-使用规则"><a href="#2-使用规则" class="headerlink" title="2. 使用规则"></a>2. 使用规则</h4><ol><li><strong>外部线程必须排队等待</strong>：没抢到锁的线程，进入阻塞或自旋，等待持有锁的线程释放。</li><li><strong>释放锁要公平（排队）</strong><ul><li>等待队列中的线程应有公平性，避免某个线程永远抢不到锁。</li><li>部分实现还要考虑 <strong>优先级反转</strong> 问题（低优先级线程持锁，阻塞高优先级线程）。</li></ul></li><li><strong>加锁与解锁要成对出现</strong><ul><li>忘记解锁 → 死锁；</li><li>多次解锁 → 未定义行为。</li></ul></li></ol><hr><h3 id="3-常见锁的概念"><a href="#3-常见锁的概念" class="headerlink" title="3. 常见锁的概念"></a>3. 常见锁的概念</h3><blockquote><p><a href="https://www.bilibili.com/video/BV1x1KuzNE9z/?share_source=copy_web&vd_source=872e5e3ccf44874c39edaf42e30ab0de">【死锁算法】校园死锁连环案——蹲坑之争 | B 站</a></p></blockquote><h4 id="1-死锁的定义"><a href="#1-死锁的定义" class="headerlink" title="1. 死锁的定义"></a>1. 死锁的定义</h4><p>死锁是指两个或多个线程（或进程）因 <strong>互相持有资源并等待对方释放</strong>，导致程序无法继续执行的情况（僵持状态）。这就好比两个人过独木桥，面对面走到中间，谁都不肯退回去，结果谁也走不了啦。 </p><ul><li><p>单进程场景也可能发生（如频繁申请单锁但不释放）。  </p></li><li><p>多线程中典型表现为：线程 A 持有锁 1 申请锁 2，线程 B 持有锁 2 申请锁 1，形成循环等待。  </p></li><li><p>特殊场景：单进程&#x2F;单线程如果频繁申请资源而不释放，也可能出现类似死锁的“永久阻塞”现象。</p></li></ul><h4 id="2-死锁四个必要条件"><a href="#2-死锁四个必要条件" class="headerlink" title="2. 死锁四个必要条件"></a>2. 死锁四个必要条件</h4><p>产生死锁 <strong>必须同时满足</strong> 以下四个条件，但满足全部条件 <strong>不一定必然发生死锁</strong>（需具体场景触发）。<strong>破坏任意一个条件即可避免死锁</strong>。</p><blockquote><p><strong>注意</strong>：四个条件是死锁的 <strong>充分必要条件</strong>——缺一不可导致死锁，但满足全部仅表示“可能”死锁（需资源竞争实际发生）。</p></blockquote><table><thead><tr><th>条件</th><th>含义</th><th>说明</th></tr></thead><tbody><tr><td><strong>互斥条件</strong></td><td>一个资源每次只能被一个执行流使用。</td><td>资源本质属性（如锁、I&#x2F;O 设备），无法完全消除，但可通过设计减少互斥场景。</td></tr><tr><td><strong>请求与保持条件</strong></td><td>线程在申请新资源时，不释放已经占有的资源。</td><td>例如：线程持有锁 A 后申请锁 B 失败，仍不释放锁 A。</td></tr><tr><td><strong>不剥夺条件</strong></td><td>资源一旦被占用，不能被强制剥夺，只能主动释放。</td><td>操作系统通常不支持强制剥夺资源（避免数据损坏）。</td></tr><tr><td><strong>循环等待条件</strong></td><td>若干执行流形成头尾相接的循环等待资源链（如 A→B→C→A）。</td><td>是前三个条件的综合结果，最易通过设计规避。</td></tr></tbody></table><h4 id="3-避免死锁的策略"><a href="#3-避免死锁的策略" class="headerlink" title="3. 避免死锁的策略"></a>3. 避免死锁的策略</h4><p>核心思路：<strong>破坏上述四个必要条件之一</strong>，或通过设计优化资源分配。  </p><table><thead><tr><th>策略方向</th><th>具体方法</th><th>说明</th></tr></thead><tbody><tr><td><strong>破坏互斥条件</strong></td><td>重写代码，尽量减少锁的使用或使用无锁数据结构</td><td>实现难度高，代价较大，代码改动多，仅适用于特定场景（如只读资源）。</td></tr><tr><td><strong>破坏请求与保持条件</strong></td><td>使用 <code>trylock</code> 等非阻塞加锁机制，获取失败时释放已占有的锁。</td><td>避免“持有并等待”，需配合重试逻辑，可能增加代码复杂度。</td></tr><tr><td><strong>破坏不剥夺条件</strong></td><td>在申请失败时主动释放已有锁，稍后重新申请，或设计可抢占式资源管理。</td><td>需谨慎处理，避免资源状态不一致。</td></tr><tr><td><strong>破坏循环等待条件</strong></td><td><strong>加锁顺序一致</strong>：所有线程按固定顺序申请锁，如全局定义锁 ID，从小到大，避免混乱。<br><strong>资源一次性分配</strong>：线程启动时申请所有所需资源，避免分步申请。<br><strong>尽快释放锁</strong>：尽快释放锁，减少竞争时间&#x2F;窗口。</td><td><strong>最常用且有效</strong>，尤其“加锁顺序一致”是工程实践首选。</td></tr></tbody></table><h4 id="4-避免死锁的算法（了解即可）"><a href="#4-避免死锁的算法（了解即可）" class="headerlink" title="4. 避免死锁的算法（了解即可）"></a>4. 避免死锁的算法（了解即可）</h4><ul><li><strong>死锁检测算法</strong>：定期检查系统里有没有死锁。它通过资源分配图这些方式，看进程和资源之间的关系，要是有循环等待且资源都被占着，那就可能死锁了。</li><li><strong>银行家算法</strong>：像银行放贷，查放贷后是否安全，安全则贷，否则不贷，避免死锁。</li></ul><blockquote><p><strong>说明</strong>：算法适用于理论场景，实际开发中常通过设计规避，而非依赖复杂算法。</p></blockquote><hr><h3 id="4-同步"><a href="#4-同步" class="headerlink" title="4. 同步"></a>4. 同步</h3><h4 id="1-同步的定义与必要性"><a href="#1-同步的定义与必要性" class="headerlink" title="1. 同步的定义与必要性"></a>1. 同步的定义与必要性</h4><p><strong>同步定义</strong>：在 <strong>保证数据安全</strong> 的前提下，协调多线程 <strong>按特定顺序访问共享资源</strong>，确保数据安全和执行逻辑正确，避免竞争条件。<strong>与死锁的关系：同步是解决资源竞争的手段，而死锁是同步使用不当的结果之一。</strong></p><ol><li><p>单纯依赖 <strong>互斥锁</strong> 可能导致问题：  </p><ul><li><p><strong>线程饥饿</strong>：强线程频繁抢锁，弱线程可能长期无法执行。</p></li><li><p><strong>死锁风险</strong>：若锁申请顺序混乱或未释放，易触发死锁条件（尤其请求与保持、循环等待）。</p></li></ul></li><li><p><strong>同步是避免死锁的关键手段</strong>：通过有序排队机制，消除“请求与保持”和“循环等待”条件。</p></li></ol><h4 id="2-同步的核心机制：条件变量"><a href="#2-同步的核心机制：条件变量" class="headerlink" title="2. 同步的核心机制：条件变量"></a>2. 同步的核心机制：条件变量</h4><blockquote><p><a href="https://www.bilibili.com/video/BV1sDrGYQEKP/?share_source=copy_web&vd_source=872e5e3ccf44874c39edaf42e30ab0de">一起来学 C++  47. 条件变量 | B 站</a></p><p><a href="https://punmy.cn/2018/06/07/%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%EF%BC%88Condition%20Variables%EF%BC%89.html">条件变量 | Punmy</a></p></blockquote><h5 id="1-什么是条件变量？"><a href="#1-什么是条件变量？" class="headerlink" title="1. 什么是条件变量？"></a>1. 什么是条件变量？</h5><p><strong>条件变量</strong> 是一种 <strong>等待队列 + 通知机制</strong>，用来协调线程按顺序执行，当资源不可用时，线程可进入条件变量队列等待（<strong>主动排队等待</strong>），被其他线程唤醒后再去竞争锁。</p><ol><li><strong>核心功能</strong>：提供 <strong>等待队列</strong> 和 <strong>通知机制</strong>，使线程在资源不可用时 <strong>主动排队等待</strong>，而非忙等或阻塞。  </li><li><strong>工作流程</strong>：<ol><li>线程尝试访问资源 → 失败 → <strong>进入条件变量等待队列</strong>（自动释放锁）。  </li><li>资源可用时（如其他线程释放资源），<strong>唤醒队列中的一个&#x2F;所有线程</strong> → 唤醒线程重新申请锁。</li></ol></li><li><strong>关键特性</strong>：<ul><li><strong>必须依赖锁使用</strong>：线程排队前需先获得锁，排队时锁自动释放；唤醒后需重新竞争锁。  </li><li><strong>避免“虚假唤醒”</strong>：线程被唤醒后需 <strong>重新检查资源状态</strong>（在加锁后），防止误判。  </li><li><strong>注意：</strong> 当线程调用 <code>pthread_cond_wait</code> 进入等待队列时，会自动释放互斥锁，唤醒后自动重新加锁。</li></ul></li></ol><h5 id="2-标准接口（以-POSIX-为例）"><a href="#2-标准接口（以-POSIX-为例）" class="headerlink" title="2. 标准接口（以 POSIX 为例）"></a>2. 标准接口（以 POSIX 为例）</h5><p>下面这些接口和 <code>pthread_mutex_init</code> 系列函数十分相似，共用头文件 <code>&lt;pthread.h&gt;</code>，这里就不详细讲解了，类比使用即可。</p><table><thead><tr><th>接口</th><th>作用</th><th>使用场景</th><th>返回值</th></tr></thead><tbody><tr><td><code>pthread_cond_t</code></td><td>定义条件变量。</td><td>全局声明条件变量。</td><td>类型定义，无返回值</td></tr><tr><td><code>pthread_cond_init(&amp;cond, &amp;attr)</code></td><td>动态初始化条件变量（可指定属性）。</td><td>局部变量或需自定义属性（如跨进程共享）。</td><td>成功返回 0；失败返回错误码。</td></tr><tr><td><code>pthread_cond_wait(&amp;cond, &amp;mutex)</code></td><td>线程进入等待队列，<strong>自动释放 mutex</strong> 并挂起。</td><td>资源不可用时调用（需在锁保护内）。</td><td>成功返回 0；失败返回错误码。</td></tr><tr><td><code>pthread_cond_signal(&amp;cond)</code></td><td>唤醒等待队列中的 <strong>一个</strong> 线程。</td><td>资源可用时通知（如生产者-消费者模型）。</td><td>成功返回 0；失败返回错误码。</td></tr><tr><td><code>pthread_cond_broadcast(&amp;cond)</code></td><td>唤醒等待队列中的 <strong>所有</strong> 线程。</td><td>多线程需同时响应资源变化时使用。</td><td>成功返回 0；失败返回错误码。</td></tr></tbody></table><ul><li><p><code>pthread_cond_wait</code> 的第二个参数 &amp;mutex 说明：需先通过 <code>pthread_mutex_lock</code> 获得该互斥锁；线程进入等待时自动释放锁，允许其他线程操作资源；被唤醒后自动重新获取锁，确保后续操作安全。</p><ul><li><p><code>PTHREAD_COND_INITIALIZER</code>：这是条件变量的 <strong>静态初始化宏</strong>，用于在定义时直接初始化条件变量，简化代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_cond_t</span> cond = PTHREAD_COND_INITIALIZER;<span class="comment">// 静态初始化（无需手动调用 pthread_cond_init）</span></span><br></pre></td></tr></table></figure></li><li><p>等价于动态初始化：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_cond_t</span> cond;</span><br><span class="line"><span class="built_in">pthread_cond_init</span>(&amp;cond, <span class="literal">NULL</span>);  <span class="comment">// 动态初始化，需手动销毁</span></span><br></pre></td></tr></table></figure></li><li><p>示例片段：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_cond_t</span> cond = PTHREAD_COND_INITIALIZER;  <span class="comment">// 静态初始化</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程等待条件</span></span><br><span class="line"><span class="built_in">pthread_mutex_lock</span>(&amp;mutex);          <span class="comment">// 先加锁</span></span><br><span class="line"><span class="built_in">pthread_cond_wait</span>(&amp;cond, &amp;mutex);  <span class="comment">// 等待时释放锁，唤醒后重获锁</span></span><br><span class="line"><span class="comment">// 被唤醒后操作共享资源...</span></span><br><span class="line"><span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);      <span class="comment">// 最终解锁</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h5 id="3-代码实现关键注意事项"><a href="#3-代码实现关键注意事项" class="headerlink" title="3. 代码实现关键注意事项"></a>3. 代码实现关键注意事项</h5><ul><li><strong>参数传递</strong>：创建线程时 <strong>优先使用值传递（拷贝）</strong>，避免多线程共享同一变量导致数据竞争。  </li><li><strong>共享资源保护</strong>：例如：多线程打印到显示器（显示器也是文件，属于共享资源），需加锁保护，否则输出内容会交叉混乱。  </li><li><strong>状态检查逻辑</strong>：判断线程是否等待或唤醒必须放在 <strong>加锁解锁区间内</strong>，保证资源状态判断与操作的原子性。</li></ul><h4 id="3-为什么需要排队？"><a href="#3-为什么需要排队？" class="headerlink" title="3. 为什么需要排队？"></a>3. 为什么需要排队？</h4><ul><li><strong>根本原因</strong>：单纯互斥锁无法解决“线程申请能力不均衡”问题。  </li><li><strong>排队机制的作用</strong>：  <ol><li><strong>防止新线程插队</strong>：确保等待线程按序获取资源，避免强线程持续抢占。  </li><li><strong>提升公平性</strong>：通过队列管理，减少线程饥饿，间接破坏“请求与保持”条件。  </li><li><strong>保证数据安全</strong>：排队过程由操作系统协调，避免用户代码手动管理导致的竞态。</li></ol></li></ul><h4 id="4-小结"><a href="#4-小结" class="headerlink" title="4. 小结"></a>4. 小结</h4><ol><li><strong>死锁是结果，同步是手段</strong>。同步用得不好会死锁，合理使用同步才能保证线程安全。</li><li><strong>避免死锁的方法</strong>：<ul><li>加锁顺序统一。</li><li>锁尽快释放。</li><li>使用 <code>trylock</code>、资源一次性分配等方式减少锁依赖。</li></ul></li><li><strong>条件变量是解决线程公平性和协调顺序的利器</strong>，必须和互斥锁配合使用。</li></ol><h3 id="5-代码示例-1"><a href="#5-代码示例-1" class="headerlink" title="5. 代码示例"></a>5. 代码示例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// uint64_t: 64 位无符号整数类型，用于确保能存储 64 位的线程 ID 或大数值</span></span><br><span class="line"><span class="comment">// uintptr_t: 足够大以容纳指针值的无符号整数类型，用于安全的指针到整数转换</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;                                            <span class="comment">// 临界资源，全局计数器，多个线程共享访问</span></span><br><span class="line"><span class="type">int</span> tid_cnt = <span class="number">5</span>;                                        <span class="comment">// 线程数量</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;      <span class="comment">// 互斥锁，保护临界资源的访问，防止数据竞争</span></span><br><span class="line"><span class="type">pthread_cond_t</span> cond = PTHREAD_COND_INITIALIZER;         <span class="comment">// 条件变量，用于线程间通信，控制线程的等待和唤醒</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">Count</span><span class="params">(<span class="type">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">pthread_detach</span>(<span class="built_in">pthread_self</span>());                     <span class="comment">// 分离线程，这样线程结束时会自动回收资源</span></span><br><span class="line">    <span class="type">uint64_t</span> number = (<span class="type">uint64_t</span>)(<span class="type">uintptr_t</span>)arg;         <span class="comment">// 修复指针到整数的转换警告，两次类型转换确保安全</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;[创建]线程&quot;</span> &lt;&lt; number &lt;&lt; <span class="string">&quot;创建成功！&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 1. 加锁进入临界区</span></span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);                     <span class="comment">// 加锁</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;[等待]线程&quot;</span> &lt;&lt; number &lt;&lt; <span class="string">&quot;获取锁，准备等待信号！&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里隐含了一个判断：&quot;是否收到了主线程的信号？&quot;</span></span><br><span class="line">        <span class="comment">// 如果没有收到信号，临界资源状态就是 &quot;不就绪&quot;，所以线程选择等待</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 等待条件满足</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;[阻塞]线程&quot;</span> &lt;&lt; number &lt;&lt; <span class="string">&quot;调用pthread_cond_wait，即将释放锁并进入等待！&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">pthread_cond_wait</span>(&amp;cond, &amp;mutex);               <span class="comment">// 等待信号（临界资源就绪）</span></span><br><span class="line">        <span class="comment">// pthread_cond_wait 的内部工作原理：</span></span><br><span class="line">        <span class="comment">// a. 释放 mutex 锁（让其他线程可以获取锁）</span></span><br><span class="line">        <span class="comment">// b. 将当前线程加入等待队列并阻塞</span></span><br><span class="line">        <span class="comment">// c. 等待被 pthread_cond_signal 或 pthread_cond_broadcast 唤醒</span></span><br><span class="line">        <span class="comment">// d. 被唤醒后自动重新获取 mutex 锁</span></span><br><span class="line">        <span class="comment">// e. 返回（此时线程重新持有锁）</span></span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;[唤醒]线程&quot;</span> &lt;&lt; number &lt;&lt; <span class="string">&quot;被唤醒并重新获得锁！开始处理任务！&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 被唤醒后执行的代码，此时已经重新获得了锁，可以安全地访问临界资源 cnt</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;[执行]线程&quot;</span> &lt;&lt; number &lt;&lt; <span class="string">&quot;收到信号，执行任务！cnt = &quot;</span> &lt;&lt; cnt++ &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 解锁 - 离开临界区</span></span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;[完成]线程&quot;</span> &lt;&lt; number &lt;&lt; <span class="string">&quot;释放锁，任务完成，重新进入等待循环中！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_exit</span>(<span class="literal">nullptr</span>);                              <span class="comment">// 线程结束，释放资源（显式）</span></span><br><span class="line">    <span class="comment">// return nullptr;                                  // 线程结束，释放资源（隐式）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Demo_cond_init</span><span class="params">()</span>                                   <span class="comment">// 这个函数没有实际意义，只是为了演示条件变量的初始化</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">pthread_cond_t</span> cond1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方式 1: 静态初始化（推荐用于全局变量）</span></span><br><span class="line">    <span class="comment">// pthread_cond_t cond = PTHREAD_COND_INITIALIZER;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方式 2: 动态初始化（推荐用于局部变量）</span></span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">pthread_cond_init</span>(&amp;cond1, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;初始化条件变量失败！&quot;</span> &lt;&lt; <span class="built_in">strerror</span>(result) &lt;&lt; endl;     <span class="comment">// cerr: 标准错误输出流，用于输出错误信息</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_cond_destroy</span>(&amp;cond1);                      <span class="comment">// 使用完后需要销毁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Demo_cond_init</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">uint64_t</span> i = <span class="number">0</span>; i &lt; tid_cnt; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">pthread_t</span> tid;</span><br><span class="line">        <span class="type">int</span> result = <span class="built_in">pthread_create</span>(&amp;tid, <span class="literal">nullptr</span>, Count, (<span class="type">void</span>*)(<span class="type">uintptr_t</span>)i);</span><br><span class="line">        <span class="keyword">if</span>(result != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cerr &lt;&lt; <span class="string">&quot;创建线程失败！&quot;</span> &lt;&lt; <span class="built_in">strerror</span>(result) &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">usleep</span>(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">3</span>);                                           <span class="comment">// 等待所有线程进入等待状态</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;主线程控制开始！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;控制规则：每1秒唤醒一个线程，每3秒唤醒全部线程！&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// while(count &lt; 自定义 value)                        // 限制循环次数，避免无限运行</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">        count++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (count % <span class="number">3</span> == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 使用 pthread_cond_broadcast 唤醒所有等待的线程</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;[广播]唤醒所有线程！&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="built_in">pthread_cond_broadcast</span>(&amp;cond);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 使用 pthread_cond_signal 唤醒一个等待的线程</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;[单播]唤醒一个线程！&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="built_in">pthread_cond_signal</span>(&amp;cond);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;信号已经发出！count = &quot;</span> &lt;&lt; count &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 显示当前计数器值</span></span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;当前计数值：&quot;</span> &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;主线程结束！&quot;</span> &lt;&lt; endl &lt;&lt; <span class="string">&quot;最终计数值：&quot;</span> &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注：上面代码模拟的是一个“多个工作线程等待任务信号，由主线程定时唤醒执行”的场景，用来演示条件变量如何控制线程的等待与唤醒、线程同步、临界资源保护、条件变量解耦协作等内容。</strong></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>040 线程控制</title>
      <link href="/posts/21804.html"/>
      <url>/posts/21804.html</url>
      
        <content type="html"><![CDATA[<h1 id="线程控制"><a href="#线程控制" class="headerlink" title="线程控制"></a>线程控制</h1><h2 id="1-POSIX-线程库"><a href="#1-POSIX-线程库" class="headerlink" title="1. POSIX 线程库"></a>1. POSIX 线程库</h2><h3 id="1-什么是-POSIX-线程库（pthread）"><a href="#1-什么是-POSIX-线程库（pthread）" class="headerlink" title="1. 什么是 POSIX 线程库（pthread）"></a>1. 什么是 POSIX 线程库（pthread）</h3><p>POSIX（Portable Operating System Interface）线程库，又称（简称） pthread（POSIX Threads），是 Unix 系统下的标准化多线程编程接口（IEEE POSIX 标准（IEEE 1003.1c）定义的线程接口）。它提供了一组函数，用于在同一进程内创建、管理和同步多个线程，实现并发和并行处理。</p><p><strong>pthread 线程库是应用层的原生线程库： 应用层指的是这个线程库并不是系统接口直接提供的，而是由第三方帮我们提供的。大部分 Linux 系统都会默认带上该线程库（原生的）。与线程有关的函数构成了一个完整的系列，绝大多数函数的名字都是以 <code>pthread_</code> 打头的。要使用这些函数库，要通过引入头文件 <code>&lt;pthreaad.h&gt;</code>，链接这些线程函数库时，要使用编译器命令的 <code>-lpthread</code> 选项。</strong></p><h3 id="2-特点"><a href="#2-特点" class="headerlink" title="2. 特点"></a>2. 特点</h3><ol><li>与操作系统紧密集成，性能开销小。</li><li>接口统一，可移植性好。</li><li>支持线程同步（互斥锁、条件变量）、线程属性设置等丰富功能。</li><li>线程共享同一进程的内存空间（代码段、堆、全局变量等）。</li><li>线程间通信更高效（直接访问共享数据）。</li><li>适用于需要高并发的场景（如服务器、实时处理）。</li></ol><hr><h3 id="3-pthread-t"><a href="#3-pthread-t" class="headerlink" title="3. pthread_t"></a>3. pthread_t</h3><h4 id="1-功能"><a href="#1-功能" class="headerlink" title="1. 功能"></a>1. 功能</h4><p><code>pthread_t</code> 是 pthread 库定义的线程标识类型，类似于进程中的 PID。每个创建的线程都会分配一个唯一的 <code>pthread_t</code> 值，用来引用和管理该线程。</p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250723152545138.png" alt="image-20250723152544973"></p><h4 id="2-本质"><a href="#2-本质" class="headerlink" title="2. 本质"></a>2. 本质</h4><p>Linux 下，<code>pthread_t</code> 通常以整数或指针的形式存在（与 glibc 实现有关），我们只需将其当作“黑盒”标识符，配合其他 pthread 函数即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span>      <span class="comment">// 声明 pthread_t 类型</span></span></span><br><span class="line"><span class="type">pthread_t</span> tid;            <span class="comment">// 声明一个线程标识符，创建后，tid 中存储的是新线程的 ID</span></span><br></pre></td></tr></table></figure><h3 id="4-pthread-create-——-创建新线程"><a href="#4-pthread-create-——-创建新线程" class="headerlink" title="4. pthread_create —— 创建新线程"></a>4. pthread_create —— 创建新线程</h3><h4 id="1-功能-1"><a href="#1-功能-1" class="headerlink" title="1. 功能"></a>1. 功能</h4><p>创建一个新线程，并让它去执行用户定义的函数。</p><h4 id="2-函数原型"><a href="#2-函数原型" class="headerlink" title="2. 函数原型"></a>2. 函数原型</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_create</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">pthread_t</span> *thread,                  <span class="comment">// 输出参数：返回新线程 ID（pthread_t类型）</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> <span class="type">pthread_attr_t</span> *attr,         <span class="comment">// 线程属性，NULL 表示默认</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">void</span> *(*start_routine)(<span class="type">void</span> *),     <span class="comment">// 线程入口函数，即线程启动后要执行的函数（必须接受void*参数并返回void*）</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">void</span> *arg                           <span class="comment">// 传给入口函数 start_routine 的参数，即线程（要执行）函数的参数</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="3-参数详解"><a href="#3-参数详解" class="headerlink" title="3. 参数详解"></a>3. 参数详解</h4><ul><li><code>thread</code>：指向 <code>pthread_t</code> 的指针，函数返回后通过它获取新线程的 ID；</li><li><code>attr</code>：线程属性指针，可设置线程栈大小、分离状态等，<strong>通常传 <code>NULL</code>&#x2F;<code>nullptr</code></strong>；</li><li><code>start_routine</code>：线程函数指针，必须形如 <code>void* func(void*)</code>；</li><li><code>arg</code>：传给线程函数的单个参数，可是任意指针（如结构体、基本类型地址），需要在函数内强转回原类型。</li></ul><h4 id="4-返回值"><a href="#4-返回值" class="headerlink" title="4. 返回值"></a>4. 返回值</h4><p>POSIX 线程（pthreads）函数在出错时 <strong>不设置全局 errno</strong> ，而是 <strong>直接通过返回值返回错误码</strong> （成功为 0，失败为非 0 值）。这与传统系统调用（如 open、read）不同，传统调用通常返回-1 并设置 errno。pthreads 这样做是为了避免多线程环境下对全局 errno 的竞争，提升性能和可移植性。尽管每个线程有独立的 errno 以兼容其他使用它的代码，但 <strong>建议始终检查 pthreads 函数的返回值来判断错误</strong> ，而不是依赖 errno。</p><ul><li>返回 <code>0</code>：创建成功；</li><li>返回非 <code>0</code>：错误码，表示创建失败（如资源不足、权限问题等）。</li></ul><h4 id="5-代码示例"><a href="#5-代码示例" class="headerlink" title="5. 代码示例"></a>5. 代码示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">func</span><span class="params">(<span class="type">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span>* str = (<span class="type">char</span>*)arg;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;tid, <span class="literal">nullptr</span>, func, (<span class="type">void</span>*)<span class="string">&quot;我是子线程，ID是：123456&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;我是主线程!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>编译（-lpthread）：</strong></p><ol><li><p><strong>编译命令</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -o pthread_create pthread_create.cc -lpthread</span><br></pre></td></tr></table></figure><p><code>-lpthread</code>：链接 pthread 库，必须加在源文件或对象文件之后。</p></li><li><p>makefile 文件：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">pthread_create:pthread_create.cc</span></span><br><span class="line">g++ -o <span class="variable">$@</span> <span class="variable">$^</span> -std=c++11 -lpthread</span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm -f pthread_create</span><br></pre></td></tr></table></figure></li></ol><p><strong>运行结果示例：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250722153957144.png" alt="image-20250722153949184"></p><blockquote><p><strong>原子性</strong> 指一个操作要么 <strong>完全执行成功</strong> ，要么 <strong>完全没执行</strong> ，在执行过程中 <strong>不会被中断或分割</strong> 。<strong>原子性 &#x3D; 不可分割性</strong>，一个操作如果是原子的，就 <strong>不会被其他线程或中断打断</strong> ，外界看起来就像“瞬间完成”。</p></blockquote><h4 id="6-线程监控与查看"><a href="#6-线程监控与查看" class="headerlink" title="6. 线程监控与查看"></a>6. 线程监控与查看</h4><ol><li><p><strong>查看进程和线程</strong></p><ul><li><p><code>ps -AL</code>：列出所有线程（Lightweight Process，LWP）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -AL | grep pthread_create<span class="comment"># 输出中，LWP 列就是线程 ID</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>查看可执行文件依赖</strong></p><ul><li><p><code>ldd</code>：列出可执行文件所依赖的共享库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ldd pthread_create<span class="comment"># 可以确认是否已正确链接 libpthread.so</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>结合 top 或 htop</strong></p><ul><li>在 <code>top</code> 中，按 <code>H</code> 可切换到线程视图；</li><li>便于实时监控各线程的 CPU&#x2F;内存占用情况。</li></ul></li></ol><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250722161316776.png" alt="image-20250722161316674"></p><blockquote><p>以下是命令的逐步解析：</p><h5 id="1-ps-axj-head-1-ps-axj-grep-pthread-create-grep-v-grep"><a href="#1-ps-axj-head-1-ps-axj-grep-pthread-create-grep-v-grep" class="headerlink" title="1. ps axj | head -1 &amp; ps axj | grep pthread_create | grep -v grep"></a>1. <code>ps axj | head -1 &amp; ps axj | grep pthread_create | grep -v grep</code></h5><ul><li><strong><code>ps axj</code></strong> :</li><li><code>ps</code> 是 Linux 系统中用于查看进程状态的命令。</li><li><code>-a</code>：显示所有终端上的进程，包括其他用户的进程。</li><li><code>-x</code>：显示没有控制终端的进程。</li><li><code>-j</code>：以长格式显示线程信息，包括线程 ID、进程组 ID、会话 ID 等。</li><li><strong><code>head -1</code></strong>：只取第一行，通常是表头信息。</li><li><strong><code>grep pthread_create</code></strong>：过滤出包含字符串 <code>pthread_create</code> 的行，这些行通常与使用了 <code>pthread_create</code> 函数创建的线程相关。</li><li><strong><code>grep -v grep</code></strong>：排除包含 <code>grep</code> 自身的行，避免干扰。</li></ul><h5 id="2-ps-aL-head-1-ps-aL-grep-pthread-create-grep-v-grep"><a href="#2-ps-aL-head-1-ps-aL-grep-pthread-create-grep-v-grep" class="headerlink" title="2. ps -aL | head -1 &amp; ps -aL | grep pthread_create | grep -v grep"></a>2. <code>ps -aL | head -1 &amp; ps -aL | grep pthread_create | grep -v grep</code></h5><ul><li><code>ps -aL</code>：</li><li><code>-a</code>：显示所有终端上的进程。</li><li><code>-L</code>：显示线程信息，类似于 <code>-j</code>，但格式稍有不同。</li></ul><h5 id="3-ldd-pthread-create"><a href="#3-ldd-pthread-create" class="headerlink" title="3. ldd pthread_create"></a>3. <code>ldd pthread_create</code></h5><ul><li><code>ldd</code>：显示指定可执行文件或共享库所依赖的动态链接库。</li></ul></blockquote><blockquote><p><code>clone()</code> 是 Linux 提供的底层系统调用，用于创建子进程或线程，是 <code>fork()</code> 和 <code>pthread_create()</code> 的核心实现基础之一。相比 <code>fork()</code>，它更灵活，可以通过传入不同的标志位来控制父子进程（或线程）之间是否共享地址空间、文件描述符、信号处理等资源，从而实现“线程”效果。因为使用较复杂（需要手动分配栈空间等），只做了解，不推荐直接使用。<strong>头文件：</strong> <code>&lt;sched.h&gt;</code>，<strong>函数原型：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="function"><span class="type">int</span> <span class="title">clone</span><span class="params">(<span class="type">int</span> (*fn)(<span class="type">void</span> *), <span class="type">void</span> *child_stack, <span class="type">int</span> flags, <span class="type">void</span> *arg, ...)</span></span>;</span><br></pre></td></tr></table></figure></blockquote><h2 id="2-线程的调度"><a href="#2-线程的调度" class="headerlink" title="2. 线程的调度"></a>2. 线程的调度</h2><h3 id="1-线程调度单位到底是谁？"><a href="#1-线程调度单位到底是谁？" class="headerlink" title="1. 线程调度单位到底是谁？"></a>1. 线程调度单位到底是谁？</h3><blockquote><p><strong>“应用层的线程与内核的 LWP 是一一对应的，调度的是 LWP 而非 PID。”在 Linux 中：调度单位是 LWP（轻量级进程），而不是进程本身（PID）。</strong></p></blockquote><p>可以理解为：</p><table><thead><tr><th>概念</th><th>含义</th></tr></thead><tbody><tr><td>应用层线程</td><td>即 <code>pthread_create</code> 创建的线程</td></tr><tr><td>内核 LWP</td><td>每个线程在内核中的调度实体</td></tr><tr><td>PID 与 LWP</td><td>主线程的 LWP ID 与 PID 相等，子线程的 LWP ID 不等于 PID</td></tr><tr><td>调度单位</td><td>Linux 中调度的是每个线程（LWP），不是进程整体</td></tr></tbody></table><h3 id="2-什么是-LWP（Light-Weight-Process）？"><a href="#2-什么是-LWP（Light-Weight-Process）？" class="headerlink" title="2. 什么是 LWP（Light Weight Process）？"></a>2. 什么是 LWP（Light Weight Process）？</h3><p>LWP 是 Linux 内核中的 <strong>最小调度单位</strong>，本质上就是一个“执行上下文”：包括程序计数器、栈、寄存器、调度信息等。每个 LWP 都有自己的 ID，即在 <code>ps -AL</code> 中看到的 <strong>LWP（Thread ID）</strong>。它们共享 <strong>所属进程的虚拟内存空间</strong>、打开的文件、信号处理器等资源。</p><h3 id="3-Linux-中-pthread-与-LWP-的关系？"><a href="#3-Linux-中-pthread-与-LWP-的关系？" class="headerlink" title="3. Linux 中 pthread 与 LWP 的关系？"></a>3. Linux 中 pthread 与 LWP 的关系？</h3><p>在 Linux 上，<strong>每个 pthread 线程 &#x3D; 一个 LWP</strong>。</p><ul><li><code>pthread_create()</code> 创建的每一个线程，都会在内核中映射成一个 LWP；</li><li>所以 Linux 是通过调度多个 LWP 来实现多线程程序并发运行（先描述再组织）。</li></ul><h3 id="4-为什么说-“我们以前接触到的都是单线程进程，PID-和-LWP-相等”？"><a href="#4-为什么说-“我们以前接触到的都是单线程进程，PID-和-LWP-相等”？" class="headerlink" title="4. 为什么说 “我们以前接触到的都是单线程进程，PID 和 LWP 相等”？"></a>4. 为什么说 “我们以前接触到的都是单线程进程，PID 和 LWP 相等”？</h3><p>单线程程序只有一个主线程，所以它只有一个 LWP。而这个 LWP 的 ID（TID）刚好等于进程 ID（PID），<code>getpid() == gettid()</code>（在主线程中成立）。但如果在程序中创建了多个线程（用 pthread），就会发现：</p><ul><li><code>getpid()</code>（获取进程 ID）在每个线程中都一样；</li><li><code>gettid()</code>（获取线程 ID）每个线程都不同；</li><li><code>ps -AL</code> 或 <code>top -H</code> 会列出多个线程，每个线程一个 TID（内核调度单位）；</li></ul><p><strong>系统调度的是 LWP（线程），不是进程（PID）</strong>，这就是为什么：</p><ul><li><strong>多线程程序中，真正被调度运行的是每个线程（LWP）</strong>。</li><li>哪些线程先运行，哪些后运行，完全由调度器决定（不是你代码里的顺序）。</li><li>每个 LWP 都可能在不同的 CPU 核心上并发运行（多核 CPU）。</li></ul><h3 id="5-pthread-self-——-获取线程-ID"><a href="#5-pthread-self-——-获取线程-ID" class="headerlink" title="5. pthread_self —— 获取线程 ID"></a>5. pthread_self —— 获取线程 ID</h3><h4 id="1-功能-2"><a href="#1-功能-2" class="headerlink" title="1. 功能"></a>1. 功能</h4><p>获取 <strong>当前线程自身的线程 ID</strong>（pthread 库中的 ID 类型 <code>pthread_t</code>），用于线程内部识别自身，或与其他线程 ID 进行比较。</p><h4 id="2-函数原型-1"><a href="#2-函数原型-1" class="headerlink" title="2. 函数原型"></a>2. 函数原型</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">pthread_t</span> <span class="title">pthread_self</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>无参数，不需要传入任何值，它自动返回当前线程对应的 <code>pthread_t</code>。</li><li>返回值类型是 <code>pthread_t</code>，表示当前线程的 ID。</li></ul><h4 id="3-返回值"><a href="#3-返回值" class="headerlink" title="3. 返回值"></a>3. 返回值</h4><p>返回 <strong>当前线程的 ID</strong>（类型为 <code>pthread_t</code>），可以用这个 ID：</p><ul><li>打印出来查看当前线程是谁；</li><li>与其他 <code>pthread_t</code> 对比，判断是不是同一个线程；注意：<code>pthread_t</code> 是个不透明类型，比较是否相等，应使用 <code>pthread_equal()</code> 函数。</li><li>在调试或日志记录中标识线程身份。</li></ul><h4 id="4-代码示例"><a href="#4-代码示例" class="headerlink" title="4. 代码示例"></a>4. 代码示例</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">func</span><span class="params">(<span class="type">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid = <span class="built_in">pthread_self</span>();         <span class="comment">// 获取当前线程 ID</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;子线程 pthread_self() = &quot;</span> &lt;&lt; tid &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;这是子线程 pthread_t 变量的地址 %p\n&quot;</span>, &amp;tid);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;tid, <span class="literal">nullptr</span>, func, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">pthread_t</span> main_tid = <span class="built_in">pthread_self</span>();    <span class="comment">// 主线程自身 ID</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;主线程 pthread_self() = &quot;</span> &lt;&lt; main_tid &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;这是主线程 pthread_t 变量的地址 %p\n&quot;</span>, &amp;main_tid);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[hcc@hcss-ecs-be68 Threads]$ ./pthread_self </span><br><span class="line">子线程 pthread_self() = 140119442462464</span><br><span class="line">这是子线程 pthread_t 变量的地址 0x7f7019980ef8</span><br><span class="line">主线程 pthread_self() = 140119459862336</span><br><span class="line">这是主线程 pthread_t 变量的地址 0x7ffebae7f9e0</span><br></pre></td></tr></table></figure><p>主线程和子线程的 <code>pthread_self()</code> 返回值不同，说明它们是两个独立的线程。两个 <code>tid</code> 变量虽然名字类似，但位于不同线程的栈上。<strong>多线程环境下，函数的局部变量是线程安全的（自动隔离）</strong>。</p><hr><h2 id="3-线程等待"><a href="#3-线程等待" class="headerlink" title="3. 线程等待"></a>3. 线程等待</h2><h3 id="1-线程等待是什么？"><a href="#1-线程等待是什么？" class="headerlink" title="1. 线程等待是什么？"></a>1. 线程等待是什么？</h3><p>在多线程程序中，主线程或其他线程可能需要等待某个线程执行完毕后再继续执行。这个等待的过程叫做 <strong>线程等待</strong> 。类似于进程中的 <code>wait()</code> 系统调用。 </p><h3 id="2-pthread-join-——-阻塞线程"><a href="#2-pthread-join-——-阻塞线程" class="headerlink" title="2. pthread_join —— 阻塞线程"></a>2. pthread_join —— 阻塞线程</h3><h4 id="1-功能-3"><a href="#1-功能-3" class="headerlink" title="1. 功能"></a>1. 功能</h4><p><strong>阻塞当前线程</strong>，直到指定的线程结束，并可 <strong>获取该线程的返回值（退出码）</strong>。</p><ul><li>常用于 <strong>主线程等待子线程完成任务</strong>；</li><li>可以在子线程中 <code>return</code> 或使用 <code>pthread_exit()</code> 返回一个结果；</li><li>主线程通过 <code>pthread_join()</code> 把这个返回值拿到。</li></ul><h4 id="2-函数原型-2"><a href="#2-函数原型-2" class="headerlink" title="2. 函数原型"></a>2. 函数原型</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_join</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="type">void</span> **retval)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="3-参数详解-1"><a href="#3-参数详解-1" class="headerlink" title="3. 参数详解"></a>3. 参数详解</h4><table><thead><tr><th>参数名</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td><code>thread</code></td><td><code>pthread_t</code></td><td>要等待的线程 ID，一般是 <code>pthread_create</code> 时返回的</td></tr><tr><td><code>retval</code></td><td><code>void**</code></td><td>二级指针，接收线程退出时的退出码信息（可以为 <code>NULL</code>）</td></tr></tbody></table><p>retval 的注意：</p><ul><li>若不关心线程返回什么，可以传 <code>NULL</code>&#x2F;<code>nullptr</code>；</li><li>若关心，则要定义 <code>void* result</code>，传 <code>&amp;result</code>，线程退出时返回值会保存在 <code>result</code> 中。</li></ul><h4 id="4-返回值-1"><a href="#4-返回值-1" class="headerlink" title="4. 返回值"></a>4. 返回值</h4><ul><li>成功：返回 0。</li><li>失败：返回非 0，即错误码（如无效的线程 ID、线程不存在等）。</li></ul><h4 id="5-代码示例-1"><a href="#5-代码示例-1" class="headerlink" title="5. 代码示例"></a>5. 代码示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">func</span><span class="params">(<span class="type">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> id = *(<span class="type">int</span>*)arg;                    <span class="comment">// 获取线程编号</span></span><br><span class="line">    <span class="built_in">sleep</span>(id);                              <span class="comment">// 模拟不同耗时</span></span><br><span class="line">    <span class="type">int</span>* result = <span class="keyword">new</span> <span class="built_in">int</span>(id * <span class="number">10</span>);         <span class="comment">// 所有线程都要分配内存，让他们分别乘以 10</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;子线程 &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; 完成任务，返回结果 = &quot;</span> &lt;&lt; *result &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>*)result;                   <span class="comment">// 返回退出码（指针）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tids[<span class="number">5</span>];                      <span class="comment">// 线程 ID 数组</span></span><br><span class="line">    <span class="type">int</span> ids[<span class="number">5</span>];                             <span class="comment">// 用于传参的线程编号数组</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)             <span class="comment">// 创建多个子线程</span></span><br><span class="line">    &#123;</span><br><span class="line">        ids[i] = i + <span class="number">1</span>;                     <span class="comment">// 编号从 1 开始</span></span><br><span class="line">        <span class="built_in">pthread_create</span>(&amp;tids[i], <span class="literal">nullptr</span>, func, &amp;ids[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)             <span class="comment">// 主线程等待所有子线程完成</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">void</span>* retval = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="built_in">pthread_join</span>(tids[i], &amp;retval);     <span class="comment">// 阻塞等待子线程退出</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>* res = (<span class="type">int</span>*)retval;            <span class="comment">// 转换返回值</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;主线程获取到线程 &quot;</span> &lt;&lt; (i + <span class="number">1</span>) &lt;&lt; <span class="string">&quot; 的返回结果 = &quot;</span> &lt;&lt; *res &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">delete</span> res;                         <span class="comment">// 释放返回结果的内存</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;所有线程任务已完成，主线程退出。&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[hcc@hcss-ecs-be68 pthread_join]$ ./pthread_join </span><br><span class="line">子线程 1 完成任务，返回结果 = 10</span><br><span class="line">主线程获取到线程 1 的返回结果 = 10</span><br><span class="line">子线程 2 完成任务，返回结果 = 20</span><br><span class="line">主线程获取到线程 2 的返回结果 = 20</span><br><span class="line">子线程 3 完成任务，返回结果 = 30</span><br><span class="line">主线程获取到线程 3 的返回结果 = 30</span><br><span class="line">子线程 4 完成任务，返回结果 = 40</span><br><span class="line">主线程获取到线程 4 的返回结果 = 40</span><br><span class="line">子线程 5 完成任务，返回结果 = 50</span><br><span class="line">主线程获取到线程 5 的返回结果 = 50</span><br><span class="line">所有线程任务已完成，主线程退出。</span><br></pre></td></tr></table></figure><hr><h3 id="3-线程退出值-退出码（为啥只能拿这个）？"><a href="#3-线程退出值-退出码（为啥只能拿这个）？" class="headerlink" title="3. 线程退出值 &#x3D; 退出码（为啥只能拿这个）？"></a>3. 线程退出值 &#x3D; 退出码（为啥只能拿这个）？</h3><blockquote><p><code>pthread_join()</code> 是主线程 <strong>阻塞等待</strong> 子线程完成，并 <strong>获取子线程返回值（退出码）</strong> 的唯一方式，而这个退出码只能是 <code>void*</code> 类型，因为 POSIX pthread 模型就规定线程函数只能返回一个 <code>void*</code> 指针。</p></blockquote><h4 id="1-为什么线程退出时只能“返回一个退出码”？"><a href="#1-为什么线程退出时只能“返回一个退出码”？" class="headerlink" title="1. 为什么线程退出时只能“返回一个退出码”？"></a>1. 为什么线程退出时只能“返回一个退出码”？</h4><p>因为线程函数的原型是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* (*start_routine)(<span class="type">void</span>*)</span><br></pre></td></tr></table></figure><ul><li>它只能有一个返回值，类型是 <code>void*</code>，这是 POSIX 标准设计决定的；</li><li>无法直接返回多个值，也不能返回栈上对象（因为线程函数退出后栈就销毁了）；</li><li>所以如果需要返回复杂数据，必须 <strong>动态申请内存（如 <code>new</code>）并 return 指针</strong>，主线程通过 <code>pthread_join()</code> 接收并自行释放。</li></ul><h4 id="2-为什么不是像-fork-那样返回整型或-exit-code？"><a href="#2-为什么不是像-fork-那样返回整型或-exit-code？" class="headerlink" title="2. 为什么不是像 fork() 那样返回整型或 exit code？"></a>2. 为什么不是像 <code>fork()</code> 那样返回整型或 exit code？</h4><ul><li><code>fork()</code> 是 <strong>进程级别</strong>，操作系统可以记录 exit status；</li><li><code>pthread_exit()</code> 或 <code>return</code> 是线程级别，线程之间共享地址空间，退出值不需要写入操作系统状态；</li><li><code>pthread_join()</code> 只关心线程退出时返回的那块 <strong>用户级别的数据指针（void*）</strong>，而不是操作系统的退出码。</li></ul><hr><h2 id="4-线程终止"><a href="#4-线程终止" class="headerlink" title="4. 线程终止"></a>4. 线程终止</h2><h3 id="1-线程终止的-4-种方式（核心）"><a href="#1-线程终止的-4-种方式（核心）" class="headerlink" title="1. 线程终止的 4 种方式（核心）"></a>1. 线程终止的 4 种方式（核心）</h3><p>在 POSIX <code>pthread</code> 中，<strong>线程的终止方式主要有以下几种</strong>：</p><ol><li><p><strong>线程函数运行完毕后自动返回：</strong> 这是最自然的退出方式，函数体执行到最后，线程就自动退出。</p></li><li><p><strong>在函数中调用 <code>pthread_exit()</code> 主动退出：</strong> 这种方式适用于希望 <strong>中途退出线程</strong>，但又希望返回一个退出值的情况。可随时退出线程、能设置退出码、等效于 <code>return</code>。</p></li><li><p><strong>其他线程调用 <code>pthread_cancel()</code> 强制取消线程：</strong> 一种 <strong>异步控制</strong> 方式。线程不一定立即退出，需要处于“<strong>可取消点</strong>”（如 sleep、read 等），线程退出码为 <code>PTHREAD_CANCELED ((void*)-1)</code>。<strong>注意：如果线程没有设置为可取消状态，<code>pthread_cancel()</code> 无效。</strong></p></li><li><p><strong>整个进程退出时，所有线程终止：</strong> 当 <strong>主线程调用 <code>exit()</code>、<code>_exit()</code> 或主线程崩溃</strong> 导致整个进程终止时，所有线程也会强制结束。粗暴退出会导致线程无法清理资源，常见于崩溃或异常退出。</p></li></ol><table><thead><tr><th>终止方式</th><th>触发者</th><th>是否能传退出码</th><th>是否立即退出</th><th>是否安全</th></tr></thead><tbody><tr><td><code>return</code></td><td>本线程自己</td><td>✅ 是</td><td>✅ 是</td><td>✅ 推荐</td></tr><tr><td><code>pthread_exit()</code></td><td>本线程自己</td><td>✅ 是</td><td>✅ 是</td><td>✅ 推荐</td></tr><tr><td><code>pthread_cancel()</code></td><td>其他线程</td><td>✅（默认为 <code>PTHREAD_CANCELED</code>）</td><td>❌ 依赖可取消点</td><td>⚠️ 谨慎使用</td></tr><tr><td><code>exit()</code> &#x2F; 崩溃</td><td>任意线程</td><td>❌ 无法获取</td><td>✅ 是</td><td>❌ 不推荐</td></tr></tbody></table><hr><h3 id="2-pthread-exit-——-主动退出当前线程"><a href="#2-pthread-exit-——-主动退出当前线程" class="headerlink" title="2. pthread_exit —— 主动退出当前线程"></a>2. <code>pthread_exit</code> —— 主动退出当前线程</h3><h4 id="1-功能-4"><a href="#1-功能-4" class="headerlink" title="1. 功能"></a>1. 功能</h4><p>主动退出当前线程，并返回一个退出值（给等待该线程的其他线程）。比 <code>return</code> 更灵活，可在任何地方终止线程。</p><p>适用于：</p><ul><li>线程需要在函数中间提前退出；</li><li>想设置返回值供 <code>pthread_join</code> 获取；</li></ul><h4 id="2-函数原型-3"><a href="#2-函数原型-3" class="headerlink" title="2. 函数原型"></a>2. 函数原型</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pthread_exit</span><span class="params">(<span class="type">void</span>* retval)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="3-参数详解-2"><a href="#3-参数详解-2" class="headerlink" title="3. 参数详解"></a>3. 参数详解</h4><p><strong><code>void* retval</code>：</strong> 线程的退出码，可传任意指针或整型强转。是 <strong>返回给 pthread_join 的退出值</strong>，如果线程已分离，该值会被忽略。</p><h4 id="4-返回值-2"><a href="#4-返回值-2" class="headerlink" title="4. 返回值"></a>4. 返回值</h4><p><strong>无返回值</strong>，调用后线程立即退出，后面的代码不会执行。</p><h4 id="5-代码示例-2"><a href="#5-代码示例-2" class="headerlink" title="5. 代码示例"></a>5. 代码示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">myThread</span><span class="params">(<span class="type">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;子线程正在运行...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">pthread_exit</span>((<span class="type">void</span>*)<span class="number">1234</span>);  <span class="comment">// 主动退出，返回值是1234</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;子线程退出已经退出了，并且这一句话不会被执行！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    <span class="type">void</span>* retval;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;tid, <span class="literal">nullptr</span>, myThread, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">pthread_join</span>(tid, &amp;retval);  <span class="comment">// 获取子线程返回值</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;子线程退出码：&quot;</span> &lt;&lt; (<span class="type">long</span> <span class="type">long</span>)retval &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 注意：在64位的Linux中，void*（指针）是 8 字节，所以转成 long long，如果转成 int 会报错！</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果示例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[hcc@hcss-ecs-be68 pthread_exit]$ ./pthread_exit </span><br><span class="line">子线程正在运行...</span><br><span class="line">子线程退出码：1234</span><br></pre></td></tr></table></figure><hr><h3 id="3-pthread-cancel-——-发送请求"><a href="#3-pthread-cancel-——-发送请求" class="headerlink" title="3. pthread_cancel —— 发送请求"></a>3. <code>pthread_cancel</code> —— 发送请求</h3><h4 id="1-功能-5"><a href="#1-功能-5" class="headerlink" title="1. 功能"></a>1. 功能</h4><p><strong>向指定线程发送“取消请求”，尝试强制终止它（但不一定立即终止）。</strong></p><p>适用于：</p><ul><li>主动终止长时间运行或卡死的线程；</li><li>线程之间的控制与协作场景。</li></ul><h4 id="2-函数原型-4"><a href="#2-函数原型-4" class="headerlink" title="2. 函数原型"></a>2. 函数原型</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_cancel</span><span class="params">(<span class="type">pthread_t</span> thread)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="3-参数详解-3"><a href="#3-参数详解-3" class="headerlink" title="3. 参数详解"></a>3. 参数详解</h4><p><strong><code>pthread_t thread</code>：</strong> 目标线程的线程 ID。</p><h4 id="4-返回值-3"><a href="#4-返回值-3" class="headerlink" title="4. 返回值"></a>4. 返回值</h4><table><thead><tr><th>返回值</th><th>含义</th></tr></thead><tbody><tr><td><strong><code>0</code></strong></td><td>成功发送取消请求（<strong>注意：不是线程已退出！</strong>）</td></tr><tr><td><code>ESRCH</code></td><td>没有找到指定的线程 ID（线程不存在）</td></tr><tr><td><code>EINVAL</code>（少见）</td><td>线程 ID 无效（某些实现中使用）</td></tr></tbody></table><h4 id="5-注意事项"><a href="#5-注意事项" class="headerlink" title="5. 注意事项"></a>5. 注意事项</h4><ol><li><strong>不是立即强制终止线程！</strong><ul><li>被取消线程 <strong>必须处于可取消状态</strong>，且处于 <strong>取消点</strong>；</li><li>常见取消点有 <code>sleep</code>、<code>read</code>、<code>pthread_join</code> 等。</li></ul></li><li><strong>线程取消成功后</strong>，其退出值为 <code>(void*)PTHREAD_CANCELED</code>，用来判断线程是否被取消。</li><li><strong>如何查一个函数是不是取消点？</strong><ul><li>查阅 <a href="https://pubs.opengroup.org/onlinepubs/9699919799/?spm=a2ty_o01.29997173.0.0.1fff235egGhhMb">POSIX 官方文档</a></li><li>使用命令：<code>man 7 pthreads</code>，在 Linux 手册中输入 <code>/</code> 搜索 “Cancellation points”，会列出所有标准取消点函数。</li></ul></li></ol><blockquote><p><code>PTHREAD_CANCELED</code> 是 POSIX 线程库（pthread）中一个 <strong>宏常量</strong>，它 <strong>用于判断&#x2F;标识线程是否是被 <code>pthread_cancel()</code> 强制取消退出的</strong>，而不是正常执行完毕返回的，可以在 <code>pthread_join()</code> 后检查返回值是否等于它，来确认线程状态。其本质是个 <code>#define</code>（宏）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="meta">#<span class="keyword">define</span> PTHREAD_CANCELED ((void *) -1)</span></span><br></pre></td></tr></table></figure><ul><li>它是一个 <code>void*</code> 类型的宏常量；</li><li>实际上是 <code>(void*)-1</code>，特殊指针，用作标记；</li><li>不能拿它当做真实的返回值内容使用，只能 <strong>判断它是不是等于某线程的退出码</strong>。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">&gt;<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line">&gt;<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line">&gt;<span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">&gt;<span class="function"><span class="type">void</span>* <span class="title">func</span><span class="params">(<span class="type">void</span>* arg)</span></span></span><br><span class="line"><span class="function">&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;子线程运行中...&quot;</span> &lt;&lt; endl;</span><br><span class="line">      <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">&gt;</span>&#123;</span><br><span class="line">  <span class="type">pthread_t</span> tid;</span><br><span class="line">  <span class="built_in">pthread_create</span>(&amp;tid, <span class="literal">nullptr</span>, func, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">sleep</span>(<span class="number">2</span>);                            <span class="comment">// 让子线程跑一会儿</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">pthread_cancel</span>(tid);                 <span class="comment">// 取消子线程</span></span><br><span class="line"></span><br><span class="line">  <span class="type">void</span>* retval;</span><br><span class="line">  <span class="built_in">pthread_join</span>(tid, &amp;retval);          <span class="comment">// 等待子线程结束</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 检查返回值是否为被取消</span></span><br><span class="line">  <span class="keyword">if</span> (retval == PTHREAD_CANCELED)</span><br><span class="line">  &#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;子线程被成功取消，返回值 = PTHREAD_CANCELED&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;子线程正常退出，返回值 = &quot;</span> &lt;&lt; retval &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;[hcc@hcss-ecs-be68 pthread_cancel]$ g++ -o PTHREAD_CANCELED PTHREAD_CANCELED.cc -std=c++11 -lpthread</span><br><span class="line">&gt;[hcc@hcss-ecs-be68 pthread_cancel]$ ./PTHREAD_CANCELED </span><br><span class="line">&gt;子线程运行中...</span><br><span class="line">&gt;子线程运行中...</span><br><span class="line">&gt;子线程被成功取消，返回值 = PTHREAD_CANCELED</span><br></pre></td></tr></table></figure></blockquote><h4 id="6-代码示例"><a href="#6-代码示例" class="headerlink" title="6. 代码示例"></a>6. 代码示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">func</span><span class="params">(<span class="type">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;子线程工作中...&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);                   <span class="comment">// sleep 是一个可取消点</span></span><br><span class="line">        <span class="comment">// pthread_testcancel();       // 手动设置一个取消点</span></span><br><span class="line">        <span class="comment">// 注意：如果使用 pthread_testcancel()，在这个程序中会无限打印 &quot;子线程工作中...&quot;，在3秒后会自动退出，</span></span><br><span class="line">        <span class="comment">// 和sleep(1)一样的效果。虽然看起来像是死循环，但实际上是可以取消的！</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    <span class="type">void</span>* retval;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;tid, <span class="literal">nullptr</span>, func, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">3</span>);                       <span class="comment">// 让子线程运行一会</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_cancel</span>(tid);            <span class="comment">// 发送取消请求</span></span><br><span class="line">    <span class="built_in">pthread_join</span>(tid, &amp;retval);     <span class="comment">// 等待子线程结束并获取退出码</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (retval == PTHREAD_CANCELED)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;收到取消请求，子线程被取消了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[hcc@hcss-ecs-be68 pthread_cancel]$ ./pthread_cancel </span><br><span class="line">子线程工作中...</span><br><span class="line">子线程工作中...</span><br><span class="line">子线程工作中...</span><br><span class="line">收到取消请求，子线程被取消了！</span><br></pre></td></tr></table></figure><h3 id="4-小结"><a href="#4-小结" class="headerlink" title="4. 小结"></a>4. 小结</h3><table><thead><tr><th>函数</th><th>主体是谁调用</th><th>用于哪个线程</th><th>是否立即终止</th><th>是否能设置退出码</th></tr></thead><tbody><tr><td><code>pthread_exit</code></td><td>当前线程</td><td>自己</td><td>立即</td><td>是</td></tr><tr><td><code>pthread_cancel</code></td><td>外部线程</td><td>目标线程</td><td>非立即</td><td>返回值为宏</td></tr></tbody></table><hr><p>线程分离（<strong>Detached Thread</strong>）是 Linux 多线程（POSIX 线程 <code>pthread</code>）编程中的一个重要概念。下面我们从概念入手，逐步深入 <code>pthread_detach</code> 函数及其背后机制，讲清楚线程分离的本质。</p><hr><h2 id="5-线程分离"><a href="#5-线程分离" class="headerlink" title="5. 线程分离"></a>5. 线程分离</h2><h3 id="1-线程分离是什么，有什么用？"><a href="#1-线程分离是什么，有什么用？" class="headerlink" title="1. 线程分离是什么，有什么用？"></a>1. 线程分离是什么，有什么用？</h3><p>在默认情况下（<strong>joinable</strong> 模式），线程执行完后不会立即释放资源，需要其他线程调用 <code>pthread_join()</code> 与之回收，才能释放其占用的资源（如线程栈、PCB 结构等）。</p><p><strong>线程分离（detached） 就是让线程在执行完毕后自动释放自己的资源，不再需要其他线程去 <code>pthread_join()</code> 它，防止资源泄漏。注意：线程一旦结束，系统自动回收资源，不能再被 <code>pthread_join</code>！</strong></p><h3 id="2-pthread-detach-函数"><a href="#2-pthread-detach-函数" class="headerlink" title="2. pthread_detach 函数"></a>2. <code>pthread_detach</code> 函数</h3><h4 id="1-功能-6"><a href="#1-功能-6" class="headerlink" title="1. 功能"></a>1. 功能</h4><p>将一个线程设置为 <strong>分离状态</strong>，使其结束时资源自动释放。</p><h4 id="2-函数原型-5"><a href="#2-函数原型-5" class="headerlink" title="2. 函数原型"></a>2. 函数原型</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_detach</span><span class="params">(<span class="type">pthread_t</span> thread)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="3-参数说明"><a href="#3-参数说明" class="headerlink" title="3. 参数说明"></a>3. 参数说明</h4><p><code>thread</code>：需要设置为分离状态的线程 ID（<code>pthread_t</code> 类型）。</p><h4 id="4-返回值-4"><a href="#4-返回值-4" class="headerlink" title="4. 返回值"></a>4. 返回值</h4><ul><li><code>0</code>：成功。</li><li><code>EINVAL</code>：线程不是 joinable 或状态无效。</li><li><code>ESRCH</code>：指定的线程 ID 不存在。</li></ul><h4 id="5-代码示例-3"><a href="#5-代码示例-3" class="headerlink" title="5. 代码示例"></a>5. 代码示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">func</span><span class="params">(<span class="type">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;子线程开始执行...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;子线程执行完毕，自动释放资源。&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">pthread_exit</span>(<span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建线程（默认是 joinable 状态）</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">pthread_create</span>(&amp;tid, <span class="literal">nullptr</span>, func, <span class="literal">nullptr</span>) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;线程创建失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置线程为分离状态</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">pthread_detach</span>(tid) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;线程分离失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;主线程不等待子线程，直接结束。&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[hcc@hcss-ecs-be68 pthread_detach]$ ./pthread_detach </span><br><span class="line">主线程不等待子线程，直接结束。</span><br><span class="line">子线程开始执行...</span><br><span class="line">子线程执行完毕，自动释放资源。</span><br></pre></td></tr></table></figure><hr><h3 id="3-线程分离的本质是什么？"><a href="#3-线程分离的本质是什么？" class="headerlink" title="3. 线程分离的本质是什么？"></a>3. 线程分离的本质是什么？</h3><p><strong>线程分离的本质就是线程的一个属性</strong>，叫作：</p><ul><li>PTHREAD_CREATE_JOINABLE（默认）</li><li>PTHREAD_CREATE_DETACHED（分离）</li></ul><p>这个属性决定了线程的生命周期如何管理资源：</p><ul><li><strong>JOINABLE 状态</strong>：线程执行完还要别人 <code>join()</code> 回收资源；</li><li><strong>DETACHED 状态</strong>：线程执行完直接自己清理干净，别人不能 <code>join()</code> 它。</li></ul><p><strong>一旦线程设置为分离状态，无法再对它调用 <code>pthread_join()</code>，否则会导致未定义行为，分离线程是否继续执行不取决于主线程是否退出，而取决于进程是否还活着。（分离线程 &#x3D; 自动回收，非分离线程 &#x3D; 手动回收）。</strong></p><hr><h3 id="4-小结-1"><a href="#4-小结-1" class="headerlink" title="4. 小结"></a>4. 小结</h3><ul><li>如果创建的线程是 <strong>短生命周期</strong>、且不需要结果回传的（如后台异步日志写入），建议使用 <code>pthread_detach()</code> 或属性设置为分离。</li><li>如果需要线程返回值（如子线程计算结果后回传主线程），则必须使用 <code>joinable</code> 并调用 <code>pthread_join()</code>。</li><li>线程分离后，即使主线程退出，分离线程也不一定会结束，只有当进程退出才会影响！</li><li><strong>千万不要创建完线程后忘记 <code>join()</code> 或 <code>detach()</code></strong>，否则会发生资源泄漏，尤其在线程频繁创建时。</li></ul><hr><h2 id="6-C-语言层面上的多线程支持（C-11-起，了解）"><a href="#6-C-语言层面上的多线程支持（C-11-起，了解）" class="headerlink" title="6. C++ 语言层面上的多线程支持（C++11 起，了解）"></a>6. C++ 语言层面上的多线程支持（C++11 起，了解）</h2><p><code>pthread</code> 是 C 语言的 POSIX 线程库（第三方），可在 C++ 中直接使用，但并非 C++ 语言原生支持；从 C++11 起，C++ 在语言层面提供了 <code>std::thread</code> 作为标准多线程支持，具有更好的类型安全和跨平台性，底层在 Linux 上通常基于 <code>pthread</code> 实现，但对用户透明。</p><h3 id="1-pthread-VS-std-thread"><a href="#1-pthread-VS-std-thread" class="headerlink" title="1. pthread VS std:: thread"></a>1. pthread VS std:: thread</h3><table><thead><tr><th>概念</th><th>说明</th></tr></thead><tbody><tr><td><code>pthread</code></td><td>是 <strong>POSIX 标准定义的 C 语言线程 API</strong>，不是 C++ 的一部分。在 Linux 上通过 <code>&lt;pthread.h&gt;</code> 提供。</td></tr><tr><td><code>std::thread</code></td><td>是 <strong>C++11 标准引入的 C++ 原生线程类</strong>，属于 C++ 标准库，头文件 <code>&lt;thread&gt;</code>。</td></tr></tbody></table><table><thead><tr><th>对比</th><th><code>pthread</code>（C 风格）</th><th><code>std::thread</code>（C++11 起标准库）</th></tr></thead><tbody><tr><td><strong>来源</strong></td><td>POSIX API（非 C++ 标准）</td><td>C++ 标准库（C++11 起）</td></tr><tr><td><strong>头文件</strong></td><td><code>&lt;pthread.h&gt;</code></td><td><code>&lt;thread&gt;</code></td></tr><tr><td><strong>依赖</strong></td><td>POSIX 系统（Linux&#x2F;Unix），Windows 原生不支持</td><td>跨平台：Windows &#x2F; Linux &#x2F; macOS（编译器支持即可）</td></tr><tr><td><strong>语言风格</strong></td><td>C 风格：函数指针 + <code>void*</code> 参数</td><td>C++ 风格：支持 lambda、成员函数、函数对象、模板</td></tr><tr><td><strong>类型安全</strong></td><td><code>void*</code> 传参，易出错</td><td>模板自动推导，类型安全</td></tr><tr><td><strong>封装性</strong></td><td>纯函数式调用，无类封装</td><td><code>std::thread</code> 是类，支持 RAII、移动语义</td></tr><tr><td><strong>适合谁</strong></td><td>系统编程、嵌入式、高性能定制、底层原理</td><td>应用开发、跨平台项目、现代 C++ 开发</td></tr><tr><td><strong>退出机制</strong></td><td><code>pthread_exit()</code>、<code>pthread_join()</code></td><td><code>t.join()</code>、<code>t.detach()</code>，析构时自动检查</td></tr><tr><td><strong>可移植性</strong></td><td>仅限 POSIX 系统</td><td>只要编译器支持 C++11 就可移植</td></tr><tr><td><strong>底层实现</strong></td><td>直接调用内核 LWP（轻量级进程）</td><td>在 Linux 上通常基于 <code>pthread</code> 封装（但对用户透明）</td></tr><tr><td><strong>编译选项</strong></td><td><code>g++ -o app app.cpp -lpthread</code></td><td><code>g++ -o app app.cpp -std=c++11</code>（自动链接）</td></tr></tbody></table><hr><h3 id="2-std-thread-vs-pthread-对照表"><a href="#2-std-thread-vs-pthread-对照表" class="headerlink" title="2. std::thread vs pthread 对照表"></a>2. <code>std::thread</code> vs <code>pthread</code> 对照表</h3><table><thead><tr><th><code>pthread</code> 函数</th><th><code>std::thread</code> 写法</th><th>说明</th></tr></thead><tbody><tr><td><code>pthread_create(&amp;tid, nullptr, func, arg)</code></td><td><code>std::thread t(func, arg);</code></td><td>创建线程</td></tr><tr><td><code>pthread_join(tid, &amp;ret)</code></td><td><code>t.join();</code></td><td>等待线程结束</td></tr><tr><td><code>pthread_exit()</code></td><td><code>return;</code></td><td>线程函数返回即退出</td></tr><tr><td><code>pthread_self()</code></td><td><code>std::this_thread::get_id()</code></td><td>获取当前线程 ID</td></tr><tr><td><code>sleep(1)</code></td><td><code>std::this_thread::sleep_for(1s);</code></td><td>睡眠 1 秒</td></tr></tbody></table><h3 id="3-代码示例"><a href="#3-代码示例" class="headerlink" title="3. 代码示例"></a>3. 代码示例</h3><h4 id="1-创建线程"><a href="#1-创建线程" class="headerlink" title="1. 创建线程"></a>1. 创建线程</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">thread <span class="title">t</span><span class="params">(函数名, 参数...)</span></span>;</span><br></pre></td></tr></table></figure><p>参数会自动拷贝（如果是对象）想传引用？用 <code>std::ref(变量)</code> 包一层。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span>&amp; x)</span> </span>&#123; x = <span class="number">100</span>; &#125;</span><br><span class="line"><span class="type">int</span> val = <span class="number">0</span>;</span><br><span class="line"><span class="function">thread <span class="title">t</span><span class="params">(func, ref(val))</span></span>;  <span class="comment">// 传引用</span></span><br><span class="line">t.<span class="built_in">join</span>();</span><br><span class="line">cout &lt;&lt; val;  <span class="comment">// 输出 100</span></span><br></pre></td></tr></table></figure><h4 id="2-等待线程结束：join"><a href="#2-等待线程结束：join" class="headerlink" title="2. 等待线程结束：join()"></a>2. 等待线程结束：<code>join()</code></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t.<span class="built_in">join</span>();  <span class="comment">// 必须调用，否则程序会崩溃！</span></span><br></pre></td></tr></table></figure><p>类比 <code>pthread_join</code>，一个 <code>thread</code> 对象只能 <code>join()</code> 一次。</p><h4 id="3-分离线程：detach"><a href="#3-分离线程：detach" class="headerlink" title="3. 分离线程：detach()"></a>3. 分离线程：<code>detach()</code></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t.<span class="built_in">detach</span>();  <span class="comment">// 不等它，让它后台运行</span></span><br></pre></td></tr></table></figure><h4 id="4-获取线程-ID"><a href="#4-获取线程-ID" class="headerlink" title="4. 获取线程 ID"></a>4. 获取线程 ID</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">&quot;当前线程ID: &quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;t的线程ID: &quot;</span> &lt;&lt; t.<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br></pre></td></tr></table></figure><h4 id="5-支持-lambda（超方便！）"><a href="#5-支持-lambda（超方便！）" class="headerlink" title="5. 支持 lambda（超方便！）"></a>5. 支持 lambda（超方便！）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">thread <span class="title">t</span><span class="params">([]&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    cout &lt;&lt; <span class="string">&quot;Lambda 线程运行！&quot;</span> &lt;&lt; endl;</span></span></span><br><span class="line"><span class="params"><span class="function">    this_thread::sleep_for(<span class="number">1</span>s);</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;)</span></span>;</span><br><span class="line">t.<span class="built_in">join</span>();</span><br></pre></td></tr></table></figure><h4 id="6-支持类成员函数"><a href="#6-支持类成员函数" class="headerlink" title="6. 支持类成员函数"></a>6. 支持类成员函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Worker</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Worker 工作 &quot;</span> &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Worker w;</span><br><span class="line"><span class="function">thread <span class="title">t</span><span class="params">(&amp;Worker::work, &amp;w, <span class="number">100</span>)</span></span>;  <span class="comment">// &amp;w 是对象地址</span></span><br><span class="line">t.<span class="built_in">join</span>();</span><br></pre></td></tr></table></figure><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(string msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;主线程: &quot;</span> &lt;&lt; msg &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 成员函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">work</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;子线程: &quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(func, <span class="string">&quot;我是普通函数线程&quot;</span>)</span></span>;         <span class="comment">// 1. 普通函数线程</span></span><br><span class="line">    work w;</span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(&amp;work::run, &amp;w, <span class="number">42</span>)</span></span>;              <span class="comment">// 2. 成员函数线程</span></span><br><span class="line">    <span class="function">thread <span class="title">t3</span><span class="params">([]() &#123;                            <span class="comment">// 3. lambda线程</span></span></span></span><br><span class="line"><span class="params"><span class="function">        cout &lt;&lt; <span class="string">&quot;lambda线程: &quot;</span> &lt;&lt; endl;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">3.</span><span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span>       <span class="comment">// C++ 中专门处理时间的库</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> chrono;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadFunc</span><span class="params">(<span class="type">const</span> string&amp; name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; name &lt;&lt; <span class="string">&quot;: 工作中 &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">        this_thread::<span class="built_in">sleep_for</span>(<span class="number">1</span>s);        <span class="comment">// 睡1秒</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">(threadFunc, <span class="string">&quot;子线程&quot;</span>)</span></span>;        <span class="comment">// 创建线程（pthread_create）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i)           <span class="comment">// 主线程也干点事</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;主线程: 主线程工作 &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">        this_thread::<span class="built_in">sleep_for</span>(<span class="number">500</span>ms);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    t.<span class="built_in">join</span>();                             <span class="comment">// 等待子线程结束（类比 pthread_join）</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;所有线程结束！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//运行结果示例：</span></span><br><span class="line"><span class="comment">//主线程:主线程工作 0</span></span><br><span class="line"><span class="comment">//子线程:工作中 0</span></span><br><span class="line"><span class="comment">//主线程:主线程工作 1</span></span><br><span class="line"><span class="comment">//子线程:工作中 1</span></span><br><span class="line"><span class="comment">//子线程:工作中 2</span></span><br><span class="line"><span class="comment">//所有线程结束！！</span></span><br></pre></td></tr></table></figure><h2 id="7-可重入与线程安全"><a href="#7-可重入与线程安全" class="headerlink" title="7. 可重入与线程安全"></a>7. 可重入与线程安全</h2><blockquote><p>  <strong>“可重入”指的是一个函数可以被多个线程同时调用，并且不会互相影响，不会出现混乱或崩溃。</strong></p></blockquote><h3 id="1-代码示例：一个不可重入的函数"><a href="#1-代码示例：一个不可重入的函数" class="headerlink" title="1. 代码示例：一个不可重入的函数"></a>1. 代码示例：一个不可重入的函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> counter = <span class="number">0</span>;                        <span class="comment">// 全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">task</span><span class="params">(<span class="type">void</span>* arg)</span>                   <span class="comment">// 所有线程都会调用这个函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 每个线程都对同一个 counter 加 1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        ++counter;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;线程 &quot;</span> &lt;&lt; <span class="built_in">pthread_self</span>() &lt;&lt; <span class="string">&quot; counter = &quot;</span> &lt;&lt; counter &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_exit</span>(<span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> t1, t2;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;t1, <span class="literal">nullptr</span>, task, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;t2, <span class="literal">nullptr</span>, task, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_join</span>(t1, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">pthread_join</span>(t2, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;最终counter = &quot;</span> &lt;&lt; counter &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数是 <strong>不是可重入的</strong>，并且运行输出是错乱的，因为 <code>counter</code> 是 <strong>全局变量</strong>，多个线程同时改它，结果错乱。<code>cout</code> 也是 <strong>共享资源</strong>，多个线程同时输出可能出现换行错乱。</p><h3 id="2-可重入函数应该是什么样？"><a href="#2-可重入函数应该是什么样？" class="headerlink" title="2. 可重入函数应该是什么样？"></a>2. 可重入函数应该是什么样？</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 完全不使用全局变量，只用局部变量</span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">safe_task</span><span class="params">(<span class="type">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> local_counter = <span class="number">0</span>;   <span class="comment">// 每个线程有自己的变量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        ++local_counter;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;线程 &quot;</span> &lt;&lt; <span class="built_in">pthread_self</span>() &lt;&lt; <span class="string">&quot; local_counter = &quot;</span> &lt;&lt; local_counter &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_exit</span>(<span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个 <code>safe_task()</code> 就是 <strong>可重入的函数</strong>，每个线程都自己玩自己的变量，互不干扰。</p><hr><h3 id="3-小结"><a href="#3-小结" class="headerlink" title="3. 小结"></a>3. 小结</h3><p><strong>现在用线程，只需要记住：可重入函数不使用全局变量，也不操作共享资源，就不会线程混乱。目前只需要做到：尽量只用局部变量，一个线程干自己的事，不要访问别人家的变量，就能避免 90% 的线程问题！</strong></p><table><thead><tr><th>要注意的点</th><th>是否说明可重入</th><th>建议做法</th></tr></thead><tbody><tr><td>用全局变量</td><td>❌ 否</td><td>每个线程用自己的局部变量</td></tr><tr><td>打印输出 cout&#x2F;printf</td><td>❌ 否</td><td>少用或后续使用加锁保护输出</td></tr><tr><td>多个线程同时调函数</td><td>✅ 是</td><td>放心大胆用</td></tr><tr><td>pthread API</td><td>✅ 无影响</td><td>这些 pthread 函数本身是线程安全的</td></tr></tbody></table><hr><h2 id="8-代码实战"><a href="#8-代码实战" class="headerlink" title="8. 代码实战"></a>8. 代码实战</h2><h3 id="1-多种终止方式"><a href="#1-多种终止方式" class="headerlink" title="1. 多种终止方式"></a>1. 多种终止方式</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">thread1</span><span class="params">(<span class="type">void</span>*)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;[线程1] 正常 return 退出&quot;</span> &lt;&lt; endl;               <span class="comment">// 方法1：函数 return 自然返回</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>*)<span class="number">1</span>;                                         <span class="comment">// 返回退出值 1</span></span><br><span class="line">    <span class="comment">// return nullptr;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">thread2</span><span class="params">(<span class="type">void</span>*)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;[线程2] 使用 pthread_exit 主动退出&quot;</span> &lt;&lt; endl;     <span class="comment">// 方法2：显式调用 pthread_exit</span></span><br><span class="line">    <span class="built_in">pthread_exit</span>((<span class="type">void</span>*)<span class="number">2</span>);                                  <span class="comment">// 返回退出值 2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">thread3</span><span class="params">(<span class="type">void</span>*)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;[线程3] 进入无限循环，等待被取消...&quot;</span> &lt;&lt; endl;     <span class="comment">// 方法3：无限循环，等待 cancel</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);                                            <span class="comment">// 可取消点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">thread4</span><span class="params">(<span class="type">void</span>*)</span>                                         <span class="comment">// 方法4：使用 exit 退出（注意：此会导致整个进程退出！不推荐！）</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;[线程4] 调用了 exit(3)，整个进程都会终止！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">3</span>);                                                 <span class="comment">// 会结束整个程序（不推荐在线程中用）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> t1, t2, t3, t4;</span><br><span class="line">    <span class="type">void</span>* ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建四个线程</span></span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;t1, <span class="literal">nullptr</span>, thread1, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;t2, <span class="literal">nullptr</span>, thread2, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;t3, <span class="literal">nullptr</span>, thread3, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="comment">// pthread_create(&amp;t4, nullptr, thread4, nullptr);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待线程1退出（正常 return）</span></span><br><span class="line">    <span class="built_in">pthread_join</span>(t1, &amp;ret);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;[主线程] 线程1退出，退出值 = &quot;</span> &lt;&lt; (<span class="type">long</span> <span class="type">long</span>)ret &lt;&lt; <span class="string">&quot;（return 返回）&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待线程2退出（pthread_exit）</span></span><br><span class="line">    <span class="built_in">pthread_join</span>(t2, &amp;ret);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;[主线程] 线程2退出，退出值 = &quot;</span> &lt;&lt; (<span class="type">long</span> <span class="type">long</span>)ret &lt;&lt; <span class="string">&quot;（pthread_exit 返回）&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取消线程3</span></span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">2</span>);                       <span class="comment">// 等它跑一下</span></span><br><span class="line">    <span class="built_in">pthread_cancel</span>(t3);</span><br><span class="line">    <span class="built_in">pthread_join</span>(t3, &amp;ret);</span><br><span class="line">    <span class="keyword">if</span> (ret == PTHREAD_CANCELED)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;[主线程] 线程3被取消（pthread_cancel）&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;[主线程] 线程3退出值 = &quot;</span> &lt;&lt; (<span class="type">long</span> <span class="type">long</span>)ret &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">2</span>);                       <span class="comment">// 等它跑一下</span></span><br><span class="line">    <span class="comment">// 等待线程4退出（exit）=&gt; 会导致其他线程无法正常退出，整个进程终止！</span></span><br><span class="line">    <span class="comment">// pthread_join(t4, &amp;ret);</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; &quot;[主线程] 线程4退出，退出值 = &quot; &lt;&lt; (long long)ret &lt;&lt; &quot;（exit 终止）&quot; &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-多线程的协同"><a href="#2-多线程的协同" class="headerlink" title="2. 多线程的协同"></a>2. 多线程的协同</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 枚举线程运行状态</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Status</span></span><br><span class="line">&#123;</span><br><span class="line">    OK = <span class="number">0</span>,             <span class="comment">// 正常</span></span><br><span class="line">    ERROR               <span class="comment">// 异常</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadTask</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数：传入线程名字、起始数、结束数、线程编号</span></span><br><span class="line">    <span class="built_in">ThreadTask</span>(<span class="type">const</span> string&amp; name, <span class="type">int</span> begin, <span class="type">int</span> end, <span class="type">int</span> id)</span><br><span class="line">        : _name(name), _begin(begin), _end(end), _id(id),</span><br><span class="line">          _result(<span class="number">0</span>), _status(Status::OK)</span><br><span class="line">    &#123;&#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">ThreadTask</span>() &#123;&#125;    <span class="comment">// 析构函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程的实际任务函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = _begin; i &lt;= _end; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            _result += i;           <span class="comment">// 计算指定区间的和</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;线程[%s]运行完毕，计算[%d~%d]结束\n&quot;</span>, _name.<span class="built_in">c_str</span>(), _begin, _end);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// pthread_exit：线程结束时返回一个指针（被主线程pthread_join获取）</span></span><br><span class="line">        <span class="built_in">pthread_exit</span>(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string _name;           <span class="comment">// 线程名称</span></span><br><span class="line">    <span class="type">int</span> _begin;             <span class="comment">// 区间起点</span></span><br><span class="line">    <span class="type">int</span> _end;               <span class="comment">// 区间终点</span></span><br><span class="line">    <span class="type">int</span> _id;                <span class="comment">// 线程编号</span></span><br><span class="line">    <span class="type">int</span> _result;            <span class="comment">// 计算结果</span></span><br><span class="line">    Status _status;         <span class="comment">// 线程状态</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程入口函数（全局函数 / 静态函数）</span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">threadEntry</span><span class="params">(<span class="type">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// static_cast&lt;T*&gt; 是 C++ 的类型转换运算符：用于在编译时进行类型安全的指针转换</span></span><br><span class="line">    ThreadTask* task = <span class="built_in">static_cast</span>&lt;ThreadTask*&gt;(arg);</span><br><span class="line"></span><br><span class="line">    task-&gt;<span class="built_in">run</span>();                                <span class="comment">// 执行实际任务（内部调用 pthread_exit 退出线程）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;                             <span class="comment">// 实际不会执行到这里，因为 run() 中直接退出了线程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> THREAD_NUM = <span class="number">4</span>;                   <span class="comment">// 总线程数量</span></span><br><span class="line">    <span class="type">pthread_t</span> tids[THREAD_NUM];                 <span class="comment">// 线程ID数组</span></span><br><span class="line">    ThreadTask* tasks[THREAD_NUM];              <span class="comment">// 每个线程绑定一个任务对象</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> range = <span class="number">100</span>;                            <span class="comment">// 每个线程负责计算100个数的和</span></span><br><span class="line">    <span class="type">int</span> start = <span class="number">1</span>;                              <span class="comment">// 区间起始点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; THREAD_NUM; ++i)        <span class="comment">// 创建线程</span></span><br><span class="line">    &#123;</span><br><span class="line">        string name = <span class="string">&quot;Thread-&quot;</span> + <span class="built_in">to_string</span>(i + <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> end = start + range - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        tasks[i] = <span class="keyword">new</span> <span class="built_in">ThreadTask</span>(name, start, end, i + <span class="number">1</span>);     <span class="comment">// 创建一个任务对象</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建线程，执行 threadEntry 函数，参数传入任务对象指针</span></span><br><span class="line">        <span class="built_in">pthread_create</span>(&amp;tids[i], <span class="literal">nullptr</span>, threadEntry, tasks[i]);</span><br><span class="line"></span><br><span class="line">        start = end + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);                                <span class="comment">// 保证顺序输出（演示效果）</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; THREAD_NUM; ++i)         <span class="comment">// 等待线程结束 + 收集结果</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">void</span>* ret = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">pthread_join</span>(tids[i], &amp;ret);             <span class="comment">// pthread_join 等待线程退出，并获取其返回值</span></span><br><span class="line"></span><br><span class="line">        ThreadTask* task = <span class="built_in">static_cast</span>&lt;ThreadTask*&gt;(ret);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (task-&gt;_status == Status::OK)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s计算[%d~%d]结果: %d\n&quot;</span>, task-&gt;_name.<span class="built_in">c_str</span>(), task-&gt;_begin, task-&gt;_end, task-&gt;_result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s执行失败！\n&quot;</span>, task-&gt;_name.<span class="built_in">c_str</span>());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">delete</span> task;                            <span class="comment">// 释放任务对象资源</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;所有线程协作完成！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-多线程特性综合演示"><a href="#3-多线程特性综合演示" class="headerlink" title="3. 多线程特性综合演示"></a>3. 多线程特性综合演示</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NUM 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// __thread 是 GCC 提供的线程局部存储关键字，用于声明在函数内的变量，每个线程都有自己的副本，互不干扰。</span></span><br><span class="line">__thread <span class="type">unsigned</span> <span class="type">int</span> thread_local_number = <span class="number">0</span>;     <span class="comment">// 每个线程独有</span></span><br><span class="line">__thread <span class="type">int</span> thread_local_pid = <span class="number">0</span>;                 <span class="comment">// 每个线程独有</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">threadData</span>                                  <span class="comment">// 线程数据结构</span></span><br><span class="line">&#123;</span><br><span class="line">    string threadname;                             <span class="comment">// 线程名称</span></span><br><span class="line">    <span class="type">int</span> thread_id;                                 <span class="comment">// 线程编号</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">toHex</span><span class="params">(<span class="type">pthread_t</span> tid)</span>                        <span class="comment">// 将pthread_t转换为十六进制字符串（便于显示）</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">128</span>];</span><br><span class="line">    <span class="built_in">snprintf</span>(buffer, <span class="built_in">sizeof</span>(buffer), <span class="string">&quot;0x%lx&quot;</span>, tid);<span class="comment">// 使用%lx格式化pthread_t</span></span><br><span class="line">    <span class="keyword">return</span> buffer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitThreadData</span><span class="params">(threadData* td, <span class="type">int</span> number)</span>    <span class="comment">// 初始化线程数据</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    td-&gt;threadname = <span class="string">&quot;thread-&quot;</span> + <span class="built_in">to_string</span>(number);<span class="comment">// 设置线程名称</span></span><br><span class="line">    td-&gt;thread_id = number;                        <span class="comment">// 设置线程ID</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">threadRoutine</span><span class="params">(<span class="type">void</span>* args)</span>                    <span class="comment">// 线程执行函数 - 所有线程都执行这个函数，但每个线程的数据是独立的</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">pthread_detach</span>(<span class="built_in">pthread_self</span>());                <span class="comment">// 立即将当前线程设置为分离状态，这样线程结束后会自动释放资源，无需主线程join</span></span><br><span class="line"></span><br><span class="line">    threadData* td = <span class="built_in">static_cast</span>&lt;threadData*&gt;(args);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前线程ID和进程ID</span></span><br><span class="line">    string tid_str = <span class="built_in">toHex</span>(<span class="built_in">pthread_self</span>());        <span class="comment">// 当前线程的ID</span></span><br><span class="line">    <span class="type">int</span> process_pid = <span class="built_in">getpid</span>();                    <span class="comment">// 进程ID（所有线程共享）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化线程局部变量</span></span><br><span class="line">    thread_local_number = td-&gt;thread_id * <span class="number">100</span>;     <span class="comment">// 每个线程有不同的值</span></span><br><span class="line">    thread_local_pid = process_pid;                <span class="comment">// 每个线程都有自己的副本</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;[&quot;</span> &lt;&lt; td-&gt;threadname &lt;&lt; <span class="string">&quot;] 启动！&quot;</span></span><br><span class="line">        &lt;&lt; <span class="string">&quot;线程ID: &quot;</span> &lt;&lt; tid_str</span><br><span class="line">        &lt;&lt; <span class="string">&quot;, 进程ID: &quot;</span> &lt;&lt; process_pid</span><br><span class="line">        &lt;&lt; <span class="string">&quot;, 线程局部变量 number: &quot;</span> &lt;&lt; thread_local_number &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)                    <span class="comment">// 减少循环次数便于观察</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 展示线程的关键特性：</span></span><br><span class="line">        <span class="comment">// 1. 同一进程内的所有线程共享进程ID</span></span><br><span class="line">        <span class="comment">// 2. 每个线程有自己的线程ID</span></span><br><span class="line">        <span class="comment">// 3. 每个线程有自己的线程局部存储变量</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;[&quot;</span> &lt;&lt; td-&gt;threadname &lt;&lt; <span class="string">&quot;] &quot;</span> &lt;&lt; <span class="string">&quot;第&quot;</span> &lt;&lt; (i + <span class="number">1</span>) &lt;&lt; <span class="string">&quot;次执行：&quot;</span></span><br><span class="line">            &lt;&lt; <span class="string">&quot;线程ID: &quot;</span> &lt;&lt; tid_str</span><br><span class="line">            &lt;&lt; <span class="string">&quot;, 进程ID: &quot;</span> &lt;&lt; process_pid</span><br><span class="line">            &lt;&lt; <span class="string">&quot;, 局部number: &quot;</span> &lt;&lt; thread_local_number</span><br><span class="line">            &lt;&lt; <span class="string">&quot;, 局部pid: &quot;</span> &lt;&lt; thread_local_pid &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);                                   <span class="comment">// 休眠1秒</span></span><br><span class="line">        thread_local_number++;                      <span class="comment">// 修改线程局部变量（只影响当前线程）</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;[&quot;</span> &lt;&lt; td-&gt;threadname &lt;&lt; <span class="string">&quot;] 执行完毕!&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> td;                                      <span class="comment">// 清理分配的内存</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;                                 <span class="comment">// 返回nullptr表示线程正常结束</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;主线程ID: &quot;</span> &lt;&lt; <span class="built_in">toHex</span>(<span class="built_in">pthread_self</span>()) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;进程ID: &quot;</span> &lt;&lt; <span class="built_in">getpid</span>() &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">pthread_t</span>&gt; tids;                         <span class="comment">// 存储所有线程ID的容器</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;开始创建 &quot;</span> &lt;&lt; NUM &lt;&lt; <span class="string">&quot; 个线程...&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM; i++)                   <span class="comment">// 创建多个线程</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">pthread_t</span> tid;                              <span class="comment">// 线程ID变量</span></span><br><span class="line">        threadData* td = <span class="keyword">new</span> threadData;            <span class="comment">// 为每个线程分配独立的数据</span></span><br><span class="line">        <span class="built_in">InitThreadData</span>(td, i);                      <span class="comment">// 初始化线程数据</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ret = <span class="built_in">pthread_create</span>(&amp;tid, <span class="literal">nullptr</span>, threadRoutine, td);</span><br><span class="line">        <span class="keyword">if</span> (ret != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cerr &lt;&lt; <span class="string">&quot;创建线程失败: &quot;</span> &lt;&lt; <span class="built_in">strerror</span>(ret) &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">delete</span> td;                              <span class="comment">// 创建失败时释放内存</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;成功创建线程 &quot;</span> &lt;&lt; td-&gt;threadname &lt;&lt; <span class="string">&quot; (ID: &quot;</span> &lt;&lt; <span class="built_in">toHex</span>(tid) &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        tids.<span class="built_in">push_back</span>(tid);                        <span class="comment">// 保存线程ID</span></span><br><span class="line">        <span class="built_in">usleep</span>(<span class="number">100000</span>);                             <span class="comment">// 延时0.1秒，确保线程正确启动</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n所有线程创建完成，主线程等待...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">2</span>);                                       <span class="comment">// 给线程一些执行时间</span></span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n=== 尝试对分离线程进行join操作 ===&quot;</span> &lt;&lt; endl;     <span class="comment">// 尝试对分离线程进行join操作（这会失败）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; tids.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> result = <span class="built_in">pthread_join</span>(tids[i], <span class="literal">nullptr</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;对线程 0x%lx 执行join的结果: %d (%s)\n&quot;</span>, tids[i], result, <span class="built_in">strerror</span>(result));</span><br><span class="line">        <span class="comment">// 由于线程已被分离，这里会返回EINVAL（无效参数）</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;1. 线程共享进程资源（如进程ID、文件描述符等）&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;2. 每个线程有自己的线程ID和栈空间&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;3. __thread关键字创建线程局部存储变量&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;4. 分离线程结束后自动释放资源&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;5. 分离线程不能被pthread_join回收&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;6. 线程执行是并发的，输出顺序不同&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n主线程继续执行中...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;主线程执行完毕，程序退出！&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>039 线程概念</title>
      <link href="/posts/25951.html"/>
      <url>/posts/25951.html</url>
      
        <content type="html"><![CDATA[<h1 id="线程概念"><a href="#线程概念" class="headerlink" title="线程概念"></a>线程概念</h1><h2 id="1-什么是线程？它和进程的关系？"><a href="#1-什么是线程？它和进程的关系？" class="headerlink" title="1. 什么是线程？它和进程的关系？"></a>1. 什么是线程？它和进程的关系？</h2><h3 id="1-粒度：执行的“颗粒大小”"><a href="#1-粒度：执行的“颗粒大小”" class="headerlink" title="1. 粒度：执行的“颗粒大小”"></a>1. 粒度：执行的“颗粒大小”</h3><p><strong>粒度（Granularity）</strong> 是个比喻术语，表示一个单位在调度或执行上的“精细程度”。举例说明：</p><ul><li><p><strong>进程</strong> 是一个较大单位（粗粒度）：拥有独立地址空间、资源。</p></li><li><p><strong>线程</strong> 是进程内部的小单位（细粒度）：共享地址空间，调度更轻便。</p></li><li><p>比喻一下：一个公司（进程）可能有多个部门（线程），每个部门是公司内部的执行单位，共享同一个资源（办公室、资金）。</p></li></ul><blockquote><p><strong>线程执行进程的代码（粒度细）</strong></p><ul><li>多线程可以同时执行同一个进程的多个代码分支，这比进程切换效率高。</li><li>一个进程内部多个线程共同完成任务，就像车间里多个工人一起干活。</li></ul></blockquote><h3 id="2-线程的定义"><a href="#2-线程的定义" class="headerlink" title="2. 线程的定义"></a>2. 线程的定义</h3><p><strong>线程是操作系统调度的最小执行单位。</strong></p><ul><li><p>在用户&#x2F;开发者角度看：线程是进程中的“执行分支”，多个线程可以并发执行进程中的不同任务。</p></li><li><p>在内核角度看：内核调度的是线程（Linux 称为“轻量级进程”），不是传统意义上的进程。</p></li><li><p>CPU 视角：只有“执行流”，每个 task_struct（无论是进程还是线程）在 CPU 看来都是“可调度实体”。因此 Linux 把线程干脆叫“轻量级进程”——名字里仍带“进程”，只是资源复用程度不同。</p></li></ul><blockquote><p><strong>执行流 &#x3D; CPU 上能被调度运行的最小单位</strong>，无论是：主线程执行 <code>main()</code>、子线程处理任务、内核线程处理 I&#x2F;O、甚至信号处理函数上下文切换，本质上，它们都是“一个在 CPU 上执行的流动单元”。所以我们抽象地称它为 <strong>执行流</strong>。</p><hr><p><strong>CPU 只调度执行流</strong>（线程）：CPU 的调度单位是线程（执行流），不是进程。所以：CPU 只管“谁来执行”，而不是“哪个进程”执行。</p></blockquote><h3 id="3-Linux-中线程的实现方式？"><a href="#3-Linux-中线程的实现方式？" class="headerlink" title="3. Linux 中线程的实现方式？"></a>3. Linux 中线程的实现方式？</h3><blockquote><p><strong>PCB 结构理解（进程是资源实体）：进程 &#x3D; PCB（Process Control Block） + 代码&#x2F;数据</strong></p><ul><li>PCB 记录了进程的所有管理信息（PID、状态、内存映射、文件表等）。</li><li>线程依附进程执行，不拥有自己的完整 PCB，只在进程的 PCB 中挂靠自己的线程控制块。</li></ul></blockquote><p>Linux 并没有原生的“线程”这个独立结构，而是通过内核的 <strong>进程机制（task_struct）</strong> 来实现线程，无论是普通进程、还是线程，<strong>在内核中都是 <code>task_struct</code> 实例</strong>。在 Linux 中，线程就是一种特殊的“进程”，又叫 <strong>轻量级进程（Lightweight Process，LWP）</strong>。多个线程共享同一个进程的资源（代码段、数据段、堆、文件描述符等），但有自己独立的：</p><ul><li><strong>栈空间（私有栈）</strong></li><li><strong>寄存器现场（上下文）</strong></li><li><strong>线程 ID（TID）</strong></li></ul><blockquote><p>  [!NOTE]</p><p>  <strong>那这样做的好处（优雅性）是什么？</strong></p><p>  这正是 Linux&#x2F;OS 设计哲学的体现：</p><ul><li>统一的数据结构，简化调度系统。</li><li>灵活的共享机制。</li><li>复用代码（内核的数据结构），降低 bug 的可能性和维护难度。</li></ul></blockquote><blockquote><p>Windows 内核线程是“<strong>真正意义上的线程</strong>”：Windows 内核中有 <strong>线程控制块</strong>，叫做 <strong>TCB（<code>struct TCB</code>，Thread Control Block）</strong>。它是 <strong>Windows 原生线程结构</strong>，用于记录线程上下文、栈地址、状态等，是 Windows 的调度单位。Windows 中，<strong>进程是资源容器</strong>，线程是独立的执行单位，系统明确区分这两个概念。</p></blockquote><h3 id="4-为什么线程要在进程“内部”执行？"><a href="#4-为什么线程要在进程“内部”执行？" class="headerlink" title="4. 为什么线程要在进程“内部”执行？"></a>4. 为什么线程要在进程“内部”执行？</h3><ul><li><strong>原因：线程不拥有自己的资源，必须依附进程的资源（如地址空间）才能执行。</strong> 任何执行流想跑起来都必须：<strong>有代码（指令）、有栈、有页表（地址空间）</strong>（加粗是必要条件！），全部条件还需要 task_struct（调度实体）、上下文。</li><li>所以：“地址空间是进程的资源窗口”，线程就是进程内部的执行分支。线程“在进程地址空间内跑”不是可选，而是必选项；离了地址空间，CPU 连下一条指令在哪都不知道。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250720155626731.png" alt="image-20250720155626624"></p><h3 id="5-进程-vs-线程"><a href="#5-进程-vs-线程" class="headerlink" title="5. 进程 vs 线程"></a>5. 进程 vs 线程</h3><blockquote><p><a href="https://www.bilibili.com/video/BV1H541187UH/?share_source=copy_web&vd_source=872e5e3ccf44874c39edaf42e30ab0de">【os 浅尝】话说进程和线程~ | B 站</a><br><a href="https://www.bilibili.com/video/BV1aw411M7xT/?share_source=copy_web&vd_source=872e5e3ccf44874c39edaf42e30ab0de">进程和线程的区别 | B 站</a><br><a href="https://www.bilibili.com/video/BV1Wr4y1P7Yr/?share_source=copy_web&vd_source=872e5e3ccf44874c39edaf42e30ab0de">【操作系统】进程和线程的区别 | B 站</a><br><a href="https://www.bilibili.com/video/BV1eR4y147fv/?share_source=copy_web&vd_source=872e5e3ccf44874c39edaf42e30ab0de">线程、进程和应用程序的关系和原理（干货教程） | B 站</a></p></blockquote><table><thead><tr><th>对比点</th><th>进程</th><th>线程</th></tr></thead><tbody><tr><td>是否独立</td><td>独立，拥有自己的地址空间、页表</td><td>依附于进程，共享进程地址空间</td></tr><tr><td>是否拥有资源</td><td>是，拥有文件描述符、内存等</td><td>否，只拥有少量运行所需资源</td></tr><tr><td>调度粒度</td><td>粗（整个进程调度）</td><td>细（线程调度）</td></tr><tr><td>创建&#x2F;销毁开销</td><td>大（复制页表、资源）</td><td>小（切换栈、寄存器）</td></tr><tr><td>通信效率</td><td>低（需进程间通信 IPC）</td><td>高（共享内存）</td></tr><tr><td>健壮性</td><td>进程崩溃不影响其他进程</td><td>线程崩溃导致整个进程崩溃</td></tr></tbody></table><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250720160747723.png" alt="image-20250720160747631"></p><h2 id="2-页表"><a href="#2-页表" class="headerlink" title="2. 页表"></a>2. 页表</h2><blockquote><p><a href="https://www.bilibili.com/video/BV1uY411k73T/?share_source=copy_web&vd_source=872e5e3ccf44874c39edaf42e30ab0de">页式存储管理讲解 | B 站</a></p><p><a href="https://www.bilibili.com/video/BV1Fb4y1y7wr/?share_source=copy_web&vd_source=872e5e3ccf44874c39edaf42e30ab0de">「Coding Master」第 30 话 这个内存分页，就挺难的 | B 站</a></p><p><a href="https://www.bilibili.com/video/BV1XD2gYrEuZ/?share_source=copy_web&vd_source=872e5e3ccf44874c39edaf42e30ab0de">CPU 眼里的：二级页表 | MMU | 虚拟内存 | B 站</a></p><p><a href="https://www.cnblogs.com/binlovetech/p/17571929.html">一步一图带你构建 Linux 页表体系 —— 详解虚拟内存如何与物理内存进行映射 | 博客园</a></p></blockquote><h3 id="1-什么是页表（Page-Table）？"><a href="#1-什么是页表（Page-Table）？" class="headerlink" title="1. 什么是页表（Page Table）？"></a>1. 什么是页表（Page Table）？</h3><h4 id="1-本质"><a href="#1-本质" class="headerlink" title="1. 本质"></a>1. 本质</h4><p>页表是操作系统用来 <strong>管理虚拟地址与物理地址映射关系</strong> 的数据结构。每个进程都有自己的 <strong>虚拟地址空间</strong> ，而页表就是这个地址空间的“地图”，告诉 CPU 如何将一个虚拟地址转换为物理地址。<strong>简单说：我们访问的是虚拟地址，系统通过页表找出对应的物理地址。</strong></p><h4 id="2-页表的核心单位"><a href="#2-页表的核心单位" class="headerlink" title="2. 页表的核心单位"></a>2. 页表的核心单位</h4><table><thead><tr><th>名称</th><th>含义</th><th>单位</th><th>特点</th><th>举例</th></tr></thead><tbody><tr><td><strong>页面（Page）</strong></td><td>虚拟地址空间被划分为固定大小的块</td><td>通常为 4KB</td><td>虚拟地址的基本单位</td><td>每个页面对应一个物理页框</td></tr><tr><td><strong>页框 &#x2F; 页帧（Page Frame）</strong></td><td>物理内存被划分为固定大小的块</td><td>通常为 4KB</td><td>存放页面数据的物理单元</td><td>物理内存中的 4KB 单元</td></tr><tr><td><strong>页目录项（PDE）</strong></td><td>一级页表项，指向页表</td><td>4 字节（32 位）</td><td>页目录有 1024 项</td><td>PDE [i] → 页表起始地址</td></tr><tr><td><strong>页表项（PTE）</strong></td><td>二级页表项，指向页框</td><td>4 字节（32 位）</td><td>PTE [i] → 页框起始地址</td><td>用于虚拟地址到物理地址映射</td></tr><tr><td><strong>页内偏移（Offset）</strong></td><td>页内地址偏移量</td><td>12 位（0~4095）</td><td>用于在页框中定位具体字节</td><td>偏移量 + 页框地址 &#x3D; 物理地址</td></tr></tbody></table><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250720151706465.png" alt="image-20250720151706339"></p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250720152800895.png" alt="image-20250720152800793"></p><h4 id="3-为什么需要页表？"><a href="#3-为什么需要页表？" class="headerlink" title="3. 为什么需要页表？"></a>3. 为什么需要页表？</h4><p><strong>页表是实现虚拟内存机制的基础，二级页表是为了节省内存并提高效率，多级页表则是为了支持更大的地址空间和更灵活的管理方式。</strong> </p><p><strong>为什么需要二级页表？</strong></p><p>单级页表的问题（以 32 位系统为例）：32 位系统地址空间为 <strong>4GB（2^32）</strong>，页大小为 <strong>4KB（2^12）</strong>，总共需要 <strong>2^20 &#x3D; 1,048,576 个页表项</strong>，每个页表项 4 字节，总大小为 <strong>4MB</strong>。所以：<strong>页表大小 &#x3D; 2²⁰ × 4B &#x3D; 4MB，每个进程都要维护一张 4MB 的页表（即使它只用了一点虚拟内存）</strong>，这对于上了年代的机器来说是灾难性设计！</p><p><strong>就是因为占内存大、浪费严重、不支持“按需分配”所以诞生了二级页表，二级页表是对“空间换时间”的优化倒转 —— 用时间（多查一次）换空间（只分配用到的），再到后来的多级页表：节省空间、支持按需映射、提升效率。</strong></p><h4 id="4-32-位系统中二级页表的工作原理结构图"><a href="#4-32-位系统中二级页表的工作原理结构图" class="headerlink" title="4. 32 位系统中二级页表的工作原理结构图"></a>4. 32 位系统中二级页表的工作原理结构图</h4><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250720153638857.png" alt="image-20250720153638765"></p><h5 id="1-分解说明"><a href="#1-分解说明" class="headerlink" title="1. 分解说明"></a>1. 分解说明</h5><ul><li><p><strong>虚拟地址 &#x3D; 32 位：</strong> 虚拟地址由 3 部分组成：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[10位 页目录索引] [10位 页表索引] [12位 页内偏移]</span><br><span class="line">(2^10 条)        (2^10 条)      (4KB 页面)</span><br></pre></td></tr></table></figure></li><li><p><strong>页大小 &#x3D; 4KB &#x3D; 2¹²：</strong> 最后 12 位表示页内偏移（Offset）</p></li><li><p><strong>页表项大小 &#x3D; 4 字节（32bit）：</strong> 一个页表（4KB）能容纳：4KB ÷ 4B &#x3D; <strong>1024 条项</strong>，刚好对应 2¹⁰。</p></li></ul><h5 id="2-x86-32-10-10-12-的意义"><a href="#2-x86-32-10-10-12-的意义" class="headerlink" title="2. x86 32 &#x3D; 10+10+12 的意义"></a>2. x86 32 &#x3D; 10+10+12 的意义</h5><p><strong>虚拟地址 32 位 &#x3D; 10（页目录）+ 10（页表）+ 12（偏移）</strong></p><table><thead><tr><th>段</th><th>位数</th><th>说明</th></tr></thead><tbody><tr><td>页目录</td><td>10</td><td>一级表，存放 <strong>页表的指针</strong>，选择哪个页表（共 1024 个）</td></tr><tr><td>页表</td><td>10</td><td>二级表，存放 <strong>页 → 物理帧</strong> 映射，选择哪个页表项</td></tr><tr><td>偏移</td><td>12</td><td>不变，表示页中具体偏移地址（4KB 页大小）</td></tr></tbody></table><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250720154605841.png" alt="image-20250720154605759"></p><h2 id="3-再谈线程"><a href="#3-再谈线程" class="headerlink" title="3. 再谈线程"></a>3. 再谈线程</h2><h3 id="1-线程的优点（相对进程）"><a href="#1-线程的优点（相对进程）" class="headerlink" title="1. 线程的优点（相对进程）"></a>1. 线程的优点（相对进程）</h3><table><thead><tr><th align="center">编号</th><th>优点描述</th><th>解释说明或场景举例</th></tr></thead><tbody><tr><td align="center">1</td><td>创建开销小</td><td>新线程共享父进程资源，不需要重新分配地址空间等</td></tr><tr><td align="center">2</td><td>上下文切换代价小</td><td>线程切换只需切换少量寄存器，进程切换需切页表等</td></tr><tr><td align="center">3</td><td>占用资源少</td><td>共享代码段、数据段、堆等，减少内存资源开销</td></tr><tr><td align="center">4</td><td>支持并发执行</td><td>多线程可利用多核 CPU，提高执行效率</td></tr><tr><td align="center">5</td><td>提升 IO 密集程序性能</td><td>下载、读写磁盘等可异步等待，主线程可继续执行</td></tr><tr><td align="center">6</td><td>提升计算密集程序性能（多核）</td><td>可将任务拆分成多个子任务，多个核并行执行</td></tr><tr><td align="center">7</td><td>IO 操作可并发等待，提高吞吐</td><td>多线程各自等待不同 IO 资源，实现重叠与效率提升</td></tr></tbody></table><h3 id="2-线程的缺点"><a href="#2-线程的缺点" class="headerlink" title="2. 线程的缺点"></a>2. 线程的缺点</h3><table><thead><tr><th align="center">编号</th><th>缺点描述</th><th>举例或解释</th></tr></thead><tbody><tr><td align="center">1</td><td>同步&#x2F;调度带来性能损失</td><td>多个计算密集型线程争抢 CPU，带来线程调度&#x2F;同步开销</td></tr><tr><td align="center">2</td><td>健壮性降低</td><td>不小心共享了不该共享的变量，或同步出错易出 bug</td></tr><tr><td align="center">3</td><td>缺乏访问隔离保护</td><td>所有线程共享进程资源，某线程异常可能影响整个进程</td></tr><tr><td align="center">4</td><td>编程难度高</td><td>多线程程序调试困难，如死锁、竞态条件难定位</td></tr></tbody></table><h3 id="3-线程异常处理风险（容易忽略）"><a href="#3-线程异常处理风险（容易忽略）" class="headerlink" title="3. 线程异常处理风险（容易忽略）"></a>3. 线程异常处理风险（容易忽略）</h3><table><thead><tr><th>问题</th><th>描述说明</th></tr></thead><tbody><tr><td>崩溃传染性强</td><td>一个线程崩溃（如除 0、野指针），触发信号机制，整个进程被终止</td></tr><tr><td>同步问题</td><td>锁没加好、条件变量判断失误，可能引发死锁、数据污染等不可预测问题</td></tr><tr><td>资源泄漏</td><td>某线程提前崩溃未释放资源，整个进程泄漏，所有线程随之退出</td></tr></tbody></table><h3 id="4-线程适用场景（牢记）"><a href="#4-线程适用场景（牢记）" class="headerlink" title="4. 线程适用场景（牢记）"></a>4. 线程适用场景（牢记）</h3><table><thead><tr><th>场景</th><th>类型</th><th>描述示例</th></tr></thead><tbody><tr><td>CPU 密集型</td><td>多核计算</td><td>视频渲染、图片处理、机器学习模型训练、加密解密</td></tr><tr><td>IO 密集型</td><td>高并发 IO</td><td>网络爬虫、数据库操作、磁盘文件下载、日志写入</td></tr><tr><td>用户体验优化</td><td>前后台并行处理</td><td>一边写代码一边下载依赖，一边加载图片一边展示 UI</td></tr></tbody></table><h3 id="5-记忆口诀"><a href="#5-记忆口诀" class="headerlink" title="5. 记忆口诀"></a>5. 记忆口诀</h3><ul><li>线程优点快轻小，共享资源效率高；</li><li>线程缺点易崩溃，调试困难需谨慎；</li><li>CPU 并行靠分工，IO 并发靠等待；</li><li>善用线程提性能，滥用线程埋雷坑。</li></ul><blockquote><p>  线程相较于进程最大的优势是开销小、切换快、共享资源，适合高并发或高性能场景。比如在多核处理器中跑 CPU 密集任务，或者处理大量 IO 等待时都能有效提升效率。但线程也存在缺乏隔离、同步复杂、异常传播等风险，因此使用时需要严格管理共享资源和同步机制。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>038 进程信号 —— 信号的处理</title>
      <link href="/posts/15091.html"/>
      <url>/posts/15091.html</url>
      
        <content type="html"><![CDATA[<h1 id="进程信号-——-信号的处理"><a href="#进程信号-——-信号的处理" class="headerlink" title="进程信号 —— 信号的处理"></a>进程信号 —— 信号的处理</h1><blockquote><p><a href="https://yohifo.blog.csdn.net/article/details/131474866">Linux 进程信号【信号处理】 | CSDN</a></p></blockquote><h2 id="1-捕捉-处理信号（进程地址空间）"><a href="#1-捕捉-处理信号（进程地址空间）" class="headerlink" title="1. 捕捉&#x2F;处理信号（进程地址空间）"></a>1. 捕捉&#x2F;处理信号（进程地址空间）</h2><h3 id="1-内核空间与用户空间"><a href="#1-内核空间与用户空间" class="headerlink" title="1. 内核空间与用户空间"></a>1. 内核空间与用户空间</h3><p>每一个进程都有自己的进程地址空间，该进程地址空间由内核空间和用户空间组成：</p><ul><li>用户所写的代码和数据位于用户空间，通过用户级页表与物理内存之间建立映射关系。</li><li>内核空间存储的实际上是操作系统代码和数据，通过内核级页表与物理内存之间建立映射关系。</li></ul><p>内核级页表是一个全局的页表，它用来维护操作系统的代码与进程之间的关系。因此，在每个进程的进程地址空间中，用户空间是属于当前进程的，每个进程看到的代码和数据是完全不同的，但内核空间所存放的都是操作系统的代码和数据，所有进程看到的都是一样的内容。</p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250717230508929.png" alt="image-20250717230508790"></p><blockquote><ul><li><strong>操作系统本质上就是一个“基于时钟中断的死循环”</strong> ，它通过中断机制不断调度任务，实现多任务并发的“假象”。 OS 本身并没有“结束”的时候，它一直在“看有没有事要做”。 它开机后就进入一个大循环：看有没有进程要运行（调度）、看有没有中断发生、处理完后继续循环，这个循环不会退出，除非关机。</li><li><strong>时钟中断就像是操作系统的心跳，每隔一段时间就“敲一下操作系统”：“该换人干活了！”</strong> 计算机硬件中有一个 <strong>时钟芯片</strong>，它每隔一定时间（微秒级）发出一个 <strong>时钟中断</strong>，OS 利用这个中断来做 <strong>时间片调度</strong>。</li></ul><p>此外我们也会发现一个很有意思的事情：无论是台式机&#x2F;笔记本，在开机后，无论联网与否，时间总是准的，原因是计算机主板中存在很小的纽扣电池，它负责在电脑断电时维持实时时钟（RTC）的运行，从而保证时间不会丢失，当机器断电数月后才可能开机后时间不准。</p><hr><p><strong>举个生活例子：餐厅的叫号系统</strong></p><p>你去餐厅吃饭，点完菜后坐等。</p><ul><li><strong>时钟中断</strong> ：就像服务员每隔一段时间查看叫号系统。</li><li><strong>进程调度</strong> ：服务员看到你号码到了，叫你去取餐。</li><li><strong>死循环</strong> ：服务员一直在柜台后面转悠，不停地看有没有新号码要处理。</li></ul><p>操作系统就像这个服务员，一直在“看有没有事做”。</p></blockquote><h3 id="2-什么是用户态和内核态？"><a href="#2-什么是用户态和内核态？" class="headerlink" title="2. 什么是用户态和内核态？"></a>2. 什么是用户态和内核态？</h3><table><thead><tr><th align="center">状态</th><th>特征</th><th align="center">权限等级</th><th>能做什么</th></tr></thead><tbody><tr><td align="center">用户态</td><td>执行用户代码，如普通应用程序</td><td align="center">低</td><td>只能访问用户空间，不能访问硬件</td></tr><tr><td align="center">内核态</td><td>执行操作系统核心代码</td><td align="center">高</td><td>可以访问内核空间、控制硬件、管理内存、调度任务等</td></tr></tbody></table><p><strong>用户态不能直接访问内核态的数据，否则整个系统会变得非常不安全！</strong></p><blockquote><p><strong>用户态和内核态的切换是由 CPU 的特权级机制控制的，CS 寄存器的 RPL 字段决定当前执行代码的权限级别，<code>int 0x80</code> 是一种触发系统调用、切换到内核态的方式，CR3 寄存器用于管理进程的虚拟地址空间，通常在进程切换时变化，但在用户态 ↔ 内核态切换时不变化。</strong></p><p><a href="https://www.linfo.org/int_0x80.html">int 0x80 定义</a><br><a href="https://www.wolai.com/tengfei-xy/kLNCWmZcDwhbFoa9ZXENMB">int 0x80</a><br><a href="https://medium.com/@sachinrajakaruna95/exploring-the-evolution-of-system-call-mechanisms-in-linux-from-int-0x80-to-syscall-e133bb5c151a">探索 Linux 系统调用机制的演变：<code>int 0x80</code> 到 <code>syscall</code></a></p><p>特权级、ecs、CR3 寄存器这些内容不做重点，点到为止了，个人能力有限，讲不太明白 🥹。</p></blockquote><h3 id="3-什么是进程切换？"><a href="#3-什么是进程切换？" class="headerlink" title="3. 什么是进程切换？"></a>3. 什么是进程切换？</h3><blockquote><p><a href="https://blog.csdn.net/qq_43176812/article/details/117414208">【操作系统】进程切换到底是怎么个过程？| CSDN</a><br><a href="https://www.cnblogs.com/linguoguo/p/15873318.html">进程切换原理 | 博客园</a><br><a href="https://blog.csdn.net/qq_43762337/article/details/130373470">深入理解进程切换 | CSDN</a></p></blockquote><p>“进程切换”是指 <strong>CPU 当前执行的进程被挂起，另一个进程被调度到 CPU 上运行</strong>，这是一种 <strong>上下文切换</strong>。<strong>所以：进程切换 &#x3D; 保存旧进程的状态 + 加载新进程的状态 + CPU 执行新进程的代码。</strong> 进程切换不仅是操作系统内部实现并发的核心机制，也是作为系统程序员写代码时需要“尽量避免过度调度”的重要优化点。</p><blockquote><ol><li><strong>保存当前进程的状态（上下文）</strong></li></ol><p>操作系统会把当前正在运行的进程的“执行状态”保存下来，比如：</p><ul><li>程序计数器（PC）：下一条要执行哪条指令</li><li>寄存器的值：临时数据</li><li>栈指针、堆栈信息：函数调用现场</li></ul><p>这些信息保存在 <strong>进程控制块（PCB）</strong> 中。</p><ol start="2"><li><p><strong>选择下一个要运行的进程（调度）：</strong> 操作系统通过调度器（scheduler）决定下一个该谁运行。</p></li><li><p><strong>加载下一个进程的状态</strong></p></li></ol><p>操作系统从下一个进程的 PCB 中加载它的上下文，包括：</p><ul><li>程序计数器（PC）</li><li>寄存器内容</li><li>栈信息</li></ul><ol start="4"><li><strong>继续执行下一个进程：</strong> CPU 开始执行下一个进程的代码。</li></ol></blockquote><p><strong>注意：用户态 ↔ 内核态切换 ≠ 进程切换</strong></p><table><thead><tr><th>类型</th><th>是否等同切换</th><th>是否改变进程</th><th>是否保存上下文</th><th>触发示例</th></tr></thead><tbody><tr><td>用户态 ↔ 内核态</td><td>❌ 不是进程切换</td><td>❌ 不换进程</td><td>❌ 不换上下文</td><td>系统调用、中断、异常</td></tr><tr><td>进程 A ↔ 进程 B</td><td>✅ 是进程切换</td><td>✅ 换进程</td><td>✅ 保存&#x2F;恢复上下文</td><td>时间片用完、I&#x2F;O 阻塞、调度触发</td></tr></tbody></table><ul><li><strong>用户态 ↔ 内核态：</strong> 你是一个顾客，在银行大厅（用户态）填单子，然后去柜台找工作人员帮你处理转账（进入内核态），处理完你回到大厅继续自己的事。<strong>你没换人，只是权限变了。</strong> </li><li><strong>进程 A ↔ 进程 B 切换：</strong> 你正在银行柜台办事，还没办完，系统叫下一个客户了。工作人员保存你当前的状态（办到哪一步），切换到下一个客户。<strong>你和别人换了，这才是真正的“切换”</strong> 。</li><li><strong>用户态 ↔ 内核态”切换只是权限切换，不换进程；而“进程切换”才是真正换人干活，需要保存和恢复上下文。</strong></li></ul><blockquote><p><strong>按 Ctrl+C 会不会进程切换？</strong></p><p>不一定！</p><ul><li>按 Ctrl+C 会触发 <strong>中断</strong>（来自键盘设备）→ 导致进程进入内核态。</li><li>由内核触发信号发送，进而 <strong>递达信号</strong>，调用 handler（仍在当前进程内）。</li></ul><p>所以：<strong>不会进程切换，只是状态切换为内核态，然后再返回用户态。</strong> 但如果按 Ctrl+C 后进程终止，那么调度器会调度其他进程，<strong>才会产生真正的进程切换</strong>。</p></blockquote><h3 id="4-内核如何捕捉信号？"><a href="#4-内核如何捕捉信号？" class="headerlink" title="4. 内核如何捕捉信号？"></a>4. 内核如何捕捉信号？</h3><p>当进程从内核态准备返回用户态时，内核会检查是否有未决（pending）且未被阻塞的信号。如果信号的处理动作是默认或忽略，内核直接执行对应动作并清除 pending 标志，然后返回用户态继续执行主流程；如果处理动作是用户自定义函数，内核会伪造一次函数调用，让用户态执行该 handler。执行完毕后，通过 <code>sigreturn</code> 系统调用重新进入内核态，清理 pending 标志并恢复进程上下文，最后再次返回用户态，继续执行主控制流程。<strong>信号的捕捉不是直接调用函数，而是由内核精心安排的一次“用户态函数调用 + 内核态恢复”的过程，确保安全、稳定、可控。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250717233930570.png" alt="image-20250717233930425"></p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250717234912834.png" alt="image-20250717234912707"></p><blockquote><p><strong>当识别到信号的处理动作是自定义时，能直接在内核态执行用户空间的代码吗？</strong><br><strong>虽然内核有权限直接执行用户代码，但为了安全和稳定，操作系统绝不允许在内核态直接执行用户定义的代码。用户代码必须在用户态下执行，权限受限，防止破坏系统。</strong></p></blockquote><hr><h2 id="2-sigaction"><a href="#2-sigaction" class="headerlink" title="2. sigaction"></a>2. sigaction</h2><h3 id="1-sigaction-函数原型"><a href="#1-sigaction-函数原型" class="headerlink" title="1. sigaction 函数原型"></a>1. sigaction 函数原型</h3><h4 id="1-功能"><a href="#1-功能" class="headerlink" title="1. 功能"></a>1. 功能</h4><p><strong>用于设置某个信号的处理方式（三种）。<code>sigaction()</code> 是 <code>signal()</code> 的“升级版”，功能更强大、更安全、更可移植，推荐在实际开发中使用它来注册信号处理函数。</strong></p><h4 id="2-函数原型"><a href="#2-函数原型" class="headerlink" title="2. 函数原型"></a>2. 函数原型</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigaction</span><span class="params">(<span class="type">int</span> signum, <span class="type">const</span> <span class="keyword">struct</span> sigaction *act, <span class="keyword">struct</span> sigaction *oldact)</span>;</span><br></pre></td></tr></table></figure><h4 id="3-参数详解"><a href="#3-参数详解" class="headerlink" title="3. 参数详解"></a>3. 参数详解</h4><table><thead><tr><th>参数名</th><th>类型</th><th>含义</th></tr></thead><tbody><tr><td><code>signum</code></td><td><code>int</code></td><td>要设置的信号编号，如 <code>SIGINT</code>（2 号信号）、<code>SIGTERM</code>（15 号信号）等</td></tr><tr><td><code>act</code></td><td><code>const struct sigaction *</code></td><td>新的信号处理方式（结构体指针），可设置 handler、flags、mask 等</td></tr><tr><td><code>oldact</code></td><td><code>struct sigaction *</code></td><td>可选，用于保存旧的处理方式（可用于恢复、可为 <code>NULL</code>）</td></tr></tbody></table><p>其中 <code>struct sigaction</code> 结构体定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sigaction</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">void</span>     (*sa_handler)(<span class="type">int</span>);         <span class="comment">// 简单的信号处理函数（类似 signal 的用法）</span></span><br><span class="line">    <span class="built_in">void</span>     (*sa_sigaction)(<span class="type">int</span>, <span class="type">siginfo_t</span> *, <span class="type">void</span> *);  <span class="comment">// 带详细信息的信号处理函数（需要 SA_SIGINFO 标志）</span></span><br><span class="line">    <span class="type">sigset_t</span>   sa_mask;                  <span class="comment">// 在信号处理函数执行期间额外屏蔽的信号集合</span></span><br><span class="line">    <span class="type">int</span>        sa_flags;                 <span class="comment">// 标志位，控制信号行为（如 SA_RESTART、SA_SIGINFO 等）</span></span><br><span class="line">    <span class="built_in">void</span>     (*sa_restorer)(<span class="type">void</span>);       <span class="comment">// 已废弃，忽略</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="1-sa-handler：最简单的处理函数"><a href="#1-sa-handler：最简单的处理函数" class="headerlink" title="1. sa_handler：最简单的处理函数"></a>1. <code>sa_handler</code>：最简单的处理函数</h5><p>类似 <code>signal()</code> 的用法，接收一个整数参数（信号编号）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">handler</span><span class="params">(<span class="type">int</span> signo)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;收到信号：%d\n&quot;</span>, signo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">act.sa_handler = handler;</span><br></pre></td></tr></table></figure><h5 id="2-sa-sigaction：带详细信息的处理函数（需要配合-SA-SIGINFO-标志使用，了解）"><a href="#2-sa-sigaction：带详细信息的处理函数（需要配合-SA-SIGINFO-标志使用，了解）" class="headerlink" title="2. sa_sigaction：带详细信息的处理函数（需要配合 SA_SIGINFO 标志使用，了解）"></a>2. <code>sa_sigaction</code>：带详细信息的处理函数（需要配合 <code>SA_SIGINFO</code> 标志使用，了解）</h5><p>可以获取信号的详细信息（发送者、原因等），接收三个参数：</p><ul><li>信号编号。</li><li><code>siginfo_t *</code>：包含信号来源等信息。</li><li><code>void *</code>：指向 <code>ucontext_t</code> 的指针（可获取寄存器等上下文信息）。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sigaction_handler</span><span class="params">(<span class="type">int</span> signo, <span class="type">siginfo_t</span> *info, <span class="type">void</span> *context)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;收到信号：%d，发送者PID：%d\n&quot;</span>, signo, info-&gt;si_pid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">act.sa_sigaction = sigaction_handler;</span><br><span class="line">act.sa_flags = SA_SIGINFO;</span><br></pre></td></tr></table></figure><h5 id="3-sa-mask：信号处理期间屏蔽的其他信号集合"><a href="#3-sa-mask：信号处理期间屏蔽的其他信号集合" class="headerlink" title="3. sa_mask：信号处理期间屏蔽的其他信号集合"></a>3. <code>sa_mask</code>：信号处理期间屏蔽的其他信号集合</h5><p>在执行信号处理函数时，可以屏蔽其他信号，防止多个信号处理函数嵌套执行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sigemptyset(&amp;act.sa_mask);</span><br><span class="line">sigaddset(&amp;act.sa_mask, SIGUSR1);  <span class="comment">// 在处理当前信号时，暂时屏蔽 SIGUSR1</span></span><br></pre></td></tr></table></figure><h5 id="4-sa-flags：控制信号行为的标志位"><a href="#4-sa-flags：控制信号行为的标志位" class="headerlink" title="4. sa_flags：控制信号行为的标志位"></a>4. <code>sa_flags</code>：控制信号行为的标志位</h5><table><thead><tr><th>标志</th><th>含义</th></tr></thead><tbody><tr><td><code>SA_RESTART</code></td><td>自动重启被中断的系统调用（如 read&#x2F;write）</td></tr><tr><td><code>SA_SIGINFO</code></td><td>使用 <code>sa_sigaction</code> 而不是 <code>sa_handler</code></td></tr><tr><td><code>SA_NODEFER</code></td><td>不自动屏蔽当前信号（默认会屏蔽）</td></tr><tr><td><code>SA_RESETHAND</code></td><td>处理完信号后重置为默认行为</td></tr></tbody></table><h4 id="4-返回值"><a href="#4-返回值" class="headerlink" title="4. 返回值"></a>4. 返回值</h4><ul><li>成功返回 <code>0</code>。</li><li>失败返回 <code>-1</code>，并设置 <code>errno</code>。</li></ul><h4 id="5-代码示例"><a href="#5-代码示例" class="headerlink" title="5. 代码示例"></a>5. 代码示例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">handler</span><span class="params">(<span class="type">int</span> signum)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;收到信号: &quot;</span> &lt;&lt; signum &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span>                       <span class="comment">// 用于设置新行为</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;act, <span class="number">0</span>, <span class="keyword">sizeof</span>(act));               <span class="comment">// 初始化为 0，避免随机值干扰</span></span><br><span class="line">    act.sa_handler = handler;                   <span class="comment">// 设置信号处理函数</span></span><br><span class="line">    sigemptyset(&amp;act.sa_mask);                  <span class="comment">// 清空屏蔽字</span></span><br><span class="line">    act.sa_flags = <span class="number">0</span>;                           <span class="comment">// 无特殊行为</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sigaction(SIGINT, &amp;act, nullptr) == <span class="number">-1</span>) <span class="comment">// 设置 SIGINT（如按 Ctrl+C） 的处理方式</span></span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;sigaction error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)                                <span class="comment">// 模拟服务一直运行</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;程序运行中...（按 Ctrl+C 测试信号）&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-pending-什么时候从-1-0？"><a href="#2-pending-什么时候从-1-0？" class="headerlink" title="2. pending 什么时候从 1 -&gt; 0？"></a>2. <code>pending</code> 什么时候从 1 -&gt; 0？</h3><p><strong>pending 位在信号递达时被清 0，早于 handler 的执行，确保信号不会重复处理。</strong> pending 位图就像一个“未读消息列表”。</p><ul><li>信号产生时，该信号在 pending 位图中被标记为 <code>1</code>（未读）。</li><li>当信号递达时，内核会把该位清 <code>0</code>，表示“这个信号我已经处理了”。</li></ul><p>实验证明：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">handler</span><span class="params">(<span class="type">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;进入 handler\n&quot;</span>);</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">3</span>);                                   <span class="comment">// 模拟处理过程</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;退出 handler\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sigaction</span> act;                       <span class="comment">// 定义信号处理结构体</span></span><br><span class="line">    act.sa_handler = handler;                   <span class="comment">// 设置信号处理函数</span></span><br><span class="line">    <span class="built_in">sigemptyset</span>(&amp;act.sa_mask);                  <span class="comment">// 阻塞信号集为空</span></span><br><span class="line">    act.sa_flags = <span class="number">0</span>;                           <span class="comment">// 信号处理标志位</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">sigaction</span>(SIGINT, &amp;act, <span class="literal">NULL</span>);              <span class="comment">// 注册信号处理函数</span></span><br><span class="line"></span><br><span class="line">    <span class="type">sigset_t</span> set;                               <span class="comment">// 定义信号集</span></span><br><span class="line">    <span class="built_in">sigemptyset</span>(&amp;set);                          <span class="comment">// 信号集为空</span></span><br><span class="line">    <span class="built_in">sigaddset</span>(&amp;set, SIGINT);                    <span class="comment">// 加入 SIGINT 信号</span></span><br><span class="line">    <span class="built_in">sigprocmask</span>(SIG_BLOCK, &amp;set, <span class="literal">NULL</span>);         <span class="comment">// 阻塞 SIGINT 信号</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请在 5 秒内按 Ctrl+C（SIGINT 会被 pending）...\n&quot;</span>);</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">5</span>);                                   <span class="comment">// 等待 5 秒</span></span><br><span class="line"></span><br><span class="line">    <span class="type">sigset_t</span> pending;                           <span class="comment">// 定义 pending 信号集  </span></span><br><span class="line">    <span class="built_in">sigpending</span>(&amp;pending);                       <span class="comment">// 获取 pending 信号集</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">sigismember</span>(&amp;pending, SIGINT))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;SIGINT 当前处于 pending 状态（位为 1）\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sigprocmask</span>(SIG_UNBLOCK, &amp;set, <span class="literal">NULL</span>);       <span class="comment">// 解除 SIGINT 信号的阻塞</span></span><br><span class="line">    <span class="built_in">pause</span>();                                    <span class="comment">// 等待信号处理完成</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">sigpending</span>(&amp;pending);                       <span class="comment">// 获取 pending 信号集</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">sigismember</span>(&amp;pending, SIGINT))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;SIGINT 的 pending 位已被清 0\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[hcc@hcss-ecs-be68 Signal Processing]$ ./test1 </span><br><span class="line">请在 5 秒内按 Ctrl+C（SIGINT 会被 pending）...</span><br><span class="line">^C</span><br><span class="line">SIGINT 当前处于 pending 状态（位为 1）</span><br><span class="line">进入 handler</span><br><span class="line">退出 handler</span><br><span class="line">^C</span><br><span class="line">进入 handler</span><br><span class="line">退出 handler</span><br><span class="line">SIGINT 的 pending 位已被清 0</span><br></pre></td></tr></table></figure><p><strong>信号的 pending 位在信号递达前被清 0，handler 执行期间该信号会被自动屏蔽，handler 执行完毕后恢复。如果在 handler 执行期间发送该信号，它会再次进入 pending，handler 会再次被调用。</strong> </p><h3 id="3-信号处理过程中，是否自动将该信号加入-blocked？"><a href="#3-信号处理过程中，是否自动将该信号加入-blocked？" class="headerlink" title="3. 信号处理过程中，是否自动将该信号加入 blocked？"></a>3. 信号处理过程中，是否自动将该信号加入 <code>blocked</code>？</h3><p><strong>在执行信号处理函数时，内核会自动将该信号加入 block 集合，防止递归调用；handler 执行完毕后，block 集合恢复原样。</strong> </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">handler</span><span class="params">(<span class="type">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;进入 handler，此时 SIGINT 被屏蔽\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">sigset_t</span> blocked;                                    <span class="comment">// 保存当前信号集</span></span><br><span class="line">    <span class="built_in">sigprocmask</span>(<span class="number">0</span>, <span class="literal">NULL</span>, &amp;blocked);                      <span class="comment">// 获取当前信号集</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">sigismember</span>(&amp;blocked, SIGINT))                   <span class="comment">// 判断 SIGINT 是否被屏蔽</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;SIGINT 当前被阻塞（屏蔽中）\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;SIGINT 未被阻塞\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">5</span>); <span class="comment">// 模拟处理过程</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;退出 handler\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sigaction</span> act;                                <span class="comment">// 信号处理结构体</span></span><br><span class="line">    act.sa_handler = handler;                            <span class="comment">// 设置信号处理函数</span></span><br><span class="line">    <span class="built_in">sigemptyset</span>(&amp;act.sa_mask);                           <span class="comment">// 初始化信号集</span></span><br><span class="line">    act.sa_flags = <span class="number">0</span>;                                    <span class="comment">// 信号处理标志</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">sigaction</span>(SIGINT, &amp;act, <span class="literal">NULL</span>);                       <span class="comment">// 注册信号处理函数</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;发送 SIGINT 将触发 handler\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pause</span>();                                         <span class="comment">// 阻塞进程，等待信号</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[hcc@hcss-ecs-be68 Signal Processing]$ ./test2</span><br><span class="line">发送 SIGINT 将触发 handler</span><br><span class="line">^C进入 handler，此时 SIGINT 被屏蔽</span><br><span class="line">SIGINT 当前被阻塞（屏蔽中）</span><br><span class="line">退出 handler</span><br><span class="line">^C进入 handler，此时 SIGINT 被屏蔽</span><br><span class="line">SIGINT 当前被阻塞（屏蔽中）</span><br><span class="line">退出 handler</span><br><span class="line">……</span><br></pre></td></tr></table></figure><p>在 handler 执行期间，SIGINT 被自动加入 block 集合（屏蔽），即使多次按 Ctrl+C，也不会再次进入 handler。</p><hr><h2 id="3-可重入函数"><a href="#3-可重入函数" class="headerlink" title="3. 可重入函数"></a>3. 可重入函数</h2><blockquote><p><a href="https://stackoverflow.com/questions/2799023/what-exactly-is-a-reentrant-function">可重入函数到底是什么？ | stack overflow</a><br><a href="https://www.bilibili.com/video/BV1eY4y1L7jE/?share_source=copy_web&vd_source=872e5e3ccf44874c39edaf42e30ab0de">c 语言学习 432 可重入函数 | B 站</a></p></blockquote><p><strong>可重入函数</strong> 是指：函数在被中断后，其上下文环境不被破坏，并且可以 <strong>安全地重新调用</strong>，不影响原始执行。我们可以把一个函数想象成一个 <strong>银行柜台</strong> ：</p><ul><li><strong>不可重入函数</strong> ：只有一个柜员，只能服务一个客户。如果另一个客户来了，就会出错（比如数据混乱、死锁）。</li><li><strong>可重入函数</strong> ：每个客户都有自己的工位，互不干扰，可以同时处理。</li></ul><p>信号处理函数中 <strong>只能用可重入函数</strong>，否则可能引发程序崩溃或行为不确定。<strong>非可重入函数，不可在 handler 中使用。</strong> 好在目前我们所学习到的函数都是可重入函数，简单注意一下即可。</p><h2 id="4-volatile"><a href="#4-volatile" class="headerlink" title="4. volatile"></a>4. volatile</h2><p>volatile 是 C 语言的一个关键字，该关键字的作用是保持内存的可见性。<strong>作用是告诉编译器：“这个变量的值可能随时被修改，不要做优化！”</strong> 当变量可能被信号处理函数或中断修改时，<strong>必须使用 <code>volatile</code> 修饰</strong>，否则优化器可能让主线程永远看不到值的变化，导致逻辑失效。 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">handler</span><span class="params">(<span class="type">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;收到信号:%d\n&quot;</span>, signo);</span><br><span class="line">flag = <span class="number">1</span>;                           <span class="comment">// 设置flag为1，表示收到信号（// 信号处理函数中修改 flag 的值）</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">signal</span>(SIGINT, handler);            <span class="comment">// 注册信号处理函数</span></span><br><span class="line"><span class="keyword">while</span> (!flag);                      <span class="comment">// 等待信号处理函数执行完毕</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;进程正常退出！\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>-O0</code>, <code>-O1</code>, <code>-O2</code>, <code>-O3</code> 是控制 <strong>编译器优化强度</strong> 的开关，等级越高程序执行速度越快，但调试越困难、对写法越敏感（如 <code>volatile</code> 就必须加）。默认建议开发调试用 <code>-O0</code>，上线前用 <code>-O2</code>。在 man 手册中查看：<code>man gcc</code> → 按下 <code>/</code> 进入搜索模式，输入：<code>-O</code> → 然后按 <code>n</code>（next）多次查找。（<a href="https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html">优化选项（使用 GNU 编译器集合（GCC））</a>）</p><table><thead><tr><th>选项</th><th>含义（优化级别）</th><th>特点 &#x2F; 行为</th></tr></thead><tbody><tr><td><code>-O0</code></td><td>不做优化</td><td>编译快、便于调试、代码按字面意思执行</td></tr><tr><td><code>-O1</code></td><td>基本优化</td><td>小幅优化、不会改变代码结构</td></tr><tr><td><code>-O2</code></td><td>常规优化（推荐上线用）</td><td>去除冗余，常量折叠，循环展开，较稳定</td></tr><tr><td><code>-O3</code></td><td>激进优化（最大速度）</td><td>包括内联函数、多重循环展开，性能极高但可能更难调试</td></tr><tr><td><code>-Os</code></td><td>优化空间（减小生成文件大小）</td><td>类似 <code>-O2</code>，但更注重体积</td></tr><tr><td><code>-Ofast</code></td><td>忽略一些标准规范，疯狂优化（不推荐）</td><td>会跳过 <code>IEEE</code>&#x2F;<code>C99</code> 规范，速度最快但可能不准确</td></tr></tbody></table></blockquote><p>运行结果示例：</p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250719164029066.png" alt="image-20250719164021603"></p><p>当我们将 <code>int flag = 0;</code> 改变成 <code>volatile int flag = 0;</code> 就会发现运行结果一致了：</p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250719165429369.png" alt="image-20250719165429223"></p><h2 id="5-SIGCHLD-信号"><a href="#5-SIGCHLD-信号" class="headerlink" title="5. SIGCHLD 信号"></a>5. SIGCHLD 信号</h2><p><strong><code>SIGCHLD</code> 是子进程退出时，自动发送给其父进程的信号（通知父进程：子进程挂了”的信号）。</strong> 也叫：<strong>子进程状态改变信号</strong>，通常用于通知父进程去回收子进程，<strong>防止僵尸进程出现！</strong></p><h3 id="1-什么时候会触发-SIGCHLD？"><a href="#1-什么时候会触发-SIGCHLD？" class="headerlink" title="1. 什么时候会触发 SIGCHLD？"></a>1. 什么时候会触发 <code>SIGCHLD</code>？</h3><p>当子进程发生以下情况，内核就会给它的父进程发送 <code>SIGCHLD</code> 信号：</p><table><thead><tr><th>子进程行为</th><th align="center">会触发 SIGCHLD 吗？</th><th>说明</th></tr></thead><tbody><tr><td>正常退出（return&#x2F;exit）</td><td align="center">是</td><td>最常见用途</td></tr><tr><td>异常终止（段错误、除 0）</td><td align="center">是</td><td>会触发</td></tr><tr><td>被信号杀死（如 SIGKILL）</td><td align="center">是</td><td>依然会通知</td></tr><tr><td>被暂停&#x2F;恢复执行</td><td align="center">是</td><td>可配合 WUNTRACED 监控状态变化</td></tr></tbody></table><h3 id="2-函数原型：signal-sigaction-监听-SIGCHLD"><a href="#2-函数原型：signal-sigaction-监听-SIGCHLD" class="headerlink" title="2. 函数原型：signal &#x2F; sigaction 监听 SIGCHLD"></a>2. 函数原型：<code>signal</code> &#x2F; <code>sigaction</code> 监听 SIGCHLD</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以用如下方式监听 SIGCHLD 信号：</span></span><br><span class="line"><span class="built_in">signal</span>(SIGCHLD, handler);        <span class="comment">// 简单方式</span></span><br><span class="line"><span class="built_in">sigaction</span>(SIGCHLD, &amp;act, <span class="literal">NULL</span>);  <span class="comment">// 更稳定推荐方式</span></span><br></pre></td></tr></table></figure><h3 id="3-示例代码：监听-SIGCHLD-回收子进程"><a href="#3-示例代码：监听-SIGCHLD-回收子进程" class="headerlink" title="3. 示例代码：监听 SIGCHLD + 回收子进程"></a>3. 示例代码：监听 SIGCHLD + 回收子进程</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">handler</span><span class="params">(<span class="type">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 回收所有退出的子进程，防止僵尸进程</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">waitpid</span>(<span class="number">-1</span>, <span class="literal">NULL</span>, WNOHANG) &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;子进程已退出，回收完成\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">signal</span>(SIGCHLD, handler);</span><br><span class="line"></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;子进程运行中，PID = %d\n&quot;</span>, <span class="built_in">getpid</span>());</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);                <span class="comment">// 正常退出，触发 SIGCHLD</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;父进程在运行中，PID = %d\n&quot;</span>, <span class="built_in">getpid</span>());</span><br><span class="line">            <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[hcc@hcss-ecs-be68 Signal Processing]$ ./SIGCHLD </span><br><span class="line">父进程在运行中，PID = 27055</span><br><span class="line">子进程运行中，PID = 27056</span><br><span class="line">父进程在运行中，PID = 27055</span><br><span class="line">父进程在运行中，PID = 27055</span><br><span class="line">子进程已退出，回收完成</span><br><span class="line">父进程在运行中，PID = 27055</span><br><span class="line">父进程在运行中，PID = 27055</span><br><span class="line">^C</span><br></pre></td></tr></table></figure><p><strong>如果不处理 <code>SIGCHLD</code> 会怎样？</strong></p><p>子进程退出，父进程没有调用 <code>wait</code> 或 <code>waitpid</code>，就会产生 <strong>僵尸进程</strong>，虽然不会占用内存，但会占用 <strong>PID 表项</strong>，多了会导致系统资源耗尽。</p><table><thead><tr><th>重点</th><th>说明</th></tr></thead><tbody><tr><td><code>SIGCHLD</code> 什么时候触发</td><td>子进程退出、异常终止、被信号杀死、状态改变</td></tr><tr><td>为啥要处理它？</td><td><strong>防止僵尸进程！</strong> 并控制子进程生命周期</td></tr><tr><td>怎么处理？</td><td><code>signal</code> 或 <code>sigaction</code> 监听 <code>SIGCHLD</code>，调用 <code>waitpid</code></td></tr><tr><td>实战用途</td><td>写守护进程、多进程服务程序、提升系统稳定性</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 进程 </tag>
            
            <tag> 地址空间 </tag>
            
            <tag> 信号 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>037 进程信号 —— 信号的保存</title>
      <link href="/posts/7454.html"/>
      <url>/posts/7454.html</url>
      
        <content type="html"><![CDATA[<h1 id="进程信号-——-信号的保存"><a href="#进程信号-——-信号的保存" class="headerlink" title="进程信号 —— 信号的保存"></a>进程信号 —— 信号的保存</h1><h2 id="1-信号的其他相关概念"><a href="#1-信号的其他相关概念" class="headerlink" title="1. 信号的其他相关概念"></a>1. 信号的其他相关概念</h2><table><thead><tr><th>概念</th><th>含义</th><th>例子</th></tr></thead><tbody><tr><td><strong>信号产生（Generate）</strong></td><td>内核决定给进程发送一个信号</td><td>比如你按了 <code>Ctrl+C</code>，系统决定给你的程序发一个 <code>SIGINT</code> 信号，就像同事敲了你的门说“有事”</td></tr><tr><td><strong>信号未决（Pending）</strong></td><td>信号已经产生，但还没被处理，只能排队等着</td><td>你正在开会，同事敲了门，但你没理他，他的请求被记下来了，等你有空再处理</td></tr><tr><td><strong>信号阻塞（Blocked）</strong></td><td>你设置了“我暂时不想处理这些信号”</td><td>你提前设置了“开会期间不接电话”，这些信号来了也只能排队等待，不会立刻打断你</td></tr><tr><td><strong>信号递达（Delivery）</strong></td><td>信号从 pending 状态变为被处理的状态</td><td>你开完会，系统发现有一个 <code>SIGINT</code> 在排队，于是开始处理它，触发你设置的处理函数</td></tr><tr><td><strong>信号处理（Handler）</strong></td><td>你决定怎么处理这个信号（默认、忽略、自定义函数）</td><td>你决定怎么处理这个信号：<br/>1. 默认处理（系统帮你处理）<br/>2. 忽略处理（假装没发生）<br/>3. 自定义函数（你写好逻辑来处理）</td></tr></tbody></table><p><strong>阻塞 ≠ 忽略 ≠ 未决：</strong></p><ul><li><strong>阻塞</strong> 是控制递达的时机，信号仍然会记录下来（进入 pending）。</li><li><strong>忽略</strong> 是告诉内核「收到信号后什么都不做」，但是信号 <strong>必须先递达</strong>。</li><li><strong>未决</strong> 是信号已经来了，但因为被阻塞，暂时不能处理，只能排队。</li></ul><blockquote><ul><li><strong>阻塞</strong> 是你设置了“不想被打扰”。</li><li><strong>未决</strong> 是“打扰已经来了，但你暂时不能处理”。</li><li><strong>忽略</strong> 是“即使打扰来了，你也假装没发生”。</li></ul></blockquote><blockquote><p><strong>信号集 &#x3D; 一堆信号的集合，用来告诉操作系统：“我现在想屏蔽哪些信号？”  或  “我正在等待哪些信号？”  或  “我目前还没处理的信号有哪些？”</strong> </p></blockquote><h2 id="2-信号处理模型的三大组成（内核中的表示）"><a href="#2-信号处理模型的三大组成（内核中的表示）" class="headerlink" title="2. 信号处理模型的三大组成（内核中的表示）"></a>2. 信号处理模型的三大组成（内核中的表示）</h2><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250717163604882.png" alt="image-20250717163556987"></p><h3 id="1-Block-位图（阻塞信号集合）"><a href="#1-Block-位图（阻塞信号集合）" class="headerlink" title="1. Block 位图（阻塞信号集合）"></a>1. Block 位图（阻塞信号集合）</h3><ul><li>叫做：<code>blocked</code> 或 <code>signal_blocked</code>。</li><li>类型：<code>sigset_t</code>（实际是一个位图 bitset）</li><li>作用：表示进程 <strong>当前阻塞了哪些信号</strong>（告诉系统：“<strong>我现在不想处理这些信号</strong>”）。</li><li>阻塞意味着：这些信号虽然可以被内核记录为 pending，但不能递达（<strong>这个集合里记录的是进程当前暂时屏蔽掉的信号。被屏蔽的信号即使发来了，也不会立刻处理，只能先记下来，等你不屏蔽了再处理</strong>）。</li></ul><p>示例：用 <code>sigprocmask</code> 设置阻塞信号：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">sigset_t</span> <span class="built_in">set</span>;</span><br><span class="line">sigemptyset(&amp;<span class="built_in">set</span>);</span><br><span class="line">sigaddset(&amp;<span class="built_in">set</span>, SIGINT);             <span class="comment">// 把 SIGINT 加入阻塞集合</span></span><br><span class="line">sigprocmask(SIG_BLOCK, &amp;<span class="built_in">set</span>, <span class="literal">NULL</span>);  <span class="comment">// 设置阻塞</span></span><br></pre></td></tr></table></figure><p>此后即使 Ctrl+C 发出 SIGINT，信号也不会递达，直到解除阻塞。</p><hr><h3 id="2-Pending-位图（未决信号集合）"><a href="#2-Pending-位图（未决信号集合）" class="headerlink" title="2. Pending 位图（未决信号集合）"></a>2. Pending 位图（未决信号集合）</h3><ul><li>叫做：<code>pending</code> 或 <code>signal_pending</code>。</li><li>类型：也是 <code>sigset_t</code>。</li><li>作用：表示当前已经产生、但还没递达的信号（<strong>记录已经发来了但还没来得及处理的信号</strong>）。</li></ul><p>每当一个信号产生时，如果它 <strong>处于阻塞状态</strong>，就会被加入 pending 集合。只有解除阻塞，pending 中的信号才会尝试递达。</p><p><strong>这些信号其实已经发给你了，但是因为你之前屏蔽了它们，所以不能马上处理。系统会先把它们存在 pending 队列里，等你不屏蔽了，再一个个处理。就像你正在开会，手机不断收到消息提醒（相当于信号），但你现在不方便看手机（相当于屏蔽）。于是这些消息就先存着，等你开完会再去查看。</strong></p><hr><h3 id="3-Handler-指针数组（信号处理函数表）"><a href="#3-Handler-指针数组（信号处理函数表）" class="headerlink" title="3. Handler 指针数组（信号处理函数表）"></a>3. Handler 指针数组（信号处理函数表）</h3><ul><li>用户空间设置方式：使用 <code>signal()</code> 或 <code>sigaction()</code>。</li><li>内核结构体：每个进程有一个叫 <code>sighand_struct</code> 的结构体（大小通常为 <code>_NSIG</code>），里面有个数组，记录每个信号对应的处理方式。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sighand_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">k_sigaction</span> <span class="title">action</span>[_<span class="title">NSIG</span>];</span> <span class="comment">// 每个信号一个动作函数</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>每个数组元素都表示：<strong>当信号递达时执行的处理方式（三种）</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250717165307568.png" alt="image-20250717165307476"></p><h2 id="3-什么是-sigset-t？它为什么重要？"><a href="#3-什么是-sigset-t？它为什么重要？" class="headerlink" title="3. 什么是 sigset_t？它为什么重要？"></a>3. 什么是 <code>sigset_t</code>？它为什么重要？</h2><h3 id="1-本质"><a href="#1-本质" class="headerlink" title="1. 本质"></a>1. 本质</h3><p><code>sigset_t</code> 是一个用于表示信号集合的结构体类型。内部实现是一个 <strong>位图</strong>，每一个 bit 表示一个信号编号的状态：</p><ul><li>第 <code>n</code> 位为 <code>1</code> → 表示 <strong>第 n 个信号有效</strong></li><li>第 <code>n</code> 位为 <code>0</code> → 表示 <strong>第 n 个信号无效</strong></li></ul><h3 id="2-用途"><a href="#2-用途" class="headerlink" title="2. 用途"></a>2. 用途</h3><p><code>sigset_t</code> 可以用于两种语义，被用于以下 API：<code>sigprocmask</code>、<code>sigpending</code>、<code>pthread_sigmask</code> 等：</p><ul><li>📦 <strong>阻塞信号集</strong>（Signal Mask）—— 表示哪些信号被阻塞。</li><li>🔔 <strong>未决信号集</strong>（Pending Set）—— 表示哪些信号已产生但未递达。</li></ul><hr><h2 id="4-信号集操作函数讲解"><a href="#4-信号集操作函数讲解" class="headerlink" title="4. 信号集操作函数讲解"></a>4. 信号集操作函数讲解</h2><blockquote><p>这里的 5 个函数的参数都是 <strong>指针类型</strong> ，他们需要修改传入的 <code>sigset_t</code> 变量本身，所以下面的 &amp; 是 <strong>取地址</strong> 而非位运算！他们的 <strong>头文件也都是 <code>#include &lt;signal.h&gt; </code></strong>。</p></blockquote><h3 id="1-int-sigemptyset-sigset-t-set"><a href="#1-int-sigemptyset-sigset-t-set" class="headerlink" title="1. int sigemptyset(sigset_t *set);"></a>1. <code>int sigemptyset(sigset_t *set);</code></h3><h4 id="1-作用："><a href="#1-作用：" class="headerlink" title="1. 作用："></a>1. 作用：</h4><p>清空信号集，使所有信号都 <strong>无效（0）</strong>。适用于初始化，创建一个 <strong>空集合</strong>。</p><h4 id="2-代码示例"><a href="#2-代码示例" class="headerlink" title="2. 代码示例"></a>2. 代码示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">sigset_t</span> set;</span><br><span class="line"><span class="built_in">sigemptyset</span>(&amp;set);   <span class="comment">// set 现在是一个空的信号集，所有位为 0</span></span><br></pre></td></tr></table></figure><hr><h3 id="2-int-sigfillset-sigset-t-set"><a href="#2-int-sigfillset-sigset-t-set" class="headerlink" title="2. int sigfillset(sigset_t *set);"></a>2. <code>int sigfillset(sigset_t *set);</code></h3><h4 id="1-作用"><a href="#1-作用" class="headerlink" title="1. 作用"></a>1. 作用</h4><p>将所有信号设置为 <strong>有效（1）</strong>，也就是“全信号集”。<strong>用于一次性屏蔽所有信号</strong>。</p><h4 id="2-代码示例-1"><a href="#2-代码示例-1" class="headerlink" title="2. 代码示例"></a>2. 代码示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">sigset_t</span> set;</span><br><span class="line"><span class="built_in">sigfillset</span>(&amp;set);    <span class="comment">// set 现在包含所有信号（位图全为 1）</span></span><br></pre></td></tr></table></figure><hr><h3 id="3-int-sigaddset-sigset-t-set-int-signo"><a href="#3-int-sigaddset-sigset-t-set-int-signo" class="headerlink" title="3. int sigaddset(sigset_t *set, int signo);"></a>3. <code>int sigaddset(sigset_t *set, int signo);</code></h3><h4 id="1-作用-1"><a href="#1-作用-1" class="headerlink" title="1. 作用"></a>1. 作用</h4><p>向信号集添加一个信号，使其在集合中 <strong>有效（设为 1）</strong>。</p><h4 id="2-代码示例-2"><a href="#2-代码示例-2" class="headerlink" title="2. 代码示例"></a>2. 代码示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">sigset_t</span> set;</span><br><span class="line"><span class="built_in">sigemptyset</span>(&amp;set);</span><br><span class="line"><span class="built_in">sigaddset</span>(&amp;set, SIGINT);   <span class="comment">// 将 SIGINT 添加进集合</span></span><br></pre></td></tr></table></figure><hr><h3 id="4-int-sigdelset-sigset-t-set-int-signo"><a href="#4-int-sigdelset-sigset-t-set-int-signo" class="headerlink" title="4. int sigdelset(sigset_t *set, int signo);"></a>4. <code>int sigdelset(sigset_t *set, int signo);</code></h3><h4 id="1-作用-2"><a href="#1-作用-2" class="headerlink" title="1. 作用"></a>1. 作用</h4><p>从信号集中移除某个信号，使其在集合中 <strong>无效（设为 0）</strong>。</p><h4 id="2-代码示例-3"><a href="#2-代码示例-3" class="headerlink" title="2. 代码示例"></a>2. 代码示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">sigset_t</span> set;</span><br><span class="line"><span class="built_in">sigfillset</span>(&amp;set);           <span class="comment">// 初始化为所有信号</span></span><br><span class="line"><span class="built_in">sigdelset</span>(&amp;set, SIGINT);    <span class="comment">// 移除 SIGINT</span></span><br></pre></td></tr></table></figure><hr><h3 id="5-int-sigismember-const-sigset-t-set-int-signo"><a href="#5-int-sigismember-const-sigset-t-set-int-signo" class="headerlink" title="5. int sigismember(const sigset_t *set, int signo);"></a>5. <code>int sigismember(const sigset_t *set, int signo);</code></h3><h4 id="1-作用-3"><a href="#1-作用-3" class="headerlink" title="1. 作用"></a>1. 作用</h4><p>检测某个信号是否在信号集中（是否为 1）。</p><h4 id="2-返回值"><a href="#2-返回值" class="headerlink" title="2. 返回值"></a>2. 返回值</h4><ul><li>存在：返回 1。</li><li>不存在：返回 0。</li><li>错误：返回 -1。</li></ul><h4 id="3-代码示例"><a href="#3-代码示例" class="headerlink" title="3. 代码示例"></a>3. 代码示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">sigset_t</span> set;</span><br><span class="line"><span class="built_in">sigemptyset</span>(&amp;set);</span><br><span class="line"><span class="built_in">sigaddset</span>(&amp;set, SIGINT);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">sigismember</span>(&amp;set, SIGINT))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;SIGINT 存在于信号集中\n&quot;</span>);</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;SIGINT 不存在于信号集中\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-小结"><a href="#6-小结" class="headerlink" title="6. 小结"></a>6. 小结</h3><table><thead><tr><th>函数名</th><th>功能</th><th>类比</th></tr></thead><tbody><tr><td><code>sigemptyset</code></td><td>清空集合</td><td>清空列表</td></tr><tr><td><code>sigfillset</code></td><td>加入所有信号</td><td>填满列表</td></tr><tr><td><code>sigaddset</code></td><td>添加某信号进集合</td><td>插入元素</td></tr><tr><td><code>sigdelset</code></td><td>移除某信号出集合</td><td>删除元素</td></tr><tr><td><code>sigismember</code></td><td>检查信号是否存在集合中</td><td>查询元素</td></tr></tbody></table><blockquote><p><strong>延伸：信号集 ≠ 信号队列</strong></p><ul><li><code>sigset_t</code> 是位图，<strong>不记录信号发生次数</strong>。</li><li>即便一个信号连续产生 10 次，只要它处于未决状态，pending 位图中就只有一个 bit 为 1。</li><li>所以，<strong>信号不具备计数能力</strong>。</li><li>多次产生的同一个信号，只会保留一次，除非是实时信号。</li></ul></blockquote><hr><h2 id="5-sigprocmask-和-sigpending-函数"><a href="#5-sigprocmask-和-sigpending-函数" class="headerlink" title="5. sigprocmask 和 sigpending 函数"></a>5. <code>sigprocmask</code> 和 <code>sigpending</code> 函数</h2><p><code>sigprocmask</code> 和 <code>sigpending</code> 是信号机制中 <strong>非常核心的两个系统调用接口</strong>，用于操作进程的信号阻塞状态和查看未决信号。</p><table><thead><tr><th>函数名</th><th>作用</th><th>常用用途</th></tr></thead><tbody><tr><td><code>sigprocmask</code></td><td>设置 &#x2F; 修改 &#x2F; 查询阻塞信号集</td><td>控制哪些信号不被递达</td></tr><tr><td><code>sigpending</code></td><td>查询未决信号集</td><td>查看哪些信号已产生但尚未递达</td></tr></tbody></table><h3 id="1-sigprocmask-函数-——-修改-获取进程的信号屏蔽字（阻塞信号集）"><a href="#1-sigprocmask-函数-——-修改-获取进程的信号屏蔽字（阻塞信号集）" class="headerlink" title="1. sigprocmask 函数 —— 修改&#x2F;获取进程的信号屏蔽字（阻塞信号集）"></a>1. <code>sigprocmask</code> 函数 —— 修改&#x2F;获取进程的信号屏蔽字（阻塞信号集）</h3><h4 id="1-功能"><a href="#1-功能" class="headerlink" title="1. 功能"></a>1. 功能</h4><p>用于 <strong>设置 &#x2F; 修改 &#x2F; 查询</strong> 当前进程的信号屏蔽字（<strong>设置“我现在不想处理哪些信号”的函数</strong>），即“阻塞信号集合”。信号屏蔽字就是 <code>task_struct.blocked</code>，通过 <code>sigprocmask</code> 修改它可以：</p><ul><li>设置新的阻塞信号集合。</li><li>添加或删除某些信号的阻塞状态。</li><li>查询当前阻塞了哪些信号。</li></ul><h4 id="2-函数原型"><a href="#2-函数原型" class="headerlink" title="2. 函数原型"></a>2. 函数原型</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sigprocmask</span><span class="params">(<span class="type">int</span> how, <span class="type">const</span> <span class="type">sigset_t</span> *set, <span class="type">sigset_t</span> *oldset)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="3-参数详解"><a href="#3-参数详解" class="headerlink" title="3. 参数详解"></a>3. 参数详解</h4><table><thead><tr><th>参数名</th><th>类型</th><th>含义</th></tr></thead><tbody><tr><td><code>how</code></td><td><code>int</code></td><td>操作类型（如下表），你要怎么改？是加一些？删一些？还是？</td></tr><tr><td><code>set</code></td><td><code>sigset_t *</code></td><td>要设置的新信号集（也就是目标集合），你这次想“屏蔽哪些信号”</td></tr><tr><td><code>oldset</code></td><td><code>sigset_t *</code></td><td>可选，保存原来的屏蔽集（先记下当前的“勿扰清单”，以后还能恢复它）</td></tr></tbody></table><p><strong><code>how</code> 参数可选值：</strong></p><table><thead><tr><th>值</th><th>解释</th><th>示例</th></tr></thead><tbody><tr><td><code>SIG_BLOCK</code></td><td>把 <code>set</code> 中的信号加入当前屏蔽集（叠加）</td><td>原来屏蔽 A，现在 set 是 B → 屏蔽 A+B</td></tr><tr><td><code>SIG_UNBLOCK</code></td><td>从当前屏蔽集中去掉 <code>set</code> 中的信号</td><td>原来屏蔽 A+B，set 是 B → 现在只屏蔽 A</td></tr><tr><td><code>SIG_SETMASK</code></td><td>直接用 <code>set</code> 替换整个屏蔽集</td><td>原来屏蔽 A+B，现在 set 是 C → 现在屏蔽 C</td></tr></tbody></table><h4 id="4-返回值"><a href="#4-返回值" class="headerlink" title="4. 返回值"></a>4. 返回值</h4><ul><li>成功返回 <code>0</code></li><li>失败返回 <code>-1</code>，并设置 <code>errno</code></li></ul><h4 id="5-代码示例：阻塞和解除阻塞-SIGINT（Ctrl-C）"><a href="#5-代码示例：阻塞和解除阻塞-SIGINT（Ctrl-C）" class="headerlink" title="5. 代码示例：阻塞和解除阻塞 SIGINT（Ctrl+C）"></a>5. 代码示例：阻塞和解除阻塞 SIGINT（Ctrl+C）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;csignal&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myhandler</span><span class="params">(<span class="type">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;收到信号：&quot;</span> &lt;&lt; signo &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">signal</span>(SIGINT, myhandler);              <span class="comment">// 设置 SIGINT 信号的处理函数为 myhandler，SIGINT 是 Ctrl+C 发出的中断信号</span></span><br><span class="line"></span><br><span class="line">    <span class="type">sigset_t</span> mask, oldmask;                 <span class="comment">// 定义两个信号集：mask：新的信号阻塞集，oldmask：保存原来的信号阻塞集，用于之后恢复</span></span><br><span class="line">    <span class="built_in">sigemptyset</span>(&amp;mask);                     <span class="comment">// 初始化 mask 为一个空集合（所有信号都未被阻塞）</span></span><br><span class="line">    <span class="built_in">sigaddset</span>(&amp;mask, SIGINT);               <span class="comment">// 向 mask 中添加 SIGINT 信号，表示我们想阻塞 SIGINT（Ctrl+C）</span></span><br><span class="line">    <span class="built_in">sigprocmask</span>(SIG_BLOCK, &amp;mask, &amp;oldmask);<span class="comment">// 使用 sigprocmask 设置当前进程的阻塞信号集：SIG_BLOCK（添加），mask（新的阻塞集），oldmask（保存原来的阻塞集）</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;SIGINT 被阻塞，按 Ctrl+C 不会触发 handler...&quot;</span> &lt;&lt; endl;     <span class="comment">// 此时 SIGINT 被阻塞，即使按下 Ctrl+C 也不会立即触发信号处理函数</span></span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">5</span>);                               <span class="comment">// 程序休眠 5 秒钟，期间 SIGINT 被阻塞</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">sigprocmask</span>(SIG_SETMASK, &amp;oldmask, <span class="literal">nullptr</span>);        <span class="comment">// 恢复原来的信号阻塞集（解除 SIGINT 的阻塞），SIG_SETMASK：将当前阻塞集完全替换为 mask 中的集合，oldmask：之前保存的阻塞集合</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;解除阻塞，SIGINT 可再次递达...&quot;</span> &lt;&lt; endl;     <span class="comment">// 现在 SIGINT 可以正常递达，再次按下 Ctrl+C 就会触发 myhandler</span></span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">5</span>);                               <span class="comment">// 再次休眠 5 秒，此时可以接收到 SIGINT 信号</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果就不演示了。<strong>mask 和 oldmask 是“信号集合变量”，它们本身没有默认包含任何信号。要用 <code>sigaddset()</code> 手动添加想阻塞的信号，用 <code>sigprocmask()</code> 告诉系统要怎么处理这些信号。</strong></p><hr><h3 id="2-sigpending-函数-——-获取当前进程未决信号集"><a href="#2-sigpending-函数-——-获取当前进程未决信号集" class="headerlink" title="2. sigpending 函数 —— 获取当前进程未决信号集"></a>2. <code>sigpending</code> 函数 —— 获取当前进程未决信号集</h3><h4 id="1-功能-1"><a href="#1-功能-1" class="headerlink" title="1. 功能"></a>1. 功能</h4><p>用于 <strong>获取当前进程的未决信号集</strong>，也就是哪些信号已经产生，但 <strong>尚未递达</strong>（因为它们被阻塞了）。通常配合 <code>sigprocmask</code> 使用：我们阻塞一个信号，然后用 <code>sigpending</code> 检查它是否 pending。</p><h4 id="2-函数原型-1"><a href="#2-函数原型-1" class="headerlink" title="2. 函数原型"></a>2. 函数原型</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sigpending</span><span class="params">(<span class="type">sigset_t</span> *set)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="3-参数详解-1"><a href="#3-参数详解-1" class="headerlink" title="3. 参数详解"></a>3. 参数详解</h4><p><strong><code>sigset_t *set</code>：</strong> 输出参数，保存当前进程的未决信号集合。</p><h4 id="4-返回值-1"><a href="#4-返回值-1" class="headerlink" title="4. 返回值"></a>4. 返回值</h4><ul><li>成功返回 <code>0</code>。</li><li>失败返回 <code>-1</code> 并设置 <code>errno</code>。</li></ul><h4 id="5-代码示例：阻塞-SIGINT，并检查它是否-pending"><a href="#5-代码示例：阻塞-SIGINT，并检查它是否-pending" class="headerlink" title="5. 代码示例：阻塞 SIGINT，并检查它是否 pending"></a>5. 代码示例：阻塞 SIGINT，并检查它是否 pending</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;csignal&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">sigset_t</span> block_set, pending_set;                    <span class="comment">// 定义两个信号集合</span></span><br><span class="line">    <span class="built_in">sigemptyset</span>(&amp;block_set);                            <span class="comment">// 初始化 block_set 为一个空集合（所有信号都不阻塞）</span></span><br><span class="line">    <span class="built_in">sigaddset</span>(&amp;block_set, SIGINT);                      <span class="comment">// 向 block_set 中添加 SIGINT 信号（Ctrl+C），表示我们想阻塞这个信号</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 sigprocmask 函数设置当前进程的信号屏蔽字（block 集合），SIG_BLOCK 表示将 block_set 中的信号添加到当前阻塞集合中（叠加），第三个参数为 nullptr，表示不保存原来的阻塞集合</span></span><br><span class="line">    <span class="built_in">sigprocmask</span>(SIG_BLOCK, &amp;block_set, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请在 5 秒内按 Ctrl+C（不会立刻触发 handler）...&quot;</span> &lt;&lt; endl;      <span class="comment">// 在 5 秒内按下 Ctrl+C，此时 SIGINT 会被阻塞，进入 pending 状态</span></span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">5</span>);                                           <span class="comment">// 程序暂停 5 秒，等待按下 Ctrl+C</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">sigpending</span>(&amp;pending_set);                           <span class="comment">// 获取当前进程的“未决信号集合”，pending_set 保存当前所有“已产生但未处理”的信号</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">sigismember</span>(&amp;pending_set, SIGINT))              <span class="comment">// 检查 SIGINT 是否在 pending_set 中</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;SIGINT 当前处于 pending 状态。&quot;</span> &lt;&lt; endl;<span class="comment">// 如果 SIGINT 在 pending 集合中，说明它已经产生但被阻塞了</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;SIGINT 没有 pending。&quot;</span> &lt;&lt; endl;        <span class="comment">// 如果 SIGINT 不在 pending 集合中，说明它没被发送，或已经被处理</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sigprocmask</span>(SIG_UNBLOCK, &amp;block_set, <span class="literal">nullptr</span>);      <span class="comment">// 解除对 SIGINT 的阻塞，让它可以正常递达</span></span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">2</span>);                                           <span class="comment">// 再等 2 秒，如果之前按过 Ctrl+C，此时 SIGINT 会递达并触发默认处理（终止程序）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-小实验"><a href="#3-小实验" class="headerlink" title="3. 小实验"></a>3. 小实验</h3><p><strong>验证：当一个信号（如 2 号信号 SIGINT）被阻塞时，即使被发送，也不会递达，而是进入 pending 状态，直到解除阻塞才会递达。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printPending</span><span class="params">(<span class="type">sigset_t</span> *pending)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">31</span>; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">sigismember</span>(pending, i))            <span class="comment">// 检查信号 i 是否在 pending 集合中</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;1&quot;</span>);                        <span class="comment">// 在 pending 集合中</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;0&quot;</span>);                        <span class="comment">// 不在 pending 集合中</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">sigset_t</span> set, oset;</span><br><span class="line">    <span class="built_in">sigemptyset</span>(&amp;set);</span><br><span class="line">    <span class="built_in">sigemptyset</span>(&amp;oset);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sigaddset</span>(&amp;set, <span class="number">2</span>);                         <span class="comment">// 向 set 中添加 2 号信号（SIGINT，即 Ctrl+C）</span></span><br><span class="line">    <span class="built_in">sigprocmask</span>(SIG_SETMASK, &amp;set, &amp;oset);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="type">sigset_t</span> pending;                           <span class="comment">// 定义 pending 信号集，用于后续获取当前 pending 的信号</span></span><br><span class="line">    <span class="built_in">sigemptyset</span>(&amp;pending);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)                                   <span class="comment">// 无限循环，持续检测 pending 信号集</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sigpending</span>(&amp;pending);                   <span class="comment">// 获取当前 pending 信号集</span></span><br><span class="line">        <span class="built_in">printPending</span>(&amp;pending);                 <span class="comment">// 打印 pending 信号位图（1 表示 pending，0 表示未 pending）</span></span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);                               <span class="comment">// 每隔 1 秒检测一次</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>运行程序</strong> ，它会阻塞 <code>SIGINT</code>（2 号信号，即 Ctrl+C）。</li><li><strong>发送 SIGINT 信号</strong> （使用 <code>kill -2 PID</code> 或 Ctrl+C）。使用 <code>ps aux | grep -E &#39;COMMAND|test1&#39; | grep -v grep</code> 查找 PID。</li><li><strong>观察输出</strong> ：是否在 pending 位图中看到 <code>1</code>。</li><li><strong>验证信号确实被阻塞</strong> ，程序不会退出。</li></ol><p>运行结果示例：</p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250717223247606.png" alt="image-20250717223247448"></p><hr><p><strong>让 1~31 号信号全部 pending，观察从全 0 到全 1 的变化过程：</strong></p><ol><li><strong>屏蔽所有 1~31 号信号 （即全部阻塞）。</strong></li><li><strong>发送多个信号（1~31）。</strong></li><li><strong>观察 pending 位图从全 0 变成全 1。</strong></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印 pending 位图（31 位），1 表示 pending，0 表示未 pending</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printPending</span><span class="params">(<span class="type">sigset_t</span> *pending)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">31</span>; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">sigismember</span>(pending, i))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">sigset_t</span> block_set, old_mask;</span><br><span class="line">    <span class="built_in">sigemptyset</span>(&amp;block_set);</span><br><span class="line">    <span class="built_in">sigemptyset</span>(&amp;old_mask);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞 1~31 号信号</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">31</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sigaddset</span>(&amp;block_set, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置阻塞信号集（屏蔽所有 1~31 号信号）</span></span><br><span class="line">    <span class="built_in">sigprocmask</span>(SIG_SETMASK, &amp;block_set, &amp;old_mask);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;已屏蔽 1~31 号信号，现在你可以发送信号了。\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;例如：kill -1 PID、kill -2 PID ... kill -31 PID\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">sigset_t</span> pending;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sigemptyset</span>(&amp;pending);</span><br><span class="line">        <span class="built_in">sigpending</span>(&amp;pending); <span class="comment">// 获取当前 pending 信号集合</span></span><br><span class="line">        <span class="built_in">printPending</span>(&amp;pending);</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 依次发送信号：</span></span><br><span class="line"><span class="built_in">kill</span> -1 12345</span><br><span class="line"><span class="built_in">kill</span> -2 12345</span><br><span class="line"><span class="built_in">kill</span> -3 12345</span><br><span class="line">...</span><br><span class="line"><span class="built_in">kill</span> -31 12345</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者写个脚本自动发送：for i in &#123;1..31&#125;; do kill -$i &lt;实际PID&gt;; sleep 1; done</span></span><br><span class="line"><span class="comment"># 查看进程 PID：ps aux | grep -E &#x27;COMMAND|test2&#x27; | grep -v grep（示例）</span></span><br></pre></td></tr></table></figure><p>运行结果示例：</p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250717225102505.png" alt="image-20250717225028475"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 进程 </tag>
            
            <tag> 信号 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>036 进程信号 —— 信号的产生</title>
      <link href="/posts/62794.html"/>
      <url>/posts/62794.html</url>
      
        <content type="html"><![CDATA[<h1 id="进程信号-——-信号的产生"><a href="#进程信号-——-信号的产生" class="headerlink" title="进程信号 —— 信号的产生"></a>进程信号 —— 信号的产生</h1><blockquote><p>首先，本节的信号和上一节的信号量没有任何关系！它们的关系就像老婆饼和老婆，没有任何关系！后面的内容主要是根据 <strong>信号的产生 → 信号的保存 → 信号的处理</strong> 来进行讲解。</p></blockquote><blockquote><p><a href="https://blog.csdn.net/chenlong_cxy/article/details/121952922">Linux 中的 31 个普通信号</a></p></blockquote><h2 id="1-信号的概念"><a href="#1-信号的概念" class="headerlink" title="1. 信号的概念"></a>1. 信号的概念</h2><h3 id="1-生活中的信号"><a href="#1-生活中的信号" class="headerlink" title="1. 生活中的信号"></a>1. 生活中的信号</h3><p>生活中常见的信号，比如：</p><ul><li><strong>闹钟</strong>：闹钟响 &#x3D; 通知你该起床了。</li><li><strong>红绿灯</strong>：红灯亮 &#x3D; 告诉你该停下来了。</li><li><strong>电话</strong>：响铃 &#x3D; 通知你有人呼叫你，需要你接听。</li><li><strong>警报器</strong>：火警 &#x3D; 紧急中断，要求人立刻撤离。</li></ul><p>可见，<strong>信号本质就是“通知 + 响应”</strong>，核心思想是：不需要你一直盯着，只要有事就异步提醒你。</p><h3 id="2-信号的定义与理解"><a href="#2-信号的定义与理解" class="headerlink" title="2. 信号的定义与理解"></a>2. 信号的定义与理解</h3><p>信号是一种 <strong>异步通知机制</strong>。用来 <strong>通知进程</strong> 发生了某种 <strong>异步事件</strong>。<strong>本质：操作系统向一个进程发送一个整数编号（信号编号），告诉它“发生了某件事”，要求它“采取行动”或“做出响应”。</strong></p><blockquote><p><strong>Q：你怎么认识这些信号？</strong><br><strong>A：有人教我 → 我记住了。认识：① 识别信号 ② 知道信号的处理方法。即便现在没有信号产生，我们也知道信号产生后该干什么。那么我们是谁？站在 OS 层面，我们自然是进程啦~</strong></p></blockquote><p>一个进程必须具备识别和处理信号的能力，这种能力是其自身功能的一部分，即使在没有收到任何信号的情况下，也应事先明确知道每种信号该如何处理。当某个信号实际产生时，进程可能不会立即响应，而是在合适的时机进行处理。因此，在信号产生与信号被真正处理之间，必然存在一个时间窗口。为了保证信号不会丢失，进程需要具备临时记录哪些信号已经发生的能力。</p><h3 id="3-信号的处理方式（3-种）"><a href="#3-信号的处理方式（3-种）" class="headerlink" title="3. 信号的处理方式（3 种）"></a>3. 信号的处理方式（3 种）</h3><p>信号产生了，我们可能并不立即处理这个信号，在合适的时候，因为我们可能正在做更重要的事情，所以，信号产生后会被保存到当前的时间窗口，等待信号处理。可以类比为生活中的“来电提醒”：你正在开会（执行重要任务），手机静音（屏蔽某些信号），有人打电话给你（信号产生），但你不接（不立即处理），手机记录未接来电（未决信号集），会议结束后，你查看未接来电并回电（处理信号）。</p><p>每个信号都有默认动作，但你可以选择以下 <strong>三种方式</strong> 之一来处理它：</p><table><thead><tr><th align="center">处理方式</th><th>含义</th><th>举例</th></tr></thead><tbody><tr><td align="center"><strong>默认动作</strong></td><td>使用系统定义的默认行为</td><td>红灯亮，人们 <strong>默认动作</strong> 是等待绿灯</td></tr><tr><td align="center"><strong>忽略</strong></td><td>显式地忽略该信号（就像没发生一样），但某些信号无法忽略（如 <code>SIGKILL</code>, <code>SIGSTOP</code>）</td><td>红灯亮，不妨存在闯红灯的人，他们完全 <strong>忽视</strong> 了红灯的存在</td></tr><tr><td align="center"><strong>自定义动作</strong></td><td>注册一个信号处理函数（signal handler），当信号到达时调用这个函数处理</td><td>红灯亮，你可能会看到“大小姐驾到统统闪开”“随我出发”这些社牛人群的 <strong>自定义动作</strong></td></tr></tbody></table><h3 id="4-深入理解-ctrl-c"><a href="#4-深入理解-ctrl-c" class="headerlink" title="4. 深入理解 ctrl + c"></a>4. 深入理解 ctrl + c</h3><blockquote><h4 id="认识“作业”（Job）和前后台进程"><a href="#认识“作业”（Job）和前后台进程" class="headerlink" title="认识“作业”（Job）和前后台进程"></a>认识“作业”（Job）和前后台进程</h4><p><strong>作业（Job）</strong> 这个词听起来抽象，其实就是：<strong>我们在一个 shell 会话里启动的一个程序或命令运行单元。关键点：</strong></p><ul><li>在 bash 里，每个“作业”可以是 <strong>一个进程</strong>，也可以是 <strong>一组进程（进程组）</strong>。</li><li>bash 会帮我们记录：当前有多少个作业？哪个是前台作业？哪些是后台作业？</li></ul><table><thead><tr><th>名称</th><th>解释</th></tr></thead><tbody><tr><td>前台作业</td><td>当前直接和终端（键盘输入、输出）交互的那组进程</td></tr><tr><td>后台作业</td><td>在终端后面跑，不占用终端输入，不能直接交互的那组进程</td></tr><tr><td>前台进程组</td><td>前台作业内部的那组进程，组成一个进程组，shell 管它</td></tr><tr><td>后台进程组</td><td>后台作业内部的那组进程</td></tr></tbody></table><table><thead><tr><th>比较点</th><th>前台作业</th><th>后台作业</th></tr></thead><tbody><tr><td>是否抢占终端输入</td><td>是（独占）</td><td>否（输入留给 shell）</td></tr><tr><td>是否能直接交互</td><td>可以</td><td>不能</td></tr><tr><td>能否直接接收 Ctrl+C</td><td>可以</td><td>不会收到</td></tr><tr><td>能否被 shell 追踪</td><td>会被追踪</td><td>会被追踪</td></tr></tbody></table><ul><li><strong>“前台进程” ≈ “前台作业对应的进程（或进程组）”</strong></li><li><strong>“后台进程” ≈ “后台作业对应的进程（或进程组）”</strong></li></ul><p>因为：bash 管理的单位是 <strong>作业（Job）</strong>，<strong>把前后台“作业”映射成前后台“进程组”</strong>。但底层作业就是由一个或多个 <strong>进程</strong>（进程组）组成，所以大家常常口头直接说“前台进程 &#x2F; 后台进程”，指的其实就是“前台作业 &#x2F; 后台作业里的进程”。<strong>我们只需要记住：“前台作业 &#x2F; 前台进程 &#x2F; 前台进程组” 在作业控制场景下是一个概念的不同层面，本质指的就是：当前跟终端交互、能直接被 Ctrl+C 打断的那一组进程。</strong></p><p>相关命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="built_in">sleep</span> 100 &amp;      <span class="comment"># 后台</span></span><br><span class="line">&gt;<span class="built_in">jobs</span>             <span class="comment"># 查看</span></span><br><span class="line">&gt;<span class="built_in">fg</span> %1            <span class="comment"># 拉回前台</span></span><br><span class="line">&gt;Ctrl+Z           <span class="comment"># 挂起</span></span><br><span class="line">&gt;<span class="built_in">bg</span> %1            <span class="comment"># 后台继续</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="1-Ctrl-C-为什么能杀掉前台进程？"><a href="#1-Ctrl-C-为什么能杀掉前台进程？" class="headerlink" title="1. Ctrl+C 为什么能杀掉前台进程？"></a>1. Ctrl+C 为什么能杀掉前台进程？</h4><p>Ctrl+C 的本质：当我们在终端（如 bash）按下 Ctrl+C，它会向 <strong>前台进程组</strong> 发送一个 <strong>SIGINT</strong> 信号。SIGINT 是信号编号 2，所以也叫 2 号信号。</p><p><strong>谁发的？</strong></p><ul><li><strong>不是按键直接杀死进程</strong>，而是 <strong>终端驱动检测到我们按下了 Ctrl+C</strong>。</li><li>然后内核就会让这个终端把 SIGINT 发给 <strong>前台进程组</strong>。</li></ul><p><strong>为什么是前台进程？</strong></p><ul><li>Linux 下，<strong>每个终端只能有一个前台进程组</strong>。</li><li>只有前台进程能接收由终端产生的 <strong>终端控制信号</strong>（比如 <code>Ctrl+C</code> → SIGINT，<code>Ctrl+Z</code> → SIGTSTP）。</li></ul><p>我没能展示一个完美的 Ctrl+C 的硬件到软件底层示意图，只能大致说一下流程了：键盘 → 控制器缓冲区 → 触发中断 → CPU 查向量表 → 键盘驱动读码 → 驱动识别特殊字符 → 内核发 SIGINT → 前台进程结束。</p><blockquote><p><a href="https://blog.csdn.net/zyqash/article/details/142134506">敲击键盘到屏幕上打印字符计算机都做了什么 | CSDN</a></p><p><a href="https://medium.com/@aantipov/what-happens-when-you-ctrl-c-in-the-terminal-36b093443e06">当你在终端中按 Ctrl-c 时会发生什么 | Medium</a></p><p><a href="https://medium.com/@techwithtwin/understanding-signals-in-linux-e-g-kill-9-ctrl-c-on-programs-6da5aee8ce68">了解 Linux 中的信号，例如程序上的 kill -9、CTRL + C | Medium</a></p><p><a href="https://sunshowers.io/posts/beyond-ctrl-c-signals/">超越 Ctrl-C：Unix 信号处理的黑暗角落 | sunshowers</a></p></blockquote><h4 id="2-signal-函数原型"><a href="#2-signal-函数原型" class="headerlink" title="2. signal 函数原型"></a>2. <code>signal</code> 函数原型</h4><h5 id="1-作用"><a href="#1-作用" class="headerlink" title="1. 作用"></a>1. 作用</h5><p>用于 <strong>设置某个信号的处理方式（3 种）：</strong></p><ul><li>使用自定义的 <strong>信号处理函数（handler，自己写函数）</strong>。</li><li>或者设置为 <strong>忽略</strong>（<code>SIG_IGN</code>）。</li><li>或者恢复为 <strong>默认处理</strong>（<code>SIG_DFL</code>）。</li></ul><h5 id="2-函数原型"><a href="#2-函数原型" class="headerlink" title="2. 函数原型"></a>2. 函数原型</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="type">sighandler_t</span>)</span><span class="params">(<span class="type">int</span>)</span></span>;<span class="comment">// typedef 定义了一个函数指针类型：sighandler_t 表示一个参数是 int、返回值是 void 的函数指针。</span></span><br><span class="line"><span class="function"><span class="type">sighandler_t</span> <span class="title">signal</span><span class="params">(<span class="type">int</span> signum, <span class="type">sighandler_t</span> handler)</span></span>;</span><br></pre></td></tr></table></figure><h5 id="3-参数详解"><a href="#3-参数详解" class="headerlink" title="3. 参数详解"></a>3. 参数详解</h5><ul><li><strong><code>int signum</code>：</strong> 要处理信号编号：如 <code>SIGINT</code>（2），<code>SIGTERM</code>（15），<code>SIGKILL</code>（9）等。这个参数可以直接写信号对应的编号，也能直接写信号（信号本身就是宏）。</li><li><strong><code>sighandler_t handler</code>：</strong> 信号处理的三种方式：① 指向你写的自定义处理函数 ② <code>SIG_IGN</code>（忽略）③ <code>SIG_DFL</code>（默认处理）。</li></ul><p><strong>注意点：<code>SIGKILL</code>（9）和 <code>SIGSTOP</code>（19）不能被捕获、不能忽略，只能默认由内核强制处理！</strong></p><h5 id="4-返回值"><a href="#4-返回值" class="headerlink" title="4. 返回值"></a>4. 返回值</h5><ul><li>成功：返回 <strong>之前注册的处理函数指针</strong>（方便保存旧处理方式）。</li><li>失败：返回 <code>SIG_ERR</code>。</li></ul><h5 id="5-放置位置（通常只设置一次！）"><a href="#5-放置位置（通常只设置一次！）" class="headerlink" title="5. 放置位置（通常只设置一次！）"></a>5. 放置位置（通常只设置一次！）</h5><p><code>signal</code> 是用来 <strong>告诉系统：如果收到了这个信号，要怎么处理</strong>，所以——<strong>一定要在信号有可能到来之前就设置好！</strong></p><table><thead><tr><th>常见位置</th><th>说明</th></tr></thead><tbody><tr><td><code>main</code> 一开始就注册</td><td>最常见、最稳妥：程序一启动就告诉内核“收到某个信号就这么处理”。</td></tr><tr><td>启动前先注册</td><td>如果有多线程 &#x2F; fork 子进程，通常会在主线程或父进程里先注册好，再去干别的活</td></tr><tr><td>循环前注册</td><td>千万别把 <code>signal</code> 放在循环里反复调！只需要设置一次就行。</td></tr></tbody></table><h4 id="3-验证-Ctrl-C-是-2-号信号"><a href="#3-验证-Ctrl-C-是-2-号信号" class="headerlink" title="3. 验证 Ctrl+C 是 2 号信号"></a>3. 验证 Ctrl+C 是 2 号信号</h4><p><strong>源码一览：证明信号的本质是宏。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250715231038826.png" alt="image-20250715231031692"></p><p><strong>列出当前系统支持的所有信号名称：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250715231713890.png" alt="image-20250715231713804"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myhandler</span><span class="params">(<span class="type">int</span> signum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;收到信号编号: &quot;</span> &lt;&lt; signum &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 当 signal 使用了自定义“捕获”函数，使用 CTRL+C 退出程序时会无法正常退出，此时在此处调用 exit 函数即可正常退出程序。</span></span><br><span class="line">    <span class="comment">// 不使用 exit 函数，想要退出可以使用 CTRL+\ 组合键。</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">signal</span>(<span class="number">2</span>, myhandler);</span><br><span class="line">    <span class="comment">// 也可以写成 signal(SIGINT, myhandler);</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;运行中，按 Ctrl+C...&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果示例：程序成功打印出“收到信号编号: 2”的字样，证明 Ctrl+C 其实是 2 号信号 SIGINT。</p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250715232026165.png" alt="image-20250715232026079"></p><h2 id="2-信号的产生"><a href="#2-信号的产生" class="headerlink" title="2. 信号的产生"></a>2. 信号的产生</h2><h3 id="1-键盘组合键（终端控制信号）"><a href="#1-键盘组合键（终端控制信号）" class="headerlink" title="1. 键盘组合键（终端控制信号）"></a>1. 键盘组合键（终端控制信号）</h3><ul><li><code>Ctrl+C</code> → 产生 <strong>SIGINT（2 号）</strong></li><li><code>Ctrl+\</code> → 产生 <strong>SIGQUIT（3 号）</strong></li><li><code>Ctrl+Z</code> → 产生 <strong>SIGTSTP（20 号）</strong></li></ul><h3 id="2-kill-命令"><a href="#2-kill-命令" class="headerlink" title="2. kill 命令"></a>2. kill 命令</h3><ul><li><code>kill -9 PID</code> → 给指定进程发 <strong>SIGKILL（9 号）</strong></li><li><code>kill -15 PID</code> → 给指定进程发 <strong>SIGTERM（15 号）</strong></li><li><code>kill -l</code> → 查看所有信号</li></ul><p><code>kill</code> 并不一定“杀”，它本质是“发信号”，<strong>什么信号自己选</strong>。</p><h3 id="3-系统调用"><a href="#3-系统调用" class="headerlink" title="3. 系统调用"></a>3. 系统调用</h3><h4 id="1-kill-函数"><a href="#1-kill-函数" class="headerlink" title="1. kill 函数"></a>1. <code>kill</code> 函数</h4><h5 id="1-功能"><a href="#1-功能" class="headerlink" title="1. 功能"></a>1. 功能</h5><p><code>kill</code> 函数用于向指定 <strong>进程</strong> 或 <strong>进程组</strong> 发送一个信号。常用于：</p><ul><li>结束某个进程（如发送 <code>SIGTERM</code>、<code>SIGKILL</code>）。</li><li>给自己或其他进程发送自定义信号。</li><li>配合信号处理函数（<code>signal</code> &#x2F; <code>sigaction</code>）实现 IPC。</li></ul><p>注意：<code>kill</code> 并不一定会“杀死”进程，它只是发送信号，是否终止要看目标进程是否处理或屏蔽该信号。</p><h5 id="2-函数原型-1"><a href="#2-函数原型-1" class="headerlink" title="2. 函数原型"></a>2. 函数原型</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kill</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> sig)</span></span>;</span><br></pre></td></tr></table></figure><h5 id="3-参数详解-1"><a href="#3-参数详解-1" class="headerlink" title="3. 参数详解"></a>3. 参数详解</h5><ol><li><code>pid_t pid</code>：目标进程 ID 或进程组 ID。特殊值含义如下：<ul><li><code>pid &gt; 0</code>：发送给 PID &#x3D; <code>pid</code> 的单个进程。</li><li><code>pid = 0</code>：发送给当前进程所在进程组的所有进程。</li><li><code>pid = -1</code>：发送给调用者有权发送信号的所有进程（<strong>不推荐危险！</strong>），<strong>在生产中，不要轻易使用 <code>pid = -1</code>，可能会把整个系统都影响了。</strong></li><li><code>pid &lt; -1</code>：发送给 PGID &#x3D; <code>-pid</code> 的进程组中所有进程。</li></ul></li><li><code>int sig</code>：要发送的信号编号，比如 <code>SIGKILL</code>（9）、<code>SIGTERM</code>（15）、<code>SIGSTOP</code>（19）等，也可以是自定义信号（如 <code>SIGUSR1</code>）。</li></ol><h5 id="4-返回值-1"><a href="#4-返回值-1" class="headerlink" title="4. 返回值"></a>4. 返回值</h5><ul><li><strong>成功</strong>：返回 <code>0</code>。</li><li><strong>失败</strong>：返回 <code>-1</code>，并设置 <code>errno</code> 说明错误原因（如 <code>ESRCH</code>：无此 PID，<code>EPERM</code>：权限不足等）。</li></ul><h5 id="5-代码示例"><a href="#5-代码示例" class="headerlink" title="5. 代码示例"></a>5. 代码示例</h5><p>下面给你一个小示例，演示父进程使用 <code>kill</code> 给子进程发送 <code>SIGTERM</code> 信号，子进程注册信号处理函数后捕获该信号：</p><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="type">pid_t</span> pid = fork();</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">&gt;&#123;</span><br><span class="line">   <span class="comment">// 这里是子进程，pid=0</span></span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>)</span><br><span class="line">&gt;&#123;</span><br><span class="line">   <span class="comment">// 这里是父进程，pid=子进程PID</span></span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>                     <span class="comment">// fork(), sleep()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span>                     <span class="comment">// signal(), kill()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span>                   <span class="comment">// wait()</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myhandler</span><span class="params">(<span class="type">int</span> signum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;子进程收到信号：&quot;</span> &lt;&lt; signum &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>)                        <span class="comment">// 子进程</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">signal</span>(<span class="number">2</span>, myhandler);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;子进程运行中，按 Ctrl+C 退出...&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">sleep</span>(<span class="number">1</span>);                   <span class="comment">// 保持运行。子进程休眠，等待父进程发送信号</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)                    <span class="comment">// 父进程</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">3</span>);                       <span class="comment">// 父进程休眠，等待子进程运行</span></span><br><span class="line">        <span class="built_in">kill</span>(pid, <span class="number">2</span>);                   <span class="comment">// 向子进程发送信号</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;父进程向子进程发送信号 2&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">wait</span>(<span class="literal">NULL</span>);                     <span class="comment">// 等待子进程结束</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;子进程已结束，父进程退出！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;fork&quot;</span>);                 <span class="comment">// fork() 失败</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="2-raise-函数"><a href="#2-raise-函数" class="headerlink" title="2. raise 函数"></a>2. <code>raise</code> 函数</h4><h5 id="1-功能-1"><a href="#1-功能-1" class="headerlink" title="1. 功能"></a>1. 功能</h5><p><strong><code>raise</code> 用来让当前程序自己给自己发一个信号。</strong></p><h5 id="2-函数原型-2"><a href="#2-函数原型-2" class="headerlink" title="2. 函数原型"></a>2. 函数原型</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;csignal&gt;</span>  <span class="comment">// 或 &lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">raise</span><span class="params">(<span class="type">int</span> sig)</span></span>;</span><br></pre></td></tr></table></figure><h5 id="3-参数详解-2"><a href="#3-参数详解-2" class="headerlink" title="3. 参数详解"></a>3. 参数详解</h5><p><strong><code>int sig</code>：</strong> 要发出的信号编号（如 <code>SIGTERM</code>、<code>SIGINT</code>）。</p><h5 id="4-返回值-2"><a href="#4-返回值-2" class="headerlink" title="4. 返回值"></a>4. 返回值</h5><ul><li>成功：0。</li><li>失败：非 0。</li></ul><h5 id="5-代码示例-1"><a href="#5-代码示例-1" class="headerlink" title="5. 代码示例"></a>5. 代码示例</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;csignal&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myhandler</span><span class="params">(<span class="type">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;收到信号: &quot;</span> &lt;&lt; sig &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">signal</span>(<span class="number">2</span>, myhandler);  <span class="comment">// 注册自定义处理</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;程序准备即将被终止！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">raise</span>(<span class="number">2</span>);              <span class="comment">// 自己给自己发 SIGTERM</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="3-abort-函数"><a href="#3-abort-函数" class="headerlink" title="3. abort 函数"></a>3. <code>abort</code> 函数</h4><h5 id="1-功能-2"><a href="#1-功能-2" class="headerlink" title="1. 功能"></a>1. 功能</h5><p><strong><code>abort</code> 用来让程序立刻异常终止，发出 <code>SIGABRT</code>（6 号信号）。</strong> 它是固定发 <code>SIGABRT</code>，<strong>不能换别的</strong>。</p><h5 id="2-函数原型-3"><a href="#2-函数原型-3" class="headerlink" title="2. 函数原型"></a>2. 函数原型</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span>  <span class="comment">// C++ 中用 &lt;cstdlib&gt;，C 中用 &lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">abort</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>注意：无参数、无返回值，调用后程序就要终止（如果没捕获 SIGABRT）。</p><h5 id="3-代码示例"><a href="#3-代码示例" class="headerlink" title="3. 代码示例"></a>3. 代码示例</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;csignal&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myhandler</span><span class="params">(<span class="type">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;收到 SIGABRT: &quot;</span> &lt;&lt; sig &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">signal</span>(SIGABRT, myhandler);  <span class="comment">// 注册自定义处理</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;程序即将收到 abort 信号立刻异常终止...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">abort</span>();                     <span class="comment">// 固定发 6号信号 SIGABRT</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="4-kill、raise-和-abort-的区别"><a href="#4-kill、raise-和-abort-的区别" class="headerlink" title="4. kill、raise 和 abort 的区别"></a>4. <code>kill</code>、<code>raise</code> 和 <code>abort</code> 的区别</h4><table><thead><tr><th>函数</th><th>作用</th><th>典型使用场景</th><th>信号目标</th><th>头文件</th><th>特点</th></tr></thead><tbody><tr><td><code>kill</code></td><td>给 <strong>指定进程&#x2F;进程组</strong> 发送信号（<strong>谁都能杀</strong>）</td><td>父进程给子进程发信号、脚本杀进程</td><td>任意指定的进程 PID（或进程组）</td><td><code>&lt;signal.h&gt;</code></td><td>最通用，支持跨进程发信号</td></tr><tr><td><code>raise</code></td><td>给 <strong>自己（当前进程）</strong> 发送信号（<strong>自己吓自己</strong>）</td><td>程序内部触发某个信号（模拟外部 kill）</td><td>调用它的当前进程</td><td><code>&lt;signal.h&gt;</code></td><td>相当于 <code>kill(getpid(), signum)</code></td></tr><tr><td><code>abort</code></td><td>给 <strong>自己</strong> 发送 <code>SIGABRT</code> 信号（<strong>自己崩溃</strong>）</td><td>程序发现不可恢复错误时触发异常中止</td><td>调用它的当前进程</td><td><code>&lt;cstdlib&gt;</code>（C++），<code>&lt;stdlib.h&gt;</code>（C）</td><td>只能发 <code>SIGABRT</code>，直接终止程序并产生 core dump（若开启）</td></tr></tbody></table><h3 id="4-硬件异常"><a href="#4-硬件异常" class="headerlink" title="4. 硬件异常"></a>4. 硬件异常</h3><h4 id="1-除以-0-导致异常"><a href="#1-除以-0-导致异常" class="headerlink" title="1. 除以 0 导致异常"></a>1. 除以 0 导致异常</h4><ul><li>CPU 有除法指令，如果除数是 0，CPU <strong>硬件级别检测到非法操作</strong>，硬件立刻触发，这个异常会立刻 <strong>中断当前指令执行</strong>，由 CPU 抛给操作系统。操作系统收到异常中断后，根据异常类型找对应的 <strong>异常处理程序</strong>。</li><li>如果是用户态进程除 0，OS 默认是：给该进程发送 <code>SIGFPE</code> （Floating Point Exception）信号。如果进程没处理这个信号，就会被 OS 杀掉并回收资源。</li></ul><p><strong>所以：除以 0 &#x3D; 硬件发现错误 → 触发 CPU 异常 → OS 发 SIGFPE → 进程崩溃</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myhandler</span><span class="params">(<span class="type">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;收到的信号是：&quot;</span> &lt;&lt; sig &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// signal(SIGFPE, myhandler);</span></span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;这是除以 0 之前！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    a /= <span class="number">0</span>;                    <span class="comment">// 触发 SIGFPE 信号</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;这是除以 0 之后！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果示例：</p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250716145736660.png" alt="image-20250716145736498"></p><h4 id="2-野指针导致异常"><a href="#2-野指针导致异常" class="headerlink" title="2. 野指针导致异常"></a>2. 野指针导致异常</h4><p>每个进程有自己的 <strong>虚拟地址空间</strong>，由操作系统 + CPU 的 MMU（内存管理单元，现代计算机会将 MMU 放入 CPU）一起管理。CPU 用 MMU 把“虚拟地址”翻译成“物理地址”；访问未映射或权限不符的地址 → MMU 触发 Page Fault → 内核一看是“合法缺页”就帮你补页，是“非法野指针”就发 SIGSEGV，默认把进程干掉。</p><p><strong>所以：非法访问 &#x3D; MMU 拦截 → Page Fault → OS 判定非法 → 发 SIGSEGV → 进程被杀</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myhandler</span><span class="params">(<span class="type">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;收到的信号是：&quot;</span> &lt;&lt; sig &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);                   <span class="comment">// 注释掉会导致程序无限循环，可以尝试注释掉观察现象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">signal</span>(SIGSEGV, myhandler);</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;这是程序开始之前！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> *p = <span class="literal">nullptr</span>;</span><br><span class="line">    *p = <span class="number">10</span>;                    <span class="comment">// 野指针，会触发信号 SIGSEGV</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;这是程序结束之后！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果示例：</p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250716150703600.png" alt="image-20250716150703445"></p><h3 id="5-软件条件"><a href="#5-软件条件" class="headerlink" title="5. 软件条件"></a>5. 软件条件</h3><blockquote><p><code>SIGPIPE</code> 就是典型的软件条件信号：管道通信：① 写端：进程 A    ② 读端：进程 B。正常流程：A 写 → B 读 → 数据传递。</p><p>异常场景：</p><ul><li>B 提前关闭读端（<code>close(fd)</code>），或者 B 异常退出。</li><li>A 还在不停 <code>write(fd, ...)</code>。</li></ul><p><code>SIGPIPE</code> &#x3D; <strong>“没人接水龙头却还在放水”</strong> → OS 发现了 → 给你发信号 → 不处理就直接 kill。</p></blockquote><p>软件条件的信号本质上是 <strong>内核或程序自己产生</strong> 的，常用来定时器、子进程管理、超时处理。注意：不是硬件 CPU 抛出的硬件异常，而是 OS 根据进程&#x2F;资源状态来调度。<code>alarm</code> 是其中最典型的。</p><h4 id="1-alarm-函数"><a href="#1-alarm-函数" class="headerlink" title="1. alarm 函数"></a>1. <code>alarm</code> 函数</h4><h5 id="1-功能-3"><a href="#1-功能-3" class="headerlink" title="1. 功能"></a>1. 功能</h5><p><code>alarm</code> 用来在指定的若干秒后，自动向当前进程发送 <code>SIGALRM</code> 信号（14 号信号）。常用于实现简单的超时控制，比如：</p><ul><li>程序运行超过 N 秒就触发中断。</li><li>防止阻塞的 IO 卡死。</li><li>与 <code>signal(SIGALRM, handler)</code> 配合使用。</li><li><code>alarm</code> 通常只能设置一个闹钟，再次调用会覆盖上一次设置。</li></ul><h5 id="2-函数原型-4"><a href="#2-函数原型-4" class="headerlink" title="2. 函数原型"></a>2. 函数原型</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">alarm</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> seconds)</span></span>;</span><br></pre></td></tr></table></figure><h5 id="3-参数详解-3"><a href="#3-参数详解-3" class="headerlink" title="3. 参数详解"></a>3. 参数详解</h5><p><strong><code>seconds</code>：</strong> 多少秒后发出 <code>SIGALRM</code>，设为 0 则取消之前设置的闹钟。</p><h5 id="4-返回值-3"><a href="#4-返回值-3" class="headerlink" title="4. 返回值"></a>4. 返回值</h5><ul><li>返回之前设置的剩余秒数（若没有则返回 0）。</li><li>如果要设置新的闹钟，返回值表示原闹钟还有多久触发。</li></ul><h5 id="5-代码示例-2"><a href="#5-代码示例-2" class="headerlink" title="5. 代码示例"></a>5. 代码示例</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>   <span class="comment">// alarm</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span>   <span class="comment">// signal</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myhandler</span><span class="params">(<span class="type">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;收到 SIGALRM 信号，编号：&quot;</span> &lt;&lt; sig &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);          <span class="comment">// 如果注释掉这里，也必须要注释掉 signal 函数（或者单独注释掉 alarm 函数），运行才会只显示前5秒的输出</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">signal</span>(SIGALRM, myhandler);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;设置闹钟，5 秒后触发 SIGALRM...&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">alarm</span>(<span class="number">5</span>);          <span class="comment">// 5 秒后产生 SIGALRM</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;程序运行中: &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; 秒&quot;</span> &lt;&lt; endl;   <span class="comment">// 程序只会运行到 i=5 秒，然后被 SIGALRM 信号中断</span></span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;程序结束。&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[hcc@hcss-ecs-be68 Signal Generation]$ ./alarm </span><br><span class="line">设置闹钟，5 秒后触发 SIGALRM...</span><br><span class="line">程序运行中: 1 秒</span><br><span class="line">程序运行中: 2 秒</span><br><span class="line">程序运行中: 3 秒</span><br><span class="line">程序运行中: 4 秒</span><br><span class="line">程序运行中: 5 秒</span><br><span class="line">收到 SIGALRM 信号，编号：14</span><br></pre></td></tr></table></figure><p>父子进程 + alarm + signal 代码示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>     <span class="comment">// fork(), alarm(), sleep()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span>     <span class="comment">// signal()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span>   <span class="comment">// wait()</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">alarm_handler</span><span class="params">(<span class="type">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;子进程收到 SIGALRM 信号，编号：&quot;</span> &lt;&lt; sig &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;子进程启动，PID: &quot;</span> &lt;&lt; <span class="built_in">getpid</span>() &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">signal</span>(SIGALRM, alarm_handler);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">alarm</span>(<span class="number">5</span>);                           <span class="comment">// 设置 5 秒后触发 SIGALRM</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;子进程运行中: &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; 秒&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;子进程正常结束。&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;父进程启动，PID: &quot;</span> &lt;&lt; <span class="built_in">getpid</span>() &lt;&lt; <span class="string">&quot;，等待子进程...&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> status;</span><br><span class="line">        <span class="built_in">waitpid</span>(pid, &amp;status, <span class="number">0</span>);           <span class="comment">// 阻塞等待子进程结束</span></span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;父进程检测到子进程结束，父进程退出。&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[hcc@hcss-ecs-be68 Signal Generation]$ ./alarm2</span><br><span class="line">父进程启动，PID: 1754，等待子进程...</span><br><span class="line">子进程启动，PID: 1755</span><br><span class="line">子进程运行中: 1 秒</span><br><span class="line">子进程运行中: 2 秒</span><br><span class="line">子进程运行中: 3 秒</span><br><span class="line">子进程运行中: 4 秒</span><br><span class="line">子进程运行中: 5 秒</span><br><span class="line">子进程收到 SIGALRM 信号，编号：14</span><br><span class="line">父进程检测到子进程结束，父进程退出。</span><br></pre></td></tr></table></figure><h4 id="2-常用信号"><a href="#2-常用信号" class="headerlink" title="2. 常用信号"></a>2. 常用信号</h4><p>使用 <code>man 7 signal</code> 命令（偏底部）查看：</p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250716232959970.png" alt="image-20250716232959815"></p><p>做一个简单的小翻译：</p><table><thead><tr><th>信号名</th><th>数值</th><th>默认动作</th><th>中文含义</th></tr></thead><tbody><tr><td><strong>SIGHUP</strong></td><td>1</td><td>Term</td><td>挂起：控制终端关闭或父进程终止</td></tr><tr><td><strong>SIGINT</strong></td><td>2</td><td>Term</td><td>键盘中断（Ctrl+C）</td></tr><tr><td><strong>SIGQUIT</strong></td><td>3</td><td>Core</td><td>键盘退出（Ctrl+\），并生成 core dump</td></tr><tr><td><strong>SIGILL</strong></td><td>4</td><td>Core</td><td>非法指令（CPU 执行了未定义或错误的指令）</td></tr><tr><td><strong>SIGABRT</strong></td><td>6</td><td>Core</td><td>程序调用 <code>abort()</code>，异常终止并生成 core dump</td></tr><tr><td><strong>SIGFPE</strong></td><td>8</td><td>Core</td><td>浮点异常（除以 0、溢出）并生成 core dump</td></tr><tr><td><strong>SIGKILL</strong></td><td>9</td><td>Term</td><td>强制终止（不可捕获，不可忽略）</td></tr><tr><td><strong>SIGSEGV</strong></td><td>11</td><td>Core</td><td>无效内存引用（段错误，野指针）并生成 core dump</td></tr><tr><td><strong>SIGPIPE</strong></td><td>13</td><td>Term</td><td>管道破裂：写端写但没人读</td></tr><tr><td><strong>SIGALRM</strong></td><td>14</td><td>Term</td><td>定时器到期（由 <code>alarm()</code> 触发）</td></tr><tr><td><strong>SIGTERM</strong></td><td>15</td><td>Term</td><td>终止信号（程序优雅退出）</td></tr><tr><td><strong>SIGUSR1</strong></td><td>30,10,16</td><td>Term</td><td>用户自定义信号 1</td></tr><tr><td><strong>SIGUSR2</strong></td><td>31,12,17</td><td>Term</td><td>用户自定义信号 2</td></tr><tr><td><strong>SIGCHLD</strong></td><td>20,17,18</td><td>Ign</td><td>子进程停止或结束</td></tr><tr><td><strong>SIGCONT</strong></td><td>19,18,25</td><td>Cont</td><td>恢复已停止的进程</td></tr><tr><td><strong>SIGSTOP</strong></td><td>17,19,23</td><td>Stop</td><td>停止进程（不可捕获，不可忽略）</td></tr><tr><td><strong>SIGTSTP</strong></td><td>18,20,24</td><td>Stop</td><td>从终端暂停（Ctrl+Z）</td></tr><tr><td><strong>SIGTTIN</strong></td><td>21,21,26</td><td>Stop</td><td>后台进程请求终端输入</td></tr><tr><td><strong>SIGTTOU</strong></td><td>22,22,27</td><td>Stop</td><td>后台进程请求终端输出</td></tr></tbody></table><p><strong>默认动作关键说明：</strong></p><ul><li><strong>终止（Term）</strong> ：终止进程。</li><li><strong>核心转储（Core）</strong> ：终止进程并生成 <strong>core dump 文件</strong>（用于调试）。<strong>注意：一般虚拟机上是启用的，而云服务器上是关闭的！</strong></li><li><strong>忽略（Ign）</strong> ：忽略该信号。</li><li><strong>继续（Cont）</strong> ：继续已暂停的进程。</li><li><strong>暂停（Stop）</strong> ：暂停进程（进程挂起，状态变成 T）。</li></ul><h5 id="1-Core-dump-是什么？"><a href="#1-Core-dump-是什么？" class="headerlink" title="1. Core dump 是什么？"></a>1. Core dump 是什么？</h5><p>Core Dump 是程序崩溃时的“事故现场记录仪”，通过它开发者可以精准还原崩溃时的程序状态，<strong>是调试复杂问题的关键工具（事后调试）</strong>。合理配置 Core Dump 生成规则，并结合 GDB 等工具分析，能显著提升问题排查效率。打开 OS 的 Core Dump 功能后，一旦进程出现异常，OS 会将进程在内存中的运行信息给 Dump（转存）到进程当前目录（磁盘）上形成 core.pid 文件！</p><p>相关命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ulimit</span> -c<span class="comment"># 查看当前进程最大 Core 文件大小（单位：KB）</span></span><br><span class="line"><span class="built_in">ulimit</span> -c unlimited <span class="comment"># 临时对当前 shell 启用，关闭 shell 后失效（0 表示禁用，unlimited 表示 无限制，即允许生成）</span></span><br><span class="line"><span class="built_in">ulimit</span> -c 0<span class="comment"># 临时禁用</span></span><br></pre></td></tr></table></figure><p>Core Dump 还有其他相关命令，这里就不过多赘述了，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>     <span class="comment">// fork(), sleep(), getpid(), exit()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span>   <span class="comment">// waitpid()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span>      <span class="comment">// exit()</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> id = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (id == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (cnt)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;我是子进程, 我的 pid 是: &quot;</span> &lt;&lt; <span class="built_in">getpid</span>() &lt;&lt; <span class="string">&quot;, 剩余次数: &quot;</span> &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">sleep</span>(<span class="number">1</span>);               <span class="comment">// 每秒打印一次</span></span><br><span class="line">            cnt--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注释掉下面这2行，子进程会正常退出，core dump（核心转储）也会显示 0，不注释则显示1</span></span><br><span class="line">        <span class="type">int</span> *p = <span class="literal">nullptr</span>;</span><br><span class="line">        *p = <span class="number">123</span>;                   <span class="comment">// 访问空指针，必触发 SIGSEGV，从而显示 core dump（核心转储）</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);                    <span class="comment">// 子进程正常退出，返回码 0(永远走不到这里)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> status = <span class="number">0</span>;</span><br><span class="line">    <span class="type">pid_t</span> rid = <span class="built_in">waitpid</span>(id, &amp;status, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rid == id)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;子进程结束，进程 id:&quot;</span> &lt;&lt; rid &lt;&lt; <span class="string">&quot;   &quot;</span>&lt;&lt; <span class="string">&quot;退出码:&quot;</span> &lt;&lt; ((status &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>) &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;退出信号: &quot;</span> &lt;&lt; (status &amp; <span class="number">0x7F</span>) &lt;&lt; <span class="string">&quot;   &quot;</span> &lt;&lt; <span class="string">&quot;核心转储: &quot;</span> &lt;&lt; ((status &gt;&gt; <span class="number">7</span>) &amp; <span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在进程等待的章节中讲过 <code>status</code> 的位布局，这里深入理解一下：</p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250414221823071.png" alt="image-20250414221815934"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">31                              16 15              8 7     7 6         0</span><br><span class="line">+--------------------------------+------------------+-------+----------+</span><br><span class="line">|           其他保留             |  <span class="built_in">exit</span> code(8位)  | core? | signal(7位)|</span><br><span class="line">+--------------------------------+------------------+-------+----------+</span><br></pre></td></tr></table></figure><p>内核会把 <strong>子进程的退出信息</strong> 打包成一个 <strong>int 型整数</strong>，放到 <code>status</code> 里，这个整数就像一个 <strong>位图</strong>，把多个信息整理到了一块。这也是为什么没有 32、33 号信号的原因。</p><p><strong>这个位图里面放了什么？</strong></p><table><thead><tr><th>位区</th><th>意义</th><th>举例</th></tr></thead><tbody><tr><td>高 8 位（位 8~15）</td><td>如果子进程是调用 <code>exit</code> 正常退出，这里是返回码</td><td><code>exit(42)</code> → 高 8 位 &#x3D; 42</td></tr><tr><td>低 7 位（位 0~6）</td><td>如果子进程是被信号杀死，这里放 <strong>信号编号</strong></td><td><code>SIGSEGV</code> → 11</td></tr><tr><td>第 7 位（位 7）</td><td>如果是信号杀死，且生成了 core dump，这里是 1</td><td>有 core dump</td></tr><tr><td>其他</td><td>还有一些特定状态（暂停&#x2F;继续）可用宏判断</td><td><code>WIFSTOPPED</code>、<code>WIFCONTINUED</code></td></tr></tbody></table><p><strong>用位运算怎么拆？</strong></p><table><thead><tr><th>表达式</th><th>意义</th></tr></thead><tbody><tr><td><code>(status &gt;&gt; 8) &amp; 0xFF</code></td><td>右移 8 位，取高 8 位 &#x3D; <code>exit code</code></td></tr><tr><td><code>status &amp; 0x7F</code></td><td>低 7 位，表示终止信号编号</td></tr><tr><td><code>(status &gt;&gt; 7) &amp; 1</code></td><td>第 7 位，表示是否生成 core dump</td></tr></tbody></table></blockquote><p>运行结果示例：</p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250717002737826.png" alt="image-20250717002737659"></p><p><strong>Core Dump 的调试：</strong> 一般会显示信号信息、调用堆栈、寄存器状态、错误行号、变量值等一系列非常详细的信息！</p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250717005042032.png" alt="image-20250717005041894"></p><p>更多调试命令请自行百度，这里点到为止了。</p><blockquote><p><strong>安装调试包命令：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="built_in">sudo</span> yum install debuginfo-install glibc-2.17-326.el7_9.3.x86_64 libgcc-4.8.5-44.el7.x86_64</span><br></pre></td></tr></table></figure></blockquote><hr><h5 id="2-为什么-Core-Dump-一般虚拟机上是启用的，而云服务器上是关闭的？"><a href="#2-为什么-Core-Dump-一般虚拟机上是启用的，而云服务器上是关闭的？" class="headerlink" title="2. 为什么 Core Dump 一般虚拟机上是启用的，而云服务器上是关闭的？"></a>2. 为什么 Core Dump 一般虚拟机上是启用的，而云服务器上是关闭的？</h5><ol><li><p><strong>在虚拟机上：</strong></p><ul><li><p><strong>调试优先</strong>：在本地虚拟机（开发机、测试机），程序挂掉后要调试，最有用的证据就是 <strong>core 文件</strong>（它保存了崩溃时的内存、堆栈、寄存器）。</p></li><li><p><strong>单机单人可控</strong>：一般是自己用或者小团队用，没有什么安全风险，也不担心磁盘写 core。</p></li><li><p><strong>调试习惯</strong>：开发环境崩溃了，生成 core → <code>gdb ./a.out core.xxx</code> → 定位 bug，常规套路。</p></li></ul></li><li><p><strong>在云服务器上：</strong></p><ul><li><p><strong>生产环境以安全和稳定为主，不是以调试为主！</strong></p></li><li><p><strong>安全隐私风险大：</strong> core dump 会把 <strong>整个进程内存快照</strong> 写到文件里，里面可能包含：明文账号密码、秘钥、用户数据（比如客户表单、交易信息）等，一旦留在磁盘或者被误传出去，就是安全事故。</p></li></ul></li><li><p><strong>影响稳定性：</strong> 仔细观察会发现：几十行的代码就会生成体积非常庞大的 core 文件。如果线上进程瞬间崩溃大量生成 core（一个 core 可以几个 GB），会把服务器磁盘打满，后果很严重（尤其是在大型服务器集群中非常显著！）：</p><ul><li><p>其他服务写文件失败。</p></li><li><p>数据库宕机。</p></li><li><p>整个实例卡死。</p></li></ul></li><li><p><strong>运维风控：</strong> 生产环境一般靠 <strong>日志</strong>、<strong>监控告警</strong> 和最小可复现 Demo 来定位问题，不直接看 core dump。有些还存在自动化的专业 debug 工具&#x2F;脚本等。</p></li></ol><h4 id="3-普通信号-VS-实时信号（了解）"><a href="#3-普通信号-VS-实时信号（了解）" class="headerlink" title="3. 普通信号 VS 实时信号（了解）"></a>3. 普通信号 VS 实时信号（了解）</h4><p><strong>早期 UNIX</strong>：</p><ul><li>信号是最简单的 IPC，设计得很“轻”：只要告诉你“有事情发生了”，具体什么事情、来了几次都不重要。</li><li>所以，重复来的同一个信号只保留一个，省开销。</li></ul><p><strong>后来的实时场景</strong>：</p><ul><li>有些实时系统（工业控制、航空、机器人）需要精确传递多次事件（每次都重要）。</li><li>所以 Linux 引入了 <strong>实时信号</strong>，内核会把多个相同实时信号放到队列里，保证每一个都能送达。</li></ul><table><thead><tr><th>维度</th><th>普通信号</th><th>实时信号</th></tr></thead><tbody><tr><td>范围</td><td>1 ~ 31</td><td>32 ~ 64</td></tr><tr><td>是否排队</td><td>不排队，同类型只保留 1 个</td><td>排队，同类型多个也可以同时排队</td></tr><tr><td>发送顺序</td><td>不保证顺序</td><td>保证顺序 FIFO</td></tr><tr><td>优先级</td><td>没有严格优先级</td><td>实时信号优先级可自定义</td></tr><tr><td>用途</td><td>kill、Ctrl+C、kill -9、常见系统信号</td><td>高实时性要求的 IPC，比如实时控制、进程间发送大量通知</td></tr><tr><td>标准来源</td><td>早期 UNIX</td><td>POSIX.1b</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 进程 </tag>
            
            <tag> 信号 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>035 System V 消息队列和信号量（了解）</title>
      <link href="/posts/30975.html"/>
      <url>/posts/30975.html</url>
      
        <content type="html"><![CDATA[<h1 id="System-V-消息队列和信号量（了解）"><a href="#System-V-消息队列和信号量（了解）" class="headerlink" title="System V 消息队列和信号量（了解）"></a>System V 消息队列和信号量（了解）</h1><blockquote><p><a href="https://blog.csdn.net/2301_80224556/article/details/139770820">【Linux】进程间通信 4——system V 消息队列，信号量 | CSDN</a></p><p><a href="https://blog.csdn.net/weixin_42511997/article/details/106444445">System V IPC —- 消息队列详解 | CSDN 博客</a></p><p><a href="https://www.softprayog.in/programming/interprocess-communication-using-system-v-message-queues-in-linux">消息队列的视频 &amp; 博文 | YouTobe</a></p><p><a href="https://docs.oracle.com/cd/E19683-01/806-4125/svipc-23310/index.html">System V 消息队列（编程接口指南）</a></p><p><a href="https://www.bilibili.com/video/BV18P41187NV/?spm_id_from=333.337.search-card.all.click">信号量机制讲解</a></p></blockquote><h2 id="1-消息队列的原理"><a href="#1-消息队列的原理" class="headerlink" title="1. 消息队列的原理"></a>1. 消息队列的原理</h2><p><strong>System V 消息队列</strong> 是 UNIX&#x2F;Linux 下的一种 <strong>进程间通信（IPC）机制</strong>，它允许不同进程以 <strong>消息（message）为单位交换数据</strong>，消息以 <strong>先进先出</strong> 的队列形式组织。<strong>异步通信</strong>：发送者发送后可以立即返回，接收者可随时读取。</p><blockquote><p>  <strong>System V 消息队列通过在内核中维护一个带有类型标记（<code>mtype</code>）的 FIFO 队列，实现了同一物理队列内多逻辑队列的分发能力，所有消息存在内核缓冲区，进程间通过 <code>msgsnd</code>&#x2F;<code>msgrcv</code> 异步收发，OS 负责元数据管理与调度。</strong></p><p>  <em>“如果只是一味地读数据，进程怎么知道哪些才是应该要读取的数据？”</em><br>  这就是 <code>mtype</code> 的意义——把“一个大 FIFO”变成“多条逻辑子队列”。这也是 System V MQ 和单纯的管道（Pipe）的关键区别：<strong>管道只能 FIFO，消息队列支持 FIFO + 过滤 + 类型分发。</strong></p></blockquote><p>核心特征：</p><ol><li><strong>内核维护队列</strong>：由操作系统内核创建并管理 <strong>内存中的消息队列</strong>（不落盘，系统重启消失）。</li><li><strong>消息结构</strong><ul><li>每条消息包含：<ul><li><strong><code>mtype</code></strong>：正整数类型标签（类型标识）。</li><li><strong><code>mtext</code></strong>：数据块&#x2F;正文数据，用户定义的内容（柔性数组）。</li></ul></li></ul></li><li><strong>队列操作（先进先出）</strong><ul><li><strong>发送&#x2F;写操作 (<code>msgsnd</code>)</strong>：<ul><li>消息 <strong>追加到队尾</strong>（FIFO 基础）。</li><li>队列满时默认 <strong>阻塞</strong>，支持 <code>IPC_NOWAIT</code> 非阻塞。</li></ul></li><li><strong>接收&#x2F;读操作 (<code>msgrcv</code>)</strong>：<ul><li><strong>按 <code>mtype</code> 选择性读取</strong>：<ul><li><code>type=0</code>：读队首消息。</li><li><code>type&gt;0</code>：读匹配类型的 <strong>第一条消息</strong>（可打破 FIFO）。</li><li><code>type&lt;0</code>：读类型值 ≤ <code>|type|</code> 的最小类型消息。</li></ul></li><li>无匹配消息时默认 <strong>阻塞</strong>。</li></ul></li></ul></li><li><strong>生命周期与权限</strong><ul><li><strong>独立于进程</strong>：队列需显式删除（<code>msgctl(IPC_RMID)</code>），否则持久存在。</li><li>通过权限结构（UID&#x2F;GID、读写模式）控制访问。</li></ul></li></ol><p>当 OS 中存在多个消息队列，OS 自然也需要进行管理，这就又是 <strong>先描述再组织</strong>：先有数据的抽象描述（如 <code>msgbuf</code>），再有内核中的组织与管理（<code>msqid_ds</code> 结构和消息链表）。</p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250709094048435.png" alt="image-20250709094041044"></p><h2 id="2-柔性数组"><a href="#2-柔性数组" class="headerlink" title="2. 柔性数组"></a>2. 柔性数组</h2><h3 id="1-什么是“柔性数组”？"><a href="#1-什么是“柔性数组”？" class="headerlink" title="1. 什么是“柔性数组”？"></a>1. 什么是“柔性数组”？</h3><p><strong>柔性数组</strong> 简称 FAM，是 C99 引入的一种特殊语法：<strong>结构体的最后一个成员可以声明为大小未知的数组</strong>，用来在结构体后面动态附加可变长度的数据。<strong>作用：</strong> 允许在一个结构体后面连续存放额外的数据，而不需要在结构体里写死数组长度。</p><hr><h3 id="2-System-V-消息队列里的体现"><a href="#2-System-V-消息队列里的体现" class="headerlink" title="2. System V 消息队列里的体现"></a>2. System V 消息队列里的体现</h3><p>来看标准定义（man 手册示例）：</p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250709101910590.png" alt="image-20250709101910493"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">long</span> mtype;    <span class="comment">// 消息类型</span></span><br><span class="line">    <span class="type">char</span> mtext[<span class="number">1</span>]; <span class="comment">// 消息正文</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><em>这里的 <code>mtext[1]</code> 很多人看到会觉得奇怪：为什么写 <code>[1]</code> 不是写 <code>[0]</code>？</em> 这是典型的 <strong>柔性数组的老写法</strong>，在老式 UNIX C 库中常这么用，因为 C90 没有正式的 <code>[0]</code> 或 <code>[]</code> 语法。在现代写法里，更标准的是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">long</span> mtype;</span><br><span class="line">    <span class="type">char</span> mtext[]; <span class="comment">// 正确的 C99 柔性数组</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="3-发送时是怎么用的？"><a href="#3-发送时是怎么用的？" class="headerlink" title="3. 发送时是怎么用的？"></a>3. 发送时是怎么用的？</h3><ul><li><p>当调用 <code>msgsnd</code> 时，<strong>内核不会管你 <code>mtext</code> 写多长</strong>，它只看你 <code>msgsz</code> 参数里指定的大小。</p></li><li><p>所以 <code>mtext</code> 只是占个位，真正的内存是由你自己分配：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">mymsg</span>* m = <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">long</span>) + real_size);</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>这就是柔性数组的经典用法：<strong>结构体头 + 动态数据块</strong>，组成真正的消息。System V 消息队列的 <code>msgbuf</code>：是一个 <strong>固定头（mtype）+ 可变长正文（mtext）</strong> 的数据结构。<code>mtext</code> 本质是柔性数组（FAM）。这让同一个消息结构既可以描述元信息，也可以承载变长数据。传给内核时，内核只看 <code>msgsz</code>，并按字节拷贝。<strong>System V 消息队列用 FAM 来封装任意长度的消息内容，保证 <code>msgbuf</code> 在同一个内存块中连续存储 mtype 和 mtext，简化了内核拷贝和用户态对齐。</strong></p></blockquote><hr><h2 id="3-系统调用（类比共享内存中-shmget-等函数）"><a href="#3-系统调用（类比共享内存中-shmget-等函数）" class="headerlink" title="3. 系统调用（类比共享内存中 shmget 等函数）"></a>3. 系统调用（类比共享内存中 <code>shmget</code> 等函数）</h2><h3 id="1-ftok-——-生成唯一的-key-t，供-msgget-使用"><a href="#1-ftok-——-生成唯一的-key-t，供-msgget-使用" class="headerlink" title="1. ftok —— 生成唯一的 key_t，供 msgget 使用"></a>1. <code>ftok</code> —— 生成唯一的 <code>key_t</code>，供 <code>msgget</code> 使用</h3><p>上一节已经讲过 <code>ftok</code>，使用方法一模一样就不多赘述了，对于下面的 <code>msgget</code> 同样适用，同样的 <strong>非必须但推荐</strong>！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">key_t</span> <span class="title">ftok</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> proj_id)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="2-msgget-——-创建"><a href="#2-msgget-——-创建" class="headerlink" title="2. msgget —— 创建"></a>2. <code>msgget</code> —— 创建</h3><h4 id="1-功能"><a href="#1-功能" class="headerlink" title="1. 功能"></a>1. 功能</h4><p>创建或打开一个消息队列。</p><h4 id="2-函数原型"><a href="#2-函数原型" class="headerlink" title="2. 函数原型"></a>2. 函数原型</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">msgget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">int</span> msgflg)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="3-msgflg-常用标志"><a href="#3-msgflg-常用标志" class="headerlink" title="3. msgflg 常用标志"></a>3. <code>msgflg</code> 常用标志</h4><ul><li><code>IPC_CREAT</code>：若不存在则创建。</li><li><code>IPC_EXCL</code>：和 <code>IPC_CREAT</code> 一起用，若已存在则报错。</li><li>权限位如 <code>0666</code>（所有用户可读写），<code>0644</code>（所有者读写，其他用户只读）。</li></ul><h4 id="4-返回值"><a href="#4-返回值" class="headerlink" title="4. 返回值"></a>4. 返回值</h4><ul><li><strong>成功</strong>：消息队列标识符（非负整数）。</li><li><strong>失败</strong>：-1，设置 <code>errno</code>。常见错误：<ul><li><code>EEXIST</code>：<code>IPC_CREAT|IPC_EXCL</code> 时队列已存在。</li><li><code>ENOENT</code>：队列不存在且未指定 <code>IPC_CREAT</code>。</li><li><code>EACCES</code>：权限不足。</li></ul></li></ul><h3 id="3-msgsnd-——-发送-写操作"><a href="#3-msgsnd-——-发送-写操作" class="headerlink" title="3. msgsnd —— 发送&#x2F;写操作"></a>3. <code>msgsnd</code> —— 发送&#x2F;写操作</h3><h4 id="1-功能-1"><a href="#1-功能-1" class="headerlink" title="1. 功能"></a>1. 功能</h4><p>发送消息。</p><h4 id="2-函数原型-1"><a href="#2-函数原型-1" class="headerlink" title="2. 函数原型"></a>2. 函数原型</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">msgsnd</span><span class="params">(<span class="type">int</span> msqid, <span class="type">const</span> <span class="type">void</span> *msgp, <span class="type">size_t</span> msgsz, <span class="type">int</span> msgflg)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="3-参数"><a href="#3-参数" class="headerlink" title="3. 参数"></a>3. 参数</h4><ul><li><code>msqid</code>：队列 ID。</li><li><code>msgp</code>：消息结构体指针。</li><li><code>msgsz</code>：不包括 <code>mtype</code> 的消息长度。</li><li><code>msgflg</code>：可用 <code>IPC_NOWAIT</code> 非阻塞。</li></ul><h4 id="4-返回值-1"><a href="#4-返回值-1" class="headerlink" title="4. 返回值"></a>4. 返回值</h4><ul><li><strong>成功</strong>：0</li><li><strong>失败</strong>：-1，设置 <code>errno</code>。常见错误：<ul><li><code>EAGAIN</code>：非阻塞模式下队列满。</li><li><code>EIDRM</code>：队列被删除。</li><li><code>EACCES</code>：无写权限。</li><li><code>EINVAL</code>：参数无效。</li></ul></li></ul><h3 id="4-msgrcv-——-接收-读操作"><a href="#4-msgrcv-——-接收-读操作" class="headerlink" title="4. msgrcv —— 接收&#x2F;读操作"></a>4. <code>msgrcv</code> —— 接收&#x2F;读操作</h3><h4 id="1-功能-2"><a href="#1-功能-2" class="headerlink" title="1. 功能"></a>1. 功能</h4><p>接收消息。</p><h4 id="2-函数原型-2"><a href="#2-函数原型-2" class="headerlink" title="2. 函数原型"></a>2. 函数原型</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">msgrcv</span><span class="params">(<span class="type">int</span> msqid, <span class="type">void</span> *msgp, <span class="type">size_t</span> msgsz, <span class="type">long</span> mtype, <span class="type">int</span> msgflg)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="3-参数详解"><a href="#3-参数详解" class="headerlink" title="3. 参数详解"></a>3. 参数详解</h4><table><thead><tr><th>参数</th><th>含义</th><th>关键点</th></tr></thead><tbody><tr><td><code>msqid</code></td><td>消息队列 ID</td><td><code>msgget</code> 得到</td></tr><tr><td><code>msgp</code></td><td>接收消息的结构体指针</td><td><code>msgbuf*</code></td></tr><tr><td><code>msgsz</code></td><td>正文大小（<strong>不含 mtype</strong>）</td><td><code>sizeof(mtext)</code></td></tr><tr><td><code>mtype</code></td><td>要接收的类型</td><td><code>0</code> 表示任意类型</td></tr><tr><td><code>msgflg</code></td><td>标志</td><td><code>0</code> 或 <code>IPC_NOWAIT</code></td></tr></tbody></table><h4 id="4-返回值-2"><a href="#4-返回值-2" class="headerlink" title="4. 返回值"></a>4. 返回值</h4><ul><li><strong>成功</strong>：实际接收的字节数（<code>mtext</code> 长度）</li><li><strong>失败</strong>：-1，设置 <code>errno</code>。常见错误：<ul><li><code>ENOMSG</code>：无匹配消息（非阻塞模式）。</li><li><code>E2BIG</code>：消息过大且未指定 <code>MSG_NOERROR</code>。</li><li><code>EIDRM</code>：队列被删除。</li></ul></li></ul><h3 id="5-msgctl-——-删除（控制）"><a href="#5-msgctl-——-删除（控制）" class="headerlink" title="5. msgctl —— 删除（控制）"></a>5. <code>msgctl</code> —— 删除（控制）</h3><h4 id="1-功能-3"><a href="#1-功能-3" class="headerlink" title="1. 功能"></a>1. 功能</h4><p>对队列做控制操作。常用作删除操作。</p><h4 id="2-函数原型-3"><a href="#2-函数原型-3" class="headerlink" title="2. 函数原型"></a>2. 函数原型</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">msgctl</span><span class="params">(<span class="type">int</span> msqid, <span class="type">int</span> cmd, <span class="keyword">struct</span> msqid_ds *buf)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="3-参数详解-1"><a href="#3-参数详解-1" class="headerlink" title="3. 参数详解"></a>3. 参数详解</h4><p><strong>常用 <code>cmd</code>：</strong></p><ul><li><code>IPC_RMID</code>：删除消息队列（最常用）。</li><li><code>IPC_STAT</code>：获取队列状态。</li><li><code>IPC_SET</code>：设置参数。</li></ul><h4 id="4-返回值-3"><a href="#4-返回值-3" class="headerlink" title="4. 返回值"></a>4. 返回值</h4><ul><li><strong>成功</strong>：0。</li><li><strong>失败</strong>：-1，设置 <code>errno</code>。常见错误：<ul><li><code>EIDRM</code>：队列已被删除。</li><li><code>EPERM</code>：权限不足。</li><li><code>EINVAL</code>：无效队列 ID。</li></ul></li></ul><p><strong>如何正确删除？</strong></p><p>消息队列是内核资源，如果 <strong>不显式删除</strong>：</p><ul><li>进程结束后也不会自动销毁</li><li>容易出现“僵尸消息队列”，占用系统 IPC 表</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">msgctl</span>(msqid, IPC_RMID, <span class="literal">NULL</span>); <span class="comment">// 删除队列正确做法</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>查看所有消息队列：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;ipcs -q</span><br></pre></td></tr></table></figure><p><strong>删除指定 ID 的消息队列：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;ipcrm -q 65536  <span class="comment"># 替换为实际的 msqid</span></span><br></pre></td></tr></table></figure></blockquote><hr><h2 id="4-代码示例"><a href="#4-代码示例" class="headerlink" title="4. 代码示例"></a>4. 代码示例</h2><h3 id="1-comm-hpp-文件"><a href="#1-comm-hpp-文件" class="headerlink" title="1. comm.hpp 文件"></a>1. comm.hpp 文件</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">my_msgbuf</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> mtype;</span><br><span class="line">    <span class="type">char</span> mtext[<span class="number">1024</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> key = <span class="built_in">ftok</span>(<span class="string">&quot;./comm.hpp&quot;</span>, <span class="number">66</span>);</span><br></pre></td></tr></table></figure><h3 id="2-consumer-cpp-文件"><a href="#2-consumer-cpp-文件" class="headerlink" title="2. consumer.cpp 文件"></a>2. consumer.cpp 文件</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;comm.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="type">key_t</span> = key;</span><br><span class="line">    <span class="type">int</span> msgid = <span class="built_in">msgget</span>(<span class="type">key_t</span>, IPC_CREAT | <span class="number">0666</span>);</span><br><span class="line">    <span class="keyword">if</span>(msgid &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;msgget failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    my_msgbuf msg;</span><br><span class="line">    <span class="built_in">msgrcv</span>(msgid, &amp;msg, <span class="built_in">sizeof</span>(msg), <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;消息类型：&quot;</span> &lt;&lt; msg.mtype &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;消息内容：&quot;</span> &lt;&lt; msg.mtext &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">msgctl</span>(msgid, IPC_RMID, <span class="literal">NULL</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;队列已删除&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-producer-cpp-文件"><a href="#3-producer-cpp-文件" class="headerlink" title="3. producer.cpp 文件"></a>3. producer.cpp 文件</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;comm.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="type">key_t</span> = key;</span><br><span class="line">    <span class="type">int</span> msgid = <span class="built_in">msgget</span>(<span class="type">key_t</span>, IPC_CREAT | <span class="number">0666</span>);</span><br><span class="line">    <span class="keyword">if</span>(msgid &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;msgget failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    my_msgbuf msg;</span><br><span class="line">    msg.mtype = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(msg.mtext, <span class="string">&quot;Hello, linux!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">msgsnd</span>(msgid, &amp;msg, <span class="built_in">sizeof</span>(msg), IPC_NOWAIT) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;msgsnd failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;消息发送成功！&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-运行示例"><a href="#4-运行示例" class="headerlink" title="4. 运行示例"></a>4. 运行示例</h3><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250714130645593.png" alt="image-20250714130637935"></p><hr><h2 id="5-信号量（线程详解）"><a href="#5-信号量（线程详解）" class="headerlink" title="5. 信号量（线程详解）"></a>5. 信号量（线程详解）</h2><h3 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h3><p>在并发环境下（多进程、多线程），<strong>多个执行流共享同一份资源</strong>（如共享内存、文件、缓冲区）时，<strong>若没有同步机制保护</strong>，就可能出现 <strong>脏读、脏写</strong> 等现象，导致 <strong>数据不一致</strong>。</p><p>例如：</p><ul><li>进程 A 正在往一块共享内存写数据，还没写完；</li><li>进程 B 此时读了这块内存，读到的是 <strong>未写完整</strong> 的半成品数据；</li><li>导致 B 拿到的结果是错误的。</li></ul><p>这就是典型的 <strong>并发访问导致的数据不一致</strong>。</p><h3 id="2-解决方案：互斥访问"><a href="#2-解决方案：互斥访问" class="headerlink" title="2. 解决方案：互斥访问"></a>2. 解决方案：互斥访问</h3><p>为了保证数据一致性，需要在多个执行流之间做 <strong>互斥</strong>，即：</p><ul><li>任何时刻 <strong>同一份共享资源</strong> 只能被 <strong>一个执行流访问</strong>。</li><li>这里的“访问”是指执行对资源有读&#x2F;写影响的那段代码。</li></ul><hr><h3 id="3-临界资源-临界区"><a href="#3-临界资源-临界区" class="headerlink" title="3. 临界资源 &amp; 临界区"></a>3. 临界资源 &amp; 临界区</h3><p><strong>临界资源：</strong> 指在同一时间内，只允许一个执行流访问的资源，比如：</p><ul><li>共享内存</li><li>公共变量</li><li>公共缓冲区</li><li>I&#x2F;O 设备 等</li></ul><p><strong>临界区：</strong> 指的是 <strong>访问临界资源的那段代码</strong>，也就是：</p><ul><li>整个程序中，可能只有几行到几十行代码真正操作共享资源；</li><li>只要保证这段代码是 <strong>互斥执行</strong> 的，数据就一致！</li></ul><h3 id="4-如何实现互斥？"><a href="#4-如何实现互斥？" class="headerlink" title="4. 如何实现互斥？"></a>4. 如何实现互斥？</h3><p>最常用的是 <strong>加锁</strong>，锁的作用：<strong>只允许一个执行流进入临界区</strong>，其它执行流需要等待锁释放。锁的概念暂时还没学，<strong>放到后面讲</strong>。</p><hr><h3 id="5-小结"><a href="#5-小结" class="headerlink" title="5. 小结"></a>5. 小结</h3><table><thead><tr><th>概念</th><th>含义</th></tr></thead><tbody><tr><td>共享资源</td><td>被多个执行流共享，且需要保护的资源</td></tr><tr><td>临界资源</td><td>需要互斥访问的共享资源</td></tr><tr><td><strong>临界区</strong></td><td><strong>访问临界资源的那段代码</strong></td></tr><tr><td><strong>互斥</strong></td><td><strong>保证同一时刻仅一个执行流访问临界区</strong></td></tr><tr><td>加锁</td><td>实现互斥的一种技术手段</td></tr></tbody></table><h3 id="6-理解信号量"><a href="#6-理解信号量" class="headerlink" title="6. 理解信号量"></a>6. 理解信号量</h3><p>信号量在旧的书籍中也称信号灯，其本质是一把计数器，类似 <code>int count = n</code>（<strong>类似不代表等于！</strong>）。</p><ul><li>它的值代表了 <strong>可用临界资源</strong> 的数量。</li><li>应用程序通过 <strong>申请（P 操作）</strong> 和 <strong>释放（V 操作）</strong> 这个计数器来间接地申请和释放临界资源。</li></ul><blockquote><p><strong>申请（P 操作）</strong> 和 <strong>释放（V 操作）</strong> 是 <strong>原子的</strong>！原子的意思是：要么不做，要做就做完 —— 两态的，没有“正在做”这样的概念。</p></blockquote><p><strong>生活案例理解信号量和临界资源：</strong> 临界资源里面其实被划分很多小块，像一个电影厅 100 个座位，它最多就只能卖 100 张票，当我们还没去看电影先买票的时候，买票的本质就是对资源的预定机制，每卖出一张票，计数器就减减，放映厅里面的资源就减少一个，当计数器减到 0，资源已经被申请完毕了。</p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250714163330329.png" alt="image-20250714163330205"></p><table><thead><tr><th>信号量模型</th><th>电影院模型</th></tr></thead><tbody><tr><td>计数器初始值 &#x3D; 可用资源数</td><td>初始票数 &#x3D; 放映厅座位总数（比如 100 张票）</td></tr><tr><td>P 操作（wait）→ 计数器–1</td><td>买走一张票 → 余票数量 –1；若余票 &gt; 0，则买票成功；若余票 &#x3D; 0，则排队（阻塞）</td></tr><tr><td>V 操作（signal）→ 计数器+1</td><td>退票 → 余票 +1；若有人在排队，就给他一张票（唤醒）</td></tr><tr><td>计数器 抵达 0</td><td>余票卖完，后续的买票请求都会被放到队列里，直到有人退票</td></tr></tbody></table><p>如果电影院放映厅里面只有一个座位呢（超级 vip）？我们只需要一个值为 1 的计数器，只有一个人能抢到，只有一个人能进放映厅看电影，看电影期间只有一个执行流在访问临界资源，这就是互斥，我们把值只能为 1，0 两态的计数器叫做 <strong>二元信号量</strong>，本质就是一个 <strong>锁</strong>（互斥锁）。</p><ul><li>只有一个买票（P）能成功，其它排队等待；</li><li>相当于把“100 个座位”合并成“1 个整体座位”，要么全占，要么全空。</li></ul><h3 id="7-System-V-信号量系统调用和使用流程（最难，多线程部分详解）"><a href="#7-System-V-信号量系统调用和使用流程（最难，多线程部分详解）" class="headerlink" title="7. System V 信号量系统调用和使用流程（最难，多线程部分详解）"></a>7. System V 信号量系统调用和使用流程（最难，多线程部分详解）</h3><table><thead><tr><th>步骤</th><th>系统调用</th><th>作用</th></tr></thead><tbody><tr><td>创建&#x2F;获取</td><td><code>semget()</code></td><td>创建或获取一个信号量集</td></tr><tr><td>初始化</td><td><code>semctl()</code></td><td>设置初始值（如资源总量）</td></tr><tr><td>P&#x2F;V 操作</td><td><code>semop()</code></td><td>对信号量执行加减操作</td></tr><tr><td>销毁</td><td><code>semctl()</code></td><td>删除信号量集（资源回收）</td></tr></tbody></table><h3 id="8-信号量为什么属于-IPC？"><a href="#8-信号量为什么属于-IPC？" class="headerlink" title="8. 信号量为什么属于 IPC？"></a>8. 信号量为什么属于 IPC？</h3><p><strong>进程间通信（IPC）</strong> 的广义定义是：“<strong>任何让两个或多个独立进程之间交换信息或状态</strong> 的机制，都是 IPC。”</p><p>信号量（System V）本质上是 <strong>由内核维护的一个计数器集合</strong>，这块计数器是：</p><ul><li>存在内核内存里（和文件描述符一样，有唯一的 <code>semid</code>）。</li><li>可以被 <strong>多个进程同时打开、读写</strong>。</li><li>状态变更（P&#x2F;V）会直接影响其他进程是否能继续往下执行。</li></ul><p>所以信号量不是像管道那样直接“传递业务数据”，而是“传递同步信息”：“我这边可以&#x2F;不可以用了！”<strong>这种状态的传递本身就是通信</strong>。</p><p><strong>理解核心：</strong></p><ol><li><p><strong>通信不等于一定要传业务数据</strong>，同步信息本身就是信息。</p><ul><li>例：A 说“我写好了”，B 听见了就去读 → 这就是一种“信号通信”。</li></ul></li><li><p>信号量是 <strong>所有需要同步的进程都能看到的</strong>：</p><ul><li><p>通过 <code>semget()</code> 创建信号量集，返回的 <code>semid</code> 类似于管道文件描述符，多个进程只要 <code>ftok</code> + <code>semget</code> 相同，就能访问同一个信号量集。</p></li><li><p>信号量在内核里是全局可见，能跨父子进程，甚至无亲缘关系的进程（只要 key 一样，权限对得上）。</p></li></ul></li></ol><blockquote><p><strong>所以：通信不仅是传数据，互相协同也是通信。要协同，就必须有一块能被所有协同方看见、且可修改的共享状态，这就是信号量。</strong></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 进程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>034 进程间通信 —— System V 共享内存</title>
      <link href="/posts/9524.html"/>
      <url>/posts/9524.html</url>
      
        <content type="html"><![CDATA[<h1 id="进程间通信-——-System-V-共享内存"><a href="#进程间通信-——-System-V-共享内存" class="headerlink" title="进程间通信 —— System V 共享内存"></a>进程间通信 —— System V 共享内存</h1><blockquote><p><strong>传统的 System V IPC 主要包括三种：共享内存、消息队列、信号量，我们后面主要涉及其 System v 共享内存，消息队列和信号量仅作为了解。</strong> 现代开发和教学中，<strong>共享内存</strong> 作为重点和常用技术，而 <strong>消息队列</strong> 和 <strong>信号量</strong> 相对被弱化，主要有以下原因（<strong>了解，信息来自网络</strong>）：</p><ul><li><p><strong>共享内存的独特优势（不可替代性）：</strong></p></li><li><p><strong>极致性能（说白了就是快）：</strong> 它是所有 IPC 方式中 <strong>速度最快</strong> 的。一旦建立映射，数据交换直接在内存中进行，<strong>没有内核到用户空间的数据拷贝开销</strong>。</p></li><li><p><strong>灵活性：</strong> 共享内存本身只是提供了一块共享区域，进程可以在上面构建任何复杂的数据结构和通信协议。消息队列则限制了消息的结构和大小。</p></li><li><p><strong>消息队列的局限性（逐渐被替代）：</strong></p></li><li><p><strong>性能瓶颈：</strong> 每次发送和接收消息都涉及 <strong>系统调用</strong> 和 <strong>数据在内核与用户空间之间的拷贝</strong>。对于大量或高频小消息的开销非常明显。</p></li><li><p><strong>灵活性限制：</strong> 消息有最大长度限制，且通常是 FIFO 的，虽然支持优先级，但模型相对固定。</p></li><li><p><strong>注：</strong> 老方案，API 麻烦，扩展性差，写多进程服务时不如直接用 socket。大厂一般直接上 RabbitMQ、Kafka（用户态 + 网络），或者自己封装 Pipe&#x2F;Socket。</p></li><li><p><strong>信号量的现状：</strong></p></li><li><p><strong>同步需求永存：</strong> 只要存在并发访问共享资源（尤其是共享内存！），就需要同步机制。信号量的核心功能（互斥、同步）仍然是必需的。</p></li><li><p><strong>注：</strong> 单独用很少，一般是搭配共享内存或者消息队列，用于加锁。现代 C++ 里更常用 POSIX Mutex、pthread_mutex、futex。所以学信号量只需要理解一下“需要同步”，但实战更偏向 POSIX Mutex 或用户态自旋锁。</p></li></ul></blockquote><h2 id="1-System-V-共享内存的直接原理"><a href="#1-System-V-共享内存的直接原理" class="headerlink" title="1. System V 共享内存的直接原理"></a>1. System V 共享内存的直接原理</h2><p><strong>System V 共享内存</strong> 就是一块 <strong>物理内存区域</strong>，由内核在物理内存中分配，多个进程通过 <code>shmget</code> 等系统调用 <strong>映射到各自的虚拟地址空间</strong>，从而实现 <strong>零拷贝的高效通信</strong>。即：<strong>System V 共享内存 &#x3D; 一块物理内存 + 多个进程虚拟映射 + 自己实现同步控制</strong>。本质是 <strong>内核帮我们做了虚拟地址和物理页的映射表维护</strong>，保证多进程读写指向同一物理地址。</p><blockquote><p><strong>共享区映射到同一物理内存的过程：</strong></p><ol><li>首先，一个进程（或内核初始化时）通过系统调用 <code>shmget</code> <strong>创建</strong> 或 <strong>获取</strong> 一个共享内存段。这个段存在于物理内存中，由一个唯一的标识符 <code>shmid</code> 标识。</li><li>接下来，<strong>任何</strong> 想要使用这个共享内存段的进程（包括创建者），都需要在自己的地址空间中 <strong>附加(Attach，更多情况我们更喜欢称挂接)</strong> 它。这是通过系统调用 <code>shmat</code> 完成的。</li><li><code>shmat</code> 在调用进程的虚拟地址空间中动态分配一块映射区（通常位于 mmap 动态映射区域，常见于堆和栈之间），并在页表中建立映射，使这块虚拟地址指向共享内存段实际占用的物理页帧，而不再指向进程私有页（注意 <strong>通常位置处于进程地址空间的共享区，但并非强制！</strong>）。</li><li><strong>多个进程执行 <code>shmat</code> 后：</strong> 它们各自的虚拟地址空间中，被 <code>shmat</code> 返回的那个地址（或指定的地址）所对应的页表项，都指向了 <strong>同一块物理内存区域</strong>。</li><li><strong>结果：</strong> 当一个进程通过它附加的虚拟地址写入数据时，数据直接写入了这块共享物理内存。另一个进程通过它自己附加的（不同的）虚拟地址读取时，直接从这块共享物理内存读取数据。<strong>不同的虚拟地址，通过各自的页表，映射到相同的物理地址。</strong> 这就是“让不同进程看到同一份资源”的本质。</li></ol></blockquote><p>下面找了几个较为形象的图：</p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250702193137385.png" alt="image-20250702193137249"></p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250702193250357.png" alt="image-20250702193250253"></p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250702193332596.png" alt="image-20250702193332460"></p><p>注意：<strong>上述的映射、页表操作，都是由操作系统（内核）来做，而不是用户态进程做！</strong></p><p>为什么？</p><ul><li>用户态没权限直接操作页表（这是 MMU 和硬件特权模式约束）。</li><li>只有内核有权限分配物理页、修改页表、维护引用计数。</li><li>如果用户态可以随意改，那整个系统就失去内存隔离了，安全性就没有了。</li></ul><p>所以，用户态只能发起系统调用（<code>shmget</code>、<code>shmat</code>），<strong>具体“找页、改表、挂映射”由内核执行</strong>。那么当系统中存在多个共享内存，OS 要不要进行管理呢？回答：要的！这就又是我们老生常谈的 <strong>“先描述，再组织”</strong>（内核结构体描述共享内存）。</p><blockquote><h3 id="深入理解-“挂接”"><a href="#深入理解-“挂接”" class="headerlink" title="深入理解 “挂接”"></a>深入理解 “挂接”</h3><p><strong>挂接 &#x3D; 页表映射 &#x3D; 在自己的地址空间里开一扇门，让我们能访问内核里那块共享仓库。</strong> 挂接是 Linux 传统的说法，和文件系统的“挂载”类似，本质都是：<strong>把已有的物理资源，通过操作系统管理，暴露给一个命名空间&#x2F;可访问空间</strong>。</p><ul><li>文件系统挂载：把设备&#x2F;分区挂到某个目录。</li><li>共享内存挂接：把物理页挂到某个虚拟地址段。</li></ul><p><strong>比喻：</strong> System V 共享内存就是一块 <strong>公共仓库</strong>（物理页帧），这块仓库在内核里用 <code>shmid_ds</code> 管理，内核负责“保管”。单纯 <code>shmget</code> 就是创建了这块仓库，但谁也没把仓库门对接到自己家里。<code>shmat</code>（<strong>attach</strong>）就像是在你的家（进程的虚拟地址空间）里开个门，和这块仓库打通，让你能直接看到和访问这块公共物理页。所以：<strong>挂接 &#x3D; 虚拟地址空间里挂一块区域指向同一块物理页帧，进程间通信的前提是让不同的进程先看到同一份资源！</strong></p><hr><p><strong>不挂能不能用？</strong><br>不能！</p><ul><li><p>共享内存只是一块物理页帧，没挂接到进程页表前，进程看不到。</p></li><li><p>只有挂接后，CPU 访问你的虚拟地址才会翻译到这块物理内存。</p></li></ul><hr><p><strong>挂接后要不要解绑？</strong><br>要！</p><ul><li>用完后要 <code>shmdt</code>（detach）把这块映射从页表里去掉，虚拟内存就能被释放。</li><li>但物理页帧还在（因为其他进程可能还挂着）。</li><li>当最后一个挂接者 <code>shmdt</code> 后，如果之前用 <code>IPC_RMID</code> 标记删除了，就会真正释放物理页。</li></ul></blockquote><hr><h2 id="2-系统调用"><a href="#2-系统调用" class="headerlink" title="2. 系统调用"></a>2. 系统调用</h2><h3 id="1-ftok-——-生成-IPC-key（为后面的-shmget-铺垫）"><a href="#1-ftok-——-生成-IPC-key（为后面的-shmget-铺垫）" class="headerlink" title="1. ftok —— 生成 IPC key（为后面的 shmget 铺垫）"></a>1. <code>ftok</code> —— 生成 IPC key（为后面的 <code>shmget</code> 铺垫）</h3><h4 id="1-作用"><a href="#1-作用" class="headerlink" title="1. 作用"></a>1. 作用</h4><p><code>ftok</code> 的作用是 <strong>生成一个 System V IPC 的 key（键值）</strong>，本质是一个将路径作为的字符串和 proj_id 这个整数结合的一个算法。和这个 key 用来在：<code>shmget</code>（共享内存）参数里作为唯一标识。它不是随机生成的！而是用 <code>pathname</code> 和 <code>proj_id</code> 生成的一个整数 <code>key_t</code>。在前面的有名管道中，我们使用路径作为唯一标识（路径本身就具有唯一性），这里使用一个 key 值作为唯一性也是异曲同工之妙。注：<code>ftok</code> 只是为了生成 key，和数据本身没关系！</p><h4 id="2-ftok-函数原型"><a href="#2-ftok-函数原型" class="headerlink" title="2. ftok 函数原型"></a>2. <code>ftok</code> 函数原型</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">key_t</span> <span class="title">ftok</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> proj_id)</span></span>;<span class="comment">// 有效路径和任意整数</span></span><br></pre></td></tr></table></figure><h4 id="3-怎么生成？"><a href="#3-怎么生成？" class="headerlink" title="3. 怎么生成？"></a>3. 怎么生成？</h4><p>内部算法 <strong>大概</strong> 是：把 inode 的低字节、设备号等信息混进去，经过算法组合，从而形成唯一的哈希值 key。所以：</p><ul><li><strong>只要文件不变，同一个 proj_id 得到的 key 是一样的。</strong></li><li>这样保证不同进程用相同文件和 proj_id，就能找到同一块 IPC 资源。</li></ul><h4 id="4-返回值"><a href="#4-返回值" class="headerlink" title="4. 返回值"></a>4. 返回值</h4><ul><li>成功：返回 key (<code>key_t</code>)，是个整数。</li><li>失败：返回 <code>-1</code>，设置 <code>errno</code>。<ul><li><code>EACCES</code>：路径不可访问。</li><li><code>ENOENT</code>：文件不存在。</li><li><code>ENOTDIR</code>：路径中的目录不存在。</li></ul></li></ul><h4 id="5-示例"><a href="#5-示例" class="headerlink" title="5. 示例"></a>5. 示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cerrno&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">key_t</span> key = <span class="built_in">ftok</span>(<span class="string">&quot;./tmp.txt&quot;</span>, <span class="number">65</span>);  <span class="comment">// 文件必须存在</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;ftok&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;IPC Key: &quot;</span> &lt;&lt; key &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250702210024190.png" alt="image-20250702210024126"></p><hr><h3 id="2-shmget-——-创建-获取共享内存"><a href="#2-shmget-——-创建-获取共享内存" class="headerlink" title="2. shmget —— 创建&#x2F;获取共享内存"></a>2. <code>shmget</code> —— 创建&#x2F;获取共享内存</h3><h4 id="1-作用-1"><a href="#1-作用-1" class="headerlink" title="1. 作用"></a>1. 作用</h4><ul><li><strong>创建一个新的共享内存段。</strong></li><li>或者 <strong>获取已存在的共享内存段。</strong></li></ul><p>关键靠 <code>key</code> 做唯一标识。</p><h4 id="2-shmget-函数原型"><a href="#2-shmget-函数原型" class="headerlink" title="2. shmget 函数原型"></a>2. <code>shmget</code> 函数原型</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">shmget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">size_t</span> size, <span class="type">int</span> shmflg)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="3-参数详解"><a href="#3-参数详解" class="headerlink" title="3. 参数详解"></a>3. 参数详解</h4><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td><code>key</code></td><td><strong>IPC 键值</strong>（由 <code>ftok</code> 生成），用于唯一标识，可以自定义，但是不保证一定有效，可能存在冲突！</td></tr><tr><td><code>size</code></td><td><strong>共享内存段大小</strong>（单位字节），如果是获取已存在的，则忽略，<strong>注意 页对齐 行为！通常分配 4KB 的整数倍（4096 的整数倍）</strong></td></tr><tr><td><code>shmflg</code></td><td><strong>权限标志 + 控制标志</strong>，典型：<code>IPC_CREAT</code>，<code>IPC_EXCL</code>，<code>0666</code></td></tr></tbody></table><p><strong>注意：</strong> System V 共享内存段在物理页帧分配时总是 <strong>按页对齐（通常是 4KB）</strong>，但 <code>shmget</code> 的 <code>size</code> 是逻辑大小，<code>ipcs -m</code> 里显示也是逻辑大小，实际物理内存占用是向上对齐的页大小倍数，使用时应按逻辑大小访问，超出即是“越界访问”，可能存在 <strong>未定义行为&#x2F;段错误</strong>。</p><p>例如：<code>shmget(4100)</code> 表示：”我承诺只用前 4100 字节（0~4099 合法）”，OS 回应：” 我实际给你 8192 字节（4KB * 2），但超出的部分你别碰 “（非越界访问指 0 ≦ 有效值 &lt; 用户分配值的大小）。<strong>永远记住：”能” 做不代表 “应该” 做。在系统编程中，自律比能力更重要。不立即爆炸，但终将毁灭！</strong></p><h4 id="4-常用的-shmflg"><a href="#4-常用的-shmflg" class="headerlink" title="4. 常用的 shmflg"></a>4. 常用的 <code>shmflg</code></h4><ul><li><code>0666</code>：权限位，表示其他进程是否可读&#x2F;写（和 <code>open</code> 的权限一样）。</li><li><code>IPC_CREAT</code>：如果不存在则创建，存在就获取返回。</li><li><code>IPC_EXCL</code>：和 <code>IPC_CREAT</code> 一起用时，要求“仅当不存在时才创建”，否则出错。</li><li><code>IPC_EXCL</code>：不单独使用！</li></ul><p>举例：</p><ul><li>只想创建（如果存在则失败）：<code>IPC_CREAT | IPC_EXCL | 0666</code>。</li><li>想获取（或必要时创建）：<code>IPC_CREAT | 0666</code>。</li></ul><h4 id="5-返回值"><a href="#5-返回值" class="headerlink" title="5. 返回值"></a>5. 返回值</h4><ul><li>成功：返回共享内存标识符（<code>shmid</code>），唯一 int ID。</li><li>失败：返回 -1，设置 <code>errno</code>。</li></ul><h4 id="6-示例"><a href="#6-示例" class="headerlink" title="6. 示例"></a>6. 示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cerrno&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">key_t</span> key = <span class="built_in">ftok</span>(<span class="string">&quot;/tmp.txt&quot;</span>, <span class="number">65</span>);                       <span class="comment">// 生成唯一 key</span></span><br><span class="line">    <span class="type">int</span> shmid = <span class="built_in">shmget</span>(key, <span class="number">4096</span>, <span class="number">0666</span> | IPC_CREAT);        <span class="comment">// 创建或获取 4KB 共享内存</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (shmid == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;shmget&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;shmid: &quot;</span> &lt;&lt; shmid &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="3-二者关系总结"><a href="#3-二者关系总结" class="headerlink" title="3. 二者关系总结"></a>3. 二者关系总结</h3><table><thead><tr><th>函数</th><th>作用</th><th>关键点</th></tr></thead><tbody><tr><td><code>ftok</code></td><td>生成 key</td><td>依赖文件 inode 和 proj_id，不保证全局唯一，但同参数一致性好</td></tr><tr><td><code>shmget</code></td><td>创建&#x2F;获取共享内存</td><td>需要 key、大小和标志，内核内部管理分配和引用计数</td></tr></tbody></table><p><strong>小坑提醒：</strong></p><ul><li><code>ftok</code> 不是必须的！我们完全可以自己写 <code>key_t</code>，只要和另一端一致就行（很多老项目直接用固定数值）。</li><li>不同机器，<code>ftok</code> 生成同一文件的 key 可能不一样（因为 inode 和设备号可能不同），所以跨机集群时要注意！</li><li><code>shmget</code> 只分配描述符，不分配虚拟地址；只有 <code>shmat</code> 才会把它挂到进程地址空间。</li></ul><blockquote><p>  <code>ftok</code> 是为了在多人协作或多程序协作时，保证只要文件和 proj_id 一致，生成的 key 就一致，从而多个进程可以用相同 key 访问同一个 IPC 对象。</p></blockquote><hr><h3 id="4-shmctl-——-删除（控制-管理）共享内存"><a href="#4-shmctl-——-删除（控制-管理）共享内存" class="headerlink" title="4. shmctl —— 删除（控制&#x2F;管理）共享内存"></a>4. <code>shmctl</code> —— 删除（控制&#x2F;管理）共享内存</h3><h4 id="1-shmctl-函数原型"><a href="#1-shmctl-函数原型" class="headerlink" title="1. shmctl 函数原型"></a>1. <code>shmctl</code> 函数原型</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">shmctl</span><span class="params">(<span class="type">int</span> shmid, <span class="type">int</span> cmd, <span class="keyword">struct</span> shmid_ds *buf)</span></span>; <span class="comment">// 控制共享内存</span></span><br></pre></td></tr></table></figure><h4 id="2-参数详解"><a href="#2-参数详解" class="headerlink" title="2. 参数详解"></a>2. 参数详解</h4><ol><li><code>shmid</code>：共享内存段标识符（由 <code>shmget</code> 返回）。</li><li><code>cmd</code>：<ul><li><strong><code>IPC_RMID</code>：删除，从系统中标记删除该段。</strong></li><li><strong><code>IPC_STAT</code>：获取状态，用于接收共享内存的状态信息（输出）。</strong></li><li><strong><code>IPC_SET</code>：设置状态，用于向内核提交新状态（输入）。</strong></li><li><code>SHM_LOCK</code>：锁定共享内存段（防止换出到交换空间）。</li><li><code>SHM_UNLOCK</code>：解除锁定。</li></ul></li><li><code>buf</code>：如果是 <code>IPC_STAT</code> 或 <code>IPC_SET</code>，就需要传状态结构体指针；<code>IPC_RMID</code> 时可传 <code>NULL</code>（<code>nullptr</code>）。</li></ol><h4 id="3-返回值"><a href="#3-返回值" class="headerlink" title="3. 返回值"></a>3. 返回值</h4><ul><li><strong>成功</strong>：返回 0。</li><li><strong>失败</strong>：返回 -1，同时设置 <code>errno</code>。常见错误：<ul><li><code>EINVAL</code>：无效的 <code>shmid</code>。</li><li><code>EACCES</code>：没有权限。</li><li><code>EIDRM</code>：段已被删除。</li></ul></li></ul><blockquote><h4 id="shmid-ds-结构体："><a href="#shmid-ds-结构体：" class="headerlink" title="shmid_ds 结构体："></a><code>shmid_ds</code> 结构体：</h4><p>这是 <code>shmctl</code> 操作的核心数据结构，用来描述共享内存段的元数据。</p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250703094226258.png" alt="image-20250703094226102"></p><p>具体含义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">struct</span> <span class="title class_">shmid_ds</span></span><br><span class="line">&gt;&#123;</span><br><span class="line">&gt;<span class="keyword">struct</span> <span class="title class_">ipc_perm</span> shm_perm;   <span class="comment">// 权限信息（UID, GID, mode）</span></span><br><span class="line">&gt;<span class="type">size_t</span> shm_segsz;           <span class="comment">// 段大小（字节）</span></span><br><span class="line">&gt;<span class="type">time_t</span> shm_atime;           <span class="comment">// 上次 attach 时间</span></span><br><span class="line">&gt;<span class="type">time_t</span> shm_dtime;           <span class="comment">// 上次 detach 时间</span></span><br><span class="line">&gt;<span class="type">time_t</span> shm_ctime;           <span class="comment">// 创建或上次修改时间</span></span><br><span class="line">&gt;<span class="type">pid_t</span> shm_cpid;             <span class="comment">// 创建该段的进程 PID</span></span><br><span class="line">&gt;<span class="type">pid_t</span> shm_lpid;             <span class="comment">// 最后一次操作该段的进程 PID</span></span><br><span class="line">&gt;<span class="type">shmatt_t</span> shm_nattch;        <span class="comment">// 当前 attach 的进程数量（引用计数）</span></span><br><span class="line">&gt;...</span><br><span class="line">&gt;&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">struct</span> <span class="title class_">ipc_perm</span></span><br><span class="line">&gt;&#123;</span><br><span class="line">&gt;<span class="type">key_t</span>          __key;    <span class="comment">// 传递给 shmget(2) 的键值</span></span><br><span class="line">&gt;<span class="type">uid_t</span>          uid;      <span class="comment">// 共享内存拥有者的有效用户ID</span></span><br><span class="line">&gt;<span class="type">gid_t</span>          gid;      <span class="comment">// 共享内存拥有者的有效组ID</span></span><br><span class="line">&gt;<span class="type">uid_t</span>          cuid;     <span class="comment">// 创建该共享内存的进程的有效用户ID</span></span><br><span class="line">&gt;<span class="type">gid_t</span>          cgid;     <span class="comment">// 创建该共享内存的进程的有效组ID</span></span><br><span class="line">&gt;<span class="type">unsigned</span> <span class="type">short</span> mode;     <span class="comment">// 权限标志位，包含 SHM_DEST 和 SHM_LOCKED 等标志</span></span><br><span class="line">&gt;<span class="type">unsigned</span> <span class="type">short</span> __seq;    <span class="comment">// 序列号，用于生成唯一标识</span></span><br><span class="line">&gt;&#125;;</span><br></pre></td></tr></table></figure><p><strong>如何查看哪个进程还挂着共享内存？</strong></p><p>查看 <code>shm_nattch</code>（引用计数），只要 &gt; 0，物理页就不释放！</p><hr><p>场景示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">struct</span> <span class="title class_">shmid_ds</span> buf;</span><br><span class="line">&gt;<span class="built_in">shmctl</span>(shmid, IPC_STAT, &amp;buf);</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 查看大小、创建者 PID、引用数</span></span><br><span class="line">&gt;<span class="built_in">printf</span>(<span class="string">&quot;Size: %zu\n&quot;</span>, buf.shm_segsz);</span><br><span class="line">&gt;<span class="built_in">printf</span>(<span class="string">&quot;Creator PID: %d\n&quot;</span>, buf.shm_cpid);</span><br><span class="line">&gt;<span class="built_in">printf</span>(<span class="string">&quot;Nattach: %ld\n&quot;</span>, buf.shm_nattch);</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="built_in">shmctl</span>(shmid, IPC_RMID, <span class="literal">NULL</span>);  <span class="comment">// 标记删除</span></span><br><span class="line">&gt;<span class="comment">// 标记删除 ≠ 立刻删除，等引用数归 0 后才真正释放。</span></span><br></pre></td></tr></table></figure></blockquote><blockquote><h4 id="1-查看系统现有的共享内存"><a href="#1-查看系统现有的共享内存" class="headerlink" title="1. 查看系统现有的共享内存"></a>1. 查看系统现有的共享内存</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;ipcs -m    <span class="comment"># 查看系统现有的共享内存</span></span><br></pre></td></tr></table></figure><h4 id="2-删除指定系统的共享内存"><a href="#2-删除指定系统的共享内存" class="headerlink" title="2. 删除指定系统的共享内存"></a>2. 删除指定系统的共享内存</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;ipcrm -m &lt;shmid&gt;    <span class="comment"># 删除指定共享内存段</span></span><br></pre></td></tr></table></figure></blockquote><hr><h3 id="5-shmat-——-“挂接内存”"><a href="#5-shmat-——-“挂接内存”" class="headerlink" title="5. shmat —— “挂接内存”"></a>5. <code>shmat</code> —— “挂接内存”</h3><h4 id="1-函数原型"><a href="#1-函数原型" class="headerlink" title="1. 函数原型"></a>1. 函数原型</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">shmat</span><span class="params">(<span class="type">int</span> shmid, <span class="type">const</span> <span class="type">void</span> *shmaddr, <span class="type">int</span> shmflg)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="2-作用"><a href="#2-作用" class="headerlink" title="2. 作用"></a>2. 作用</h4><p>进程各自的虚拟地址空间是隔离的，但 <code>shmat</code> 把同一个物理内存页挂接到多个进程的页表里，所以多个进程访问同一块物理页，实现了多进程 <strong>“看到同一份资源”</strong>，到此，多进程间才具备的通信的能力。底层做的是页表映射和引用计数，返回值是可直接访问的指针，真正实现多进程间的零拷贝数据共享（<strong>拷贝少 → 速度快</strong>）。</p><h4 id="3-参数详解-1"><a href="#3-参数详解-1" class="headerlink" title="3. 参数详解"></a>3. 参数详解</h4><table><thead><tr><th>参数</th><th>作用</th><th>解释</th></tr></thead><tbody><tr><td><code>int shmid</code></td><td>共享内存段标识符</td><td>来自 <code>shmget</code> 的返回值</td></tr><tr><td><code>const void *shmaddr</code></td><td>希望映射到进程虚拟空间的 <strong>首选地址</strong></td><td>通常写 <code>NULL</code>&#x2F;<code>nullptr</code>（让内核自己找个合适的可用地址）</td></tr><tr><td><code>int shmflg</code></td><td>标志位</td><td>主要用于指定映射权限或对齐</td></tr></tbody></table><ul><li><p><code>shmaddr</code>：</p><ul><li><p>如果是 <code>NULL</code>，表示“由内核自动分配虚拟地址”，这是 <strong>最常用也最安全的写法</strong>。</p></li><li><p>如果指定了具体地址：必须是页对齐地址，<code>shmflg</code> 可以带 <code>SHM_RND</code> 表示“按 4KB 对齐”。</p></li></ul></li><li><p><code>shmflg</code> 的典型值：</p><ul><li><strong><code>0</code>：最常用，表示默认读写。</strong></li><li><code>SHM_RDONLY</code>：以只读方式挂接（这个进程只能读，别的进程可以写）。</li><li><code>SHM_RND</code>：如果指定了 <code>shmaddr</code>，且希望地址自动按 4KB 页对齐，就要加这个。</li></ul></li></ul><h4 id="4-返回值-1"><a href="#4-返回值-1" class="headerlink" title="4. 返回值"></a>4. 返回值</h4><ul><li><p><strong>成功</strong>：返回共享内存段在当前进程虚拟地址空间中的起始地址（<code>void *</code>）。</p></li><li><p><strong>失败：</strong> 返回 <code>(void *) -1</code>，并设置 <code>errno</code>。</p><ul><li><p><code>EINVAL</code>：<code>shmid</code> 不存在或非法。</p></li><li><p><code>EACCES</code>：权限不足（比如只读段却尝试写挂接）。</p></li><li><p><code>ENOMEM</code>：找不到可用虚拟地址（尤其是自己指定 <code>shmaddr</code> 时更容易出现）。</p></li></ul></li></ul><hr><h3 id="6-shmdt-——-脱挂，释放虚拟空间的映射"><a href="#6-shmdt-——-脱挂，释放虚拟空间的映射" class="headerlink" title="6. shmdt —— 脱挂，释放虚拟空间的映射"></a>6. <code>shmdt</code> —— 脱挂，释放虚拟空间的映射</h3><h4 id="1-作用-2"><a href="#1-作用-2" class="headerlink" title="1. 作用"></a>1. 作用</h4><p>从当前进程的页表中卸载共享内存段的映射区域，并把内核引用计数 -1，不会释放物理页帧，物理段释放要靠 <code>shmctl(IPC_RMID)</code> 和引用计数归零一起决定。</p><blockquote><p><strong><code>shmdt</code> 负责 “关门走人”，<code>shmctl(IPC_RMID)</code> 负责 “拆掉仓库”。</strong></p><table><thead><tr><th>对比</th><th><code>shmdt</code></th><th><code>shmctl</code></th></tr></thead><tbody><tr><td>主要功能</td><td><strong>脱挂（取消挂接）</strong></td><td><strong>控制（管理）共享内存段</strong></td></tr><tr><td>作用对象</td><td>当前进程的虚拟地址空间</td><td>内核中整个共享内存段</td></tr><tr><td>是否影响物理内存</td><td>❌ 不会直接删除物理页帧</td><td>✅ 可以通过 <code>IPC_RMID</code> 标记删除物理页帧</td></tr><tr><td>引用计数影响</td><td>调用后，<code>shmid_ds.shm_nattch</code> -1</td><td><code>IPC_RMID</code> 后，等引用数归零才真正释放</td></tr><tr><td>调用场景</td><td>挂接用完后必须调用，释放虚拟空间</td><td>要永久回收内存段时必须调用</td></tr><tr><td>是否必须</td><td>一般必须（防止虚拟内存泄漏）</td><td>必须（否则段会一直挂在内核 IPC 表）</td></tr><tr><td>错误示例</td><td>不脱挂会浪费虚拟地址空间</td><td>不标记删除会造成内核残留，需手动 <code>ipcrm</code></td></tr></tbody></table></blockquote><h4 id="2-函数原型"><a href="#2-函数原型" class="headerlink" title="2. 函数原型"></a>2. 函数原型</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">shmdt</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *shmaddr)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="3-参数详解-2"><a href="#3-参数详解-2" class="headerlink" title="3. 参数详解"></a>3. 参数详解</h4><ul><li><strong><code>const void *shmaddr</code>：</strong> 由 <code>shmat</code> 返回的指针，表示要脱挂的共享内存区域的起始虚拟地址。</li><li><strong>注意</strong>：这个地址必须是之前 <code>shmat</code> 成功挂接时返回的那个指针。不允许随便传地址！</li></ul><h4 id="4-返回值-2"><a href="#4-返回值-2" class="headerlink" title="4. 返回值"></a>4. 返回值</h4><ul><li>成功：返回 0。</li><li>失败：返回 -1。常见错误：<ul><li><code>EINVAL</code>：找不到对应挂接（<code>shmaddr</code> 非法）。</li><li><code>ENOMEM</code>：有些实现里如果内部释放失败（比较罕见）。</li></ul></li></ul><hr><h2 id="3-System-V-共享内存的生命周期随内核"><a href="#3-System-V-共享内存的生命周期随内核" class="headerlink" title="3. System V 共享内存的生命周期随内核"></a>3. System V 共享内存的生命周期随内核</h2><p><strong>结论：System V 共享内存段 &#x3D; 不手动删就不回收，引用计数归零 + IPC_RMID 才是唯一的释放条件！<code>IPC_RMID</code> + <code>shm_nattch == 0</code> → 真正释放物理页。</strong> 如果没 <code>IPC_RMID</code>，引用计数再归零也不删，物理页照样挂着！</p><p>System V 共享内存的生命周期和两个东西密切相关：</p><ol><li>共享内存 <strong>段本身</strong>（<code>shmid_ds</code> 描述的物理页）。</li><li>挂接（attach）的 <strong>引用计数</strong>（<code>shm_nattch</code>）。</li></ol><p>他们俩共同决定：<strong>什么时候物理页还存在，什么时候物理页真正被回收！</strong></p><blockquote><p>注意：System V 共享内存不会自动回收，必须手动使用 <code>shmctl</code> &#x2F; <code>ipcrm</code>，<strong>内核</strong> 会一直保留这块物理页帧，只要系统 <strong>重启前</strong>，这段共享内存都在 <code>/proc/sysvipc/shm</code> 里挂着！所以 <strong>System V IPC 的最终清理手段 &#x3D; 重启！</strong></p><p><strong>System V IPC</strong> 是 Linux 内核维护的全局资源，而 Xshell 是 <strong>一个远程终端工具</strong>，本质就是个 SSH 客户端。它 <strong>不会“托管”共享内存段</strong>，只是帮助登录远程 Linux 主机。关掉 Xshell，只是 SSH 断了，跟远程机器上的进程、内核资源没有必然关系。所以，<strong>关掉 Xshell 对共享内存没有任何直接影响！</strong></p></blockquote><h2 id="4-示例-Demo"><a href="#4-示例-Demo" class="headerlink" title="4. 示例 Demo"></a>4. 示例 Demo</h2><h3 id="1-System-V-共享内存通信完整步骤"><a href="#1-System-V-共享内存通信完整步骤" class="headerlink" title="1. System V 共享内存通信完整步骤"></a>1. System V 共享内存通信完整步骤</h3><ol><li><p><strong><code>ftok</code> （可选，但推荐）：</strong> 生成一个 <strong>key_t</strong>，作为 IPC 对象的唯一标识。本质上就是用路径名+id 生成一个整数 key。</p></li><li><p><strong><code>shmget</code>：</strong> 内核分配一块 <strong>物理内存页帧</strong>，挂到内核的共享内存表（<code>shmid_ds</code>）。得到一个 <code>shmid</code>（共享内存段标识符）。</p></li><li><p><strong><code>shmat</code> 挂接（attach）：</strong> 把这块共享内存段映射到调用进程的 <strong>虚拟地址空间</strong>，更新页表。返回一个指针，后续直接对这块物理页读写。</p></li><li><p><strong>各个进程的读写操作：</strong>……（省略）。</p></li><li><p><strong><code>shmdt</code>：</strong> 用完后，进程要执行 <code>shmdt</code> 脱挂，把这块内存区域从自己的页表取消映射。</p></li><li><p><strong><code>shmctl</code>：</strong> 用 <code>IPC_RMID</code> 命令显式标记这块共享内存段为“待删除”。当挂接计数归零时，内核真正回收物理页。</p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250707210159129.png" alt="image-20250707210158998"></p><h3 id="2-System-V-共享内存的服务端-客户端模型-Demo"><a href="#2-System-V-共享内存的服务端-客户端模型-Demo" class="headerlink" title="2. System V 共享内存的服务端-客户端模型 Demo"></a>2. System V 共享内存的服务端-客户端模型 Demo</h3><blockquote><h3 id="fgets-函数"><a href="#fgets-函数" class="headerlink" title="fgets 函数"></a>fgets 函数</h3><h4 id="1-作用-功能"><a href="#1-作用-功能" class="headerlink" title="1. 作用 &#x2F; 功能"></a>1. 作用 &#x2F; 功能</h4><p>C 标准库提供的一个输入函数，用于 <strong>从指定的文件流中读取一行字符串</strong>，可安全限制最大读取长度，避免缓冲区溢出。常用于读取带空格的一整行输入（包括换行符），常用于：</p><ul><li>从 <code>stdin</code> 获取用户输入。</li><li>从文件中按行读取文本。</li></ul><h4 id="2-函数原型-1"><a href="#2-函数原型-1" class="headerlink" title="2. 函数原型"></a>2. 函数原型</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span>   <span class="comment">// C++ 推荐使用</span></span></span><br><span class="line">&gt;<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span><span class="comment">// 或者在纯 C 里用</span></span></span><br><span class="line">&gt;<span class="function"><span class="type">char</span> *<span class="title">fgets</span><span class="params">(<span class="type">char</span> *str, <span class="type">int</span> n, FILE *stream)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="3-参数详解-3"><a href="#3-参数详解-3" class="headerlink" title="3.参数详解"></a>3.参数详解</h4><table><thead><tr><th>参数名</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td><code>char *str</code></td><td>输入输出参数</td><td>指向用于存放读取字符串的缓冲区的指针。读取到的字符串（包括换行符）会存到这里。必须有足够空间。</td></tr><tr><td><code>int n</code></td><td>输入参数</td><td>要读取的最大字符数（包含结尾的 <code>\0</code>），所以实际最多读取 <code>n - 1</code> 个字符。</td></tr><tr><td><code>FILE *stream</code></td><td>输入参数</td><td>文件流指针，比如 <code>stdin</code>（标准输入）或用 <code>fopen</code> 打开的文件指针。</td></tr></tbody></table><h4 id="4-返回值-3"><a href="#4-返回值-3" class="headerlink" title="4. 返回值"></a>4. 返回值</h4><ul><li><strong>返回值类型：</strong> <code>char *</code>。</li><li><strong>成功时：</strong> 返回传入的缓冲区 <code>str</code> 指针。</li><li><strong>失败时：</strong> 如果发生错误或遇到文件结尾（EOF）且未读取到任何字符，则返回 <code>NULL</code>。</li></ul><p>常用的判断写法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">if</span> (<span class="built_in">fgets</span>(buffer, size, stdin) != <span class="literal">NULL</span>)</span><br><span class="line">&gt;&#123;</span><br><span class="line">   <span class="comment">// 成功</span></span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="keyword">else</span></span><br><span class="line">&gt;&#123;</span><br><span class="line">   <span class="comment">// 读取失败或 EOF</span></span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><h4 id="5-代码示例"><a href="#5-代码示例" class="headerlink" title="5. 代码示例"></a>5. 代码示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span>                       <span class="comment">// 引入 fgets 需要的头文件</span></span></span><br><span class="line">&gt;<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span>                      <span class="comment">// exit() 用于异常退出</span></span></span><br><span class="line"></span><br><span class="line">&gt;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">&gt;</span>&#123;</span><br><span class="line">   <span class="type">const</span> <span class="type">int</span> SIZE = <span class="number">100</span>;               <span class="comment">// 定义缓冲区大小</span></span><br><span class="line">   <span class="type">char</span> buffer[SIZE];                  <span class="comment">// 创建缓冲区</span></span><br><span class="line"></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;请输入一行文字（最多 %d 个字符）：\n&quot;</span>, SIZE - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">fgets</span>(buffer, SIZE, stdin) != <span class="literal">NULL</span>)      <span class="comment">// 调用 fgets 从 stdin 读取</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;您输入的是：%s&quot;</span>, buffer);         <span class="comment">// fgets 会保留换行符</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="built_in">perror</span>(<span class="string">&quot;读取失败&quot;</span>);                       <span class="comment">// 读取出错或 EOF</span></span><br><span class="line">       <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure></blockquote><h4 id="1-Log-hpp-文件（之前写的日志插件）"><a href="#1-Log-hpp-文件（之前写的日志插件）" class="headerlink" title="1. Log.hpp 文件（之前写的日志插件）"></a>1. Log.hpp 文件（之前写的日志插件）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>                                      <span class="comment">// exit, perror</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>                                      <span class="comment">// read, write, close</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span>                                   <span class="comment">// open, close, read, write, lseek</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span>                                    <span class="comment">// mkdir</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span>                                       <span class="comment">// open, O_RDONLY, O_WRONLY, O_CREAT, O_APPEND</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span>                                       <span class="comment">// errno</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span>                                    <span class="comment">// gettimeofday, struct timeval</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span>                                         <span class="comment">// localtime_r, struct tm</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 管道错误码</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">FIFO_ERROR_CODE</span></span><br><span class="line">&#123;</span><br><span class="line">    FIFO_CREATE_ERR = <span class="number">1</span>,                                 <span class="comment">// 这是创建管道文件失败的错误码</span></span><br><span class="line">    FIFO_DELETE_ERR = <span class="number">2</span>,                                 <span class="comment">// 这是删除管道文件失败的错误码</span></span><br><span class="line">    FIFO_OPEN_ERR                                        <span class="comment">// 这是打开管道文件失败的错误码（枚举会自动赋值为3）</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 日志等级</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Log_Level</span></span><br><span class="line">&#123;</span><br><span class="line">    Fatal,                                               <span class="comment">// 最严重级别</span></span><br><span class="line">    Error,                                               <span class="comment">// 严重错误</span></span><br><span class="line">    Warning,                                             <span class="comment">// 警告</span></span><br><span class="line">    Debug,                                               <span class="comment">// 调试信息</span></span><br><span class="line">    Info                                                 <span class="comment">// 普通信息</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Log</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span>  enable = <span class="number">1</span>;                                     <span class="comment">// 是否启用日志</span></span><br><span class="line">    <span class="type">int</span>  classification = <span class="number">1</span>;                             <span class="comment">// 是否分类</span></span><br><span class="line">    string log_path = <span class="string">&quot;./log.txt&quot;</span>;                       <span class="comment">// 日志存放路径</span></span><br><span class="line">    <span class="type">int</span>  console_out = <span class="number">1</span>;                                <span class="comment">// 是否输出到终端</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 日志等级转换成字符串</span></span><br><span class="line">    <span class="function">string <span class="title">level_to_string</span><span class="params">(<span class="type">int</span> level)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (level)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> Fatal:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;Fatal&quot;</span>;</span><br><span class="line">            <span class="keyword">case</span> Error:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;Error&quot;</span>;</span><br><span class="line">            <span class="keyword">case</span> Warning:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;Warning&quot;</span>;</span><br><span class="line">            <span class="keyword">case</span> Debug:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;Debug&quot;</span>;</span><br><span class="line">            <span class="keyword">case</span> Info:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;Info&quot;</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;None&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前计算机的时间，返回格式：YYYY-MM-DD HH:MM:SS.UUUUUU （含微秒）</span></span><br><span class="line">    <span class="function">string <span class="title">get_current_time</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">timeval</span> tv;                               <span class="comment">// timeval：包含秒和微秒</span></span><br><span class="line">        <span class="built_in">gettimeofday</span>(&amp;tv, <span class="literal">nullptr</span>);                      <span class="comment">// 系统调用：获取当前时间（精确到微秒）</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">tm</span> t;                                     <span class="comment">// tm：分解时间，转格式（年、月、日、时、分、秒）</span></span><br><span class="line">        <span class="built_in">localtime_r</span>(&amp;tv.tv_sec, &amp;t);                     <span class="comment">// 把秒转换成年月日时分秒（本地时区）</span></span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> buffer[<span class="number">64</span>];                                 <span class="comment">// 定义字符数组作为格式化输出的缓冲区</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">snprintf</span>(buffer, <span class="built_in">sizeof</span>(buffer),</span><br><span class="line">                <span class="string">&quot;%04d-%02d-%02d %02d:%02d:%02d.%06ld&quot;</span>,</span><br><span class="line">                t.tm_year + <span class="number">1900</span>,                        <span class="comment">// 年：tm_year 从 1900 开始计数</span></span><br><span class="line">                t.tm_mon + <span class="number">1</span>,                            <span class="comment">// 月：tm_mon 从 0 开始，0 表示 1 月</span></span><br><span class="line">                t.tm_mday,                               <span class="comment">// 日</span></span><br><span class="line">                t.tm_hour,                               <span class="comment">// 时</span></span><br><span class="line">                t.tm_min,                                <span class="comment">// 分</span></span><br><span class="line">                t.tm_sec,                                <span class="comment">// 秒</span></span><br><span class="line">                tv.tv_usec);                             <span class="comment">// 微秒部分，取自 gettimeofday</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">string</span>(buffer);                           <span class="comment">// 转换成 string 返回</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Log</span>() = <span class="keyword">default</span>;                                     <span class="comment">// 使用默认构造</span></span><br><span class="line">    <span class="built_in">Log</span>(<span class="type">int</span> enable, <span class="type">int</span> classification, string log_path, <span class="type">int</span> console_out)</span><br><span class="line">        : <span class="built_in">enable</span>(enable),</span><br><span class="line">        <span class="built_in">classification</span>(classification),</span><br><span class="line">        <span class="built_in">log_path</span>(log_path),</span><br><span class="line">        <span class="built_in">console_out</span>(console_out)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 重载函数调用运算符</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> level, <span class="type">const</span> string&amp; content)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (enable == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;                                      <span class="comment">// 日志未启用</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        string level_str = <span class="string">&quot;[&quot;</span> + <span class="built_in">level_to_string</span>(level) + <span class="string">&quot;] &quot;</span>;</span><br><span class="line">        string log_message;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (classification == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            log_message = level_str + <span class="string">&quot;[&quot;</span> + <span class="built_in">get_current_time</span>() + <span class="string">&quot;] &quot;</span> + content + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (classification == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            log_message = <span class="string">&quot;[&quot;</span> + <span class="built_in">get_current_time</span>() + <span class="string">&quot;] &quot;</span> + content + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;传入的分类参数错误！\n&quot;</span>);              <span class="comment">// 分类未启用</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (console_out == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; log_message;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">log_to_file</span>(level, log_message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 文件路径的后缀处理函数：当按照日志等级分类存储并且文件路径是 &quot;./log.txt&quot; 这种有文件扩展名时的处理方法</span></span><br><span class="line">    <span class="function">string <span class="title">Suffix_processing</span><span class="params">(<span class="type">int</span> level, string log_path)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        string Path;</span><br><span class="line">        <span class="keyword">if</span> (log_path.<span class="built_in">back</span>() == <span class="string">&#x27;/&#x27;</span>)                      <span class="comment">// 如果是一个目录的路径，比如 &quot;./log/&quot;，则最终文件名为 &quot;log_等级名.txt&quot;</span></span><br><span class="line">        &#123;</span><br><span class="line">            Path = log_path + <span class="string">&quot;log_&quot;</span> + <span class="built_in">level_to_string</span>(level) + <span class="string">&quot;.txt&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>                                             <span class="comment">// 如果是一个文件路径，比如 &quot;./log.txt&quot;，则最终文件名为 &quot;log_等级名.txt&quot;</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">size_t</span> pos = log_path.<span class="built_in">find_last_of</span>(<span class="string">&#x27;.&#x27;</span>);     <span class="comment">// 从后往前找到第一个 &#x27;.&#x27; 的位置，即最后一次出现的 &#x27;.&#x27; 的位置</span></span><br><span class="line">            <span class="keyword">if</span> (pos != string::npos)</span><br><span class="line">            &#123;</span><br><span class="line">                string left = log_path.<span class="built_in">substr</span>(<span class="number">0</span>, pos);   <span class="comment">// 去掉后缀，即我所需要的有效的前部分路径</span></span><br><span class="line">                string right = log_path.<span class="built_in">substr</span>(pos);     <span class="comment">// 保留后缀，即有效的文件扩展名</span></span><br><span class="line">                Path = left + <span class="string">&quot;_&quot;</span> + <span class="built_in">level_to_string</span>(level) + right;         <span class="comment">// 组合成新的文件名</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>                                         <span class="comment">// 如果没有文件扩展名（比如 &quot;./log&quot;），则直接在文件名后面加上 &quot;_等级名.txt&quot;</span></span><br><span class="line">            &#123;</span><br><span class="line">                Path = log_path + <span class="string">&quot;_&quot;</span> + <span class="built_in">level_to_string</span>(level) + <span class="string">&quot;.txt&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Path;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 核心写文件函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">log_to_file</span><span class="params">(<span class="type">int</span> level, <span class="type">const</span> string&amp; log_content)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        string Path;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (classification == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Path = <span class="built_in">Suffix_processing</span>(level, log_path);   <span class="comment">// 按照日志等级分类存储</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (classification == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Path = log_path;                             <span class="comment">// 不分类直接使用传入的 log_path</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 追加写入，文件不存在则创建，权限 0644</span></span><br><span class="line">        <span class="type">int</span> fd = <span class="built_in">open</span>(Path.<span class="built_in">c_str</span>(), O_WRONLY | O_CREAT | O_APPEND, <span class="number">0644</span>);</span><br><span class="line">        <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(FIFO_OPEN_ERR);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">write</span>(fd, log_content.<span class="built_in">c_str</span>(), log_content.<span class="built_in">size</span>());</span><br><span class="line">        <span class="built_in">close</span>(fd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="2-comm-hpp-文件"><a href="#2-comm-hpp-文件" class="headerlink" title="2. comm.hpp 文件"></a>2. comm.hpp 文件</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Log.hpp&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* pathname = <span class="string">&quot;/home/hcc&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> project_id = <span class="number">0x1234</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> shm_size = <span class="number">4096</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FIFO_FILE <span class="string">&quot;./myfifo&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MODE 0664</span></span><br><span class="line"><span class="function">Log <span class="title">log</span><span class="params">(<span class="number">1</span>, <span class="number">0</span>, <span class="string">&quot;./log.txt&quot;</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取共享内存的key</span></span><br><span class="line"><span class="function"><span class="type">key_t</span> <span class="title">get_key</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">key_t</span> key = <span class="built_in">ftok</span>(pathname, project_id);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(key == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;共享内存的key创建失败！&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建共享内存</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">create_shm</span><span class="params">(<span class="type">int</span> flag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> shm_id = <span class="built_in">shmget</span>(<span class="built_in">get_key</span>(), shm_size, flag);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(shm_id == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;共享内存创建失败！&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> shm_id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只想创建共享内存，如果存在则报错</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">create_shm_only</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">create_shm</span>(IPC_CREAT | IPC_EXCL | <span class="number">0666</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取共享内存，如果不存在则创建</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_shm</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">create_shm</span>(IPC_CREAT | <span class="number">0666</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-processA-cc-文件"><a href="#3-processA-cc-文件" class="headerlink" title="3. processA.cc 文件"></a>3. processA.cc 文件</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;comm.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> shmid = <span class="built_in">create_shm_only</span>();                            <span class="comment">// 创建共享内存（只创建）</span></span><br><span class="line">    <span class="type">char</span> *shmaddr = (<span class="type">char</span> *)<span class="built_in">shmat</span>(shmid, <span class="literal">nullptr</span>, <span class="number">0</span>);         <span class="comment">// 挂接共享内存</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">open</span>(FIFO_FILE, O_RDONLY);                       <span class="comment">// 打开管道文件</span></span><br><span class="line">    <span class="keyword">if</span>(fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;打开文件失败！&quot;</span>);</span><br><span class="line">        <span class="built_in">log</span>(Error, <span class="string">&quot;打开文件失败！&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(FIFO_OPEN_ERR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">shmid_ds</span> shmds;                                    <span class="comment">// 共享内存信息结构体</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> c;                                               <span class="comment">// 读取字符</span></span><br><span class="line">        <span class="type">ssize_t</span> s = <span class="built_in">read</span>(fd, &amp;c, <span class="number">1</span>);                          <span class="comment">// 读取管道文件</span></span><br><span class="line">        <span class="keyword">if</span>(s &lt; <span class="number">0</span> || s == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;客户说：&quot;</span> &lt;&lt; shmaddr &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);                                             <span class="comment">// 模拟业务处理时间，延迟1秒</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">shmctl</span>(shmid, IPC_STAT, &amp;shmds);                      <span class="comment">// 获取共享内存信息</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;段大小: &quot;</span> &lt;&lt; shmds.shm_segsz &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;附着进程数: &quot;</span> &lt;&lt; shmds.shm_nattch &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;传递给进程的键值: 0x%x\n&quot;</span>,  shmds.shm_perm.__key);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;访问模式: &quot;</span> &lt;&lt; shmds.shm_perm.mode &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">shmdt</span>(shmaddr);                                           <span class="comment">// 脱挂共享内存</span></span><br><span class="line">    <span class="built_in">shmctl</span>(shmid, IPC_RMID, <span class="literal">nullptr</span>);                         <span class="comment">// 删除共享内存</span></span><br><span class="line">    <span class="built_in">close</span>(fd);                                                <span class="comment">// 关闭文件描述符</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-processB-cc-文件"><a href="#4-processB-cc-文件" class="headerlink" title="4. processB.cc 文件"></a>4. processB.cc 文件</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;comm.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> shmid = <span class="built_in">get_shm</span>();                                    <span class="comment">// 获取共享内存ID</span></span><br><span class="line">    <span class="type">char</span> *shmaddr = (<span class="type">char</span>*)<span class="built_in">shmat</span>(shmid, <span class="literal">nullptr</span>, <span class="number">0</span>);          <span class="comment">// 挂接共享内存</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">open</span>(FIFO_FILE, O_WRONLY);                       <span class="comment">// 打开FIFO文件</span></span><br><span class="line">    <span class="keyword">if</span>(fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;打开文件失败！&quot;</span>);</span><br><span class="line">        <span class="built_in">log</span>(Error, <span class="string">&quot;打开文件失败！&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(FIFO_OPEN_ERR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;请输入要发送的消息：&quot;</span>;</span><br><span class="line">        <span class="built_in">fgets</span>(shmaddr, <span class="number">4096</span>, stdin);                          <span class="comment">// 从标准输入读取消息</span></span><br><span class="line">        <span class="built_in">write</span>(fd, <span class="string">&quot;c&quot;</span>, <span class="number">1</span>);                                    <span class="comment">// 发送消息</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">shmdt</span>(shmaddr);                                           <span class="comment">// 脱挂共享内存</span></span><br><span class="line">    <span class="built_in">close</span>(fd);                                                <span class="comment">// 关闭FIFO文件</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-运行示例"><a href="#5-运行示例" class="headerlink" title="5. 运行示例"></a>5. 运行示例</h4><p><a href="https://www.bilibili.com/video/BV1vY32ziEGc/?spm_id_from=333.1387.upload.video_card.click">System V 共享内存 Demo</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 进程 </tag>
            
            <tag> 地址空间 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>033 日志</title>
      <link href="/posts/45891.html"/>
      <url>/posts/45891.html</url>
      
        <content type="html"><![CDATA[<h1 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h1><h2 id="1-为什么需要日志等级？"><a href="#1-为什么需要日志等级？" class="headerlink" title="1. 为什么需要日志等级？"></a>1. 为什么需要日志等级？</h2><p>在实际生产中，程序输出的信息非常多，如果没有等级就会导致：</p><ul><li>开发阶段找不到重点（调试信息太多）。</li><li>上线后也不好排查问题（没有区分严重错误和普通信息）。</li></ul><p>因此，合理使用日志等级，能让我们：</p><ol><li>快速定位错误。</li><li>过滤无用信息。</li><li>分环境（开发、测试、生产）灵活控制日志量。</li></ol><h2 id="2-Linux-常见日志等级"><a href="#2-Linux-常见日志等级" class="headerlink" title="2. Linux 常见日志等级"></a>2. Linux 常见日志等级</h2><p>以 <strong><code>syslog</code> 标准</strong> 为例（这是 Linux 内核和很多守护进程默认遵循的）：</p><table><thead><tr><th>等级名</th><th>数值（优先级）</th><th>典型含义</th></tr></thead><tbody><tr><td><strong>EMERG</strong></td><td>0</td><td>系统不可用，比如内核崩溃（panic）</td></tr><tr><td><strong>ALERT</strong></td><td>1</td><td>必须立刻采取措施，比如磁盘坏块</td></tr><tr><td><strong>CRIT</strong></td><td>2</td><td>严重错误，可能导致程序崩溃</td></tr><tr><td><strong>ERR</strong> (<strong>ERROR</strong>)</td><td>3</td><td>一般错误，需要修复</td></tr><tr><td><strong>WARNING</strong></td><td>4</td><td>警告信息，可能有潜在风险</td></tr><tr><td><strong>NOTICE</strong></td><td>5</td><td>正常但需要注意的事件</td></tr><tr><td><strong>INFO</strong></td><td>6</td><td>普通运行信息</td></tr><tr><td><strong>DEBUG</strong></td><td>7</td><td>调试信息，开发阶段最详细</td></tr></tbody></table><ul><li>数值越小，级别越高，越重要。</li><li>在生产环境中，一般只保留 <strong>WARNING</strong> 及以上等级，避免刷盘压力和磁盘占用。</li></ul><hr><p>然而在实际操作当中，我们大多只考虑下面几种日志等级信息：</p><ul><li><strong>Info：常规消息。</strong></li><li><strong>Warning：报警信息。</strong></li><li><strong>Error：比较严重了，可能需要立即处理。</strong></li><li><strong>Fatal：致命的。</strong></li><li><strong>Debug：调试信息。</strong></li></ul><p>无论是写到文件、控制台，还是系统日志，<strong>一个完整的日志条目</strong> 通常包含：</p><table><thead><tr><th>部分</th><th>示例</th><th>说明</th></tr></thead><tbody><tr><td><strong>时间戳（必须）</strong></td><td><code>2025-01-01 11:11:11</code></td><td>发生时间</td></tr><tr><td><strong>日志等级（必须）</strong></td><td><code>INFO</code></td><td>该条日志的重要性</td></tr><tr><td><strong>内容（必须）</strong></td><td><code>Connection established from 192.168.225.225.0</code></td><td>实际信息</td></tr><tr><td>主机名</td><td><code>server-01</code></td><td>哪台机器</td></tr><tr><td>程序名&#x2F;模块名</td><td><code>nginx</code></td><td>哪个程序</td></tr><tr><td>进程 ID</td><td><code>[pid=1234]</code></td><td>哪个进程</td></tr><tr><td>线程 ID</td><td><code>[tid=5678]</code></td><td>哪个线程（多线程时可选）</td></tr><tr><td>上下文（可选）</td><td>文件名、行号、函数名</td><td>开启调试时很重要</td></tr></tbody></table><h2 id="3-日志的实现"><a href="#3-日志的实现" class="headerlink" title="3. 日志的实现"></a>3. 日志的实现</h2><p>下面演示之前的 <strong>有名管道通信的服务端-客户端模型 Demo</strong> 进行的日志化：</p><h3 id="1-comm-hpp-文件"><a href="#1-comm-hpp-文件" class="headerlink" title="1. comm.hpp 文件"></a>1. comm.hpp 文件</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Log.hpp&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FIFO_FILE <span class="string">&quot;./myfifo&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MODE 0664</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// enum</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     FIFO_CREATE_ERR = 1,                    // 这是创建管道文件失败的错误码</span></span><br><span class="line"><span class="comment">//     FIFO_DELETE_ERR = 2,                    // 这是删除管道文件失败的错误码</span></span><br><span class="line"><span class="comment">//     FIFO_OPEN_ERR                           // 这是打开管道文件失败的错误码（枚举会自动赋值为3）</span></span><br><span class="line"><span class="comment">// &#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Init</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Init</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> n = <span class="built_in">mkfifo</span>(FIFO_FILE, MODE);    <span class="comment">// 创建管道文件</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;mkfifo&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(FIFO_CREATE_ERR);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Init</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> m = <span class="built_in">unlink</span>(FIFO_FILE);          <span class="comment">// 删除管道文件</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;unlink&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(FIFO_DELETE_ERR);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="2-Log-hpp（主要）"><a href="#2-Log-hpp（主要）" class="headerlink" title="2. Log.hpp（主要）"></a>2. Log.hpp（主要）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>                                      <span class="comment">// exit, perror</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>                                      <span class="comment">// read, write, close</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span>                                   <span class="comment">// open, close, read, write, lseek</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span>                                    <span class="comment">// mkdir</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span>                                       <span class="comment">// open, O_RDONLY, O_WRONLY, O_CREAT, O_APPEND</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span>                                       <span class="comment">// errno</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span>                                    <span class="comment">// gettimeofday, struct timeval</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span>                                         <span class="comment">// localtime_r, struct tm</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 管道错误码</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">FIFO_ERROR_CODE</span></span><br><span class="line">&#123;</span><br><span class="line">    FIFO_CREATE_ERR = <span class="number">1</span>,                                 <span class="comment">// 这是创建管道文件失败的错误码</span></span><br><span class="line">    FIFO_DELETE_ERR = <span class="number">2</span>,                                 <span class="comment">// 这是删除管道文件失败的错误码</span></span><br><span class="line">    FIFO_OPEN_ERR                                        <span class="comment">// 这是打开管道文件失败的错误码（枚举会自动赋值为3）</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 日志等级</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Log_Level</span></span><br><span class="line">&#123;</span><br><span class="line">    Fatal,                                               <span class="comment">// 最严重级别</span></span><br><span class="line">    Error,                                               <span class="comment">// 严重错误</span></span><br><span class="line">    Warning,                                             <span class="comment">// 警告</span></span><br><span class="line">    Debug,                                               <span class="comment">// 调试信息</span></span><br><span class="line">    Info                                                 <span class="comment">// 普通信息</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Log</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span>  enable = <span class="number">1</span>;                                     <span class="comment">// 是否启用日志</span></span><br><span class="line">    <span class="type">int</span>  classification = <span class="number">1</span>;                             <span class="comment">// 是否分类</span></span><br><span class="line">    string log_path = <span class="string">&quot;./log.txt&quot;</span>;                       <span class="comment">// 日志存放路径</span></span><br><span class="line">    <span class="type">int</span>  console_out = <span class="number">1</span>;                                <span class="comment">// 是否输出到终端</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 日志等级转换成字符串</span></span><br><span class="line">    <span class="function">string <span class="title">level_to_string</span><span class="params">(<span class="type">int</span> level)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (level)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> Fatal:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;Fatal&quot;</span>;</span><br><span class="line">            <span class="keyword">case</span> Error:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;Error&quot;</span>;</span><br><span class="line">            <span class="keyword">case</span> Warning:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;Warning&quot;</span>;</span><br><span class="line">            <span class="keyword">case</span> Debug:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;Debug&quot;</span>;</span><br><span class="line">            <span class="keyword">case</span> Info:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;Info&quot;</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;None&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前计算机的时间，返回格式：YYYY-MM-DD HH:MM:SS.UUUUUU （含微秒）</span></span><br><span class="line">    <span class="function">string <span class="title">get_current_time</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">timeval</span> tv;                               <span class="comment">// timeval：包含秒和微秒</span></span><br><span class="line">        <span class="built_in">gettimeofday</span>(&amp;tv, <span class="literal">nullptr</span>);                      <span class="comment">// 系统调用：获取当前时间（精确到微秒）</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">tm</span> t;                                     <span class="comment">// tm：分解时间，转格式（年、月、日、时、分、秒）</span></span><br><span class="line">        <span class="built_in">localtime_r</span>(&amp;tv.tv_sec, &amp;t);                     <span class="comment">// 把秒转换成年月日时分秒（本地时区）</span></span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> buffer[<span class="number">64</span>];                                 <span class="comment">// 定义字符数组作为格式化输出的缓冲区</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">snprintf</span>(buffer, <span class="built_in">sizeof</span>(buffer),</span><br><span class="line">                <span class="string">&quot;%04d-%02d-%02d %02d:%02d:%02d.%06ld&quot;</span>,</span><br><span class="line">                t.tm_year + <span class="number">1900</span>,                        <span class="comment">// 年：tm_year 从 1900 开始计数</span></span><br><span class="line">                t.tm_mon + <span class="number">1</span>,                            <span class="comment">// 月：tm_mon 从 0 开始，0 表示 1 月</span></span><br><span class="line">                t.tm_mday,                               <span class="comment">// 日</span></span><br><span class="line">                t.tm_hour,                               <span class="comment">// 时</span></span><br><span class="line">                t.tm_min,                                <span class="comment">// 分</span></span><br><span class="line">                t.tm_sec,                                <span class="comment">// 秒</span></span><br><span class="line">                tv.tv_usec);                             <span class="comment">// 微秒部分，取自 gettimeofday</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">string</span>(buffer);                           <span class="comment">// 转换成 string 返回</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Log</span>() = <span class="keyword">default</span>;                                     <span class="comment">// 使用默认构造</span></span><br><span class="line">    <span class="built_in">Log</span>(<span class="type">int</span> enable, <span class="type">int</span> classification, string log_path, <span class="type">int</span> console_out)</span><br><span class="line">        : <span class="built_in">enable</span>(enable),</span><br><span class="line">        <span class="built_in">classification</span>(classification),</span><br><span class="line">        <span class="built_in">log_path</span>(log_path),</span><br><span class="line">        <span class="built_in">console_out</span>(console_out)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 重载函数调用运算符</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> level, <span class="type">const</span> string&amp; content)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (enable == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;                                      <span class="comment">// 日志未启用</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        string level_str = <span class="string">&quot;[&quot;</span> + <span class="built_in">level_to_string</span>(level) + <span class="string">&quot;] &quot;</span>;</span><br><span class="line">        string log_message;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (classification == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            log_message = level_str + <span class="string">&quot;[&quot;</span> + <span class="built_in">get_current_time</span>() + <span class="string">&quot;] &quot;</span> + content + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (classification == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            log_message = <span class="string">&quot;[&quot;</span> + <span class="built_in">get_current_time</span>() + <span class="string">&quot;] &quot;</span> + content + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;传入的分类参数错误！\n&quot;</span>);              <span class="comment">// 分类未启用</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (console_out == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; log_message;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">log_to_file</span>(level, log_message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 文件路径的后缀处理函数：当按照日志等级分类存储并且文件路径是 &quot;./log.txt&quot; 这种有文件扩展名时的处理方法</span></span><br><span class="line">    <span class="function">string <span class="title">Suffix_processing</span><span class="params">(<span class="type">int</span> level, string log_path)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        string Path;</span><br><span class="line">        <span class="keyword">if</span> (log_path.<span class="built_in">back</span>() == <span class="string">&#x27;/&#x27;</span>)                      <span class="comment">// 如果是一个目录的路径，比如 &quot;./log/&quot;，则最终文件名为 &quot;log_等级名.txt&quot;</span></span><br><span class="line">        &#123;</span><br><span class="line">            Path = log_path + <span class="string">&quot;log_&quot;</span> + <span class="built_in">level_to_string</span>(level) + <span class="string">&quot;.txt&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>                                             <span class="comment">// 如果是一个文件路径，比如 &quot;./log.txt&quot;，则最终文件名为 &quot;log_等级名.txt&quot;</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">size_t</span> pos = log_path.<span class="built_in">find_last_of</span>(<span class="string">&#x27;.&#x27;</span>);     <span class="comment">// 从后往前找到第一个 &#x27;.&#x27; 的位置，即最后一次出现的 &#x27;.&#x27; 的位置</span></span><br><span class="line">            <span class="keyword">if</span> (pos != string::npos)</span><br><span class="line">            &#123;</span><br><span class="line">                string left = log_path.<span class="built_in">substr</span>(<span class="number">0</span>, pos);   <span class="comment">// 去掉后缀，即我所需要的有效的前部分路径</span></span><br><span class="line">                string right = log_path.<span class="built_in">substr</span>(pos);     <span class="comment">// 保留后缀，即有效的文件扩展名</span></span><br><span class="line">                Path = left + <span class="string">&quot;_&quot;</span> + <span class="built_in">level_to_string</span>(level) + right;         <span class="comment">// 组合成新的文件名</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>                                         <span class="comment">// 如果没有文件扩展名（比如 &quot;./log&quot;），则直接在文件名后面加上 &quot;_等级名.txt&quot;</span></span><br><span class="line">            &#123;</span><br><span class="line">                Path = log_path + <span class="string">&quot;_&quot;</span> + <span class="built_in">level_to_string</span>(level) + <span class="string">&quot;.txt&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Path;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 核心写文件函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">log_to_file</span><span class="params">(<span class="type">int</span> level, <span class="type">const</span> string&amp; log_content)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        string Path;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (classification == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Path = <span class="built_in">Suffix_processing</span>(level, log_path);   <span class="comment">// 按照日志等级分类存储</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (classification == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Path = log_path;                             <span class="comment">// 不分类直接使用传入的 log_path</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 追加写入，文件不存在则创建，权限 0644</span></span><br><span class="line">        <span class="type">int</span> fd = <span class="built_in">open</span>(Path.<span class="built_in">c_str</span>(), O_WRONLY | O_CREAT | O_APPEND, <span class="number">0644</span>);</span><br><span class="line">        <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(FIFO_OPEN_ERR);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">write</span>(fd, log_content.<span class="built_in">c_str</span>(), log_content.<span class="built_in">size</span>());</span><br><span class="line">        <span class="built_in">close</span>(fd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="3-Client-cc-文件"><a href="#3-Client-cc-文件" class="headerlink" title="3. Client.cc 文件"></a>3. Client.cc 文件</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;comm.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Log <span class="title">log</span><span class="params">(<span class="number">1</span>, <span class="number">1</span>, <span class="string">&quot;./log.txt&quot;</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">open</span>(FIFO_FILE, O_WRONLY);             <span class="comment">// 以只写方式打开管道文件</span></span><br><span class="line">    <span class="keyword">if</span>(fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">log</span>(Error, <span class="string">&quot;open FIFO_FILE failed&quot;</span>);        <span class="comment">// 使用日志记录错误</span></span><br><span class="line">        <span class="built_in">exit</span>(FIFO_OPEN_ERR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string str;                                     <span class="comment">// 定义消息字符串</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;请输入要发送的消息：&quot;</span>;</span><br><span class="line">        <span class="built_in">getline</span>(cin, str);                          <span class="comment">// 读取用户输入的消息（一整行）</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">write</span>(fd, str.<span class="built_in">c_str</span>(), str.<span class="built_in">size</span>());         <span class="comment">// 向管道文件写入消息，str.c_str()是 string 转换为 C 风格字符串 的方法</span></span><br><span class="line">        <span class="built_in">log</span>(Info, <span class="string">&quot;发送的消息: &quot;</span> + str);             <span class="comment">// 记录发送内容</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">close</span>(fd);                                      <span class="comment">// 关闭管道文件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-Server-cc-文件"><a href="#4-Server-cc-文件" class="headerlink" title="4. Server.cc 文件"></a>4. Server.cc 文件</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;comm.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Log <span class="title">log</span><span class="params">(<span class="number">1</span>, <span class="number">0</span>, <span class="string">&quot;./log.txt&quot;</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">open</span>(FIFO_FILE, O_RDONLY);                 <span class="comment">// 以只读方式打开管道</span></span><br><span class="line">    <span class="keyword">if</span>(fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">log</span>(Error, <span class="string">&quot;打开文件失败！&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(FIFO_OPEN_ERR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">int</span> x = <span class="built_in">read</span>(fd, buf, <span class="built_in">sizeof</span>(buf));             <span class="comment">// 读取管道数据，x 为读取的字节数</span></span><br><span class="line">        <span class="keyword">if</span>(x &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            buf[x] = <span class="number">0</span>;                                 <span class="comment">// 将完整的字节流转换为字符串，并添加结束符‘\0’</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;客户端说:&quot;</span> &lt;&lt; buf &lt;&lt; endl;</span><br><span class="line">            <span class="built_in">log</span>(Debug, <span class="string">&quot;收到消息: &quot;</span> + (string)buf);      <span class="comment">// 记录接收内容</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(fd);                                          <span class="comment">// 关闭管道</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-运行示例"><a href="#5-运行示例" class="headerlink" title="5. 运行示例"></a>5. 运行示例</h3><p><a href="https://www.bilibili.com/video/BV11AGjzBEQM/?spm_id_from=333.1387.homepage.video_card.click">日志插件 Demo 展示</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>032 进程间通信 —— 有名管道篇</title>
      <link href="/posts/1893.html"/>
      <url>/posts/1893.html</url>
      
        <content type="html"><![CDATA[<h1 id="进程间通信-——-有名管道篇"><a href="#进程间通信-——-有名管道篇" class="headerlink" title="进程间通信 —— 有名管道篇"></a>进程间通信 —— 有名管道篇</h1><h2 id="1-什么是有名管道"><a href="#1-什么是有名管道" class="headerlink" title="1. 什么是有名管道"></a>1. 什么是有名管道</h2><h3 id="1-基本定义"><a href="#1-基本定义" class="headerlink" title="1. 基本定义"></a>1. 基本定义</h3><p>有名管道是 Linux 中的一种进程间通信方式，其本质也是一个特殊类型的文件，存在于文件系统中，支持 <strong>无亲缘关系的进程</strong> 之间的数据通信。</p><h3 id="2-与匿名管道的对比"><a href="#2-与匿名管道的对比" class="headerlink" title="2. 与匿名管道的对比"></a>2. 与匿名管道的对比</h3><table><thead><tr><th align="center">特性</th><th align="center">匿名管道（pipe）</th><th align="center">有名管道（FIFO）</th></tr></thead><tbody><tr><td align="center">是否有文件路径</td><td align="center">❌ 没有</td><td align="center">✅ 有（存在于文件系统中）</td></tr><tr><td align="center">是否只能父子进程通信</td><td align="center">✅ 是</td><td align="center">❌ 可以无亲缘关系通信</td></tr><tr><td align="center">创建方式</td><td align="center"><code>pipe()</code></td><td align="center"><code>mkfifo()</code> &#x2F; <code>mknod()</code></td></tr><tr><td align="center">常见用途</td><td align="center">父子进程、线程内通信</td><td align="center">shell 脚本、后台服务通信</td></tr></tbody></table><h2 id="2-有名管道的创建与使用"><a href="#2-有名管道的创建与使用" class="headerlink" title="2. 有名管道的创建与使用"></a>2. 有名管道的创建与使用</h2><h3 id="1-mkfifo-函数原型-——-创建有名管道"><a href="#1-mkfifo-函数原型-——-创建有名管道" class="headerlink" title="1. mkfifo 函数原型 —— 创建有名管道"></a>1. <code>mkfifo</code> 函数原型 —— 创建有名管道</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mkfifo</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">mode_t</span> mode)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="参数详解"><a href="#参数详解" class="headerlink" title="参数详解"></a>参数详解</h4><ol><li><strong><code>const char *pathname</code>：</strong> 表示希望创建的 <strong>有名管道的路径</strong>（通常是绝对路径或当前目录下的文件名）。它创建出来的是一个 <strong>文件系统中的特殊设备文件</strong>，使用 <code>ls -l</code> 可以看到文件类型为 <code>p</code>（pipe）：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prw-r--r-- 1 user user 0 Jun 21 14:00 myfifo</span><br></pre></td></tr></table></figure><ol start="2"><li><p><strong><code>mode_t mode</code>：</strong> 表示新创建的 FIFO 文件的权限，常用类似 shell 中的权限位（与 <code>chmod</code> 相同），如：</p><ul><li><p><code>0666</code>：所有用户可读写（不加执行权限）。</p></li><li><p><code>0644</code>：仅拥有者可写，其它用户只读。</p></li><li><p><code>0600</code>：仅拥有者可读写。</p></li></ul></li></ol><p>注意：这个权限会受到 <strong>umask（用户掩码）</strong> 的影响！</p><h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><ul><li>成功时：返回 0。</li><li>失败时：返回 -1，并设置 errno 表示错误原因。</li></ul><hr><p><strong>通信 Demo：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250626222620689.gif"></p><p>创建一个有名管道文件 <code>myfifo</code>，使用 <code>while :; do echo &quot;Hello Linux&quot; ; sleep 1; done &gt;&gt; myfifo</code> 循环写入内容，发现管道文件大小始终是 0。<a href="https://www.bilibili.com/video/BV1RqKBzAEnY/?spm_id_from=333.1387.homepage.video_card.click">实验演示 | B 站</a>。说明：<strong>FIFO 是一种特殊文件，用于进程通信，其内容不保存在磁盘上，而是临时存放在内存缓冲区中，并且只有当有读端存在时，写入操作才能成功。即使有数据写入，文件大小也始终显示为 0。</strong></p><h3 id="2-unlink-函数原型-——-删除有名管道（本质就是从文件系统里删掉一个文件）"><a href="#2-unlink-函数原型-——-删除有名管道（本质就是从文件系统里删掉一个文件）" class="headerlink" title="2. unlink 函数原型 —— 删除有名管道（本质就是从文件系统里删掉一个文件）"></a>2. <code>unlink</code> 函数原型 —— 删除有名管道（本质就是从文件系统里删掉一个文件）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>   <span class="comment">// 头文件</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">unlink</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname)</span></span>;<span class="comment">// 删除一个名字与文件系统中 inode 的链接</span></span><br></pre></td></tr></table></figure><p><strong>参数：</strong> 要删除的文件（或管道、socket 文件等）的路径名，支持相对路径或绝对路径。</p><p><strong>返回值：</strong></p><ul><li>成功：返回 0</li><li>失败：返回 -1，并设置全局变量 errno</li></ul><blockquote><p><strong>重点理解</strong></p><ul><li><code>unlink()</code> 不会管里面有没有读写端打开，只是把文件名从文件系统中移除。</li><li>如果此时还有进程打开这个管道文件，管道内内核资源还在用，直到所有引用关闭后，内核才真正释放资源。（和普通文件 inode 行为一样）</li></ul></blockquote><hr><h3 id="3-unlink-和-rm-的关系"><a href="#3-unlink-和-rm-的关系" class="headerlink" title="3. unlink 和 rm 的关系"></a>3. <code>unlink</code> 和 <code>rm</code> 的关系</h3><ul><li><strong><code>unlink()</code></strong> 是 Linux 内核提供的低级系统调用，直接作用于文件系统的 inode 链接数。</li><li><strong><code>rm</code></strong> 是用户空间程序，底层就是调用 <code>unlink()</code> 来完成删除。</li></ul><p><strong>在实际生产场景中：</strong></p><ul><li>有名管道通常是 <strong>临时文件</strong>，由程序创建出来给进程通信用。</li><li>程序结束时，最好自己负责清理掉。</li><li>如果不主动 <code>unlink()</code>，就要依赖人去 <code>rm</code>，这就是“脏文件”了 —— 下次 <code>mkfifo</code> 会报 <code>EEXIST</code>。</li></ul><table><thead><tr><th>操作</th><th>作用</th><th>场景</th></tr></thead><tbody><tr><td><code>rm</code></td><td>命令行层面的文件删除</td><td>人工手动操作</td></tr><tr><td><code>unlink()</code></td><td>系统调用层面的文件删除</td><td>程序自动管理资源，退出时清理</td></tr></tbody></table><p>本质是一样的，只是执行主体和使用时机不同。</p><blockquote><p><strong>思考：你知道 <code>rm</code> 删除文件背后的原理吗？如果文件还被打开，<code>rm</code> 会发生什么？</strong></p><p>答案：</p><ul><li><code>rm</code> 会把文件名目录项删除，<strong>但是只要还有进程打开这个文件，inode 不会被释放</strong>。</li><li>所以有名管道如果还有进程在读写，<code>rm</code>（或 <code>unlink</code>）后文件看不到了，但内核仍然维护着，直到最后一个 fd 关闭，内核才真正释放。</li></ul></blockquote><h2 id="3-基于有名管道通信的服务端-客户端模型-Demo"><a href="#3-基于有名管道通信的服务端-客户端模型-Demo" class="headerlink" title="3. 基于有名管道通信的服务端-客户端模型 Demo"></a>3. 基于有名管道通信的服务端-客户端模型 Demo</h2><h3 id="1-头文件-comm-hpp"><a href="#1-头文件-comm-hpp" class="headerlink" title="1. 头文件 comm.hpp"></a>1. 头文件 comm.hpp</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FIFO_FILE <span class="string">&quot;./myfifo&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MODE 0664</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span></span><br><span class="line">&#123;</span><br><span class="line">    FIFO_CREATE_ERR = <span class="number">1</span>,                    <span class="comment">// 这是创建管道文件失败的错误码</span></span><br><span class="line">    FIFO_DELETE_ERR = <span class="number">2</span>,                    <span class="comment">// 这是删除管道文件失败的错误码</span></span><br><span class="line">    FIFO_OPEN_ERR                           <span class="comment">// 这是打开管道文件失败的错误码（枚举会自动赋值为3）</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Init</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Init</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> n = <span class="built_in">mkfifo</span>(FIFO_FILE, MODE);    <span class="comment">// 创建管道文件</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;mkfifo&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(FIFO_CREATE_ERR);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Init</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> m = <span class="built_in">unlink</span>(FIFO_FILE);          <span class="comment">// 删除管道文件</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;unlink&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(FIFO_DELETE_ERR);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="2-客户端-Client-cc"><a href="#2-客户端-Client-cc" class="headerlink" title="2. 客户端 Client.cc"></a>2. 客户端 Client.cc</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;comm.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">open</span>(FIFO_FILE, O_WRONLY);             <span class="comment">// 以只写方式打开管道文件</span></span><br><span class="line">    <span class="keyword">if</span>(fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(FIFO_OPEN_ERR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string str;                                     <span class="comment">// 定义消息字符串</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;请输入要发送的消息：&quot;</span>;</span><br><span class="line">        <span class="built_in">getline</span>(cin, str);                          <span class="comment">// 读取用户输入的消息（一整行）</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">write</span>(fd, str.<span class="built_in">c_str</span>(), str.<span class="built_in">size</span>());         <span class="comment">// 向管道文件写入消息，str.c_str()是 string 转换为 C 风格字符串 的方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">close</span>(fd);                                      <span class="comment">// 关闭管道文件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-服务端-Server-cc"><a href="#3-服务端-Server-cc" class="headerlink" title="3. 服务端 Server.cc"></a>3. 服务端 Server.cc</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;comm.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Init fifo;                                          <span class="comment">// 初始化管道</span></span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">open</span>(FIFO_FILE, O_RDONLY);                 <span class="comment">// 以只读方式打开管道</span></span><br><span class="line">    <span class="keyword">if</span>(fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(FIFO_OPEN_ERR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">int</span> x = <span class="built_in">read</span>(fd, buf, <span class="built_in">sizeof</span>(buf));             <span class="comment">// 读取管道数据，x 为读取的字节数</span></span><br><span class="line">        <span class="keyword">if</span>(x &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            buf[x] = <span class="number">0</span>;                                 <span class="comment">// 将完整的字节流转换为字符串，并添加结束符‘\0’</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;客户端说:&quot;</span> &lt;&lt; buf &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(fd);                                          <span class="comment">// 关闭管道</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行展示：<a href="https://www.bilibili.com/video/BV1SNKSz9E7k/?spm_id_from=333.1387.homepage.video_card.click">有名管道通信的服务端-客户端模型 Demo 运行示例 | B 站</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 进程 </tag>
            
            <tag> 管道 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>031 进程间通信 —— 匿名管道篇</title>
      <link href="/posts/60299.html"/>
      <url>/posts/60299.html</url>
      
        <content type="html"><![CDATA[<h1 id="进程间通信-——-匿名管道篇"><a href="#进程间通信-——-匿名管道篇" class="headerlink" title="进程间通信 —— 匿名管道篇"></a>进程间通信 —— 匿名管道篇</h1><h2 id="1-什么是管道"><a href="#1-什么是管道" class="headerlink" title="1. 什么是管道"></a>1. 什么是管道</h2><p><strong>管道就是一个内核缓冲区，允许一个进程写数据，另一个进程从中读数据。</strong> 它像一根水管：一头写入，一头读取，中间是内核帮我们传递数据。</p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250617212422461.png" alt="image-20250617212422402"></p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250617211905195.png" alt="image-20250617211905112"></p><h2 id="2-管道的直接原理"><a href="#2-管道的直接原理" class="headerlink" title="2. 管道的直接原理"></a>2. 管道的直接原理</h2><h3 id="1-底层本质"><a href="#1-底层本质" class="headerlink" title="1. 底层本质"></a>1. 底层本质</h3><p>管道就是操作系统在内核空间里开辟的一块 <strong>内存缓冲区</strong>，这个缓冲区由内核维护，进程不能直接访问，只能通过 <strong>文件描述符</strong> 进行读写。</p><ul><li><p>管道使用了 <strong>环形缓冲区</strong>（循环队列结构），读写两端由内核控制。</p></li><li><p>当我们调用 <code>pipe(fd)</code>，操作系统会：</p><ul><li><p>在内核里创建一个缓冲区。</p></li><li><p>返回两个文件描述符：</p><ul><li><code>fd[0]</code>：读端读进程：<code>read(fd[0], buf, size);</code> 从管道中读取数据（从内核缓冲区读）。</li><li><code>fd[1]</code>：写端写进程：<code>write(fd[1], data, size);</code> 把数据写入管道（进入内核缓冲区）。</li></ul><blockquote><p><code>pipefd[0]</code> → <code>0</code> → 嘴巴 → 读书 → 读端<br><code>pipefd[1]</code> → <code>1</code> → 钢笔 → 写字 → 写端</p></blockquote></li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250617211557553.png" alt="image-20250617211550142"></p><h2 id="3-匿名管道的接口"><a href="#3-匿名管道的接口" class="headerlink" title="3. 匿名管道的接口"></a>3. 匿名管道的接口</h2><h3 id="1-pipe-函数原型"><a href="#1-pipe-函数原型" class="headerlink" title="1. pipe() 函数原型"></a>1. <code>pipe()</code> 函数原型</h3><p>在 Linux 中，<code>pipe()</code> 是用于创建 <strong>匿名管道</strong> 的系统调用，原型如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span><span class="comment">// 头文件</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pipe</span><span class="params">(<span class="type">int</span> pipefd[<span class="number">2</span>])</span></span>;<span class="comment">// 函数声明</span></span><br></pre></td></tr></table></figure><p><strong>参数解释：</strong></p><p><code>pipefd[2]</code> 是一个 <strong>整型数组</strong>，用来返回两个文件描述符：</p><ul><li><code>pipefd[0]</code>：<strong>读端</strong>。</li><li><code>pipefd[1]</code>：<strong>写端</strong>。</li></ul><p><strong>返回值：</strong></p><ul><li>成功：返回 <code>0</code>。</li><li>失败：返回 <code>-1</code>，并设置 <code>errno</code>。</li></ul><p><strong><code>pipe()</code> 创建的是匿名管道。也就是说：匿名管道不能跨无亲缘关系的进程通信，通常用于 父子进程 或 具有共同祖先进程的兄弟进程 间的通信。</strong></p><h3 id="2-demo-示例"><a href="#2-demo-示例" class="headerlink" title="2. demo 示例"></a>2. demo 示例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> pipefd[<span class="number">2</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">pipe</span>(pipefd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;pipefd[0]: &quot;</span> &lt;&lt; pipefd[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; , pipefd[1]: &quot;</span> &lt;&lt; pipefd[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><ul><li>代码中 <code>int pipefd[2] = &#123; 0 &#125;;</code> 将数组初始化为 <code>[0, 0]</code>，但这只是 <strong>临时状态</strong>。</li><li><code>pipe()</code> 是 <strong>系统调用</strong>，它的核心功能是由操作系统内核实现的。调用时，内核会：<ol><li><strong>忽略</strong> 我们传入的初始值（<code>pipefd</code> 只是用于接收结果的缓冲区）。</li><li><strong>动态分配</strong> 两个可用的文件描述符（通常是当前未用的最小数值），并写入到 <code>pipefd</code> 中。</li></ol></li></ul><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250617220653615.png" alt="image-20250617220653484"></p><p>程序输出了：<code>pipefd[0]: 3 , pipefd[1]: 4</code>。原因：Linux 中，0&#x2F;1&#x2F;2 已默认分配给 <code>stdin</code>&#x2F;<code>stdout</code>&#x2F;<code>stderr</code>，就不过多赘述了。如果重复创建管道（例如在循环中），描述符会如何变化？</p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250617222145964.png" alt="image-20250617222145806"></p><p>解释：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span>, <span class="number">4</span>    <span class="comment">// 上一次分配 3(读), 4(写)，关闭 3，但 4 还在</span></span><br><span class="line"><span class="number">3</span>, <span class="number">5</span>    <span class="comment">// 再次分配最小未用的是 3(读), 5(写)</span></span><br><span class="line"><span class="number">3</span>, <span class="number">6</span>    <span class="comment">// 再次分配 3(读), 6(写)</span></span><br></pre></td></tr></table></figure><p>实现一个最基础的 <strong>匿名管道通信模型</strong>，用于父子进程之间传输数据：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>                 <span class="comment">// 提供 pipe, fork, read, write, sleep 等系统调用</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span>               <span class="comment">// 提供 waitpid</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NUM 1024</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 子进程写入函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Writer</span><span class="params">(<span class="type">int</span> wfd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s = <span class="string">&quot;我是子进程&quot;</span>;         <span class="comment">// 待发送内容</span></span><br><span class="line">    <span class="type">pid_t</span> self = <span class="built_in">getpid</span>();          <span class="comment">// 获取当前子进程 PID</span></span><br><span class="line">    <span class="type">int</span> number = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buffer[NUM];               <span class="comment">// 缓冲区</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);                   <span class="comment">// 每秒写一次，节省 CPU</span></span><br><span class="line"></span><br><span class="line">        buffer[<span class="number">0</span>] = <span class="number">0</span>;              <span class="comment">// 清空缓冲区，表明我们是用它当字符串用</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造发送信息：我是子进程-子进程pid-序号</span></span><br><span class="line">        <span class="built_in">snprintf</span>(buffer, <span class="built_in">sizeof</span>(buffer), <span class="string">&quot;%s-%d-%d&quot;</span>, s.<span class="built_in">c_str</span>(), self, number++);</span><br><span class="line">        cout &lt;&lt; buffer &lt;&lt; endl;     <span class="comment">// 本地输出（写给终端）</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将内容写入管道（系统调用 write），供父进程读取</span></span><br><span class="line">        <span class="built_in">write</span>(wfd, buffer, <span class="built_in">strlen</span>(buffer));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父进程读取函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Reader</span><span class="params">(<span class="type">int</span> rfd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> buffer[NUM];               <span class="comment">// 读取缓冲区</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        buffer[<span class="number">0</span>] = <span class="number">0</span>;              <span class="comment">// 清空</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取管道数据，read 是系统调用</span></span><br><span class="line">        <span class="type">ssize_t</span> n = <span class="built_in">read</span>(rfd, buffer, <span class="built_in">sizeof</span>(buffer));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (n &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            buffer[n] = <span class="number">0</span>;          <span class="comment">// 加上字符串结束符 &#x27;\0&#x27;，确保安全打印</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;父进程收到消息[&quot;</span> &lt;&lt; <span class="built_in">getpid</span>() &lt;&lt; <span class="string">&quot;]# &quot;</span> &lt;&lt; buffer &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">0</span>)            <span class="comment">// 返回 0 表示对端写入端关闭，读到 EOF</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;父进程读到 EOF!\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>                        <span class="comment">// 读取失败</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> pipefd[N] = &#123; <span class="number">0</span> &#125;;       <span class="comment">// pipefd[0]: read 端, pipefd[1]: write 端</span></span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">pipe</span>(pipefd);        <span class="comment">// 创建匿名管道</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;                <span class="comment">// 创建失败返回</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建子进程（fork）</span></span><br><span class="line">    <span class="type">pid_t</span> id = fork();</span><br><span class="line">    <span class="keyword">if</span> (id &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;                <span class="comment">// 创建失败</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (id == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 子进程逻辑</span></span><br><span class="line">        <span class="built_in">close</span>(pipefd[<span class="number">0</span>]);        <span class="comment">// 关闭读端，只写</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">Writer</span>(pipefd[<span class="number">1</span>]);       <span class="comment">// 执行写入任务</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">close</span>(pipefd[<span class="number">1</span>]);        <span class="comment">// 写完关闭写端</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);                 <span class="comment">// 退出子进程</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 父进程逻辑</span></span><br><span class="line">    <span class="built_in">close</span>(pipefd[<span class="number">1</span>]);            <span class="comment">// 父进程关闭写端，只读</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">Reader</span>(pipefd[<span class="number">0</span>]);           <span class="comment">// 执行读取任务（会阻塞等待）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待子进程退出</span></span><br><span class="line">    <span class="type">pid_t</span> rid = <span class="built_in">waitpid</span>(id, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (rid &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;waitpid&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(pipefd[<span class="number">0</span>]);            <span class="comment">// 关闭读端</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">5</span>);                    <span class="comment">// 给终端输出留个时间</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong><code>snprintf</code> 函数原型</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line">&gt;<span class="function"><span class="type">int</span> <span class="title">snprintf</span><span class="params">(<span class="type">char</span> *str, <span class="type">size_t</span> size, <span class="type">const</span> <span class="type">char</span> *format, ...)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>参数解释：</strong></p><table><thead><tr><th>参数名</th><th>含义</th></tr></thead><tbody><tr><td><code>str</code></td><td>输出缓冲区（目标字符串），用于保存格式化后的字符串</td></tr><tr><td><code>size</code></td><td><code>str</code> 缓冲区的最大容量（<strong>包括结尾的 <code>\0</code></strong>）</td></tr><tr><td><code>format</code></td><td>格式字符串（类似 <code>printf</code>）</td></tr><tr><td><code>...</code></td><td>可变参数，对应 <code>format</code> 中的格式说明符</td></tr></tbody></table><p><strong>返回值：</strong></p><ul><li>如果成功：返回 <strong>欲写入的字符串长度</strong>（<strong>不包括结尾的 <code>\0</code></strong>）。</li><li>如果返回值 ≥ <code>size</code>：说明输出被截断（因为目标缓冲区太小）。</li><li>如果返回值 &lt; <code>size</code>：说明字符串成功写入，结尾自动加上了 <code>\0</code>。</li></ul><p><strong>作用总结：</strong></p><p><code>snprintf</code> 是一种 <strong>安全版本</strong> 的 <code>sprintf</code>，能防止内存溢出。常用于 <strong>格式化字符串写入缓冲区</strong>。相比 <code>sprintf</code>，它加了一个 <strong>长度限制参数 <code>size</code></strong>，从而更安全：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="built_in">sprintf</span>(buf, <span class="string">&quot;%d-%s&quot;</span>, id, name);      <span class="comment">// ⚠️ 可能溢出</span></span><br><span class="line">&gt;<span class="built_in">snprintf</span>(buf, <span class="built_in">sizeof</span>(buf), <span class="string">&quot;%d-%s&quot;</span>, id, name);  <span class="comment">// 安全</span></span><br></pre></td></tr></table></figure></blockquote><p>上面的代码的运行结果就不演示了，从关闭父子进程的读端和写端就可以发现：</p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250618130246228.png" alt="image-20250618130238994"></p><h4 id="站在文件描述符角度深入理解管道"><a href="#站在文件描述符角度深入理解管道" class="headerlink" title="站在文件描述符角度深入理解管道"></a>站在文件描述符角度深入理解管道</h4><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250618130445729.png" alt="image-20250618130445595"></p><h4 id="站在内核角度理解管道的本质"><a href="#站在内核角度理解管道的本质" class="headerlink" title="站在内核角度理解管道的本质"></a>站在内核角度理解管道的本质</h4><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250618131847420.png" alt="image-20250618131847304"></p><h2 id="4-重新认识管道"><a href="#4-重新认识管道" class="headerlink" title="4. 重新认识管道"></a>4. 重新认识管道</h2><h3 id="1-管道也是文件吗？"><a href="#1-管道也是文件吗？" class="headerlink" title="1. 管道也是文件吗？"></a>1. 管道也是文件吗？</h3><p>是的，在 Linux 中，<strong>管道是“特殊类型的文件”，非磁盘文件</strong>（准确说，是一种特殊的 I&#x2F;O 通道），完全符合：「一切皆文件」：键盘、鼠标、终端、套接字、管道、设备，全都是文件，统一用文件描述符（<code>int fd</code>）访问。</p><p><strong>匿名管道没有名字，但有文件描述符。</strong> 它在内核中创建一个缓冲区，并返回两个文件描述符指向它，但它 <strong>没有路径名</strong>，在 <code>/proc/[pid]/fd/</code> 中也只表现为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 -&gt; pipe:[12345]</span><br></pre></td></tr></table></figure><h3 id="2-管道有没有固定大小？可以写多少内容？"><a href="#2-管道有没有固定大小？可以写多少内容？" class="headerlink" title="2. 管道有没有固定大小？可以写多少内容？"></a>2. 管道有没有固定大小？可以写多少内容？</h3><p><strong>有：内核缓冲区大小是有限的：</strong> 默认大小一般是 <strong>65536 字节（64KB）</strong>，不同系统下可以通过命令查看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/sys/fs/pipe-max-size      <span class="comment"># 管道最大容量</span></span><br></pre></td></tr></table></figure><hr><h3 id="3-匿名管道的-5-个特征"><a href="#3-匿名管道的-5-个特征" class="headerlink" title="3. 匿名管道的 5 个特征"></a>3. 匿名管道的 5 个特征</h3><h4 id="1-具有血缘关系的进程进行进程间通信"><a href="#1-具有血缘关系的进程进行进程间通信" class="headerlink" title="1. 具有血缘关系的进程进行进程间通信"></a>1. 具有血缘关系的进程进行进程间通信</h4><p>有血缘关系的进程通信：匿名管道（<code>pipe()</code>）只支持 <strong>父子或兄弟</strong> 这种有“血缘”的进程通信（还存在爷孙关系，非常少见）。<strong>原因：匿名管道没有文件路径，只能靠 <code>fork()</code> 时继承文件描述符传递给子进程。</strong></p><h4 id="2-匿名管道只能单向通信，双向可以使用多管道"><a href="#2-匿名管道只能单向通信，双向可以使用多管道" class="headerlink" title="2. 匿名管道只能单向通信，双向可以使用多管道"></a>2. 匿名管道只能单向通信，双向可以使用多管道</h4><p><code>pipefd[0]</code> 是读端，<code>pipefd[1]</code> 是写端，<strong>本质就是单向数据流</strong>。父子进程需要互相通信 → 开两个 <code>pipe</code>。</p><h4 id="3-父子进程协同通信-同步-互斥（保护管道文件的数据安全）"><a href="#3-父子进程协同通信-同步-互斥（保护管道文件的数据安全）" class="headerlink" title="3. 父子进程协同通信 &#x3D; 同步 + 互斥（保护管道文件的数据安全）"></a>3. 父子进程协同通信 &#x3D; 同步 + 互斥（保护管道文件的数据安全）</h4><p>管道通信是 <strong>阻塞 I&#x2F;O</strong> 的体现，天然就是同步机制。<strong>详见下方的匿名管道中的 4 中情况</strong>。</p><ul><li><strong>读阻塞（没有数据时）</strong> ⇒ 读线程自动挂起，等待写线程唤醒（即写入数据）。</li><li><strong>写阻塞（写满时）</strong> ⇒ 写线程自动挂起，等待读线程消费。</li></ul><p>这是典型的 <strong>生产者-消费者模型</strong>，操作系统自动帮我们实现了互斥和同步。</p><h4 id="4-管道是面向字节流的"><a href="#4-管道是面向字节流的" class="headerlink" title="4. 管道是面向字节流的"></a>4. 管道是面向字节流的</h4><p>管道是“字节流”接口，<code>read</code> 和 <code>write</code> 都是面向字节，没有结构、没有分隔、没有消息边界。</p><h4 id="5-管道是基于文件的，但不落盘，生命周期跟随进程"><a href="#5-管道是基于文件的，但不落盘，生命周期跟随进程" class="headerlink" title="5. 管道是基于文件的，但不落盘，生命周期跟随进程"></a>5. 管道是基于文件的，但不落盘，生命周期跟随进程</h4><p>匿名管道 &#x3D; 临时文件 &#x3D; 内核缓冲区，<strong>使用文件描述符访问</strong>。<code>pipe()</code> 创建的管道，不存在磁盘上，进程退出后自动销毁。</p><hr><h3 id="4-匿名管道中的-4-中情况"><a href="#4-匿名管道中的-4-中情况" class="headerlink" title="4. 匿名管道中的 4 中情况"></a>4. 匿名管道中的 4 中情况</h3><table><thead><tr><th>编号</th><th>场景</th><th>阻塞？</th><th>原因 &amp; 说明</th></tr></thead><tbody><tr><td>1</td><td>管道没数据，读端阻塞</td><td>✅ 是</td><td>等待写端写数据</td></tr><tr><td>2</td><td>管道满了，写端阻塞</td><td>✅ 是</td><td>等待读端消费数据</td></tr><tr><td>3</td><td>写端关闭，读端读取</td><td>❌ 否</td><td><code>read()</code> 返回 0，表示 EOF，不会阻塞</td></tr><tr><td>4</td><td>读端关闭，写端写入</td><td>❌ 失败</td><td>写端收到 <code>SIGPIPE</code> 信号 → 默认会被杀死（转到情况 3）</td></tr></tbody></table><p><strong>深度解析：第 4 种情况为什么会崩？</strong></p><p>示例代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>     <span class="comment">// pipe, fork, write, close, read</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span>      <span class="comment">// exit</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span>      <span class="comment">// strlen</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span>   <span class="comment">// waitpid</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cerrno&gt;</span>       <span class="comment">// errno</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span>       <span class="comment">// perror</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子进程写入管道（触发SIGPIPE）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ChildWrite</span><span class="params">(<span class="type">int</span> wfd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* msg = <span class="string">&quot;你好，父进程！\n&quot;</span>;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;子进程写入 #&quot;</span> &lt;&lt; count++ &lt;&lt; endl;</span><br><span class="line">        <span class="type">ssize_t</span> n = <span class="built_in">write</span>(wfd, msg, <span class="built_in">strlen</span>(msg));</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;子进程写入管道失败！&quot;</span>);</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;errno: &quot;</span> &lt;&lt; errno &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);                           <span class="comment">// 控制写入频率</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正常情况下不会执行到这里（SIGPIPE会终止进程）</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;子进程关闭写端，退出...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">close</span>(wfd);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父进程读管道后关闭读端（触发子进程SIGPIPE）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ParentRead</span><span class="params">(<span class="type">int</span> rfd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">ssize_t</span> n = <span class="built_in">read</span>(rfd, buf, <span class="built_in">sizeof</span>(buf) - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (n &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            buf[n] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;父进程读到：&quot;</span> &lt;&lt; buf;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);                           <span class="comment">// 模拟读操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;父进程关闭读端（将触发子进程SIGPIPE）...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">close</span>(rfd);                             <span class="comment">// 关闭读端</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">pipe</span>(pipefd) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;管道创建失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;创建子进程失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)                      <span class="comment">// 子进程：关闭读端，持续写入</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">close</span>(pipefd[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">ChildWrite</span>(pipefd[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(pipefd[<span class="number">1</span>]);                       <span class="comment">// 父进程：关闭写端，读取数据</span></span><br><span class="line">    <span class="built_in">ParentRead</span>(pipefd[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;等待10秒，观察僵尸进程（PID=&quot;</span> &lt;&lt; pid &lt;&lt; <span class="string">&quot;）...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">10</span>);                              <span class="comment">// 延迟等待（此时子进程成为僵尸进程）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回收子进程（将显示SIGPIPE终止）</span></span><br><span class="line">    <span class="type">int</span> status = <span class="number">0</span>;</span><br><span class="line">    <span class="type">pid_t</span> ret = <span class="built_in">waitpid</span>(pid, &amp;status, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">WIFSIGNALED</span>(status))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> sig = <span class="built_in">WTERMSIG</span>(status);</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;子进程被信号终止，信号编号: &quot;</span> &lt;&lt; sig &lt;&lt; <span class="string">&quot; (&quot;</span> &lt;&lt; <span class="built_in">strsignal</span>(sig) &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">WIFEXITED</span>(status))</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;子进程正常退出，exit code: &quot;</span> &lt;&lt; <span class="built_in">WEXITSTATUS</span>(status) &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;子进程异常退出&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;waitpid 失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;父进程退出...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果并验证：确实收到了 <code>SIGPIPE</code> 信号。</p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250618170142593.png" alt="image-20250618170142443"></p><p>当我们关闭读端后，系统就会发现没人接收了，就：</p><ul><li>向当前进程发送 <code>SIGPIPE</code>。</li><li>默认行为是 <strong>终止进程（kill）</strong>。</li></ul><p>实际开发中一般这么做防御：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">signal</span>(SIGPIPE, SIG_IGN); <span class="comment">// 忽略 SIGPIPE 信号</span></span><br></pre></td></tr></table></figure><p>然后再手动检查 <code>write()</code> 的返回值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> n = <span class="built_in">write</span>(wfd, buffer, len);</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">perror</span>(<span class="string">&quot;write failed&quot;</span>);</span><br><span class="line">    <span class="comment">// 尝试重连 / 停止写入</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>操作系统哲学：“操作系统不做无意义、不必要、低效的工作。如果做了，就是操作系统的 BUG！”</strong></p><p>比如：</p><ul><li>没有写端了 → 管道也就没用了，读再久也不会有数据 → 不如直接返回 0</li><li>没有读端了 → 继续写是浪费 → 直接 kill 写入进程（SIGPIPE）</li></ul><p>如果非要系统继续阻塞读，那就是设计缺陷（<strong>不会给无意义的等待</strong>）。</p></blockquote><hr><h3 id="5-匿名管道的应用场景"><a href="#5-匿名管道的应用场景" class="headerlink" title="5. 匿名管道的应用场景"></a>5. 匿名管道的应用场景</h3><ol><li>shell 命令中的管道符 —— <code>ps aux | grep nginx | wc -l</code> 等。</li><li>实时数据处理 —— 监控系统、日志系统、流式数据预处理。</li><li>后端开发的进程管理 —— 主进程 + 子进程池（进程池模型）、数据库连接池等。</li></ol><h2 id="5-Shell-的管道符"><a href="#5-Shell-的管道符" class="headerlink" title="5. Shell 的管道符 |"></a>5. Shell 的管道符 <code>|</code></h2><p>Shell 的管道符 <code>|</code> 是一种 <strong>把一个命令的标准输出（stdout）传递给下一个命令的标准输入（stdin）</strong> 的方式。<strong>形式：</strong> <code>命令1 | 命令2 | 命令3</code>。作用：实现多个命令之间的 <strong>数据流式传递</strong>，将它们组合成 <strong>处理流水线（pipeline）</strong>。</p><h3 id="1-常见用法示例"><a href="#1-常见用法示例" class="headerlink" title="1. 常见用法示例"></a>1. 常见用法示例</h3><blockquote><h4 id="1-grep-——-文本搜索利器"><a href="#1-grep-——-文本搜索利器" class="headerlink" title="1. grep —— 文本搜索利器"></a>1. <code>grep</code> —— 文本搜索利器</h4><p><code>grep</code> 用于在文本中按行查找 <strong>符合正则表达式的内容</strong>，是日志分析、文本处理的核心工具。</p><p><strong>基本语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;grep [选项] <span class="string">&quot;模式&quot;</span> 文件名</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">常用选项</th><th align="left">含义</th></tr></thead><tbody><tr><td align="center"><code>-i</code></td><td align="left">忽略大小写（ignore case）</td></tr><tr><td align="center"><code>-v</code></td><td align="left">反向匹配（只显示不包含模式的行）</td></tr><tr><td align="center"><code>-r</code></td><td align="left">递归搜索目录</td></tr><tr><td align="center"><code>-n</code></td><td align="left">显示匹配行的行号</td></tr><tr><td align="center"><code>--color=auto</code></td><td align="left">高亮显示匹配部分</td></tr></tbody></table><p><strong>示例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;grep error server.log               <span class="comment"># 查找包含 &quot;error&quot; 的行</span></span><br><span class="line">&gt;grep -i http access.log             <span class="comment"># 忽略大小写搜索</span></span><br><span class="line">&gt;dmesg | grep -i usb                 <span class="comment"># 在内核日志中查找 usb 相关信息</span></span><br></pre></td></tr></table></figure><h4 id="2-nginx-——-高性能-Web-服务器"><a href="#2-nginx-——-高性能-Web-服务器" class="headerlink" title="2. nginx —— 高性能 Web 服务器"></a>2. <code>nginx</code> —— 高性能 Web 服务器</h4><p>此时还不涉及，留个悬念，以后再讲，示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;ps aux | grep nginx   <span class="comment"># 查看 nginx 是否正在运行</span></span><br></pre></td></tr></table></figure></blockquote><ol><li><p>统计当前登录用户数量：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">who</span> | <span class="built_in">wc</span> -l<span class="comment"># who: 显示当前登录的用户，wc -l: 统计行数</span></span><br></pre></td></tr></table></figure></li><li><p>查看系统中以 nginx 运行的进程数量：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps aux | grep nginx | <span class="built_in">wc</span> -l<span class="comment"># ps aux: 列出所有进程，grep nginx: 过滤包含 nginx 的行，wc -l: 统计行数（即进程数）</span></span><br></pre></td></tr></table></figure></li><li><p>显示 <code>/etc/passwd</code> 中包含 “bash” 的用户名：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /etc/passwd | grep bash | <span class="built_in">cut</span> -d: -f1<span class="comment"># cut -d: -f1: 用冒号分割字段，提取第一列（用户名）</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="2-底层原理（深入理解）"><a href="#2-底层原理（深入理解）" class="headerlink" title="2. 底层原理（深入理解）"></a>2. 底层原理（深入理解）</h3><p>当你写下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A | B</span><br></pre></td></tr></table></figure><p>Shell 做了如下事情：</p><ol><li>调用 <code>pipe()</code> 创建一个匿名管道（两个文件描述符：读和写）。</li><li>使用 <code>fork()</code> 创建两个子进程。</li><li>子进程 A：将 <code>stdout</code> 重定向到管道的写端（<code>dup2(pipefd[1], STDOUT_FILENO)</code>）。</li><li>子进程 B：将 <code>stdin</code> 重定向到管道的读端（<code>dup2(pipefd[0], STDIN_FILENO)</code>）。</li><li>A 执行命令 A，输出写入管道。</li><li>B 执行命令 B，从管道读取数据。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 进程 </tag>
            
            <tag> 管道 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>030 进程间通信前言</title>
      <link href="/posts/13919.html"/>
      <url>/posts/13919.html</url>
      
        <content type="html"><![CDATA[<h2 id="进程间通信前言"><a href="#进程间通信前言" class="headerlink" title="进程间通信前言"></a>进程间通信前言</h2><h3 id="1-进程间通信的介绍"><a href="#1-进程间通信的介绍" class="headerlink" title="1. 进程间通信的介绍"></a>1. 进程间通信的介绍</h3><h4 id="1-进程间通信的目的"><a href="#1-进程间通信的目的" class="headerlink" title="1. 进程间通信的目的"></a>1. 进程间通信的目的</h4><p><strong>进程通信的核心目的是在多个独立运行的进程之间传递数据、同步执行、共享资源。即实现多个进程在数据层面的交互。</strong></p><p><strong>实际应用需求：</strong></p><ul><li><strong>数据共享：</strong> 多个进程处理同一批数据，共享同样的资源。</li><li><strong>通知事件：</strong> 某一进程完成任务后通知其他进程（如进程终止时要通知父进程）。</li><li><strong>某种协同：</strong> 控制对临界资源的访问，防止竞争。</li><li><strong>服务请求与响应：</strong> 客户端请求服务器、子进程向父进程返回结果。</li><li><strong>进程控制</strong> ：有些进程希望完全控制另一个进程的执行（如 Debug 进程），此时控制进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变。</li></ul><blockquote><p>  [!NOTE]</p><p>  每个进程本质上是一个 <strong>独立的虚拟地址空间</strong>（由 MMU&#x2F;页表保护），天然是“互不相见”的。因为进程独立性的存在，导致进程通信的成本比较高，所以 <strong>通信是有成本的</strong>！想要通信，必须要构造一个 <strong>“公共的资源”</strong>（可访问区域）。这个“资源”谁来提供？—— <strong>操作系统</strong>。</p></blockquote><h4 id="2-“公共资源”为什么不是由一个进程来提供？"><a href="#2-“公共资源”为什么不是由一个进程来提供？" class="headerlink" title="2. “公共资源”为什么不是由一个进程来提供？"></a>2. “公共资源”为什么不是由一个进程来提供？</h4><p>如果由 <strong>某个进程创建并拥有</strong> 这个资源：</p><ul><li>该资源的生命周期就依附于该进程。一旦这个进程结束，资源销毁，通信失效。</li><li>资源隶属问题，产生资源“纠纷”。</li><li>更重要的是，<strong>破坏了进程之间的隔离性</strong>，打破了操作系统“沙盒式”的管理理念。</li></ul><p>所以：必须由 <strong>操作系统</strong> 来作为中立方、统一提供这类通信资源。</p><h4 id="3-如何访问这个共享资源-——-通过系统调用接口"><a href="#3-如何访问这个共享资源-——-通过系统调用接口" class="headerlink" title="3. 如何访问这个共享资源 —— 通过系统调用接口"></a>3. 如何访问这个共享资源 —— 通过系统调用接口</h4><p>通信资源的创建&#x2F;访问&#x2F;销毁，<strong>都需要进程向操作系统发出系统调用</strong>。所以：<strong>“进程通信 &#x3D; 通过系统调用访问 OS 提供的共享资源”</strong>。</p><h4 id="4-操作系统是如何组织这些通信资源的-——-先描述，再组织"><a href="#4-操作系统是如何组织这些通信资源的-——-先描述，再组织" class="headerlink" title="4. 操作系统是如何组织这些通信资源的 —— 先描述，再组织"></a>4. 操作系统是如何组织这些通信资源的 —— 先描述，再组织</h4><p>操作系统内部有专门的“<strong>进程通信模块</strong>”，有些还隶属于“<strong>文件系统子系统</strong>”。</p><h4 id="5-为什么和文件系统有关？"><a href="#5-为什么和文件系统有关？" class="headerlink" title="5. 为什么和文件系统有关？"></a>5. 为什么和文件系统有关？</h4><p>很多通信机制是 <strong>“文件化”处理的</strong>，所以，在 Linux 哲学里，<strong>“一切皆文件”</strong>，通信资源被抽象为“特殊文件”来管理。</p><hr><h3 id="2-接口标准：System-V-vs-POSIX"><a href="#2-接口标准：System-V-vs-POSIX" class="headerlink" title="2. 接口标准：System V vs POSIX"></a>2. 接口标准：System V vs POSIX</h3><table><thead><tr><th>标准类型</th><th>出现时间</th><th>通信接口风格</th><th>特点</th></tr></thead><tbody><tr><td>System V</td><td>较早</td><td>结构化复杂</td><td>功能强，兼容性差，接口繁琐</td></tr><tr><td>POSIX</td><td>后来</td><td>简洁、现代</td><td>更现代、跨平台、统一接口规范</td></tr></tbody></table><hr><h3 id="3-基于文件系统的通信方式：管道（Pipe）"><a href="#3-基于文件系统的通信方式：管道（Pipe）" class="headerlink" title="3. 基于文件系统的通信方式：管道（Pipe）"></a>3. 基于文件系统的通信方式：管道（Pipe）</h3><p>最早的 IPC 方式，基于 <strong>文件读写模型</strong> 构建：</p><ul><li><strong>无名管道</strong>（pipe）：父子进程间通信，内核缓冲区。</li><li><strong>有名管道</strong>（FIFO）：通过路径文件节点访问，允许无关进程通信。</li></ul><h3 id="4-现代进程间通信方式总览"><a href="#4-现代进程间通信方式总览" class="headerlink" title="4. 现代进程间通信方式总览"></a>4. 现代进程间通信方式总览</h3><table><thead><tr><th>类型</th><th>是否主流</th><th align="center">是否跨主机</th><th>传输方式</th><th>使用场景</th></tr></thead><tbody><tr><td>1. <strong>共享内存（+锁）</strong></td><td>✅ 高性能主流</td><td align="center">❌</td><td>内存映射 + 同步机制</td><td>高性能缓存、图像处理、数据库内核</td></tr><tr><td>2. <strong>管道（pipe &#x2F; FIFO）</strong></td><td>❌ 较老</td><td align="center">❌</td><td>内核缓冲区</td><td>父子进程，命令行通信</td></tr><tr><td>3. <strong>消息队列（mq）</strong></td><td>☑️ 中等主流</td><td align="center">❌</td><td>内核消息缓冲</td><td>日志、异步任务、模块解耦</td></tr><tr><td>4. <strong>Socket &#x2F; Unix Socket</strong></td><td>✅ 主流</td><td align="center">✅</td><td>网络&#x2F;本地</td><td>客户端-服务端架构、微服务</td></tr><tr><td>5. <strong>gRPC &#x2F; Thrift &#x2F; HTTP RPC</strong></td><td>✅ 主流</td><td align="center">✅</td><td>网络封装</td><td>微服务通信、分布式服务调用</td></tr><tr><td>6. <strong>ZeroMQ &#x2F; nanomsg &#x2F; Redis PubSub</strong></td><td>☑️ 高级封装</td><td align="center">✅</td><td>用户态&#x2F;网络</td><td>分布式流式通信，轻量消息传输</td></tr><tr><td>7. <strong>DBus &#x2F; Binder &#x2F; XPC</strong></td><td>特殊平台</td><td align="center">❌</td><td>内核&#x2F;对象封装</td><td>桌面系统、移动系统（Android）</td></tr></tbody></table><p><strong>后续的文章则主要涉及下面的内容：</strong></p><table><thead><tr><th>类别</th><th>技术</th><th>说明</th></tr></thead><tbody><tr><td>基础</td><td><strong>管道（Pipe）</strong></td><td>本地进程间通信的经典方式，所有 IPC 的入门基础，Shell 编程中广泛使用</td></tr><tr><td></td><td><strong>System V 共享内存</strong></td><td>高性能场景常用，适用于高速数据通信，常用于数据库、服务与内核之间</td></tr><tr><td>进阶</td><td><strong>信号量（System V &#x2F; POSIX）</strong></td><td>用于同步共享内存访问，避免多进程并发导致的数据竞争与混乱</td></tr><tr><td></td><td><strong>POSIX 共享内存 &#x2F; 互斥量</strong></td><td>更现代的共享内存机制，支持线程同步，跨平台性好，新项目使用</td></tr></tbody></table><h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h3><blockquote><p>  <strong>进程通信的本质</strong> 是：通过 <strong>系统调用访问操作系统提供的共享通信资源</strong>（通常是一段特殊的内存空间），这个资源是 <strong>由内核统一管理</strong>，而不是某个进程私有，从而实现了进程之间的协作、数据交换与资源共享。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 进程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>029 VS Code 连接 Linux 服务器全流程解析</title>
      <link href="/posts/62793.html"/>
      <url>/posts/62793.html</url>
      
        <content type="html"><![CDATA[<h2 id="VS-Code-连接-Linux-服务器全流程解析"><a href="#VS-Code-连接-Linux-服务器全流程解析" class="headerlink" title="VS Code 连接 Linux 服务器全流程解析"></a>VS Code 连接 Linux 服务器全流程解析</h2><p>关于 VS Code 最基本的使用这里就不过多赘述了，因为我这里之前已经装好配置过 VS Code 了，下面开始介绍如何使用 VS Code 连接远端主机进行开发：</p><h3 id="1-使用-VS-Code-连接远端主机"><a href="#1-使用-VS-Code-连接远端主机" class="headerlink" title="1. 使用 VS Code 连接远端主机"></a>1. 使用 VS Code 连接远端主机</h3><ol><li><strong>首先在 Windows 下打开我们的 VS Code，找到扩展，下载插件 Remote - SSH。</strong></li></ol><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250616151940138.png" alt="image-20250616151932972"></p><ol start="2"><li><strong>下载完成后，添加远端主机：</strong> 摁下键盘的 F1 键，输入 <strong>Remote-SSH: Open SSH Host</strong> 的字样，在下方找到添加新的主机。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250616153859339.png" alt="image-20250616153859221"></p><ol start="3"><li><strong>进行登录：基本格式是 ssh root@……（ssh + 空格 + root@ + 自己的公网 IP）</strong>，就是当初在 Xshell 中进行登录一样。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250616154328277.png" alt="image-20250616154328211"></p><ol start="4"><li><strong>本地记录：</strong> VS Code 会提示将在本地将远端的用户名和密码记录下来。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250616154807114.png" alt="image-20250616154807044"></p><p><strong>如何找到这个所谓的 config 文件？</strong><br>我们的刚刚进行的本地记录文件（config）可以从 C 盘 的用户目录下的 .ssh\config 中找到，用记事本打开该文件，就是本地对远端主机的配置信息。</p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250616160559033.png" alt="image-20250616160558948"></p><ol start="5"><li><strong>连接远端主机：</strong> 选中左边窗口栏的 <strong>远程资源管理器</strong> 下的 SSH 目录，鼠标右键你的公网 ip 文件，任选一个连接方式。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250616155825266.png" alt="image-20250616155825161"></p><p>选择正确的平台、继续和输入正确的密码。</p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250616160042163.png" alt="image-20250616160042098"></p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250616160327321.png" alt="image-20250616160327259"></p><h3 id="2-连接出错，如何解决？（官方说明）"><a href="#2-连接出错，如何解决？（官方说明）" class="headerlink" title="2. 连接出错，如何解决？（官方说明）"></a>2. 连接出错，如何解决？（<a href="https://code.visualstudio.com/docs/remote/linux#_remote-host-container-wsl-linux-prerequisites">官方说明</a>）</h3><h4 id="1-在设置中正确配置-Config-File-的文件路径（可解决-70-以上的问题）"><a href="#1-在设置中正确配置-Config-File-的文件路径（可解决-70-以上的问题）" class="headerlink" title="1. 在设置中正确配置 Config File 的文件路径（可解决 70%以上的问题）"></a>1. 在设置中正确配置 Config File 的文件路径（可解决 70%以上的问题）</h4><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250616161602594.png" alt="image-20250616161602490"></p><h4 id="2-选用较低版本的-VS-Code（可解决-90-以上的问题，也是最推荐的方案！）"><a href="#2-选用较低版本的-VS-Code（可解决-90-以上的问题，也是最推荐的方案！）" class="headerlink" title="2. 选用较低版本的 VS Code（可解决 90%以上的问题，也是最推荐的方案！）"></a>2. 选用较低版本的 VS Code（可解决 90%以上的问题，也是最推荐的方案！）</h4><p>像我一样出现下面的情况呢，就是 VS Code 版本太高了，建议再安装一个 <strong>1.85.1 版本的 VS Code</strong> ，虽然心里有那么一丁点膈应，但总比连不上好吧。</p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250616193723857.png" alt="image-20250616193723775"></p><h4 id="3-提升远程主机-glibc-和-libstdc-的最低版本要求（不推荐）"><a href="#3-提升远程主机-glibc-和-libstdc-的最低版本要求（不推荐）" class="headerlink" title="3. 提升远程主机 glibc 和 libstdc++ 的最低版本要求（不推荐）"></a>3. 提升远程主机 <code>glibc</code> 和 <code>libstdc++</code> 的最低版本要求（不推荐）</h4><p>仍然使用 Xshell 分别执行下面的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ldd --version<span class="comment"># 检查 glibc 版本</span></span><br><span class="line">strings /usr/lib*/libstdc++.so.6 | grep <span class="string">&#x27;GLIBCXX&#x27;</span><span class="comment"># 检查 libstdc++ 支持的版本</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>检查项</th><th>VS Code Server 最低要求</th></tr></thead><tbody><tr><td><code>glibc</code> 版本</td><td>最低要求：2.17</td></tr><tr><td><code>libstdc++</code> 版本</td><td>最低推荐：GLIBCXX_3.4.21 或更高</td></tr></tbody></table><h5 id="1-使用新版系统"><a href="#1-使用新版系统" class="headerlink" title="1. 使用新版系统"></a>1. 使用新版系统</h5><p><strong>更换远程主机操作系统</strong>，使用如下之一：</p><ul><li><strong>Ubuntu 20.04 &#x2F; 22.04</strong></li><li><strong>Debian 10+</strong></li><li><strong>CentOS 8 &#x2F; Rocky Linux &#x2F; AlmaLinux</strong></li></ul><p>这些系统默认自带的 <code>glibc</code> 和 <code>libstdc++</code> 都足够新，兼容 VS Code 的 Remote Server。</p><blockquote><p>  ✅ 优点：一劳永逸，安全稳定<br>   ❌ 缺点：需要权限换服务器</p></blockquote><h5 id="2-手动安装新版本-libstdc-（中高级方案）"><a href="#2-手动安装新版本-libstdc-（中高级方案）" class="headerlink" title="2. 手动安装新版本 libstdc++（中高级方案）"></a>2. 手动安装新版本 libstdc++（中高级方案）</h5><p>如果不能更换系统，可以考虑以下方式 <strong>在本地目录下构建较新版本的 <code>libstdc++</code> 并覆盖 VS Code Server 加载路径</strong>：</p><p><strong>步骤简述：</strong></p><ol><li>下载新版本的 gcc 源码（例如 9.3.0）。</li><li>只编译 <code>libstdc++</code> 子模块。</li><li>安装到用户目录下，比如 <code>~/custom_libs/libstdc++</code>。</li><li>在 VS Code SSH 配置中强制加上：<code>export LD_LIBRARY_PATH=~/custom_libs/libstdc++:$LD_LIBRARY_PATH</code>。</li></ol><h5 id="3-手动安装兼容的-glibc-和-libstdc-（仅限高阶用户）"><a href="#3-手动安装兼容的-glibc-和-libstdc-（仅限高阶用户）" class="headerlink" title="3. 手动安装兼容的 glibc 和 libstdc++（仅限高阶用户）"></a>3. 手动安装兼容的 <code>glibc</code> 和 <code>libstdc++</code>（仅限高阶用户）</h5><p>如果你不能升级系统，只能尝试 <strong>在用户目录编译或下载新版 <code>glibc</code> 和 <code>libstdc++</code> 并配置 <code>LD_LIBRARY_PATH</code></strong>，但这个过程非常复杂，容易出错，不推荐初学者操作。</p><h3 id="3-使用-VS-Code-连接主机开始开发"><a href="#3-使用-VS-Code-连接主机开始开发" class="headerlink" title="3. 使用 VS Code 连接主机开始开发"></a>3. 使用 VS Code 连接主机开始开发</h3><p>当我们连接上远端服务器后就可以打开文件开始像在 Xshell 中一样进行使用了，但是还有一点需要注意：<strong>我们使用 VS Code 进行远程连接时，最好只打开一个文件夹，且是包含文件较少的文件夹，最好不要直接打开最根目录的文件夹，因为使用 VS Code 远程连接本来就耗资源，加上自己的服务器主机是 2 核 2GB 的，当同步文件过多&#x2F;过大时很容易卡死！如果服务器配置很高，就可以稍微肆意一点啦~</strong></p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250616185910346.png" alt="image-20250616185910223"></p><p>当我们打开文件夹以后，还需要再一次输入密码，之前输入密码是登录，这一次的密码用于同步文件，这里就不演示了。</p><h4 id="1-插件篇"><a href="#1-插件篇" class="headerlink" title="1. 插件篇"></a>1. 插件篇</h4><p>连上主机后来写代码其实是不太顺手的，所以，我们还需要装一些插件用于代码高亮、提示等。注意一定要连接上主机后再下载自己想要的插件，这样才不是装到了自己 Windows 的本地（当然极少部分插件也只能安装在本地）！下面展示我的一些基本使用的插件，算是大道至简了，更多插件请自行探索。</p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250616193356180.png" alt="image-20250616193356071"></p><p>此时，在 Xshell 中执行 <code>ls ~/ -al</code> 就会发现存在一个 <code>.vscode-server</code> 文件夹，它用于存放 <strong>VS Code Remote Server 在远程主机上的运行环境和相关组件</strong>。我们安装的远程插件就在这里，其还存在 VS Code 远程服务端核心二进制及其环境相关设置等，如果更换了服务器或清理 <code>.vscode-server</code>，就需要重新连接远程主机，VS Code 会：</p><ul><li>自动重新下载 Remote Server 二进制。</li><li>自动安装必要插件。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250616193955233.png" alt="image-20250616193955150"></p><h4 id="2-开发篇"><a href="#2-开发篇" class="headerlink" title="2. 开发篇"></a>2. 开发篇</h4><p>首先确认自己的主机上是否存在 GNU C++ 编译器，大部分机器都存在 GCC ，但不一定都存在 G++，像我的机器上就没有，所以需要进行安装一下，使用下面的命令进行 G++ 的安装（任选其一）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> yum install gcc-c++</span><br><span class="line"><span class="built_in">sudo</span> yum install -y gcc-c++<span class="comment"># 自动确认安装，避免手动输入 y</span></span><br></pre></td></tr></table></figure><p><code>gcc-c++</code> 是包含 <code>g++</code> 编译器的软件包。安装完成后，就可以使用 <code>g++</code> 来编译 C++ 程序了。使用命令 <code>g++ -v</code> 或者 <code>g++ --version</code> 验证是否安装成功，出现版本号等信息代表安装成功。</p><p><strong>附加推荐：安装常用开发工具组（可选）</strong></p><p>如果想使用更多开发工具（如 <code>make</code>、调试器 <code>gdb</code> 等），可以一并安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> yum groupinstall -y <span class="string">&quot;Development Tools&quot;</span></span><br></pre></td></tr></table></figure><p>这个命令会自动安装一组软件包，非常适合服务器开发者使用。</p><h4 id="3-实战篇"><a href="#3-实战篇" class="headerlink" title="3. 实战篇"></a>3. 实战篇</h4><p>下面的操作其实和在 Xshell 中操作区别不大，优点是使用 VS Code 代替了 Vim，下面简单演示一下基本使用：</p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250616203720922.png" alt="image-20250616203720810"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> VS Code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 的使用</title>
      <link href="/posts/3572.html"/>
      <url>/posts/3572.html</url>
      
        <content type="html"><![CDATA[<h1 id="Git-的使用"><a href="#Git-的使用" class="headerlink" title="Git 的使用"></a>Git 的使用</h1><h2 id="1-Git-版本迭代"><a href="#1-Git-版本迭代" class="headerlink" title="1. Git 版本迭代"></a>1. Git 版本迭代</h2><h3 id="1-查看-Git-版本"><a href="#1-查看-Git-版本" class="headerlink" title="1. 查看 Git 版本"></a>1. 查看 Git 版本</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git --version   <span class="comment"># 查看当前安装的 Git 版本号</span></span><br></pre></td></tr></table></figure><h3 id="2-Windows-系统更新-Git"><a href="#2-Windows-系统更新-Git" class="headerlink" title="2. Windows 系统更新 Git"></a>2. Windows 系统更新 Git</h3><ol><li>访问 <a href="https://gitforwindows.org/">Git for Windows</a>，下载最新版安装程序。</li><li>运行安装程序，如果存在旧版本会直接覆盖升级成新版本。</li><li>安装完成后，再次执行 <code>git --version</code> 验证。</li></ol><hr><h2 id="2-Git-仓库的基本使用"><a href="#2-Git-仓库的基本使用" class="headerlink" title="2. Git 仓库的基本使用"></a>2. Git 仓库的基本使用</h2><h3 id="1-新建仓库"><a href="#1-新建仓库" class="headerlink" title="1. 新建仓库"></a>1. 新建仓库</h3><ol><li>去 GitHub&#x2F;Gitee 网页端，点击新建仓库，填写仓库名、介绍等信息。</li><li>可选择开源或私有，是否初始化 README、License、<code>.gitignore</code> 等，按需配置。</li></ol><h3 id="2-初始化-Git-仓库（本地仓库）"><a href="#2-初始化-Git-仓库（本地仓库）" class="headerlink" title="2. 初始化 Git 仓库（本地仓库）"></a>2. 初始化 Git 仓库（本地仓库）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init   <span class="comment"># 在本地初始化一个空仓库（会生成隐藏的 .git 文件夹）</span></span><br></pre></td></tr></table></figure><h3 id="3-关联远程仓库"><a href="#3-关联远程仓库" class="headerlink" title="3. 关联远程仓库"></a>3. 关联远程仓库</h3><p>添加 GitHub 或者 Gitee 仓库作为远程地址（默认命名为 <code>origin</code>）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin 仓库链接   <span class="comment"># 把远程仓库链接绑到本地，默认叫 origin</span></span><br><span class="line">git remote -v                   <span class="comment"># 查看远程仓库信息，验证是否添加成功，确认绑对了</span></span><br></pre></td></tr></table></figure><h3 id="4-添加文件到暂存区"><a href="#4-添加文件到暂存区" class="headerlink" title="4. 添加文件到暂存区"></a>4. 添加文件到暂存区</h3><p>要让 Git 记录文件的改动（ <strong>要提交的文件或者修改后的文件</strong>），得先加到暂存区，可以通过以下命令进行：</p><ul><li><p>添加单个文件：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add 文件名称</span><br><span class="line"><span class="comment"># 例如：git add helloWord.cpp</span></span><br></pre></td></tr></table></figure></li><li><p>添加多个文件（空格分隔）：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add 文件1 文件2  <span class="comment"># 加多个文件，空格分开</span></span><br><span class="line"><span class="comment"># 例如：git add file1.txt file2.txt</span></span><br></pre></td></tr></table></figure></li><li><p>添加所有文件：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add .<span class="comment"># 使用 . 可以一次性将所有已修改的文件添加到暂存区。</span></span><br></pre></td></tr></table></figure></li><li><p>提交某个目录下的所有文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add 文件夹/  <span class="comment"># 加某个文件夹里的所有文件</span></span><br><span class="line">git add subfolder/<span class="comment"># subfolder 是子文件夹</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="5-提交更改"><a href="#5-提交更改" class="headerlink" title="5. 提交更改"></a>5. 提交更改</h3><p>提交暂存区的改动，并为这次提交写一条描述信息（写清楚改了啥）。每次提交都会生成一个唯一的提交 ID（hash），并记录下本次提交的描述信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">&quot;这里写说明，比如：修复登录按钮bug&quot;</span><span class="comment"># 你本次提交的说明信息</span></span><br></pre></td></tr></table></figure><h3 id="6-推送到远程仓库"><a href="#6-推送到远程仓库" class="headerlink" title="6. 推送到远程仓库"></a>6. 推送到远程仓库</h3><p>推送代码到远程分支（如 <code>main</code> 或 <code>master</code>）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -u origin main            <span class="comment"># 推到远程的 main 分支（首次推送需加 -u，-u 是绑定分支，下次不用写）</span></span><br></pre></td></tr></table></figure><p>后续推送只需：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push</span><br></pre></td></tr></table></figure><hr><h2 id="3-配置问题"><a href="#3-配置问题" class="headerlink" title="3. 配置问题"></a>3. 配置问题</h2><h3 id="1-让-Git-正确显示中文文件名（支持-UTF-8-）"><a href="#1-让-Git-正确显示中文文件名（支持-UTF-8-）" class="headerlink" title="1. 让 Git 正确显示中文文件名（支持 UTF-8 ）"></a>1. 让 Git 正确显示中文文件名（支持 UTF-8 ）</h3><p>Windows Git 默认可能会的不正确显示中文，比如把中文文件名显示成 <code>\345\210\233\……</code>（一堆数字），运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global core.quotePath <span class="literal">false</span><span class="comment"># 让 Git 正确显示 UTF-8 文件名</span></span><br></pre></td></tr></table></figure><h3 id="2-创建新仓库时设置默认分支"><a href="#2-创建新仓库时设置默认分支" class="headerlink" title="2. 创建新仓库时设置默认分支"></a>2. 创建新仓库时设置默认分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global init.defaultBranch main  <span class="comment"># 全局设置默认分支为 main</span></span><br><span class="line">git init    <span class="comment"># 新建仓库时就会用 main 分支</span></span><br></pre></td></tr></table></figure><p>验证是否设置成功：</p><ol><li><p>方法 1：直接查看全局配置（最直接）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global --get init.defaultBranch<span class="comment"># 查看全局配置中默认分支的具体值，输出 main 则成功</span></span><br></pre></td></tr></table></figure></li><li><p>方法 2：查看完整全局配置文件（适合确认配置是否存在）</p><ul><li><p>Windows 系统：</p><ol><li><p>打开文件管理器，在地址栏输入 <code>%USERPROFILE%</code> 并回车（快速进入用户目录，比如 <code>C:\Users\你的用户名</code>）；</p></li><li><p>找到并打开 <code>.gitconfig</code> 文件（文本文件，可用记事本&#x2F;VS Code 打开）；</p></li><li><p>查看文件内容，是否有以下内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[init]</span><br><span class="line">    defaultBranch = main</span><br></pre></td></tr></table></figure></li></ol></li><li><p>Mac&#x2F;Linux 系统：</p><ol><li><p>打开终端，执行命令查看配置文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> ~/.gitconfig</span><br></pre></td></tr></table></figure></li><li><p>查看输出内容，是否包含上述 <code>[init]</code> 段落。</p></li></ol></li></ul></li><li><p>方法 3：新建仓库测试（最能验证实际效果）：<code>git init</code> 初始化一个仓库并 <code>git branch</code> 查看当前分支。</p></li></ol><h3 id="3-将现有仓库从-master-切换到-main"><a href="#3-将现有仓库从-master-切换到-main" class="headerlink" title="3. 将现有仓库从 master 切换到 main"></a>3. 将现有仓库从 master 切换到 main</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git branch -m master main  <span class="comment"># 本地改名为 main</span></span><br><span class="line">git push -u origin main  <span class="comment"># 推到远程</span></span><br><span class="line">git push origin --delete master  <span class="comment"># 删除远程的 master（谨慎！）</span></span><br><span class="line"><span class="comment"># 最后去 GitHub/Gitee 网页端，把默认分支设为 main</span></span><br></pre></td></tr></table></figure><h2 id="4-gitignore-——-忽略不想提交的文件"><a href="#4-gitignore-——-忽略不想提交的文件" class="headerlink" title="4. .gitignore —— 忽略不想提交的文件"></a>4. <code>.gitignore</code> —— 忽略不想提交的文件</h2><p><code>.gitignore</code> 文件的作用是：只要在 <code>.gitignore</code> 文件中存在的文件都选择忽略，即将文件写入 <code>.gitignore</code> 就不会让 Git 管。</p><h3 id="1-基本规则"><a href="#1-基本规则" class="headerlink" title="1. 基本规则"></a>1. 基本规则</h3><table><thead><tr><th>符号</th><th>意思</th><th>例子</th></tr></thead><tbody><tr><td><code>#</code></td><td>注释</td><td><code># 这行是注释</code></td></tr><tr><td><code>*</code></td><td>匹配多个字符</td><td><code>*.log</code> 忽略所有.log 文件</td></tr><tr><td><code>?</code></td><td>匹配单个字符</td><td><code>file?.txt</code> 匹配 file1.txt</td></tr><tr><td><code>/</code></td><td>只忽略根目录下的文件 &#x2F; 夹</td><td><code>/build/</code> 只忽略根目录的 build</td></tr><tr><td><code>!</code></td><td>不忽略这个文件</td><td><code>!important.log</code> 保留这个文件</td></tr></tbody></table><h3 id="2-已上传的文件想忽略"><a href="#2-已上传的文件想忽略" class="headerlink" title="2. 已上传的文件想忽略"></a>2. 已上传的文件想忽略</h3><p>如果文件已经被 Git 跟踪了，.gitignore 没用，得先移除跟踪：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">rm</span> --cached 文件名  <span class="comment"># 移除单个文件的跟踪（本地文件保留）</span></span><br><span class="line">git <span class="built_in">rm</span> -r --cached 文件夹/  <span class="comment"># 移除整个文件夹的跟踪</span></span><br><span class="line">git commit -m <span class="string">&quot;不再跟踪这个文件/夹&quot;</span>  <span class="comment"># 提交这个改动</span></span><br></pre></td></tr></table></figure><hr><h2 id="5-常用场景命令"><a href="#5-常用场景命令" class="headerlink" title="5. 常用场景命令"></a>5. 常用场景命令</h2><table><thead><tr><th>场景</th><th>命令示例</th></tr></thead><tbody><tr><td><strong>提交并推送</strong></td><td><code>git add .</code> → <code>git commit -m &quot;xxx&quot;</code> → <code>git push</code></td></tr><tr><td><strong>新分支开发</strong></td><td><code>git checkout -b 分支名</code> → 改代码 → <code>git add .</code> → <code>git commit -m &quot;说明&quot;</code> → <code>git push origin 分支名</code></td></tr><tr><td><strong>撤销暂存区文件</strong></td><td><code>git reset 文件名</code></td></tr><tr><td><strong>撤销最近一次提交</strong></td><td><code>git reset --soft HEAD^</code></td></tr><tr><td><strong>撤销已推送的提交</strong></td><td><code>git revert 提交ID</code></td></tr><tr><td><strong>强制推送（慎用）</strong></td><td><code>git push origin 分支名 --force</code></td></tr></tbody></table><hr><h2 id="6-git-目录清理与性能优化指南"><a href="#6-git-目录清理与性能优化指南" class="headerlink" title="6. .git 目录清理与性能优化指南"></a>6. <code>.git</code> 目录清理与性能优化指南</h2><h3 id="1-git-目录的结构与作用"><a href="#1-git-目录的结构与作用" class="headerlink" title="1. .git 目录的结构与作用"></a>1. <code>.git</code> 目录的结构与作用</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">核心文件/目录：</span><br><span class="line">├── objects/   <span class="comment"># 存储所有 Git 对象（提交、文件快照等）</span></span><br><span class="line">├── refs/      <span class="comment"># 存储分支、标签指针</span></span><br><span class="line">├── HEAD       <span class="comment"># 当前分支指向</span></span><br><span class="line">├── config     <span class="comment"># 仓库专属配置</span></span><br><span class="line">├── index      <span class="comment"># 暂存区信息</span></span><br><span class="line">└── hooks/     <span class="comment"># Git 操作触发的脚本</span></span><br></pre></td></tr></table></figure><h3 id="2-常用清理命令"><a href="#2-常用清理命令" class="headerlink" title="2. 常用清理命令"></a>2. 常用清理命令</h3><table><thead><tr><th>命令</th><th>作用</th><th>风险</th></tr></thead><tbody><tr><td><code>git gc --prune=now</code></td><td>清理无用文件&#x2F;松散对象</td><td>低</td></tr><tr><td><code>git repack -ad</code></td><td>重新打包文件，减少碎片</td><td>中</td></tr><tr><td><code>git clean -dfx</code></td><td>删除没有跟踪的文件 &#x2F; 夹（<strong>慎用！</strong>）</td><td>高</td></tr></tbody></table><hr><h2 id="7-绿点计算规则"><a href="#7-绿点计算规则" class="headerlink" title="7. 绿点计算规则"></a>7. 绿点计算规则</h2><ul><li><p><strong>统计依据</strong>：提交次数而非提交文件数。</p></li><li><p><strong>有效条件</strong>：</p><ul><li>绑定的邮箱需与账号一致。</li><li>提交需合并到默认分支（如 <code>main</code>）。</li></ul></li><li><p><strong>导入仓库不算贡献</strong>，除非产生新提交。</p></li></ul><hr><p><strong>为何一次提交多个文件只算 1 个绿点？</strong></p><p><strong>提交次数决定绿点</strong>：无论一次提交包含多少文件修改，均视为 <strong>1 次提交</strong>。例如：</p><ul><li>修改 10 个文件后执行 <code>git commit -m &quot;update&quot;</code> → 计为 1 次贡献。</li><li>分 3 次提交（每次修改不同文件）→ 计为 3 次贡献。</li></ul><hr><p><strong>导入仓库是否算绿点？</strong></p><ul><li><strong>GitHub&#x2F;Gitee 导入功能</strong>：直接通过平台的「导入仓库」功能迁移代码（如 GitHub 导入到 Gitee），<strong>不会生成绿点</strong>，因为无新提交记录。</li><li><strong>手动克隆后提交</strong>：若导入后手动提交新代码（如修复冲突或更新内容），<strong>会计入绿点</strong>。</li></ul><blockquote><p>但实际就我测试来看，将 Gitee 仓库导入 GitHub 会计算绿点，但是 GitHub 仓库导入 Gitee 却不会计算绿点。</p></blockquote><hr><h2 id="8-选择合适的许可证"><a href="#8-选择合适的许可证" class="headerlink" title="8. 选择合适的许可证"></a>8. 选择合适的许可证</h2><p>首先，你需要确定适合你项目的许可证类型。GitHub 提供了一个 <a href="https://choosealicense.com/">许可证选择器</a>，可以帮助你根据项目的需求和目标选择合适的许可证。常见的许可证包括 MIT、Apache 2.0、GPL 等。</p><h3 id="1-添加许可证文件"><a href="#1-添加许可证文件" class="headerlink" title="1. 添加许可证文件"></a>1. 添加许可证文件</h3><h4 id="方法一：使用-GitHub-网页界面"><a href="#方法一：使用-GitHub-网页界面" class="headerlink" title="方法一：使用 GitHub 网页界面"></a>方法一：使用 GitHub 网页界面</h4><ol><li><strong>访问仓库</strong>：在 GitHub 上打开你的仓库页面。</li><li><strong>创建新文件</strong>：点击页面上的 “Add file” 按钮，然后选择 “Create new file”。</li><li><strong>命名许可证文件</strong>：在文件名输入框中，输入 <code>LICENSE.md</code>。</li><li><strong>选择许可证模板</strong>：在文件编辑区域，GitHub 会提示你选择一个许可证模板。点击 “Choose a license template” 链接，然后从可用的许可证列表中选择你之前确定的许可证类型。</li><li><strong>提交许可证文件</strong>：选择许可证后，GitHub 会自动填充许可证内容。你可以根据需要进行任何修改，然后滚动到页面底部，填写提交信息（如 “Add MIT License”），并点击 “Commit new file” 按钮提交许可证文件。</li></ol><h4 id="方法二：使用本地-Git-命令行"><a href="#方法二：使用本地-Git-命令行" class="headerlink" title="方法二：使用本地 Git 命令行"></a>方法二：使用本地 Git 命令行</h4><ol><li><p><strong>克隆仓库</strong>：如果你还没有在本地克隆仓库，请先执行以下命令：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> 仓库链接</span><br></pre></td></tr></table></figure></li><li><p><strong>创建许可证文件</strong>：在本地仓库的根目录下，创建一个名为 <code>LICENSE.md</code> 的文件。</p></li><li><p><strong>编辑许可证内容</strong>：使用文本编辑器打开许可证文件，并将你选择的许可证文本粘贴进去。你可以从 <a href="https://choosealicense.com/">许可证选择器</a> 网站复制许可证文本。</p></li><li><p><strong>提交并推送</strong>：使用 Git 提交许可证文件，并将其推送到 GitHub 仓库。</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add LICENSE.md</span><br><span class="line">git commit -m <span class="string">&quot;Add MIT License&quot;</span></span><br><span class="line">git push origin main</span><br></pre></td></tr></table></figure></li></ol><h3 id="2-验证许可证添加成功"><a href="#2-验证许可证添加成功" class="headerlink" title="2. 验证许可证添加成功"></a>2. 验证许可证添加成功</h3><p>添加许可证文件后，你可以在仓库页面的 “Code” 选项卡下看到新的 <code>LICENSE</code> 文件。此外，GitHub 会在仓库页面的右上角显示许可证类型，并提供一个链接，方便访问者查看完整的许可证内容。</p><h3 id="3-示例：添加-MIT-许可证"><a href="#3-示例：添加-MIT-许可证" class="headerlink" title="3. 示例：添加 MIT 许可证"></a>3. 示例：添加 MIT 许可证</h3><p>以下是 MIT 许可证的示例内容，你可以将其复制到你的 <code>LICENSE</code> 文件中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">MIT License</span><br><span class="line"></span><br><span class="line">Copyright (c) [year] [fullname]</span><br><span class="line"></span><br><span class="line">Permission is hereby granted, free of charge, to any person obtaining a copy</span><br><span class="line">of this software and associated documentation files (the &quot;Software&quot;), to deal</span><br><span class="line">in the Software without restriction, including without limitation the rights</span><br><span class="line">to use, copy, modify, merge, publish, distribute, sublicense, and/or sell</span><br><span class="line">copies of the Software, and to permit persons to whom the Software is</span><br><span class="line">furnished to do so, subject to the following conditions:</span><br><span class="line"></span><br><span class="line">The above copyright notice and this permission notice shall be included in all</span><br><span class="line">copies or substantial portions of the Software.</span><br><span class="line"></span><br><span class="line">THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</span><br><span class="line">IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,</span><br><span class="line">FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE</span><br><span class="line">AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER</span><br><span class="line">LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,</span><br><span class="line">OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE</span><br><span class="line">SOFTWARE.</span><br></pre></td></tr></table></figure><p>请将 <code>[year]</code> 和 <code>[fullname]</code> 替换为实际的年份和你的全名。通过以上步骤，你可以为你的 GitHub 仓库添加适当的许可证，明确项目的法律条款和使用条件。</p><h2 id="9-Git-LFS（大文件存储）"><a href="#9-Git-LFS（大文件存储）" class="headerlink" title="9. Git LFS（大文件存储）"></a>9. Git LFS（大文件存储）</h2><h3 id="1-什么是-Git-LFS"><a href="#1-什么是-Git-LFS" class="headerlink" title="1. 什么是 Git LFS"></a>1. 什么是 Git LFS</h3><p>Git LFS (Large File Storage) 是 Git 的一个扩展，用于高效管理大文件（如图片、视频、数据集等）。它将大文件存储在远程服务器上，而 Git 仓库中只保留指向这些文件的指针，如果你的项目里有 <strong>很大的文件</strong>，用普通 Git 会很慢，仓库也会变得巨大。这时就用 Git LFS。</p><h3 id="2-安装-Git-LFS"><a href="#2-安装-Git-LFS" class="headerlink" title="2. 安装 Git LFS"></a>2. 安装 Git LFS</h3><p><strong>Windows:</strong></p><ul><li>通过 Git for Windows 安装（推荐）：下载最新版 <a href="https://gitforwindows.org/">Git for Windows</a>，安装时勾选 “Git LFS” 选项；</li><li>或单独安装：下载 <a href="https://git-lfs.github.com/">Git LFS 安装程序</a></li></ul><h3 id="3-基本使用流程"><a href="#3-基本使用流程" class="headerlink" title="3. 基本使用流程"></a>3. 基本使用流程</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git lfs install             <span class="comment"># 初始化 LFS（在仓库里跑一次）</span></span><br><span class="line">git lfs track <span class="string">&quot;*.psd&quot;</span>   <span class="comment"># 告诉 LFS 跟踪所有.psd 文件（换成你的大文件类型）</span></span><br><span class="line">git lfs track <span class="string">&quot;*.zip&quot;</span>  <span class="comment"># 可以多写几个，跟踪不同类型</span></span><br><span class="line">git add .gitattributes  <span class="comment"># 提交 LFS 的配置文件</span></span><br><span class="line"><span class="comment"># 然后正常加文件、提交、推送</span></span><br><span class="line">git add 大文件.psd</span><br><span class="line">git commit -m <span class="string">&quot;加个大文件&quot;</span></span><br><span class="line">git push origin main</span><br></pre></td></tr></table></figure><h3 id="4-常见问题解决"><a href="#4-常见问题解决" class="headerlink" title="4. 常见问题解决"></a>4. 常见问题解决</h3><ul><li><p><strong>已提交的大文件如何迁移到 LFS？</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git lfs migrate import --include=<span class="string">&quot;*.psd,*.zip&quot;</span> --everything  <span class="comment"># 迁移已提交的大文件</span></span><br><span class="line">git push origin --force --all  <span class="comment"># 强制推送改动（谨慎！）</span></span><br><span class="line">git push origin --force --tags</span><br></pre></td></tr></table></figure></li><li><p><strong>查看 LFS 文件状态</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git lfs ls-files  <span class="comment"># 查看所有 LFS 跟踪的文件</span></span><br></pre></td></tr></table></figure></li><li><p><strong>LFS 存储空间限制</strong></p><ul><li>GitHub 免费用户：每月 500MB（存储 + 带宽合计），但公开仓库的下载带宽免费。</li><li>GitLab 免费用户：每个项目 10GB 存储空间。</li><li>超出后，他人无法下载 LFS 文件，需清理或升级解决。</li></ul></li></ul><h2 id="10-GitHub-语言统计不准确问题及解决方案"><a href="#10-GitHub-语言统计不准确问题及解决方案" class="headerlink" title="10. GitHub 语言统计不准确问题及解决方案"></a>10. GitHub 语言统计不准确问题及解决方案</h2><h3 id="1-为什么-GitHub-语言统计不准确？"><a href="#1-为什么-GitHub-语言统计不准确？" class="headerlink" title="1. 为什么 GitHub 语言统计不准确？"></a>1. 为什么 GitHub 语言统计不准确？</h3><p>GitHub 使用 <a href="https://github.com/github/linguist">linguist 库</a> 分析仓库语言构成，但有时会出现：</p><ul><li>误判第三方库为项目主要语言</li><li>忽略特定语言文件</li><li>无法识别自定义文件扩展名</li></ul><h3 id="2-使用-gitattributes-调整语言统计"><a href="#2-使用-gitattributes-调整语言统计" class="headerlink" title="2. 使用.gitattributes 调整语言统计"></a>2. 使用.gitattributes 调整语言统计</h3><p>在仓库 <strong>根目录</strong> 创建或修改 <code>.gitattributes</code> 文件，写入规则调整统计示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 忽略所有 Markdown 文档文件，不计入语言统计</span><br><span class="line">*.md linguist-detectable=false</span><br><span class="line"></span><br><span class="line"># 忽略所有 jpg 图片文件，不计入语言统计</span><br><span class="line">*.jpg linguist-detectable=false</span><br><span class="line"></span><br><span class="line"># 忽略所有 png 图片文件，不计入语言统计</span><br><span class="line">*.png linguist-detectable=false</span><br><span class="line"></span><br><span class="line"># 忽略所有 Jupyter Notebook 文件，不计入语言统计</span><br><span class="line">*.ipynb linguist-detectable=false</span><br><span class="line"></span><br><span class="line"># 强制将所有 .h 文件识别为 C++ 代码（否则可能被识别为 C）</span><br><span class="line">*.h linguist-language=C++</span><br></pre></td></tr></table></figure><h3 id="3-验证-gitattributes-是否生效"><a href="#3-验证-gitattributes-是否生效" class="headerlink" title="3. 验证.gitattributes 是否生效"></a>3. 验证.gitattributes 是否生效</h3><ol><li>提交并推送 <code>.gitattributes</code> 文件</li><li>等待几分钟&#x2F;几小时让 GitHub 重新计算</li><li>查看仓库语言统计是否更新</li></ol><h2 id="11-分支管理"><a href="#11-分支管理" class="headerlink" title="11. 分支管理"></a>11. 分支管理</h2><h3 id="1-基础操作"><a href="#1-基础操作" class="headerlink" title="1. 基础操作"></a>1. 基础操作</h3><table><thead><tr><th>操作</th><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>看本地分支</td><td><code>git branch</code></td><td>带 <code>*</code> 的是当前分支</td></tr><tr><td>看远程分支</td><td><code>git branch -r</code></td><td>远程分支带 <code>remotes/</code> 前缀</td></tr><tr><td>新建分支</td><td><code>git branch 分支名</code></td><td>基于当前分支新建</td></tr><tr><td>新建并切换到分支</td><td><code>git checkout -b 分支名</code></td><td>一步到位</td></tr><tr><td>切换分支</td><td><code>git checkout 分支名</code> 或 <code>git switch 分支名</code></td><td>换分支</td></tr><tr><td>删除本地分支</td><td><code>git branch -d 分支名</code></td><td>分支合并后才能删</td></tr><tr><td>强制删本地分支</td><td><code>git branch -D 分支名</code></td><td>没合并也能删</td></tr><tr><td>删除远程分支</td><td><code>git push origin --delete 分支名</code></td><td>删了就找不回了，谨慎！</td></tr></tbody></table><h3 id="2-合并分支与解决冲突"><a href="#2-合并分支与解决冲突" class="headerlink" title="2. 合并分支与解决冲突"></a>2. 合并分支与解决冲突</h3><ol><li><p>合并分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout 目标分支  <span class="comment"># 比如要合并到 main，先切到 main</span></span><br><span class="line">git merge 要合并的分支  <span class="comment"># 比如 git merge feature/login</span></span><br></pre></td></tr></table></figure></li><li><p>冲突解决：</p><ul><li>冲突文件里会有 <code>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</code>、<code>=======</code>、<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 分支名</code> 标记。</li><li>打开文件，手动删掉标记，保留需要的内容。</li><li>标记解决：<code>git add 冲突文件</code>。</li><li>完成合并：<code>git commit -m &quot;解决冲突&quot;</code>。</li></ul></li></ol><h2 id="12-标签管理（标记版本，比如-v1-0）"><a href="#12-标签管理（标记版本，比如-v1-0）" class="headerlink" title="12. 标签管理（标记版本，比如 v1.0）"></a>12. 标签管理（标记版本，比如 v1.0）</h2><table><thead><tr><th>操作</th><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>看所有标签</td><td><code>git tag</code></td><td>按字母排序</td></tr><tr><td>建轻量标签</td><td><code>git tag v1.0</code></td><td>只记版本号</td></tr><tr><td>建带说明的标签（推荐）</td><td><code>git tag -a v1.0 -m &quot;第一个正式版&quot;</code></td><td>带创建人、时间和说明</td></tr><tr><td>推单个标签到远程</td><td><code>git push origin v1.0</code></td><td>标签不会自动推，得手动</td></tr><tr><td>推所有标签到远程</td><td><code>git push origin --tags</code></td><td>一次性推所有标签</td></tr><tr><td>删除本地标签</td><td><code>git tag -d v1.0</code></td><td>删本地的</td></tr><tr><td>删除远程标签</td><td><code>git push origin --delete v1.0</code></td><td>先删本地再删远程</td></tr></tbody></table><h2 id="13-拉取远程代码"><a href="#13-拉取远程代码" class="headerlink" title="13. 拉取远程代码"></a>13. 拉取远程代码</h2><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>git fetch</code></td><td>拉远程最新代码到本地，不合并</td></tr><tr><td><code>git pull</code></td><td>拉远程代码并自动合并到当前分支</td></tr><tr><td><code>git pull origin 远程分支名</code></td><td>拉指定远程分支到本地当前分支</td></tr></tbody></table><p>示例：同步远程 main 到本地：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout main  <span class="comment"># 切到本地 main</span></span><br><span class="line">git pull origin main  <span class="comment"># 拉远程 main 并合并</span></span><br></pre></td></tr></table></figure><h2 id="14-暂存工作区（stash，临时存改动）"><a href="#14-暂存工作区（stash，临时存改动）" class="headerlink" title="14. 暂存工作区（stash，临时存改动）"></a>14. 暂存工作区（stash，临时存改动）</h2><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>git stash</code></td><td>暂存当前所有未提交的改动</td></tr><tr><td><code>git stash save &quot;说明&quot;</code></td><td>暂存时加个描述，方便区分</td></tr><tr><td><code>git stash list</code></td><td>看所有暂存记录，格式：stash@{n}: 描述</td></tr><tr><td><code>git stash apply stash@&#123;n&#125;</code></td><td>恢复第 n 个暂存（n 是序号，默认最近的）</td></tr><tr><td><code>git stash pop</code></td><td>恢复最近的暂存，并删掉这条记录</td></tr><tr><td><code>git stash drop stash@&#123;n&#125;</code></td><td>删掉第 n 个暂存</td></tr><tr><td><code>git stash clear</code></td><td>清空所有暂存</td></tr></tbody></table><h2 id="15-查看提交历史（log）"><a href="#15-查看提交历史（log）" class="headerlink" title="15. 查看提交历史（log）"></a>15. 查看提交历史（log）</h2><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>git log</code></td><td>看完整历史（按时间倒序）</td></tr><tr><td><code>git log --oneline</code></td><td>简洁显示：一行一个提交（哈希前 7 位 + 说明）</td></tr><tr><td><code>git log --graph</code></td><td>图形化显示分支合并历史</td></tr><tr><td><code>git log 文件名</code></td><td>只看这个文件的修改历史</td></tr></tbody></table><h2 id="16-协作开发（Pull-Request-流程）"><a href="#16-协作开发（Pull-Request-流程）" class="headerlink" title="16. 协作开发（Pull Request 流程）"></a>16. 协作开发（Pull Request 流程）</h2><ol><li>先在 GitHub 上 “Fork” 目标仓库，复制到自己账号下。</li><li>克隆到本地：<code>git clone 自己的仓库链接</code>。</li><li>新建分支开发：<code>git checkout -b feature/新功能</code>。</li><li>改完后提交推送：<code>git add .</code> → <code>git commit -m &quot;说明&quot;</code> → <code>git push origin feature/新功能</code>。</li><li>在自己仓库页面点 “Compare &amp; pull request”，发起 PR。</li><li>等审核，按反馈改（改完直接 push，PR 会自动更新）。</li><li>审核过了，对方合并到主分支。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数学函数</title>
      <link href="/posts/1171.html"/>
      <url>/posts/1171.html</url>
      
        <content type="html"><![CDATA[<h2 id="数学相关函数"><a href="#数学相关函数" class="headerlink" title="数学相关函数"></a>数学相关函数</h2><blockquote><p><strong>算法数据范围初定：单数据 10 的 9 次方以内无脑用 <code>int</code>，单数据 10 的 18 次方以内无脑 <code>long long</code>，更高的数据量需要考虑 <code>long double</code>（10 的 308 次方左右），但是注意：<code>long double</code> 虽然能表示很大的数，但精度不够稳定，误差较大！对准确性要求极高的场景下，就不太靠谱了。这时就需要考虑高精度算法和计算库了。还有在多数据涉及加法和乘法操作时，注意边界溢出！</strong></p></blockquote><h3 id="1-基本数学函数（）"><a href="#1-基本数学函数（）" class="headerlink" title="1. 基本数学函数（&lt;cmath&gt;）"></a>1. 基本数学函数（<code>&lt;cmath&gt;</code>）</h3><table><thead><tr><th align="left"><strong>功能</strong></th><th><strong>函数原型</strong></th><th><strong>使用示例</strong></th><th><strong>注意事项</strong></th></tr></thead><tbody><tr><td align="left">平方根</td><td><code>double sqrt(double x)</code></td><td><code>sqrt(16.0) = 4.0</code></td><td>参数需非负</td></tr><tr><td align="left">幂运算 (b <sup> e </sup>)</td><td><code>double pow(double b, double e)</code></td><td><code>pow(2.0, 3.0) = 8.0</code></td><td>效率低于位运算</td></tr><tr><td align="left">浮点数绝对值</td><td><code>double abs(double x)</code></td><td><code>abs(-3.14) = 3.14</code></td><td>整数用 <code>&lt;cstdlib&gt;</code> 的 <code>abs()</code></td></tr><tr><td align="left">浮点数绝对值</td><td><code>double fabs(double x)</code></td><td><code>fabs(-2.5) = 2.5</code></td><td>同 <code>abs()</code></td></tr><tr><td align="left">向上取整</td><td><code>double ceil(double x)</code></td><td><code>ceil(2.3) = 3.0</code></td><td></td></tr><tr><td align="left">向下取整</td><td><code>double floor(double x)</code></td><td><code>floor(2.7) = 2.0</code></td><td></td></tr><tr><td align="left">四舍五入</td><td><code>double round(double x)</code></td><td><code>round(2.5) = 3.0</code></td><td>C++11</td></tr><tr><td align="left">浮点数取模</td><td><code>double fmod(double a, double b)</code></td><td><code>fmod(5.5, 2.0) = 1.5</code></td><td>余数 &#x3D; a - b*trunc(a&#x2F;b)</td></tr><tr><td align="left">欧几里得距离 (√(x²+y²))</td><td><code>double hypot(double x, double y)</code></td><td><code>hypot(3,4) = 5.0</code></td><td>避免溢出</td></tr><tr><td align="left">自然对数 (ln x)</td><td><code>double log(double x)</code></td><td><code>log(exp(1)) ≈ 1.0</code></td><td>x &gt; 0</td></tr><tr><td align="left">常用对数 (log₁₀ x)</td><td><code>double log10(double x)</code></td><td><code>log10(100) = 2.0</code></td><td>x &gt; 0</td></tr></tbody></table><h3 id="2-数值算法（-）"><a href="#2-数值算法（-）" class="headerlink" title="2. 数值算法（&lt;algorithm&gt; &amp; &lt;numeric&gt;）"></a>2. 数值算法（<code>&lt;algorithm&gt;</code> &amp; <code>&lt;numeric&gt;</code>）</h3><table><thead><tr><th><strong>功能</strong></th><th><strong>函数原型</strong></th><th><strong>使用示例</strong></th><th><strong>注意事项</strong></th></tr></thead><tbody><tr><td>最大值</td><td><code>T max(T a, T b)</code></td><td><code>max(3, 5) = 5</code></td><td>支持多参数 <code>max(&#123;a,b,c&#125;)</code></td></tr><tr><td>最小值</td><td><code>T min(T a, T b)</code></td><td><code>min(2.0, 1.5) = 1.5</code></td><td>支持多参数</td></tr><tr><td>绝对值</td><td><code>T abs(T x)</code></td><td><code>abs(-10) = 10</code></td><td>模板版本</td></tr><tr><td>最大公约数</td><td><code>int gcd(int a, int b)</code> (C++17)</td><td><code>gcd(12, 18) = 6</code></td><td>C++17 需 <code>&lt;numeric&gt;</code></td></tr><tr><td>最小公倍数</td><td><code>int lcm(int a, int b)</code> (C++17)</td><td><code>lcm(4, 6) = 12</code></td><td>C++17 需 <code>&lt;numeric&gt;</code></td></tr><tr><td>区间求和</td><td><code>T accumulate(It first, It last, T init)</code></td><td><code>accumulate(v.begin(), v.end(), 0)</code></td><td>需 <code>&lt;numeric&gt;</code></td></tr><tr><td>填充递增序列</td><td><code>void iota(It first, It last, T value)</code></td><td><code>iota(v.begin(), v.end(), 1)</code></td><td>需 <code>&lt;numeric&gt;</code>，生成 1,2,3,…</td></tr></tbody></table><h3 id="3-常见相关常量（也在-中）："><a href="#3-常见相关常量（也在-中）：" class="headerlink" title="3. 常见相关常量（也在 &lt;climits&gt; 中）："></a>3. 常见相关常量（也在 <code>&lt;climits&gt;</code> 中）：</h3><table><thead><tr><th>功能</th><th>值</th></tr></thead><tbody><tr><td><strong>int 最大值（通常是 2³¹−1）</strong></td><td><strong><code>INT_MAX</code></strong></td></tr><tr><td><strong>int 最小值（通常是 -2³¹）</strong></td><td><strong><code>INT_MIN</code></strong></td></tr><tr><td><strong>long long 最大值</strong></td><td><strong><code>LLONG_MAX</code></strong></td></tr><tr><td><strong>long long 最小值</strong></td><td><strong><code>LLONG_MIN</code></strong></td></tr><tr><td><strong>大概是 <code>INT_MAX</code> 的一半，本质是一个 16 进制数，常用于防溢出</strong></td><td><strong><code>0x3f3f3f3f</code>（f 可大写可小写）</strong></td></tr><tr><td>unsigned int 最大值</td><td><code>UINT_MAX</code></td></tr><tr><td>char 最大值</td><td><code>CHAR_MAX</code></td></tr><tr><td>long 最大值</td><td><code>LONG_MAX</code></td></tr><tr><td>short 最大值</td><td><code>SHRT_MAX</code></td></tr></tbody></table><p><strong>注意事项：</strong></p><ul><li>不要混淆 <code>&lt;climits&gt;</code>（C++） 和 <code>&lt;limits.h&gt;</code>（C）。</li><li>如果你用的是 C++，推荐使用 <code>&lt;climits&gt;</code>。</li><li><code>INT_MAX</code> 是编译器根据系统架构定义的，保证可移植性。</li></ul><h3 id="4-位运算函数（GCC-内置）"><a href="#4-位运算函数（GCC-内置）" class="headerlink" title="4. 位运算函数（GCC 内置）"></a>4. 位运算函数（GCC 内置）</h3><table><thead><tr><th><strong>功能</strong></th><th><strong>函数原型</strong></th><th><strong>使用示例</strong></th><th><strong>返回值</strong></th></tr></thead><tbody><tr><td>二进制中 1 的个数</td><td><code>int __builtin_popcount(unsigned int x)</code></td><td><code>__builtin_popcount(7) = 3</code></td><td>32 位整数</td></tr><tr><td>前导 0 的个数</td><td><code>int __builtin_clz(unsigned int x)</code></td><td><code>__builtin_clz(1) = 31</code></td><td>32 位整数（MSB 开始）</td></tr><tr><td>后缀 0 的个数</td><td><code>int __builtin_ctz(unsigned int x)</code></td><td><code>__builtin_ctz(8) = 3</code></td><td>32 位整数（LSB 开始）</td></tr><tr><td>最低位 1 的位置</td><td><code>int __builtin_ffs(int x)</code></td><td><code>__builtin_ffs(6) = 2</code></td><td>位置从 1 开始计数</td></tr></tbody></table><h3 id="5-随机数（）"><a href="#5-随机数（）" class="headerlink" title="5. 随机数（&lt;cstdlib&gt;）"></a>5. 随机数（<code>&lt;cstdlib&gt;</code>）</h3><table><thead><tr><th><strong>功能</strong></th><th><strong>函数原型</strong></th><th><strong>使用示例</strong></th><th><strong>注意事项</strong></th></tr></thead><tbody><tr><td>生成伪随机数</td><td><code>int rand()</code></td><td><code>rand() % 100</code></td><td>范围 [0, RAND_MAX]</td></tr><tr><td>设置随机种子</td><td><code>void srand(unsigned seed)</code></td><td><code>srand(time(0))</code></td><td>需 <code>&lt;ctime&gt;</code></td></tr></tbody></table><p><strong>使用技巧：</strong></p><ol><li><p><strong>定义 π 常量</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);  <span class="comment">// 最精确的定义方式</span></span><br></pre></td></tr></table></figure></li><li><p><strong>整数绝对值</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="type">int</span> a = <span class="built_in">abs</span>(<span class="number">-10</span>);  <span class="comment">// 整数用cstdlib的abs</span></span><br></pre></td></tr></table></figure></li><li><p><strong>C++17 GCD&#x2F;LCM</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span></span></span><br><span class="line">cout &lt;&lt; <span class="built_in">gcd</span>(<span class="number">12</span>, <span class="number">18</span>) &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="built_in">lcm</span>(<span class="number">4</span>, <span class="number">6</span>);  <span class="comment">// 输出: 6 12</span></span><br></pre></td></tr></table></figure></li><li><p><strong>位运算优化</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断2的幂次</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isPowerOfTwo</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n &gt; <span class="number">0</span> &amp;&amp; (n &amp; (n - <span class="number">1</span>)) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>随机数生成</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="number">0</span>));  <span class="comment">// 初始化随机种子</span></span><br><span class="line"><span class="type">int</span> randNum = <span class="built_in">rand</span>() % <span class="number">100</span>;  <span class="comment">// 0-99的随机数</span></span><br></pre></td></tr></table></figure></li></ol><blockquote><p><strong>注意</strong>：竞赛中常用 GCC 编译器，可使用 <code>__builtin</code> 系列函数优化位运算操作。C++17 及以上建议使用标准库的 <code>gcd()</code> 和 <code>lcm()</code> 函数。</p></blockquote><h3 id="6-三角函数（）"><a href="#6-三角函数（）" class="headerlink" title="6. 三角函数（&lt;cmath&gt;）"></a>6. 三角函数（<code>&lt;cmath&gt;</code>）</h3><table><thead><tr><th><strong>功能</strong></th><th><strong>函数原型</strong></th><th><strong>使用示例</strong></th><th><strong>注意事项</strong></th></tr></thead><tbody><tr><td>正弦</td><td><code>double sin(double rad)</code></td><td><code>sin(M_PI/2) = 1.0</code></td><td>参数为弧度（非角度）</td></tr><tr><td>余弦</td><td><code>double cos(double rad)</code></td><td><code>cos(M_PI) = -1.0</code></td><td>需定义 <code>#define M_PI 3.1415926535</code></td></tr><tr><td>正切</td><td><code>double tan(double rad)</code></td><td><code>tan(M_PI/4) ≈ 1.0</code></td><td></td></tr><tr><td>反正弦</td><td><code>double asin(double x)</code></td><td><code>asin(1.0) = M_PI/2</code></td><td>返回值 ∈ [-π&#x2F;2, π&#x2F;2]</td></tr><tr><td>反余弦</td><td><code>double acos(double x)</code></td><td><code>acos(-1.0) = M_PI</code></td><td>返回值 ∈ [0, π]</td></tr><tr><td>反正切</td><td><code>double atan(double x)</code></td><td><code>atan(1.0) = M_PI/4</code></td><td>返回值 ∈ [-π&#x2F;2, π&#x2F;2]</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>028 动静态库 —— 动态库</title>
      <link href="/posts/14104.html"/>
      <url>/posts/14104.html</url>
      
        <content type="html"><![CDATA[<h2 id="动静态库-——-动态库"><a href="#动静态库-——-动态库" class="headerlink" title="动静态库 —— 动态库"></a>动静态库 —— 动态库</h2><h3 id="1-库的制作者-如何制作动态库"><a href="#1-库的制作者-如何制作动态库" class="headerlink" title="1. 库的制作者 如何制作动态库"></a>1. 库的制作者 如何制作动态库</h3><h4 id="1-编写库的源代码和头文件"><a href="#1-编写库的源代码和头文件" class="headerlink" title="1. 编写库的源代码和头文件"></a>1. 编写库的源代码和头文件</h4><ol><li><p><strong>创建头文件</strong>：声明库的对外接口函数。</p></li><li><p><strong>创建源文件</strong>：实现头文件中声明的函数。</p></li></ol><h4 id="2-编译为位置无关目标文件"><a href="#2-编译为位置无关目标文件" class="headerlink" title="2. 编译为位置无关目标文件"></a>2. 编译为位置无关目标文件</h4><p><strong><code>-fPIC</code> 关键作用</strong>：生成位置无关代码（Position Independent Code），使代码可被加载到内存任意位置，这是动态库的核心要求。</p><h4 id="3-链接生成动态库文件"><a href="#3-链接生成动态库文件" class="headerlink" title="3. 链接生成动态库文件"></a>3. 链接生成动态库文件</h4><p><strong><code>-shared</code> 参数</strong>：指示链接器生成共享库（.so 文件）。</p><h4 id="4-组织发布文件"><a href="#4-组织发布文件" class="headerlink" title="4. 组织发布文件"></a>4. 组织发布文件</h4><p>将以下文件提供给使用者：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">├── include/           # 头文件目录</span><br><span class="line">│   └── mathlib.h      # 接口声明</span><br><span class="line">└── lib/               # 库文件目录</span><br><span class="line">    └── libmathlib.so  # 动态库二进制</span><br></pre></td></tr></table></figure><hr><h3 id="2-动态库-demo"><a href="#2-动态库-demo" class="headerlink" title="2. 动态库 demo"></a>2. 动态库 demo</h3><h4 id="1-mathlib-h（头文件）——-对外接口声明"><a href="#1-mathlib-h（头文件）——-对外接口声明" class="headerlink" title="1. mathlib.h（头文件）—— 对外接口声明"></a>1. <code>mathlib.h</code>（头文件）—— 对外接口声明</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//相当于 #pragma once , 用于防止重复包含头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MATHLIB_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MATHLIB_H</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sub</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span><span class="comment">//表明头文件结束</span></span></span><br></pre></td></tr></table></figure><h4 id="2-add-c-和-sub-c（源文件）——-函数定义"><a href="#2-add-c-和-sub-c（源文件）——-函数定义" class="headerlink" title="2. add.c 和 sub.c（源文件）—— 函数定义"></a>2. <code>add.c</code> 和 <code>sub.c</code>（源文件）—— 函数定义</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mathlib.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mathlib.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sub</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-test-c（测试文件）"><a href="#3-test-c（测试文件）" class="headerlink" title="3. test.c（测试文件）"></a>3. <code>test.c</code>（测试文件）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mathlib.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;add(3, 5) = %d\n&quot;</span>, <span class="built_in">add</span>(<span class="number">3</span>, <span class="number">5</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sub(10, 4) = %d\n&quot;</span>, <span class="built_in">sub</span>(<span class="number">10</span>, <span class="number">4</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-目录结构"><a href="#4-目录结构" class="headerlink" title="4. 目录结构"></a>4. 目录结构</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── add.c          // 加法实现</span><br><span class="line">├── sub.c          // 减法实现</span><br><span class="line">├── mathlib.h      // 接口声明头文件</span><br><span class="line">├── lib/           // 输出的动态库放在这里</span><br><span class="line">├── test.c         // 用于测试动态库的代码</span><br></pre></td></tr></table></figure><h4 id="5-编译成位置无关码"><a href="#5-编译成位置无关码" class="headerlink" title="5. 编译成位置无关码"></a>5. 编译成位置无关码</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -fPIC -c add.c -o add.o     <span class="comment"># 生成 add.o</span></span><br><span class="line">gcc -fPIC -c sub.c -o sub.o     <span class="comment"># 生成 sub.o</span></span><br></pre></td></tr></table></figure><blockquote><h4 id="什么是-fPIC？"><a href="#什么是-fPIC？" class="headerlink" title="什么是 -fPIC？"></a>什么是 -fPIC？</h4><p><strong>位置无关代码就是一段“到哪都能跑”的代码，它不依赖自己必须加载到某个固定地址。</strong></p><ul><li>普通代码：写死了“我只能住在 0x123456 这个地址附近”。</li><li>位置无关代码：随便系统安排我住哪，我都能运行！</li></ul><p>动态库 <code>.so</code> 是一种 <strong>可被多个程序同时加载</strong> 的“共享代码段”，但每个程序自己内存布局不同，比如：</p><ul><li>程序 A：把 <code>.so</code> 放在内存地址 <code>0x100000</code>。</li><li>程序 B：放在 <code>0x200000</code>。</li></ul><p>如果 <code>.so</code> 里面代码写死了“我在 0x100000”，那程序 B 加载后就炸了！所以我们必须写出：<strong>可在任意地址运行的 <code>.so</code> 代码</strong> —— 这就是位置无关代码（PIC）。</p><hr><p><strong>怎么生成位置无关代码？</strong><br>在编译 <code>.c</code> 或 <code>.cpp</code> 文件时加上：<code>gcc -fPIC -c add.c -o add.o</code>。</p><hr><p><strong>所以，位置无关代码（<code>Position Independent Code</code>） 是动态库的“打包必需品”，它能让我们的代码“住哪都行，拷贝即跑”，这是 Linux 系统让多个程序共享一份 <code>.so</code> 的关键机制。</strong></p><table><thead><tr><th>用途</th><th align="left">描述</th></tr></thead><tbody><tr><td>创建动态库</td><td align="left"><code>gcc -shared ...</code> 时要求 <code>.o</code> 是位置无关的</td></tr><tr><td>支持多个程序加载共享代码</td><td align="left">系统可将同一个 <code>.so</code> 加载到任意地址</td></tr><tr><td>降低代码冲突和内存浪费</td><td align="left">PIC 允许系统更好地重用内存页（节省内存）</td></tr></tbody></table><hr><p><strong>我们已经知道了 PIC 是位置无关码，那么 <code>-f</code> 又是什么？</strong><br><code>-f</code> 是 GCC 用来启用&#x2F;关闭编译“特性（feature）”的选项前缀，<code>-fPIC</code> 是告诉编译器生成位置无关代码，<strong>是动态库开发必备的特性之一。</strong> 反之如果看到 <code>-fno-XXX</code> 那就是 <strong>禁用</strong> 某个特性。</p></blockquote><h4 id="6-链接生成动态库-so"><a href="#6-链接生成动态库-so" class="headerlink" title="6. 链接生成动态库 .so"></a>6. 链接生成动态库 .so</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p lib                                 <span class="comment"># 创建输出目录</span></span><br><span class="line">gcc -shared -o lib/libmathlib.so add.o sub.o <span class="comment"># 链接成动态库</span></span><br></pre></td></tr></table></figure><h4 id="7-测试程序调用该动态库"><a href="#7-测试程序调用该动态库" class="headerlink" title="7. 测试程序调用该动态库"></a>7. 测试程序调用该动态库</h4><p>编译时指定头文件和库路径：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc test.c -I. -L./lib -lmathlib -o <span class="built_in">test</span>// 注意：-I. 是头文件路径，-L./lib 是动态库路径，-lmathlib 自动匹配 libmathlib.so</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><code>test.c</code>：测试源文件。</li><li><code>-I.</code>：当前目录，告诉编译器头文件 <code>mathlib.h</code> 在当前目录。</li><li><code>-L./lib</code>：告诉编译器去 <code>./lib/</code> 目录下找 <code>.so</code> 文件。</li><li><code>-lmathlib</code>：表示链接 <code>libmathlib.so</code>（前缀 <code>lib</code> 和后缀 <code>.so</code> 是自动补全的）。</li><li><code>-o test</code>：输出最终的可执行文件 <code>test</code>。</li></ul><hr><p>运行前设置动态库查找路径：因为 <code>libmathlib.so</code> 在当前目录，不在 <code>/usr/lib</code> 等默认路径，需用 <code>LD_LIBRARY_PATH</code> 指定路径：<code>LD_LIBRARY_PATH=./lib ./test</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">临时环境变量设置:</span><br><span class="line">LD_LIBRARY_PATH=./lib ./test   <span class="comment"># 单次运行有效</span></span><br><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=./lib:<span class="variable">$LD_LIBRARY_PATH</span>     <span class="comment"># 当前会话有效</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250613230316142.png" alt="image-20250613230234991"></p><blockquote><p>如果遇到：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;./test: error <span class="keyword">while</span> loading shared libraries: libmathlib.so: cannot open shared object file: No such file or directory</span><br></pre></td></tr></table></figure><p>这是一个 <strong>非常经典的 Linux 动态库加载错误</strong>，表示已经 <strong>链接成功</strong>，但是运行时报错。<strong>根本原因：Linux 在运行程序时会去“系统的动态库搜索路径”中查找链接的 动态库（<code>libmathlib.so</code>），但我们的库在 <code>./lib/</code> 目录，不在默认路径中！</strong> 系统默认查找动态库的路径包括：</p><ul><li><code>/lib</code></li><li><code>/usr/lib</code></li><li><code>/usr/local/lib</code></li></ul><p><strong>解决加载找不到动态库的方法：</strong></p><ul><li>拷贝到系统默认的库路径&#x2F;lib64&#x2F; 或 &#x2F;usr&#x2F;lib64&#x2F;。</li><li>在系统默认的库路径&#x2F;lib64&#x2F; 或 &#x2F;usr&#x2F;lib64&#x2F;下建立软连接。</li><li>将自己的库所在的路径，添加到环境变量 <code>LD_LIBRARY_PATH</code> 中。</li><li>&#x2F;etc&#x2F;ld.so.conf.d&#x2F; 建立自己的动态库路径的配置文件，然后重新 <code>sudo ldconfig</code> 命令刷新缓存即可。</li></ul><p><strong>实际情况，我们用的库都是别人的成熟的库，都采用直接安装到系统的方式！</strong></p></blockquote><h3 id="3-静态库-VS-动态库"><a href="#3-静态库-VS-动态库" class="headerlink" title="3. 静态库 VS 动态库"></a>3. 静态库 VS 动态库</h3><table><thead><tr><th>特性</th><th>静态库（<code>.a</code>）</th><th>动态库（<code>.so</code>）</th></tr></thead><tbody><tr><td>链接方式</td><td>编译期拷贝符号</td><td>运行时动态加载</td></tr><tr><td>可执行文件大小</td><td>大（包含所有库函数）</td><td>小（只包含引用信息）</td></tr><tr><td>升级方式</td><td>需重新编译应用</td><td>替换 <code>.so</code> 即可</td></tr><tr><td>使用场景</td><td>发布单文件程序、部署简单</td><td>支持版本隔离、插件式架构、共享资源</td></tr></tbody></table><hr><h3 id="4-动态库的加载（重点）"><a href="#4-动态库的加载（重点）" class="headerlink" title="4. 动态库的加载（重点）"></a>4. 动态库的加载（重点）</h3><p>一旦动态库被加载，它的代码就会被映射到进程的地址空间。此后，该库的代码就是我们进程自己的一部分，任何执行都在进程内部完成。操作系统始终知道 <strong>当前有哪些库被加载、哪些进程在使用哪些库</strong>，这一切都由 <strong>内核 + 动态链接器</strong> 管理（<strong>先描述再组织</strong>）。</p><ul><li><strong>什么是“建立映射”</strong>：当运行一个程序，操作系统会为它创建虚拟地址空间（每个进程都有自己独立的）。<strong>动态库的内容，并不是直接“复制”一份到我们的进程里，而是操作系统建立了“映射关系”，访问它时就像是我们自己的内存一样。</strong></li><li><strong>每个进程的动态库加载情况在哪看</strong>：<code>cat /proc/&lt;pid&gt;/maps | grep .so</code></li></ul><p>动态库通过映射机制变成我们进程的一部分，它的代码执行就在我们的地址空间里；但代码本体可能在物理内存中被多个进程共享，而操作系统负责管理这一切。</p><hr><h4 id="1-动态库在进程运行时，是如何被加载的？"><a href="#1-动态库在进程运行时，是如何被加载的？" class="headerlink" title="1. 动态库在进程运行时，是如何被加载的？"></a>1. 动态库在进程运行时，是如何被加载的？</h4><p><strong>结论：动态库是由 操作系统的动态链接器 在程序运行时加载进内存的。</strong></p><p><strong>加载时机分为两种：</strong></p><table><thead><tr><th>加载方式</th><th>说明</th><th>举例</th></tr></thead><tbody><tr><td><strong>隐式加载（默认）</strong></td><td>程序启动时自动加载 <code>.so</code> 文件</td><td><code>gcc test.c -lxxx</code> 编译出的程序</td></tr><tr><td><strong>显式加载</strong></td><td>程序运行过程中用 <code>dlopen()</code> 主动加载</td><td>插件机制、热更新系统常用</td></tr></tbody></table><h5 id="谁负责加载？"><a href="#谁负责加载？" class="headerlink" title="谁负责加载？"></a>谁负责加载？</h5><p>Linux 中负责加载 <code>.so</code> 的是：<code>/lib64/ld-linux-x86-64.so.2 </code>，这就是动态链接器，程序启动时它会完成：</p><ol><li>找到依赖的 <code>.so</code>。</li><li>将 <code>.so</code> 加载进内存。</li><li>解析符号地址表（.got &#x2F; .plt）。</li><li>将函数地址绑定到调用位置（延迟绑定）。</li></ol><p>我们可以通过 <code>ldd</code> 命令查看哪个程序使用了这个链接器。</p><hr><h4 id="2-动态库加载后，是否会被“所有进程共享”？"><a href="#2-动态库加载后，是否会被“所有进程共享”？" class="headerlink" title="2. 动态库加载后，是否会被“所有进程共享”？"></a>2. 动态库加载后，是否会被“所有进程共享”？</h4><p><strong>结论：是的，部分共享！</strong> 动态库在被多个程序使用时，<strong>内存中可以共享一份代码段</strong>，但 <strong>数据段不会共享</strong>。<br>原因：代码段只读、可重定位、不包含状态数据；数据段：每个进程有自己的全局变量&#x2F;堆栈。</p><p>例子：当运行两个程序时，操作系统发现他们都用到了同一个库：</p><ul><li><code>.text</code> 段代码是只读的，所以直接 <strong>映射到同一块物理内存</strong>；</li><li><code>.data</code> 段是每个进程自己的，<strong>分配在各自的地址空间中</strong>。</li></ul><p><strong>所以，动态库的“代码部分”是可以被多个进程共享的，从而节省内存！</strong></p><blockquote><p><strong>共享库和缓存的关系</strong></p><p>动态库一旦被加载一次（如被某个程序加载），<strong>其 <code>.so</code> 文件内容可能已经缓存在内存页中</strong>，之后被其他程序再次加载时，操作系统可以 <strong>直接使用缓存的页</strong>，而不必重新从磁盘读取。这也就是 Linux 内核的 Page Cache 机制。</p></blockquote><hr><h4 id="3-物理地址和虚拟地址"><a href="#3-物理地址和虚拟地址" class="headerlink" title="3. 物理地址和虚拟地址"></a>3. 物理地址和虚拟地址</h4><ul><li><strong>物理地址</strong> 很好理解，<strong>就是真实的内存地址</strong>，就是机器上内存条中某个具体物理位置。</li><li><strong>虚拟地址</strong> 则是 <strong>操作系统为进程“伪造”的地址空间</strong>，每个进程以为自己从 0 开始拥有 4GB（其实并没有）。</li></ul><p><strong>谁来把虚拟地址 → 转成 → 物理地址？</strong><br>操作系统 + CPU 一起完成，依赖于 <strong>MMU（内存管理单元）+ 页表</strong></p><blockquote><p>  MMU 是 CPU 内负责“地址翻译”的硬件单元，它会根据当前进程的“页表”把虚拟地址转换为物理地址。</p></blockquote><hr><h4 id="4-编译、加载、运行三个阶段的“地址含义”"><a href="#4-编译、加载、运行三个阶段的“地址含义”" class="headerlink" title="4. 编译、加载、运行三个阶段的“地址含义”"></a>4. 编译、加载、运行三个阶段的“地址含义”</h4><h5 id="1-编译阶段：编译器只生成“相对地址”"><a href="#1-编译阶段：编译器只生成“相对地址”" class="headerlink" title="1. 编译阶段：编译器只生成“相对地址”"></a>1. 编译阶段：编译器只生成“相对地址”</h5><p>编译器不知道程序会加载到内存的哪一块，所以使用 <strong>偏移量 &#x2F; 虚拟地址模板</strong>（编译器也要考虑操作系统）。例子：编译后并不会写死“某个变量在物理地址 0x80000000”，而是说：”该变量位于 <code>.data</code> 段中的偏移 +0x04”。</p><h5 id="2-程序尚未加载前（可执行文件中）"><a href="#2-程序尚未加载前（可执行文件中）" class="headerlink" title="2. 程序尚未加载前（可执行文件中）"></a>2. 程序尚未加载前（可执行文件中）</h5><ul><li>程序文件（ELF）中写的是 <strong>虚拟地址模板</strong>。</li><li>比如：<ul><li>代码段 <code>.text</code> 映射地址是 0x08048000。</li><li>数据段 <code>.data</code> 映射地址是 0x0804a000。</li></ul></li><li>这些只是“建议地址”，加载时由操作系统决定。</li></ul><h5 id="3-程序加载运行后"><a href="#3-程序加载运行后" class="headerlink" title="3. 程序加载运行后"></a>3. 程序加载运行后</h5><p>操作系统为每个进程创建 <strong>虚拟地址空间</strong>，并按照 ELF 文件中的要求分配地址空间，将指令、数据装入虚拟地址中。然后，<strong>CPU 执行指令时看到的地址是虚拟地址！</strong></p><hr><blockquote><p><strong>CPU 读到的指令里面的地址，是虚拟地址吗？</strong><br><strong>是的！</strong> 程序运行期间，CPU 执行的所有地址操作（读取代码、读取变量、跳转函数）都是虚拟地址。然后由 MMU 将这些地址实时映射成物理地址。</p><hr><p><strong>编译完成的程序里有没有地址的概念？</strong><br><strong>有！</strong> 但它们是虚拟地址模板或偏移量（不是最终的内存地址）。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250614193537357.png" alt="image-20250614193537214"></p><p><strong>所以，编译看偏移，加载定地址，执行用虚拟，MMU 做翻译。</strong></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 地址空间 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>纪念“一周年”，我的成长、蜕变与收获</title>
      <link href="/posts/57061.html"/>
      <url>/posts/57061.html</url>
      
        <content type="html"><![CDATA[<h1 id="纪念“一周年”，我的成长、蜕变与收获"><a href="#纪念“一周年”，我的成长、蜕变与收获" class="headerlink" title="纪念“一周年”，我的成长、蜕变与收获"></a>纪念“一周年”，我的成长、蜕变与收获</h1><blockquote><p>今天是 2025 年 5 月 22 日，一个值得纪念的日子 —— 一年前的今天，我毅然选择报班学习，踏上了改变命运的征程。在这一年里，我经历了从迷茫到觉醒的成长蜕变，踩过无数坑后总结出血泪教训，也收获了宝贵的心得与经验。这篇文章分成三个部分展开：我的成长故事、成长心得分享与总结，以及大学避坑指南。</p></blockquote><h2 id="1-初入象牙塔：从志愿时长-100-到安逸下的不安"><a href="#1-初入象牙塔：从志愿时长-100-到安逸下的不安" class="headerlink" title="1. 初入象牙塔：从志愿时长 100+ 到安逸下的不安"></a>1. 初入象牙塔：从志愿时长 100+ 到安逸下的不安</h2><p>我来到“大学”的日子是 2023 年 8 月 26 日，那时候真的是天真得不行，时间也多得用不完。每天就是老老实实去上课，下课后就呆在宿舍玩一玩，偶尔出去搞点志愿活动，对了，当时加入了青年志愿者社团，短短小半年时间，<strong>志愿时长已经有 100 多小时了</strong>。有时候也会去打打球，放松一下。可是这样的生活让我渐渐觉得很乏味，也不能说是乏味吧，就觉得看不到未来，如果一直这么混下去，终将一事无成，沦落到街头混饭吃。所以，我就萌生了做点什么去挣点钱，当时的想法很简单，就是赚点小钱补贴生活费，顺便也为以后谋生积攒经验。</p><h2 id="2-搬砖记：跌跌宕宕换来的碎银几两"><a href="#2-搬砖记：跌跌宕宕换来的碎银几两" class="headerlink" title="2. 搬砖记：跌跌宕宕换来的碎银几两"></a>2. 搬砖记：跌跌宕宕换来的碎银几两</h2><p>于是，我就一头扎进了搞钱的路子。初期什么都不了解，没人带，也没有门道，只能自己胡乱的摸索，上网到处找点门道。从最开始试着做线上任务，一块两块地挣，麻烦不说，还贼繁琐，赚的那点钱连一顿饭都不够。后来又跑去知乎写文章，想靠流量挣钱，结果可想而知，总共才弄到不到 50 米，惨败收场。也许是受了打击，也或许是不甘，沉默了一段时间后，在校园墙上看到了一些代课、写作业或者完成 XX 任务的信息，我二话不说果断就去了，结果呢？累得要死不说，还遇到过跑路的和挨骂的 😭，真是气得我整个人都不好了。到后来，为了解决自身和好友的流量问题，不成想，既解决了问题，又拿到了流量卡的“网售资格”，为此又结识了另一位合伙人，做上了校园跑的“业务”，这份“合作”还算成功，尝到了些许甜头……</p><h2 id="3-误入“传销”工作室，识破“机会”的面具"><a href="#3-误入“传销”工作室，识破“机会”的面具" class="headerlink" title="3. 误入“传销”工作室，识破“机会”的面具"></a>3. 误入“传销”工作室，识破“机会”的面具</h2><p>再后来，我听说有个校园业务的工作室，还是一样果断跑去尝试，结果只能说——“传销的味儿太重了”。我半信半疑地听着，期间那个工作室的“老大”掏出一堆证，四六级、营业执照、心理咨询师（听说是中科院心理所才能发）啥的，说随便啥证都能直接办下来，还在那儿一顿胡吹海吹。我心里不由得冷笑，这东西一看就是假的，国家颁发到你这就这么容易？这事儿也就这么不了了之了。直到小半年后，一次碰巧偶遇了那个工作室的一个成员，才知道真相：他们“老大”寒假忽悠大家进厂干活，说是高薪，结果被抽成抽到时薪连 10 米都不到，其他校园业务也是充满欺骗，加入还得交 1000 米的入会费……最后这位老大被其他成员联手踢了出去，好像又因为挂科太多等原因退学了，活该！</p><h2 id="4-创业记：个人创业的短暂尝试到“送货上门”的无奈停业"><a href="#4-创业记：个人创业的短暂尝试到“送货上门”的无奈停业" class="headerlink" title="4. 创业记：个人创业的短暂尝试到“送货上门”的无奈停业"></a>4. 创业记：个人创业的短暂尝试到“送货上门”的无奈停业</h2><p>同步时间，我也没闲着，不断钻研着我的“创业”事儿，不断引进“新业务”，做点知识付费、校园跑、小说推文（这是一个业余活儿，有兴趣的朋友可以试试，<strong>方法：微信搜索“青风助手”，can666 这是我的邀请码</strong>，已是 180+ 人的“团队”。这个活儿就是剪视频去推广小说，从而赚流量的收益）、流量卡等等“小生意”，零零散散混着，那时大家都称我是校园众包，但其实很多“业务”遍布全国各地，都是分别来自不同学校的学生，听着好像很高大上，但其实这些来自不同学校的“客户”总计也就千于人。后来结识了双创主席，开始做宿舍小卖铺。大学嘛，不就是要敢想敢干！拉上一个舍友一起合伙，去城里批发市场跟人谈价钱，最后宿舍小卖铺也是成功开起来了，学校物价偏贵，我们凭借偏低的物价和“送货上门”也是小挣了一点，尝到甜头了。可惜好景不长，合伙的舍友后来迷上了打球，退出了，我呢，又因为课程繁忙，精力有限，难以独自支撑整个小卖部的运营，最终只能无奈地按下了暂停键，这段创业尝试也就草草收场了。恰似 <strong>小铺如烛，风起即灭</strong>。</p><h2 id="5-觉醒时刻：从知识星球到狠心报班的“破釜沉舟”"><a href="#5-觉醒时刻：从知识星球到狠心报班的“破釜沉舟”" class="headerlink" title="5. 觉醒时刻：从知识星球到狠心报班的“破釜沉舟”"></a>5. 觉醒时刻：从知识星球到狠心报班的“破釜沉舟”</h2><p>再到后来，觉得一事无成、很失败，陷入无限焦虑中。那段时间非常压抑，最后我决定：得好好学习，卷卷技术。其实从进入大学以来，就有一直好好学习，可能有点高中的行为和思维固化，只知道跟着老师走，当时也会偶尔课外学一点编程，现在看来不过是浪费时间罢了，实际没学到多少东西。大一各科成绩一直挺靠前，总成绩在班里排第三。说到编程技术，我只会点皮毛。可能是突然开窍了，也可能是命运推了我一把，我开始上网自学技术。刚开始学得稀稀拉拉，没啥进展，后来在哔哩哔哩刷到了一个 C 语言课程，一开始我对这个课完全没兴趣，画面是画图板加真人讲解，视频时长还很长，由于之前刷到过那种动画讲编程的视频，下意识就觉得动画讲有意思、容易理解，不太喜这种类似课堂的讲解。好巧不巧，视频下面有个知识星球的社群链接，想着进去看看，结果就像打开了潘多拉魔盒，一发不可收拾。里面都是一些正在努力的大学生，有很多“大佬”问着我看不懂的问题，也有着和我一样的萌新，来寻求人生方向和发问编程问题的人，清晰记得有一条发文说有人已经将所学运用开始接单挣钱了，剩下还有一些学长分享的 offer 经历，这更坚定了我要学技术的信心。瞬间感觉志同道合，找到了组织！此刻或许就是从焦虑到笃定的转折点吧……</p><p>到了 2024 年 5 月 17 日，我开始正式深入了解这个“社群”。一开始还是有点半信半疑，各种问题抛出去被一一得到了解答，到后来的一句“有内推、包就业”，当时不知道内推是什么意思，以为是什么内部渠道，就觉得很高大上，其实不然，而包就业则是一直服务到就业，但那时候就觉得很牛逼。我直接就狠下心来和父母说了这件事，结果交谈并不那么顺利，他们不太支持。我呢也就没有再多说，毕竟命运是掌握在自己手中的！于是用自己不多的家底在 2024.5.22 报了班，开始我默默努力学习的道路，倘若将来发达了，我会证明我的选择是正确的，不发达就当没干过 🤣。</p><blockquote><p>同步时间，2024.5.17 那几天学校举行了程序设计校赛（具体时间记不清了），凭借之前学到的一些知识和一点点的基础底子，在这场“校赛”中拿到了一个 <strong>个位</strong> 名次，成功进入 517 算法实验室，后来才知道这场校赛是为 ACM 校队纳新的，我也是成功成为了校队的一名新成员，同时走上了我的算法竞赛之路……</p></blockquote><p><strong>我相信，2024 年 5 月 22 日，命运的齿轮，就从这一刻开始转动……</strong></p><blockquote><p>后来的一年里，我基本上是在实验室中度过的，没课就基本呆在实验室，我见过实验室人满为患的样子，也见过假期和晚上 11 点钟稀稀疏疏的人影。这一年，我远离了吵闹的宿舍，远离了爱打游戏、摆烂的舍友，远离了各种乱七八糟的社团，放弃了各种部长、班干部、评奖评优的竞选……我感觉后来的这一年过的很快很快，比高中还快，我过的很踏实也很充实，学到了很多、见到了很多、也成长了很多……</p><p>这里着重感谢一下刘*鑫学长，感谢你每次的教导，教我写题、写代码……虽然你每次都说我很笨、很蠢 😂，但我真的很受益！感谢！😘</p></blockquote><hr><h1 id="成长心得分享与总结"><a href="#成长心得分享与总结" class="headerlink" title="成长心得分享与总结"></a>成长心得分享与总结</h1><p><img src="https://zycs-img-8kd.pages.dev/v2/EEeutKD.png" alt="image-20250811190443462"></p><p><strong>正如 <a href="https://wyqz.top/">行码棋</a> 所提到的，过去的路径可能已经封闭，但未来仍有大量可能等待着你去探索。人生道路是动态的，有些道路已经关闭，有些道路则充满了希望和潜能。</strong> 我们更多需要的是：</p><ul><li><p><strong>突破自我局限：</strong> 阻碍你前进的往往不是外部竞争，而是 <strong>固步自封的思维</strong>；决定成败的并非小聪明，而是基于长远视野的理性选择。</p></li><li><p><strong>成功的稀缺性：</strong> 成功之路并不拥挤，因为多数人仅停留在 “想要” 而非 “必须” 的层面，缺乏持续行动和代价付出的决心。</p></li><li><p><strong>认知与行动的鸿沟：</strong> 人们习惯用偏见判断事物，却拒绝验证与纠错；总是等待 “完美时机”，却从未真正开始，导致机会在观望中流失。</p></li><li><p><strong>经验优于准备：</strong> 人生不需要过度准备，需要的是在行动中试错、迭代。唯有持续实践才能积累真实认知，空想只会停滞不前。</p></li><li><p><strong>知识的有效转化：</strong> 单纯的知识储备无意义，只有学习能指导实践、解决问题的知识，才能真正改变命运。</p></li></ul><hr><ol><li><p>真正的成长始于 <strong>打破思维惯性</strong>，成于 <strong>持续行动</strong> 与理性选择。少纠结 “是否正确”，多问 “是否行动”；少沉迷准备，多投入实践 —— 在试错中校准方向，才是普通人跃迁的核心路径。<strong>大学生活中，我们要用于尝试，失败不可怕，可怕的是你永远不敢去行动！大学的试错机会很多，试错成本也很低，年轻人一定要把握机会！</strong></p></li><li><p>真正的成长不是盲目填满时间表，而是学会区分 “虚假忙碌” 和 “有效突破”。在舒适区重复 100 次不如在挑战区失败 1 次。衡量进步的标准不是投入时间，而是认知边界的拓展。</p></li><li><p>退出 3 个闲聊群后，我完成了人生第一个开源项目。不是所有社交都值得维系，有些关系就像内存泄漏的程序，不断消耗你的精力却毫无产出。现在我的交友原则很简单：要么能一起创造价值，要么能让彼此成为更好的人。</p></li><li><p>小学生学会造句以后还要下很大功夫才能写出像样的作文。编程需要大量的练习，只看和听是不够的，反过来，如果只是盲目的练习，不看不听也是不明智的。<strong>有效的“听”要靠教师的辛勤劳动，而有效的“练”则要靠学生自己。</strong>——摘自《算法竞赛 入门经典（第 2 版） 前言部分》</p></li><li><p>知识早已浩瀚无边，我们所能接触到的不过大海之一滴，所能理解掌握谨记于心的更不过是这一滴中很微小的一部分，我们每日所做的也不过是为了使这一滴更大，使那一部分更多而已。如果把这一滴比作我们所掌握的资源，那么我们平时开发时应该不求下笔千行，而力求迅速地从各种资源中找到解决方案。——摘自《Linux 内核修炼之道 317 页》</p></li><li><p>“真正的智慧不在于知道答案，而在于提出更好的问题；不在于避免犯错，而在于从错误中提炼认知模式。” —— 我的实验室日记第 182 天</p></li><li><p>学校不能为天才提供任何帮助，它只能制造阻碍，什么时候一个人能意识到学校永远都无法学到东西，他就彻底开始了真正的学习；与此同时，学校也不能为培养人才提供任何帮助，其原因是：人才不是通过培养的，人才没有固定路线和计划，人才是在社会中随机历练的。出校，出国，并历练。（<strong>声明：这不是对国家教育制度的全盘否定和“反体制”言论，我想传达的是：于我而言，课堂内容与社会脱节，不得不靠自学补足技能。真正的学习不能只依赖课堂，而要主动向外探索！</strong>）</p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Blog/20251001133032929.png" alt="PixPin_2025-10-01_13-30-22"></p><p>该信息来自 <a href="https://mp.weixin.qq.com/s/SqP-S_qQDsH8-VpgyjWMlg">上大学，最耽误时间的是上课 | 黑马程序员微信公众号</a>，不出意外，<strong>从计算机方面来说</strong>，大家认为大学知识不能支撑计算机学子找到好工作的远超其他选项。</p><hr><h1 id="大学避坑指南：这些坑我替你踩过了！"><a href="#大学避坑指南：这些坑我替你踩过了！" class="headerlink" title="大学避坑指南：这些坑我替你踩过了！"></a>大学避坑指南：这些坑我替你踩过了！</h1><blockquote><p>  [!NOTE]</p><p>  我的大学生活基本上是全靠自己去摸索，没有太多有用的指点和引导，所以吃过很多亏和踩过很多坑，现在总结放在这里，为后来者提供参考，希望后来者的你们可以一步到位，避免重蹈覆辙。</p><p>  <strong>注：下面内容的编排不分先后。在此，我需要郑重声明：脱离具体场景的结论往往是片面且不负责任的，因此，以下所有观点均是基于我本人所处的大学校园环境、个人所见所闻以及亲身经历所提炼出的真实感悟与认知，为屏幕前的你呈现出更贴合实际、更具参考价值的经验分享，而非放之四海而皆准的绝对真理。仅供参考！</strong></p></blockquote><h2 id="别等机会敲门，机会不是等来的！"><a href="#别等机会敲门，机会不是等来的！" class="headerlink" title="别等机会敲门，机会不是等来的！"></a>别等机会敲门，机会不是等来的！</h2><p>我见过有些有想法的同学会找到我们的实验室来，可能是纳新和校赛错过了，也可能是压根不知道，不管什么原因，后来这些同学来到实验室就说，“我想做项目，能不能收我”“我会编程，我能进不？”……我很佩服他们自荐的勇气，但是要么是和实验室方向不相关，要么就是基础太差，反正一个也没进来 😮‍💨。</p><p>每个学校或多或少都会有一些实验室&#x2F;工作室，我建议想学的同学可以大胆先去了解，然后提升自己的基本实力，学成归来在大胆的去力荐自己！我认为这种 <strong>主动去寻找机会和力荐自己的精神很可贵！要学会去尝试！大学本就是一个试错的过程，要大胆去试错、去尝试，大学的试错成本很低，但是未来就不一样了！成就永远不是光靠脑子就能想出来的，更多是要用执行力去行动！</strong></p><h2 id="不推荐盲目打临时工！"><a href="#不推荐盲目打临时工！" class="headerlink" title="不推荐盲目打临时工！"></a>不推荐盲目打临时工！</h2><p>我用亲身经历告诉你，作为大学生最好不要盲目去打临时工，经常就是不讨好，还一肚子气，也别被“大学生整顿职场”误导，现实一定会打破流言蜚语为我证明！“大学生整顿职场”不过是段子，现实的大学生进入职场是真不容易，进去大多是边角料、出气筒，不要说什么特例，说真的，你觉得特例会是自己吗？像海底捞、服务员、做奶茶、外卖员等这些工作没有太多实际意义，对个人成长帮助微乎甚微，除非遇到了经济危机或者说想要释放压力&#x2F;体验不一样的生活等特殊情况，才建议去打工。</p><p><strong>人少年时期的时间非常宝贵！在年轻气盛的时期最好把这些时间拿去做个人成长，培养一门手艺，精进一门技能，永远不要为了一时的蝇头小利而错失更大的利益！定下一个长远的目标，用上 3-5 年的时间去奋斗！无论最后是否成功，其收获不出意外肯定是要大于打临时工的。</strong></p><h2 id="一定要学好英语"><a href="#一定要学好英语" class="headerlink" title="一定要学好英语!!!"></a>一定要学好英语!!!</h2><p>我的英语很差，这主要就要从小学说起了，小学不知从哪里听到“我是中国人，不需学外国文”等类似的话，于是我也就盲目跟风不学英语，后来发现只有我把这句话当真了，到了初高中都会有老师给出了希望，两次都是信心满满的去尝试将英语捡起，奈何基础太差跟不上老师上课节奏，换来失败，直到大学学计算机，才知道英语的重要性，不要说什么可以用拼音！为什么？因为有些命名稍长，拼音的长度就跟指数一样上去了，另外拼音不利于阅读，在团队的项目中大家统一都用英语，谁会想要去读你的拼音？而且用拼音不利于代码维护，再者就很 low。</p><p>有人问，那你现在学英语嘛？准备过四六级嘛？我的回答是学，但肯定是不能从 0 基础开始，我的时间好像不太充裕了（这里指的是毕业前找实习和 offer 之前）。我的英语底子我非常清楚，还是比较有自知之明的 🥹，所以我并不打算过四六级（如果后面有机会的话，可能还是会想要试试 🙃）。我认为四六级也只能代表个人英语的相对情况，考证也或多或少存在一些水分，举个例子：<code>ACM-icpc</code> 需要三人组队，题目是英文，历届学长曾找过一个英语专业（四级已过）的学生共同参赛，结果是根本翻译不了一点，看不懂、翻不通。这里只是个例，并不能代表全部，说到底大多数人不可能记得住所有的单词，也会有陌生和忘记的，他也需要去查单词，和我没有太大区别，好吧，我承认区别还是蛮大的，至少我查的会多一点 😭，所以我是面向就业，先专注于就业常用的单词，再去查漏补缺。<strong>这里推荐我的背单词软件——墨墨背单词，以及常用的软件翻译（提升效率）：沉浸式翻译、Sider、谷歌翻译、DeepL 翻译、全局的夸克划词翻译等。</strong> 看来我还是在翻译上下了功夫滴 😁。</p><p><strong>总之，英语真的很重要，它应该是一项必备技能！扎实的英语功底一定会为你带来很多便捷！</strong></p><h2 id="降噪耳机：大学生活的第一生产力"><a href="#降噪耳机：大学生活的第一生产力" class="headerlink" title="降噪耳机：大学生活的第一生产力"></a>降噪耳机：大学生活的第一生产力</h2><p>在大学，无论什么样的学校，只要你运气不好，就会和不文明、吵闹的人一起度过一段时间，这段时间可能是大学 4 年也可能是一堂课，感受过的朋友一定很煎熬，所以有一个降噪耳机是很必要的！此外如果你想在课堂上自己学，不想被老师的讲话声打扰，降噪耳机就更有存在的必要了！</p><p><strong>降噪耳机怎么选？</strong> 推荐一下我用的：<strong>头戴式用的是 <code>QCY H3</code></strong>，使用体验：价比高、降噪效果好，但是好像使用时间久了，或是被我压过，降噪效果下降了一点，影响不大，有多余预算的建议直接上 <code>Pro</code> 版。如果在外不想使用头戴式，<strong>也可以看看 <code>QCY MeloBuds Pro</code></strong>，使用体验：降噪挺好，虽然不能完全阻挡老师的扩音器，但是放个背景白噪音再看书&#x2F;看课很容易专下心来，降噪不仅将声音降低了，而且感觉说话声变远了整体很不错。<strong>这两款耳机均支持双蓝牙同时连接，价格在 200 以内。如果预算很充足，也可以看看其他高价产品，这里仅是分享，市面上正常降噪也就 <code>50dB</code> 上下，效果分别其实没有特别大，选一款适合自己的才最好，还是建议长期使用的降噪耳机不要吝啬。</strong>（如果 QCY 官方看到请给我打广告费 😂）</p><h2 id="学习无用？名校和二本的差距，比想象中更残酷！"><a href="#学习无用？名校和二本的差距，比想象中更残酷！" class="headerlink" title="学习无用？名校和二本的差距，比想象中更残酷！"></a>学习无用？名校和二本的差距，比想象中更残酷！</h2><p>说实话，高中学的“死知识”，但现在我都不知道到有什么用，但是高考成绩还是相当重要的！</p><p>正巧，前段时间去西工大打天梯赛，才知道一所好学校的含金量。只知道西工大站地面积大，却不知有那么大，校园的小电驴要骑行近 2 小时才能浏览完其全貌，各种景色和建筑也都是堪称硬核与无法言表的，不知道的还以为是顶级公园 + 一流市中心呢。在天梯赛中有幸左右两大西工大护法，他们做起题来感觉就像玩一样，赛后简单交流，发现他们的 C++我甚至有些看不懂 🥹，西工大人不仅学习好，而且文明热情。当我问朋友何尊组雕位置时，碰巧被本校学生听到，主动为我们介绍、指路，真是太爱了。现在想想我的学校那都是些什么啊？走在路上全是不文明的行为，不多说懂得都懂。除西工大外（偷偷告诉你，西工大公众号可以直接预约参观哦~），还有还多名校未曾接触，还有很多认知之外的事情……想去吗，得分够啊！所以 <strong>一个好的环境和氛围是靠高考分换来的，你说学习重要吗？</strong></p><p>高中的分很重要，那么大学呢？我不了解像西工大那些名校的相关培养，但是我能保守的说，像二本甚至一些一本，课堂上传授的知识基本上没用，对，你没有听错，就是没用！于我来说，老师讲一个学期的 C 语言（循环、判断、指针、结构体、文件等），我现在 3 天就能学完，甚至还有充足时间用来复习，最关键的是比课堂的更深刻、更深入，毕竟老师可不会讲地址空间、内存布局和字节对齐等。<strong>专业课传授的内容远不及企业入门的门槛！</strong> 好在遇到了一个讲的好的数据结构的老师，讲的虽好，但是还是太浅了，而且只有理论，没有实战啥也不是，试问讲台下能有 5 人能用代码实现吗？讲了一个学期的物理，从来没听过，考试前一天晚上才预习 😏，考试依旧高分通过，这就是应试教育吧。先声明不存在任何作弊，也不是老师捞人，是真的“预习”出来的，<strong>传授一下如何突击期末考试：只针对期末考试题型复习，不是学做题方法，而是记做题方法，记做题步骤、顺序、要点，不要问为什么，只要记就行了，记不下来的，背也要背下来，就相当于是一个背模板的过程，考前抽出 1 天时间，在这 1 天中能够专注 3-5 小时，基本上要通过期末考试都不是难事。</strong></p><p><strong>还有太多难说和说不清的，点到为止吧：学习很重要，学习不一定能改变你的命运，但不学习，你的命运一定不会改变，学习力、学习的能力，才永远是成功最关键的因素！</strong></p><blockquote><p><strong>像西工大、南昌大，他们的机房装的都是最新的 PyCharm 2025.2.1.1、IntelliJ IDEA Community Edition 2025.2.1、VS Code 等等，再看看我们学校用的什么：上古时期的电脑巨卡无比，当然这两年开始换新了，还在用上古时期的 VC 6.0、Dev-C++、eclipse。不多评价 👉🤣。</strong></p></blockquote><h2 id="万能的-B-站大学：更实用的“中国第三大高校”"><a href="#万能的-B-站大学：更实用的“中国第三大高校”" class="headerlink" title="万能的 B 站大学：更实用的“中国第三大高校”"></a>万能的 B 站大学：更实用的“中国第三大高校”</h2><p>众所周知，中国只有三种大学是有用的：985、211 和 B 站大学。在学习的征程中怎么能少得了 B 站这个利器，B 站原名哔哩哔哩，很多人只知道它是一个二次元的领地，殊不知他才是一个真正的学习软件！我大学后才知道 B 站，如果早一点知道，高考少说指定多几十分，多说就不要了（已是过去事 😮‍💨）。</p><p>想学的这里都有，关键是自己会不会去 B 站的搜索引擎搜索，否则再强大的工具也发挥不出他的作用。赶快把手机上的抖音卸载了吧，投入 B 站的怀抱，反正我从来没刷过抖音，我刷快手 🤣，不过后来也就只剩了一个 B 站，毕竟 B 站也能刷快手、抖音同款 🤣（说笑了，好好学习，不要天天刷视频，<strong>常刷降智，少刷放松</strong>）。</p><h2 id="不要贪“机哥”：一年半两次大修的血泪史"><a href="#不要贪“机哥”：一年半两次大修的血泪史" class="headerlink" title="不要贪“机哥”：一年半两次大修的血泪史"></a>不要贪“机哥”：一年半两次大修的血泪史</h2><p>2023 年 10 月入手的机械革命旷世 G16，当时也就是看到了机哥的性价比直接入手，不曾想，时至今日，这台陪伴了我 <strong>一年半的机哥已经经过两次大修了</strong>，第一次是 24 年 6 月，无缘无故电脑风扇狂转不停，返厂维修后直接也是换了硬件，再次拿到手时，电脑的数据已经全没了，摄像头也是莫名检测不到、用不了，而且一个铰链&#x2F;转轴还给干断了，这售后真是牛波一！<code>gitee</code> 的打卡也是断掉了 😭：</p><p><img src="https://zycs-img-8kd.pages.dev/v2/zNSFq6e.png" alt="image-20250522104218723"></p><p>时间来到 25 年 4 月，机哥又莫名其妙的开不开机到开机进不去系统，期间屏幕也是一直出现闪屏的状况，找到线下的维修店说是系统的原因，需要重做一个系统，但是那家店太黑了，我没同意。回来后，机哥突然能进系统了，检测不到一年的摄像头也是突然正常了，吓得我急忙备份文件……一个即将毕业的学长看了看说，他也是机哥，是机哥的锐龙系列，也有闪屏的情况，据他所说是显卡虚焊。在到后来的一次停电，正用着呢，机哥突然开始闪屏，我也是见怪不怪了，好在只停了一分钟的电，这里看来似乎又和电压不稳有关系。闪屏和系统问题是第二次大修 😡。</p><p><strong>我的机哥除了除了两次大修外，期间也是各种小问题不断，比如莫名的关机、死机、睡死、黑屏、闪屏等问题时有发生。这是我第一次选择机哥也是最后一次 😡！我的感受是除了性价比，什么都差！售后差！质量差！已经准备换了，所以，还没买电脑的朋友建议避雷一下机械革命！</strong></p><blockquote><p>如今终于换掉了机哥，把机哥挂上了京东回收，可惜了机哥完好的 4060 只换了 3000 米整，当时个人售卖 3500 时还有很多人抢，但是官方回收质检严格，正常人眼目测不到的划痕都能揪出来，加上较高的手续费，真是让个人卖家吃亏咯。同时也能说明 <strong>京东的二手数码比其他平台更可靠一些，建议买但不建议卖，个人卖家如果不是急需转手，最好还是不要通过第三方转手&#x2F;回收，就这样。</strong></p></blockquote><h2 id="一定要有一个自己实名长期使用的手机号！校园卡-vs-流量卡，哪个更划算？"><a href="#一定要有一个自己实名长期使用的手机号！校园卡-vs-流量卡，哪个更划算？" class="headerlink" title="一定要有一个自己实名长期使用的手机号！校园卡 vs 流量卡，哪个更划算？"></a>一定要有一个自己实名长期使用的手机号！校园卡 vs 流量卡，哪个更划算？</h2><p>在大学中，用到手机号的场景很多，比如，导员找不到你或是有急事会打电话，需要确保电话畅通；各类竞赛（传智杯、普通话等等）的报名，报名可能需要用手机号注册账号、比赛时间和题目信息会用手机短信通知、预留参赛信息等，需要保证手机通讯和收发验证码正常。下面是最最常用的场景——流量，出门在外，没有流量、上不了网的手机不就成板砖了吗？所以流量也很重要！我们学校的校园网&#x2F;卡有三个配置，大概在 50 米上下每月，价格偏贵、频繁卡顿、只支持一台设备、出省还无法使用，要毕业了各种阻挠销户，把消费者当韭菜割，最可气的是一堆卡商骗子用“抢课必须要校园网”“校园系统操作要校园网”等各种理由欺骗学生进行办理。我都学计算机了，这点小事还用得着校园网&#x2F;卡？</p><p>所以，如果有需求的朋友可以从 <a href="https://ym.ksjhaoka.com/?s=Kr8M3NTs212675">官方正规号卡</a> 办理一张大流量卡来应对，我使用的就是一张保号套餐和从 <a href="https://ym.ksjhaoka.com/?s=Kr8M3NTs212675">官方正规号卡</a> 办理的大流量卡，两张卡每月只需要贡献 <code>29 + 5</code> 米就有 <code>300+</code> 用不完的流量。相比校园网&#x2F;卡实惠太多，也没有各种麻烦的手续和套路，此外，都学计算机了，不得自己想想如何免费使用校园网 🤪。</p><blockquote><p><strong>需要注意的是：<a href="https://ym.ksjhaoka.com/?s=Kr8M3NTs212675">官方正规号卡</a> 其实就是我拿到的“推广资格”，我本人也是一直在用自己在这里办理的卡，里面其实是有很多不那么性价比的卡品的，应该是历史原因，运营商用来模糊视线用的，但不管什么时候都会存在几张极具性价比的卡，这需要我们慧眼识别，作为消费者要仔细阅读相关收费和配置说明等！我就是选到了真性价比的卡才使得每月流量用不完。</strong></p></blockquote><h2 id="校园常见消费陷阱：驾校与校园卡-网避坑指南"><a href="#校园常见消费陷阱：驾校与校园卡-网避坑指南" class="headerlink" title="校园常见消费陷阱：驾校与校园卡&#x2F;网避坑指南"></a>校园常见消费陷阱：驾校与校园卡&#x2F;网避坑指南</h2><p>我的大学听过的最大的传销就是驾校和校园卡，驾校总是会用各种谎言忽悠着你去报名，然而呢，学校的驾校场地小、车少，人却是非常多，这就导致每次去都得要排队，非常麻烦，报名前吹的各种服务，在报名后全都烟消云散，那么多人，谁管得上你对吧？而且对于大学生收费还不低，我们打折后是 <code>3980</code> 米 😲。还有不要通过一些“中间商”去报驾校，据我所知，中间商每介绍一个学员，就有 <code>500</code> 米的介绍费（相当于自己多交的 💴），自己拿着去吃点好、买点好的不香吗？更有介绍到隔壁学校里报驾校的，报了之后你就知道，去另一所学校考驾照是有多麻烦！不说外校门禁啥的，隔壁学校驾校倒闭了自己都不知道！某些学校和校内驾校有合作，有没有提成不知道，但是和学分挂钩，有人就心动了，其实没必要，也就 2 分学分，拿和不拿都不影响毕业，只要课程正常修满就能毕业，即使没满（不太过分的情况），甚至许多学校都会自动保证学分足够帮助学子毕业，学校嘛，总要保证这个毕业率、就业率啥的。</p><p><strong>所以建议要考驾照的朋友慎重考虑！我建议是最好在高考完的暑假快速拿证！如果错过了，就在大学期间挑一个寒暑假去专门考证，不要拖延！尽量在大学毕业前拿下驾照。尽量不要在学校报驾校，直接自己在家附近找或者去外面找，怎么方便怎么来，理性判断，多方比价，避免因信息不对称而吃亏。驾照和学分挂钩的话更要理性看待，当然，如果你学校驾校很好，当我没说。</strong></p><p>其次就是所谓的校园卡&#x2F;网，他们总是会拿着没有校园卡&#x2F;网请不了假、抢不了课、进不了教务&#x2F;校园系统等之类的谎言欺骗学生去办卡办网，这些人相当一部分都不是校内人员、业务人员，属于社会闲散人士或代理等，多出现新生入学阶段。据我所知，我们学校的校园卡出了省就用不了了，校园网出了学校用不了自然不用多说（但在学校也经常卡，甚至某些楼用不了）。价格算不上很高，仅支持一台设备，完全没有性价比，甚至某些学校存在毕业时各种理由不让销户，销户还得回学校，麻不麻烦吧？真是离了个大谱！所以本人选择在 <a href="https://ym.ksjhaoka.com/?s=Kr8M3NTs212675">官方正规号卡</a> 直接办理大流量卡，能抢课也能进教务系统，最重要的是月租 <code>29</code> 米流量用不完，网速嘎嘎快，支持线上销户，就没有那么多麻烦事。</p><p><strong>校园网&#x2F;卡建议理性看待，根据自身实际需求选择，毕业前及时销户，避免后续销户、消费透支等问题。有技术的可以尝试如何免费使用校园网 🤪。</strong></p><h2 id="账号管理翻车：不要随意注册莫名网站的莫名账号"><a href="#账号管理翻车：不要随意注册莫名网站的莫名账号" class="headerlink" title="账号管理翻车：不要随意注册莫名网站的莫名账号"></a>账号管理翻车：不要随意注册莫名网站的莫名账号</h2><p>如今我的浏览器记录了 107 个站点和 134 个账密，以前也不知道为什么会去各种站点进行账号注册，导致现在有很多用处不大网站的账号，虽然并不影响日常使用，可能我有强迫症吧，就是不用就不想要这些账号，有相同“强迫症”的朋友一定不要直接注册账号，因为有可能网站 <strong>不支持删除账户</strong>，这里点名一下 C 语言中文网（现在都是跟着视频学习，这个网站基本用不上）和 <code>PTA</code>（程序设计类实验辅助教学平台）等。<strong>不用账号最好及时销户，一方面会避免未来隐私泄露的问题，另一方面可以减少个人名下所有账户的管理。</strong> 像牛客、力扣、洛谷、PTA、CSDN、gitee、GitHub、蓝桥云客、微软、谷歌等比较知名的直接注册就好，没什么问题，只需要注意一下部分“奇奇怪怪”的站点。</p><p><strong>总之，注册一些不了解、鲜为人知的网站时，可以使用临时邮箱&#x2F;小号&#x2F;测试号&#x2F;无用号进行注册，再考虑是否需要注册长期使用的账号。个人比较倾向于临时邮箱，现在市面上有很多临时邮箱服务，大部分也是免费的，目前个人使用的临时邮箱有 <a href="https://tempmail100.com/">Temp Mail 100 </a>、<a href="https://temp-mail.org/">Temp-mail</a> 等，这些临时邮箱真的是很棒的产品！临时邮箱的作用远不止于此！还有一种情况：选择使用 <code>GitHub</code> 登录还是 谷歌账号 登录，建议进行统一，账号一多，自己都不知道哪些是 <code>GitHub</code> 登录的还是谷歌登录的。再推荐一个好习惯：尽量在确认账号长期使用后，将账号和微信&#x2F;邮箱&#x2F;QQ&#x2F;谷歌&#x2F;GitHub 等进行关联，避免重复或遗忘账号，并且账密做备份，浏览器也好，其他备份也好，总之一定要备份！！</strong></p><h2 id="导员一定可信吗？大学里的“善意谎言”！"><a href="#导员一定可信吗？大学里的“善意谎言”！" class="headerlink" title="导员一定可信吗？大学里的“善意谎言”！"></a>导员一定可信吗？大学里的“善意谎言”！</h2><p>那还真不一定！虽然是导员，但是导员也要服从学校的意思、传达学校的统一要求，这就可能会使导员无法完全兼顾立场考虑问题，导致信息的传达方式、内容有所偏差，从我们学生的立场来看就是玩文字游戏和详略不符、弱化最真实的情况和信息，当然，这也不能全怪导员，毕竟很多导员就是自己历届的学长学姐，他们难免有不知如何处理和处理不周的情况，<strong>如何避免？对于自己不确定的信息及时和导员、相关老师等进行沟通！</strong></p><h2 id="不要虚荣奖项，那些“水奖”真的有用吗？"><a href="#不要虚荣奖项，那些“水奖”真的有用吗？" class="headerlink" title="不要虚荣奖项，那些“水奖”真的有用吗？"></a>不要虚荣奖项，那些“水奖”真的有用吗？</h2><p><strong>这里说的是那些不知名、没有实际意义的“奖项”。</strong> 那么什么才算是呢？比如（部分属于我在志愿者中被部长硬性要求）：</p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Blog/20250421223123887.png"></p><p><strong>反正就是 任何不费吹灰之力就能得到的奖项都没用！ 简单想一下，如果不用努力、不费力气得来的奖项真的有用吗？真的有含金量吗？而且上面这些所谓的奖项已经替你们试过了，学校不认，不能加学分，唯一的作用就是满足自己的虚荣心。</strong></p><h2 id="平板有没有必要入手？"><a href="#平板有没有必要入手？" class="headerlink" title="平板有没有必要入手？"></a>平板有没有必要入手？</h2><p>我告诉你如果会用平板打游戏才有必要入手，不要说什么“手机屏幕太小”、“用平板做笔记&#x2F;学习”、“用平板编码”等等，因为我之前也是这么想的，最后无奈把平板放哪吃灰了，什么屏幕小、编码体验都不如电脑，大学做笔记？首先自己要想要会去做非专业课的笔记，其次编程方面哪有什么笔记，不如实操。<strong>感觉平板这个定位就很尴尬，不如手机方便，功能不如电脑，建议没有实际需求的就不要入手！非要入手几百块的配置就够了，或者直接选二手，超过 1000 的不打游戏基本上是大材小用&#x2F;吃灰了。</strong></p><h2 id="为什么逃课要趁早？"><a href="#为什么逃课要趁早？" class="headerlink" title="为什么逃课要趁早？"></a>为什么逃课要趁早？</h2><p><strong>声明：不提倡逃课，而提倡的是合理规划课堂时间或在保证学业底线的前提下，优先投入高价值学习！</strong></p><p>我大一很老实，认认真真的上课、学习，一节课都没旷，成绩班级前三，但是没什么用，<strong>大部分是水课</strong>，典型代表：大学生社会劳动实践中教我们如何叠被子、洗衣服，我想这应该是四肢退化的才需要的吧……。我同级的朋友大一旷课自学，大二就已经开始找实习、找工作了。再看看我，除了课堂上无用的知识，什么都不会，现在后悔了，大二上才旷了几节课，大二下就全是小班授课，还碰上学校年度评估，抓得更紧了，无奈只能老老实实的上完这无用、枯燥和煎熬的课程。</p><p><strong>所以，旷课要乘早，但是旷课要有意义，不能旷课去玩，而是旷课学习！如果实在旷不了，那就把电脑带进教室，上课随便学点（实测老师的干扰专不下心，建议写博客&#x2F;算法题），正常来说和专业相关的课程，老师不会说什么，但是像数学、政治、英语慎重！切记：在课上自己学自己的就行，不要干扰他人，也不要被干扰，更不要主动去和任课老师说自学的事！！这就像是大学的潜规则，你自己学不学无所谓，但是自己指明了不听课，刁钻的老师就是会不同意，而且可能留下不太好的印象！</strong></p><h2 id="奖学金、助学金、团员、党员、绩点怎么选？"><a href="#奖学金、助学金、团员、党员、绩点怎么选？" class="headerlink" title="奖学金、助学金、团员、党员、绩点怎么选？"></a>奖学金、助学金、团员、党员、绩点怎么选？</h2><p><strong>这部分内容比较敏感，所以叙述上会比较委婉，但请屏幕前的你高度警示！先说结论：越早越好！推荐大一、二想争取的去争取！</strong></p><p>奖学金的评定和成绩、奖项、他人评价等挂钩；助学金和家庭情况挂钩；团员、党员和相关考试、他人评价挂钩；绩点自然就和成绩挂钩。但实际，这里面“<strong>水很深</strong>”！！！下面是基于 <strong>我的经历</strong> 总结的：</p><p>先说 <strong>奖学金大一、二是比较好拿到的</strong>。前期大家基本上没有奖项，大家也基本上不熟悉、不认识（评分大差不差），所以成绩、个人表现和学校&#x2F;班级职位占大头，稍好一点基本上就有了。到了后期相当一部分人不学，每逢考试都是作弊的，手机、小抄、雷同屡见不鲜，这部分人的成绩、绩点就上升了；通过购买、团队躺赢、AI 作弊等手段就能获得诸多有用没用的奖项，我印象很深刻，学校中存在一位 “AI 哥”，逢作弊被抓，已是臭名远扬，但奈何没被抓的奖项也蛮多；各种社团等乱七八糟的内推甚至内定，和学姐学长交好可获得职务；有些班级“小团体”早就穿上一条裤子了，有说好话、人情、收买……导致评价上升。单方面提升其实作用不大，但是多方面提升影响就很大！</p><p>助学金本是帮助家庭困难的学生，却被不贫困的人拿去挥霍。大一可能碍于面子没人要，过一年就能变抢手！渐渐就会发现申请书上的负债越来越高，理由越来越离谱，名额不够，只能按投票，给穿“一条裤子”的小团体有了可乘之机，拿到 💴 后，小团体就会聚餐挥霍等，少数情况会按照导员意见&#x2F;成绩排名等选择，但这并不意味着公平公正了 🤐。只有身在局中才能看清真相，大家心里大概都知道谁困难需要帮助，奈何受不住诱惑，以至于助学金失却了它本来的意义……明事理的都知道这是不公的，但大家都是普通人，结局可想而知……所以，<strong>助学金最公平的时期只有大一</strong>。</p><p><strong>团员最好获得的时间是大学之前</strong>，大学之前，团员的名额基本上掌握在班主任手里的，评选资格大概率是以成绩，公平的是成绩，不公平的呢？班主任谎报名额、关系户等，我记得很清楚，初中有个混混和他的班主任是亲戚，结果不用多说。其次是在大学，<strong>获取团员、党员次要时间是大学期间</strong>，大学的入团、入党要先考试，但可能存在多年试题一模一样的情况！这就又会出现背答案、科技很活儿等舞弊情况，后续只要谈话等流程没问题就通过了。未来进入社会才是入团入党最困难的时刻，因为很多企业没有党政办公室的部门。</p><p>绩点也就是成绩，这就各凭本事了，有人苦苦夜读，有人科技创新，还有互利共赢……</p><p><strong>这部分水很深，拿捏不住，建议放弃。有时放弃也是一种选择，像我这种就是典型的不评奖不评优、不入团入党，也少问世事，圈子分明，不为自己求麻烦也挺好的。一心打磨技术，力求找好工作，大家各有所得也各有所失，向各自的真理迈进，岂不快哉？</strong></p>]]></content>
      
      
      <categories>
          
          <category> 历程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 历程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>027 动静态库 —— 静态库</title>
      <link href="/posts/6493.html"/>
      <url>/posts/6493.html</url>
      
        <content type="html"><![CDATA[<h2 id="动静态库-——-静态库"><a href="#动静态库-——-静态库" class="headerlink" title="动静态库 —— 静态库"></a>动静态库 —— 静态库</h2><blockquote><p><a href="https://juejin.cn/post/7202060340725268539?searchId=202505131912544909ED61C0FBE9050869#heading-17">稀土掘金 | 动静态库的认识</a></p><p><a href="https://blog.csdn.net/2301_77900444/article/details/144778074">CSDN | 理解文件系统|文件缓冲区|软硬链接|动静态库</a></p><p><a href="https://blog.csdn.net/chenlong_cxy/article/details/121009923">CSDN | 相关好文</a></p><p><a href="https://blog.csdn.net/2301_80220607/article/details/145066627">CSDN | 相关好文</a></p></blockquote><h3 id="1-扩展概要（了解）"><a href="#1-扩展概要（了解）" class="headerlink" title="1. 扩展概要（了解）"></a>1. 扩展概要（了解）</h3><p><strong>一个文件被打开操作系统要做什么：打开文件的流程 &#x3D; 找 <code>inode</code> ➜ 创建 <code>file</code> 结构 ➜ 建立缓冲 ➜ 用页表映射读写 ➜ 后续 <code>read</code>&#x2F;<code>write </code> 就操作 <code>page</code> 缓冲。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250514202820407.png" alt="image-20250514202813281"></p><h4 id="1-为什么说“4KB-Page”是核心单位？"><a href="#1-为什么说“4KB-Page”是核心单位？" class="headerlink" title="1. 为什么说“4KB Page”是核心单位？"></a>1. 为什么说“4KB Page”是核心单位？</h4><p>现代操作系统使用 <strong>分页机制（Paging）</strong> 管理内存，每一页（Page）是 <strong>一块固定大小的内存单元</strong>。Linux 默认：</p><ul><li>一页大小为 <strong>4KB</strong>。</li><li>物理内存也以页框为单位分配（如 Frame #0，Frame #1…）。</li><li>所有虚拟内存地址映射到物理内存页框时，以 4KB 为基本单位。</li></ul><table><thead><tr><th>地址空间</th><th>页面大小</th><th>含义</th></tr></thead><tbody><tr><td>虚拟地址空间</td><td>4KB&#x2F;page</td><td>每个进程有自己的虚拟地址空间</td></tr><tr><td>物理内存</td><td>4KB&#x2F;frame</td><td>物理内存被划分为一个个页框</td></tr><tr><td>页面表（Page Table）</td><td></td><td>将虚拟页映射到物理页框</td></tr></tbody></table><blockquote><p>  <strong>所以：所有读写、分配、预加载、换页，都是以“页”为单位处理的！</strong></p></blockquote><hr><h4 id="2-局部性原理？为什么和-4KB-页有关？"><a href="#2-局部性原理？为什么和-4KB-页有关？" class="headerlink" title="2. 局部性原理？为什么和 4KB 页有关？"></a>2. 局部性原理？为什么和 4KB 页有关？</h4><p>局部性原理包括：</p><ol><li><strong>时间局部性</strong>（Temporal Locality）：刚访问的数据，可能马上还会用。</li><li><strong>空间局部性</strong>（Spatial Locality）：访问了地址 A，可能马上会访问 A 附近的数据。</li></ol><p><strong>为什么用 4KB？</strong></p><ul><li>如果你访问了一个变量 <code>a</code>，操作系统会把 <strong>整个 4KB 页</strong> 都读进内存（或者缓存）；</li><li>这个 4KB 的空间里，<strong>很可能包含你接下来会访问的变量 <code>b, c, d</code></strong>；</li><li>这样可以极大提升性能：只需要一次 IO，就加载一大片“可能用到的数据”。</li></ul><blockquote><p>磁盘文件（假设 8KB）：[0<del>4KB]  [4</del>8KB] （2 个块）</p><ul><li>内核发现 <code>[0~4KB]</code> 不在页缓存中。触发磁盘读取，加载整个 <code>[0~4KB]</code> 块到内存（即使只访问 1 字节）。存入页缓存，供后续快速访问。（访问第 1 字节 ➜ 内核页缓存判断没有 ➜ 从磁盘读 <code>[0~4KB]</code> ➜ 存入页缓存）</li><li>继续访问第 3KB 字节 ➜ 命中页缓存 ➜ 直接返回（<code>[0~4KB]</code> 已在页缓存中，<strong>直接返回数据</strong>（无需磁盘 IO）。）</li><li>访问第 5KB 字节 ➜ 没有命中 ➜ 再从磁盘读 <code>[4~8KB]</code>（<code>[4~8KB]</code> 不在页缓存中，<strong>再次触发磁盘读取</strong>，加载整个 <code>[4~8KB]</code> 块到内存。）</li></ul></blockquote><table><thead><tr><th>问题</th><th>回答</th></tr></thead><tbody><tr><td>打开 1KB 文件会读取多少？</td><td>最少读取 4KB</td></tr><tr><td>多出来 3KB 是什么？</td><td>文件中后续的数据</td></tr><tr><td>是怎么加载的？</td><td>从磁盘块读取并映射到页缓存</td></tr><tr><td>多出来的内容从哪加载？</td><td>从磁盘上一次性读取 4KB 的块（block）加载进来</td></tr><tr><td>为什么这么设计？</td><td>为了性能，利用局部性原理进行预读</td></tr><tr><td>如果文件只有 1KB 呢？</td><td>剩下部分为空白，但页缓存仍然占用 4KB</td></tr></tbody></table><hr><h4 id="3-文件打开后是否每次都从磁盘读取？"><a href="#3-文件打开后是否每次都从磁盘读取？" class="headerlink" title="3. 文件打开后是否每次都从磁盘读取？"></a>3. 文件打开后是否每次都从磁盘读取？</h4><p><strong>不是！Linux 有一个机制叫做：页缓存（Page Cache）。把文件内容按“页”读取后，缓存到内存中。</strong></p><ul><li>文件第一次打开时，会将所需部分 <strong>加载到内存页缓存（struct page）中</strong>。</li><li>之后对文件的 <code>read</code>、<code>write</code> 操作，<strong>都直接在内存中进行</strong>，不再频繁访问磁盘。</li></ul><hr><h4 id="4-每个打开的文件都会分配什么？"><a href="#4-每个打开的文件都会分配什么？" class="headerlink" title="4. 每个打开的文件都会分配什么？"></a>4. 每个打开的文件都会分配什么？</h4><table><thead><tr><th>对象</th><th>含义</th></tr></thead><tbody><tr><td><code>struct file</code></td><td>表示这次“打开”</td></tr><tr><td><code>struct inode</code></td><td>表示文件的“元数据”（公共）</td></tr><tr><td>页缓存（Page）</td><td>对应的文件内容存到内存的页中</td></tr><tr><td>缓冲区（Buffer）</td><td>应用层的输入输出缓冲区</td></tr></tbody></table><blockquote><p>  所以：每个打开的文件，不管在哪个进程中，都有自己的“打开实例”，但共享 <code>inode</code> 和缓存页。</p></blockquote><hr><h4 id="5-Linux-如何管理所有内存？"><a href="#5-Linux-如何管理所有内存？" class="headerlink" title="5. Linux 如何管理所有内存？"></a>5. Linux 如何管理所有内存？</h4><p>Linux 会维护一个大的 <code>mem_map[]</code> 数组，里面是所有 <strong>物理内存页的描述结构 <code>struct page</code></strong>。</p><ul><li>每当程序申请内存，都会通过虚拟地址查找页表，映射到 <code>mem_map[i]</code> 对应的页框。</li><li><code>mem_map[i]</code> 就表示第 i 个物理页框的属性（是否空闲、是否缓存文件、是否在使用等）。</li></ul><hr><h4 id="6-操作系统能看到物理地址吗？"><a href="#6-操作系统能看到物理地址吗？" class="headerlink" title="6. 操作系统能看到物理地址吗？"></a>6. 操作系统能看到物理地址吗？</h4><p>操作系统自己可以看见物理地址，但应用程序不行。</p><ul><li>每个进程只能访问自己的 <strong>虚拟地址空间</strong>；</li><li>操作系统通过 <strong>页表机制</strong> 管理虚拟地址 → 物理地址的映射；</li></ul><blockquote><p>  <strong>所以现代操作系统的内存与文件缓存管理，都是基于“4KB 页”为单位，结合“局部性原理”和“分页机制”来提高性能和效率。</strong></p><p>  <img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250514204626220.png" alt="image-20250514204626090"></p></blockquote><hr><h3 id="2-动静态库"><a href="#2-动静态库" class="headerlink" title="2. 动静态库"></a>2. 动静态库</h3><h4 id="1-库的制作者-如何制作静态库？"><a href="#1-库的制作者-如何制作静态库？" class="headerlink" title="1. 库的制作者 如何制作静态库？"></a>1. 库的制作者 如何制作静态库？</h4><p>步骤如下：</p><ul><li><p>① 编写 <code>.c</code> 实现和 <code>.h</code> 头文件：对外接口声明和函数的实现。</p></li><li><p>② 使用 <code>gcc -c</code> 编译为目标文件（.o）：<code>gcc -c MyStaticLibrary.c -o MyStaticLibrary.o</code>。</p></li><li><p>③ 使用 <code>ar</code> 命令打包创建静态库 <code>.a</code>：<code>ar -rc My_static_library.a My_static_library.o</code>。</p></li><li><p>④ 组织输出目录（可选）：</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p lib/include lib/My_static_library_lib</span><br><span class="line"><span class="built_in">cp</span> *.h lib/include/</span><br><span class="line"><span class="built_in">cp</span> *.a lib/My_static_library_lib/</span><br></pre></td></tr></table></figure><h4 id="2-静态库-demo"><a href="#2-静态库-demo" class="headerlink" title="2. 静态库 demo"></a>2. 静态库 <code>demo</code></h4><h5 id="1-My-static-library-h-（头文件）——-对外接口声明"><a href="#1-My-static-library-h-（头文件）——-对外接口声明" class="headerlink" title="1. My_static_library.h （头文件）—— 对外接口声明"></a>1. <code>My_static_library.h</code> （头文件）—— 对外接口声明</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once                    <span class="comment">// 防止头文件被重复包含</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>             <span class="comment">// 引入标准库（虽然这个例子中不一定需要）</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> myerrno;            <span class="comment">// 声明一个全局变量，用于错误码（比如除0错误）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数声明：提供加、减、乘、除功能</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>;         <span class="comment">// 加法</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sub</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>;         <span class="comment">// 减法</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mul</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>;         <span class="comment">// 乘法</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">div</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>;         <span class="comment">// 除法（除数为0时返回-1，并设置myerrno=1）</span></span><br></pre></td></tr></table></figure><h5 id="2-My-static-library-c（源文件）——-函数定义-错误处理"><a href="#2-My-static-library-c（源文件）——-函数定义-错误处理" class="headerlink" title="2. My_static_library.c（源文件）—— 函数定义 + 错误处理"></a>2. <code>My_static_library.c</code>（源文件）—— 函数定义 + 错误处理</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;My_static_library.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> myerrno = <span class="number">0</span>;               <span class="comment">// 定义全局错误码变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sub</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x - y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mul</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">div</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (y == <span class="number">0</span>)                <span class="comment">// 检查除数是否为0</span></span><br><span class="line">    &#123;</span><br><span class="line">        myerrno = <span class="number">1</span>;           <span class="comment">// 设置错误码</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;             <span class="comment">// 返回错误标识</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x / y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-Makefile-文件-——-构建静态库的自动化脚本"><a href="#3-Makefile-文件-——-构建静态库的自动化脚本" class="headerlink" title="3. Makefile 文件 —— 构建静态库的自动化脚本"></a>3. <code>Makefile</code> 文件 —— 构建静态库的自动化脚本</h5><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 目标静态库名称</span></span><br><span class="line">lib = My_static_library.a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建静态库目标：由目标文件构建 .a 文件</span></span><br><span class="line"><span class="variable">$(lib)</span>: My_static_library.o</span><br><span class="line">ar -rc <span class="variable">$@</span> <span class="variable">$^</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成 .o 目标文件</span></span><br><span class="line"><span class="section">My_static_library.o: My_static_library.c</span></span><br><span class="line">gcc -c <span class="variable">$^</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 清理构建产物</span></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm -rf *.o *.a lib</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出头文件和库文件到标准目录</span></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: output</span></span><br><span class="line"><span class="section">output:</span></span><br><span class="line">    mkdir -p lib/<span class="keyword">include</span>                        <span class="comment"># 创建头文件目录</span></span><br><span class="line">mkdir -p lib/My_static_library_lib          <span class="comment"># 创建库文件目录</span></span><br><span class="line">cp *.h lib/<span class="keyword">include</span>                          <span class="comment"># 复制头文件</span></span><br><span class="line">cp *.a lib/My_static_library_lib          <span class="comment"># 复制静态库文件</span></span><br></pre></td></tr></table></figure><hr><h4 id="3-库的使用者-如何使用静态库？"><a href="#3-库的使用者-如何使用静态库？" class="headerlink" title="3. 库的使用者 如何使用静态库？"></a>3. 库的使用者 如何使用静态库？</h4><h5 id="1-假设目录结构如下："><a href="#1-假设目录结构如下：" class="headerlink" title="1. 假设目录结构如下："></a>1. 假设目录结构如下：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── lib</span><br><span class="line">│   ├── include</span><br><span class="line">│   │   └── My_static_library.h</span><br><span class="line">│   └── My_static_library_lib</span><br><span class="line">│       └── My_static_library.a</span><br><span class="line">├── makefile</span><br><span class="line">├── My_static_library.a</span><br><span class="line">├── My_static_library.c</span><br><span class="line">├── My_static_library.h</span><br><span class="line">├── My_static_library.o</span><br><span class="line">└── test_main.c</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250520203815146.png" alt="image-20250520203807988"></p><h5 id="2-test-main-c-示例："><a href="#2-test-main-c-示例：" class="headerlink" title="2. test_main.c 示例："></a>2. test_main.c 示例：</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;My_static_library.h&quot;</span>  <span class="comment">// 包含头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;add(3, 4) = %d\n&quot;</span>, add(<span class="number">3</span>, <span class="number">4</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;div(10, 0) = %d\n&quot;</span>, div(<span class="number">10</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (myerrno == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error: Divide by zero\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>编译命令说明：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o <span class="built_in">test</span> test_main.c -I.lib/include -L./lib/My_static_library_lib -l:My_static_library.a</span><br></pre></td></tr></table></figure><table><thead><tr><th align="left">选项</th><th align="left">作用</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>-I.lib/include</code></td><td align="left">指定头文件搜索路径</td><td align="left">确保 <code>My_static_library.h</code> 能被 <code>#include</code> 找到</td></tr><tr><td align="left"><code>-L./lib/My_static_library_lib</code></td><td align="left">指定库文件搜索路径</td><td align="left"><code>.</code> 表示当前目录（即 <code>./My_static_library.a</code>）</td></tr><tr><td align="left"><code>-l:My_static_library.a</code></td><td align="left">直接链接指定的 <code>.a</code> 文件</td><td align="left"><code>:</code> 表示精确匹配文件名，直接指定库文件名，而非默认的 <code>libxxx.a</code> 格式</td></tr></tbody></table><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250520205029950.png" alt="image-20250520205029824"></p><p><strong>小技巧（调试辅助）：</strong></p><ul><li><p>查看 <code>.a</code> 文件里的内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ar -t My_static_library.a</span><br></pre></td></tr></table></figure></li><li><p>若静态库升级，记得重新编译目标文件和链接。</p></li></ul><hr><h3 id="3-总结：制作者-使用者视角速查表"><a href="#3-总结：制作者-使用者视角速查表" class="headerlink" title="3. 总结：制作者 &amp; 使用者视角速查表"></a>3. 总结：制作者 &amp; 使用者视角速查表</h3><table><thead><tr><th>角色</th><th>步骤</th><th>命令或说明</th></tr></thead><tbody><tr><td><strong>制作者</strong></td><td>编写 Header&#x2F;Source</td><td><code>My_static_library.h</code>&#x2F;<code>My_static_library.c</code></td></tr><tr><td></td><td>生成目标文件(.o)</td><td><code>gcc -c My_static_library.c -o My_static_library.o</code></td></tr><tr><td></td><td>打包静态库(.a)</td><td><code>ar -rc My_static_library.a My_static_library.o</code></td></tr><tr><td></td><td>分发库与头文件</td><td><code>mkdir -p lib/include lib/lib &amp;&amp; cp *.h lib/include/ &amp;&amp; cp *.a lib/lib/</code></td></tr><tr><td><strong>使用者</strong></td><td>包含头文件 (include)</td><td><code>#include &quot;My_static_library.h&quot;</code></td></tr><tr><td></td><td>编译链接形成可执行程序</td><td><code>gcc -o test test_main.c -I.lib/include -L./lib/My_static_library_lib -l:My_static_library.a</code></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 地址空间 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>026 inode 与软硬链接</title>
      <link href="/posts/6239.html"/>
      <url>/posts/6239.html</url>
      
        <content type="html"><![CDATA[<h2 id="inode-与软硬链接"><a href="#inode-与软硬链接" class="headerlink" title="inode 与软硬链接"></a>inode 与软硬链接</h2><p>先说明一下前面没有解释的东西：文件权限后面的 <code>1</code> 是什么？</p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250511124056848.png" alt="image-20250511124049719"></p><h3 id="1-软链接（Symbolic-Link-Symlink）"><a href="#1-软链接（Symbolic-Link-Symlink）" class="headerlink" title="1. 软链接（Symbolic Link &#x2F; Symlink）"></a>1. 软链接（Symbolic Link &#x2F; Symlink）</h3><h4 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h4><p>软链接是一个特殊类型的文件，它的内容是一个 <strong>路径字符串</strong>，指向原始文件的路径。</p><ul><li><strong>就像 Windows 的 快捷方式；</strong></li><li><strong>保存的是目标路径</strong>；</li><li>用途：可以在任何地方“引用”一个程序、配置文件、目录；</li><li><strong>常用于：</strong><ul><li>给程序创建入口路径（比如 <code>/usr/bin/python</code> 链接到 <code>/usr/bin/python3.11</code>）；</li><li>让你在任意位置执行程序；</li><li>多个配置环境之间切换。</li></ul></li></ul><table><thead><tr><th>特性</th><th>描述</th></tr></thead><tbody><tr><td>inode 不一致</td><td>链接文件有自己的 inode，数据内容是“路径名”</td></tr><tr><td>可跨分区</td><td>因为只是保存路径字符串，不依赖 inode</td></tr><tr><td>可对目录使用</td><td>如 <code>/usr/bin/python</code> 链接到 <code>/usr/bin/python3.11</code></td></tr><tr><td>不影响原文件</td><td>原文件不变，软链接只是一个指向的“引用”</td></tr></tbody></table><h4 id="2-相关命令"><a href="#2-相关命令" class="headerlink" title="2. 相关命令"></a>2. 相关命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ln</span> -s 源文件或目录 软链接文件名</span><br><span class="line"><span class="built_in">ln</span> -s /真实路径/程序 /usr/local/bin/程序名</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ln</span> -s /usr/bin/python3 /usr/local/bin/python</span><br><span class="line"><span class="comment"># 相当于：给 /usr/bin/python3 创建一个快捷方式，命名为 python，放到 /usr/local/bin/，让你直接用 python 执行。</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -li<span class="comment"># 显示文件的 inode 编号以及其它详细信息</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250511131522514.png" alt="image-20250511131522366"></p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250511131957204.png" alt="image-20250511131957126"></p><p><strong>删除软链接：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> 软链接路径（快捷方式的名称）</span><br><span class="line"><span class="built_in">rm</span> text<span class="comment"># 只删除test对应的软链接，不影响原文件！</span></span><br></pre></td></tr></table></figure><h4 id="3-软链接断裂检测"><a href="#3-软链接断裂检测" class="headerlink" title="3. 软链接断裂检测"></a>3. 软链接断裂检测</h4><p>软链接如果原始文件删除，会变成“悬挂链接”。</p><p><strong>检测方法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -<span class="built_in">type</span> l ! -<span class="built_in">exec</span> <span class="built_in">test</span> -e &#123;&#125; \; -<span class="built_in">print</span><span class="comment"># 找出指向无效文件的软链接。</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250511140346914.png" alt="image-20250511140346798"></p><h4 id="4-使用场景"><a href="#4-使用场景" class="headerlink" title="4. 使用场景"></a>4. 使用场景</h4><ul><li>配置文件切换（配置环境切换只改软链接）</li><li>多版本程序切换（如 python2 ↔ python3）</li><li>日志链接（如将 <code>/var/log/nginx/access.log</code> 链接到别的目录）</li></ul><hr><h3 id="2-硬链接（hard-link）"><a href="#2-硬链接（hard-link）" class="headerlink" title="2. 硬链接（hard link）"></a>2. 硬链接（hard link）</h3><h4 id="1-概念-1"><a href="#1-概念-1" class="headerlink" title="1. 概念"></a>1. 概念</h4><p><strong>所谓的建立硬链接，本质其实就是在特定目录的数据块中新增文件名和指向的文件的 <code>inode</code> 编号的映射关系！</strong></p><ul><li>是给文件 <strong>起一个新名字</strong>，指向 <strong>同一个内容（inode）</strong>；</li><li>就像给一篇文章起了两个标题，内容一模一样；</li><li>删除“原始文件”不会丢内容，因为还有另一个“标题”指向同一内容；</li><li><strong>不能跨分区，不能用于目录</strong>。</li></ul><table><thead><tr><th>特性</th><th>描述</th></tr></thead><tbody><tr><td>inode 不一致</td><td>链接文件有自己的 inode，数据内容是“路径名”</td></tr><tr><td>可跨分区</td><td>因为只是保存路径字符串，不依赖 inode</td></tr><tr><td>可对目录使用·</td><td>如 <code>/usr/bin/python</code> 链接到 <code>/usr/bin/python3.11</code></td></tr><tr><td>不影响原文件</td><td>原文件不变，软链接只是一个指向的“引用”</td></tr></tbody></table><h4 id="2-相关命令-1"><a href="#2-相关命令-1" class="headerlink" title="2. 相关命令"></a>2. 相关命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ln</span> 原文件 硬链接名</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ln</span> myfile.txt myfile2.txt<span class="comment"># myfile.txt 和 myfile2.txt 指向同一个 inode，内容完全一样。</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250511172443361.png" alt="image-20250511172443257"></p><p><strong>删除硬链接：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> myfile.txt<span class="comment"># 内容不会被删除，只是链接计数 -1，除非所有硬链接都删光，才会真的释放 inode 和数据块。</span></span><br></pre></td></tr></table></figure><h4 id="3-使用场景"><a href="#3-使用场景" class="headerlink" title="3. 使用场景"></a>3. 使用场景</h4><ul><li>保留日志数据：删除前先做一个硬链接</li><li>防止误删重要配置文件</li><li>建立多个文件名访问同一内容的“别名”</li></ul><hr><h3 id="3-对比总结表"><a href="#3-对比总结表" class="headerlink" title="3. 对比总结表"></a>3. 对比总结表</h3><table><thead><tr><th>特性</th><th>软链接 (Symbolic Link)</th><th>硬链接 (Hard Link)</th></tr></thead><tbody><tr><td>指向目标</td><td>指向路径</td><td>指向 inode</td></tr><tr><td>是否可跨分区</td><td>✅ 是</td><td>❌ 否</td></tr><tr><td>是否可对目录使用</td><td>✅ 是</td><td>❌ 否</td></tr><tr><td>删除原文件是否失效</td><td>✅ 会失效断裂（变为悬挂链接）</td><td>❌ 不会，不影响内容</td></tr><tr><td>inode 是否相同（共享）</td><td>❌ 否</td><td>✅ 是</td></tr><tr><td>使用场景</td><td>环境切换、目录链接、动态路径引用</td><td>防止误删、节省空间</td></tr></tbody></table><hr><h3 id="4-软硬链接对目录能否使用的原理"><a href="#4-软硬链接对目录能否使用的原理" class="headerlink" title="4. 软硬链接对目录能否使用的原理"></a>4. 软硬链接对目录能否使用的原理</h3><blockquote><p>任意一个文件，无论是目录，还是普通文件，都有 <code>inode</code>，目录里面保存的是：文件名和 <code>inode</code> 编号的映射关系。</p></blockquote><h4 id="1-为什么硬链接不能对目录使用-——-Linux-内核禁止对目录创建硬链接"><a href="#1-为什么硬链接不能对目录使用-——-Linux-内核禁止对目录创建硬链接" class="headerlink" title="1. 为什么硬链接不能对目录使用 —— Linux 内核禁止对目录创建硬链接"></a>1. 为什么硬链接不能对目录使用 —— Linux 内核禁止对目录创建硬链接</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ln</span> /etc /tmp/etc_hardlink</span><br></pre></td></tr></table></figure><p>会报错：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ln</span>: hard <span class="built_in">link</span> not allowed <span class="keyword">for</span> directory<span class="comment"># 目录不允许硬链接</span></span><br></pre></td></tr></table></figure><h5 id="原因-1：防止目录结构循环"><a href="#原因-1：防止目录结构循环" class="headerlink" title="原因 1：防止目录结构循环"></a>原因 1：防止目录结构循环</h5><p>假设你可以对目录建立硬链接：</p><ul><li><code>/dir1</code> 是一个目录。</li><li>你执行：<code>ln /dir1 /dir2/hardlink_to_dir1</code></li></ul><p><strong>如果允许硬链接对目录，可能会使目录形成了循环结构（死循环，无限递归）：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/dir1/hardlink_to_dir1/hardlink_to_dir1/...</span><br></pre></td></tr></table></figure><hr><h5 id="这会导致什么？"><a href="#这会导致什么？" class="headerlink" title="这会导致什么？"></a>这会导致什么？</h5><ul><li><code>ls</code>、<code>find</code>、<code>du</code> 等递归命令无限循环、卡死。</li><li>操作系统处理 <code>.</code>、<code>..</code> 也将失去一致性。</li></ul><blockquote><p>  <strong>所以：为避免目录树出现“死循环”，Linux 内核从一开始就禁用对目录的硬链接。</strong></p></blockquote><hr><h4 id="2-为什么软链接可以对目录？"><a href="#2-为什么软链接可以对目录？" class="headerlink" title="2. 为什么软链接可以对目录？"></a>2. 为什么软链接可以对目录？</h4><p>软链接本质上是 <strong>一个路径字符串</strong>，系统通过解析路径再跳转过去，跟文件&#x2F;目录本体无直接绑定。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ln</span> -s /etc /tmp/etc_soft</span><br><span class="line"><span class="built_in">cd</span> /tmp/etc_soft</span><br></pre></td></tr></table></figure><p>这样就没问题，软链接不会打破目录结构，也不会增加 <code>inode</code> 引用计数（每一个 <code>inode</code> 内部，都有一个叫做引用计数的计数器，表示有多少个文件名指向我自己），因此安全、灵活。</p><hr><h4 id="3-和-是目录硬链接的特例！"><a href="#3-和-是目录硬链接的特例！" class="headerlink" title="3. .  和 .. 是目录硬链接的特例！"></a>3. <code>. </code> 和 <code>..</code> 是目录硬链接的特例！</h4><blockquote><p><strong>每个目录都有一个 <code>.</code> 和一个 <code>..</code> 条目，他们其实硬链接！为什么？</strong></p><h4 id="1-是当前目录的硬链接"><a href="#1-是当前目录的硬链接" class="headerlink" title="1. . 是当前目录的硬链接"></a>1. <code>.</code> 是当前目录的硬链接</h4><ul><li>每个目录都需要能指向“自己”。</li><li>所以 <code>.</code> 实际上就是 <strong>指向本目录 <code>inode</code> 的硬链接</strong>。</li><li>在文件系统中，这让程序在目录内操作时可以引用“当前目录”。</li></ul><p>例如：<code>cd .</code> 其实就是进入当前目录，操作的就是 <code>.</code> 所指向的那个 <code>inode</code>。</p><hr><h4 id="2-是父目录的硬链接"><a href="#2-是父目录的硬链接" class="headerlink" title="2. .. 是父目录的硬链接"></a>2. <code>..</code> 是父目录的硬链接</h4><ul><li>为了从当前目录 <strong>返回上一级目录</strong>，需要有个入口。</li><li>所以 <code>..</code> 就是一个 <strong>指向父目录 <code>inode</code> 的硬链接</strong>。</li><li>执行 <code>cd ..</code> 时，系统读取 <code>..</code> 所指向的 <code>inode</code>，从而跳转到父目录。</li></ul><hr><h4 id="3-这两者是“硬链接”，而不是软链接，原因很简单："><a href="#3-这两者是“硬链接”，而不是软链接，原因很简单：" class="headerlink" title="3. 这两者是“硬链接”，而不是软链接，原因很简单："></a>3. 这两者是“硬链接”，而不是软链接，原因很简单：</h4><ul><li>它们存储的是 <strong><code>inode</code> 号</strong>，不是路径字符串。</li><li>所以当父目录名或当前目录名被改了，<code>..</code> 和 <code>.</code> <strong>依然有效</strong>（不像软链接那样容易失效）。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250512153701538.png" alt="image-20250512153654379"></p><p><strong>所以每个目录的 <code>.</code> 和 <code>..</code> 是硬链接，是因为它们直接存储 <code>inode</code> 号，这样能让系统通过 <code>inode</code> 来维护目录结构，确保文件系统高效且可靠地定位目录关系。</strong></p></blockquote><table><thead><tr><th>目录项</th><th>说明</th></tr></thead><tbody><tr><td><code>.</code></td><td>当前目录的硬链接，指向本目录 <code>inode</code></td></tr><tr><td><code>..</code></td><td>父目录的硬链接，指向父目录 <code>inode</code></td></tr></tbody></table><p><strong>这也是为什么：</strong></p><ul><li>创建一个目录，其 <strong>链接数默认为 2</strong>（<code>.</code> + 父目录中的它一次）</li><li>每新增一个子目录，父目录的硬链接计数 +1（因为子目录的 <code>..</code> 指向父目录）</li></ul><p><strong>示意图：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/home</span><br><span class="line"> └── user</span><br><span class="line">      ├── .   -&gt; /home/user</span><br><span class="line">      ├── ..  -&gt; /home</span><br><span class="line">      └── doc</span><br><span class="line">           ├── .. -&gt; /home/user</span><br></pre></td></tr></table></figure><blockquote><p>  但这是系统创建时 <strong>自动维护的结构</strong>，是 <strong>特权性操作</strong>，而 <strong>用户不能手动对目录建立普通硬链接</strong>。</p></blockquote><hr><h3 id="5-小结"><a href="#5-小结" class="headerlink" title="5. 小结"></a>5. 小结</h3><ul><li><strong>软链接 &#x3D; 快捷方式，路径引用，灵活，常用在程序入口&#x2F;配置切换上</strong>；</li><li><strong>硬链接 &#x3D; 一个文件多个名字，共享内容，适合防误删、备份节省空间</strong>。</li></ul><p>想在终端任意地方运行程序，用 <strong>软链接</strong> 就行！</p><table><thead><tr><th>问题</th><th>解释</th></tr></thead><tbody><tr><td>为什么硬链接不能用于目录？</td><td>为防止目录循环，系统不允许用户对目录建立硬链接</td></tr><tr><td><code>. </code> 和 <code>..</code> 是硬链接吗？</td><td>是的，是系统自动创建并维护的特殊硬链接（特例）</td></tr><tr><td>为什么软链接能对目录？</td><td>因为它只是路径跳转，逻辑上没有破坏目录结构</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>025 理解文件系统</title>
      <link href="/posts/34793.html"/>
      <url>/posts/34793.html</url>
      
        <content type="html"><![CDATA[<h2 id="理解文件系统"><a href="#理解文件系统" class="headerlink" title="理解文件系统"></a>理解文件系统</h2><h3 id="1-认识磁盘磁带"><a href="#1-认识磁盘磁带" class="headerlink" title="1. 认识磁盘磁带"></a>1. 认识磁盘磁带</h3><p><span style="color:#FF0000;"><strong>由于磁盘磁带和操作系统组成原理更相关，而且相关概念用语言太抽象，所以我找到了一些比较好的视频和书籍内容来帮助理解（注意视频、书籍内容有部分知识我们不涉及，所以不懂也没关系，多出的就当是眼界扩展了）：</strong></span></p><blockquote><p><a href="https://www.youtube.com/watch?v=wtdnatmVdIg">硬盘驱动器是如何工作的？（You Tube）</a></p><p><a href="https://www.bilibili.com/video/BV1iT411o7sW/?spm_id_from=333.337.search-card.all.click&vd_source=47fe2fe2f10c4e806e38c62553037767">硬盘的工作原理（B 站）</a></p><p><a href="https://www.bilibili.com/video/BV1ug411b7Wo/?spm_id_from=333.337.search-card.all.click&vd_source=47fe2fe2f10c4e806e38c62553037767">机械硬盘是如何工作的？（B 站）</a></p><p>→ <a href="https://www.bilibili.com/video/BV1J44y1C7RR/?spm_id_from=333.337.search-card.all.click&vd_source=47fe2fe2f10c4e806e38c62553037767">机械磁盘：结构与工作原理详解</a></p><p>→ <a href="https://www.bilibili.com/video/BV1Hz4y1V7RC/?spm_id_from=333.1391.0.0&vd_source=47fe2fe2f10c4e806e38c62553037767">磁带为何能记录声音？（主要了解其存储原理）</a></p><p><a href="https://www.cnblogs.com/andy9468/p/11091115.html">相关文章 | 博客园</a></p><p><a href="https://yohifo.blog.csdn.net/article/details/130467665">相关文章 | CSDN</a></p><p><a href="https://blog.csdn.net/chenlong_cxy/article/details/120743720">相关文章 | CSDN</a></p></blockquote><blockquote><p><strong>摘自《操作系统概念精要 原书第 2 版》<code>298</code> 页前后（真的是很想将内容直接摘过来，奈何实在是没找到电子版，只能扫描现书将就看吧 😂）。这里的图片已经排好序，直接按照顺序看即可。推荐直接去看原书，也希望有电子版的进行贡献一下，感谢您的开源精神！</strong></p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250506203145366.png" alt="image-20250506203138105"></p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250506203307042.jpg" alt="8d8a9a29b2373d90ba4e09a41ccf2bcb"></p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250506203402543.png" alt="image-20250506203402279"></p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250506203527538.png" alt="image-20250506203527455"></p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250506203703851.png" alt="image-20250506203703623"></p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250506203757968.png" alt="image-20250506203757884"></p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250506203840986.png" alt="image-20250506203840852"></p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250506204215684.png" alt="image-20250506204215459"></p></blockquote><blockquote><p><strong>自然也少不了鸟哥啦~ 摘自《鸟哥的 Linux 私房菜 基础学习篇（第四版）》<code>210</code>~&#96;217&#96; 页相关内容。还是推荐看原书，就不过多赘述了。</strong></p><p>首先说明一下磁盘的物理组成，整颗磁盘的组成主要有：</p><ul><li>圆形的盘片（主要记录数据的部分）；</li><li>机械手臂，与在机械手臂上的磁头（可读写盘片上的数据）；</li><li>主轴马达，可以转动盘片，让机械手臂的磁头在盘片上读写数据。</li></ul><p>从上面我们知道数据储存与读取的重点在于盘片，而盘片上的物理组成则为（假设此磁盘为单碟片，盘片图示请参考第二章图 2.2.1 的示意）：</p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250506205841943.png" alt="image-20250506205841870"></p><ul><li>扇区 (Sector)为最小的物理储存单位，且依据磁盘设计的不同，目前主要有 512Bytes 与 4K 两种格式；</li><li>将扇区组成一个圆，那就是柱面 (Cylinder) ;</li><li>早期的分区主要以柱面为最小分区单位，现在的分区通常使用扇区为最小分区单位（每个扇区都有其号码喔，就好像座位一样）；</li><li>磁盘分区表主要有两种格式，一种是限制较多的 MBR 分区表，一种是较新且限制较少的 <code>GPT</code> 分区表。</li><li><code>MBR</code> 分区表中，第一个扇区最重要，里面有：主引导记录(Master boot record，MBR)及分区表 (partition table) , 其中 <code>MBR</code> 占有 <code>446B</code>, 而分区表则占有 <code>64B</code>。</li><li><code>GPT</code> 分区表除了分区数量扩充较多之外，支持的磁盘容量也可以超过 <code>2TB</code>。</li></ul><p>至于磁盘的文件名部份，基本上，所有物理磁盘的文件名都已经被仿真成 <code>/dev/sd[a-p]</code> 的格式，第一块磁盘文件名为 <code>/dev/sda</code>。而分区的文件名若以第一块磁盘为例，则为 <code>/dev/sda[1-128]</code>。除了物理磁盘之外，虚拟机的磁盘通常为 <code>/dev/vd[a-p]</code> 的格式。</p><p>复习完物理组成后，来复习一下磁盘分区吧！如前所述，以前磁盘分区最小单位经常是柱面，但 CentOS7 的分区软件，已经将最小单位改成扇区了，所以容量大小的分区可以切的更细 〜 此外，由于新的大容量磁盘大多得要使用 <code>GPT</code> 分区表才能够使用全部的容量，因此过去那个 <code>MBR</code> 的传统磁盘分区表限制就不会存在了。不过，由于还是有小磁盘啊！因此，你在处理分区的时候，还是得要先查询一下，你的分区是 <code>MBR</code> 的分区？还是 <code>GPT</code> 的分区？在第三章的 CentOS7 安装中，鸟哥建议过强制使用 <code>GPT</code> 分区喔！</p><h4 id="文件系统特性"><a href="#文件系统特性" class="headerlink" title="文件系统特性"></a>文件系统特性</h4><p>传统的磁盘与文件系统之应用中，一个分区就是只能够被格式化成为一个文件系统，所以我们可以说一个文件系统就是一个硬盘分区。但是由于新技术的利用，例如我们常听到的 <code>LVM</code> 与软件磁盘阵列 (softwareraid)，这些技术可以将一个分区格式化为多个文件系统(例如 <code>LVM</code>)，也能够将多个分区合成一个文件系统 (LVM，RAID)。所以说，目前我们在格式化时已经不再说成针对硬盘分区来格式化了，通常我们可以称呼 <strong>一个可被挂载的数据为一个文件系统而不是一个分区喔！</strong></p><p>那么文件系统是如何运行的呢？这与操作系统的文件数据有关。较新的操作系统的文件数据除了文件实际内容外，通常含有非常多的属性，例如 <code>Linux</code> 操作系统的文件权限 (<code>rwx</code>)与文件属性（拥有者丶用户组丶时间参数等）。<strong>文件系统通常会将这两部份的数据分别存放在不同的区块，权限与属性放置到 <code>inode</code> 中，至于实际数据则放置到数据区块中。</strong> 另外，还有一个超级区块 (super 数据区块) 会记录整个文件系统的整体信息，包括 <code>inode</code> 与数据区块的总量、使用量、剩余量等。</p><p><strong>每个 <code>inode</code> 与区块都有编号，至于这三个数据的意义可以简略说明如下：</strong></p><ul><li><strong>超级区块 ∶ 记录此 f 文件系统的整体信息，包括 <code>inode</code> 与数据区块的总量、使用量、剩余量，以及文件系统的格式与相关信息等；</strong></li><li><strong><code>inode</code>：记录文件的属性，一个文件占用一个 <code>inode</code>，同时记录此文件的数据所在的区块号码；</strong></li><li><strong>数据区块：实际记录文件的内容，若文件太大时，会占用多个区块。</strong></li></ul><p>由于每个 <code>inode</code> 与数据区块都有编号，而每个文件都会占用一个 <code>inode </code>，<code>inode</code> 内则有文件数据放置的数据区块号码。因此，我们可以知道的是，如果能够找到文件的 <code>inode</code> 的话，那么自然就会知道这个文件所放置数据的数据区块号码，当然也就能够读出该文件的实际数据了。这是个比较有效率的作法，因为如此一来我们的磁盘就能够在短时间内读取出全部的数据，读写的性能比较好啰。</p><p>我们将 <code>inode</code> 与数据区块区块用图解来说明一下，如下图所示，文件系统先格式化出 <code>inode</code> 与数据区块的区块，假设某一个文件的属性与权限数据是放置到 <code>inode 4</code> 号（下图较小方格内），而这个 <code>inode</code> 记录了文件数据的实际放置点为 2，7，13，15 这四个数据区块号码，此时我们的操作系统就能够据此来排列磁盘的读取顺序，可以一口气将四个数据区块内容读出来！那么数据的读取就如同下图中的箭头所指定的模样了。</p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250506212506040.png" alt="image-20250506212505957"></p><p>这种数据存取的方法我们称为索引式文件系统 (indexed allocation)。那有没有其他的惯用文件系统可以比较一下啊？有的，那就是我们惯用的 U 盘（闪存），U 盘使用的文件系统一般为 <code>FAT</code> 格式。<code>FAT</code> 这种格式的文件系统并没有 <code>inode</code> 存在，所以 <code>FAT</code> 没有办法将这个文件的所有区块在一开始就读取出来。每个区块号码都记录在前一个区块当中，他的读取方式有点像下面这样：</p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250506212829231.png" alt="image-20250506212829181"></p><p>上图中我们假设文件的数据依序写入 <code>1-&gt;7-&gt;4-&gt;15</code> 号这四个 block 号码中，但这个文件系统没有办法一口气就知道四个区块的号码，他得要一个一个的将区块读出后，才会知道下一个区块在何处。如果同一个文件数据写入的区块分散的太过厉害时，则我们的磁头将无法在磁盘转一圈就读到所有的数据，因此磁盘就会多转好几圈才能完整的读取到这个文件的内容！</p><p>常常会听到所谓的碎片整理吧？<strong>需要碎片整理的原因就是文件写入的区块太过于离散了，此时文件读取的性能将会变的很差所致。</strong> 这个时候 <strong>可以通过碎片整理将同一个文件所属的区块集合在一起，这样数据的读取会比较容易啊！</strong> 因此，<code>FAT</code> 的文件系统需要时不时的碎片整理一下，那么 <code>Ext2</code> 是否需要磁盘重整呢？</p><p>由于 <code>Ext2</code> 是索引式文件系统，基本上不太需要常常进行碎片整理的。但是如果文件系统使用太久，常常删除、编辑、新增文件时，那么还是可能会造成文件数据太过于离散的问题，此时或许会需要进行重整一下的。不过，老实说，鸟哥倒是没有在 <code>Linux</code> 操作系统上面进行过 <code>Ext2</code>&#x2F;<code>Ext3 </code> 文件系统的碎片整理，似乎不太需要啦！</p><hr><p>太多了，还是看图片吧 😂</p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250506214005907.png" alt="image-20250506214005755"></p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250506214113327.png" alt="image-20250506214113160"></p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250506214325829.png" alt="image-20250506214325696"></p></blockquote><hr><h3 id="2-磁带、HDD、SSD-数据存储原理与演进"><a href="#2-磁带、HDD、SSD-数据存储原理与演进" class="headerlink" title="2. 磁带、HDD、SSD 数据存储原理与演进"></a>2. 磁带、HDD、SSD 数据存储原理与演进</h3><p>磁带是最古老的电子数据存储技术之一，其介质为带有磁性涂层的长条塑料薄膜。数据以磁化痕迹形式记录在磁带上：写入时磁头通过控制磁场使带面上的磁性颗粒朝向发生改变，分别表示二进制的 0 或 1；读取时固定的磁头感应这些磁化痕迹输出数据。磁带基片通常是聚酯薄膜，上面涂覆氧化铁或金属磁粉层。磁带读取为串行访问，速度较慢但容量极大，而且成本低廉、耐用性高，因此常用于海量数据的长期归档和备份。</p><h4 id="小知识"><a href="#小知识" class="headerlink" title="小知识"></a>小知识</h4><ol><li><strong>固态硬盘（SSD）</strong>：不属于磁盘或硬盘（HDD），因其使用闪存芯片而非磁性介质。  </li><li><strong>关系总结</strong>：  <ul><li><strong>磁盘</strong> 是技术大类（磁性存储），<strong>硬盘</strong> 是磁盘的现代主流应用。  </li><li>日常中“磁盘”有时被误用作“硬盘”的同义词，但严格意义上前者更广泛。</li></ul></li></ol><table><thead><tr><th><strong>对比项</strong></th><th><strong>硬盘（HDD, Hard Disk Drive）</strong></th><th><strong>磁盘（广义）</strong></th><th><strong>关系说明</strong></th></tr></thead><tbody><tr><td><strong>定义</strong></td><td>一种使用磁性存储技术的物理存储设备，属于磁盘的一种具体类型。</td><td>广义指所有利用磁性记录数据的圆形盘片（如软盘、硬盘中的盘片）。</td><td>硬盘是磁盘的一种具体应用形式，磁盘的概念更广泛。</td></tr><tr><td><strong>存储原理</strong></td><td>通过磁头在高速旋转的磁性盘片上读写数据。</td><td>依赖磁性材料记录数据（如硬盘盘片、软盘等）。</td><td>硬盘的存储基于磁盘的磁性原理。</td></tr><tr><td><strong>常见类型</strong></td><td>机械硬盘（<code>HDD</code>）</td><td>包括硬盘中的盘片、软盘（<code>Floppy Disk</code>）、早期磁光盘（<code>MO</code>）等。</td><td>硬盘是磁盘技术的主流应用之一，其他磁盘类型逐渐被淘汰或小众化。</td></tr><tr><td><strong>速度</strong></td><td>较慢（依赖机械转动，通常转速 5400&#x2F;7200 RPM）。</td><td>取决于类型（如软盘速度远低于硬盘）。</td><td>硬盘速度优于大多数传统磁盘介质。</td></tr><tr><td><strong>容量</strong></td><td>大（当前主流 1TB~20TB）。</td><td>差异大（软盘仅 1.44MB，硬盘盘片单碟可达数 TB）。</td><td>硬盘是磁盘技术中容量发展的巅峰代表。</td></tr><tr><td><strong>体积&#x2F;便携性</strong></td><td>体积较大（3.5 英寸或 2.5 英寸）。</td><td>灵活（软盘小巧，硬盘盘片不可单独使用）。</td><td>磁盘的形态多样，硬盘更注重固定存储。</td></tr><tr><td><strong>应用场景</strong></td><td>电脑、服务器等大容量存储需求。</td><td>历史曾用于数据交换（软盘）、临时存储等，现硬盘主要用于长期存储。</td><td>硬盘取代了多数传统磁盘的用途。</td></tr><tr><td><strong>价格</strong></td><td>较低（单位容量成本低）。</td><td>历史中软盘成本低，但现代高性能磁盘（如企业级硬盘）价格较高。</td><td>硬盘性价比高，是磁盘技术的经济化产物。</td></tr><tr><td><strong>发展趋势</strong></td><td>逐渐被 <code>SSD</code> 替代，但仍在大容量存储中占优。</td><td>传统磁盘技术（如软盘）已淘汰，硬盘技术仍在优化。</td><td><code>SSD</code>（固态硬盘）不属于磁盘范畴，但硬盘仍是磁性存储的重要选择。</td></tr></tbody></table><h3 id="3-硬盘-HDD-存储原理"><a href="#3-硬盘-HDD-存储原理" class="headerlink" title="3. 硬盘 (HDD) 存储原理"></a>3. 硬盘 (HDD) 存储原理</h3><p><strong>硬盘通过磁性方式在旋转的盘片上存储二进制数据。</strong> 每个盘片表面涂覆磁性材料，盘片由主马达高速旋转，而机械臂上的磁头在盘片上方移动进行读写。<strong>盘片表面被划分为同心圆形的磁道（track）和扇区（sector）</strong>，每个扇区通常固定容量（如 <code>512B</code> 或 <code>4096B</code>）；这些磁道和扇区号构成了数据的物理地址。盘片上的微小磁颗粒可以被磁化成两种极性，分别代表二进制 <code>0</code> 和 <code>1</code>。写入时，磁头在线圈通电后在盘片下方产生磁场，将被选区域的小颗粒磁极方向改变以记录信息；读取时，磁头感知磁性材料的极性排列并将其转换为电信号恢复出数据。<code>HDD</code> 提供随机访问能力，因而读写延迟主要受磁头寻道和盘片旋转时间影响。</p><p><img src="https://github.com/huangcancan-xbc/Drawing-bed/blob/master/Linux/20250506231436727.png?raw=true"></p><h3 id="4-固态硬盘-SSD-存储原理"><a href="#4-固态硬盘-SSD-存储原理" class="headerlink" title="4. 固态硬盘 (SSD) 存储原理"></a>4. 固态硬盘 (SSD) 存储原理</h3><p><code>SSD</code> 使用闪存芯片（典型的 <code>NAND Flash</code>）作为存储介质，无机械活动部件。每个闪存单元是一个带浮栅的 <code>MOSFET</code> 晶体管，通过存储电荷来保存数据。当浮栅中注入电子时，晶体管阈值变化被解读为二进制“0”；当浮栅不带电子时则被视为二进制“1”。SSD 写入数据时，控制器通常需要先擦除整个块（块内所有单元恢复为空状态），然后才将新数据写入（利用高压使电子通过隧道注入浮栅）。由于没有机械部件，<code>SSD</code> 读写速度远快于 <code>HDD</code>。另一方面，闪存擦写次数有限，<code>SSD</code> 控制器必须使用磨损平衡（<code>wear leveling</code>）和 <code>TRIM</code> 等技术均衡使用单元并回收空间。总的来说，<code>SSD</code> 速度高、无噪音、功耗低，但成本相对较高且写入寿命有限。</p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250506231741339.png" alt="image-20250506231740872"></p><h3 id="5-HDD-未被淘汰的原因"><a href="#5-HDD-未被淘汰的原因" class="headerlink" title="5. HDD 未被淘汰的原因"></a>5. HDD 未被淘汰的原因</h3><p>虽然 <code>SSD</code> 性能优秀，但 <code>HDD</code> 凭借成本和容量优势仍不可替代。根据权威资料，对于大容量、冷备份或归档场景，经济实惠的 <code>HDD</code> 依然是首选。<code>AWS</code> 指出“若需要高速频繁访问用 <code>SSD</code>；处理备份、归档或大容量存储时，普通硬盘是更好的选择”。此外，<code>HDD</code> 技术发展成熟，数据恢复难度更低，长期保存历史数据也更稳定可靠。有些公司可能会将用户长期不访问的数据&#x2F;很多年前的数据从 <code>SSD</code> 迁移至磁盘，从而长期保存数据并节约成本。</p><hr><p>上面我们已经基本上了解了磁盘磁带的构造和存储、读写的原理，下面就到我的讲解了：</p><h3 id="6-文件系统磁盘布局（重点）"><a href="#6-文件系统磁盘布局（重点）" class="headerlink" title="6. 文件系统磁盘布局（重点）"></a>6. 文件系统磁盘布局（重点）</h3><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250507122425503.png" alt="image-20250507122425391"></p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250507122324688.png" alt="image-20250507122324436"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">+----------------------+  &lt;- 偏移 0</span><br><span class="line">|     Boot Block       |       (第 0 块, 1KB/2KB/4KB)</span><br><span class="line">+----------------------+  &lt;- 偏移 BLOCK_SIZE</span><br><span class="line">|    Superblock (SB)   |       (备份 SB 存放在每个 Block Group 的第 0/1/2 块)</span><br><span class="line">+----------------------+  &lt;- 偏移 BLOCK_SIZE + sizeof(SB)</span><br><span class="line">| Group Descriptor Tbl |       (每个 Block Group 保持一份)</span><br><span class="line">+----------------------|</span><br><span class="line">| Block Bitmap         |       (标记该 Group 中哪些数据块已用)</span><br><span class="line">+----------------------|</span><br><span class="line">| Inode Bitmap         |       (标记该 Group 中哪些 inode 已用)</span><br><span class="line">+----------------------|</span><br><span class="line">| Inode Table          |       (存放 inode 结构，文件元数据)</span><br><span class="line">+----------------------|</span><br><span class="line">| Data Blocks          |       (真正存放文件和目录内容的数据区)  </span><br><span class="line">|                      |</span><br><span class="line">|                      |</span><br><span class="line">+----------------------+</span><br><span class="line">      …（重复多个 Block Group）…</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li><strong><code>Boot Block</code>：文件系统第 <code>0</code> 块（通常 <code>1KB</code> 或 <code>2KB</code>），包含启动加载代码，不属于文件系统使用范围，仅在可启动分区时有意义。</strong></li><li><strong><code>Block Group</code>：整个分区被划分成若干个相同大小的 <code>Block Group</code>，以提高并行性并减少碎片。每个 <code>Group</code> 包含上述结构一次。</strong></li></ul><hr><h4 id="1-Boot-Block（启动块-引导块）"><a href="#1-Boot-Block（启动块-引导块）" class="headerlink" title="1. Boot Block（启动块&#x2F;引导块）"></a>1. Boot Block（启动块&#x2F;引导块）</h4><ul><li><strong>大小</strong>：<code>1</code> 个块（<code>BLOCK_SIZE</code>），通常 <code>512B</code> 或 <code>4KB</code>。</li><li><strong>作用</strong>：存放引导代码（<code>Bootloader</code>）及分区信息，在 <code>BIOS/UEFI</code> 加载文件系统之前被使用，文件系统本身不访问此区域。</li><li><strong>存放位置</strong>：分区的第 <code>0</code> 块。</li></ul><h4 id="2-Superblock-SB，超级块"><a href="#2-Superblock-SB，超级块" class="headerlink" title="2. Superblock (SB，超级块)"></a>2. Superblock (SB，超级块)</h4><ul><li><strong>作用</strong>：文件系统的“总控信息”，记录整个分区的全局属性。</li><li><strong>存放位置</strong>：分区的第 <code>1</code> 块（紧跟 <code>Boot Block</code> 之后）。</li><li><strong>大小</strong>：固定 <code>1024 B</code>。</li><li><strong>关键字段</strong>：<ul><li><strong>Magic Number（魔数）</strong>：文件系统类型标识（如 <code>0xEF53</code> 表示 Ext2&#x2F;3&#x2F;4）。</li><li><strong>Block Size（块大小）</strong>：数据块大小（常见 <code>4KB</code>）。</li><li><strong>Total Blocks（总块数）</strong>：总数据块数。</li><li><strong>Total Inodes（总 <code>inode</code> 数）</strong>：总 <code>inode</code> 数。</li><li><strong>First Inode（第一个 <code>inode</code>）</strong>：第一个可分配 <code>inode</code>（通常 <code>inode 2</code> 为根目录）。</li></ul></li><li><strong>冗余存储</strong>：备份 <code>Superblock</code> 分布在各 <code>Block Group</code> 的第 <code>0/1/2</code> 块，防止损坏。</li></ul><hr><h4 id="3-Group-Descriptor-Table-GDT，块组描述符表"><a href="#3-Group-Descriptor-Table-GDT，块组描述符表" class="headerlink" title="3. Group Descriptor Table (GDT，块组描述符表)"></a>3. Group Descriptor Table (GDT，块组描述符表)</h4><ul><li><strong>作用</strong>：描述每个 <code>Block Group</code> 的布局信息（如位图、<code>inode</code> 表的位置）。</li><li><strong>存放位置</strong>：紧跟主 <code>Superblock</code> 之后，占用若干个块。</li><li><strong>描述符大小</strong>：32 B&#x2F;个。<code>GroupDescriptorTable</code> 的总大小 &#x3D; 描述符数 × 32，向上对齐到 <code>BLOCK_SIZE</code>。</li><li><strong>关键字段</strong>：<ul><li><strong><code>block_bitmap</code>（块号）：</strong> 指向当前 <code>Group</code> 的 <code>Block Bitmap</code> 的块号。</li><li><strong><code>inode_bitmap</code>（块号）：</strong> 指向当前 <code>Group</code> 的 <code>inode Bitmap</code> 的块号。</li><li><strong><code>inode_table</code>（起始块号）：</strong> 指向当前 <code>Group</code> 的 <code>inode Table</code> 的起始块号。</li><li>空闲块数、空闲 <code>inode</code> 数等统计信息。</li></ul></li></ul><hr><h4 id="4-Block-Bitmap（块位图）"><a href="#4-Block-Bitmap（块位图）" class="headerlink" title="4. Block Bitmap（块位图）"></a>4. Block Bitmap（块位图）</h4><ul><li><strong>作用</strong>：位图方式标记本组中各数据块是否已分配。</li><li><strong>存放位置</strong>：由 <code>GDT</code> 中的 <code>block_bitmap</code> 字段指定。</li><li><strong>大小</strong>：1 个 <code>BLOCK_SIZE</code>（例如 4KB &#x3D; 32768 bits，能管理 32768 个块 ≈128MB）。</li><li><strong>标记规则</strong>：1 &#x3D; 已分配，0 &#x3D; 空闲。</li></ul><hr><h4 id="5-Inode-Bitmap（inode-位图）"><a href="#5-Inode-Bitmap（inode-位图）" class="headerlink" title="5. Inode Bitmap（inode 位图）"></a>5. Inode Bitmap（inode 位图）</h4><ul><li><strong>作用</strong>：位图方式标记本组中各 <code>inode</code> 是否已分配。</li><li><strong>存放位置</strong>：由 <code>GDT</code> 中的 <code>inode_bitmap</code> 字段指定。</li><li><strong>大小</strong>：1 个 <code>BLOCK_SIZE</code>（例如 <code>4KB</code> 可管理 <code>32768</code> 个 <code>inode</code>）。</li><li><strong>标记规则</strong>：1 &#x3D; 已分配，0 &#x3D; 空闲。</li></ul><hr><h4 id="6-Inode-Table（inode-表）"><a href="#6-Inode-Table（inode-表）" class="headerlink" title="6. Inode Table（inode 表）"></a>6. Inode Table（inode 表）</h4><ul><li><strong>作用</strong>：存储所有文件&#x2F;目录的元信息，每个 <code>inode</code> 大小通常为 <code>128B</code> 或 <code>256B</code>。</li><li><strong>存放位置</strong>：由 <code>GDT</code> 中的 <code>inode_table</code> 字段指定，长度 &#x3D; <code>(inodes_per_group * inode_size) / BLOCK_SIZE</code> 块。</li><li><strong>关键字段</strong>：<ul><li><strong>File Type</strong>：普通文件、目录、符号链接等。</li><li><strong>Permissions</strong>：访问权限（rwx）。</li><li><strong>File Size</strong>：文件大小。</li><li><strong>Timestamps</strong>：创建&#x2F;修改&#x2F;访问 时间戳。</li><li><strong>Data Block Pointers</strong>：直接指针（12 个）、一级&#x2F;二级&#x2F;三级间接指针。</li></ul></li></ul><hr><h4 id="7-Data-Blocks（数据块）"><a href="#7-Data-Blocks（数据块）" class="headerlink" title="7. Data Blocks（数据块）"></a>7. Data Blocks（数据块）</h4><ul><li><strong>作用</strong>：实际存放用户数据。<strong><span style="color:#FF0000;">所以，Linux 的文件在磁盘中存储是将属性和内容分开存储的！（文件内容 → 数据块，文件属性 → <code>inode</code>）</span></strong><ul><li><strong>目录（directory）</strong>：保存 <code>&lt;inode号, 文件名&gt;</code> 的列表。</li><li><strong>普通文件（file）</strong>：存放文件内容的二进制数据。</li></ul></li><li><strong>存放位置</strong>：紧跟在各组的 <code>Inode Table</code> 之后，直至本组末尾。</li></ul><table><thead><tr><th>Block Group 字段</th><th>作用</th><th>大小&#x2F;位置</th></tr></thead><tbody><tr><td><strong>SuperBlock</strong></td><td>记录文件系统的全局信息（如总块数、<code>inode</code> 数、块大小等）。</td><td>每个 <code>Group</code> 可能有一份副本（冗余）。</td></tr><tr><td><strong>Group Descriptor Table</strong></td><td>描述当前 <code>Block Group</code> 的元数据（如块位图、<code>inode</code> 位图的位置）。</td><td>紧接 <code>SuperBlock</code> 之后。</td></tr><tr><td><strong>Block Bitmap</strong></td><td>标记当前 <code>Group</code> 中哪些数据块已被占用（1 &#x3D; 占用，0 &#x3D; 空闲）。</td><td>占用 1 个块，按位映射。</td></tr><tr><td><strong>inode Bitmap</strong></td><td>标记当前 <code>Group</code> 中哪些 <code>inode</code> 已被占用（类似 <code>Block Bitmap</code>）。</td><td>占用 1 个块，按位映射。</td></tr><tr><td><strong>inode Table</strong></td><td>存储 <code>inode</code> 数组，每个 <code>inode</code> 描述一个文件&#x2F;目录的元数据（权限、大小、数据块指针等）。</td><td>占用多个块，具体取决于 <code>inode</code> 数量。</td></tr><tr><td><strong>Data Blocks</strong></td><td>实际存储文件数据的块。</td><td>剩余所有块。</td></tr></tbody></table><hr><h4 id="8-对比记忆"><a href="#8-对比记忆" class="headerlink" title="8. 对比记忆"></a>8. 对比记忆</h4><table><thead><tr><th>记忆</th><th>作用</th><th>类比</th></tr></thead><tbody><tr><td><strong>SuperBlock</strong></td><td>文件系统的“总说明书”。</td><td>书的目录页。</td></tr><tr><td><strong>Group Descriptor Table</strong></td><td>描述每个 <code>Block Group</code> 的布局。</td><td>章节的页码索引。</td></tr><tr><td><strong>Block Bitmap</strong></td><td>标记哪些块被占用。</td><td>仓库货架占用表。</td></tr><tr><td><strong>inode Table</strong></td><td>存储文件元信息（如权限、大小）。</td><td>文件的属性卡。</td></tr><tr><td><strong>Data Blocks</strong></td><td>实际存储文件内容。</td><td>仓库里的货物。</td></tr></tbody></table><hr><h3 id="7-深入理解（重点）"><a href="#7-深入理解（重点）" class="headerlink" title="7. 深入理解（重点）"></a>7. 深入理解（重点）</h3><h4 id="1-创建空文件的过程"><a href="#1-创建空文件的过程" class="headerlink" title="1. 创建空文件的过程"></a>1. 创建空文件的过程</h4><ol><li><strong>查找空闲 inode</strong>：遍历 <code>inode</code> 位图，找到一个空闲 <code>inode</code>。</li><li><strong>初始化 inode</strong>：在 <code>inode</code> 表中找到对应 <code>inode</code>，填入文件的属性信息（如创建时间、权限、大小等）。</li><li><strong>关联目录项</strong>：在当前目录文件的数据块中，增加一条目录项（文件名 + <code>inode</code> 号）。</li></ol><h4 id="2-写入文件的过程"><a href="#2-写入文件的过程" class="headerlink" title="2. 写入文件的过程"></a>2. 写入文件的过程</h4><ol><li>根据文件名找到对应 <code>inode</code>（通过目录的数据块中查找 <code>inode</code> 号）。</li><li>读取 <code>inode</code> 内容，查看已分配的数据块。</li><li>如果存在空余数据块，直接写入。</li><li>若数据块已满：<ul><li>遍历块位图找到空闲数据块，分配并标记为已用。</li><li>在 <code>inode</code> 中的数据块指针数组中记录该数据块号。</li><li>写入数据。</li></ul></li></ol><p><strong><code>inode</code> 与数据块的映射关系：</strong></p><p>使用一个 <code>15</code> 元素的数组维护：</p><ul><li>前 <code>12</code> 个元素：直接指向 <code>12</code> 个数据块</li><li>后 <code>3</code> 个元素：一级索引、二级索引和三级索引（用于数据块扩展）</li></ul><hr><h4 id="3-删除文件的过程"><a href="#3-删除文件的过程" class="headerlink" title="3. 删除文件的过程"></a>3. 删除文件的过程</h4><ol><li><strong>标记 <code>inode</code> 无效</strong>：在 <code>inode</code> 位图中将对应 <code>inode</code> 置为无效。</li><li><strong>标记数据块无效</strong>：在块位图中将文件使用的数据块置为无效。</li><li><strong>删除映射关系：</strong> 删除对应目录文件中该文件的目录项（文件名和 <code>inode</code> 号的映射关系）。</li></ol><blockquote><p>  <strong>注意：删除操作只是标记为无效（标记为“可复用”）而非真正擦除数据，因此短时间内可恢复。后续文件操作可能重新分配这些 <code>inode</code> 和数据块，导致原数据被覆盖。这也就是数据恢复的原理：删除 &#x3D; 允许被覆盖。</strong></p></blockquote><p><strong>为什么是“短时间”？</strong></p><ul><li>被标记为空闲的 <code>inode</code> 号和数据块号可能在新文件或写入时重新分配。</li><li>一旦覆盖，原始数据就不可恢复。</li></ul><hr><h4 id="4-拷贝-vs-删除-的时间差异"><a href="#4-拷贝-vs-删除-的时间差异" class="headerlink" title="4. 拷贝 vs 删除 的时间差异"></a>4. 拷贝 vs 删除 的时间差异</h4><ul><li><strong>拷贝文件慢</strong>：<ul><li>创建新 <code>inode</code>。</li><li>分配多个数据块。</li><li>写入文件内容（复制）。</li></ul></li><li><strong>删除文件快</strong>：<ul><li>只需修改 <code>inode</code> 和块位图。</li><li>不需要物理&#x2F;真实的删除文件内容。</li></ul></li></ul><p><strong>类比：</strong></p><ul><li>创建文件 &#x3D; 建楼 → 慢</li><li>删除文件 &#x3D; 在楼上写“拆”字 → 快</li></ul><hr><h4 id="5-目录的理解"><a href="#5-目录的理解" class="headerlink" title="5. 目录的理解"></a>5. 目录的理解</h4><ul><li><strong>在 Linux 中“一切皆文件”，目录也属于文件。</strong></li><li>目录有自己的 <code>inode</code>（属性信息）和数据块（内容）。</li><li>目录的数据块内容：该目录下的文件名 与 对应 <code>inode</code> 号的映射表。</li></ul><p><strong>目录权限</strong>：</p><ul><li>无 <code>w</code> 权限：无法创建文件。</li><li>无 <code>r</code> 权限：无法查看文件列表。</li><li>无 <code>x</code> 权限：无法进入目录。</li></ul><p><strong>特别说明：</strong></p><ul><li>文件名不存储在 <code>inode</code> 中，而是存储在它所在目录文件的数据块中。</li><li>系统通过“目录项”建立文件名和 <code>inode</code> 号的联系。</li></ul><hr><h4 id="6-文件系统中增删查改系统要做什么？"><a href="#6-文件系统中增删查改系统要做什么？" class="headerlink" title="6. 文件系统中增删查改系统要做什么？"></a>6. 文件系统中增删查改系统要做什么？</h4><table><thead><tr><th>操作</th><th>系统执行的步骤概要</th></tr></thead><tbody><tr><td>新建文件</td><td>分配 <code>inode</code>、数据块，更新目录项</td></tr><tr><td>删除文件</td><td><code>inode</code>&#x2F;块标记无效，删除目录项</td></tr><tr><td>查找文件</td><td>遍历目录数据块，找 <code>inode</code>，再查 <code>inode</code> 内容</td></tr><tr><td>修改文件</td><td>定位 <code>inode</code>，追加&#x2F;覆盖数据块</td></tr></tbody></table><h4 id="7-查看文件的-inode-编号"><a href="#7-查看文件的-inode-编号" class="headerlink" title="7. 查看文件的 inode 编号"></a>7. 查看文件的 inode 编号</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -i 文件名</span><br></pre></td></tr></table></figure><ul><li>使用者通过文件名访问文件。</li><li>内核通过目录项映射找到 inode。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>024 基础 IO —— 缓冲区</title>
      <link href="/posts/36108.html"/>
      <url>/posts/36108.html</url>
      
        <content type="html"><![CDATA[<h2 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h2><blockquote><p><a href="https://blog.csdn.net/2301_80220607/article/details/144565752">相关文章 | CSDN</a></p></blockquote><h3 id="1-为什么需要缓冲区？（核心原因）"><a href="#1-为什么需要缓冲区？（核心原因）" class="headerlink" title="1. 为什么需要缓冲区？（核心原因）"></a>1. 为什么需要缓冲区？（核心原因）</h3><p><span style="color:#FF0000;"><strong>先出结论：格式化 ➔ 拼接成大数据块 ➔ 缓冲 ➔ 统一输出 ➔ 保证数据连贯，减少系统调用，提高效率！</strong></span></p><h4 id="1-提高-I-O-效率！"><a href="#1-提高-I-O-效率！" class="headerlink" title="1. 提高 I&#x2F;O 效率！"></a>1. 提高 I&#x2F;O 效率！</h4><p>硬件设备（尤其是磁盘、网络、终端）操作 <strong>很慢很慢</strong>，每次读写都直接操作设备 ➔ 太耗时 ➔ 系统负担重。</p><p><strong>所以：</strong></p><ul><li><strong>少量多次 ➔ 聚集成大量一次。</strong></li><li>把「很多小的写操作」放到内存中，攒到一定量再「统一批量」写入磁盘&#x2F;屏幕。</li><li><strong>减少系统调用（syscall）次数</strong> ➔ 提高整体程序运行效率。</li></ul><p><strong>简单比喻：你买菜如果每买一根葱就跑一次超市，累不累？当然要一次性买一堆，装个购物袋带回来！（这就是缓冲思想）</strong></p><h4 id="2-配合格式化"><a href="#2-配合格式化" class="headerlink" title="2. 配合格式化"></a>2. 配合格式化</h4><p><code>printf(&quot;名字:%s, 年龄:%d\n&quot;, name, age);</code> 这种格式化输出，本质上做了两件事：</p><ol><li><strong>格式化处理（Format）</strong><ul><li><code>%s</code>、<code>%d</code> 等占位符 ➔ 根据数据类型，把 <code>name</code> 和 <code>age</code> 这两个变量 <strong>格式化成字符串</strong>。</li><li>例如：把整数 <code>23</code> 转成 <code>&quot;23&quot;</code>，字符串 <code>&quot;Tom&quot;</code> 保持原样。</li></ul></li><li><strong>统一输出（Buffer）</strong><ul><li>把格式化好的整个大字符串（比如 <code>&quot;名字:Tom, 年龄:23\n&quot;</code>）<strong>统一写入</strong> 缓冲区</li><li>最后一次性刷出去（flush 到终端&#x2F;文件）</li></ul></li></ol><hr><p><strong>如果没有缓冲区，结果会很糟糕：</strong></p><ul><li>每遇到一个小块格式化的数据就立刻 <code>write()</code> 系统调用 ➔ 系统调用开销非常大（context switch）！</li><li>输出内容 <strong>碎片化</strong> ➔ 终端打印时出现撕裂、乱码、数据乱序。</li><li>多线程程序中可能出现 <strong>打印穿插错乱</strong>。</li></ul><p><span style="color:#FF0000;"><strong>所以：必须先格式化 → 再统一放入缓冲区 → 再统一刷新输出！这样可以：</strong></span></p><ul><li><span style="color:#FF0000;"><strong>保证输出内容的原子性（一整块输出，保持顺序一致性）</strong></span></li><li><span style="color:#FF0000;"><strong>提高I&#x2F;O效率（少系统调用）</strong></span></li><li><span style="color:#FF0000;"><strong>减少设备压力</strong></span></li></ul><hr><h3 id="2-C-语言的缓冲区（库缓冲区）"><a href="#2-C-语言的缓冲区（库缓冲区）" class="headerlink" title="2. C 语言的缓冲区（库缓冲区）"></a>2. C 语言的缓冲区（库缓冲区）</h3><p>在 C 语言中，当使用 <code>printf</code>、<code>fprintf</code>、<code>scanf</code>、<code>fread</code> 等 <strong>标准 I&#x2F;O 函数</strong> 时，<strong>默认是有自己的</strong> <strong>「用户态缓冲区」</strong> 的！这些缓冲区存在于内存（堆&#x2F;栈）里，由 <code>glibc</code>（标准 C 库）管理。<strong>注意：<code>printf()</code> 输出不一定立刻 <code>write()</code>，是因为它先写入 C 标准库的缓冲区。</strong></p><h3 id="3-缓冲区分类（死记！）"><a href="#3-缓冲区分类（死记！）" class="headerlink" title="3. 缓冲区分类（死记！）"></a>3. 缓冲区分类（死记！）</h3><table><thead><tr><th>类型</th><th>触发条件</th><th>典型应用</th></tr></thead><tbody><tr><td>无缓冲（unbuffered）</td><td>直接写入设备，不缓存</td><td><code>stderr</code>、低层 <code>read</code>&#x2F;<code>write</code></td></tr><tr><td>行缓冲（line buffered）</td><td>遇到换行符 <code>\n</code> 或者缓冲区满就刷新</td><td><code>stdout</code>（连接终端时）</td></tr><tr><td>全缓冲（fully buffered）</td><td>缓冲区满才刷新</td><td><code>文件流</code>（比如 <code>fopen</code>）</td></tr></tbody></table><p><strong>具体解释：</strong></p><h4 id="1-无缓冲（Unbuffered）"><a href="#1-无缓冲（Unbuffered）" class="headerlink" title="1. 无缓冲（Unbuffered）"></a>1. 无缓冲（Unbuffered）</h4><ul><li>直接 <code>write</code> 到设备。例如：<code>stderr</code>（标准错误）。</li><li>因为错误信息要 <strong>第一时间输出</strong>，不允许缓存延迟！</li></ul><h4 id="2-行缓冲（Line-Buffered）"><a href="#2-行缓冲（Line-Buffered）" class="headerlink" title="2. 行缓冲（Line Buffered）"></a>2. 行缓冲（Line Buffered）</h4><ul><li>只有遇到换行符 <code>\n</code>，或者缓冲区满了，才 <code>flush</code>（刷新到设备）。例如：<code>stdout</code>，而且是 <strong>连接到终端（屏幕）</strong> 时。</li><li>为什么这么设计？ ➔ 人习惯一行一行看输出，比如提示、菜单。</li></ul><h4 id="3-全缓冲（Fully-Buffered）"><a href="#3-全缓冲（Fully-Buffered）" class="headerlink" title="3. 全缓冲（Fully Buffered）"></a>3. 全缓冲（Fully Buffered）</h4><ul><li>要等到缓冲区塞满了（比如 4KB），才刷新到设备。例如：往文件写数据（文件 I&#x2F;O）</li><li>为什么这么设计？ ➔ 文件操作频繁，小块数据浪费资源，聚集起来一次性写最省！</li></ul><h3 id="4-缓冲区刷新的时机"><a href="#4-缓冲区刷新的时机" class="headerlink" title="4. 缓冲区刷新的时机"></a>4. 缓冲区刷新的时机</h3><table><thead><tr><th>刷新操作</th><th>说明</th></tr></thead><tbody><tr><td>遇到换行符</td><td>行缓冲场景</td></tr><tr><td>缓冲区满</td><td>全缓冲、行缓冲场景</td></tr><tr><td>手动调用 <code>fflush(FILE *fp)</code></td><td>主动要求刷新</td></tr><tr><td>程序正常结束时</td><td><code>exit()</code> 会自动 <code>flush</code> 所有打开的流</td></tr><tr><td>文件流关闭时</td><td>调用 <code>fclose()</code> 会刷新并关闭流</td></tr></tbody></table><h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><h5 id="1-标准输出行缓冲示例："><a href="#1-标准输出行缓冲示例：" class="headerlink" title="1. 标准输出行缓冲示例："></a>1. 标准输出行缓冲示例：</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello, &quot;</span>); <span class="comment">// 暂存在行缓冲区</span></span><br><span class="line">    sleep(<span class="number">2</span>);          <span class="comment">// 暂停2秒，屏幕还没输出！</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;World!\n&quot;</span>); <span class="comment">// 遇到换行符，flush 输出</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-手动刷新缓冲区示例："><a href="#2-手动刷新缓冲区示例：" class="headerlink" title="2. 手动刷新缓冲区示例："></a>2. 手动刷新缓冲区示例：</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;处理中...&quot;</span>);  <span class="comment">// 没有 \n，屏幕不会立刻看到</span></span><br><span class="line">    fflush(<span class="built_in">stdout</span>);      <span class="comment">// 手动刷新，立刻输出到屏幕</span></span><br><span class="line">    sleep(<span class="number">3</span>);            <span class="comment">// 继续做别的事情</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;完成！\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="5-后续语言（C-等）流式封装"><a href="#5-后续语言（C-等）流式封装" class="headerlink" title="5. 后续语言（C++等）流式封装"></a>5. 后续语言（C++等）流式封装</h3><p><strong>C++ 的流（iostream）：<code>cout</code>、<code>cin</code> 就是对标准输入输出的面向对象封装。本质上也是自带缓冲区的！</strong></p><table><thead><tr><th>流对象</th><th>缓冲模式</th></tr></thead><tbody><tr><td><code>cout</code></td><td>行缓冲</td></tr><tr><td><code>cin</code></td><td>行缓冲</td></tr></tbody></table><p><strong>例如：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Hello&quot;</span>;<span class="comment">// 存在缓冲区，暂时不会马上输出</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot; World\n&quot;</span>;<span class="comment">// 遇到换行符，flush，全部一起输出</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C++标准库自动帮我们管理了：</p><ol><li>格式化处理（重载 <code>&lt;&lt;</code> 操作符）</li><li>缓冲区管理（什么时候 flush）</li></ol><p><strong>所以，不管是 C、C++、Python、Java……只要涉及到「格式化输出」+「IO 效率」的问题，背后一定都有缓冲区！只是封装层次不同，隐藏细节不同而已。</strong></p><p><span style="color:#FF0000;"><strong>缓冲区&#x3D;效率神器，格式化&#x3D;顺序保障，流&#x3D;高级封装。三者互相配合，共同提升程序性能和输出正确性！</strong></span></p><hr><h3 id="6-缓冲区在哪？（内存位置）"><a href="#6-缓冲区在哪？（内存位置）" class="headerlink" title="6. 缓冲区在哪？（内存位置）"></a>6. 缓冲区在哪？（内存位置）</h3><ul><li>缓冲区是在 <strong>用户态内存</strong>（<strong>程序进程的虚拟内存空间里</strong>）。</li><li>由标准 C 库（glibc）自己在后台维护，比如 <code>FILE</code> 结构体内部就有指针指向缓冲区。</li></ul><p>简要结构（示意）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* _IO_buf_base; <span class="comment">// 缓冲区起始地址</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* _IO_buf_end;  <span class="comment">// 缓冲区结束地址</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h3 id="7-系统级缓冲区（内核缓冲区）"><a href="#7-系统级缓冲区（内核缓冲区）" class="headerlink" title="7. 系统级缓冲区（内核缓冲区）"></a>7. 系统级缓冲区（内核缓冲区）</h3><p>除了上面讲的「C 语言库缓冲区」，<strong>Linux 内核</strong> 也有自己的「<strong>内核缓冲区</strong>」：</p><ul><li>当使用 <code>write(fd, buf, len)</code> 时<ul><li>其实只是把数据拷贝到 <strong>内核态缓冲区</strong>（Page Cache）。</li><li>并不是立刻真正落到磁盘。</li></ul></li><li>真正落盘（<code>Flush</code> 到磁盘） ➔ 要靠 <code>fsync()</code>、<code>sync()</code> 或者内核自己异步刷盘。</li></ul><hr><h3 id="8-C-语言缓冲区-vs-内核缓冲区"><a href="#8-C-语言缓冲区-vs-内核缓冲区" class="headerlink" title="8. C 语言缓冲区 vs 内核缓冲区"></a>8. C 语言缓冲区 vs 内核缓冲区</h3><table><thead><tr><th>特点</th><th>C 语言库缓冲区（用户态缓冲）</th><th>系统内核缓冲区（内核态缓冲）</th></tr></thead><tbody><tr><td>属于</td><td>用户空间</td><td>内核空间</td></tr><tr><td>负责</td><td>提高用户态小块 <code>I/O</code> 效率</td><td>提高系统磁盘 <code>I/O</code> 效率</td></tr><tr><td>刷新操作</td><td><code>fflush(FILE*)</code></td><td><code>fsync(int fd)</code></td></tr><tr><td>刷新时机</td><td>行满&#x2F;换行&#x2F;手动&#x2F;程序结束</td><td>写缓存异步、<code>fsync</code> 手动同步</td></tr><tr><td>举例</td><td><code>printf</code> 的缓存、<code>scanf</code> 缓存</td><td><code>write</code> 到文件、<code>read</code> 从文件</td></tr><tr><td>说明</td><td>属于标准库 <code>stdio</code> 层</td><td>由操作系统控制</td></tr></tbody></table><blockquote><p>  <strong>C 语言缓冲区</strong> 是为了 <strong>减少用户态到内核态的系统调用次数</strong>，<br>   <strong>内核缓冲区</strong> 是为了 <strong>减少磁盘操作的次数</strong>。</p></blockquote><p>两者分工明确，各司其职，一起大大提高了 <strong>程序和系统整体性能</strong>！</p><hr><h3 id="9-重定向后缓冲策略如何变化？"><a href="#9-重定向后缓冲策略如何变化？" class="headerlink" title="9. 重定向后缓冲策略如何变化？"></a>9. 重定向后缓冲策略如何变化？</h3><p>当我们将标准输出 <code>stdout</code> 重定向到一个 <strong>文件</strong> 时，<strong>缓冲模式会从行缓冲变为全缓冲</strong>。</p><h4 id="1-实验证明"><a href="#1-实验证明" class="headerlink" title="1. 实验证明"></a>1. 实验证明</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;打印到屏幕（终端）前先睡5秒...\n&quot;</span>);</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">5</span>);  <span class="comment">// 打印了才 sleep，说明是“行缓冲”</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在改一下输出到文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./a.out &gt; temp.txt</span><br></pre></td></tr></table></figure><p>你会发现：<strong>程序 <code>sleep</code> 完后，<code>temp.txt</code> 才会出现内容！</strong> 因为是“全缓冲”，<code>printf</code> 输出被缓存在内存中，直到程序结束才 <code>flush</code> 到文件！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;准备输出...\n&quot;</span>);</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello, File!\n&quot;</span>);</span><br><span class="line">    <span class="comment">// fflush(stdout);  // 去掉这行试试！</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行方式：./a.out &gt; test.txt</span></span><br></pre></td></tr></table></figure><p>观察：</p><ul><li>如果不加 <code>fflush()</code>，在 <code>sleep</code> 前的输出内容是否立即出现在 <code>test.txt</code>？</li><li>加了 <code>fflush()</code> 是否立刻输出？</li></ul><hr><h4 id="2-为什么会发生这种变化？"><a href="#2-为什么会发生这种变化？" class="headerlink" title="2. 为什么会发生这种变化？"></a>2. 为什么会发生这种变化？</h4><p>标准 I&#x2F;O 的缓冲策略是由库函数（如 <code>printf</code> 所依赖的 <code>stdio</code> 层）自动根据 <strong>输出目标类型</strong> 决定的：</p><table><thead><tr><th>输出目标</th><th>默认缓冲模式</th></tr></thead><tbody><tr><td>终端（屏幕）</td><td><strong>行缓冲</strong>（line-buffered）</td></tr><tr><td>普通文件</td><td><strong>全缓冲</strong>（fully-buffered）</td></tr><tr><td>管道 &#x2F; socket</td><td><strong>全缓冲</strong>（fully-buffered）</td></tr><tr><td>标准错误 stderr</td><td><strong>无缓冲</strong>（unbuffered）</td></tr></tbody></table><h4 id="3-为什么屏幕默认用行缓冲？"><a href="#3-为什么屏幕默认用行缓冲？" class="headerlink" title="3. 为什么屏幕默认用行缓冲？"></a>3. 为什么屏幕默认用行缓冲？</h4><ul><li>因为用户在终端交互时，<strong>希望立刻看到输出</strong>，不能等太久。</li><li>所以只要遇到换行符 <code>\n</code> 或缓冲区满了，就会刷新。</li></ul><h4 id="4-为什么输出到文件变成全缓冲？"><a href="#4-为什么输出到文件变成全缓冲？" class="headerlink" title="4. 为什么输出到文件变成全缓冲？"></a>4. 为什么输出到文件变成全缓冲？</h4><ul><li>写文件不需要实时响应，频繁刷写磁盘 <strong>开销很大</strong>。</li><li>所以库会自动采用 <strong>更高效的方式</strong>：<ul><li>多次 <code>printf()</code> 的内容先拼到缓冲区。</li><li>缓冲区满或手动调用 <code>fflush()</code> 时才统一写入磁盘。</li></ul></li></ul><hr><blockquote><p>  [!NOTE]</p><p>  <strong>了解内容：手动控制缓冲行为</strong></p><p>  用 <code>setvbuf()</code> 可以手动设置缓冲区行为：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setvbuf</span>(stdout, <span class="literal">NULL</span>, _IONBF, <span class="number">0</span>);      <span class="comment">// 设置 stdout 为无缓冲（unbuffered）</span></span><br><span class="line"><span class="built_in">setvbuf</span>(stdout, <span class="literal">NULL</span>, _IOLBF, <span class="number">0</span>);      <span class="comment">// 设置 stdout 为行缓冲（line-buffered）</span></span><br><span class="line"><span class="built_in">setvbuf</span>(stdout, <span class="literal">NULL</span>, _IOFBF, <span class="number">0</span>);      <span class="comment">// 设置 stdout 为全缓冲（full-buffered）</span></span><br></pre></td></tr></table></figure><p>  注意：<code>setvbuf()</code> 必须在第一次输出之前调用，否则无效！示例代码：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 设置 stdout 为无缓冲</span></span><br><span class="line">    <span class="built_in">setvbuf</span>(stdout, <span class="literal">NULL</span>, _IONBF, <span class="number">0</span>);       <span class="comment">// 立即刷新，适用于日志输出</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 stdout 为行缓冲（默认终端下行为）</span></span><br><span class="line">    <span class="comment">// setvbuf(stdout, NULL, _IOLBF, 0);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 stdout 为全缓冲（适用于文件等）</span></span><br><span class="line">    <span class="comment">// setvbuf(stdout, NULL, _IOFBF, BUFSIZ);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><hr><h4 id="5-常见情况"><a href="#5-常见情况" class="headerlink" title="5. 常见情况"></a>5. 常见情况</h4><ol><li><strong>输出内容看不到？</strong></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;日志输出：程序开始执行...\n&quot;</span>);         <span class="comment">// 重定向后不会立刻写入文件（全缓冲）</span></span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">10</span>);                                   <span class="comment">// 程序“暂停”10 秒，但日志还未写入</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;日志输出：程序即将退出。\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 注意：查看重定向文件时：在程序运行期间它是空的，只有等程序结束后才出现内容。</span></span><br></pre></td></tr></table></figure><p>解决办法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;日志输出：程序开始执行...\n&quot;</span>);</span><br><span class="line">    <span class="built_in">fflush</span>(stdout);                        <span class="comment">// 手动刷新，确保写入文件</span></span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;日志输出：程序即将退出。\n&quot;</span>);</span><br><span class="line">    <span class="built_in">fflush</span>(stdout);                        <span class="comment">// 最好在关键日志后都刷新一次</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>程序崩溃、日志文件为空？</strong></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;准备执行崩溃逻辑...\n&quot;</span>);</span><br><span class="line">    <span class="type">int</span>* p = <span class="literal">NULL</span>;</span><br><span class="line">    *p = <span class="number">42</span>;              <span class="comment">// 故意造成段错误，程序崩溃</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决办法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;准备执行崩溃逻辑...\n&quot;</span>);</span><br><span class="line">    <span class="built_in">fflush</span>(stdout);       <span class="comment">// 手动刷新，日志及时写入</span></span><br><span class="line">    <span class="type">int</span>* p = <span class="literal">NULL</span>;</span><br><span class="line">    *p = <span class="number">42</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>直接设置为无缓冲模式</strong></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">setvbuf</span>(stdout, <span class="literal">NULL</span>, _IONBF, <span class="number">0</span>);   <span class="comment">// 设置 stdout 为无缓冲模式</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;程序正在执行...\n&quot;</span>);          <span class="comment">// 会立刻写入</span></span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;程序执行结束。\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="10-简易版本的-stdio-库的实现"><a href="#10-简易版本的-stdio-库的实现" class="headerlink" title="10. 简易版本的 stdio 库的实现"></a>10. 简易版本的 <code>stdio</code> 库的实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头文件</span></span><br><span class="line"><span class="comment">//#pragma once                              // 可选，防止头文件重复包含</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __MYSTDIO_H__                       <span class="comment">// 防止头文件重复包含（include guard）</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MYSTDIO_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span>                         <span class="comment">// 用于处理字符串函数，strcmp(), memcpy()</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE 1024                           <span class="comment">// 缓冲区大小：1KB</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 缓冲刷新策略（flush strategy）标志</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FLUSH_NOW 1                         <span class="comment">// 每次写入立即刷新（立即写入文件）</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FLUSH_LINE 2                        <span class="comment">// 按行刷新（检测到换行符时刷新）</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FLUSH_ALL 4                         <span class="comment">// 缓冲区满了才刷新（默认）</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义文件结构体，模拟 FILE 类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">IO_FILE</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fileno;                             <span class="comment">// 文件描述符</span></span><br><span class="line">    <span class="type">int</span> flag;                               <span class="comment">// 刷新策略</span></span><br><span class="line">    <span class="comment">//char inbuffer[SIZE];                  // 输入缓冲区（未实现）</span></span><br><span class="line">    <span class="comment">//int in_pos;                           // 输入缓冲位置指针</span></span><br><span class="line">    <span class="type">char</span> outbuffer[SIZE];                   <span class="comment">// 输出缓冲区（output buffer）</span></span><br><span class="line">    <span class="type">int</span> out_pos;                            <span class="comment">// 当前写入缓冲区的位置</span></span><br><span class="line">&#125;_FILE;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数声明部分</span></span><br><span class="line">_FILE* _fopen(<span class="type">const</span> <span class="type">char</span>* filename, <span class="type">const</span> <span class="type">char</span>* flag);          <span class="comment">// 打开文件（模拟 fopen）</span></span><br><span class="line"><span class="type">int</span> _fwrite(_FILE* fp, <span class="type">const</span> <span class="type">char</span>* s, <span class="type">int</span> len);                 <span class="comment">// 写入字符串到缓冲区（模拟 fwrite）</span></span><br><span class="line"><span class="type">void</span> _fclose(_FILE* fp);                                        <span class="comment">// 关闭文件（模拟 fclose）</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mystdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span>                                  <span class="comment">// 基本系统数据类型定义 size_t</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span>                                   <span class="comment">// 文件权限模式常量 S_IRWXU、S_IRWXG、S_IRWXO</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span>                                      <span class="comment">// 文件控制选项 O_CREAT、O_WRONLY、O_APPEND、O_RDONLY</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>                                     <span class="comment">// malloc()、free()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>                                     <span class="comment">// read()、write()、close()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span>                                     <span class="comment">// assert() 断言检查</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FILE_MODE 0666                                  <span class="comment">// 默认文件权限 rw-rw-rw-</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 打开文件：支持 &quot;w&quot;（写入）、&quot;a&quot;（追加）、&quot;r&quot;（只读）</span></span><br><span class="line">_FILE* _fopen(<span class="type">const</span> <span class="type">char</span>* filename, <span class="type">const</span> <span class="type">char</span>* flag)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">assert</span>(filename);                                   <span class="comment">// 确保文件名不为空</span></span><br><span class="line">    <span class="built_in">assert</span>(flag);                                       <span class="comment">// 确保模式不为空</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> f = <span class="number">0</span>;                                          <span class="comment">// 打开文件使用的标志位（flags）</span></span><br><span class="line">    <span class="type">int</span> fd = <span class="number">-1</span>;                                        <span class="comment">// 文件描述符初始化为非法值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(flag, <span class="string">&quot;w&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        f = (O_CREAT | O_WRONLY | O_TRUNC);             <span class="comment">// 创建+只写+截断旧内容</span></span><br><span class="line">        fd = <span class="built_in">open</span>(filename, f, FILE_MODE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(flag, <span class="string">&quot;a&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        f = (O_CREAT | O_WRONLY | O_APPEND);            <span class="comment">// 创建+只写+追加写入</span></span><br><span class="line">        fd = <span class="built_in">open</span>(filename, f, FILE_MODE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(flag, <span class="string">&quot;r&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        f = O_RDONLY;                                   <span class="comment">// 只读模式</span></span><br><span class="line">        fd = <span class="built_in">open</span>(filename, f);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;                                    <span class="comment">// 不支持的模式，返回空指针</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;                                    <span class="comment">// 打开失败</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _FILE* fp = (_FILE*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(_FILE));          <span class="comment">// 为 _FILE 结构体分配内存</span></span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;                                    <span class="comment">// 内存分配失败</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fp-&gt;fileno = fd;                                    <span class="comment">// 设置文件描述符</span></span><br><span class="line">    <span class="comment">//fp-&gt;flag = FLUSH_LINE;                            // 可选行刷新模式</span></span><br><span class="line">    fp-&gt;flag = FLUSH_ALL;                               <span class="comment">// 默认采用缓存满再写入</span></span><br><span class="line">    fp-&gt;out_pos = <span class="number">0</span>;                                    <span class="comment">// 输出缓冲区指针置 0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> _fwrite(_FILE* fp, <span class="type">const</span> <span class="type">char</span>* s, <span class="type">int</span> len)          <span class="comment">// 写入函数：将字符串写入到自定义缓冲区中</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 将数据从字符串拷贝到输出缓冲区（假设缓冲足够）</span></span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;fp-&gt;outbuffer[fp-&gt;out_pos], s, len);        <span class="comment">// 无边界检测（简化实现）</span></span><br><span class="line">    fp-&gt;out_pos += len;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fp-&gt;flag &amp; FLUSH_NOW)                           <span class="comment">// 判断刷新策略</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">write</span>(fp-&gt;fileno, fp-&gt;outbuffer, fp-&gt;out_pos);  <span class="comment">// 立即写入所有缓冲数据到文件</span></span><br><span class="line">        fp-&gt;out_pos = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (fp-&gt;flag &amp; FLUSH_LINE)                     <span class="comment">// 按行刷新</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (fp-&gt;outbuffer[fp-&gt;out_pos - <span class="number">1</span>] == <span class="string">&#x27;\n&#x27;</span>)     <span class="comment">// 如果最后一个字符是换行符，则刷新</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">write</span>(fp-&gt;fileno, fp-&gt;outbuffer, fp-&gt;out_pos);</span><br><span class="line">            fp-&gt;out_pos = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (fp-&gt;flag &amp; FLUSH_ALL)                      <span class="comment">// 按缓存满刷新</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (fp-&gt;out_pos == SIZE)                        <span class="comment">// 缓冲区满时刷新（一次写入 SIZE 字节）</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">write</span>(fp-&gt;fileno, fp-&gt;outbuffer, fp-&gt;out_pos);</span><br><span class="line">            fp-&gt;out_pos = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> len;                                         <span class="comment">// 返回写入的长度</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 手动刷新函数（模拟 fflush）</span></span><br><span class="line"><span class="type">void</span> _fflush(_FILE* fp)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (fp-&gt;out_pos &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">write</span>(fp-&gt;fileno, fp-&gt;outbuffer, fp-&gt;out_pos);  <span class="comment">// 写入缓冲数据</span></span><br><span class="line">        fp-&gt;out_pos = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭文件（释放资源）</span></span><br><span class="line"><span class="type">void</span> _fclose(_FILE* fp)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    _fflush(fp);                                        <span class="comment">// 关闭前确保缓冲区已写入</span></span><br><span class="line">    <span class="built_in">close</span>(fp-&gt;fileno);                                  <span class="comment">// 关闭文件描述符</span></span><br><span class="line">    <span class="built_in">free</span>(fp);                                           <span class="comment">// 释放分配的内存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mystdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>                         <span class="comment">// 用于 sleep() 函数</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> myfile <span class="string">&quot;test.txt&quot;</span>                   <span class="comment">// 要写入的测试文件名称</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 打开文件，以追加模式 (&quot;a&quot;) 打开</span></span><br><span class="line">    _FILE* fp = _fopen(myfile, <span class="string">&quot;a&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;                           <span class="comment">// 打开失败则退出</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* msg = <span class="string">&quot;hello world\n&quot;</span>;      <span class="comment">// 写入的字符串内容</span></span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">10</span>;                           <span class="comment">// 循环次数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (cnt)</span><br><span class="line">    &#123;</span><br><span class="line">        _fwrite(fp, msg, <span class="built_in">strlen</span>(msg));      <span class="comment">// 每次写入一行</span></span><br><span class="line">        <span class="comment">// _fflush(fp);                     // 如需每次立即写入可手动刷新</span></span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);                           <span class="comment">// 每 1 秒写一次</span></span><br><span class="line">        cnt--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _fclose(fp);                            <span class="comment">// 写入完毕后关闭文件，释放资源</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> IO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>023 基础 IO —— 重定向</title>
      <link href="/posts/29393.html"/>
      <url>/posts/29393.html</url>
      
        <content type="html"><![CDATA[<h2 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h2><blockquote><p><a href="https://blog.csdn.net/chenlong_cxy/article/details/120743720">相关好文 | CSDN</a></p></blockquote><h3 id="1-什么是重定向？"><a href="#1-什么是重定向？" class="headerlink" title="1. 什么是重定向？"></a>1. 什么是重定向？</h3><p><strong>重定向本质上就是操作文件描述符</strong>（每一个打开的文件或设备在内核中都有一个编号，称为文件描述符），即 <strong>修改标准输入&#x2F;输出&#x2F;错误</strong> 这三个文件描述符（file descriptor，简称 FD）的指向，让它们 <strong>不再指向默认终端（屏幕、键盘）</strong>，而是指向 <strong>文件、设备或者其他地方</strong>。</p><table><thead><tr><th>文件描述符编号</th><th>描述</th><th>默认指向</th></tr></thead><tbody><tr><td>0</td><td>标准输入 <code>stdin</code></td><td>键盘</td></tr><tr><td>1</td><td>标准输出 <code>stdout</code></td><td>屏幕</td></tr><tr><td>2</td><td>标准错误 <code>stderr</code></td><td>屏幕</td></tr></tbody></table><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250426191149822.png" alt="image-20250426191149734"></p><p>比如常见的 <code>shell</code> 命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> &gt; output.txt</span><br></pre></td></tr></table></figure><p><strong>背后的本质动作是：</strong></p><ol><li>关闭文件描述符 1（stdout）</li><li>打开或创建 <code>output.txt</code></li><li>将描述符 1 指向 <code>output.txt</code> 文件</li></ol><p>这样，<strong>所有本应该显示在屏幕上的内容，都会写入 <code>output.txt</code> 文件</strong>。</p><hr><h3 id="2-常见的重定向符号"><a href="#2-常见的重定向符号" class="headerlink" title="2. 常见的重定向符号"></a>2. 常见的重定向符号</h3><table><thead><tr><th>符号</th><th>含义</th><th>功能描述</th><th>示例</th><th>效果</th></tr></thead><tbody><tr><td><code>&gt;</code></td><td>输出重定向（覆盖），<code>stdout</code></td><td>把标准输出写入到指定文件，若文件存在则 <strong>清空</strong> 后写入，否则创建</td><td><code>ls &gt; out.txt</code></td><td>将 <code>ls</code> 的 stdout 写入（或覆盖）<code>out.txt</code></td></tr><tr><td><code>&gt;&gt;</code></td><td>输出追加，<code>stdout</code></td><td>把标准输出追加到指定文件末尾，若文件不存在则创建</td><td><code>echo hi &gt;&gt; out.txt</code></td><td>将 <code>hi</code> 追加到 <code>out.txt</code> 末尾</td></tr><tr><td><code>&lt;</code></td><td>输入重定向，<code>stdin</code></td><td>从指定文件读取内容作为标准输入</td><td><code>wc -l &lt; in.txt</code></td><td>将 <code>in.txt</code> 作为 stdin 传给 <code>wc -l</code></td></tr><tr><td><code>&lt;&lt;</code></td><td>Here-Document（多行输入）</td><td>在脚本中内联一段文本作为标准输入，直到遇到结束标识符</td><td></td><td></td></tr></tbody></table><hr><h3 id="3-使用-dup2-系统调用"><a href="#3-使用-dup2-系统调用" class="headerlink" title="3. 使用 dup2 系统调用"></a>3. 使用 dup2 系统调用</h3><h4 id="1-dup2-是什么？"><a href="#1-dup2-是什么？" class="headerlink" title="1. dup2 是什么？"></a>1. dup2 是什么？</h4><p><strong><code>dup2</code> 是一个系统调用，用于复制文件描述符。本质作用就是：让两个文件描述符指向同一个内核打开文件表项。经常用于做输入输出重定向。</strong></p><h4 id="2-函数原型"><a href="#2-函数原型" class="headerlink" title="2. 函数原型"></a>2. 函数原型</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dup2</span><span class="params">(<span class="type">int</span> oldfd, <span class="type">int</span> newfd)</span>;</span><br></pre></td></tr></table></figure><p><strong>参数：</strong></p><ul><li><strong><code>oldfd</code>：</strong> 已经打开的文件描述符（比如文件、管道等）</li><li><strong><code>newfd</code>：</strong> 要复制到的新文件描述符（比如 0&#x2F;1&#x2F;2）</li></ul><p><strong>返回值：成功：</strong> 返回 <code>newfd</code>；<strong>失败：</strong> 返回 <code>-1</code>，并设置 errno 错误号（需要 perror 打印）</p><h4 id="3-dup2-做了什么事情？（内部流程）"><a href="#3-dup2-做了什么事情？（内部流程）" class="headerlink" title="3. dup2 做了什么事情？（内部流程）"></a>3. dup2 做了什么事情？（内部流程）</h4><p>假设调用 <code>dup2(oldfd, newfd)</code>：</p><ul><li>如果 <code>oldfd == newfd</code>：直接返回 <code>newfd</code>，<strong>什么也不做</strong>（高效优化）；</li><li>如果 <code>newfd</code> 已经打开，会 <strong>先关闭 newfd</strong>（防止资源泄漏）；</li><li>然后 <strong>让 newfd 指向 oldfd 指向的内核文件表项</strong>。</li></ul><p><strong>注意：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">         ┌──────────────┐</span><br><span class="line">oldfd →  │ 内核打开文件表 │ ← newfd</span><br><span class="line">         └──────────────┘</span><br></pre></td></tr></table></figure><p><strong>不是简单复制数字，而是让它们“指向同一块内核资源”！dup2 后，<code>oldfd</code> 和 <code>newfd</code> 同时指向同一个内核文件表结构。修改一边，另一边也受影响（因为指的是同一份数据）。</strong></p><h4 id="4-代码实验验证"><a href="#4-代码实验验证" class="headerlink" title="4. 代码实验验证"></a>4. 代码实验验证</h4><p>如何 <strong>将 printf 打印内容重定向到一个文件中</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>              <span class="comment">// printf, perror</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>             <span class="comment">// dup2, close</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span>              <span class="comment">// open</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;output.txt&quot;</span>, O_WRONLY | O_CREAT | O_TRUNC, <span class="number">0644</span>);        <span class="comment">// 打开一个文件，准备写入（如果不存在就会自动创建）</span></span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open failed&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(<span class="number">1</span>);                                                               <span class="comment">// 关闭标准输出 1（stdout）</span></span><br><span class="line"></span><br><span class="line">    dup2(fd, <span class="number">1</span>);                                                            <span class="comment">// 将打开的文件描述符复制到 1（标准输出）</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;这行文字被写入到 output.txt 文件中啦！\n&quot;</span>);                        <span class="comment">// 现在所有的 printf 都不会打印到屏幕，而是写到 output.txt</span></span><br><span class="line">    dprintf(fd, <span class="string">&quot;这是直接用 fd 写的一行文字！\n&quot;</span>);                             <span class="comment">// 可以继续用 fd 写数据（可选）</span></span><br><span class="line"></span><br><span class="line">    close(fd);                                                              <span class="comment">// 关闭文件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行示例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gcc dup2_1.c -o dup2_1</span><br><span class="line">./dup2_1</span><br><span class="line"><span class="built_in">cat</span> output.txt</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250426193916829.png" alt="image-20250426193916749"></p><p>你会看到 <code>output.txt</code> 文件里出现了程序输出的内容，而不是显示在屏幕上！</p><h4 id="5-标准错误也能重定向"><a href="#5-标准错误也能重定向" class="headerlink" title="5. 标准错误也能重定向"></a>5. 标准错误也能重定向</h4><p>如果想把错误信息也重定向，可以：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dup2(fd, STDERR_FILENO); <span class="comment">// 把标准错误（2）也重定向到 fd</span></span><br></pre></td></tr></table></figure><p>这样 <code>perror</code>、<code>fprintf(stderr, ...)</code> 的内容也会写进文件！</p><hr><h4 id="6-minishell-重定向"><a href="#6-minishell-重定向" class="headerlink" title="6. minishell 重定向"></a>6. <code>minishell</code> 重定向</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pwd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEN 1024<span class="comment">// 命令最大长度</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NUM 32<span class="comment">// 命令拆分后的最大个数</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> type = <span class="number">0</span>;<span class="comment">// 0 &gt;, 1 &gt;&gt;, 2 &lt;</span></span><br><span class="line"><span class="type">char</span> cmd[LEN];<span class="comment">// 存储命令</span></span><br><span class="line"><span class="type">char</span>* myargv[NUM];<span class="comment">// 存储命令拆分后的结果</span></span><br><span class="line"><span class="type">char</span> hostname[<span class="number">32</span>];<span class="comment">// 主机名</span></span><br><span class="line"><span class="type">char</span> pwd[<span class="number">128</span>];<span class="comment">// 当前目录</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//获取命令提示信息</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">passwd</span>* pass = <span class="built_in">getpwuid</span>(<span class="built_in">getuid</span>());</span><br><span class="line"><span class="built_in">gethostname</span>(hostname, <span class="built_in">sizeof</span>(hostname) - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">getcwd</span>(pwd, <span class="built_in">sizeof</span>(pwd) - <span class="number">1</span>);</span><br><span class="line"><span class="type">int</span> len = <span class="built_in">strlen</span>(pwd);</span><br><span class="line"><span class="type">char</span>* p = pwd + len - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (*p != <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">p--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p++;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[%s@%s %s]$ &quot;</span>, pass-&gt;pw_name, hostname, p);<span class="comment">// 打印命令提示信息</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">fgets</span>(cmd, LEN, stdin);<span class="comment">// 读取命令</span></span><br><span class="line">cmd[<span class="built_in">strlen</span>(cmd) - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* start = cmd;<span class="comment">// 实现重定向功能</span></span><br><span class="line"><span class="keyword">while</span> (*start != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (*start == <span class="string">&#x27;&gt;&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">type = <span class="number">0</span>;<span class="comment">// 遇到一个&#x27;&gt;&#x27;，输出重定向</span></span><br><span class="line">*start = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">start++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (*start == <span class="string">&#x27;&gt;&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">type = <span class="number">1</span>;<span class="comment">// 遇到第二个&#x27;&gt;&#x27;，追加重定向</span></span><br><span class="line">start++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (*start == <span class="string">&#x27;&lt;&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">type = <span class="number">2</span>;<span class="comment">// 遇到&#x27;&lt;&#x27;，输入重定向</span></span><br><span class="line">*start = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">start++;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">start++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (*start != <span class="string">&#x27;\0&#x27;</span>)<span class="comment">// start位置不为&#x27;\0&#x27;，说明命令包含重定向内容</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isspace</span>(*start))<span class="comment">// 跳过重定向符号后面的空格</span></span><br><span class="line">&#123;</span><br><span class="line">start++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">start = <span class="literal">NULL</span>;<span class="comment">// start设置为NULL，标识命令当中不含重定向内容</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//拆分命令</span></span><br><span class="line">myargv[<span class="number">0</span>] = <span class="built_in">strtok</span>(cmd, <span class="string">&quot; &quot;</span>);</span><br><span class="line"><span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (myargv[i] = <span class="built_in">strtok</span>(<span class="literal">NULL</span>, <span class="string">&quot; &quot;</span>))</span><br><span class="line">&#123;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> id = fork();<span class="comment">// 创建子进程执行命令</span></span><br><span class="line"><span class="keyword">if</span> (id == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (start != <span class="literal">NULL</span>)<span class="comment">// 重定向符号后面有内容</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (type == <span class="number">0</span>)<span class="comment">// 输出重定向</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> fd = <span class="built_in">open</span>(start, O_WRONLY | O_CREAT | O_TRUNC, <span class="number">0664</span>);<span class="comment">// 以写的方式打开文件（清空原文件内容）</span></span><br><span class="line"><span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">error</span>(<span class="string">&quot;open&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">close</span>(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">dup2</span>(fd, <span class="number">1</span>);<span class="comment">// 重定向</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="number">1</span>)<span class="comment">// 追加重定向</span></span><br><span class="line">&#123; </span><br><span class="line"><span class="type">int</span> fd = <span class="built_in">open</span>(start, O_WRONLY | O_APPEND | O_CREAT, <span class="number">0664</span>);<span class="comment">// 以追加的方式打开文件</span></span><br><span class="line"><span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">perror</span>(<span class="string">&quot;open&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">dup2</span>(fd, <span class="number">1</span>);<span class="comment">// 重定向</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span><span class="comment">// 输入重定向</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> fd = <span class="built_in">open</span>(start, O_RDONLY);<span class="comment">// 以读的方式打开文件</span></span><br><span class="line"><span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">perror</span>(<span class="string">&quot;open&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">dup2</span>(fd, <span class="number">0</span>);<span class="comment">// 重定向</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">execvp</span>(myargv[<span class="number">0</span>], myargv);<span class="comment">// child进行程序替换</span></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);<span class="comment">// 替换失败的退出码设置为1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//shell</span></span><br><span class="line"><span class="type">int</span> status = <span class="number">0</span>;</span><br><span class="line"><span class="type">pid_t</span> ret = <span class="built_in">waitpid</span>(id, &amp;status, <span class="number">0</span>);<span class="comment">// shell等待child退出</span></span><br><span class="line"><span class="keyword">if</span> (ret &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;exit code:%d\n&quot;</span>, <span class="built_in">WEXITSTATUS</span>(status));      <span class="comment">// 打印child的退出码</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="4-1（stdout）-VS-2（stderr）"><a href="#4-1（stdout）-VS-2（stderr）" class="headerlink" title="4. 1（stdout） VS 2（stderr）"></a>4. 1（stdout） VS 2（stderr）</h3><p>还是那句话，在类 <code>Linux</code> 中，每个进程启动时都会默认打开三个 <strong>文件描述符（file descriptor）</strong>，分别对应三个“数据通道（stream）”：</p><table><thead><tr><th>描述符</th><th>名称（英文）</th><th>默认指向</th><th>常用符号</th></tr></thead><tbody><tr><td>0</td><td>标准输入（stdin）</td><td>键盘（或重定向的输入文件）</td><td><code>&lt;</code></td></tr><tr><td>1</td><td>标准输出（stdout）</td><td>终端屏幕（或重定向的输出文件）</td><td><code>&gt;</code></td></tr><tr><td>2</td><td>标准错误（stderr）</td><td>终端屏幕（或重定向的错误文件）</td><td><code>2&gt;</code></td></tr></tbody></table><h4 id="1-基本重定向：分开输出"><a href="#1-基本重定向：分开输出" class="headerlink" title="1. 基本重定向：分开输出"></a>1. 基本重定向：分开输出</h4><ul><li><code>1&gt;file1.txt</code>  将 <strong>stdout</strong> 写入 <code>file1.txt</code></li><li><code>2&gt;file2.txt</code>  将 <strong>stderr</strong> 写入 <code>file2.txt</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./mytest 1&gt;file1.txt 2&gt;file2.txt<span class="comment"># 执行名为 mytest 的程序，并进行输出重定向</span></span><br><span class="line"><span class="comment"># 任何正常输出（如 printf、cout 等）都会进入 file1.txt</span></span><br><span class="line"><span class="comment"># 任何错误信息（如 error: …、segfault 报错）都会进入 file2.txt</span></span><br></pre></td></tr></table></figure><p>如果只写 <code>&gt;file1.txt</code>，<code>Shell</code> 会把它当作 <code>1&gt;file1.txt</code> 处理，因为不加数字时默认重定向文件描述符 1（stdout）。</p><h4 id="2-将-stderr-重定向到-stdout-已指向的文件"><a href="#2-将-stderr-重定向到-stdout-已指向的文件" class="headerlink" title="2. 将 stderr 重定向到 stdout 已指向的文件"></a>2. 将 stderr 重定向到 stdout 已指向的文件</h4><p>有时希望把 <strong>stderr</strong> 合并到与 <strong>stdout</strong> 相同的目标中，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./mytest &gt;all.txt 2&gt;&amp;1</span><br></pre></td></tr></table></figure><p>这里的执行顺序和含义要注意：</p><ol><li><strong><code>&gt;all.txt</code>：</strong> 先把 <strong>stdout (1)</strong> 重定向到 <code>all.txt</code>。</li><li><strong><code>2&gt;&amp;1</code>：</strong> 再把 <strong>stderr (2)</strong> “重定向到（&amp;）” <strong>描述符 1</strong> 当前所指向的地方。</li></ol><p>最终，<code>all.txt</code> 会包含正常输出和错误输出，顺序按照程序真正写入时的先后混合在一起。</p><blockquote><p>  <strong>注意顺序</strong></p><ul><li>如果写成 <code>./mytest 2&gt;&amp;1 &gt;all.txt</code>，则会先将 stderr 重定向到 <strong>原先</strong> 的 stdout（通常还是终端），然后再把 stdout 重定向到 <code>all.txt</code>，结果是：<ul><li>stderr 仍然打印到终端</li><li>stdout 写入 <code>all.txt</code></li></ul></li></ul></blockquote><h4 id="3-追加模式（append）"><a href="#3-追加模式（append）" class="headerlink" title="3. 追加模式（append）"></a>3. 追加模式（append）</h4><ul><li><code>&gt;&gt;</code> ：向文件末尾追加（append），不覆盖原文件</li><li><code>2&gt;&gt;</code>：同理，对 stderr 追加</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./mytest &gt;&gt;out.log 2&gt;&gt;err.log</span><br><span class="line">./mytest &gt;&gt;all.log 2&gt;&amp;1       <span class="comment"># 追加模式下合并所有输出</span></span><br></pre></td></tr></table></figure><h4 id="4-Bash-的简写特性"><a href="#4-Bash-的简写特性" class="headerlink" title="4. Bash 的简写特性"></a>4. Bash 的简写特性</h4><p>Bash 提供了更简洁的写法，将 stdout 与 stderr 同时重定向：</p><ul><li><code>&amp;&gt;</code>：等价于 <code>&gt;file 2&gt;&amp;1</code></li><li><code>&amp;&gt;&gt;</code>：等价于 <code>&gt;&gt;file 2&gt;&amp;1</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./mytest &amp;&gt;both.log      <span class="comment"># 将 stdout 和 stderr 一次性写入 both.log（覆盖）</span></span><br><span class="line">./mytest &amp;&gt;&gt;both.log     <span class="comment"># 将 stdout 和 stderr 追加到 both.log</span></span><br></pre></td></tr></table></figure><h4 id="5-形象比喻"><a href="#5-形象比喻" class="headerlink" title="5. 形象比喻"></a>5. 形象比喻</h4><p>可把 <strong>stdout</strong>（1）比作“普通信件通道”，<strong>stderr</strong>（2）比作“特别邮件通道”：</p><ol><li><strong>各走各的信道</strong><ul><li><code>1&gt;normal.txt 2&gt;error.txt</code></li><li>相当于把普通信件放到 A 信箱，特别邮件放到 B 信箱。</li></ul></li><li><strong>合并邮件</strong><ul><li><code>&gt;all.txt 2&gt;&amp;1</code></li><li>先把普通信件都放进 C 信箱，再把特别邮件也投入到 C 信箱。</li></ul></li></ol><hr><h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h3><p><strong>重定向 &#x3D; 文件描述符指向改变</strong>。通过 <code>close + dup2</code> 等系统调用，把标准输入输出 <strong>重新绑定</strong> 到文件或设备上。</p><ol><li><strong>单独重定向</strong><ul><li><code>cmd 1&gt;out.txt 2&gt;err.txt</code></li></ul></li><li><strong>合并到同一文件</strong><ul><li>覆盖： <code>cmd &gt;all.txt 2&gt;&amp;1</code> 或 <code>cmd &amp;&gt;all.txt</code></li><li>追加： <code>cmd &gt;&gt;all.txt 2&gt;&amp;1</code> 或 <code>cmd &amp;&gt;&gt;all.txt</code></li></ul></li><li><strong>顺序关键</strong><ul><li><code>2&gt;&amp;1</code> 始终要写在将 stdout 重定向之后，才能“接上”正确的目标。</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> IO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>022 基础 IO —— 文件</title>
      <link href="/posts/15473.html"/>
      <url>/posts/15473.html</url>
      
        <content type="html"><![CDATA[<h2 id="基础-IO-——-C-语言文件-I-O-操作基础"><a href="#基础-IO-——-C-语言文件-I-O-操作基础" class="headerlink" title="基础 IO —— C 语言文件 I/O 操作基础"></a>基础 <code>IO</code> —— <code>C</code> 语言文件 <code>I/O</code> 操作基础</h2><blockquote><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p><strong>1. 文件的基本概念</strong></p><p>文件的定义：</p><ul><li><strong>文件 &#x3D; 内容（数据） + 属性</strong>（如权限、修改时间、所有者等）。</li><li>属性是文件管理的重要依据，贯穿文件的存储、访问和控制全流程。</li></ul><p><strong>2. 文件的两种状态</strong></p><ol><li><p><strong>打开的文件</strong>  </p><ul><li><strong>触发条件</strong>：由进程主动打开（如读写操作）。</li><li><strong>存储位置</strong>：加载到内存中。</li><li><strong>核心机制：</strong><ul><li><strong>进程关联</strong>：每个打开的文件需与进程绑定，形成“进程-文件”的 <strong>多对一关系</strong>（<strong>1: n 关系：一个进程可打开多个文件</strong>）。</li><li><strong>内核管理</strong>：操作系统为每个打开的文件创建 <strong>文件打开对象</strong>（如 <code>struct XXX</code>），记录文件属性、状态及链表指针（如 <code>next</code>），便于统一管理。</li></ul></li></ul></li><li><p><strong>未打开的文件</strong>  </p><ul><li><strong>存储位置</strong>：磁盘上。</li><li><strong>核心问题</strong>：如何高效组织海量未打开文件，支持 <strong>快速增删查改</strong>。</li><li><strong>管理目标</strong>：通过目录结构、文件系统层级等实现文件分类与定位。</li></ul></li></ol><p><strong>3. 操作系统如何管理打开的文件</strong></p><ol><li><p><strong>管理原则 —— 先描述，后组织：</strong>  </p><ul><li><strong>描述</strong>：为每个打开的文件创建内核对象（如 <code>struct file</code>），记录文件属性（如读写位置、权限）和操作接口。  </li><li><strong>组织</strong>：通过链表、哈希表等数据结构管理所有打开的文件对象，实现高效访问。</li></ul></li><li><p><strong>关键数据结构示例</strong>  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">mode_t</span> permissions;    <span class="comment">// 文件权限</span></span><br><span class="line">    <span class="type">off_t</span> read_offset;     <span class="comment">// 当前读位置</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span>;</span>   <span class="comment">// 指向磁盘文件的元数据（如 inode）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">next</span>;</span>     <span class="comment">// 链表指针，用于组织多个打开的文件</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>核心目标</strong>  </p><ul><li>高效管理大量打开的文件。  </li><li>确保进程间文件操作的隔离性与安全性（如通过文件描述符隔离）。</li></ul></li></ol></blockquote><h3 id="1-C-语言文件操作函数汇总"><a href="#1-C-语言文件操作函数汇总" class="headerlink" title="1. C 语言文件操作函数汇总"></a>1. C 语言文件操作函数汇总</h3><p><a href="https://blog.csdn.net/Huangcancan666/article/details/140827857?spm=1001.2014.3001.5501">CSDN 相关文章</a></p><h4 id="1-文件打开与关闭"><a href="#1-文件打开与关闭" class="headerlink" title="1. 文件打开与关闭"></a>1. 文件打开与关闭</h4><table><thead><tr><th>函数</th><th>参数与模式</th><th>返回值</th><th>功能描述</th><th>示例</th></tr></thead><tbody><tr><td><code>fopen</code></td><td><code>(const char *filename, const char *mode)</code><br>模式：<code>&quot;r&quot;</code>（读）、<code>&quot;w&quot;</code>（写覆盖）、<code>&quot;a&quot;</code>（追加）、<code>&quot;rb&quot;</code>（二进制读）等</td><td><code>FILE*</code>（成功）<br><code>NULL</code>（失败）</td><td>打开文件并返回文件指针</td><td><code>FILE *fp = fopen(&quot;test.txt&quot;, &quot;r&quot;);</code></td></tr><tr><td><code>fclose</code></td><td><code>(FILE *stream)</code></td><td><code>0</code>（成功）<br><code>EOF</code>（失败）</td><td>关闭文件流并释放资源</td><td><code>fclose(fp);</code></td></tr><tr><td><code>freopen</code></td><td><code>(const char *filename, const char *mode, FILE *stream)</code></td><td><code>FILE*</code>（新流）<br><code>NULL</code>（失败）</td><td>重定向已打开的流到新文件</td><td><code>freopen(&quot;log.txt&quot;, &quot;a&quot;, stdout);</code></td></tr></tbody></table><h4 id="2-字符与字符串读写"><a href="#2-字符与字符串读写" class="headerlink" title="2. 字符与字符串读写"></a>2. 字符与字符串读写</h4><table><thead><tr><th>函数</th><th>参数与说明</th><th>返回值</th><th>功能描述</th><th>注意事项</th></tr></thead><tbody><tr><td><code>fputc</code></td><td><code>(int char, FILE *stream)</code></td><td>写入的字符（成功）<br><code>EOF</code>（失败）</td><td>向文件写入一个字符</td><td>适用于文本文件</td></tr><tr><td><code>fgetc</code></td><td><code>(FILE *stream)</code></td><td>读取的字符（成功）<br><code>EOF</code>（失败或结尾）</td><td>从文件读取一个字符</td><td>需用 <code>feof</code> 检测结尾</td></tr><tr><td><code>fputs</code></td><td><code>(const char *str, FILE *stream)</code></td><td>非负值（成功）<br><code>EOF</code>（失败）</td><td>向文件写入字符串（不自动加 <code>\n</code>）</td><td>确保字符串以 <code>\0</code> 结尾</td></tr><tr><td><code>fgets</code></td><td><code>(char *str, int n, FILE *stream)</code></td><td><code>str</code>（成功）<br><code>NULL</code>（失败或结尾）</td><td>从文件读取一行字符串（最多 <code>n-1</code> 字符）</td><td>保留换行符，末尾补 <code>\0</code></td></tr></tbody></table><h4 id="3-格式化读写"><a href="#3-格式化读写" class="headerlink" title="3. 格式化读写"></a>3. 格式化读写</h4><table><thead><tr><th>函数</th><th>参数与格式说明</th><th>返回值</th><th>功能描述</th><th>示例</th></tr></thead><tbody><tr><td><code>fprintf</code></td><td><code>(FILE *stream, const char *format, ...)</code></td><td>写入的字符数（成功）<br>负值（失败）</td><td>按格式向文件写入数据</td><td><code>fprintf(fp, &quot;Value: %d&quot;, 42);</code></td></tr><tr><td><code>fscanf</code></td><td><code>(FILE *stream, const char *format, ...)</code></td><td>成功匹配的参数数量（成功）<br><code>EOF</code>（失败）</td><td>按格式从文件读取数据</td><td><code>fscanf(fp, &quot;%d&quot;, &amp;num);</code></td></tr></tbody></table><h4 id="4-二进制文件读写"><a href="#4-二进制文件读写" class="headerlink" title="4. 二进制文件读写"></a>4. 二进制文件读写</h4><table><thead><tr><th>函数</th><th>参数与说明</th><th>返回值</th><th>功能描述</th><th>注意事项</th></tr></thead><tbody><tr><td><code>fwrite</code></td><td><code>(const void *ptr, size_t size, size_t count, FILE *stream)</code></td><td>成功写入的项数</td><td>向二进制文件写入数据块</td><td>参数顺序：数据指针、项大小、项数量</td></tr><tr><td><code>fread</code></td><td><code>(void *ptr, size_t size, size_t count, FILE *stream)</code></td><td>成功读取的项数</td><td>从二进制文件读取数据块</td><td>需检查返回值以确认实际读取量</td></tr></tbody></table><h4 id="5-文件定位与状态"><a href="#5-文件定位与状态" class="headerlink" title="5. 文件定位与状态"></a>5. 文件定位与状态</h4><table><thead><tr><th>函数</th><th>参数与说明</th><th>返回值</th><th>功能描述</th><th>示例</th></tr></thead><tbody><tr><td><code>fseek</code></td><td><code>(FILE *stream, long offset, int origin)</code><br><code>origin</code>：<code>SEEK_SET</code>（文件头）、<code>SEEK_CUR</code>（当前位置）、<code>SEEK_END</code>（文件尾）</td><td><code>0</code>（成功）<br>非零（失败）</td><td>移动文件指针到指定位置</td><td><code>fseek(fp, 10, SEEK_SET);</code></td></tr><tr><td><code>ftell</code></td><td><code>(FILE *stream)</code></td><td>当前偏移量（成功）<br><code>-1L</code>（失败）</td><td>获取文件指针当前位置</td><td><code>long pos = ftell(fp);</code></td></tr><tr><td><code>rewind</code></td><td><code>(FILE *stream)</code></td><td>无</td><td>重置文件指针到文件开头</td><td><code>rewind(fp);</code></td></tr><tr><td><code>feof</code></td><td><code>(FILE *stream)</code></td><td>非零值（到结尾）<br><code>0</code>（未到结尾）</td><td>检测文件指针是否到达结尾</td><td><code>if (feof(fp)) &#123; ... &#125;</code></td></tr><tr><td><code>ferror</code></td><td><code>(FILE *stream)</code></td><td>非零值（有错误）<br><code>0</code>（无错误）</td><td>检测文件操作是否出错</td><td><code>if (ferror(fp)) &#123; ... &#125;</code></td></tr></tbody></table><h4 id="6-其他辅助函数"><a href="#6-其他辅助函数" class="headerlink" title="6. 其他辅助函数"></a>6. 其他辅助函数</h4><table><thead><tr><th>函数</th><th>参数与说明</th><th>返回值</th><th>功能描述</th><th>示例</th></tr></thead><tbody><tr><td><code>fflush</code></td><td><code>(FILE *stream)</code></td><td><code>0</code>（成功）<br><code>EOF</code>（失败）</td><td>强制将缓冲区数据写入文件</td><td><code>fflush(fp);</code></td></tr><tr><td><code>remove</code></td><td><code>(const char *filename)</code></td><td><code>0</code>（成功）<br>非零（失败）</td><td>删除指定文件</td><td><code>remove(&quot;temp.txt&quot;);</code></td></tr><tr><td><code>rename</code></td><td><code>(const char *oldname, const char *newname)</code></td><td><code>0</code>（成功）<br>非零（失败）</td><td>重命名或移动文件</td><td><code>rename(&quot;old.txt&quot;, &quot;new.txt&quot;);</code></td></tr></tbody></table><h3 id="2-什么是当前路径？"><a href="#2-什么是当前路径？" class="headerlink" title="2. 什么是当前路径？"></a>2. 什么是当前路径？</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">FILE* fp = fopen(<span class="string">&quot;temp.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);<span class="comment">// 打开文件，如果文件不存在则创建，如果存在则覆盖</span></span><br><span class="line"><span class="keyword">if</span> (fp == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">&quot; fopen&quot;</span>);<span class="comment">// 如果打开文件失败，打印错误信息</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fclose(fp);<span class="comment">// 关闭文件</span></span><br><span class="line">sleep(<span class="number">1</span>);<span class="comment">// 休眠 1 秒</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250423181745155.png" alt="image-20250423181745027"></p><p>由上我们知道，当 <code>fopen</code> 以写入的方式打开一个文件时，若该文件不存在，则会自动在当前路径创建该文件，那么这里所说的当前路径指的是什么呢？答案是 <strong>进程的当前路径——<code>cwd</code></strong>。验证：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">chdir</span>(<span class="string">&quot;/home/hcc&quot;</span>);<span class="comment">// 改变当前工作目录为/home/hcc(注意：目录不存在，可能会导致后续操作失败)</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Pid: %d\n&quot;</span>, <span class="built_in">getpid</span>());          <span class="comment">// 打印进程 ID</span></span><br><span class="line"></span><br><span class="line">    FILE* fp = <span class="built_in">fopen</span>(<span class="string">&quot;temp.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);      <span class="comment">// 打开文件，如果文件不存在则创建，如果存在则覆盖</span></span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot; fopen&quot;</span>);            <span class="comment">// 如果打开文件失败，打印错误信息</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fclose</span>(fp);                <span class="comment">// 关闭文件</span></span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">100</span>);                    <span class="comment">// 休眠 100 秒</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250423195323570.png" alt="image-20250423195323426"></p><h3 id="3-w-总是先清空，再写入"><a href="#3-w-总是先清空，再写入" class="headerlink" title="3. w 总是先清空，再写入"></a>3. <code>w</code> 总是先清空，再写入</h3><p><strong><code>fopen</code> 的 <code>w</code> 模式，当以 w 模式打开文件时：</strong></p><ul><li>如果文件不存在，则创建新文件。</li><li>如果文件已存在，则清空原有内容并重新开始写入。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>         <span class="comment">// 包含系统调用的头文件，如 getpid 等</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span>         <span class="comment">// 包含字符串处理函数的头文件，如 strlen 等</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Pid: %d\n&quot;</span>, getpid());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开文件 temp.txt，模式为 &quot;w&quot;，表示以写方式打开文件</span></span><br><span class="line">    <span class="comment">// 如果文件不存在，则创建该文件</span></span><br><span class="line">    <span class="comment">// 如果文件已存在，则覆盖原有内容</span></span><br><span class="line">    FILE* fp = fopen(<span class="string">&quot;temp.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fopen&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* message = <span class="string">&quot;abcd&quot;</span>;       <span class="comment">// 定义一个字符串常量 message，字符串常量是只读的，不能被修改</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将字符串 message 写入文件</span></span><br><span class="line">    <span class="comment">// fwrite 函数用于将数据写入文件</span></span><br><span class="line">    <span class="comment">// 第一个参数是要写入的数据的指针</span></span><br><span class="line">    <span class="comment">// 第二个参数是每个数据单元的大小，这里是 1 字节（即每个字符）</span></span><br><span class="line">    <span class="comment">// 第三个参数是数据单元的数量，这里是字符串的长度加 1（包括字符串结束符&#x27;\0&#x27;）</span></span><br><span class="line">    <span class="comment">// 第四个参数是文件指针</span></span><br><span class="line">    fwrite(message, <span class="built_in">strlen</span>(message) + <span class="number">1</span>, <span class="number">1</span>, fp);</span><br><span class="line"></span><br><span class="line">    fclose(fp);                         <span class="comment">// 关闭文件</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250423202401793.png" alt="image-20250423202401670"></p><p>好像没什么问题，<code>w</code> 会先清空文件，再将新文件内容进行写入，但是当我们打开这个 <code>temp.txt</code> 文件就会发现一点问题：</p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250423203204650.png" alt="image-20250423203204561"></p><p><strong>注意：<code>w</code> 即使不写入数据，只打开文件也会清空文件数据！</strong> 因为 <code>w</code> 是先清空再写入。</p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250423204157546.png" alt="image-20250423204157421"></p><p><strong><code>echo</code> 与 <code>fopen</code> 的关系</strong></p><ul><li><strong>底层实现</strong>：<code>echo</code> 是 shell 命令，但其重定向功能依赖于操作系统提供的文件 I&#x2F;O 机制。</li><li><strong>类比 <code>fopen(&quot;w&quot;)</code></strong>：当执行 <code>echo ... &gt; file</code> 时，系统调用类似 <code>fopen(file, &quot;w&quot;)</code> 的操作，确保输出内容替换原有数据。</li></ul><p><strong>虽然 <code>echo</code> 本身不直接调用 <code>fopen</code>，但其重定向功能在底层实现了与 <code>fopen(&quot;w&quot;)</code> 相同的效果：覆盖原有文件内容。因此，可以认为 <code>echo</code> 的重定向机制在功能上模拟了 <code>fopen</code> 的 <code>w</code> 模式。</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;现在有文件数据哦！&quot;</span> &gt; temp.txt<span class="comment"># 创建初始文件</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;你好！&quot;</span> &gt; temp.txt<span class="comment"># 使用 echo 覆盖内容</span></span><br><span class="line"><span class="built_in">cat</span> temp.txt<span class="comment"># 查看结果</span></span><br><span class="line"></span><br><span class="line">结果显示：temp.txt的内容被完全替换为“你好！”，证明<span class="built_in">echo</span>的重定向行为等同于fopen的w模式。</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250423205108411.png" alt="image-20250423205108315"></p><h3 id="4-a-是追加写"><a href="#4-a-是追加写" class="headerlink" title="4. a 是追加写"></a>4. <code>a</code> 是追加写</h3><table><thead><tr><th><strong>特性</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>追加模式</strong></td><td>写入内容总在文件末尾，不覆盖原有数据。</td></tr><tr><td><strong>自动创建文件</strong></td><td>若文件不存在，<code>a</code> 模式会创建新文件。</td></tr><tr><td><strong>文本模式 vs 二进制</strong></td><td>默认为文本模式（<code>&quot;a&quot;</code>），若需二进制追加，使用 <code>&quot;ab&quot;</code>。</td></tr><tr><td><strong>缓冲区依赖</strong></td><td>写入内容需等待缓冲区满或显式刷新（<code>fflush</code>）后才写入磁盘。</td></tr></tbody></table><p><strong>1. 基本追加写入</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    FILE* file = fopen(<span class="string">&quot;log.txt&quot;</span>, <span class="string">&quot;a&quot;</span>);             <span class="comment">// 以追加模式打开文件</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (file == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;打开文件失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(file, <span class="string">&quot;这是一个测试文件\n&quot;</span>);             <span class="comment">// 写入内容到文件末尾</span></span><br><span class="line">    fclose(file);                                  <span class="comment">// 关闭文件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="特性说明"><a href="#特性说明" class="headerlink" title="特性说明"></a>特性说明</h4><ul><li><strong>追加行为</strong>：每次写入均追加到文件末尾，不覆盖原有内容。</li><li><strong>自动创建</strong>：若文件不存在，<code>a</code> 模式会自动创建新文件。</li></ul><p><strong>2. 文件不存在时的自动创建</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    FILE* file = fopen(<span class="string">&quot;file.txt&quot;</span>, <span class="string">&quot;a&quot;</span>);    <span class="comment">// 文件不存在时自动创建</span></span><br><span class="line">    <span class="keyword">if</span> (file == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;写入文件失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(file, <span class="string">&quot;已创建并追加的文件。\n&quot;</span>);</span><br><span class="line">    fclose(file);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="特性说明-1"><a href="#特性说明-1" class="headerlink" title="特性说明"></a>特性说明</h4><ul><li><strong>权限问题</strong>：若当前目录无写权限，<code>a</code> 模式会失败（需处理 <code>fopen</code> 返回的 <code>NULL</code>）。</li></ul><p><strong>3. 未关闭文件导致的数据丢失</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    FILE* file = fopen(<span class="string">&quot;data.txt&quot;</span>, <span class="string">&quot;a&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (file == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;Error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(file, <span class="string">&quot;重要数据！&quot;</span>);  <span class="comment">// 写入后未关闭文件</span></span><br><span class="line">    <span class="comment">// 错误：未调用 fclose(file)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="坑点说明"><a href="#坑点说明" class="headerlink" title="坑点说明"></a>坑点说明</h4><ul><li><strong>未关闭文件</strong>：若程序异常终止或忘记调用 <code>fclose</code>，缓冲区中的数据可能未写入磁盘。</li><li><strong>解决方案</strong>：始终确保写入后调用 <code>fclose</code>，或显式调用 <code>fflush(file)</code> 强制刷新缓冲区。</li></ul><p><strong>4. 并发写入的潜在问题</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    FILE* file1 = fopen(<span class="string">&quot;shared.txt&quot;</span>, <span class="string">&quot;a&quot;</span>);</span><br><span class="line">    FILE* file2 = fopen(<span class="string">&quot;shared.txt&quot;</span>, <span class="string">&quot;a&quot;</span>);  <span class="comment">// 同一文件被多次打开</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(file1, <span class="string">&quot;来自 file1 的消息\n&quot;</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(file2, <span class="string">&quot;来自 file2 的消息\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    fclose(file1);</span><br><span class="line">    fclose(file2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="坑点说明-1"><a href="#坑点说明-1" class="headerlink" title="坑点说明"></a>坑点说明</h4><ul><li><strong>并发写入</strong>：若多个进程&#x2F;线程同时追加文件，内容可能交错（如 <code>&quot;来自 file2 的消息\n&quot;</code>）。</li><li><strong>解决方案</strong>：在多线程&#x2F;多进程场景中，需通过锁机制或原子操作保证顺序。</li></ul><hr><h3 id="5-open-函数"><a href="#5-open-函数" class="headerlink" title="5. open() 函数"></a>5. <code>open()</code> 函数</h3><p>题外话：<strong>比特位方式的标志位传递</strong>。其核心原理是通过 <strong>二进制位的每一位</strong> 来表示不同的标志状态，利用位运算符（如 <code>|</code> 和 <code>&amp;</code>）高效地组合和检测多个标志（了解，以后详解）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ONE (1<span class="string">&lt;&lt;0)                                          // 0001 -&gt;</span> 十进制 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TWO (1<span class="string">&lt;&lt;1)                                          // 0010 -&gt;</span> 十进制 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> THREE (1<span class="string">&lt;&lt;2)                                        // 0100 -&gt;</span> 十进制 4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FOUR (1<span class="string">&lt;&lt;3)                                         // 1000 -&gt;</span> 十进制 8</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">show</span><span class="params">(<span class="type">int</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">if</span>(flags&amp;ONE) <span class="built_in">printf</span>(<span class="string">&quot;hello function1\n&quot;</span>);              <span class="comment">// 如果第 0 位是 1</span></span><br><span class="line">   <span class="keyword">if</span>(flags&amp;TWO) <span class="built_in">printf</span>(<span class="string">&quot;hello function2\n&quot;</span>);              <span class="comment">// 如果第 1 位是 1</span></span><br><span class="line">   <span class="keyword">if</span>(flags&amp;THREE) <span class="built_in">printf</span>(<span class="string">&quot;hello function3\n&quot;</span>);            <span class="comment">// 如果第 2 位是 1</span></span><br><span class="line">   <span class="keyword">if</span>(flags&amp;FOUR) <span class="built_in">printf</span>(<span class="string">&quot;hello function4\n&quot;</span>);             <span class="comment">// 如果第 3 位是 1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;-----------------------------\n&quot;</span>);</span><br><span class="line">   show(ONE);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;-----------------------------\n&quot;</span>);</span><br><span class="line">   show(TWO);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;-----------------------------\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">   show(ONE|TWO);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;-----------------------------\n&quot;</span>);</span><br><span class="line">   show(ONE|TWO|THREE);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;-----------------------------\n&quot;</span>);</span><br><span class="line">   show(ONE|THREE);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;-----------------------------\n&quot;</span>);</span><br><span class="line">   show(THREE|FOUR);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;-----------------------------\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><code>open()</code> 是 Linux 系统调用中最核心、最常用的函数之一，是一切文件&#x2F;设备操作的起点。</p><p><strong>1. 头文件</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span>      <span class="comment">// 提供 open 函数、O_RDONLY 等常量</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br></pre></td></tr></table></figure><p><strong>2. 函数原型 &amp; 参数解释</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags, <span class="type">mode_t</span> mode)</span>;  <span class="comment">// 创建文件时用到</span></span><br></pre></td></tr></table></figure><p><strong>3. 参数说明</strong></p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>pathname</code></td><td>文件路径（绝对或相对路径）</td></tr><tr><td><code>flags</code></td><td>文件打开方式和行为控制（重点！）</td></tr><tr><td><code>mode</code></td><td>权限位（<strong>只有当创建新文件时才用！</strong>）</td></tr></tbody></table><p><strong>4. 返回值</strong></p><table><thead><tr><th>返回值</th><th>含义</th></tr></thead><tbody><tr><td><code>&gt;= 0</code></td><td>打开成功，返回的是 <strong>文件描述符</strong>（整数）</td></tr><tr><td><code>&lt; 0</code></td><td>打开失败，返回 <code>-1</code>，<strong>具体错误原因通过 <code>errno</code> 查看</strong></td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    perror(<span class="string">&quot;open failed&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="1-flags-参数详解（支持“位或-”组合使用）"><a href="#1-flags-参数详解（支持“位或-”组合使用）" class="headerlink" title="1. flags 参数详解（支持“位或 |”组合使用）"></a>1. <code>flags</code> 参数详解（支持“位或 |”组合使用）</h4><p><strong>1. 访问方式（必须选一个）</strong></p><table><thead><tr><th>常量</th><th>说明</th></tr></thead><tbody><tr><td><code>O_RDONLY</code></td><td>只读打开（Read Only）</td></tr><tr><td><code>O_WRONLY</code></td><td>只写打开（Write Only）</td></tr><tr><td><code>O_RDWR</code></td><td>读写都打开（Read + Write）</td></tr></tbody></table><p><strong>2. 控制行为（可选，多个之间用 <code>|</code> 连接）</strong></p><table><thead><tr><th>常量</th><th>含义</th></tr></thead><tbody><tr><td><code>O_CREAT</code></td><td>文件不存在就创建（需要配合 mode 参数）</td></tr><tr><td><code>O_EXCL</code></td><td>和 <code>O_CREAT</code> 同用，文件存在则失败（避免重复创建）</td></tr><tr><td><code>O_TRUNC</code></td><td>打开文件时清空原内容（通常配合写）</td></tr><tr><td><code>O_APPEND</code></td><td>写入内容追加到文件末尾</td></tr><tr><td><code>O_NONBLOCK</code></td><td>非阻塞模式打开文件（常用于设备&#x2F;管道）</td></tr><tr><td><code>O_CLOEXEC</code></td><td>在 exec 调用时关闭该文件描述符</td></tr><tr><td><code>O_SYNC</code></td><td>写入时直接同步到硬盘（安全但慢）</td></tr></tbody></table><h4 id="2-mode-参数（仅在-O-CREAT-创建新文件时才用）"><a href="#2-mode-参数（仅在-O-CREAT-创建新文件时才用）" class="headerlink" title="2. mode 参数（仅在 O_CREAT 创建新文件时才用）"></a>2. <code>mode</code> 参数（仅在 <code>O_CREAT</code> 创建新文件时才用）</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open(<span class="string">&quot;file.txt&quot;</span>, O_WRONLY | O_CREAT, <span class="number">0664</span>);</span><br></pre></td></tr></table></figure><ul><li><code>mode_t</code> 用来设置 <strong>新文件的权限</strong>，与 <code>chmod</code> 类似</li><li>常用组合：</li></ul><table><thead><tr><th>权限数字</th><th>含义说明</th></tr></thead><tbody><tr><td><code>0664</code></td><td>用户读写，组读写，其他只读</td></tr><tr><td><code>0644</code></td><td>用户读写，其他只读</td></tr></tbody></table><p><strong>代码示例解读：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码 1：</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">open</span>(<span class="string">&quot;temp.txt&quot;</span>, O_WRONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;open file error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 代码 2：</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">open</span>(<span class="string">&quot;temp.txt&quot;</span>, O_WRONLY | O_CREAT);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;open file error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 代码 3：头文件一样，后面不再重复</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">open</span>(<span class="string">&quot;temp.txt&quot;</span>, O_WRONLY | O_CREAT, <span class="number">0666</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;open file error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 代码 4：</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">umask</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">open</span>(<span class="string">&quot;temp.txt&quot;</span>, O_WRONLY | O_CREAT, <span class="number">0666</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;open file error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>代码编号</th><th>是否自动创建文件</th><th>权限设定</th><th>是否受 umask 影响</th><th>常见用途</th></tr></thead><tbody><tr><td>1️⃣</td><td>❌ 否</td><td>无</td><td>-</td><td>仅打开已存在文件</td></tr><tr><td>2️⃣</td><td>⚠️ 可能报错</td><td>❌ 缺少权限参数（可能是乱码）</td><td>-</td><td>不推荐用法</td></tr><tr><td>3️⃣</td><td>✅ 创建</td><td>0666 - umask（与 0666 不符，原因 <code>umask</code>）</td><td>✅ 是</td><td>正常用法</td></tr><tr><td>4️⃣</td><td>✅ 创建</td><td>0666</td><td>❌ 不受影响</td><td>特殊场合</td></tr></tbody></table><hr><h4 id="3-战代码示例：打开-写入-关闭"><a href="#3-战代码示例：打开-写入-关闭" class="headerlink" title="3. 战代码示例：打开 + 写入 + 关闭"></a>3. 战代码示例：打开 + 写入 + 关闭</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span>                      <span class="comment">// 包含文件控制相关的定义和函数声明</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>                     <span class="comment">// 包含 POSIX 操作函数的声明，如 open、close、write 等</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>                      <span class="comment">// 包含标准输入输出函数的声明，如 perror 等</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 打开或创建文件，并设置为只写模式、创建文件、截断文件</span></span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">open</span>(<span class="string">&quot;demo.txt&quot;</span>, O_WRONLY | O_CREAT | O_TRUNC, <span class="number">0644</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;open failed&quot;</span>);          <span class="comment">// 打印错误信息，open failed 为自定义的错误前缀</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;                       <span class="comment">// 打开文件失败，返回非零值表示程序异常退出</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* msg = <span class="string">&quot;实习 / 工作要掌握 open 的实战用法！\n&quot;</span>;       <span class="comment">// 定义要写入文件的字符串，将字符串写入文件</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">write</span>(fd, msg, <span class="built_in">strlen</span>(msg));        <span class="comment">// 第一个参数是文件描述符，第二个是数据的指针，第三个是数据的长度</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">close</span>(fd);                          <span class="comment">// 关闭文件，释放资源</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;                           <span class="comment">// 程序正常退出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-文件描述符"><a href="#6-文件描述符" class="headerlink" title="6. 文件描述符"></a>6. 文件描述符</h3><p><strong>先出结论：<code>open()</code> 的返回值 就是文件描述符（fd），它是一个 数组下标，指向当前进程的 打开文件表（fd table） 中的一个 <code>struct file *</code> 指针。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> fd = <span class="built_in">open</span>(<span class="string">&quot;a.txt&quot;</span>, O_WRONLY);  <span class="comment">// 返回 3</span></span><br><span class="line"><span class="built_in">write</span>(fd, <span class="string">&quot;Hello&quot;</span>, <span class="number">5</span>);             <span class="comment">// 实际就是 write(fd_table [3], ...)</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250424150534053.png" alt="image-20250424150533845"></p><p>我们通过一段完整的 <strong>C 代码</strong> 演示：“访问文件的本质，其实是 <strong>数组下标访问</strong>”。接着再来讲解内核中是如何通过 <code>struct file</code>、<code>struct files_struct</code> 等结构体来描述和管理已打开的文件。</p><h4 id="1-C-代码示例：文件描述符本质是数组下标"><a href="#1-C-代码示例：文件描述符本质是数组下标" class="headerlink" title="1. C 代码示例：文件描述符本质是数组下标"></a>1. C 代码示例：文件描述符本质是数组下标</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 打开三个不同的文件</span></span><br><span class="line">    <span class="type">int</span> fd1 = open(<span class="string">&quot;file1.txt&quot;</span>, O_CREAT | O_WRONLY, <span class="number">0666</span>);</span><br><span class="line">    <span class="type">int</span> fd2 = open(<span class="string">&quot;file2.txt&quot;</span>, O_CREAT | O_WRONLY, <span class="number">0666</span>);</span><br><span class="line">    <span class="type">int</span> fd3 = open(<span class="string">&quot;file3.txt&quot;</span>, O_CREAT | O_WRONLY, <span class="number">0666</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fd1 &lt; <span class="number">0</span> || fd2 &lt; <span class="number">0</span> || fd3 &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fd1: %d\n&quot;</span>, fd1);  <span class="comment">// 通常是 3</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fd2: %d\n&quot;</span>, fd2);  <span class="comment">// 通常是 4</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fd3: %d\n&quot;</span>, fd3);  <span class="comment">// 通常是 5</span></span><br><span class="line"></span><br><span class="line">    write(fd2, <span class="string">&quot;Hello file2\n&quot;</span>, <span class="number">12</span>);  <span class="comment">// 通过 fd2 向 file2.txt 写入内容</span></span><br><span class="line"></span><br><span class="line">    close(fd1);</span><br><span class="line">    close(fd2);</span><br><span class="line">    close(fd3);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出示例（实际运行）：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fd1: 3</span><br><span class="line">fd2: 4</span><br><span class="line">fd3: 5</span><br></pre></td></tr></table></figure><h4 id="解释说明："><a href="#解释说明：" class="headerlink" title="解释说明："></a>解释说明：</h4><p><strong>为什么编号是从 <code>3</code> 开始的？<code>0</code>，<code>1</code>，<code>2</code> 去哪了？</strong></p><p>答案：<code>Linux</code> 进程默认情况下会有 <code>3</code> 个缺省打开的文件描述符，分别是标准输入 <code>0</code>，标准输出 <code>1</code>，标准错误 <code>2</code>。0，1，2 对应的物理设备一般是：键盘，显示器，显示器。</p><ul><li><strong>标准输入（stdin）：文件描述符是 0</strong></li><li><strong>标准输出（stdout）：是 1</strong></li><li><strong>标准错误（stderr）：是 2</strong></li></ul><p>后续打开的文件就是从 <strong>下标 3</strong> 开始往上分配。所以：<code>fd</code> 本质上是一个 <strong>打开文件表的下标</strong>（int 类型的索引）</p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250424151024820.png" alt="image-20250424151024593"></p><hr><h4 id="2-内核层的结构体解析（推荐-linux-2-6-11-1-tar-gz-——-09-Mar-2005-00-59-44M-这个版本查看源码）"><a href="#2-内核层的结构体解析（推荐-linux-2-6-11-1-tar-gz-——-09-Mar-2005-00-59-44M-这个版本查看源码）" class="headerlink" title="2. 内核层的结构体解析（推荐 linux-2.6.11.1.tar.gz —— 09-Mar-2005 00:59     44M 这个版本查看源码）"></a>2. 内核层的结构体解析（<a href="https://www.kernel.org/pub/linux/kernel/v2.6/">推荐 linux-2.6.11.1.tar.gz —— 09-Mar-2005 00:59     44M 这个版本查看源码</a>）</h4><p><strong>用户层调用 <code>open()</code> 后，内核做了什么？</strong></p><p>Linux 内核有三层数据结构来描述一个打开的文件：</p><h5 id="1-files-struct（表示进程级的打开文件表）"><a href="#1-files-struct（表示进程级的打开文件表）" class="headerlink" title="1. files_struct（表示进程级的打开文件表）"></a>1. <code>files_struct</code>（表示进程级的打开文件表）</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">fd_array</span>[<span class="title">NR_OPEN</span>];</span>  <span class="comment">// 进程文件描述符数组（最多可打开的文件数）</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>每个进程都有一个 <code>files_struct</code> 实例。</li><li><code>fd_array[i]</code> 中存的是指向 <code>struct file</code> 的指针。</li><li><strong>这个数组的下标就是我们用户层看到的 <code>fd</code>！</strong></li></ul><h5 id="2-struct-file（表示一个已打开的文件实例）"><a href="#2-struct-file（表示一个已打开的文件实例）" class="headerlink" title="2. struct file（表示一个已打开的文件实例）"></a>2. <code>struct file</code>（表示一个已打开的文件实例）</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">f_inode</span>;</span>          <span class="comment">// 指向文件的 inode 结构</span></span><br><span class="line">    <span class="type">loff_t</span>        f_pos;            <span class="comment">// 当前读写位置（文件偏移量）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">f_op</span>;</span>   <span class="comment">// 操作函数表</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>表示一次文件打开操作。</li><li>不同进程打开同一个文件，会有 <strong>不同的 <code>struct file</code></strong>。</li><li><code>struct file</code> 直接或间接包含的属性：在磁盘的什么位置、基本属性（权限、大小、读写位置、谁打开的……）、文件的内核缓冲区信息、<code>struct file *next</code> 指针、引用计数 <code>count</code> 等。</li><li>类似于“文件打开上下文”，记录偏移、标志等状态。</li></ul><h5 id="3-inode（文件元数据结构）"><a href="#3-inode（文件元数据结构）" class="headerlink" title="3. inode（文件元数据结构）"></a>3. <code>inode</code>（文件元数据结构）</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// 文件类型、权限、拥有者、指向数据块的指针等等</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>一个 <code>inode</code> 代表文件系统中一个“实际的文件”。</li><li>所有打开该文件的 <code>file</code> 都指向同一个 <code>inode</code>。</li></ul><h4 id="3-三者之间的联系总结"><a href="#3-三者之间的联系总结" class="headerlink" title="3. 三者之间的联系总结"></a>3. 三者之间的联系总结</h4><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250424150002169.png" alt="image-20250424150001978"></p><p><strong>小结：用户空间的文件描述符（fd）就是内核中的 <code>struct file *</code> 数组的下标！通过这个下标，进程就能访问并操作该文件在内核中对应的资源。</strong></p><h4 id="4-文件描述符的分配规则"><a href="#4-文件描述符的分配规则" class="headerlink" title="4. 文件描述符的分配规则"></a>4. 文件描述符的分配规则</h4><p><strong>先出结论：Linux 内核始终分配当前未被使用的最小下标，作为新的文件描述符。当你调用 <code>open()</code> 或 <code>dup()</code> 等函数时，内核会在 <code>fd_array[]</code> 中从头开始查找：寻找当前未被使用的最小下标，作为新的文件描述符（fd）。</strong></p><p><strong>关闭 fd 后：</strong> 它会被回收，下一次打开文件就可能重复使用这个编号。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">close</span>(<span class="number">0</span>);                           <span class="comment">// 关闭标准输入（fd = 0）</span></span><br><span class="line">    <span class="type">int</span> fd1 = <span class="built_in">open</span>(<span class="string">&quot;test1.txt&quot;</span>, O_CREAT | O_RDWR, <span class="number">0666</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fd1=%d\n&quot;</span>, fd1);            <span class="comment">// 输出 fd1 = 0</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(<span class="number">1</span>);                           <span class="comment">// 关闭标准输出（fd = 1）</span></span><br><span class="line">    <span class="type">int</span> fd2 = <span class="built_in">open</span>(<span class="string">&quot;test2.txt&quot;</span>, O_CREAT | O_RDWR, <span class="number">0666</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fd2=%d\n&quot;</span>, fd2);            <span class="comment">// 无法输出到终端（因为 stdout 已关闭），重定向到文件观察</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(<span class="number">2</span>);                           <span class="comment">// 关闭标准错误（fd = 2）</span></span><br><span class="line">    <span class="type">int</span> fd3 = <span class="built_in">open</span>(<span class="string">&quot;test3.txt&quot;</span>, O_CREAT | O_RDWR, <span class="number">0666</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fd3=%d\n&quot;</span>, fd3);            <span class="comment">// 同样无法输出到终端</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行与验证:</strong></p><ol><li><p>编译并运行程序，将输出重定向到文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc test.c -o <span class="built_in">test</span> &amp;&amp; ./test &gt; output.txt 2&gt;&amp;1</span><br></pre></td></tr></table></figure></li><li><p>查看 <code>output.txt</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fd1=0</span><br><span class="line">fd2=1</span><br><span class="line">fd3=2</span><br></pre></td></tr></table></figure></li></ol><p><strong>说明</strong>：关闭 <code>0/1/2</code> 后，新打开的文件的描述符依次复用这些最小下标。</p><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="comment">// dprintf(fd, ...) 就是“向 fd 指定的地方 像用 printf 一样 输出内容”，非常适合标准输出关闭或重定向时使用。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;原始状态：stdin=0, stdout=1, stderr=2\n&quot;</span>);       <span class="comment">// 先确认 fd = 0,1,2 都是开启状态</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(<span class="number">1</span>);                                               <span class="comment">// 关闭标准输出（fd = 1），但保留 stdin(0) 和 stderr(2)</span></span><br><span class="line">    <span class="type">int</span> fd1 = <span class="built_in">open</span>(<span class="string">&quot;test1.txt&quot;</span>, O_CREAT | O_RDWR, <span class="number">0666</span>);    <span class="comment">// 打开文件 1</span></span><br><span class="line">    <span class="built_in">dprintf</span>(<span class="number">2</span>, <span class="string">&quot;fd1 = %d\n&quot;</span>, fd1);                          <span class="comment">// 输出到 stderr（fd = 2），应为 1</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(<span class="number">0</span>);                                               <span class="comment">// 关闭标准输入（fd = 0）</span></span><br><span class="line">    <span class="type">int</span> fd2 = <span class="built_in">open</span>(<span class="string">&quot;test2.txt&quot;</span>, O_CREAT | O_RDWR, <span class="number">0666</span>);    <span class="comment">// 打开文件 2</span></span><br><span class="line">    <span class="built_in">dprintf</span>(<span class="number">2</span>, <span class="string">&quot;fd2 = %d\n&quot;</span>, fd2);                          <span class="comment">// 应为 0</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd3 = <span class="built_in">open</span>(<span class="string">&quot;test3.txt&quot;</span>, O_CREAT | O_RDWR, <span class="number">0666</span>);    <span class="comment">// 打开文件 3（fd = 2 还在用）</span></span><br><span class="line">    <span class="built_in">dprintf</span>(<span class="number">2</span>, <span class="string">&quot;fd3 = %d\n&quot;</span>, fd3);                          <span class="comment">// 应为 3，因为 0 和 1 被占用，新开只能用 3</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出内容会写入 <code>stderr</code>（fd &#x3D; 2），因为 <code>stdout</code> 被关闭。示例输出：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fd1 = <span class="number">1</span>  ← 因为 fd=<span class="number">1</span> 被关闭，最小空位就是 <span class="number">1</span></span><br><span class="line">fd2 = <span class="number">0</span>  ← fd=<span class="number">0</span> 被关闭，最小空位变为 <span class="number">0</span></span><br><span class="line">fd3 = <span class="number">3</span>  ← 此时 <span class="number">0</span> 和 <span class="number">1</span> 被占用，<span class="number">2</span> 还在用，所以下一空位是 <span class="number">3</span></span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 当你只关闭了 <code>fd=1</code>，而 <code>0</code> 和 <code>2</code> 保持开启，<strong>新文件会被分配到 1</strong>。<strong>不会跳到 2</strong>，因为 2 是正在使用中的文件描述符（stderr）。所以：</p><ul><li>内核分配新 fd 的顺序是：<strong>从低到高，找第一个没用的</strong>。</li><li>如果你关闭了某个 fd，那么它会被下一次 <code>open()</code> 回收复用。</li><li>只有当 <strong>0、1、2</strong> 都被关闭，才会让新文件从 0 开始重新分配。</li></ul><hr><h3 id="7-文件描述符-VS-FILE"><a href="#7-文件描述符-VS-FILE" class="headerlink" title="7. 文件描述符 VS FILE *"></a>7. 文件描述符 VS <code>FILE *</code></h3><p><strong>一句话总结：<code>文件描述符（fd）</code> 是 Linux 系统内核的低层 I&#x2F;O 机制，而 <code>FILE \*</code> 是 C 标准库（stdio.h）封装的高级 I&#x2F;O 结构，它内部依赖文件描述符实现功能。</strong></p><h4 id="1-文件描述符（int-fd）"><a href="#1-文件描述符（int-fd）" class="headerlink" title="1. 文件描述符（int fd）"></a>1. 文件描述符（<code>int fd</code>）</h4><ul><li>是 Linux 内核分配的一个 <strong>整数索引</strong></li><li>用于标识当前进程打开的某个文件（实际上是指向内核 <code>struct file</code> 的下标）</li><li>使用 <code>open()</code>, <code>read()</code>, <code>write()</code>, <code>close()</code> 等系统调用操作</li><li>属于 <strong>低级 I&#x2F;O</strong></li></ul><p><strong>示例：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> fd = open(<span class="string">&quot;a.txt&quot;</span>, O_RDWR);<span class="comment">// 打开文件 &quot;a.txt&quot;，以读写模式（O_RDWR）打开，返回文件描述符 fd</span></span><br><span class="line">write(fd, <span class="string">&quot;hello&quot;</span>, <span class="number">5</span>);<span class="comment">// 向文件描述符 fd 指向的文件中写入字符串 &quot;hello&quot;，写入长度为 5 字节</span></span><br><span class="line">close(fd);<span class="comment">// 关闭文件描述符 fd，释放相关资源</span></span><br></pre></td></tr></table></figure><h4 id="2-FILE-指针"><a href="#2-FILE-指针" class="headerlink" title="2. FILE * 指针"></a>2. <code>FILE *</code> 指针</h4><ul><li>是 <code>stdio.h</code> 定义的 <strong>高级抽象结构体</strong></li><li>内部其实就是封装了一个 <code>int fd</code> + 缓冲区 + 文件状态等信息</li><li>使用 <code>fopen()</code>, <code>fread()</code>, <code>fwrite()</code>, <code>fprintf()</code>, <code>fclose()</code> 等函数操作</li><li>属于 <strong>高级 I&#x2F;O</strong></li></ul><p><strong>示例：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FILE* fp = fopen(<span class="string">&quot;a.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);<span class="comment">// 以写模式（&quot;w&quot;）打开文件 &quot;a.txt&quot;，返回文件指针 fp，注意：以 &quot;w&quot; 模式打开会清空文件原有内容</span></span><br><span class="line"><span class="built_in">fprintf</span>(fp, <span class="string">&quot;hello\n&quot;</span>);<span class="comment">// 使用 fprintf 向文件指针 fp 指向的文件中写入字符串 &quot;hello\n&quot;</span></span><br><span class="line">fclose(fp);<span class="comment">// 关闭文件指针 fp，确保数据被正确写入并释放相关资源</span></span><br></pre></td></tr></table></figure><h4 id="3-二者之间的关系图"><a href="#3-二者之间的关系图" class="headerlink" title="3. 二者之间的关系图"></a>3. 二者之间的关系图</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FILE *fp ───► struct __FILE (库层) ───► int fd ───► 内核打开文件表（files_struct）</span><br></pre></td></tr></table></figure><h4 id="4-相互转换方法"><a href="#4-相互转换方法" class="headerlink" title="4. 相互转换方法"></a>4. 相互转换方法</h4><p><strong>从 <code>FILE *</code> 获取 <code>fd</code>：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> fd = fileno(fp);</span><br></pre></td></tr></table></figure><p><strong>从 <code>fd</code> 获取 <code>FILE *</code>：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FILE *fp = fdopen(fd, <span class="string">&quot;w&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="5-区别对比总结"><a href="#5-区别对比总结" class="headerlink" title="5. 区别对比总结"></a>5. 区别对比总结</h4><table><thead><tr><th>特性</th><th>文件描述符（int fd）</th><th>FILE * 指针</th></tr></thead><tbody><tr><td>所属层次</td><td>内核层（系统调用）</td><td>C 标准库（用户空间）</td></tr><tr><td>使用头文件</td><td><code>&lt;fcntl.h&gt;</code>, <code>&lt;unistd.h&gt;</code></td><td><code>&lt;stdio.h&gt;</code></td></tr><tr><td>是否有缓冲机制</td><td>❌ 无缓冲</td><td>✅ 有缓冲</td></tr><tr><td>速度</td><td>快（系统级）</td><td>慢（用户态带缓冲）</td></tr><tr><td>函数接口</td><td>open&#x2F;read&#x2F;write</td><td>fopen&#x2F;fread&#x2F;fwrite</td></tr><tr><td>可否转换</td><td>✅ 可以互相转换</td><td>✅ 可以互相转换</td></tr><tr><td>控制精细程度</td><td>更细粒度（如非阻塞、异步）</td><td>比较抽象、功能丰富</td></tr></tbody></table><p>实战建议：</p><table><thead><tr><th>场景</th><th>建议使用</th></tr></thead><tbody><tr><td>写系统调用、驱动、IO 重定向等底层功能</td><td><code>fd</code>（文件描述符）</td></tr><tr><td>做格式化文本输出、文件读写、缓存优化等</td><td><code>FILE *</code>（标准库）</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> IO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>021 多语言协同执行（了解）</title>
      <link href="/posts/47579.html"/>
      <url>/posts/47579.html</url>
      
        <content type="html"><![CDATA[<h2 id="fork-exec-系列函数创建子进程并执行其他程序（跨语言衔接示例）"><a href="#fork-exec-系列函数创建子进程并执行其他程序（跨语言衔接示例）" class="headerlink" title="fork + exec 系列函数创建子进程并执行其他程序（跨语言衔接示例）"></a><code>fork</code> + <code>exec</code> 系列函数创建子进程并执行其他程序（跨语言衔接示例）</h2><blockquote><p><a href="https://blog.csdn.net/chenlong_cxy/article/details/120579992">CSDN 相关文章</a><a href="https://man7.org/linux/man-pages/man2/fork.2.html?spm=5176.28103460.0.0.2f2e1db8S7unlT">fork（2） - Linux 手册页</a><a href="https://man7.org/linux/man-pages/man3/execvp.3.html?spm=5176.28103460.0.0.2f2e1db8S7unlT">exec（3） - Linux 手册页</a></p></blockquote><p>在 Linux 系统编程中，<code>fork()</code> 和 <code>exec()</code> 是进程控制的两大核心。本文将演示如何使用 <code>fork</code> 创建子进程，再使用 <code>exec</code> 执行外部程序，展示多语言之间的 <strong>协同执行</strong> 过程。</p><hr><h3 id="1-fork-exec-基础原理"><a href="#1-fork-exec-基础原理" class="headerlink" title="1. fork + exec 基础原理"></a>1. fork + exec 基础原理</h3><ul><li><code>fork()</code>：复制当前进程，返回两次（一次给父进程，一次给子进程）</li><li><code>exec*()</code>：用新程序 <strong>替换当前进程映像</strong>（进程 ID 不变）</li></ul><p>通常模式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pid_t</span> pid = fork();</span><br><span class="line"><span class="keyword">if</span> (pid == <span class="number">0</span>)                               <span class="comment">// 子进程执行新程序</span></span><br><span class="line">&#123;</span><br><span class="line">    execl(<span class="string">&quot;/bin/ls&quot;</span>, <span class="string">&quot;ls&quot;</span>, <span class="string">&quot;-l&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">    perror(<span class="string">&quot;execl&quot;</span>);                        <span class="comment">// 出错处理</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>                                        <span class="comment">// 父进程继续执行</span></span><br><span class="line">&#123;</span><br><span class="line">    wait(<span class="literal">NULL</span>);                             <span class="comment">// 等待子进程退出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="2-执行-Python-脚本的示例"><a href="#2-执行-Python-脚本的示例" class="headerlink" title="2. 执行 Python 脚本的示例"></a>2. 执行 Python 脚本的示例</h3><h4 id="1-Python-文件：script-py"><a href="#1-Python-文件：script-py" class="headerlink" title="1. Python 文件：script.py"></a>1. Python 文件：<code>script.py</code></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># script.py</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello from Python script!&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="2-C-程序执行-Python-脚本："><a href="#2-C-程序执行-Python-脚本：" class="headerlink" title="2. C 程序执行 Python 脚本："></a>2. C 程序执行 Python 脚本：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>)                       <span class="comment">// 子进程执行 python 脚本</span></span><br><span class="line">    &#123;</span><br><span class="line">        execl(<span class="string">&quot;/usr/bin/python3&quot;</span>, <span class="string">&quot;python3&quot;</span>, <span class="string">&quot;script.py&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">        perror(<span class="string">&quot;exec failed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>                                <span class="comment">// 父进程等待</span></span><br><span class="line">    &#123;</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Python 脚本执行完毕\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译并运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc run_python.c -o run_python</span><br><span class="line">./run_python</span><br></pre></td></tr></table></figure><p>运行结果示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hello from Python script!</span><br><span class="line">Python 脚本执行完毕</span><br></pre></td></tr></table></figure><hr><h3 id="3-执行-C-程序的示例"><a href="#3-执行-C-程序的示例" class="headerlink" title="3. 执行 C++ 程序的示例"></a>3. 执行 C++ 程序的示例</h3><h4 id="1-C-程序：hello-cpp"><a href="#1-C-程序：hello-cpp" class="headerlink" title="1. C++ 程序：hello.cpp"></a>1. C++ 程序：<code>hello.cpp</code></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Hello, world!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ hello.cpp -o hello_cpp</span><br></pre></td></tr></table></figure><h4 id="2-C-程序调用该可执行文件："><a href="#2-C-程序调用该可执行文件：" class="headerlink" title="2. C 程序调用该可执行文件："></a>2. C 程序调用该可执行文件：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        execl(<span class="string">&quot;./hello_cpp&quot;</span>, <span class="string">&quot;hello_cpp&quot;</span>, <span class="literal">NULL</span>); <span class="comment">// 执行 C++ 程序</span></span><br><span class="line">        perror(<span class="string">&quot;exec failed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;C++ 程序执行完毕\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译并运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc run_cpp.c -o run_cpp</span><br><span class="line">./run_cpp</span><br></pre></td></tr></table></figure><p>运行结果示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hello, world!</span><br><span class="line">C++ 程序执行完毕</span><br></pre></td></tr></table></figure><hr><h3 id="4-常见问题"><a href="#4-常见问题" class="headerlink" title="4. 常见问题"></a>4. 常见问题</h3><table><thead><tr><th>问题</th><th>说明</th></tr></thead><tbody><tr><td>exec 不执行？</td><td>路径错误、参数没加 NULL、权限不够</td></tr><tr><td>子进程未退出？</td><td>忘记 <code>wait()</code> 等待</td></tr></tbody></table><hr><h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h3><p><code>fork + exec</code> 提供了 Linux 编程中最灵活的跨语言进程调用方式。你可以：</p><ul><li>用 C 控制调度</li><li>执行 Python、C++、Shell 等不同程序</li><li>实现自定义脚本执行平台、服务型任务处理器等</li></ul><p>此处仅演示最简单的 <strong>多语言协同执行</strong>，带环境变量、传参数等其他形式不涉及。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>020 实现一个简易 Shell</title>
      <link href="/posts/61868.html"/>
      <url>/posts/61868.html</url>
      
        <content type="html"><![CDATA[<h3 id="从零到一实现一个简易-Shell"><a href="#从零到一实现一个简易-Shell" class="headerlink" title="从零到一实现一个简易 Shell"></a>从零到一实现一个简易 <code>Shell</code></h3><p>这应该是个蛮有趣的话题：“什么是 <code>Shell</code>”？相信只要摸过计算机，对于操作系统(不论是 <code>Linux</code>、<code>Unix</code> 或者是 <code>Windows</code>)有点概念的朋友们大多听过这个名词，因为只要有“操作系统“那么就离不开 <code>Shell</code> 这个东西。不过，在讨论 <code>Shell</code> 之前，我们先来了解一下计算机的运行状况吧！举个例子来说：当你要计算机传输出来“音乐”的时候，你的计算机需要什么东西呢？</p><ol><li>硬件：当然就是需要你的硬件有“声卡芯片”这个配备，否则怎么会有声音；</li><li>核心管理：操作系统的核心可以支持这个芯片组，当然还需要提供芯片的驱动程序啰；</li><li>应用程序：需要使用者（就是你）输入发生声音的指令啰！</li></ol><p>这就是基本的一个输出声音所需要的步骤！也就是说，你必须要“输入”一个指令之后，“硬件“才会通过你下达的指令来工作！那么硬件如何知道你下达的指令呢？那就是 <code>kernel</code>（核心）的控制工作了！也就是说，我们必须要通过“<code>Shell</code>”将我们输入的指令与 <code>Kernel</code> 沟通，好让 <code>Kernel</code> 可以控制硬件来正确无误的工作！基本上，我们可以通过下面这张图来说明一下：</p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250422201807649.png" alt="image-20250422201800429"></p><blockquote><p>以上内容摘自《鸟哥的 <code>Linux</code> 私房菜基础学习篇（第四版）》311 页。</p></blockquote><hr><h4 id="1-Shell-的基本功能"><a href="#1-Shell-的基本功能" class="headerlink" title="1. Shell 的基本功能"></a>1. <code>Shell</code> 的基本功能</h4><p>一个基本的 <code>Shell</code> 需要具备以下功能：</p><ul><li><strong>提示符显示</strong>：显示当前用户、主机名和工作目录，例如 <code>[user@host ~]#</code>。</li><li><strong>命令读取</strong>：从标准输入读取用户输入的命令。</li><li><strong>命令解析</strong>：将输入的命令行分割为命令和参数。</li><li><strong>命令执行</strong>：支持内置命令（如 <code>cd</code>、<code>export</code>）和外部命令（如 <code>ls</code>、<code>cat</code>）。</li><li><strong>重定向支持</strong>：支持输入重定向 <code>&lt;</code>、输出重定向 <code>&gt;</code> 和追加输出重定向 <code>&gt;&gt;</code>。</li><li><strong>环境变量管理</strong>：支持查看和设置环境变量。</li><li><strong>退出机制</strong>：支持通过 <code>exit</code> 退出 <code>Shell</code>。</li></ul><p>让我们一步步实现这些功能。</p><h4 id="2-实现-Shell-的提示符"><a href="#2-实现-Shell-的提示符" class="headerlink" title="2. 实现 Shell 的提示符"></a>2. 实现 <code>Shell</code> 的提示符</h4><p><code>Shell</code> 的提示符是用户交互的起点，通常显示为 <code>[用户名@主机名 当前目录]#</code>。我们需要获取用户名、主机名和当前工作目录。</p><h5 id="1-获取用户信息"><a href="#1-获取用户信息" class="headerlink" title="1. 获取用户信息"></a>1. 获取用户信息</h5><ul><li><strong>用户名</strong>：使用 <code>getenv(&quot;USER&quot;)</code> 获取当前用户名。</li><li><strong>主机名</strong>：使用 <code>getenv(&quot;HOSTNAME&quot;)</code> 获取主机名。</li><li><strong>当前目录</strong>：使用 <code>getcwd()</code> 获取当前工作目录。</li></ul><h5 id="2-定义提示符格式"><a href="#2-定义提示符格式" class="headerlink" title="2. 定义提示符格式"></a>2. 定义提示符格式</h5><p>我们通过宏定义设置提示符的格式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LEFT <span class="string">&quot;[&quot;</span>        <span class="comment">// 左括号</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RIGHT <span class="string">&quot;]&quot;</span>       <span class="comment">// 右括号</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LABLE <span class="string">&quot;#&quot;</span>       <span class="comment">// 提示符号</span></span></span><br></pre></td></tr></table></figure><h5 id="3-实现-interact-函数"><a href="#3-实现-interact-函数" class="headerlink" title="3. 实现 interact 函数"></a>3. 实现 <code>interact</code> 函数</h5><p><code>interact</code> 函数负责显示提示符并读取用户输入：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">interact</span><span class="params">(<span class="type">char</span>* cline, <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    getpwd();  <span class="comment">// 获取当前工作目录</span></span><br><span class="line">    <span class="built_in">printf</span>(LEFT<span class="string">&quot;%s@%s %s&quot;</span>RIGHT<span class="string">&quot;&quot;</span>LABLE<span class="string">&quot; &quot;</span>, getusername(), gethostname1(), pwd);</span><br><span class="line">    <span class="type">char</span>* s = fgets(cline, size, <span class="built_in">stdin</span>);  <span class="comment">// 读取用户输入</span></span><br><span class="line">    assert(s);                            <span class="comment">// 确保读取成功</span></span><br><span class="line">    (<span class="type">void</span>)s;    <span class="comment">// 显式标记该变量已被“使用”，从而抑制编译器警告（这是一种代码规范技巧，表明有意忽略此变量）</span></span><br><span class="line">    cline[<span class="built_in">strlen</span>(cline) - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;      <span class="comment">// 去除末尾换行符</span></span><br><span class="line">    check_redir(cline);                   <span class="comment">// 检查重定向符号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>getpwd()</code> 调用 <code>getcwd(pwd, sizeof(pwd))</code> 更新全局变量 <code>pwd</code>。</p></li><li><p><code>printf</code> 格式化输出提示符，例如 <code>[user@host /home]#</code>。</p></li><li><p><code>fgets</code> 从标准输入读取命令行。</p></li><li><p><code>check_redir</code> 检查是否有重定向符号（稍后实现）。</p></li><li><p>命令行解析：用户输入的命令行需要被分割成命令和参数。例如，输入 <code>ls -l /home</code> 应分割为 <code>[&quot;ls&quot;, &quot;-l&quot;, &quot;/home&quot;]</code>。</p></li></ul><h5 id="3-使用-strtok-分割字符串"><a href="#3-使用-strtok-分割字符串" class="headerlink" title="3. 使用 strtok 分割字符串"></a>3. 使用 <code>strtok</code> 分割字符串</h5><p>我们使用 <code>strtok</code> 函数按空格或制表符分割命令行：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DELIM <span class="string">&quot; \t&quot;</span>  <span class="comment">// 分隔符：空格和制表符</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">splitstring</span><span class="params">(<span class="type">char</span> cline[], <span class="type">char</span>* _argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    argv[i++] = strtok(cline, DELIM);       <span class="comment">// 分割第一个 token</span></span><br><span class="line">    <span class="keyword">while</span> (_argv[i++] = strtok(<span class="literal">NULL</span>, DELIM));  <span class="comment">// 继续分割后续 token</span></span><br><span class="line">    <span class="keyword">return</span> i - <span class="number">1</span>;                           <span class="comment">// 返回参数个数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>strtok(cline, DELIM)</code> 分割第一个 <code>token</code>（命令）。</li><li>循环调用 <code>strtok(NULL, DELIM)</code> 获取后续参数。</li><li>返回值是参数个数 <code>argc</code>，存储在全局数组 <code>argv</code> 中。</li></ul><p>全局变量定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LINE_SIZE 1024</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ARGC_SIZE 32</span></span><br><span class="line"><span class="type">char</span> commandline[LINE_SIZE];  <span class="comment">// 存储用户输入</span></span><br><span class="line"><span class="type">char</span>* argv[ARGC_SIZE];        <span class="comment">// 存储分割后的参数</span></span><br></pre></td></tr></table></figure><h5 id="4-命令执行"><a href="#4-命令执行" class="headerlink" title="4. 命令执行"></a>4. 命令执行</h5><p><code>Shell</code> 需要区分两种命令：</p><ul><li><strong>内置命令</strong>：由 <code>Shell</code> 直接处理，如 <code>cd</code>、<code>export</code>、<code>echo</code>。</li><li><strong>外部命令</strong>：通过 <code>fork</code> 和 <code>exec</code> 执行系统中的可执行文件。</li></ul><h5 id="5-内置命令实现"><a href="#5-内置命令实现" class="headerlink" title="5. 内置命令实现"></a>5. 内置命令实现</h5><p>内置命令在 <code>Shell</code> 进程中直接执行，无需创建子进程。我们在 <code>buildCommand</code> 函数中实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">buildCommand</span><span class="params">(<span class="type">char</span>* _argv[], <span class="type">int</span> _argc)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// cd 命令：切换目录</span></span><br><span class="line">    <span class="keyword">if</span> (_argc == <span class="number">2</span> &amp;&amp; <span class="built_in">strcmp</span>(_argv[<span class="number">0</span>], <span class="string">&quot;cd&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        chdir(argv[<span class="number">1</span>]);              <span class="comment">// 切换工作目录</span></span><br><span class="line">        getpwd();</span><br><span class="line">        <span class="built_in">sprintf</span>(getenv(<span class="string">&quot;PWD&quot;</span>), <span class="string">&quot;%s&quot;</span>, pwd);  <span class="comment">// 更新 PWD 环境变量</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;                    <span class="comment">// 表示已处理</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// export 命令：设置环境变量</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (_argc == <span class="number">2</span> &amp;&amp; <span class="built_in">strcmp</span>(_argv[<span class="number">0</span>], <span class="string">&quot;export&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">strcpy</span>(myenv, _argv[<span class="number">1</span>]);</span><br><span class="line">        putenv(myenv);               <span class="comment">// 添加到环境变量表</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// echo 命令：打印参数</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (_argc == <span class="number">2</span> &amp;&amp; <span class="built_in">strcmp</span>(_argv[<span class="number">0</span>], <span class="string">&quot;echo&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(_argv[<span class="number">1</span>], <span class="string">&quot;$?&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, lastcode);  <span class="comment">// 打印上一次命令退出码</span></span><br><span class="line">            lastcode = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (*_argv[<span class="number">1</span>] == <span class="string">&#x27;$&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">char</span>* val = getenv(_argv[<span class="number">1</span>] + <span class="number">1</span>);  <span class="comment">// 获取环境变量值</span></span><br><span class="line">            <span class="keyword">if</span> (val)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, _argv[<span class="number">1</span>]);  <span class="comment">// 直接打印参数</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 增强 ls 命令</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(_argv[<span class="number">0</span>], <span class="string">&quot;ls&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        _argv[_argc++] = <span class="string">&quot;--color&quot;</span>;    <span class="comment">// 添加颜色选项</span></span><br><span class="line">        _argv[_argc] = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 未处理，交给外部命令执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong><code>cd</code></strong>：使用 <code>chdir</code> 切换目录，并更新 <code>PWD</code> 环境变量。</li><li><strong><code>export</code></strong>：使用 <code>putenv</code> 设置环境变量，<code>myenv</code> 是全局缓冲区。</li><li><strong><code>echo</code></strong>：支持打印上一次退出码、环境变量 <code>VAR</code> 或普通字符串。</li><li><strong><code>ls</code> 增强</strong>：自动添加 <code>--color</code> 选项以显示彩色输出。</li><li>返回值：1 表示内置命令已处理，0 表示需要外部执行。</li></ul><h5 id="6-外部命令执行"><a href="#6-外部命令执行" class="headerlink" title="6. 外部命令执行"></a>6. 外部命令执行</h5><p>外部命令通过 <code>fork</code> 创建子进程并使用 <code>execvp</code> 执行：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">NormalExcute</span><span class="params">(<span class="type">char</span>* _argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> id = fork();</span><br><span class="line">    <span class="keyword">if</span> (id &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (id == <span class="number">0</span>)  <span class="comment">// 子进程</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> fd = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (rdir == IN_RDIR)</span><br><span class="line">        &#123;</span><br><span class="line">            fd = open(rdirfilename, O_RDONLY);</span><br><span class="line">            dup2(fd, <span class="number">0</span>);  <span class="comment">// 重定向标准输入</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (rdir == OUT_RDIR)</span><br><span class="line">        &#123;</span><br><span class="line">            fd = open(rdirfilename, O_CREAT | O_WRONLY | O_TRUNC, <span class="number">0666</span>);</span><br><span class="line">            dup2(fd, <span class="number">1</span>);  <span class="comment">// 重定向标准输出</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (rdir == APPEND_RDIR)</span><br><span class="line">        &#123;</span><br><span class="line">            fd = open(rdirfilename, O_CREAT | O_WRONLY | O_APPEND, <span class="number">0666</span>);</span><br><span class="line">            dup2(fd, <span class="number">1</span>);  <span class="comment">// 追加重定向标准输出</span></span><br><span class="line">        &#125;</span><br><span class="line">        execvp(_argv[<span class="number">0</span>], _argv);  <span class="comment">// 执行命令</span></span><br><span class="line">        <span class="built_in">exit</span>(EXIT_CODE);          <span class="comment">// exec 失败退出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>  <span class="comment">// 父进程</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> status = <span class="number">0</span>;</span><br><span class="line">        <span class="type">pid_t</span> rid = waitpid(id, &amp;status, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (rid == id)</span><br><span class="line">        &#123;</span><br><span class="line">            lastcode = WEXITSTATUS(status);  <span class="comment">// 记录退出码</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>fork()</code> 创建子进程。</p></li><li><p>子进程根据重定向类型（<code>rdir</code>）打开文件并使用 <code>dup2</code> 重定向。</p></li><li><p><code>execvp</code> 执行命令，从 <code>PATH</code> 中查找可执行文件。</p></li><li><p>父进程使用 <code>waitpid</code> 等待子进程结束，并记录退出码到 <code>lastcode</code>。</p></li><li><p>重定向支持，<code>Shell</code> 支持三种重定向：</p><ul><li><p><strong>输入重定向</strong>：<code>&lt; filename</code></p></li><li><p><strong>输出重定向</strong>：<code>&gt; filename</code></p></li><li><p><strong>追加输出重定向</strong>：<code>&gt;&gt; filename</code></p></li></ul></li></ul><h5 id="7-解析重定向符号"><a href="#7-解析重定向符号" class="headerlink" title="7. 解析重定向符号"></a>7. 解析重定向符号</h5><p>在 <code>check_redir</code> 函数中解析重定向：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NONE -1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IN_RDIR 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OUT_RDIR 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> APPEND_RDIR 2</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* rdirfilename = <span class="literal">NULL</span>;  <span class="comment">// 重定向文件名</span></span><br><span class="line"><span class="type">int</span> rdir = NONE;            <span class="comment">// 重定向类型</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">check_redir</span><span class="params">(<span class="type">char</span>* cmd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span>* pos = cmd;</span><br><span class="line">    <span class="keyword">while</span> (*pos)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (*pos == <span class="string">&#x27;&gt;&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (*(pos + <span class="number">1</span>) == <span class="string">&#x27;&gt;&#x27;</span>)  <span class="comment">// &gt;&gt;</span></span><br><span class="line">            &#123;</span><br><span class="line">                *pos++ = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                *pos++ = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                <span class="keyword">while</span> (<span class="built_in">isspace</span>(*pos)) pos++;</span><br><span class="line">                rdirfilename = pos;</span><br><span class="line">                rdir = APPEND_RDIR;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>  <span class="comment">// &gt;</span></span><br><span class="line">            &#123;</span><br><span class="line">                *pos = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                pos++;</span><br><span class="line">                <span class="keyword">while</span> (<span class="built_in">isspace</span>(*pos)) pos++;</span><br><span class="line">                rdirfilename = pos;</span><br><span class="line">                rdir = OUT_RDIR;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (*pos == <span class="string">&#x27;&lt;&#x27;</span>)  <span class="comment">// &lt;</span></span><br><span class="line">        &#123;</span><br><span class="line">            *pos = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">            pos++;</span><br><span class="line">            <span class="keyword">while</span> (<span class="built_in">isspace</span>(*pos)) pos++;</span><br><span class="line">            rdirfilename = pos;</span><br><span class="line">            rdir = IN_RDIR;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pos++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>遍历命令行，检测 <code>&lt;</code>、<code>&gt;</code> 或 <code>&gt;&gt;</code>。</li><li>将符号替换为 <code>\0</code> 以分割命令和文件名。</li><li>设置全局变量 <code>rdir</code> 和 <code>rdirfilename</code>。</li><li><code>interact</code> 函数调用 <code>check_redir</code> 进行解析。</li></ul><h5 id="8-执行重定向"><a href="#8-执行重定向" class="headerlink" title="8. 执行重定向"></a>8. 执行重定向</h5><p>在 <code>NormalExcute</code> 中根据 <code>rdir</code> 处理重定向：</p><ul><li><strong>输入重定向</strong>：打开文件并重定向到标准输入（文件描述符 0）。</li><li><strong>输出重定向</strong>：创建或截断文件并重定向到标准输出（文件描述符 1）。</li><li><strong>追加输出重定向</strong>：创建或追加文件并重定向到标准输出。</li><li><strong>环境变量管理：</strong><ul><li><strong>查看</strong>：通过 <code>echo $VAR</code> 查看环境变量值。</li><li><strong>设置</strong>：通过 <code>export VAR = VALUE</code> 设置环境变量。</li></ul></li></ul><p>这些功能已在 <code>buildCommand</code> 的 <code>echo</code> 和 <code>export</code> 实现中完成。</p><h5 id="9-主循环"><a href="#9-主循环" class="headerlink" title="9. 主循环"></a>9. 主循环</h5><p><code>Shell</code> 的主循环负责持续运行：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (!quit)</span><br><span class="line">    &#123;</span><br><span class="line">        rdirfilename = <span class="literal">NULL</span>;  <span class="comment">// 重置重定向信息</span></span><br><span class="line">        rdir = NONE;</span><br><span class="line">        interact(commandline, <span class="keyword">sizeof</span>(commandline));  <span class="comment">// 获取输入</span></span><br><span class="line">        <span class="type">int</span> argc = splitstring(commandline, argv);   <span class="comment">// 解析命令</span></span><br><span class="line">        <span class="keyword">if</span> (argc == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">int</span> n = buildCommand(argv, argc);            <span class="comment">// 处理内置命令</span></span><br><span class="line">        <span class="keyword">if</span> (!n)</span><br><span class="line">        &#123;</span><br><span class="line">            NormalExcute(argv);                      <span class="comment">// 执行外部命令</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>重置重定向状态。</li><li>获取并解析用户输入。</li><li>处理内置命令或外部命令。</li><li><code>quit</code> 变量控制退出（当前代码中未实现 <code>exit</code> 命令，可扩展）。</li></ul><h4 id="3-源码一览"><a href="#3-源码一览" class="headerlink" title="3. 源码一览"></a>3. 源码一览</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ======================== 宏定义区域 ========================</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEFT <span class="string">&quot;[&quot;</span>                            <span class="comment">// shell 显示用的左括号</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RIGHT <span class="string">&quot;]&quot;</span>                           <span class="comment">// shell 显示用的右括号</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LABLE <span class="string">&quot;#&quot;</span>                           <span class="comment">// shell 显示用的提示符号</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DELIM <span class="string">&quot; \t&quot;</span>                         <span class="comment">// 分隔符（空格和制表符）</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LINE_SIZE 1024                      <span class="comment">// 每一行命令最大长度</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ARGC_SIZE 32                        <span class="comment">// 最大命令参数个数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXIT_CODE 44                        <span class="comment">// 子进程执行失败退出码</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 重定向类型定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NONE -1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IN_RDIR     0                       <span class="comment">// 输入重定向（&lt;）</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OUT_RDIR    1                       <span class="comment">// 输出重定向（&gt;）</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> APPEND_RDIR 2                       <span class="comment">// 追加输出重定向（&gt;&gt;）</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ======================== 全局变量 ========================</span></span><br><span class="line"><span class="type">int</span> lastcode = <span class="number">0</span>;                           <span class="comment">// 上一次命令的返回码</span></span><br><span class="line"><span class="type">int</span> quit = <span class="number">0</span>;                               <span class="comment">// 控制是否退出 shell</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span>** environ;                      <span class="comment">// 系统环境变量表</span></span><br><span class="line"><span class="type">char</span> commandline[LINE_SIZE];                <span class="comment">// 存储用户输入命令</span></span><br><span class="line"><span class="type">char</span>* argv[ARGC_SIZE];                      <span class="comment">// 存储分割后的命令参数</span></span><br><span class="line"><span class="type">char</span> pwd[LINE_SIZE];                        <span class="comment">// 当前工作目录</span></span><br><span class="line"><span class="type">char</span>* rdirfilename = <span class="literal">NULL</span>;                  <span class="comment">// 重定向的文件名</span></span><br><span class="line"><span class="type">int</span> rdir = NONE;                            <span class="comment">// 当前重定向类型</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> myenv[LINE_SIZE];                      <span class="comment">// 存储 export 设置的环境变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ======================== 工具函数 ========================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前用户名</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* <span class="title function_">getusername</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> getenv(<span class="string">&quot;USER&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取主机名</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* <span class="title function_">gethostname1</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> getenv(<span class="string">&quot;HOSTNAME&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前路径（PWD）</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">getpwd</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    getcwd(pwd, <span class="keyword">sizeof</span>(pwd));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析重定向符号（&lt; &gt; &gt;&gt;）并设置 rdir 和 rdirfilename</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">check_redir</span><span class="params">(<span class="type">char</span>* cmd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span>* pos = cmd;</span><br><span class="line">    <span class="keyword">while</span> (*pos)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (*pos == <span class="string">&#x27;&gt;&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (*(pos + <span class="number">1</span>) == <span class="string">&#x27;&gt;&#x27;</span>)          <span class="comment">// &gt;&gt; 追加重定向</span></span><br><span class="line">            &#123; </span><br><span class="line">                *pos++ = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                *pos++ = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                <span class="keyword">while</span> (<span class="built_in">isspace</span>(*pos))</span><br><span class="line">                &#123;</span><br><span class="line">                    pos++;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                rdirfilename = pos;</span><br><span class="line">                rdir = APPEND_RDIR;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>                            <span class="comment">// &gt; 普通输出重定向</span></span><br><span class="line">            &#123; </span><br><span class="line">                *pos = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                pos++;</span><br><span class="line">                <span class="keyword">while</span> (<span class="built_in">isspace</span>(*pos))</span><br><span class="line">                &#123;</span><br><span class="line">                    pos++;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                rdirfilename = pos;</span><br><span class="line">                rdir = OUT_RDIR;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (*pos == <span class="string">&#x27;&lt;&#x27;</span>)               <span class="comment">// &lt; 输入重定向</span></span><br><span class="line">        &#123;</span><br><span class="line">            *pos = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">            pos++;</span><br><span class="line">            <span class="keyword">while</span> (<span class="built_in">isspace</span>(*pos))</span><br><span class="line">            &#123;</span><br><span class="line">                pos++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            rdirfilename = pos;</span><br><span class="line">            rdir = IN_RDIR;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pos++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示 shell 提示符并获取用户输入命令</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">interact</span><span class="params">(<span class="type">char</span>* cline, <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    getpwd();</span><br><span class="line">    <span class="built_in">printf</span>(LEFT<span class="string">&quot;%s@%s %s&quot;</span>RIGHT<span class="string">&quot;&quot;</span>LABLE<span class="string">&quot; &quot;</span>, getusername(), gethostname1(), pwd);</span><br><span class="line">    <span class="type">char</span>* s = fgets(cline, size, <span class="built_in">stdin</span>);    <span class="comment">// 获取用户输入</span></span><br><span class="line">    assert(s);                              <span class="comment">// 确保输入成功</span></span><br><span class="line">    (<span class="type">void</span>)s; <span class="comment">// 显式标记该变量已被“使用”，从而抑制编译器警告（这是一种代码规范技巧，表明有意忽略此变量）</span></span><br><span class="line"></span><br><span class="line">    cline[<span class="built_in">strlen</span>(cline) - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;        <span class="comment">// 去除换行符</span></span><br><span class="line">    check_redir(cline);                     <span class="comment">// 检查是否有重定向</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将命令行字符串根据空格分割成参数数组</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">splitstring</span><span class="params">(<span class="type">char</span> cline[], <span class="type">char</span>* _argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    argv[i++] = strtok(cline, DELIM);</span><br><span class="line">    <span class="keyword">while</span> (_argv[i++] = strtok(<span class="literal">NULL</span>, DELIM));   <span class="comment">// 使用 strtok 循环分割</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> i - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行普通命令（fork+exec）</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">NormalExcute</span><span class="params">(<span class="type">char</span>* _argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> id = fork();</span><br><span class="line">    <span class="keyword">if</span> (id &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (id == <span class="number">0</span>)                           <span class="comment">// 子进程执行命令</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> fd = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (rdir == IN_RDIR)</span><br><span class="line">        &#123;</span><br><span class="line">            fd = open(rdirfilename, O_RDONLY);</span><br><span class="line">            dup2(fd, <span class="number">0</span>);                        <span class="comment">// 标准输入重定向</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (rdir == OUT_RDIR)</span><br><span class="line">        &#123;</span><br><span class="line">            fd = open(rdirfilename, O_CREAT | O_WRONLY | O_TRUNC, <span class="number">0666</span>);</span><br><span class="line">            dup2(fd, <span class="number">1</span>);                        <span class="comment">// 标准输出重定向</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (rdir == APPEND_RDIR) &#123;</span><br><span class="line">            fd = open(rdirfilename, O_CREAT | O_WRONLY | O_APPEND, <span class="number">0666</span>);</span><br><span class="line">            dup2(fd, <span class="number">1</span>);                        <span class="comment">// 标准输出追加重定向</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        execvp(_argv[<span class="number">0</span>], _argv);                <span class="comment">// 执行命令（从 PATH 路径中查找）</span></span><br><span class="line">        <span class="built_in">exit</span>(EXIT_CODE);                        <span class="comment">// exec 出错则退出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>                                        <span class="comment">// 父进程等待子进程结束</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> status = <span class="number">0</span>;</span><br><span class="line">        <span class="type">pid_t</span> rid = waitpid(id, &amp;status, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (rid == id)</span><br><span class="line">        &#123;</span><br><span class="line">            lastcode = WEXITSTATUS(status);     <span class="comment">// 记录子进程退出码</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建内置命令：cd, export, echo</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">buildCommand</span><span class="params">(<span class="type">char</span>* _argv[], <span class="type">int</span> _argc)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (_argc == <span class="number">2</span> &amp;&amp; <span class="built_in">strcmp</span>(_argv[<span class="number">0</span>], <span class="string">&quot;cd&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        chdir(argv[<span class="number">1</span>]);                         <span class="comment">// 切换工作目录</span></span><br><span class="line">        getpwd();</span><br><span class="line">        <span class="built_in">sprintf</span>(getenv(<span class="string">&quot;PWD&quot;</span>), <span class="string">&quot;%s&quot;</span>, pwd);      <span class="comment">// 更新环境变量 PWD</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (_argc == <span class="number">2</span> &amp;&amp; <span class="built_in">strcmp</span>(_argv[<span class="number">0</span>], <span class="string">&quot;export&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">strcpy</span>(myenv, _argv[<span class="number">1</span>]);</span><br><span class="line">        putenv(myenv);                          <span class="comment">// 添加或修改环境变量</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (_argc == <span class="number">2</span> &amp;&amp; <span class="built_in">strcmp</span>(_argv[<span class="number">0</span>], <span class="string">&quot;echo&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(_argv[<span class="number">1</span>], <span class="string">&quot;$?&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, lastcode);           <span class="comment">// 打印上一次命令的返回码</span></span><br><span class="line">            lastcode = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (*_argv[<span class="number">1</span>] == <span class="string">&#x27;$&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">char</span>* val = getenv(_argv[<span class="number">1</span>] + <span class="number">1</span>);   <span class="comment">// 获取环境变量值</span></span><br><span class="line">            <span class="keyword">if</span> (val)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, _argv[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 针对 ls 增加颜色选项</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(_argv[<span class="number">0</span>], <span class="string">&quot;ls&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        _argv[_argc++] = <span class="string">&quot;--color&quot;</span>; <span class="comment">// 自动加上颜色显示</span></span><br><span class="line">        _argv[_argc] = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ======================== 主函数入口 ========================</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (!quit)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 初始化重定向信息</span></span><br><span class="line">        rdirfilename = <span class="literal">NULL</span>;</span><br><span class="line">        rdir = NONE;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取用户输入的命令行</span></span><br><span class="line">        interact(commandline, <span class="keyword">sizeof</span>(commandline));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 分割命令行为参数数组</span></span><br><span class="line">        <span class="type">int</span> argc = splitstring(commandline, argv);</span><br><span class="line">        <span class="keyword">if</span> (argc == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理内置命令</span></span><br><span class="line">        <span class="type">int</span> n = buildCommand(argv, argc);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行普通命令</span></span><br><span class="line">        <span class="keyword">if</span> (!n)</span><br><span class="line">        &#123;</span><br><span class="line">            NormalExcute(argv);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个 <code>Shell</code> 虽简单，但展示了 <code>Shell</code> 的相对核心机制。当然还有一些其他功能没有实现，以及代码中还多场景考虑不周到、兼容性、健壮性等问题处理不够完美，还是等以后学深了再完善吧~</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>019 进程控制 —— 进程程序替换</title>
      <link href="/posts/28370.html"/>
      <url>/posts/28370.html</url>
      
        <content type="html"><![CDATA[<h2 id="进程控制-——-进程程序替换"><a href="#进程控制-——-进程程序替换" class="headerlink" title="进程控制 —— 进程程序替换"></a>进程控制 —— 进程程序替换</h2><h3 id="1-替换原理"><a href="#1-替换原理" class="headerlink" title="1. 替换原理"></a>1. 替换原理</h3><p>进程程序替换是指在一个已经存在的进程中，通过系统调用将当前进程的代码、数据等全部替换为新程序的内容，也就是说，新程序加载到当前进程的地址空间中，原来进程的内容被完全覆盖。在这一过程中，进程的 <code>PID</code> 保持不变，但内存空间、寄存器的内容和代码逻辑均变为新程序的内容。</p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250416125005995.png" alt="image-20250416124958825"></p><p>【关键点】</p><ol><li>进程替换不创建新进程，而是复用现有进程的 <code>PID</code>，这对需要快速切换任务、降低资源开销有很大好处。</li><li>一旦替换成功，原进程的代码 <strong>立即终止</strong>，从新程序的 <code>main</code> 函数开始执行。</li><li>替换过程会关闭原进程中打开的文件描述符（除非这些描述符被标记为在 exec 之后保留），<code>fcntl(fd, F_SETFD, FD_CLOEXEC)</code> 标记文件描述符在 <code>exec</code> 后关闭（了解）。</li></ol><hr><h3 id="2-execl-的单进程使用"><a href="#2-execl-的单进程使用" class="headerlink" title="2. execl 的单进程使用"></a>2. execl 的单进程使用</h3><h4 id="1-函数原型"><a href="#1-函数原型" class="headerlink" title="1. 函数原型"></a>1. 函数原型</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">execl</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* path, <span class="type">const</span> <span class="type">char</span>* arg, ..., (<span class="type">char</span>*)<span class="literal">NULL</span>)</span>;</span><br><span class="line"></span><br><span class="line">注意：execl 接受变长参数，需要以 <span class="literal">NULL</span> 结束参数列表，参数顺序要求严格，第一个参数通常写为程序文件的绝对路径，第二个参数是新程序的“名称”，随后是实际参数。</span><br><span class="line"><span class="type">int</span> <span class="title function_">execl</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="type">char</span>* path,       <span class="comment">// 新程序的路径（核心！）</span></span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="type">char</span>* arg0,       <span class="comment">// 第一个参数（通常为程序名）</span></span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="type">char</span>* arg1,       <span class="comment">// 第二个参数（如命令行选项）</span></span></span><br><span class="line"><span class="params">    ...,                    <span class="comment">// 可变参数（灵活传递）</span></span></span><br><span class="line"><span class="params">    (<span class="type">char</span>*)<span class="literal">NULL</span>             <span class="comment">// 参数结束标志（必须！忘记会导致崩溃或参数错乱）</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p><strong>参数解析</strong>：</p><ul><li><code>path</code>：<strong>新程序的绝对路径</strong>（如 <code>/bin/ls</code>），必须明确指定位置！</li><li><code>arg</code>：命令行参数列表，<strong>第一个参数通常是程序名</strong>，最后必须加 <code>NULL</code> 表示结束。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;原进程即将被替换！\n&quot;</span>);</span><br><span class="line">    execl(<span class="string">&quot;/bin/ls&quot;</span>, <span class="string">&quot;ls&quot;</span>, <span class="string">&quot;-l&quot;</span>, <span class="literal">NULL</span>);     <span class="comment">// 执行 ls -l 命令</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;这里不会被执行！你看不到我！\n&quot;</span>);</span><br><span class="line">    perror(<span class="string">&quot;execl failed&quot;</span>);                 <span class="comment">// 若替换失败才会执行到这里</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>替换成功后，<code>printf(&quot;原进程...&quot;)</code> 之后的代码 <strong>不再执行</strong>。</li><li>若替换失败（如路径错误），<code>perror</code> 会输出错误信息。</li></ul><p><strong>运行示例：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250416132648901.png" alt="image-20250416132648832"></p><hr><h3 id="3-execl-的多进程使用"><a href="#3-execl-的多进程使用" class="headerlink" title="3. execl 的多进程使用"></a>3. execl 的多进程使用</h3><p>我们先 <code>fork()</code> 创建一个 <strong>子进程</strong>，在子进程中使用 <code>execl()</code> 替换自身为另一个程序，而 <strong>父进程继续执行原有逻辑</strong>。这种方式不会影响父进程，同时能让子进程跑一个完全不同的程序，是 <strong>非常经典的进程控制模式</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>  <span class="comment">// 包含 fork() 的头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>  <span class="comment">// 包含 exit() 的头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid = fork();         <span class="comment">// 创建子进程</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>)               <span class="comment">// 子进程：使用 execl 替换为新程序</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我是子进程，PID: %d，现在执行 execl 替换为 ls 命令\n&quot;</span>, <span class="built_in">getpid</span>());</span><br><span class="line">        <span class="built_in">execl</span>(<span class="string">&quot;/bin/ls&quot;</span>, <span class="string">&quot;ls&quot;</span>, <span class="string">&quot;-l&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;execl failed&quot;</span>); <span class="comment">// 若 execl 出错，才会继续执行下面语句</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>)           <span class="comment">// 父进程继续执行原有逻辑</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我是父进程，PID: %d，创建了子进程: %d\n&quot;</span>, <span class="built_in">getpid</span>(), pid);</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;父进程结束\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;fork failed&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行示例：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250416134826358.png" alt="image-20250416134826280"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">我是父进程，PID: 18882，创建了子进程: 18883</span><br><span class="line">我是子进程，PID: 18883，现在执行 execl 替换为 <span class="built_in">ls</span> 命令</span><br><span class="line">total 32</span><br><span class="line">-rwxrwxr-x 1 hcc hcc 8720 Apr 16 13:47 Multi-process</span><br><span class="line">-rw-rw-r-- 1 hcc hcc  833 Apr 16 13:44 Multi-process.c</span><br><span class="line">-rwxrwxr-x 1 hcc hcc 8464 Apr 16 13:25 test1</span><br><span class="line">-rw-rw-r-- 1 hcc hcc  325 Apr 16 13:24 test1.c</span><br><span class="line">父进程结束</span><br></pre></td></tr></table></figure><h3 id="4-exec-函数“全家桶”"><a href="#4-exec-函数“全家桶”" class="headerlink" title="4. exec 函数“全家桶”"></a>4. <code>exec</code> 函数“全家桶”</h3><p>Linux 下有 7 种以 <code>exec</code> 开头的函数，统称 <code>exec</code> 函数。</p><ul><li>系统调用类：<code>exec</code> 是由内核提供的系统调用，属于 <code>man</code> 手册的第 2 章节。</li><li>库函数类：其他 <code>exec</code> 函数均是 C 标准库对 <code>execve</code> 的封装，属于 <code>man</code> 手册第 3 章节。</li></ul><p><strong><code>exec</code> 函数族成员一览（记熟）</strong></p><table><thead><tr><th>函数名</th><th>参数类型</th><th>使用说明</th></tr></thead><tbody><tr><td><strong>execl</strong></td><td>列出参数（arg0, arg1, …, NULL）</td><td>最常用，适合参数个数固定 ✅</td></tr><tr><td><strong>execv</strong></td><td>参数数组（char * argv []）</td><td>参数可变，用数组表示（* *程序参数动态构造（任务调度器）**）</td></tr><tr><td><strong>execle</strong></td><td>列出参数 + 环境变量（envp）</td><td>适合需要指定环境变量</td></tr><tr><td><strong><span style="color:#FF0000;">execve</span></strong></td><td>参数数组 + 环境变量</td><td>最底层函数，系统调用接口 ✅</td></tr><tr><td><strong>execlp</strong></td><td>自动查 <code>$PATH</code> + 列出参数</td><td>不指定绝对路径，依赖环境 PATH ✅</td></tr><tr><td><strong>execvp</strong></td><td>自动查 <code>$PATH</code> + 参数数组</td><td>最常见 Shell 结构 ✅（<strong>支持 PATH 查找 + 动态参数</strong>）</td></tr><tr><td><strong>execvpe</strong></td><td>自动查 <code>$PATH</code> + 参数数组 + envp</td><td>非标准，GNU 扩展</td></tr></tbody></table><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250416185202771.png" alt="image-20250416185202635"></p><p><strong>记忆：</strong></p><ul><li>l（list）：表示参数采用列表。</li><li>v（vector）：参数用数组。</li><li>p（path）：有 p 自动搜索环境变量 PATH。</li><li>e（env）：表示自己维护环境变量。</li></ul><hr><h4 id="1-man-手册查询"><a href="#1-man-手册查询" class="headerlink" title="1. man 手册查询"></a>1. <code>man</code> 手册查询</h4><p>一般来说使用 <strong><code>man 3 exec</code></strong>（6 个）和 <strong><code>man 2 execve</code></strong>（1 个）就能进行查询，但是不妨有朋友像我一样被提示“<code>No manual entry for execl</code>”，如何解决？根据搜索，使用命令 <strong><code>sudo yum install man-pages man-pages-posix</code></strong> 即可（如果是其他情况还请自行搜索）。</p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250416170533933.png" alt="image-20250416170533773"></p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250416171813105.png" alt="image-20250416171812992"></p><h4 id="2-核心函数详解（实战场景）"><a href="#2-核心函数详解（实战场景）" class="headerlink" title="2. 核心函数详解（实战场景）"></a>2. 核心函数详解（实战场景）</h4><h5 id="①-execl（列表传参-绝对路径）"><a href="#①-execl（列表传参-绝对路径）" class="headerlink" title="① execl（列表传参 + 绝对路径）"></a>① <code>execl</code>（列表传参 + 绝对路径）</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execl(<span class="string">&quot;/bin/ls&quot;</span>, <span class="string">&quot;ls&quot;</span>, <span class="string">&quot;-l&quot;</span>, <span class="literal">NULL</span>); <span class="comment">// 执行 /bin/ls -l</span></span><br></pre></td></tr></table></figure><ul><li><strong>重点</strong>：必须指定完整路径，参数以列表形式传递，末尾必须加 <code>NULL</code>。</li></ul><h5 id="②-execlp（列表传参-自动搜索-PATH）"><a href="#②-execlp（列表传参-自动搜索-PATH）" class="headerlink" title="② execlp（列表传参 + 自动搜索 PATH）"></a>② <code>execlp</code>（列表传参 + 自动搜索 <code>PATH</code>）</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execlp(<span class="string">&quot;ls&quot;</span>, <span class="string">&quot;ls&quot;</span>, <span class="string">&quot;-l&quot;</span>, <span class="literal">NULL</span>); <span class="comment">// 执行系统命令 ls（自动搜索 PATH 环境变量）</span></span><br></pre></td></tr></table></figure><ul><li><strong>优势</strong>：直接使用命令名（如 <code>ls</code>），无需写绝对路径。</li></ul><h5 id="③-execle（列表传参-自定义环境变量）"><a href="#③-execle（列表传参-自定义环境变量）" class="headerlink" title="③ execle（列表传参 + 自定义环境变量）"></a>③ <code>execle</code>（列表传参 + 自定义环境变量）</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义环境变量并执行程序</span></span><br><span class="line"><span class="type">char</span> *env[] = &#123;<span class="string">&quot;MY_ENV=hello&quot;</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">execle(<span class="string">&quot;/path/to/my_program&quot;</span>, <span class="string">&quot;my_program&quot;</span>, <span class="literal">NULL</span>, env); </span><br></pre></td></tr></table></figure><ul><li><strong>应用场景</strong>：需要为子进程指定独立环境变量（如容器化任务）。</li></ul><h5 id="④-execv（数组传参-绝对路径）"><a href="#④-execv（数组传参-绝对路径）" class="headerlink" title="④ execv（数组传参 + 绝对路径）"></a>④ <code>execv</code>（数组传参 + 绝对路径）</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数以数组形式传递</span></span><br><span class="line"><span class="type">char</span> *argv[] = &#123;<span class="string">&quot;ls&quot;</span>, <span class="string">&quot;-l&quot;</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">execv(<span class="string">&quot;/bin/ls&quot;</span>, argv); </span><br></pre></td></tr></table></figure><ul><li><strong>适用场景</strong>：参数动态生成（如从用户输入或配置文件读取）。</li></ul><h5 id="⑤-execvp（数组传参-自动搜索-PATH）"><a href="#⑤-execvp（数组传参-自动搜索-PATH）" class="headerlink" title="⑤ execvp（数组传参 + 自动搜索 PATH）"></a>⑤ <code>execvp</code>（数组传参 + 自动搜索 <code>PATH</code>）</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态参数数组 + 自动搜索 PATH</span></span><br><span class="line"><span class="type">char</span> *argv[] = &#123;<span class="string">&quot;ls&quot;</span>, <span class="string">&quot;-l&quot;</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">execvp(<span class="string">&quot;ls&quot;</span>, argv); </span><br></pre></td></tr></table></figure><ul><li><strong>高频用法</strong>：实现类似 Shell 的功能（动态解析命令参数）。</li></ul><h5 id="⑥-execvpe（数组传参-搜索-PATH-自定义环境变量）"><a href="#⑥-execvpe（数组传参-搜索-PATH-自定义环境变量）" class="headerlink" title="⑥ execvpe（数组传参 + 搜索 PATH + 自定义环境变量）"></a>⑥ <code>execvpe</code>（数组传参 + 搜索 <code>PATH</code> + 自定义环境变量）</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GNU 扩展，非所有系统支持</span></span><br><span class="line"><span class="type">char</span> *argv[] = &#123;<span class="string">&quot;my_program&quot;</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line"><span class="type">char</span> *env[] = &#123;<span class="string">&quot;CUSTOM_ENV=1&quot;</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">execvpe(<span class="string">&quot;my_program&quot;</span>, argv, env); </span><br></pre></td></tr></table></figure><ul><li><strong>注意</strong>：<code>execvpe</code> 是 <code>GNU</code> 扩展函数，需确认系统支持（如 Linux 可用）。</li></ul><h5 id="⑦-execve（系统调用-完全控制）"><a href="#⑦-execve（系统调用-完全控制）" class="headerlink" title="⑦ execve（系统调用 + 完全控制）"></a>⑦ <code>execve</code>（系统调用 + 完全控制）</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 系统调用级函数，直接控制环境变量和参数</span></span><br><span class="line"><span class="type">char</span> *argv[] = &#123;<span class="string">&quot;ls&quot;</span>, <span class="string">&quot;-l&quot;</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line"><span class="type">char</span> *env[] = &#123;<span class="string">&quot;PATH=/bin&quot;</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">execve(<span class="string">&quot;/bin/ls&quot;</span>, argv, env); </span><br></pre></td></tr></table></figure><ul><li><strong>本质</strong>：其他 <code>exec</code> 函数最终调用 <code>execve</code> 实现功能。</li></ul><blockquote><p>  [!NOTE]</p><p>  所有 <code>exec</code> 函数 <strong>成功时不返回，失败时返回 <code>-1</code>！</strong> 检查返回值并处理错误：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">execl</span>(...) == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">perror</span>(<span class="string">&quot;执行失败！&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span>* <span class="type">const</span> argv[] = &#123; <span class="string">&quot;ps&quot;</span>, <span class="string">&quot;-ef&quot;</span>, <span class="literal">NULL</span> &#125;;</span><br><span class="line">    <span class="type">char</span>* <span class="type">const</span> envp[] = &#123; <span class="string">&quot;PATH=/bin:/usr/bin&quot;</span>, <span class="string">&quot;TERM=console&quot;</span>, <span class="literal">NULL</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// execl: 需要完整路径</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">execl</span>(<span class="string">&quot;/bin/ps&quot;</span>, <span class="string">&quot;ps&quot;</span>, <span class="string">&quot;-ef&quot;</span>, <span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;execl&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// execlp: 使用 PATH 环境变量</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">execlp</span>(<span class="string">&quot;ps&quot;</span>, <span class="string">&quot;ps&quot;</span>, <span class="string">&quot;-ef&quot;</span>, <span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;execlp&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// execle: 需要自己设置环境变量</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">execle</span>(<span class="string">&quot;ps&quot;</span>, <span class="string">&quot;ps&quot;</span>, <span class="string">&quot;-ef&quot;</span>, <span class="literal">NULL</span>, envp) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;execle&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// execv: 参数通过数组传递</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">execv</span>(<span class="string">&quot;/bin/ps&quot;</span>, argv) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;execv&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// execvp: 使用 PATH 环境变量</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">execvp</span>(<span class="string">&quot;ps&quot;</span>, argv) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;execvp&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// execve: 需要自己设置环境变量</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">execve</span>(<span class="string">&quot;/bin/ps&quot;</span>, argv, envp) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;execve&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><hr><h3 id="5-部分代码实战"><a href="#5-部分代码实战" class="headerlink" title="5. 部分代码实战"></a>5. 部分代码实战</h3><h4 id="1-使用-execvp-执行动态命令"><a href="#1-使用-execvp-执行动态命令" class="headerlink" title="1. 使用 execvp 执行动态命令"></a>1. 使用 <code>execvp</code> 执行动态命令</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *args[] = &#123;<span class="string">&quot;ls&quot;</span>, <span class="string">&quot;-l&quot;</span>, <span class="string">&quot;-a&quot;</span>, <span class="literal">NULL</span>&#125;; <span class="comment">// 参数数组</span></span><br><span class="line">    execvp(<span class="string">&quot;ls&quot;</span>, args);</span><br><span class="line">    perror(<span class="string">&quot;execvp 失败！&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>输出</strong>：执行 <code>ls -l -a</code>，参数通过数组动态传递。</li></ul><h4 id="2-使用-execle-自定义环境变量"><a href="#2-使用-execle-自定义环境变量" class="headerlink" title="2. 使用 execle 自定义环境变量"></a>2. 使用 <code>execle</code> 自定义环境变量</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *env[] = &#123;<span class="string">&quot;USER=test&quot;</span>, <span class="string">&quot;PATH=/usr/bin&quot;</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">    execle(<span class="string">&quot;/bin/ls&quot;</span>, <span class="string">&quot;ls&quot;</span>, <span class="string">&quot;-l&quot;</span>, <span class="literal">NULL</span>, env);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 只有出错才会执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>作用</strong>：子进程的环境变量被替换为 <code>env</code> 数组中的内容。</li></ul><hr><h3 id="6-代码验证-exec-执行系统命令和自定义命令"><a href="#6-代码验证-exec-执行系统命令和自定义命令" class="headerlink" title="6. 代码验证 exec 执行系统命令和自定义命令"></a>6. 代码验证 <code>exec</code> 执行系统命令和自定义命令</h3><h4 id="1-执行系统命令（如-ls）"><a href="#1-执行系统命令（如-ls）" class="headerlink" title="1. 执行系统命令（如 ls）"></a>1. 执行系统命令（如 <code>ls</code>）</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    execlp(<span class="string">&quot;ls&quot;</span>, <span class="string">&quot;ls&quot;</span>, <span class="string">&quot;-l&quot;</span>, <span class="literal">NULL</span>);     <span class="comment">// 执行系统命令 ls -l，自动搜索 PATH 环境变量</span></span><br><span class="line">    perror(<span class="string">&quot;execlp 失败！&quot;</span>);            <span class="comment">// 若替换失败才会执行以下代码</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>执行结果</strong>：输出当前目录的文件列表（与终端直接运行 <code>ls -l</code> 效果一致）。</p><h4 id="2-执行自定义程序（如编译后的-my-program）"><a href="#2-执行自定义程序（如编译后的-my-program）" class="headerlink" title="2. 执行自定义程序（如编译后的 my_program）"></a>2. 执行自定义程序（如编译后的 <code>my_program</code>）</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 执行我们用户自己的程序（假设 my_program 在 /home/user/bin 下）</span></span><br><span class="line">    execl(<span class="string">&quot;/home/user/bin/my_program&quot;</span>, <span class="string">&quot;my_program&quot;</span>, <span class="string">&quot;arg1&quot;</span>, <span class="string">&quot;arg2&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">    perror(<span class="string">&quot;execl失败！&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>关键点</strong>：</p><ul><li><strong>路径必须正确</strong>：需指定自定义程序的绝对路径或确保其在 <code>PATH</code> 环境变量中。</li><li><strong>参数自由传递</strong>：可传递任意参数给自定义程序（<code>my_program</code> 的 <code>main</code> 函数接收这些参数）。</li></ul><hr><h3 id="7-向子进程传递环境变量"><a href="#7-向子进程传递环境变量" class="headerlink" title="7. 向子进程传递环境变量"></a>7. 向子进程传递环境变量</h3><h4 id="1-使用-execle-或-execvpe-自定义环境变量"><a href="#1-使用-execle-或-execvpe-自定义环境变量" class="headerlink" title="1. 使用 execle 或 execvpe 自定义环境变量"></a>1. 使用 <code>execle</code> 或 <code>execvpe</code> 自定义环境变量</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span>* env[] = &#123; <span class="string">&quot;MY_ENV=hello&quot;</span>, <span class="string">&quot;PATH=/usr/bin&quot;</span>, <span class="literal">NULL</span> &#125;;    <span class="comment">// 自定义环境变量数组（必须以 NULL 结尾）</span></span><br><span class="line">    execle(<span class="string">&quot;/bin/ls&quot;</span>, <span class="string">&quot;ls&quot;</span>, <span class="string">&quot;-l&quot;</span>, <span class="literal">NULL</span>, env);                   <span class="comment">// 执行程序并传递自定义环境变量</span></span><br><span class="line">    perror(<span class="string">&quot;execle失败！&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>验证方法</strong>：在 <code>ls</code> 程序中无法直接看到环境变量（因为 <code>ls</code> 不读取这些变量），但可通过以下方式验证：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编写一个测试程序 test_env.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;MY_ENV=%s\n&quot;</span>, getenv(<span class="string">&quot;MY_ENV&quot;</span>));    <span class="comment">// 输出自定义环境变量</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译后执行：</span></span><br><span class="line">execle(<span class="string">&quot;./test_env&quot;</span>, <span class="string">&quot;test_env&quot;</span>, <span class="literal">NULL</span>, env);    <span class="comment">// 输出 &quot;MY_ENV = hello&quot;</span></span><br></pre></td></tr></table></figure><hr><h3 id="8-环境变量是覆盖还是追加？"><a href="#8-环境变量是覆盖还是追加？" class="headerlink" title="8. 环境变量是覆盖还是追加？"></a>8. 环境变量是覆盖还是追加？</h3><h4 id="1-核心规则"><a href="#1-核心规则" class="headerlink" title="1. 核心规则"></a>1. 核心规则</h4><ul><li><strong>若显式传递环境变量</strong>（如 <code>execle</code> 或 <code>execve</code>）：<strong>完全覆盖</strong> 父进程的环境变量，子进程仅保留传递的环境变量。</li><li><strong>若不传递环境变量</strong>（如 <code>execlp</code> 或 <code>execv</code>）：<strong>继承父进程的所有环境变量</strong>。</li></ul><h4 id="2-示例验证"><a href="#2-示例验证" class="headerlink" title="2. 示例验证"></a>2. 示例验证</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    setenv(<span class="string">&quot;PARENT_ENV&quot;</span>, <span class="string">&quot;parent_value&quot;</span>, <span class="number">1</span>);            <span class="comment">// 父进程设置一个环境变量</span></span><br><span class="line">    <span class="type">char</span>* env[] = &#123; <span class="string">&quot;CHILD_ENV=child_value&quot;</span>, <span class="literal">NULL</span> &#125;;    <span class="comment">// 自定义子进程环境变量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fork() == <span class="number">0</span>)                                    <span class="comment">// 子进程使用 execle 传递自定义环境变量</span></span><br><span class="line">    &#123;</span><br><span class="line">        execle(<span class="string">&quot;./test_env&quot;</span>, <span class="string">&quot;test_env&quot;</span>, <span class="literal">NULL</span>, env);</span><br><span class="line">        perror(<span class="string">&quot;execle failed&quot;</span>);</span><br><span class="line">        _exit(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>test_env</code> 程序输出</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CHILD_ENV=child_value</span><br><span class="line">PARENT_ENV=(null)   <span class="comment"># 父进程的环境变量被覆盖！</span></span><br></pre></td></tr></table></figure><hr><h3 id="9-总结"><a href="#9-总结" class="headerlink" title="9. 总结"></a>9. 总结</h3><h4 id="1-核心原理"><a href="#1-核心原理" class="headerlink" title="1. 核心原理"></a>1. 核心原理</h4><ul><li><strong>不创建新进程</strong>：复用现有进程的 <code>PID</code> 和资源（文件描述符等），仅替换代码和数据段。</li><li><strong>执行即替换</strong>：成功后原进程代码立即终止，从新程序的 <code>main</code> 开始执行。</li><li><strong>资源处理</strong>：默认关闭未标记的文件描述符，避免资源泄漏。</li></ul><h4 id="2-关键函数实战场景"><a href="#2-关键函数实战场景" class="headerlink" title="2. 关键函数实战场景"></a>2. 关键函数实战场景</h4><table><thead><tr><th>函数名</th><th>参数形式</th><th>路径搜索</th><th>环境变量</th><th>适用场景</th></tr></thead><tbody><tr><td><strong>execl</strong></td><td>列表传参</td><td>否</td><td>继承父进程</td><td>参数固定 + 绝对路径（如 <code>/bin/ls</code>）</td></tr><tr><td><strong>execlp</strong></td><td>列表传参</td><td>是</td><td>继承父进程</td><td>执行系统命令（如 <code>ls</code>，依赖 <code>PATH</code>）</td></tr><tr><td><strong>execle</strong></td><td>列表传参</td><td>否</td><td><strong>自定义覆盖</strong></td><td>需要独立环境变量（如容器化任务）</td></tr><tr><td><strong>execv</strong></td><td>数组传参</td><td>否</td><td>继承父进程</td><td>动态生成参数（如用户输入解析）</td></tr><tr><td><strong>execvp</strong></td><td>数组传参</td><td>是</td><td>继承父进程</td><td>Shell 类动态命令执行（如 <code>ls -l -a</code>）</td></tr><tr><td><strong>execve</strong></td><td>数组传参</td><td>否</td><td><strong>自定义覆盖</strong></td><td>系统级控制（底层实现）</td></tr></tbody></table><h4 id="3-环境变量规则"><a href="#3-环境变量规则" class="headerlink" title="3. 环境变量规则"></a>3. 环境变量规则</h4><ul><li><strong>覆盖规则</strong>：使用 <code>execle</code> 或 <code>execve</code> 时，子进程环境变量完全替换为传入的数组。</li><li><strong>继承规则</strong>：默认继承父进程环境变量，适用于 <code>execl</code>、<code>execv</code>、<code>execlp</code>、<code>execvp</code>。</li></ul><h4 id="4-实战口诀"><a href="#4-实战口诀" class="headerlink" title="4. 实战口诀"></a>4. 实战口诀</h4><ul><li><strong>列表传参用 <code>l</code>，数组传参用 <code>v</code></strong>  </li><li><strong>自动搜索加 <code>p</code>，环境变量加 <code>e</code></strong>  </li><li><strong>路径要对、参数要全、NULL 收尾、错误要检！</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 进程 </tag>
            
            <tag> 地址空间 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>018 进程控制 —— 进程等待</title>
      <link href="/posts/16008.html"/>
      <url>/posts/16008.html</url>
      
        <content type="html"><![CDATA[<h2 id="进程控制-——-进程等待"><a href="#进程控制-——-进程等待" class="headerlink" title="进程控制 —— 进程等待"></a>进程控制 —— 进程等待</h2><h3 id="1-进程等待必要性"><a href="#1-进程等待必要性" class="headerlink" title="1. 进程等待必要性"></a>1. 进程等待必要性</h3><ul><li>当父进程通过 <code>fork()</code> 创建了子进程后，<strong>子进程终止时，其退出信息必须由父进程读取</strong>，父进程如果不管不顾，就可能造成 <strong>僵尸进程</strong> 的问题，进而造成内存泄漏。</li><li>另外，进程一旦变成僵尸状态，那就刀枪不入，“杀人不眨眼”的 <code>kill -9</code> 也无能为力，因为谁也没有办法杀死一个已经死去的进程。</li><li>最后，父进程派给子进程的任务完成的如何，我们需要知道。如子进程运行完成，结果对还是不对，或者是否正常退出。</li><li>父进程通过进程等待的方式，回收子进程资源，获取子进程退出信息。</li></ul><blockquote><p>如果不等待会怎样？</p><ul><li>子进程退出了，但父进程没有调用 <code>wait()</code> 系列函数。</li><li>子进程的“退出状态”会保留在内核中，直到父进程读取它。</li><li><strong>此时子进程的 PCB 没有完全释放，占用系统资源。</strong></li><li>如果产生大量僵尸进程，系统资源将耗尽，导致无法创建新进程。、</li></ul></blockquote><p><strong>所以：父进程需要“等待”子进程终止并获取其退出状态，以释放系统资源。</strong></p><blockquote><p>  <strong>面试点拨：</strong> 如果不调用 <code>wait()</code> 会怎样？</p><p>  回答：子进程的退出信息留在内核，<code>PCB</code> 未释放，形成僵尸进程，长期不回收会占满系统资源。</p></blockquote><hr><h3 id="2-常用等待方法（重点掌握）"><a href="#2-常用等待方法（重点掌握）" class="headerlink" title="2. 常用等待方法（重点掌握）"></a>2. 常用等待方法（重点掌握）</h3><table><thead><tr><th>函数名</th><th>作用</th></tr></thead><tbody><tr><td><code>wait(int *status)</code></td><td>阻塞等待任意一个子进程结束，并获取其退出状态</td></tr><tr><td><code>waitpid(pid, &amp;status, options)</code></td><td>更灵活：等待指定子进程，或非阻塞等</td></tr></tbody></table><h4 id="1-wait-示例（阻塞等待子进程）"><a href="#1-wait-示例（阻塞等待子进程）" class="headerlink" title="1. wait() 示例（阻塞等待子进程）"></a>1. <code>wait()</code> 示例（阻塞等待子进程）</h4><blockquote><p><strong><code>wait()</code>：</strong></p><ul><li><strong>原型</strong>：<code>pid_t wait(int *status);</code></li><li><strong>功能</strong>：阻塞等待任意一个子进程退出，并回收其资源。</li><li><strong>参数</strong>：<code>status</code>（输出型参数）：保存&#x2F;获取子进程退出状态（需用宏解析，如 <code>WIFEXITED</code>）。不关心可设置为 NULL。</li><li><strong>返回值</strong>：成功返回子进程 PID，失败返回 <code>-1</code>。</li></ul></blockquote><p><strong>实验目的：</strong></p><ul><li>学会使用 <code>wait()</code> 函数阻塞等待子进程结束。</li><li>理解如何通过 <code>status</code> 获取子进程的退出状态。</li><li>掌握如何判断子进程是否正常退出以及获取其退出码。</li></ul><blockquote><p>  [!CAUTION]</p><p>  下面代码会涉及部分知识盲区，在文章后面会讲到！</p></blockquote><p><strong>实验：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> id = fork();</span><br><span class="line">    <span class="keyword">if</span> (id == <span class="number">0</span>)                            <span class="comment">// 子进程</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">while</span> (count--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;我是子进程...PID:%d, PPID:%d\n&quot;</span>, getpid(), getppid());   <span class="comment">// 子进程逻辑：打印 PID 和 PPID</span></span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);                            <span class="comment">// 子进程退出</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> status = <span class="number">0</span>;                         <span class="comment">// 存储子进程退出状态</span></span><br><span class="line">    <span class="type">pid_t</span> ret = wait(&amp;status);              <span class="comment">// 阻塞等待子进程结束</span></span><br><span class="line">    <span class="keyword">if</span> (ret &gt; <span class="number">0</span>)                            <span class="comment">// 父进程</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 父进程等待子进程结束</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;等待子进程结束...\n&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (WIFEXITED(status))              <span class="comment">// 判断子进程是否正常退出</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 子进程正常结束</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;子进程正常结束，退出状态码:%d\n&quot;</span>, WEXITSTATUS(status));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>实验示例结果：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">我是子进程...PID:1234, PPID:1233</span><br><span class="line">我是子进程...PID:1234, PPID:1233</span><br><span class="line">...</span><br><span class="line">等待子进程结束...</span><br><span class="line">子进程正常结束，退出状态码:0</span><br></pre></td></tr></table></figure><h4 id="2-waitpid-示例（等待指定子进程，更灵活）"><a href="#2-waitpid-示例（等待指定子进程，更灵活）" class="headerlink" title="2. waitpid() 示例（等待指定子进程，更灵活）"></a>2. <code>waitpid()</code> 示例（等待指定子进程，更灵活）</h4><blockquote><p><strong><code>waitpid()</code></strong></p><ul><li><strong>原型</strong>：<code>pid_t waitpid(pid_t pid, int *status, int options);</code></li><li><strong>功能</strong>：更灵活地等待指定子进程，支持非阻塞模式。</li><li><strong>参数</strong>：</li><li><code>pid</code>：指定子进程 PID，或 -1 表示任意子进程。</li><li><code>options</code>：常用的有 WNOHANG 表示非阻塞等待（立即返回，无子进程退出时返回 <code>0</code>）。</li><li><strong>返回值</strong>：成功返回子进程 PID，WNOHANG 模式下无退出子进程时返回 <code>0</code>，失败返回 <code>-1</code>。</li></ul></blockquote><p><strong>实验目的：</strong></p><ul><li>学会使用 <code>waitpid()</code> 函数等待指定子进程。</li><li>理解非阻塞等待（WNOHANG）的使用场景和优势。</li><li>掌握如何在等待子进程的同时处理其他任务。</li></ul><p><strong>实验 1：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> status;</span><br><span class="line">        <span class="type">pid_t</span> wpid;</span><br><span class="line">        <span class="keyword">while</span> ((wpid = waitpid(pid, &amp;status, WNOHANG)) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;父进程忙别的事...\n&quot;</span>);</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (WIFEXITED(status))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;子进程退出码 = %d\n&quot;</span>, WEXITSTATUS(status));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>实验示例结果：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">父进程忙别的事...</span><br><span class="line">父进程忙别的事...</span><br><span class="line">...</span><br><span class="line">子进程退出码 = 10</span><br></pre></td></tr></table></figure><blockquote><p>WNOHANG 的用途（<strong>后面详讲</strong>）：它用于非阻塞轮询场景，让父进程可以边处理任务边检查子进程状态。</p></blockquote><p><strong>实验 2：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> id = fork();          <span class="comment">// 创建子进程</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (id == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> time = <span class="number">5</span>;</span><br><span class="line">        <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &lt; time)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;我是子进程，我已经运行了:%d秒 PID:%d   PPID:%d\n&quot;</span>, n + <span class="number">1</span>, <span class="built_in">getpid</span>(), <span class="built_in">getppid</span>());</span><br><span class="line">            <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">            n++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">244</span>);              <span class="comment">// 子进程退出</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> status = <span class="number">0</span>;             <span class="comment">// 状态</span></span><br><span class="line">    <span class="type">pid_t</span> ret = <span class="built_in">waitpid</span>(id, &amp;status, <span class="number">0</span>);        <span class="comment">// 参数3 为0，为默认选项</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;进程等待失败！进程不存在！\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;子进程还在运行中！\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;进程等待成功，子进程已被回收\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;我是父进程, PID:%d   PPID:%d\n&quot;</span>, <span class="built_in">getpid</span>(), <span class="built_in">getppid</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过 status 判断子进程运行情况</span></span><br><span class="line">    <span class="keyword">if</span> ((status &amp; <span class="number">0x7F</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;子进程异常退出，core dump：%d   退出信号：%d\n&quot;</span>, (status &gt;&gt; <span class="number">7</span>) &amp; <span class="number">1</span>, (status &amp; <span class="number">0x7F</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;子进程正常退出，退出码：%d\n&quot;</span>, (status &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>实验示例结果：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">我是子进程，我已经运行了:1秒 PID:1234   PPID:1233</span><br><span class="line">...</span><br><span class="line">进程等待成功，子进程已被回收</span><br><span class="line">我是父进程, PID:1233   PPID:1232</span><br><span class="line">子进程正常退出，退出码：244</span><br></pre></td></tr></table></figure><hr><h3 id="3-status-退出状态详解"><a href="#3-status-退出状态详解" class="headerlink" title="3. status 退出状态详解"></a>3. status 退出状态详解</h3><h4 id="1-什么是-status？"><a href="#1-什么是-status？" class="headerlink" title="1. 什么是 status？"></a>1. 什么是 <code>status</code>？</h4><p>当你用 <code>wait()</code> 或 <code>waitpid()</code> 等函数回收子进程时，会通过一个整型变量 <code>status</code> 返回子进程的 <strong>终止状态&#x2F;状态码 status</strong> 信息。这个 <code>status</code> 是一个 <strong>32 位整数</strong>，它的 <strong>各个位（bit）存储了子进程退出的不同信息</strong>，主要包括：</p><ul><li>子进程是否正常退出</li><li>退出的返回码</li><li>是否是被信号中断</li><li>是否是 <code>core dump</code> 等</li></ul><p>当子进程结束时，它就会返回一个 <strong>状态码 status</strong>，通过宏函数解读它：</p><table><thead><tr><th>宏函数</th><th>判断或提取内容</th><th>实现底层逻辑</th><th>本质</th></tr></thead><tbody><tr><td><code>WIFEXITED()</code></td><td>是否正常退出</td><td><code>(status &amp; 0x7F) == 0</code></td><td>判断是否未被信号终止（是否正常退出）</td></tr><tr><td><code>WEXITSTATUS()</code></td><td>获取退出码</td><td><code>(status &gt;&gt; 8) &amp; 0xFF</code></td><td>提取退出码所在的 8 位（获取 exit 返回码）</td></tr></tbody></table><p>这些宏的 <strong>设计目的</strong> 就是为了 <strong>屏蔽底层实现细节</strong>，让你写代码时更易读。但其实就是对 <code>status</code> 进行的位运算封装。</p><hr><h4 id="2-status-的位布局（Linux-下）"><a href="#2-status-的位布局（Linux-下）" class="headerlink" title="2. status 的位布局（Linux 下）"></a>2. <code>status</code> 的位布局（Linux 下）</h4><p>通常（glibc 实现下），status 的位布局如下：</p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250414221823071.png" alt="image-20250414221815934"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">31.</span>.........<span class="number">.16</span> | <span class="number">15.</span>...<span class="number">.8</span> | <span class="number">7.</span>....<span class="number">.0</span></span><br><span class="line">   保留位        | 退出码   | 信号位  </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  31                            16 15         8 7      0</span><br><span class="line">+-----------------------------+-------------+--------+</span><br><span class="line">|           保留              | 退出码(exit) | 信号码 |</span><br><span class="line">+-----------------------------+-------------+--------+</span><br><span class="line">                                ↑           ↑</span><br><span class="line">                                |           |</span><br><span class="line">                             (status &gt;&gt; 8)  status &amp; 0x7F                                                 </span><br></pre></td></tr></table></figure><hr><h4 id="3-WIFEXITED-和-WEXITSTATUS-的底层原理"><a href="#3-WIFEXITED-和-WEXITSTATUS-的底层原理" class="headerlink" title="3. WIFEXITED 和 WEXITSTATUS 的底层原理"></a>3. WIFEXITED 和 WEXITSTATUS 的底层原理</h4><h5 id="1-WIFEXITED-status"><a href="#1-WIFEXITED-status" class="headerlink" title="1. WIFEXITED(status)"></a>1. <code>WIFEXITED(status)</code></h5><p>判断子进程是否 <strong>正常退出</strong>（调用了 <code>exit()</code> 或 <code>return</code>）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> WIFEXITED(status)  (((status) &amp; 0x7F) == 0)</span></span><br></pre></td></tr></table></figure><p>🔸 它检测的是 <strong>低 7 位（status &amp; 0x7F）是否为 0</strong>，即 <strong>没有被信号终止</strong>。</p><h5 id="2-WEXITSTATUS-status"><a href="#2-WEXITSTATUS-status" class="headerlink" title="2. WEXITSTATUS(status)"></a>2. <code>WEXITSTATUS(status)</code></h5><p>获取子进程的 <strong>退出码（exit() 或 return 的值）</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> WEXITSTATUS(status)  (((status) &gt;&gt; 8) &amp; 0xFF)</span></span><br></pre></td></tr></table></figure><p>🔸 它提取的是 <strong>第 8~15 位</strong>，因为退出码就被编码在这里。</p><h4 id="4-实验测试"><a href="#4-实验测试" class="headerlink" title="4. 实验测试"></a>4. 实验测试</h4><p><strong>实验目的：</strong></p><ul><li>学会解析 <code>status</code> 的各个位，了解子进程的退出状态。</li><li>掌握如何通过宏函数判断子进程是否正常退出以及获取其退出码。</li><li>理解如何手动解析 <code>status</code> 的位信息。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">66</span>); <span class="comment">// 子进程退出码设为 66</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> status = <span class="number">0</span>;</span><br><span class="line">        waitpid(pid, &amp;status, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;原始 status：%d (0x%x)\n&quot;</span>, status, status);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (WIFEXITED(status))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;正常退出，返回值 = %d\n&quot;</span>, WEXITSTATUS(status));</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;手动解析返回值 = %d\n&quot;</span>, (status &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;非正常退出\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出示例：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250414223219851.png" alt="image-20250414223219766"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">原始 status：16896 (0x4200)</span><br><span class="line">正常退出，返回值 = 66</span><br><span class="line">手动解析返回值 = 66</span><br></pre></td></tr></table></figure><p><strong>示例：手动解析 <code>status</code>：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">66</span>);                                       <span class="comment">// 子进程退出码设为 66</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> status = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">waitpid</span>(pid, &amp;status, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;原始 status: 0x%x\n&quot;</span>, status);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 手动解析 status</span></span><br><span class="line">        <span class="keyword">if</span> ((status &amp; <span class="number">0x7F</span>) == <span class="number">0</span>)                       <span class="comment">// 判断是否正常退出</span></span><br><span class="line">        &#123; </span><br><span class="line">            <span class="type">int</span> exit_code = (status &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>;       <span class="comment">// 提取退出码</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;手动解析：子进程正常退出，退出码: %d\n&quot;</span>, exit_code);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;手动解析：子进程异常退出，信号码: %d\n&quot;</span>, (status &amp; <span class="number">0x7F</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>扩展：</strong></p><p><strong>写法模板：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">&gt;<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line">&gt;<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line">&gt;<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">&gt;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">&gt;</span>&#123;</span><br><span class="line">   <span class="type">pid_t</span> pid = fork();</span><br><span class="line">   <span class="keyword">if</span> (pid == <span class="number">0</span>)           <span class="comment">// 子进程逻辑</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>)       <span class="comment">// 父进程逻辑</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="type">int</span> status;</span><br><span class="line">       <span class="type">pid_t</span> ret = <span class="built_in">waitpid</span>(pid, &amp;status, <span class="number">0</span>);</span><br><span class="line">       <span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="built_in">perror</span>(<span class="string">&quot;waitpid error&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">WIFEXITED</span>(status))</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="built_in">printf</span>(<span class="string">&quot;子进程正常退出，退出码: %d\n&quot;</span>, <span class="built_in">WEXITSTATUS</span>(status));</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">       &#123;</span><br><span class="line">           <span class="built_in">printf</span>(<span class="string">&quot;子进程异常退出\n&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="built_in">perror</span>(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><hr><p>若子进程是被信号杀死的，还可用：</p><ul><li><code>WIFSIGNALED(status)</code>：是否被信号终止。</li><li><code>WTERMSIG(status)</code>：哪个信号导致的。</li></ul><p>这些也都是对 <code>status</code> 特定位的封装。</p></blockquote><blockquote><p><strong>面试点拨：</strong></p><p><strong>Q：只创建一个子进程也要</strong> <code>wait()</code> <strong>吗？</strong></p><p>A：要，不然会产生僵尸进程。</p><p><strong>Q：</strong> <code>wait(NULL)</code> <strong>和</strong> <code>wait(&amp;status)</code> <strong>有何不同？</strong></p><p>A：前者不关心子进程退出码，后者可以判断退出状态。</p><p><strong>Q：<code>wait()</code> 和 <code>waitpid()</code> 的区别是什么？（详见下文）</strong></p><p>A：<code>wait()</code> 阻塞等待任意一个子进程，而 <code>waitpid()</code> 可以指定子进程，并支持非阻塞模式。</p><p><strong>Q：怎么判断子进程是否异常退出？</strong></p><p>A：<code>WIFEXITED(status)</code> 为假时即为异常，可结合 <code>WIFSIGNALED</code> 查看是否被信号终止。</p></blockquote><hr><h3 id="4-非阻塞轮询"><a href="#4-非阻塞轮询" class="headerlink" title="4. 非阻塞轮询"></a>4. 非阻塞轮询</h3><h4 id="1-什么是非阻塞轮询（Non-blocking-Polling）？"><a href="#1-什么是非阻塞轮询（Non-blocking-Polling）？" class="headerlink" title="1. 什么是非阻塞轮询（Non-blocking Polling）？"></a>1. 什么是非阻塞轮询（Non-blocking Polling）？</h4><p><strong>非阻塞轮询</strong> 是一种在程序中检查某项资源状态（比如文件描述符、输入输出、子进程状态等）时，不会阻塞（挂起）当前线程或进程的技术。非阻塞轮询其实是 <strong>进程等待的一种特殊形式</strong>，本质上就是使用 <code>waitpid()</code> 函数时，配合选项 <code>WNOHANG</code>，来实现 <strong>非阻塞地检查子进程是否退出</strong>。</p><p><strong>非阻塞轮询底层依赖：</strong></p><ul><li><code>waitpid(..., WNOHANG)</code>：设置为非阻塞检查子进程。</li><li><code>read()</code> &#x2F; <code>write()</code> 配合 <code>O_NONBLOCK</code> 标志。</li><li><code>select()</code> &#x2F; <code>poll()</code> &#x2F; <code>epoll()</code> 这些高级接口也支持非阻塞 I&#x2F;O 检测。</li></ul><p><strong>联系：</strong></p><ul><li><strong>非阻塞轮询 ≈ 进程等待 + <code>WNOHANG</code> 参数。</strong></li><li>是进程等待的一种实现方式，<strong>可以避免父进程“卡死”在等待中。</strong></li><li>适合场景：父进程还有其他任务要处理、需要同时监控多个子进程、构造后台守护程序等。</li></ul><hr><p>这样说难以理解，我们用一个示例来帮助理解：假如你是快递员，你今天安排了送货任务，但你同时还在等一个客户签收你的包裹。现在有两种做法：</p><h5 id="场景一：阻塞等待（wait）"><a href="#场景一：阻塞等待（wait）" class="headerlink" title="场景一：阻塞等待（wait）"></a>场景一：阻塞等待（wait）</h5><p>你在客户门口等着他开门签字，<strong>你哪儿也不去</strong>，什么都不干，就在那儿等。就是 <code>wait()</code> 或 <code>waitpid(pid, NULL, 0)</code>。</p><ul><li><strong>优点</strong>：等到了就能马上处理。</li><li><strong>缺点</strong>：你被“卡住”了，浪费了等的这段时间。</li></ul><h5 id="场景二：非阻塞轮询（WNOHANG）"><a href="#场景二：非阻塞轮询（WNOHANG）" class="headerlink" title="场景二：非阻塞轮询（WNOHANG）"></a>场景二：非阻塞轮询（WNOHANG）</h5><p>你不一直站在门口，而是 <strong>每隔 10 分钟回来敲一次门</strong>，空闲的时候你还可以去送别的快递。就是 <code>waitpid(pid, &amp;status, WNOHANG)</code> + <code>sleep(1)</code>。</p><ul><li><strong>优点</strong>：你不会被“卡住”，还能干其他事。</li><li><strong>缺点</strong>：客户签收可能不能第一时间知道（需要“轮询”）。</li></ul><h5 id="场景三：阻塞轮询（极端示例）"><a href="#场景三：阻塞轮询（极端示例）" class="headerlink" title="场景三：阻塞轮询（极端示例）"></a>场景三：阻塞轮询（极端示例）</h5><p>你不停敲门、再敲门，一直不走，<strong>一直问：“你签了没？你签了没？”</strong> 程序中表现为没有 <code>sleep</code> 的非阻塞 <code>waitpid(pid, WNOHANG)</code> 死循环。</p><ul><li><strong>缺点</strong>：会让 CPU 疯狂运转（忙等待）。</li></ul><h5 id="术语与现实对应表"><a href="#术语与现实对应表" class="headerlink" title="术语与现实对应表"></a>术语与现实对应表</h5><table><thead><tr><th>系统术语</th><th>现实中的你</th></tr></thead><tbody><tr><td>阻塞等待</td><td>在门口站着等，不做别的事</td></tr><tr><td>非阻塞轮询</td><td>每隔一段时间回来问一次，期间干别的事</td></tr><tr><td>阻塞轮询</td><td>疯狂按门铃，问个不停，CPU 很累</td></tr><tr><td>进程等待</td><td>等子进程结束，获取退出状态</td></tr></tbody></table><hr><h4 id="2-联系总结（术语图谱）"><a href="#2-联系总结（术语图谱）" class="headerlink" title="2. 联系总结（术语图谱）"></a>2. 联系总结（术语图谱）</h4><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250414230218765.png" alt="image-20250414230218594"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">               wait/waitpid</span><br><span class="line">               ┌────────────┐</span><br><span class="line">               │ 进程等待机制│</span><br><span class="line">               └────┬───────┘</span><br><span class="line">                    │</span><br><span class="line">      ┌─────────────┴────────────┐</span><br><span class="line">      │                          │</span><br><span class="line">┌─────▼─────┐             ┌─────▼─────────┐</span><br><span class="line">│ 阻塞等待   │             │ 非阻塞轮询     │</span><br><span class="line">│ wait()    │             │ waitpid(pid, WNOHANG) │</span><br><span class="line">└────────────┘             └──────────────────────┘</span><br></pre></td></tr></table></figure><hr><h4 id="3-我该怎么选？怎么使用？"><a href="#3-我该怎么选？怎么使用？" class="headerlink" title="3. 我该怎么选？怎么使用？"></a>3. 我该怎么选？怎么使用？</h4><table><thead><tr><th>场景</th><th>推荐方法</th><th>原因</th></tr></thead><tbody><tr><td>父进程只等子进程结束，没别的事干</td><td>阻塞等待 (<code>wait</code>)</td><td>简单、直接、不会浪费资源</td></tr><tr><td>父进程还有其他重要任务</td><td>非阻塞轮询 (<code>waitpid + WNOHANG</code>)</td><td>不中断其他逻辑，更灵活</td></tr><tr><td>你同时要监控多个子进程</td><td>非阻塞轮询</td><td>可以处理多个子进程，适合服务端&#x2F;守护程序</td></tr><tr><td>写简单的练习题&#x2F;实验代码</td><td>阻塞等待即可</td><td>写起来方便，看得懂</td></tr></tbody></table><p><strong>实验目的：</strong></p><ul><li>学会使用非阻塞轮询等待子进程结束。</li><li>理解如何在等待子进程的同时处理其他任务。</li><li>掌握如何通过 <code>WNOHANG</code> 选项实现非阻塞等待。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>)                       <span class="comment">// 子进程</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;子进程开始运行...\n&quot;</span>);</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">5</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;子进程即将退出\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>                                <span class="comment">// 父进程：非阻塞方式轮询子进程状态</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> status;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">pid_t</span> result = <span class="built_in">waitpid</span>(pid, &amp;status, WNOHANG);      <span class="comment">// 非阻塞调用</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (result == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 子进程还未退出</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;父进程：子进程还在运行...\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (result == pid)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 子进程已经退出</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">WIFEXITED</span>(status))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;父进程：子进程正常退出，退出码为 %d\n&quot;</span>, <span class="built_in">WEXITSTATUS</span>(status));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">perror</span>(<span class="string">&quot;waitpid error&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">sleep</span>(<span class="number">1</span>);                    <span class="comment">// 轮询间隔</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>实验示例结果：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">父进程：子进程还在运行...</span><br><span class="line">父进程：子进程还在运行...</span><br><span class="line">...</span><br><span class="line">子进程开始运行...</span><br><span class="line">子进程即将退出</span><br><span class="line">父进程：子进程正常退出，退出码为 0</span><br></pre></td></tr></table></figure><h4 id="4-小结一句话"><a href="#4-小结一句话" class="headerlink" title="4. 小结一句话"></a>4. 小结一句话</h4><blockquote><p>  <strong>非阻塞轮询是一种“智能等待”方式，让父进程在等待子进程的同时，还能处理其他任务，是并发编程的常见技巧。</strong></p></blockquote><hr><h3 id="5-总结记忆点"><a href="#5-总结记忆点" class="headerlink" title="5. 总结记忆点"></a>5. 总结记忆点</h3><table><thead><tr><th>内容</th><th>说明</th></tr></thead><tbody><tr><td><strong>为什么等待</strong></td><td>防止僵尸进程，释放系统资源，获取子进程退出信息，确保系统稳定性和资源高效利用。</td></tr><tr><td><strong>常用函数</strong></td><td><code>wait()</code>：阻塞等待任意子进程结束；<code>waitpid()</code>：灵活等待指定子进程，支持非阻塞模式。</td></tr><tr><td><strong>状态解析</strong></td><td>使用宏函数 <code>WIFEXITED()</code> 判断子进程是否正常退出，<code>WEXITSTATUS()</code> 获取退出码。</td></tr><tr><td><strong>非阻塞轮询</strong></td><td>适用于父进程需要同时处理其他任务或监控多个子进程的场景，通过 <code>waitpid()</code> 配合 <code>WNOHANG</code> 实现。</td></tr><tr><td><strong>推荐写法</strong></td><td>常用 <code>waitpid(pid, &amp;status, 0)</code>，安全灵活，适合大多数场景。</td></tr><tr><td><strong>注意事项</strong></td><td>父进程必须回收子进程资源，否则会导致僵尸进程，长期不回收会耗尽系统资源。</td></tr><tr><td><strong>适用场景</strong></td><td>简单程序使用阻塞等待，复杂程序或需要并发处理时使用非阻塞轮询。</td></tr></tbody></table><p><strong>实战技巧</strong></p><ol><li><strong>调试技巧</strong>：在调试时，若发现僵尸进程，检查父进程是否正确调用了 <code>wait()</code> 或 <code>waitpid()</code>。</li><li><strong>性能优化</strong>：在高并发场景下，使用非阻塞轮询避免父进程被长时间阻塞，提高系统响应速度。</li><li><strong>代码健壮性</strong>：始终检查 <code>wait()</code> 和 <code>waitpid()</code> 的返回值，处理可能的错误情况。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 进程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>017 进程控制 —— 终止进程</title>
      <link href="/posts/59037.html"/>
      <url>/posts/59037.html</url>
      
        <content type="html"><![CDATA[<h2 id="进程控制-——-终止进程"><a href="#进程控制-——-终止进程" class="headerlink" title="进程控制 —— 终止进程"></a>进程控制 —— 终止进程</h2><h3 id="一、进程退出场景"><a href="#一、进程退出场景" class="headerlink" title="一、进程退出场景"></a>一、进程退出场景</h3><p>从我们的视角来看进程终止的场景一般就是以下三种：</p><ol><li>代码运行完毕，结果正确（一般不关心）。</li><li>代码运行完毕，结果不正确。</li><li>代码异常终止。</li></ol><p>但是进程也可能因多种原因终止，比如：</p><table><thead><tr><th><strong>场景</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>正常完成任务</strong></td><td>程序执行完所有代码逻辑后退出</td></tr><tr><td><strong>异常错误终止</strong></td><td>遇到不可恢复的错误（如段错误、除零错误）</td></tr><tr><td><strong>主动终止</strong></td><td>调用退出函数（<code>exit()</code>&#x2F;<code>_exit()</code>）或通过 <code>return</code> 退出</td></tr><tr><td><strong>被动终止</strong></td><td>收到终止信号（如 <code>SIGKILL</code>、<code>SIGTERM</code>）</td></tr><tr><td><strong>被父进程杀死</strong></td><td>父进程调用 <code>kill()</code> 函数发送信号，使子进程退出。</td></tr></tbody></table><p>看进程终止的角度、进程终止的原因等不同方面来解释进程的终止，虽然说法上不同，但也大同小异，我们只需要记住一点：</p><blockquote><p>  所有进程的退出方式都可以归为两大类：<strong>正常退出</strong> 和 <strong>异常退出</strong>，而主动或被动，是从行为发起方角度来分的。<strong>进程出现异常，本质是我们的进程收到了对应的信号！！</strong></p></blockquote><hr><h3 id="二、进程的退出码"><a href="#二、进程的退出码" class="headerlink" title="二、进程的退出码"></a>二、进程的退出码</h3><blockquote><p>我们都知道 <code>main</code> 函数是代码的入口，但实际上 <code>main</code> 函数只是用户级别代码的入口，<code>main</code> 函数也是被其他函数调用的，也就是说 <code>main</code> 函数是间接性被操作系统所调用的。</p><p>既然 <code>main</code> 函数是间接性被操作系统所调用的，那么当 <code>main</code> 函数调用结束后就应该给操作系统返回相应的退出信息，而这个所谓的退出信息就是以退出码的形式作为 <code>main</code> 函数的返回值返回，我们一般以 <code>0</code> 表示代码成功执行完毕，以非 <code>0</code> 表示代码执行过程中出现错误，这就是为什么我们都在 <code>main</code> 函数的最后返回 <code>0</code> 的原因。</p></blockquote><h4 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h4><p>进程退出码：是进程终止时向 <strong>操作系统</strong> 返回的一个 <strong>整数值</strong>，用于标识该进程是否 <strong>成功完成任务</strong> 或 <strong>出现了错误</strong>。</p><table><thead><tr><th align="center">退出码</th><th>含义说明</th></tr></thead><tbody><tr><td align="center"><code>0</code></td><td>表示进程 <strong>成功</strong> 退出（Success）</td></tr><tr><td align="center"><code>1~255</code></td><td>表示进程 <strong>异常</strong> 或 <strong>错误</strong> 退出（Failure）</td></tr><tr><td align="center">其它值</td><td>可以由程序自定义（常用于表示不同类型的错误）</td></tr></tbody></table><p>当我们的代码运行起来就变成了进程，当进程结束后 <code>main</code> 函数的返回值实际上就是该进程的进程退出码，我们可以使用 <code>echo $?</code> 命令查看最近一次进程退出的退出码信息。</p><p>例如，对于下面这个简单的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello, World!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码运行结束后，我们可以使用 <code>echo $?</code> 查看该进程的进程退出码：</p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250406133329633.png" alt="image-20250406133322513"></p><p>这里进程退出码显示 <code>0</code> 便是可以确定程序顺利执行完毕了。</p><p>实际上 <code>Linux</code> 中的 <code>ls</code>、<code>pwd</code> 等命令都是可执行程序，使用这些命令后我们也可以查看其对应的退出码。</p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250406133818832.png" alt="image-20250406133818700"></p><p><strong>注意：</strong> 命令执行错误后，其退出码就是非 <code>0</code> 的数字，该数字具体代表某一错误信息。 退出码都有对应的字符串含义，帮助用户确认执行失败的原因，而这些退出码具体代表什么含义是人为规定的，不同环境下相同的退出码的字符串含义可能不同。</p><h4 id="2-为什么以-0-表示代码执行成功，以-非0-表示代码执行错误？"><a href="#2-为什么以-0-表示代码执行成功，以-非0-表示代码执行错误？" class="headerlink" title="2. 为什么以 0 表示代码执行成功，以 非0 表示代码执行错误？"></a>2. 为什么以 <code>0</code> 表示代码执行成功，以 <code>非0</code> 表示代码执行错误？</h4><p>因为代码执行成功只有一种情况，成功了就是成功了，而代码执行错误却有多种原因，例如内存空间不足、非法访问以及栈溢出等等，我们就可以用这些 <code>非0</code> 的数字分别表示代码执行错误的原因。</p><h4 id="3-errno-常量和-strerror-函数（牵扯信号，初步了解）"><a href="#3-errno-常量和-strerror-函数（牵扯信号，初步了解）" class="headerlink" title="3. errno 常量和 strerror 函数（牵扯信号，初步了解）"></a>3. <code>errno</code> 常量和 <code>strerror</code> 函数（牵扯信号，初步了解）</h4><blockquote><p><strong>查看信号对应的退出码</strong></p><p>信号终止的进程退出码为 <code>128 + 信号编号</code>。可通过命令 <code>kill -l</code>（列出所有信号及其编号）查看信号列表：</p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250406153812390.png" alt="image-20250406153812273"></p></blockquote><p>上面我们提到我们可以通过不同的退出码来代表不同的错误信息，那么不同的退出码究竟各自代表什么信息呢？我们可以通过 <code>strerror</code> 函数来查看, 比如我们来看一下退出码 <code>0</code> 到 <code>10</code> 所代表的信息：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">10</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d: %s\n&quot;</span>,i,strerror(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;                </span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250406140838426.png" alt="image-20250406140838340"></p><p><strong>进程在退出是会有退出码，我们可以通过 <code>echo</code> 来查看退出码，那我们如何获取呢？</strong></p><p>C&#x2F;C++中其实还定义了一个叫 <code>errno</code> 的常量来记录错误码，所以我们就可以将 <code>errno</code> 常量与 <code>strerror</code> 函数结合使用，用 <code>errno</code> 来记录进程的错误码，然后传给 <code>strerror</code> 函数得到错误信息，比如下面的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span>                                                                                                                                                                                           </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;errno.h&gt;</span>                                       <span class="comment">//注意要带好头文件</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span>* p = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="number">1000</span> * <span class="number">1000</span> * <span class="number">1000</span> * <span class="number">4</span>);    <span class="comment">//这个扩容肯定会出错的，因为扩容空间太大了</span></span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;mallo error, %d:%s\n&quot;</span>, errno, <span class="built_in">strerror</span>(errno));   <span class="comment">//errno会记录错误码，将它传到strerror中就可以得到错误信息</span></span><br><span class="line">        ret = errno;                                    <span class="comment">//将错误码作为返回值返回，从而让父进程得到返回信息</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;malloc success\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250406141949419.png" alt="image-20250406141949307"></p><h3 id="三、进程常见退出方法"><a href="#三、进程常见退出方法" class="headerlink" title="三、进程常见退出方法"></a>三、进程常见退出方法</h3><h4 id="1-exit-函数"><a href="#1-exit-函数" class="headerlink" title="1. exit() 函数"></a>1. <code>exit()</code> 函数</h4><ul><li><p><strong>头文件</strong>：<code>#include &lt;stdlib.h&gt;</code></p></li><li><p><strong>行为</strong>：</p><ul><li>执行标准清理操作（刷新缓冲区、关闭文件描述符等）。</li><li>调用通过 <code>atexit()</code> 注册的函数。</li><li>返回状态码给父进程（通过 <code>wait()</code> 获取）。</li></ul></li><li><p><strong>示例</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">3</span>);  <span class="comment">// 设置退出码为 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-exit-函数"><a href="#2-exit-函数" class="headerlink" title="2. _exit() 函数"></a>2. <code>_exit()</code> 函数</h4><ul><li><p><strong>头文件</strong>：<code>#include &lt;unistd.h&gt;</code>（函数：<code>void _exit(int status);</code>）</p></li><li><p><strong>行为</strong>：</p><ul><li><code>status</code> 定义了进程的终止状态，父进程通过 <code>wait</code> 来获取该值，虽然 <code>status</code> 是 <code>int</code>，但是仅有低 <code>8</code> 位可以被父进程所用。所以 <code>exit(-1)</code> 时，在终端执行 <code>echo $?</code> 发现返回值是 <code>255</code>。</li><li><strong>立即终止</strong> 进程（系统调用级别的退出），不执行任何清理（缓冲区不刷新、<code>atexit()</code> 函数不调用）。</li><li>适用于子进程在 <code>fork()</code> 后需要快速退出的场景。</li></ul></li><li><p><strong>示例</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello, World!\n&quot;</span>);</span><br><span class="line">    _exit(<span class="number">0</span>);<span class="comment">// 立刻退出，状态码为0</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;这一行将不会被打印。.\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-return-退出"><a href="#3-return-退出" class="headerlink" title="3. return 退出"></a>3. <code>return</code> 退出</h4><ul><li><p><strong>行为</strong>：</p><ul><li>在 <code>main()</code> 函数中，<code>return</code> 等效于调用 <code>exit()</code>。</li><li>在其他函数中，<code>return</code> 仅退出当前函数。</li></ul></li><li><p><strong>示例</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span>;  <span class="comment">// 等效于 exit(42)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><blockquote><p>  [!WARNING]</p><p>  <span style="color:#CC0000;"><strong>警告：下面的程序会源源不断的创建僵尸进程，直至将系统资源耗尽！请谨慎使用！实测：在虚拟机中运行 20 秒不到，系统直接卡死。</strong></span></p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (fork() == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            _exit(<span class="number">0</span>); <span class="comment">// 子进程立即退出，成为僵尸进程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><hr><h3 id="三、关键区别对比"><a href="#三、关键区别对比" class="headerlink" title="三、关键区别对比"></a>三、关键区别对比</h3><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250406135753592.png" alt="image-20250406135753463"></p><table><thead><tr><th><strong>方法</strong></th><th><strong>是否刷新缓冲区</strong></th><th><strong>是否调用 <code>atexit()</code></strong></th><th><strong>适用场景</strong></th></tr></thead><tbody><tr><td><code>exit()</code></td><td>✅ 是</td><td>✅ 是</td><td>正常退出，需清理资源</td></tr><tr><td><code>_exit()</code></td><td>❌ 否</td><td>❌ 否</td><td>子进程快速退出或错误紧急终止</td></tr><tr><td><code>return</code></td><td>✅ 是（仅 <code>main</code>）</td><td>✅ 是（仅 <code>main</code>）</td><td><code>main()</code> 函数中的简洁退出方式</td></tr></tbody></table><h3 id="四、代码示例分析"><a href="#四、代码示例分析" class="headerlink" title="四、代码示例分析"></a>四、代码示例分析</h3><h4 id="1-父子进程退出行为差异"><a href="#1-父子进程退出行为差异" class="headerlink" title="1. 父子进程退出行为差异"></a>1. 父子进程退出行为差异</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Start (PID:%d)\n&quot;</span>, getpid());   <span class="comment">// 注意：无换行，缓冲区未刷新</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fork() == <span class="number">0</span>)                        <span class="comment">// 子进程</span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Child exiting\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);                            <span class="comment">// 刷新缓冲区并退出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>                                    <span class="comment">// 父进程</span></span><br><span class="line">    &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Parent exiting\n&quot;</span>);</span><br><span class="line">        _exit(<span class="number">0</span>);                           <span class="comment">// 不刷新缓冲区</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出结果</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 由于 printf 未刷新缓冲区，子进程继承了未刷新的缓冲区内容，导致重复输出:</span></span><br><span class="line">Start (PID:123)</span><br><span class="line">Child exiting</span><br><span class="line">Start (PID:123)  // 父进程的缓冲区未刷新，被子进程继承后输出</span><br><span class="line">Parent exiting</span><br></pre></td></tr></table></figure><h4 id="2-atexit-注册清理函数"><a href="#2-atexit-注册清理函数" class="headerlink" title="2. atexit() 注册清理函数"></a>2. <code>atexit()</code> 注册清理函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">cleanup</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Cleanup done!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    atexit(cleanup);  <span class="comment">// 注册清理函数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Main running\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);          <span class="comment">// 会调用 cleanup()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Main running</span><br><span class="line">Cleanup done!</span><br></pre></td></tr></table></figure><hr><h3 id="五、进程终止后的状态"><a href="#五、进程终止后的状态" class="headerlink" title="五、进程终止后的状态"></a>五、进程终止后的状态</h3><ol><li><p><strong>僵尸进程（Zombie）</strong>：</p><ul><li>进程已终止，但父进程未通过 <code>wait()</code> 回收其资源。</li><li>解决方案：<ul><li>父进程调用 <code>wait()</code> 或 <code>waitpid()</code>。</li><li>忽略 <code>SIGCHLD</code> 信号：<code>signal(SIGCHLD, SIG_IGN)</code>，<strong>注意：在某些系统中，忽略 <code>SIGCHLD</code> 会自动回收子进程，但并非所有系统都支持这一行为！</strong></li></ul></li></ul></li><li><p><strong>孤儿进程</strong>：</p><ul><li>父进程先退出，子进程被 <code>init</code>（PID &#x3D; 1）接管。</li><li>无害，<code>init</code> 会自动回收孤儿进程。</li></ul></li></ol><hr><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li><strong><code>exit()</code>（优先使用 ）</strong>：安全退出，适合大多数场景，确保资源正确释放。</li><li><strong><code>_exit()</code></strong>：紧急退出，跳过清理。子进程慎用，除非明确需要跳过清理。</li><li><strong><code>return</code></strong>：仅在 <code>main()</code> 中等效于 <code>exit()</code>。</li><li><strong>进程管理</strong>：正确处理父子进程关系，避免资源泄漏。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 进程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 Git 从 HTTPS 切换至 SSH</title>
      <link href="/posts/59939.html"/>
      <url>/posts/59939.html</url>
      
        <content type="html"><![CDATA[<h1 id="使用-Git-从-HTTPS-切换至-SSH"><a href="#使用-Git-从-HTTPS-切换至-SSH" class="headerlink" title="使用 Git 从 HTTPS 切换至 SSH"></a>使用 Git 从 HTTPS 切换至 SSH</h1><p>起因是我在 Linux 中使用 <code>git push</code> <strong>推送经常卡住或失败</strong>，真的很烦，于是选择 <strong>切换成 SSH</strong> ，可以提高稳定性和体验，比较适合在 Linux 系统开发环境中长期使用。当然本文的方法也同样适用于 Windows。</p><hr><h2 id="1-确认是否已生成-SSH-密钥对"><a href="#1-确认是否已生成-SSH-密钥对" class="headerlink" title="1. 确认是否已生成 SSH 密钥对"></a>1. 确认是否已生成 SSH 密钥对</h2><p>先检查是否已有 <code>.ssh/id_rsa</code> 文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> ~/.ssh</span><br></pre></td></tr></table></figure><p>如果看到了 <code>id_rsa</code> 和 <code>id_rsa.pub</code> 就说明已经有了密钥对。如果没有，就执行下面的命令生成：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096 -C <span class="string">&quot;你的邮箱&quot;</span></span><br></pre></td></tr></table></figure><p>一路回车即可生成（个人使用，建议不设密码短语，会方便些）。</p><hr><h2 id="2-将-SSH-公钥添加到远程仓库平台（如-GitHub-Gitee）"><a href="#2-将-SSH-公钥添加到远程仓库平台（如-GitHub-Gitee）" class="headerlink" title="2. 将 SSH 公钥添加到远程仓库平台（如 GitHub &#x2F; Gitee）"></a>2. 将 SSH 公钥添加到远程仓库平台（如 GitHub &#x2F; Gitee）</h2><h3 id="1-复制公钥内容"><a href="#1-复制公钥内容" class="headerlink" title="1. 复制公钥内容"></a>1. 复制公钥内容</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure><p>复制输出的整段文本（以 <code>ssh-rsa</code> 开头，以邮箱结尾）。对应 Windows 实际路径为 <code>C:\Users\你的用户名\.ssh\</code>。</p><h3 id="2-添加到远程平台"><a href="#2-添加到远程平台" class="headerlink" title="2. 添加到远程平台"></a>2. 添加到远程平台</h3><h4 id="1-GitHub："><a href="#1-GitHub：" class="headerlink" title="1. GitHub："></a>1. GitHub：</h4><ul><li>登录 GitHub。</li><li>点击头像 → <code>Settings</code> → <code>SSH and GPG keys</code>。</li><li>点 <code>New SSH key</code>，粘贴公钥，命名为“centos 7.6”等，命名自定义就好。</li></ul><h4 id="2-Gitee："><a href="#2-Gitee：" class="headerlink" title="2. Gitee："></a>2. Gitee：</h4><ul><li>登录 Gitee。</li><li>用户头像 → <code>设置</code> → <code>SSH公钥</code>。</li><li>粘贴进去即可。</li></ul><hr><h2 id="3-切换仓库的远程地址从-HTTPS-➜-SSH"><a href="#3-切换仓库的远程地址从-HTTPS-➜-SSH" class="headerlink" title="3. 切换仓库的远程地址从 HTTPS ➜ SSH"></a>3. 切换仓库的远程地址从 HTTPS ➜ SSH</h2><p><strong>切换命令如下（在项目根目录下执行）：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git remote -v                          <span class="comment"># 查看当前远程仓库地址</span></span><br><span class="line">git remote set-url origin git@github.com:yourname/yourrepo.git<span class="comment"># 这个在 github/gitee 对应仓库 → 代码/克隆/下载 → SSH，点击复制</span></span><br><span class="line">git remote -v                          <span class="comment"># 再次查看，确保已修改成功</span></span><br></pre></td></tr></table></figure><hr><h2 id="4-测试-SSH-是否连接成功"><a href="#4-测试-SSH-是否连接成功" class="headerlink" title="4. 测试 SSH 是否连接成功"></a>4. 测试 SSH 是否连接成功</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><p>第一次会提示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">The authenticity of host <span class="string">&#x27;github.com (IP)&#x27;</span> can<span class="string">&#x27;t be established...</span></span><br><span class="line"><span class="string">Are you sure you want to continue connecting (yes/no)?</span></span><br></pre></td></tr></table></figure><p>输入 <code>yes</code> 后，如果成功，会看到：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hi yourname! You<span class="string">&#x27;ve successfully authenticated, but GitHub does not provide shell access.</span></span><br></pre></td></tr></table></figure><blockquote><p>这里可能存在一个 <code>warning</code>，大概意思是说 shell 中不能使用，不用管，这就已经配置好了！</p></blockquote><h2 id="5-配置完成，一键三连！"><a href="#5-配置完成，一键三连！" class="headerlink" title="5. 配置完成，一键三连！"></a>5. 配置完成，一键三连！</h2><hr><h2 id="6-解决-GitHub-SSH-连接被屏蔽：配置-443-端口"><a href="#6-解决-GitHub-SSH-连接被屏蔽：配置-443-端口" class="headerlink" title="6. 解决 GitHub SSH 连接被屏蔽：配置 443 端口"></a>6. 解决 GitHub SSH 连接被屏蔽：配置 443 端口</h2><p>没错，又是我，经过 SSH 一段长期稳定后，它又又又又出问题了，于是就诞生了下面的内容（此方法仅适用于 <strong>GitHub</strong>，Gitee 等平台需不同配置）：</p><blockquote><p><strong>22 端口（默认的 SSH 方式）</strong></p><ol><li><strong>优点</strong></li></ol><ul><li>是 GitHub 官方最原生的 SSH 接口，最直接，少一层“伪装”。</li><li>如果网络环境宽松（家里宽带、海外服务器），几乎是最快最稳的。</li></ul><ol start="2"><li><strong>缺点</strong></li></ol><ul><li>很多公司 &#x2F; 校园 &#x2F; 国内云服务器，会屏蔽 22 端口（因为它是典型的 SSH 管理端口，容易被滥用）。</li><li>一旦被封，直接 <code>Connection timed out</code>，完全没法用。</li></ul><hr><p><strong>443 端口（备用 SSH 方式）</strong></p><ol><li><strong>优点</strong></li></ol><ul><li>443 是 HTTPS 的标准端口，几乎任何网络都必须放行（否则连网页都上不了）。</li><li>GitHub 把 SSH 流量伪装成走 443，看起来像 HTTPS，因此能穿透大部分防火墙和限制。</li><li>对于国内网络环境（尤其是云主机 &#x2F; 校园网 &#x2F; 公共 WiFi），稳定性往往比 22 更好。</li></ul><ol start="2"><li><strong>缺点</strong></li></ol><ul><li>在极少数情况下，某些 DPI（深度包检测）会识别“这不是 HTTPS 流量”然后丢弃，但这种情况比较罕见。</li><li>多了一层转发，理论上延迟可能略高，但对推送&#x2F;拉取代码来说几乎无感。</li></ul><hr><p><strong>总结：</strong></p><ul><li><strong>22 端口</strong>：原生 SSH，速度可能更快，但容易被封。👉 如果在家宽带上，22 可能稳定；但一旦换环境（比如公司 VPN、云主机），22 就可能挂掉。</li><li><strong>443 端口</strong>：稳定性最高，几乎所有网络环境都可用。👉 从长期和通用性来看，<strong>SSH 走 443 更稳定</strong>，因为 443 基本不会被封。443 和 22 性能差异极小，日常使用无感。</li></ul></blockquote><p>在国内或公司网络环境下，Git SSH 默认 22 端口有时会被屏蔽，导致推送失败（<code>Connection timed out</code>）。解决办法是切换到 GitHub 提供的备用入口： <strong>443 端口 SSH</strong>。下面介绍操作步骤。</p><h3 id="1-查看当前远程仓库地址"><a href="#1-查看当前远程仓库地址" class="headerlink" title="1. 查看当前远程仓库地址"></a>1. 查看当前远程仓库地址</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure><p>输出类似：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">origin  git@github.com:用户名/仓库名.git (fetch)</span><br><span class="line">origin  git@github.com:用户名/仓库名.git (push)</span><br></pre></td></tr></table></figure><p>默认都是 22 端口的 SSH。</p><h3 id="2-切换到-SSH-443-端口"><a href="#2-切换到-SSH-443-端口" class="headerlink" title="2. 切换到 SSH 443 端口"></a>2. 切换到 SSH 443 端口</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote set-url origin ssh://git@ssh.github.com:443/用户名/仓库名.git</span><br></pre></td></tr></table></figure><p><strong>注意：<code>ssh.github.com</code> + <code>:443</code> 是 GitHub 提供的备用端口，<code>/用户名/仓库名.git</code> 替换成你的仓库路径。</strong></p><h3 id="3-第一次连接需要确认主机指纹（验证）"><a href="#3-第一次连接需要确认主机指纹（验证）" class="headerlink" title="3. 第一次连接需要确认主机指纹（验证）"></a>3. 第一次连接需要确认主机指纹（验证）</h3><p>测试连接（任意一个即可，都执行也行）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br><span class="line">ssh -T -p 443 git@ssh.github.com</span><br></pre></td></tr></table></figure><p>会提示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The authenticity of host <span class="string">&#x27;[ssh.github.com]:443 ...&#x27;</span> can<span class="string">&#x27;t be established.</span></span><br><span class="line"><span class="string">ECDSA key fingerprint is SHA256:...</span></span><br><span class="line"><span class="string">Are you sure you want to continue connecting (yes/no)?</span></span><br></pre></td></tr></table></figure><p>输入完整的 <code>yes</code> 并回车，SSH 会把主机写入 <code>~/.ssh/known_hosts</code>，以后就不再提示。成功后应看到：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hi &lt;你的用户名&gt;! You<span class="string">&#x27;ve successfully authenticated, but GitHub does not provide shell access.</span></span><br></pre></td></tr></table></figure><p>🎉 表示配置成功，现在你可以正常执行 <code>git push</code> 了！</p><h3 id="4-推送代码"><a href="#4-推送代码" class="headerlink" title="4. 推送代码"></a>4. 推送代码</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push</span><br></pre></td></tr></table></figure><p>现在 SSH 走 443 端口，推送应该稳定可用。适合任何仓库、任何网络环境。</p><hr><h3 id="5-恢复默认-22-端口（可选）"><a href="#5-恢复默认-22-端口（可选）" class="headerlink" title="5. 恢复默认 22 端口（可选）"></a>5. 恢复默认 22 端口（可选）</h3><p>如果网络环境允许，想还原默认 SSH：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote set-url origin git@github.com:用户名/仓库名.git</span><br></pre></td></tr></table></figure><p>再推送就会回到原来的 22 端口方式。</p><hr><h2 id="7-修改本地-SSH-配置文件（另一种方法）"><a href="#7-修改本地-SSH-配置文件（另一种方法）" class="headerlink" title="7. 修改本地 SSH 配置文件（另一种方法）"></a>7. 修改本地 SSH 配置文件（另一种方法）</h2><p>如果上面的方法无效，可尝试这里的方法：通过修改本地 SSH 配置文件，让所有对 <code>github.com</code> 的 SSH 请求自动转发到 <code>ssh.github.com:443</code>。</p><h3 id="1-配置文件路径"><a href="#1-配置文件路径" class="headerlink" title="1. 配置文件路径"></a>1. 配置文件路径</h3><table><thead><tr><th>平台</th><th>路径</th></tr></thead><tbody><tr><td>Linux &#x2F; macOS</td><td><code>~/.ssh/config</code></td></tr><tr><td>Windows（Git Bash）</td><td><code>C:\Users\&lt;用户名&gt;\.ssh\config</code></td></tr></tbody></table><blockquote><p>  注意：<code>.ssh</code> 目录和 <code>config</code> 文件权限需设置正确，避免 SSH 拒绝加载。 </p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> 700 ~/.ssh</span><br><span class="line"><span class="built_in">chmod</span> 600 ~/.ssh/config</span><br></pre></td></tr></table></figure><h3 id="2-添加配置内容"><a href="#2-添加配置内容" class="headerlink" title="2. 添加配置内容"></a>2. 添加配置内容</h3><blockquote><p>如果已有其他 Host 配置（如私有服务器 IP），<strong>不要删除或覆盖</strong>，只需 <strong>追加</strong> 即可。SSH 会按 Host 匹配规则自动选择。 </p></blockquote><p>打开或创建 <code>~/.ssh/config</code>，添加以下内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Host github.com</span><br><span class="line">  HostName ssh.github.com</span><br><span class="line">  Port 443<span class="comment"># 可以直接改成 22 或者更简单地 直接删除整个 Host github.com 块，就等于 恢复默认行为:走 github.com: 22。</span></span><br><span class="line">  User git</span><br></pre></td></tr></table></figure><p><strong>说明</strong>：</p><ul><li><code>Host github.com</code>：匹配所有 <code>git@github.com:xxx/yyy.git</code> 的请求。</li><li><code>HostName ssh.github.com</code>：GitHub 提供的 SSH over HTTPS 网关。</li><li><code>Port 443</code>：使用 HTTPS 常用端口，绕过 22 端口封锁。</li><li><code>User git</code>：SSH 协议要求用户为 <code>git</code>。</li></ul><blockquote><p><strong>后面的步骤就和上面一样了：验证和推送。</strong></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>016 进程控制 —— 进程创建</title>
      <link href="/posts/9600.html"/>
      <url>/posts/9600.html</url>
      
        <content type="html"><![CDATA[<h2 id="进程控制-——-进程创建"><a href="#进程控制-——-进程创建" class="headerlink" title="进程控制 —— 进程创建"></a>进程控制 —— 进程创建</h2><h3 id="一、fork-函数基础"><a href="#一、fork-函数基础" class="headerlink" title="一、fork() 函数基础"></a>一、<code>fork()</code> 函数基础</h3><h4 id="1-fork-的作用"><a href="#1-fork-的作用" class="headerlink" title="1. fork() 的作用"></a>1. <code>fork()</code> 的作用</h4><ul><li><strong>创建子进程</strong>：通过复制父进程的地址空间生成一个新进程。</li><li><strong>调用一次，返回两次</strong>：<ul><li>父进程返回子进程的 PID（即 &gt; 0 or 正数）。</li><li>子进程返回 0。</li><li>失败返回 -1。</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">pid_t</span> <span class="title">fork</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="2-写时拷贝（Copy-On-Write-COW）"><a href="#2-写时拷贝（Copy-On-Write-COW）" class="headerlink" title="2. 写时拷贝（Copy-On-Write, COW）"></a>2. 写时拷贝（Copy-On-Write, COW）</h4><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250405192403856.png" alt="image-20250405192403735"></p><ul><li><p><strong>机制</strong>：<code>fork</code> 时不会立刻复制父进程的所有内存页。<code>fork()</code> 后，父子进程 <strong>共享物理内存</strong>（共享内存页（只读）），直到一方尝试修改数据时，内核才复制该内存页。</p><ul><li>修改时触发“页错误”</li><li>操作系统才会为该进程分配新的物理页，完成“真正拷贝”</li></ul></li><li><p><strong>优点</strong>：</p><ul><li><strong>提升效率：</strong> 减少 <code>fork()</code> 的开销（避免立即复制全部内存）。</li><li><strong>节省内存开销：</strong> 节省物理内存（共享未修改的页）。</li></ul></li></ul><blockquote><p>  [!NOTE]</p><p>  通常，父子代码共享，父子再不写入时，数据也是共享的，当任意一方试图写入，便以写时拷贝的方式各自一份副本。具体见下图：</p><p>  <img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250714185539160.png" alt="image-20250714185539037"></p></blockquote><hr><h3 id="二、代码示例"><a href="#二、代码示例" class="headerlink" title="二、代码示例"></a>二、代码示例</h3><h4 id="示例-1：基础-fork-使用"><a href="#示例-1：基础-fork-使用" class="headerlink" title="示例 1：基础 fork() 使用"></a>示例 1：基础 <code>fork()</code> 使用</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 5</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pid:%d before!\n&quot;</span>, getpid());  <span class="comment">// fork 调用前，打印一次</span></span><br><span class="line">    fork();                                <span class="comment">// 创建子进程</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pid:%d after!\n&quot;</span>, getpid());   <span class="comment">// 父子进程都会执行这一句</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果</strong>：</p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/image-20250405184713829.png" alt="image-20250405184713829"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">说明：</span><br><span class="line">pid:31612 before!      <span class="comment"># 父进程打印</span></span><br><span class="line">pid:31612 after!       <span class="comment"># 父进程打印</span></span><br><span class="line">pid:31613 after!       <span class="comment"># 子进程打印（PID不同）</span></span><br></pre></td></tr></table></figure><p><strong>关键点</strong>：</p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250714185622318.png" alt="image-20250714185622229"></p><ul><li><code>fork()</code> 前的代码仅父进程执行，之后的代码父子进程均执行。</li><li>父子进程的 <code>printf</code> 输出顺序不确定，由调度器决定。</li></ul><hr><h4 id="示例-2：循环创建多个子进程"><a href="#示例-2：循环创建多个子进程" class="headerlink" title="示例 2：循环创建多个子进程"></a>示例 2：循环创建多个子进程</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span>              <span class="comment">// 定义 pid_t 类型</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>                 <span class="comment">// 定义 fork() 函数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 5</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">runChild</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">while</span> (cnt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我是子进程：%d，ppid:%d\n&quot;</span>, getpid(), getppid());</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        cnt--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;    <span class="comment">// 避免 C99 不支持报错</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">pid_t</span> pid = fork();<span class="comment">// 创建子进程</span></span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>)               <span class="comment">// 子进程进入</span></span><br><span class="line">        &#123;</span><br><span class="line">            runChild();             <span class="comment">// 子进程执行任务</span></span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);                <span class="comment">// 子进程退出，防止继续 fork</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pid &lt; <span class="number">0</span>)           <span class="comment">// fork失败</span></span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 父进程继续循环</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">我是子进程：1761, ppid:1760</span><br><span class="line">我是子进程：1762, ppid:1760</span><br><span class="line">我是子进程：1763, ppid:1760 </span><br><span class="line">我是子进程：1764, ppid:1760</span><br><span class="line">我是子进程：1765, ppid:1760</span><br><span class="line">(每个子进程完成10次输出后)</span><br></pre></td></tr></table></figure><p><strong>关键点</strong>：</p><ol><li><strong>子进程立即退出循环</strong>：通过 <code>if (pid == 0)</code> 确保子进程执行 <code>runChild()</code> 后调用 <code>exit(0)</code>，避免子进程继续 <code>for</code> 循环。</li><li><strong>父进程管理子进程</strong>：父进程在循环中创建所有子进程后退出。但是父进程没有调用 <code>wait</code> 回收子进程，子进程结束后将变成僵尸进程。</li><li><strong>并发执行</strong>：所有子进程同时运行，输出顺序交错（由调度器决定）。</li></ol><hr><h3 id="三、fork-常见问题"><a href="#三、fork-常见问题" class="headerlink" title="三、fork() 常见问题"></a>三、<code>fork()</code> 常见问题</h3><h4 id="1-fork-失败的原因"><a href="#1-fork-失败的原因" class="headerlink" title="1. fork() 失败的原因"></a>1. <code>fork()</code> 失败的原因</h4><ul><li><strong>系统限制</strong>：进程数超过 <code>RLIMIT_NPROC</code> 限制。</li><li><strong>内存不足</strong>：无法复制页表或分配 PID。</li><li><strong>资源耗尽</strong>：如内核进程表满。</li></ul><p>如果 <code>fork()</code> 返回 <code>-1</code>，通常是以下原因：</p><table><thead><tr><th align="center">原因</th><th>描述</th></tr></thead><tbody><tr><td align="center">进程数超出限制</td><td>系统有最大进程数限制（<code>ulimit -u</code>）</td></tr><tr><td align="center">内存不足</td><td>无法分配页表或必要资源</td></tr><tr><td align="center">权限问题</td><td>某些系统限制普通用户创建大量进程</td></tr><tr><td align="center">系统负载过高</td><td>为了保护系统稳定性，内核可能拒绝 fork</td></tr></tbody></table><p>建议加上错误处理：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (pid &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">perror</span>(<span class="string">&quot;fork failed&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-避免子进程成为僵尸"><a href="#2-避免子进程成为僵尸" class="headerlink" title="2. 避免子进程成为僵尸"></a>2. 避免子进程成为僵尸</h4><ul><li>父进程需调用 <code>wait()</code> 或 <code>waitpid()</code> 回收子进程资源。</li><li>或忽略 <code>SIGCHLD</code> 信号：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">signal(SIGCHLD, SIG_IGN);  <span class="comment">// 自动回收子进程</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="3-父子进程共享的资源"><a href="#3-父子进程共享的资源" class="headerlink" title="3. 父子进程共享的资源"></a>3. 父子进程共享的资源</h4><ul><li><strong>共享</strong>：<ul><li>文件描述符（打开的文件）。</li><li>信号处理函数（但信号掩码独立）。</li></ul></li><li><strong>独立</strong>：<ul><li>内存数据（因 COW 机制）。</li><li>进程 ID、父进程 ID。</li></ul></li></ul><hr><h3 id="四、进阶用法"><a href="#四、进阶用法" class="headerlink" title="四、进阶用法"></a>四、进阶用法</h3><h4 id="1-父子进程分工"><a href="#1-父子进程分工" class="headerlink" title="1. 父子进程分工"></a>1. 父子进程分工</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pid_t</span> pid = fork();</span><br><span class="line"><span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    execvp(<span class="string">&quot;ls&quot;</span>, (<span class="type">char</span>* []) &#123; <span class="string">&quot;ls&quot;</span>, <span class="string">&quot;-l&quot;</span>, <span class="literal">NULL</span> &#125;);  <span class="comment">// 子进程执行任务</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    wait(<span class="literal">NULL</span>);                                     <span class="comment">// 父进程等待子进程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-链式创建进程"><a href="#2-链式创建进程" class="headerlink" title="2. 链式创建进程"></a>2. 链式创建进程</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (fork() == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Child %d\n&quot;</span>, i);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 进程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>015 程序地址空间入门</title>
      <link href="/posts/45500.html"/>
      <url>/posts/45500.html</url>
      
        <content type="html"><![CDATA[<h2 id="程序地址空间入门"><a href="#程序地址空间入门" class="headerlink" title="程序地址空间入门"></a>程序地址空间入门</h2><p>程序的 <strong>地址空间</strong> 是操作系统为每个程序分配的内存区域，它决定了程序如何访问存储在计算机内存中的数据。程序地址空间包括了多个部分，每一部分有不同的用途。通过合理管理地址空间，操作系统可以有效地进行内存分配和保护。</p><h3 id="1-地址空间的划分"><a href="#1-地址空间的划分" class="headerlink" title="1. 地址空间的划分"></a>1. 地址空间的划分</h3><p>程序的地址空间通常分为多个段，每个段具有不同的功能。这些段的划分通常是由操作系统定义的。下图是基于 <code>kernel 2.6.32</code> 和 <code>32位平台</code> 的典型空间布局图： </p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250323175946255.png" alt="image-20250323175946087"></p><p>然而，一个标准的程序地址空间布局图（32 位系统）包括：</p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250402122116601.png" alt="image-20250402122116475"></p><p>更详细点来说则是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">+------------------------+  &lt;-- <span class="number">0xC0000000</span>（内核空间起始，用户不可访问）  </span><br><span class="line">|        内核空间         |  </span><br><span class="line">+------------------------+  &lt;-- <span class="number">0xBFFFFFFF</span>（用户空间结束）  </span><br><span class="line">|        栈（Stack）      | ↓ 向低地址增长  </span><br><span class="line">|  - 主线程栈             |  </span><br><span class="line">+------------------------+  </span><br><span class="line">|  命令行参数与环境变量区  | ← 位于栈的顶部下方（高地址区域）  </span><br><span class="line">+------------------------+  </span><br><span class="line">|        保护页           | ← 防止栈溢出  </span><br><span class="line">+------------------------+  </span><br><span class="line">|      内存映射段         |  </span><br><span class="line">|  - 共享库（.so/.dll）   |  </span><br><span class="line">|  - 文件映射（mmap）     |  </span><br><span class="line">|  - 匿名映射（大块堆内存）|  </span><br><span class="line">|  - 线程栈（多线程时）    | ← 其他线程栈通过 mmap 分配在此区域  </span><br><span class="line">+------------------------+  </span><br><span class="line">|        堆（Heap）       | ↑ 向高地址增长  </span><br><span class="line">+------------------------+  </span><br><span class="line">|        保护页           | ← 防止堆越界  </span><br><span class="line">+------------------------+  </span><br><span class="line">|    BSS段（未初始化数据） |  </span><br><span class="line">+------------------------+  </span><br><span class="line">|   数据段（已初始化数据） |  </span><br><span class="line">+------------------------+  </span><br><span class="line">|   文本段（程序代码）     |  </span><br><span class="line">+------------------------+  &lt;-- <span class="number">0x00000000</span>（低地址）</span><br></pre></td></tr></table></figure><h4 id="1-内核空间（Kernel-Space）"><a href="#1-内核空间（Kernel-Space）" class="headerlink" title="1. 内核空间（Kernel Space）"></a>1. 内核空间（Kernel Space）</h4><ul><li>范围：<code>0xC0000000</code> ~ <code>0xFFFFFFFF</code>（占用 1GB 空间，32 位系统下）。</li></ul><blockquote><p>  [!NOTE]</p><p>  <strong>据搜索：Linux 现在广泛使用 64 位系统，</strong> 现在主流云服务商（如阿里云、腾讯云、华为云）的 默认系统都是 64 位（包括 CentOS、Ubuntu、Debian 等）。CentOS 7 默认只提供 64 位版本，32 位需要手动编译，非常少见。</p><p>  <strong>怎么查看自己的服务器是几位？</strong></p><p>  在 Xshell 里运行以下命令查看：<code>uname -m</code></p><ul><li>返回 <strong><code>x86_64</code></strong>：说明是 <strong>64 位系统</strong>。</li><li>返回 <strong><code>i686</code></strong> 或 <strong><code>i386</code></strong>：说明是 <strong>32 位系统</strong>（几乎不会出现）。</li></ul><p>  在 <strong>64 位系统</strong> 下，内核空间和用户空间的划分会有所不同。</p><ol><li><strong>虚拟地址空间总大小：</strong><ul><li>32 位系统：最大可寻址空间是 <strong>4GB</strong>（2^32^ &#x3D; 4,294,967,296 字节）。</li><li>64 位系统：理论上最大可寻址空间是 <strong>16 EB（Exabyte）</strong>（2^64^），但目前的操作系统通常不会直接使用全部 64 位地址空间。</li></ul></li><li><strong>内核空间与用户空间划分：</strong><br> 在常见的 64 位 Linux 系统（如 CentOS、Ubuntu）中，用户空间与内核空间的划分通常是：<ul><li><strong>内核空间（Kernel Space）：</strong> 占用最高的 <strong>128TB</strong>（<code>0xFFFF800000000000</code> 到 <code>0xFFFFFFFFFFFFFFFF</code>），用户程序无法访问。</li><li><strong>用户空间（User Space）：</strong> 占用最低的 <strong>128TB</strong>（<code>0x0000000000000000</code> 到 <code>0x00007FFFFFFFFFFF</code>），程序代码、堆、栈、共享库等都在这个范围内。<br><strong>注意：实际物理内存远小于此，操作系统通过稀疏地址映射管理。</strong></li></ul></li><li><strong>总结：</strong><ul><li>在 <strong>32 位系统</strong> 下，用户空间通常是 <strong>3GB</strong>，内核空间是 <strong>1GB</strong>。</li><li>在 <strong>64 位系统</strong> 下，用户空间可以高达 <strong>128TB</strong>，内核空间也可达 <strong>128TB</strong>，两者远比 32 位系统宽裕。</li></ul></li></ol></blockquote><ul><li><strong>说明：内核空间是操作系统内核运行的地方，用户程序无法直接访问。</strong> 任何直接访问都会触发 <strong>段错误（Segmentation Fault）</strong>。</li><li><strong>用途：管理硬件、进程调度、内存管理、系统调用等。</strong></li></ul><h4 id="2-命令行参数与环境变量区"><a href="#2-命令行参数与环境变量区" class="headerlink" title="2. 命令行参数与环境变量区"></a>2. 命令行参数与环境变量区</h4><ul><li>位置：紧挨着栈的顶部。</li><li><strong>说明：</strong> 当程序启动时，命令行参数（<code>argc</code> 和 <code>argv</code>）以及环境变量（<code>envp</code>）会存储在这个区域。通过 <code>getenv()</code>、<code>argc/argv</code> 来访问它们。</li><li>示例：运行 <code>./a.out hello world</code> 时，<code>argv</code> 会保存 <code>&quot;hello&quot;</code> 和 <code>&quot;world&quot;</code> 这两个参数。</li></ul><h4 id="3-栈（Stack）"><a href="#3-栈（Stack）" class="headerlink" title="3. 栈（Stack）"></a>3. 栈（Stack）</h4><ul><li><strong>方向：从高地址向低地址增长（↓）。</strong></li><li><strong>说明：栈用于管理函数调用</strong>，包括：<ul><li>函数的返回地址。</li><li>局部变量、函数参数等。</li><li>栈帧（Stack Frame）：每次函数调用都会在栈上创建新的栈帧。</li></ul></li><li>特点：<ul><li>栈的内存分配是自动的，函数调用结束后，栈内存会自动回收。</li><li>如果栈空间耗尽，会触发 <strong>栈溢出（Stack Overflow）</strong>。</li></ul></li></ul><h4 id="4-保护页（Guard-Page）"><a href="#4-保护页（Guard-Page）" class="headerlink" title="4. 保护页（Guard Page）"></a>4. 保护页（Guard Page）</h4><ul><li>位置：保护页位于栈底和堆顶，防止越界</li><li>说明：保护页是操作系统设置的特殊内存页，目的是防止栈或堆意外越界。</li><li>机制：一旦程序试图访问保护页，系统会触发段错误（<code>Segmentation Fault</code>），保护程序免受内存破坏。</li></ul><h4 id="5-内存映射段（Memory-Mapping-Segment）"><a href="#5-内存映射段（Memory-Mapping-Segment）" class="headerlink" title="5. 内存映射段（Memory Mapping Segment）"></a>5. 内存映射段（Memory Mapping Segment）</h4><ul><li><p><strong>位置：</strong> 堆和栈之间。</p></li><li><p>说明：该区域通过 <code>mmap()</code> 系统调用进行映射，包含：</p><ul><li><strong>共享库（Shared Libraries）</strong>：动态链接库（<code>.so</code>、<code>.dll</code>），如 <code>libc.so</code>。</li><li><strong>文件映射（File Mapping）</strong>：用来映射文件到内存。</li><li><strong>匿名映射（Anonymous Mapping）</strong>：用于分配大块堆内存或创建内存池。</li><li><strong>线程栈（Thread Stack）</strong>：在多线程程序中，每个线程都有自己独立的栈，分布在这个区域。</li></ul></li></ul><h4 id="6-堆（Heap）"><a href="#6-堆（Heap）" class="headerlink" title="6. 堆（Heap）"></a>6. 堆（Heap）</h4><ul><li><strong>方向：从低地址向高地址增长（↑）。</strong></li><li>说明：堆用于动态内存分配，通过 <code>malloc()</code>、<code>calloc()</code>、<code>new</code> 等操作分配，<code>free()</code>、<code>delete</code> 释放。</li><li>特点：<ul><li>堆的生命周期由程序员管理，忘记释放内存会导致 <strong>内存泄漏</strong>。</li><li>堆的大小可以动态扩展，直到达到栈或内存映射段的边界。</li></ul></li></ul><h4 id="7-BSS-段（未初始化数据段）"><a href="#7-BSS-段（未初始化数据段）" class="headerlink" title="7. BSS 段（未初始化数据段）"></a>7. BSS 段（未初始化数据段）</h4><ul><li><p><strong>说明：存储程序中未初始化的全局变量和静态变量。系统在程序启动时自动将它们初始化为 0。</strong></p></li><li><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> global_var;  <span class="comment">// 未初始化的全局变量，放在 BSS 段</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="8-数据段（已初始化数据段）"><a href="#8-数据段（已初始化数据段）" class="headerlink" title="8. 数据段（已初始化数据段）"></a>8. 数据段（已初始化数据段）</h4><ul><li><p><strong>说明：存储已初始化的全局变量和静态变量。</strong></p></li><li><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> global_var = <span class="number">10</span>;    <span class="comment">// 已初始化的全局变量，放在数据段</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="9-文本段（Text-Segment）"><a href="#9-文本段（Text-Segment）" class="headerlink" title="9. 文本段（Text Segment）"></a>9. 文本段（Text Segment）</h4><ul><li><strong>说明：存储程序的机器指令（代码部分），通常是只读的，防止程序运行时意外修改自身代码。</strong></li><li>特点：<ul><li>文本段不可写入，任何写操作都会触发段错误。</li><li>共享库的代码也加载到这部分，多个程序可以共享同一份代码副本。</li></ul></li></ul><hr><h3 id="2-实验证明"><a href="#2-实验证明" class="headerlink" title="2. 实验证明"></a>2. 实验证明</h3><ul><li><strong>代码段（.text）</strong>：存放可执行指令。</li><li><strong>只读数据段（.rodata）</strong>：存放字符串常量和 <code>const</code> 全局变量。</li><li><strong>数据段（.data）</strong>：存放已初始化全局变量。</li><li><strong>BSS 段（.bss）</strong>：存放未初始化全局变量。</li><li><strong>堆区（heap）</strong>：动态分配的内存，向高地址生长。</li><li><strong>栈区（stack）</strong>：局部变量，向低地址生长。</li><li><strong>命令行参数和环境变量</strong>：位于栈区附近的高地址。</li></ul><p>实验一代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> global_init = <span class="number">10</span>;               <span class="comment">// 数据段</span></span><br><span class="line"><span class="type">int</span> global_uninit;                  <span class="comment">// BSS段</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> stack_var;                  <span class="comment">// 栈</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> static_init = <span class="number">20</span>;    <span class="comment">// 数据段</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> static_uninit;       <span class="comment">// BSS段</span></span><br><span class="line">    <span class="type">char</span>* heap_var = <span class="built_in">malloc</span>(<span class="number">10</span>);    <span class="comment">// 堆</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;文本段（代码）: %p\n&quot;</span>, (<span class="type">void</span>*)main);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;数据段（已初始化全局变量）: %p\n&quot;</span>, (<span class="type">void</span>*)&amp;global_init);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;数据段（已初始化静态变量）: %p\n&quot;</span>, (<span class="type">void</span>*)&amp;static_init);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;BSS段（未初始化全局变量）: %p\n&quot;</span>, (<span class="type">void</span>*)&amp;global_uninit);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;BSS段（未初始化静态变量）: %p\n&quot;</span>, (<span class="type">void</span>*)&amp;static_uninit);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;堆（动态分配内存）: %p\n&quot;</span>, (<span class="type">void</span>*)heap_var);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;栈（局部变量）: %p\n&quot;</span>, (<span class="type">void</span>*)&amp;stack_var);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(heap_var);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果示例：</p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250402125741895.png" alt="image-20250402125741766"></p><p>实验二代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> g_unval;                            <span class="comment">// 未初始化全局变量（BSS段）</span></span><br><span class="line"><span class="type">int</span> g_val = <span class="number">100</span>;                        <span class="comment">// 已初始化全局变量（数据段）</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> g_const = <span class="number">200</span>;                <span class="comment">// 只读常量（可能位于文本段或只读数据段）</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[], <span class="type">char</span>* envp[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1. 代码段和只读数据</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;==================== 代码段和只读数据 ====================\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main函数地址（代码段）          : %p\n&quot;</span>, main);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;字符串常量地址（只读数据）       : %p\n&quot;</span>, <span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 数据段和BSS段</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n==================== 数据段和BSS段 ====================\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;已初始化全局变量（g_val）        : %p\n&quot;</span>, &amp;g_val);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;未初始化全局变量（g_unval）      : %p\n&quot;</span>, &amp;g_unval);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;const全局常量（g_const）        : %p\n&quot;</span>, &amp;g_const);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 堆区</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n==================== 堆区 ====================\n&quot;</span>);</span><br><span class="line">    <span class="type">int</span>* p1 = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="type">int</span>* p2 = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="number">20</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;小堆块地址（p1）                : %p\n&quot;</span>, p1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;大堆块地址（p2）                : %p\n&quot;</span>, p2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;堆生长方向（p2 - p1）           : %ld\n&quot;</span>, p2 - p1);  <span class="comment">// 正数表示向高地址生长</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 栈区</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n==================== 栈区 ====================\n&quot;</span>);</span><br><span class="line">    <span class="type">int</span> stack_var1;</span><br><span class="line">    <span class="type">int</span> stack_var2;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;栈变量1（stack_var1）           : %p\n&quot;</span>, &amp;stack_var1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;栈变量2（stack_var2）           : %p\n&quot;</span>, &amp;stack_var2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;栈生长方向（&amp;stack_var2 - &amp;stack_var1）: %ld\n&quot;</span>,</span><br><span class="line">        (<span class="type">long</span>)&amp;stack_var2 - (<span class="type">long</span>)&amp;stack_var1);  <span class="comment">// 负数表示向低地址生长</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 命令行参数和环境变量</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n==================== 命令行参数和环境变量 ====================\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;argv数组地址                    : %p\n&quot;</span>, argv);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;envp数组地址                    : %p\n&quot;</span>, envp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; argc; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;argv[%d]地址                   : %p\n&quot;</span>, i, argv[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; envp[i]; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;envp[%d]地址                   : %p\n&quot;</span>, i, envp[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 动态库加载地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n==================== 动态库 ====================\n&quot;</span>);</span><br><span class="line">    <span class="type">void</span>* libc_addr = (<span class="type">void</span>*)printf;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;libc函数（printf）地址          : %p\n&quot;</span>, libc_addr);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(p1);</span><br><span class="line">    <span class="built_in">free</span>(p2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果示例：</p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250402131235172.png" alt="image-20250402131235019"></p><hr><h3 id="3-虚拟地址-VS-物理地址"><a href="#3-虚拟地址-VS-物理地址" class="headerlink" title="3. 虚拟地址 VS 物理地址"></a>3. 虚拟地址 VS 物理地址</h3><blockquote><p>虚拟地址就像是邮寄地址，CPU 先找到它，再由内存管理单元（MMU）翻译成物理地址，就像邮递员最终找到具体的收件地点。</p></blockquote><p>为了更好地理解地址空间的实际运作，需深入虚拟地址与物理地址的关系。先来段代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> g_val = <span class="number">100</span>;                <span class="comment">// 全局变量，存储在数据段</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> id = fork();          <span class="comment">// 调用 fork() 创建子进程</span></span><br><span class="line">    <span class="keyword">if</span> (id == <span class="number">0</span>)                <span class="comment">// 子进程</span></span><br><span class="line">    &#123;              </span><br><span class="line">        g_val = <span class="number">200</span>;            <span class="comment">// 修改全局变量的值</span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child:PID:%d, PPID:%d, g_val:%d, &amp;g_val:%p\n&quot;</span>, <span class="built_in">getpid</span>(), <span class="built_in">getppid</span>(), g_val, &amp;g_val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (id &gt; <span class="number">0</span>)            <span class="comment">// 父进程</span></span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">3</span>);               <span class="comment">// 父进程睡眠 3 秒，等待子进程运行</span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;father:PID:%d, PPID:%d, g_val:%d, &amp;g_val:%p\n&quot;</span>, <span class="built_in">getpid</span>(), <span class="built_in">getppid</span>(), g_val, &amp;g_val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>                        <span class="comment">// fork() 失败</span></span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="comment">// 处理 fork() 错误</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250402133458199.png" alt="image-20250402133458095"></p><p>我们发现，父子进程，输出地址是一致的，但是变量内容不一样！能得出如下结论：</p><ul><li>变量内容不一样，所以父子进程输出的变量绝对不是同一个变量。</li><li>但地址值是一样的，说明该地址绝对不是物理地址！</li><li>在 Linux 地址下，这种地址叫做虚拟地址。</li></ul><p><strong>结论</strong>：虚拟地址相同，但值独立，证明物理地址不同。我们在用 <code>C/C++</code> 语言所看到的地址，全部都是虚拟地址！物理地址用户一概看不到，由 <code>OS</code> 统一管理。<code>OS</code> 必须负责将虚拟地址转化成物理地址。</p><hr><ol><li><p><strong>虚拟地址空间独立性</strong></p><ul><li>每个进程的虚拟地址空间独立，与物理内存解耦，由 MMU 映射到物理内存。<ul><li>进程访问的地址是虚拟地址，由 <strong>MMU（内存管理单元）</strong> 转换为物理地址。</li></ul></li><li><strong>虚拟地址相同 ≠ 物理地址相同</strong>：父子进程的相同虚拟地址可能指向不同的物理内存。</li></ul></li><li><p><strong>写时复制（Copy-On-Write, COW）机制</strong></p><ol><li><p><strong>优势</strong>  </p><ul><li><strong>隔离性</strong>：进程间内存互不可见，防止相互干扰。</li><li><strong>简化开发</strong>：程序员无需关心物理内存布局。</li><li><strong>高效利用</strong>：支持分页、交换等技术，扩展可用内存。</li></ul></li><li><p><strong><code>fork()</code> 创建子进程时</strong>：</p><ul><li>子进程复制父进程的虚拟地址空间结构（如代码段、数据段）。</li><li><strong>实际物理内存未被复制</strong>，父子进程共享同一物理页，标记为 <strong>只读</strong>。</li></ul></li><li><p><strong>COW 机制（[Linux 5.11.4 内核 COW 机制源码分析](<a href="https://woodpenker.github.io/2021/04/03/COW%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/">Linux 5.11.4内核COW机制源码分析 | woodpenker’s blog</a>)）：</strong> 在 <code>fork()</code> 之后，父子进程会 <strong>共享同一块物理内存</strong>，但如果 <strong>任何一个进程试图修改</strong>，Linux <strong>才会创建新的物理内存</strong>，从而保证它们的数据互不影响。</p><blockquote><p>  [!CAUTION]</p><ul><li>当任一进程尝试写入共享页（如子进程修改 <code>g_val</code>），触发 <strong>页错误（Page Fault）</strong>。</li><li>操作系统 <strong>复制该物理页</strong>，为子进程创建新副本，更新页表映射。</li><li>此后，父子进程的相同虚拟地址指向 <strong>不同的物理内存</strong>。</li></ul></blockquote></li></ol></li><li><p><strong>地址相同的本质</strong></p><ul><li>虚拟地址是进程内部的逻辑地址，由编译器和链接器在程序加载时确定。</li><li><strong>子进程继承父进程的虚拟地址布局</strong>，因此变量地址值相同。</li></ul></li></ol><blockquote><h3 id="主要了解虚拟地址，不做过多解释，点到为止："><a href="#主要了解虚拟地址，不做过多解释，点到为止：" class="headerlink" title="主要了解虚拟地址，不做过多解释，点到为止："></a><span style="font-weight:bold; color:#CC0000;">主要了解虚拟地址，不做过多解释，点到为止：</span></h3><h4 id="Q1：为什么子进程和父进程的-g-val-地址相同？"><a href="#Q1：为什么子进程和父进程的-g-val-地址相同？" class="headerlink" title="Q1：为什么子进程和父进程的 g_val 地址相同？"></a>Q1：为什么子进程和父进程的 <code>g_val</code> 地址相同？</h4><p>在 Linux 进程管理中，每个进程都有 <strong>独立的虚拟地址空间</strong>，但是多个进程可以在 <strong>各自的虚拟地址空间</strong> 中看到相同的地址。</p><p><strong><code>fork()</code> 之后，子进程获得了父进程的完整拷贝</strong>。<code>fork()</code> 会创建一个 <strong>新的进程</strong>，这个新进程的 <strong>地址空间</strong> 是 <strong>父进程的完整副本</strong>，由于子进程 <strong>继承了父进程的虚拟地址空间布局</strong>，<strong>它的全局变量 <code>g_val</code> 也会出现在相同的虚拟地址</strong>。</p><hr><h4 id="Q2：为什么数据相互独立？"><a href="#Q2：为什么数据相互独立？" class="headerlink" title="Q2：为什么数据相互独立？"></a>Q2：为什么数据相互独立？</h4><p>虽然子进程和父进程的变量 <strong>在虚拟地址上相同</strong>，但它们 <strong>实际上是两个独立的物理内存区域</strong>。</p></blockquote><h4 id="1-虚拟地址相同的根本原因：分页机制-——-类比为“字典”或“目录索引”"><a href="#1-虚拟地址相同的根本原因：分页机制-——-类比为“字典”或“目录索引”" class="headerlink" title="1. 虚拟地址相同的根本原因：分页机制 —— 类比为“字典”或“目录索引”"></a>1. 虚拟地址相同的根本原因：分页机制 —— 类比为“字典”或“目录索引”</h4><p><strong>上面的现象其实与分页机制有密切关系！</strong> 结合分页的概念再解释：</p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250402135849980.png" alt="image-20250402135849830"></p><p>在 Linux 和大多数现代操作系统中，进程的 <strong>地址空间是基于“分页（Paging）”管理的</strong>。分页的作用主要是：</p><ol><li><strong>将进程的虚拟地址映射到物理地址</strong>，实现内存的高效管理。</li><li><strong>隔离进程的内存空间</strong>，不同进程看到的地址相同，但实际物理地址不同。</li></ol><h4 id="2-分页表（Page-Table）是如何运作的？"><a href="#2-分页表（Page-Table）是如何运作的？" class="headerlink" title="2. 分页表（Page Table）是如何运作的？"></a>2. 分页表（Page Table）是如何运作的？</h4><ul><li>在 Linux 的 <strong>分页机制</strong> 中，每个进程都有一个 <strong>页表（Page Table）</strong>，它 <strong>记录虚拟地址到物理地址的映射</strong>。</li><li><code>fork()</code> 后，子进程 <strong>的页表会复制父进程的页表</strong>，但两者 <strong>指向相同的物理页</strong>，直到发生 <strong>写操作</strong> 时，才会真正分配新物理页。</li></ul><h4 id="3-分页是如何影响-fork-的？"><a href="#3-分页是如何影响-fork-的？" class="headerlink" title="3. 分页是如何影响 fork() 的？"></a>3. 分页是如何影响 <code>fork()</code> 的？</h4><ul><li><code>fork()</code> 后，子进程会 <strong>继承父进程的虚拟地址空间</strong>，因此在 <strong>虚拟地址</strong> 层面，它们的全局变量 <code>g_val</code> 地址相同（<code>0x601054</code>）。</li><li>但是，操作系统 <strong>并不会立即复制父进程的所有物理内存页</strong>，而是采用 <strong>写时复制（Copy-On-Write, COW）</strong> 机制。</li></ul><p><strong>示意图（分页机制 + COW）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">父进程：</span><br><span class="line">+------------+      +------------+</span><br><span class="line">| 0x601054   | ---&gt; | 物理页 A   |</span><br><span class="line">+------------+      +------------+</span><br><span class="line"></span><br><span class="line">子进程（fork后）：</span><br><span class="line">+------------+      +------------+</span><br><span class="line">| 0x601054   | ---&gt; | 物理页 A   | （共享）</span><br><span class="line">+------------+      +------------+</span><br><span class="line"></span><br><span class="line">子进程（修改 g_val = 200 后）：</span><br><span class="line">+------------+      +------------+     +------------+</span><br><span class="line">| 0x601054   | ---&gt; | 物理页 B   |     | 物理页 A   |</span><br><span class="line">+------------+      +------------+     +------------+</span><br><span class="line">  (子进程获得新的物理页)      (父进程的物理页)</span><br></pre></td></tr></table></figure><h4 id="4-fork-分页-COW-的关系"><a href="#4-fork-分页-COW-的关系" class="headerlink" title="4. fork() + 分页 + COW 的关系"></a>4. fork() + 分页 + COW 的关系</h4><table><thead><tr><th><strong>机制</strong></th><th><strong>影响</strong></th></tr></thead><tbody><tr><td><strong>分页</strong></td><td>每个进程有独立的虚拟地址空间，但可以共享物理页。</td></tr><tr><td><strong>页表（Page Table）</strong></td><td>记录虚拟地址到物理地址的映射，fork() 后子进程继承父进程的页表。</td></tr><tr><td><strong>写时复制（COW）</strong></td><td>直到子进程或父进程修改数据时，才会真正分配新的物理内存页。</td></tr><tr><td><strong>进程隔离</strong></td><td>虽然地址相同，但修改数据后，两者的物理页不再共享。</td></tr></tbody></table><hr><h3 id="4-小结"><a href="#4-小结" class="headerlink" title="4. 小结"></a>4. 小结</h3><ul><li><p><strong>程序地址空间：</strong> 是操作系统为每个进程分配的 <strong>虚拟内存布局</strong>，决定了代码、数据、堆、栈等区域的访问方式。</p></li><li><p><strong>虚拟地址相同，但物理地址可能不同</strong>：fork() 只是复制了 <strong>页表</strong>，不会立即复制物理内存，直到子进程写入数据。</p></li><li><p><strong>虚拟地址 ≠ 物理地址</strong>：程序看到的是虚拟地址，由操作系统通过 <strong>MMU（内存管理单元）</strong> 动态映射到物理内存。</p></li><li><p><strong>分页 + COW 机制确保内存效率</strong>：避免了不必要的物理内存复制，只有修改数据时才会真正分配新内存。</p></li></ul><p><strong>总结一句话：虚拟地址是“门牌号”，物理地址是“真实房屋”。</strong> <code>fork()</code> 后，父子进程共享“门牌号目录”（页表），但“房屋”（物理内存）仅在需要时复制（COW），从而实现高效隔离。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 地址空间 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>014 Linux 2.6内核进程调度队列（了解）</title>
      <link href="/posts/14630.html"/>
      <url>/posts/14630.html</url>
      
        <content type="html"><![CDATA[<h2 id="Linux-2-6内核进程调度队列（了解）"><a href="#Linux-2-6内核进程调度队列（了解）" class="headerlink" title="Linux 2.6内核进程调度队列（了解）"></a>Linux 2.6内核进程调度队列（了解）</h2><blockquote><p><a href="https://blog.csdn.net/2301_81265915/article/details/144487075">更多文章 | CSDN</a></p><p><a href="https://zhuanlan.zhihu.com/p/472955572">更多文章 | 知乎</a></p><p><a href="https://cloud.tencent.com/developer/article/2488258">更多文章 | 腾讯云</a></p></blockquote><p>Linux 2.6 内核在进程调度方面引入了 <strong>O(1) 调度器</strong>，该调度器的核心目标是保证调度决策的时间复杂度为恒定时间 O(1)，即无论系统中有多少个进程，调度器的决策时间始终保持不变。这个设计对于大规模系统具有重要意义，可以有效避免调度决策的性能瓶颈。</p><h3 id="1-调度队列结构"><a href="#1-调度队列结构" class="headerlink" title="1. 调度队列结构"></a>1. 调度队列结构</h3><p>Linux 2.6 内核的进程调度通过多个调度队列进行管理，核心数据结构是 <strong>运行队列（Runqueue）</strong>，每个 CPU 核心都维护一个独立的运行队列。运行队列（Runqueue）：每个 CPU 核心维护一个独立的运行队列，队列内包含当前可运行的进程。运行队列结构主要由以下几个组件组成：</p><ul><li>优先级数组：<ul><li>活跃数组（Active Array）：存放当前可运行的进程，按优先级分为 140 个队列（0~139）。<ul><li><strong>0~99</strong>：实时进程（RT进程，如硬实时任务）。</li><li><strong>100~139</strong>：普通进程（分时进程，如用户程序）。</li></ul></li><li><strong>过期数组（Expired Array）</strong>：存放已经用完时间片的进程，结构与活跃数组相同。</li></ul></li><li><strong>时间片管理</strong>：每个进程被分配一个时间片（Time Slice），进程执行时消耗时间片，执行完毕后会被移到过期数组，活跃数组和过期数组会周期性交换角色。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250323162106629.png" alt="image-20250323162106486"><br><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250323162254932.png" alt="image-20250323162254808"></p><hr><h3 id="2-调度流程"><a href="#2-调度流程" class="headerlink" title="2. 调度流程"></a>2. 调度流程</h3><h4 id="1-选择进程"><a href="#1-选择进程" class="headerlink" title="1. 选择进程"></a>1. 选择进程</h4><p>调度器会从活跃数组的 <strong>最高优先级非空队列</strong> 中选择第一个进程执行。实时进程（优先级 0<del>99）总是优先于普通进程（优先级 100</del>139）。</p><h4 id="2-时间片分配"><a href="#2-时间片分配" class="headerlink" title="2. 时间片分配"></a>2. 时间片分配</h4><ul><li>高优先级的进程获得更长的时间片。例如，优先级 0 的进程可能获得 200ms 的时间片，而优先级 139 的进程仅获得 10ms。</li><li>时间片用尽的进程会被移至过期数组，等待下一轮调度。</li></ul><h4 id="3-数组切换"><a href="#3-数组切换" class="headerlink" title="3. 数组切换"></a>3. 数组切换</h4><p>当活跃数组中的所有进程时间片耗尽时，调度器交换活跃数组和过期数组的角色，开始新一轮的调度。</p><hr><h3 id="3-动态优先级调整"><a href="#3-动态优先级调整" class="headerlink" title="3. 动态优先级调整"></a>3. 动态优先级调整</h3><p>为了优化系统的响应速度，Linux 2.6 内核提供了动态优先级调整机制：</p><ul><li><strong>交互式进程优化</strong>：长时间等待 I&#x2F;O 操作的进程（例如用户界面程序）会被提升优先级，以确保系统响应更及时。</li><li><strong>CPU 密集型进程惩罚</strong>：长时间占用 CPU 的进程会被降低优先级，防止其饿死其他进程。</li></ul><hr><h3 id="4-多核负载均衡"><a href="#4-多核负载均衡" class="headerlink" title="4. 多核负载均衡"></a>4. 多核负载均衡</h3><p>Linux 2.6 内核还引入了多核 CPU 的负载均衡机制：</p><ul><li><strong>每个 CPU 独立队列</strong>：每个 CPU 核心都维护自己的运行队列，从而减少了锁竞争，提高了并发性能。</li><li><strong>负载均衡机制</strong>：当某个 CPU 核心空闲时，内核会从其他繁忙 CPU 核心的运行队列中迁移进程，保持多核负载均衡。</li></ul><hr><h3 id="5-优缺点分析"><a href="#5-优缺点分析" class="headerlink" title="5. 优缺点分析"></a>5. 优缺点分析</h3><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><ul><li><strong>调度时间复杂度为 O(1)</strong>：在 Linux 2.6 的 O(1) 调度器中，不论系统中进程数量如何变化，调度决策的时间始终是常数时间 O(1)，避免了大规模系统中的性能瓶颈。</li><li><strong>实时任务响应快</strong>：实时进程（RT 进程）的响应优先级高，系统能够确保它们能迅速获得 CPU 资源。</li><li><strong>交互式优化</strong>：内核会动态调整交互式进程的优先级，确保用户界面等任务能够得到优先响应，提高用户体验。</li></ul><h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><ul><li><strong>优先级划分复杂</strong>：调度器的优先级划分较为复杂，且需要根据系统的不同需求调节，调整过程不够灵活。</li><li><strong>参数调优困难</strong>：调度器的细节调整复杂，需要对系统进行大量的测试和调优，增加了内核维护的难度。</li><li><strong>被 CFS 替代</strong>：虽然 O(1) 调度器在许多场景下表现优秀，但它在处理公平性、灵活性等方面有局限，因此在 Linux 2.6.23+ 版本中被 <strong>完全公平调度器（CFS）</strong> 取代。</li></ul><hr><h3 id="6-概念小结"><a href="#6-概念小结" class="headerlink" title="6. 概念小结"></a>6. 概念小结</h3><p>Linux 2.6 内核中的 O(1) 调度器通过 <strong>多级优先级队列</strong> 和 <strong>动态数组切换</strong> 实现了高效的进程调度。其核心设计思想是 <strong>优先级驱动</strong> 和 <strong>时间片轮转</strong>，确保了实时任务的快速响应，同时兼顾了普通任务的公平性。尽管在后来的版本中被 CFS 替代，但 O(1) 调度器的设计理念对现代调度器仍有深远的影响。</p><p>Linux 2.6 内核的调度器通过优化进程调度策略和结构设计，不仅提升了系统的调度效率，还增强了对多核系统和大规模进程的适应性，为更高效的操作系统调度奠定了基础。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 进程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>013 环境变量</title>
      <link href="/posts/10533.html"/>
      <url>/posts/10533.html</url>
      
        <content type="html"><![CDATA[<h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><h3 id="1-什么是环境变量？"><a href="#1-什么是环境变量？" class="headerlink" title="1. 什么是环境变量？"></a>1. 什么是环境变量？</h3><p>环境变量（Environment Variables）是操作系统中用于指定系统运行环境参数的一组动态键值对。每个环境变量由一个 <strong>名称（键）</strong> 和一个 <strong>值</strong> 组成，用于存储应用程序或系统需要访问的配置信息。例如：</p><ul><li><strong>名称</strong>：<code>PATH</code></li><li><strong>值</strong>：<code>/usr/bin:/usr/local/bin</code></li></ul><p>环境变量的作用类似于操作系统的“配置开关”，可以影响程序的运行行为、路径搜索、资源访问等。</p><h4 id="1-环境变量的分类"><a href="#1-环境变量的分类" class="headerlink" title="1. 环境变量的分类"></a>1. 环境变量的分类</h4><p>根据作用范围和修改权限，环境变量可分为两类：</p><h5 id="1-用户环境变量（User-Variables）"><a href="#1-用户环境变量（User-Variables）" class="headerlink" title="1. 用户环境变量（User Variables）"></a>1. 用户环境变量（User Variables）</h5><ul><li><strong>作用范围</strong>：仅对当前用户生效。</li><li><strong>用途</strong>：存储用户个性化配置（如用户专属的软件路径）。</li></ul><h5 id="2-系统环境变量（System-Variables）"><a href="#2-系统环境变量（System-Variables）" class="headerlink" title="2. 系统环境变量（System Variables）"></a>2. 系统环境变量（System Variables）</h5><ul><li><strong>作用范围</strong>：对所有用户和系统进程生效。</li><li><strong>用途</strong>：存储全局配置（如系统工具路径、公共依赖库路径）。</li></ul><h5 id="3-临时环境变量"><a href="#3-临时环境变量" class="headerlink" title="3. 临时环境变量"></a>3. 临时环境变量</h5><ul><li><strong>作用</strong>：仅在当前终端会话或子进程中有效。</li></ul><h4 id="2-和环境变量相关的命令"><a href="#2-和环境变量相关的命令" class="headerlink" title="2. 和环境变量相关的命令"></a>2. 和环境变量相关的命令</h4><ul><li><code>echo</code>：显示某个环境变量值</li><li><code>export</code>：设置一个新的环境变量</li><li><code>env</code>：显示所有环境变量</li><li><code>unset</code>: 清除环境变量</li><li><code>set</code>：显示本地定义的 shell 变量和环境变量</li></ul><hr><h3 id="2-常见环境变量及用途"><a href="#2-常见环境变量及用途" class="headerlink" title="2. 常见环境变量及用途"></a>2. 常见环境变量及用途</h3><table><thead><tr><th align="left">变量名</th><th align="left">作用</th><th align="left">示例值</th></tr></thead><tbody><tr><td align="left"><strong>PATH</strong></td><td align="left">执行文件的查找的路径，目录与目录中间用 <code>:</code> 分隔。注意：文件查找是按 PATH 变量内的目录来查询的，所以，目录顺序很重要</td><td align="left"><code>/usr/bin:/usr/local/bin</code></td></tr><tr><td align="left"><strong>HOME</strong></td><td align="left">当前用户的家目录（根目录）</td><td align="left"><code>/home/user</code></td></tr><tr><td align="left"><strong>USER</strong></td><td align="left">当前用户名</td><td align="left"><code>user</code></td></tr><tr><td align="left"><strong>SHELL</strong></td><td align="left">告知我们目前这个环境使用的 SHELL 是哪个程序？默认 Shell 程序路径</td><td align="left"><code>/bin/bash</code>（Linux 默认使用）</td></tr><tr><td align="left"><strong>LANG</strong></td><td align="left">系统语言和字符编码</td><td align="left"><code>en_US.UTF-8</code></td></tr><tr><td align="left"><strong>PWD</strong></td><td align="left">当前工作目录</td><td align="left"><code>/home/user/projects</code></td></tr></tbody></table><p>还有 <strong>自定义变量：</strong> 你可以定义自己的变量来影响程序行为。示例：<code>MY_VAR=123</code></p><blockquote><p>  [!CAUTION]</p><p>  自定义变量和本地变量在概念上有些相似，但它们并不完全相同。</p><ol><li><strong>自定义变量</strong>：手动创建的变量，默认是 <strong>本地变量</strong>。</li><li><strong>本地变量</strong>：默认不使用 <code>export</code>，只在当前 Shell 生效，子进程无法访问。</li><li><strong>环境变量</strong>：通过 <code>export</code> 声明，子进程也能访问。</li></ol><p>  ✅ <strong>判断标准：</strong> 是否用 <code>export</code> 导出，决定了变量是本地的还是环境的。</p><hr><h4 id="自定义变量："><a href="#自定义变量：" class="headerlink" title="自定义变量："></a>自定义变量：</h4><ul><li><strong>定义方式：</strong> 直接赋值，或者使用 <code>export</code> 命令声明。</li><li><strong>作用范围：</strong> 根据是否使用 <code>export</code>，它可以是 <strong>本地变量</strong> 或者 <strong>环境变量</strong>。</li><li><strong>示例：</strong></li></ul>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MY_VAR=<span class="string">&quot;Hello World&quot;</span>  <span class="comment"># 定义自定义变量</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$MY_VAR</span>          <span class="comment"># 输出：Hello World</span></span><br></pre></td></tr></table></figure><h4 id="本地变量（Local-Variable）："><a href="#本地变量（Local-Variable）：" class="headerlink" title="本地变量（Local Variable）："></a>本地变量（Local Variable）：</h4><ul><li><strong>定义方式：</strong> 在当前 Shell 会话中赋值，不使用 <code>export</code>。</li><li><strong>作用范围：</strong> 仅在 <strong>当前 Shell 会话</strong> 内有效，不会被子进程继承。</li><li><strong>示例：</strong></li></ul>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LOCAL_VAR=<span class="string">&quot;I am local&quot;</span></span><br><span class="line">bash  <span class="comment"># 打开新的子 Shell</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$LOCAL_VAR</span>   <span class="comment"># 无输出，子 Shell 无法访问父 Shell 的本地变量</span></span><br></pre></td></tr></table></figure><h4 id="环境变量（Environment-Variable）："><a href="#环境变量（Environment-Variable）：" class="headerlink" title="环境变量（Environment Variable）："></a>环境变量（Environment Variable）：</h4><ul><li><strong>定义方式：</strong> 使用 <code>export</code> 命令导出。</li><li><strong>作用范围：</strong> 在 <strong>当前 Shell</strong> 以及所有 <strong>子进程</strong> 中都可用。</li><li><strong>示例：</strong></li></ul>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> ENV_VAR=<span class="string">&quot;I am environment&quot;</span></span><br><span class="line">bash  <span class="comment"># 打开新的子 Shell</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$ENV_VAR</span>  <span class="comment"># 输出：I am environment</span></span><br></pre></td></tr></table></figure></blockquote><hr><h3 id="3-查看环境变量"><a href="#3-查看环境变量" class="headerlink" title="3. 查看环境变量"></a>3. 查看环境变量</h3><ol><li><strong>查看单个变量</strong></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo $NAME <span class="comment">//NAME为待查看的环境变量名称，例如：echo $PATH</span></span><br><span class="line">printenv NAME<span class="comment">//NAME为待查看的环境变量名称，例如：printenv USER</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250319184836272.png" alt="image-20250319184829137"></p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250319185701316.png" alt="image-20250319185701254"></p><ol start="2"><li><strong>查看所有环境变量</strong></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printenv</span>  <span class="comment"># 或 env，输出一模一样</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250319185045666.png" alt="image-20250319185045556"></p><hr><h3 id="4-设置环境变量"><a href="#4-设置环境变量" class="headerlink" title="4. 设置环境变量"></a>4. 设置环境变量</h3><h4 id="1-为什么-ls-命令可以直接执行，而我们自己的可执行程序需要带上路径（如-）来执行的问题？"><a href="#1-为什么-ls-命令可以直接执行，而我们自己的可执行程序需要带上路径（如-）来执行的问题？" class="headerlink" title="1. 为什么 ls 命令可以直接执行，而我们自己的可执行程序需要带上路径（如 ./）来执行的问题？"></a>1. 为什么 <code>ls</code> 命令可以直接执行，而我们自己的可执行程序需要带上路径（如 <code>./</code>）来执行的问题？</h4><p><strong>原因：<code>PATH</code>。</strong> 它是一个环境变量，指定了一个目录列表，系统会在这些目录中搜索用户输入的命令。当你在终端中输入一个命令（例如 <code>ls</code>），系统会按照 <code>PATH</code> 中列出的顺序查找该命令，并执行找到的第一个匹配项。像 <code>ls</code> 这样的命令之所以可以不带路径直接执行，是因为它们所在的目录（通常是 <code>/bin</code> 或 <code>/usr/bin</code> 等）被包含在了系统的 <code>PATH</code> 环境变量中。因此，当你输入 <code>ls</code> 时，系统能够在指定的目录中找到并执行这个命令。</p><h4 id="2-我们自己生成的可执行程序为什么不能直接执行？"><a href="#2-我们自己生成的可执行程序为什么不能直接执行？" class="headerlink" title="2. 我们自己生成的可执行程序为什么不能直接执行？"></a>2. 我们自己生成的可执行程序为什么不能直接执行？</h4><p>当我们创建了自己的可执行程序并尝试在终端运行时，默认情况下当前工作目录（即 <code>.</code> 代表的目录）通常不会包含在 <code>PATH</code> 环境变量中。这说明：当我们在终端输入自己程序的名字时，系统不会自动在当前目录下查找该程序。因此，我们需要使用 <code>./</code> 前缀来明确指出要执行的是当前目录下的程序。</p><h4 id="3-如何让自定义的可执行程序无需带路径就能直接运行？"><a href="#3-如何让自定义的可执行程序无需带路径就能直接运行？" class="headerlink" title="3. 如何让自定义的可执行程序无需带路径就能直接运行？"></a>3. 如何让自定义的可执行程序无需带路径就能直接运行？</h4><p>要让自定义的可执行程序无需带路径就能直接运行，你需要将它所在的目录添加到 <strong>环境变量 <code>PATH</code></strong> 中。这样，当你在命令行中输入程序名时，系统会在 <code>PATH</code> 指定的目录中查找该可执行程序。以下是详细步骤：</p><h4 id="1-临时生效（仅当前终端有效）"><a href="#1-临时生效（仅当前终端有效）" class="headerlink" title="1. 临时生效（仅当前终端有效）"></a>1. 临时生效（仅当前终端有效）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 假设程序放在 /home/user/myprogram/ 目录下</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="string">&quot;<span class="variable">$PATH</span>:/home/user/myprogram&quot;</span></span><br></pre></td></tr></table></figure><p><strong>测试验证</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$PATH</span>                 <span class="comment"># 查看 PATH 是否包含目录</span></span><br><span class="line">myprogram                  <span class="comment"># 直接运行你的程序（无需路径）</span></span><br></pre></td></tr></table></figure><p><strong>取消临时设置：临时添加的路径在会话结束后就会丢失。</strong> 如果想手动取消，使用 <code>unset</code> 命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unset</span> PATH    <span class="comment"># 或者将 PATH 恢复为原始值</span></span><br></pre></td></tr></table></figure><h4 id="2-永久生效（对所有终端和子进程生效）"><a href="#2-永久生效（对所有终端和子进程生效）" class="headerlink" title="2. 永久生效（对所有终端和子进程生效）"></a>2. 永久生效（对所有终端和子进程生效）</h4><p>如果希望即使重启终端或计算机后仍然有效，可以将 <code>export</code> 命令添加到用户的启动文件中（如 <code>.bashrc</code>、<code>.bash_profile</code> 或 <code>.zshrc</code> 等），这样每次打开终端时就会自动设置。</p><p>根据自己使用的 Shell 选择配置文件：</p><ul><li><strong>Bash</strong>：<code>~/.bashrc</code> 或 <code>~/.bash_profile</code></li><li><strong>Zsh</strong>：<code>~/.zshrc</code></li></ul><blockquote><p>  [!NOTE]</p><p>  简单解释一下：</p><ul><li><p><strong>Bash</strong> 是最常见的默认 shell，适合日常使用和脚本编写。</p></li><li><p><strong>Zsh</strong> 是更强大、功能丰富的 shell，特别适合喜欢定制和使用插件的用户。</p></li><li><p>Xshell 作为终端模拟器，可以连接到 Linux 服务器，使用的 shell 是由服务器设置的，可以是 Bash 或 Zsh。</p></li></ul><p>  可以通过以下命令来查看当前使用的是哪个 shell：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $SHELL</span><br></pre></td></tr></table></figure><ul><li>如果返回的结果是 <code>/bin/bash</code>，那说明你使用的是 <strong>Bash</strong>。</li><li>如果返回的结果是 <code>/bin/zsh</code>，那说明你使用的是 <strong>Zsh</strong>。</li></ul></blockquote><p>这里以我的 <code>Bash</code> 为例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.bashrc</span><br></pre></td></tr></table></figure><p>在文件末尾添加这一行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/home/user/myprogram<span class="comment"># 或者export PATH=&quot;$PATH:/home/user/myprograms&quot;</span></span><br></pre></td></tr></table></figure><p>保存并退出编辑器，使配置生效：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bashrc  <span class="comment"># 或 source ~/.bash_profile，重新加载配置文件</span></span><br></pre></td></tr></table></figure><p><strong>测试：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$PATH</span>  <span class="comment"># 查看 PATH 变量，确认是否添加成功</span></span><br><span class="line">myprogram   <span class="comment"># 直接执行程序，无需路径</span></span><br></pre></td></tr></table></figure><h4 id="3-取消永久设置："><a href="#3-取消永久设置：" class="headerlink" title="3. 取消永久设置："></a>3. 取消永久设置：</h4><p>如果不再需要这个路径，可以编辑 <code>.bashrc</code> 或 <code>.bash_profile</code>，删除那一行，然后重新执行 <code>source</code> 命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.bashrc   <span class="comment"># 删除 export PATH 行</span></span><br><span class="line"><span class="built_in">source</span> ~/.bashrc  <span class="comment"># 使配置生效</span></span><br></pre></td></tr></table></figure><hr><h3 id="5-注意事项"><a href="#5-注意事项" class="headerlink" title="5. 注意事项"></a>5. 注意事项</h3><ol><li><p><strong>安全性</strong>：  </p><ul><li><strong>不要将当前目录 <code>.</code> 添加到 <code>PATH</code></strong>（如 <code>export PATH=&quot;.:$PATH&quot;</code>），这会允许当前目录下的任意程序被执行，存在安全风险。</li></ul></li><li><p><strong>路径优先级</strong>：  </p><ul><li><p><code>PATH</code> 中目录的顺序决定查找优先级。例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=<span class="string">&quot;/my_dir:<span class="variable">$PATH</span>&quot;</span>  <span class="comment"># 优先搜索 /my_dir</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="string">&quot;<span class="variable">$PATH</span>:/my_dir&quot;</span>  <span class="comment"># 最后搜索 /my_dir</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>多用户系统</strong>：  </p><ul><li>若需所有用户生效，可修改系统级配置文件（如 <code>/etc/profile</code> 或 <code>/etc/environment</code>），但需 root 权限。</li></ul></li><li><p><strong>误删了 <code>PATH </code> 变量怎么办？</strong></p><ul><li>恢复默认 <code>PATH</code>:</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=<span class="string">&quot;/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot;</span></span><br></pre></td></tr></table></figure></li></ol><hr><h3 id="6-理解-HOME-环境变量"><a href="#6-理解-HOME-环境变量" class="headerlink" title="6. 理解 HOME 环境变量"></a>6. 理解 <code>HOME</code> 环境变量</h3><p>在 Linux 系统中，每个用户都有一个专属的工作目录，称为 <strong>主目录（Home Directory）</strong>。这个目录是用户登录系统后的默认位置，用户可以在其中存储个人文件、配置文件等。</p><ul><li><strong><code>HOME</code></strong> 是一个环境变量，存储了当前用户的主目录路径。</li><li>每当登录到系统时，系统会分配一个 <strong>主目录</strong>，通常位于 <code>/home/用户名</code>，例如，假设我的用户名是 <code>hcc</code>，那么我的主目录就是 <code>/home/hcc</code>。</li></ul><p>在终端中，使用命令 <code>echo $HOME</code>，系统会返回当前登录用户的主目录路径：</p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250322204612109.png" alt="image-20250322204611987"></p><h4 id="1-主目录的作用"><a href="#1-主目录的作用" class="headerlink" title="1. 主目录的作用"></a>1. 主目录的作用</h4><ol><li><strong>默认工作目录</strong>：<ul><li>当登录到系统时，通常会自动进入主目录。这个目录是我们个人的空间，通常可以放置配置文件、文档、程序文件等。</li></ul></li><li><strong>保存用户的配置文件</strong>：<ul><li>在主目录下，用户的配置文件（如 <code>.bashrc</code>、<code>.zshrc</code> 等）存放在那里。这样，无论我们从哪个位置打开终端，都会读取这些文件的配置。</li></ul></li><li><strong>用户的私有空间</strong>：<ul><li>每个用户在系统中都有自己的主目录，确保用户数据和配置是隔离的，不会互相干扰。</li></ul></li></ol><h4 id="2-HOME-和-的关系"><a href="#2-HOME-和-的关系" class="headerlink" title="2. HOME 和 ~ 的关系"></a>2. <code>HOME</code> 和 <code>~</code> 的关系</h4><p><strong><code>~</code></strong> 是 <code>HOME</code> 变量的简写，表示当前用户的主目录。可以在命令行中使用 <code>~</code> 来快速访问主目录。例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~  <span class="comment"># 等同于 cd $HOME，切换到当前用户的主目录</span></span><br></pre></td></tr></table></figure><p>这样，无论处在哪个目录下，<code>~</code> 都会自动被替换为我们的主目录路径。</p><p><strong>每个用户的工作目录（主目录）都是独立且唯一的。</strong> 即使是同一台机器上的多个用户，它们的主目录路径也不同，这样可以保证用户数据的隔离和安全。</p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250322205018948.png" alt="image-20250322205018865"></p><hr><h3 id="7-环境变量的组织方式"><a href="#7-环境变量的组织方式" class="headerlink" title="7. 环境变量的组织方式"></a>7. 环境变量的组织方式</h3><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250322205313972.png" alt="image-20250322205313857"></p><hr><h3 id="8-如何通过代码获取环境变量"><a href="#8-如何通过代码获取环境变量" class="headerlink" title="8. 如何通过代码获取环境变量"></a>8. 如何通过代码获取环境变量</h3><h4 id="1-通过命令行的第三个参数获取环境变量"><a href="#1-通过命令行的第三个参数获取环境变量" class="headerlink" title="1. 通过命令行的第三个参数获取环境变量"></a>1. 通过命令行的第三个参数获取环境变量</h4><p>要在 C 语言中获取和操作环境变量，我们可以通过以下几种方式：</p><ol><li><strong>通过命令行第三个参数（<code>env[]</code>）获取环境变量</strong>：这是通过命令行启动程序时传递给 <code>main()</code> 函数的第三个参数。</li><li><strong>通过第三方变量 <code>environ</code> 获取环境变量</strong>：<code>environ</code> 是一个外部变量，包含了环境变量的列表。</li><li><strong>通过系统调用获取或设置环境变量</strong>：可以使用 <code>getenv()</code> 来获取环境变量的值，使用 <code>putenv()</code> 来设置环境变量。</li></ol><p><code>main()</code> 函数的第三个参数 <code>char *env[]</code> 是一个指向环境变量的字符串数组，数组中的每个元素都是一个格式为 <code>KEY=VALUE</code> 的字符串。</p><p>示例代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[], <span class="type">char</span> *env[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;获取命令行参数:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; argc; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;参数[%d]: %s\n&quot;</span>, i, argv[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n获取环境变量:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; env[i] != <span class="literal">NULL</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;环境变量[%d]: %s\n&quot;</span>, i, env[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250323133118703.png" alt="image-20250323133118466"></p><h4 id="2-通过-environ-获取环境变量"><a href="#2-通过-environ-获取环境变量" class="headerlink" title="2. 通过 environ 获取环境变量"></a>2. 通过 <code>environ</code> 获取环境变量</h4><p><code>environ</code> 是一个外部全局变量，包含当前环境变量的数组，它是 <code>char **environ</code> 类型。</p><p>示例代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> **environ;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;通过 environ 获取环境变量:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; environ[i] != <span class="literal">NULL</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;环境变量[%d]: %s\n&quot;</span>, i, environ[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250323133624287.png" alt="image-20250323133624112"></p><h4 id="3-使用-getenv-和-putenv-系统调用获取和设置环境变量"><a href="#3-使用-getenv-和-putenv-系统调用获取和设置环境变量" class="headerlink" title="3. 使用 getenv() 和 putenv() 系统调用获取和设置环境变量"></a>3. 使用 <code>getenv()</code> 和 <code>putenv()</code> 系统调用获取和设置环境变量</h4><p>常用 <code>getenv</code> 和 <code>putenv</code> 函数来访问特定的环境变量。</p><ul><li><code>getenv()</code>：获取指定环境变量的值。</li><li><code>putenv()</code>：设置一个新的环境变量或修改已有环境变量的值。</li></ul><h5 id="示例：获取和设置环境变量"><a href="#示例：获取和设置环境变量" class="headerlink" title="示例：获取和设置环境变量"></a>示例：获取和设置环境变量</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">putenv</span><span class="params">(<span class="type">char</span> *<span class="built_in">string</span>)</span>;<span class="comment">// 添加putenv的显式声明</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获取环境变量</span></span><br><span class="line">    <span class="type">char</span> *home = getenv(<span class="string">&quot;HOME&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (home)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;HOME 环境变量的值: %s\n&quot;</span>, home);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;HOME 环境变量未设置。\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置环境变量</span></span><br><span class="line">    putenv(<span class="string">&quot;MYVAR=MyCustomValue&quot;</span>);</span><br><span class="line">    <span class="type">char</span> *myvar = getenv(<span class="string">&quot;MYVAR&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (myvar)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;MYVAR 环境变量的值: %s\n&quot;</span>, myvar);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改环境变量</span></span><br><span class="line">    putenv(<span class="string">&quot;MYVAR=NewValue&quot;</span>);</span><br><span class="line">    myvar = getenv(<span class="string">&quot;MYVAR&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (myvar)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;修改后的 MYVAR 环境变量的值: %s\n&quot;</span>, myvar);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解释和输出：</strong></p><ol><li><strong><code>getenv()</code></strong>：获取环境变量的值，如果变量存在，返回该变量的值；如果不存在，返回 <code>NULL</code>。</li><li><strong><code>putenv()</code></strong>：设置环境变量，参数是一个格式为 <code>KEY=VALUE</code> 的字符串。<code>putenv</code> 会修改当前进程的环境变量，不需要重新调用 <code>setenv()</code> 或 <code>unsetenv()</code> 来更新。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250323134534303.png" alt="image-20250323134534197"></p><hr><h3 id="9-环境变量通常是具有全局属性的"><a href="#9-环境变量通常是具有全局属性的" class="headerlink" title="9. 环境变量通常是具有全局属性的"></a>9. 环境变量通常是具有全局属性的</h3><ol><li><p><strong>获取环境变量：</strong> 在程序中，通过 <code>getenv(&quot;MYENV&quot;)</code> 获取环境变量 <code>MYENV</code> 的值。如果该变量存在，程序会打印出它的值。</p><p>示例代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *env = getenv(<span class="string">&quot;MYENV&quot;</span>);  <span class="comment">// 获取环境变量</span></span><br><span class="line">    <span class="keyword">if</span> (env)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, env);  <span class="comment">// 如果环境变量存在，则打印</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>没有结果：</strong> 程序首次运行时，显示没有结果，表示 <code>MYENV</code> 环境变量并未被设置。</p></li><li><p><strong>设置环境变量：</strong> 通过执行 <code>export MYENV=&quot;hello world&quot;</code> 命令，设置环境变量 <code>MYENV</code>，并再次运行程序，结果成功打印了 <code>hello world</code>，表示环境变量是可以在当前进程中继承并使用的。</p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250323135915988.png" alt="image-20250323135915861"></p><p><strong>注意：</strong> 如果我们直接在命令行中设置 <code>MYENV=&quot;helloworld&quot;</code> 而不使用 <code>export</code>，在我们的 C 程序中是无法获取到这个环境变量的。</p><p><strong>解释：</strong></p><ul><li><strong><code>export</code></strong> 是用来 <strong>将环境变量传递给子进程</strong> 的命令。如果在命令行中仅设置了 <code>MYENV=&quot;helloworld&quot;</code>，这个环境变量只在当前 shell 会话中有效，但不会影响到子进程或其他程序。</li><li>使用 <code>export</code> 后，环境变量会被子进程继承并传递，这就是为什么在使用 <code>export</code> 设置了 <code>MYENV</code> 后，程序能够成功读取到该变量的原因。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>012 进程状态和优先级</title>
      <link href="/posts/22624.html"/>
      <url>/posts/22624.html</url>
      
        <content type="html"><![CDATA[<h2 id="进程状态和优先级"><a href="#进程状态和优先级" class="headerlink" title="进程状态和优先级"></a>进程状态和优先级</h2><blockquote><p>  [!TIP]</p><p>  <a href="https://www.bilibili.com/video/BV1juzZYhEG2/?spm_id_from=333.1391.0.0&vd_source=47fe2fe2f10c4e806e38c62553037767">相关推荐视频 | B站</a></p></blockquote><h3 id="一、进程状态分类"><a href="#一、进程状态分类" class="headerlink" title="一、进程状态分类"></a>一、进程状态分类</h3><p>Linux 中的进程状态可以通过 <code>ps</code> 命令或者 <code>top</code> 命令来查看，常见的状态码有以下几种：</p><table><thead><tr><th>状态码</th><th>名称</th><th>含义说明</th></tr></thead><tbody><tr><td><strong>R</strong></td><td>运行（Running）</td><td>进程正在运行或处于可运行状态（等待 CPU 调度）</td></tr><tr><td><strong>S</strong></td><td>可中断睡眠（Sleeping）</td><td>进程正在等待某个事件（如 I&#x2F;O、信号等），可以被信号或外部事件唤醒</td></tr><tr><td><strong>D</strong></td><td>不可中断睡眠（Uninterruptible Sleep）</td><td>进程正等待 <strong>无法被信号唤醒</strong> 的事件（如磁盘 I&#x2F;O），一般出现在设备驱动程序中，例如正在等待硬件操作</td></tr><tr><td><strong>T</strong></td><td>停止（Stopped&#x2F;Traced）</td><td>进程已被暂停执行，例如收到了 <code>SIGSTOP</code> 信号，或者在被调试时被暂停。</td></tr><tr><td><strong>Z</strong></td><td>僵尸（Zombie）</td><td>子进程已结束&#x2F;终止，但父进程未回收它的资源（PID 和退出状态仍占用系统资源），导致进程表里留有“尸体”</td></tr><tr><td><strong>X</strong></td><td>死亡（Dead）</td><td>进程已彻底终止，且不会再存在于进程表中（非常短暂极少见，用户通常看不到）</td></tr></tbody></table><h4 id="特殊状态说明"><a href="#特殊状态说明" class="headerlink" title="特殊状态说明"></a>特殊状态说明</h4><ol><li><strong>僵尸进程 (Z)（一种比较特殊的状态）</strong><ul><li><strong>产生原因</strong>：当进程退出并且父进程（使用 <code>wait()</code> 系统调用，后面讲）没有读取到子进程退出的返回代码时就会产生僵死（尸）进程。僵死进程会以终止状态保持在进程表中，并且会一直在等待父进程读取退出状态代码。所以，只要子进程退出，父进程还在运行，但父进程没有读取子进程状态，子进程进入 <code>Z</code> 状态。</li><li><strong>危害</strong>：占用 PID，可能导致系统 PID 耗尽。</li><li><strong>解决</strong>：杀死父进程（僵尸进程会由 <code>init</code> 进程接管并回收）。</li></ul></li><li><strong>不可中断睡眠 (D)</strong><ul><li><strong>常见场景</strong>：进程在执行关键系统调用（如写入磁盘）。</li><li><strong>处理</strong>：通常需等待操作完成，强制终止可能导致数据损坏。</li></ul></li></ol><hr><h3 id="二、如何查看进程状态（进程的状态显示在-STAT-字段下）"><a href="#二、如何查看进程状态（进程的状态显示在-STAT-字段下）" class="headerlink" title="二、如何查看进程状态（进程的状态显示在 STAT 字段下）"></a>二、如何查看进程状态（进程的状态显示在 <code>STAT</code> 字段下）</h3><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250317193133677.png" alt="image-20250317193133559"></p><h4 id="1-使用-ps-命令"><a href="#1-使用-ps-命令" class="headerlink" title="1. 使用 ps 命令"></a>1. 使用 <code>ps</code> 命令</h4><p><code>ps</code> 可以显示一次性快照信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps aux</span><br></pre></td></tr></table></figure><p>查看部分关键字段：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -eo pid,ppid,<span class="built_in">stat</span>,<span class="built_in">comm</span></span><br></pre></td></tr></table></figure><ul><li><strong>PID</strong>：进程 ID。</li><li><strong>PPID</strong>：父进程 ID。</li><li><strong>STAT</strong>：进程状态（如 <code>S</code>、<code>R</code>、<code>Z</code> 等）。</li><li><strong>COMMAND</strong>：执行该进程的命令。</li></ul><p>输出示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PID  PPID STAT COMMAND</span><br><span class="line">  1     0 Ss   systemd</span><br><span class="line">  2     0 S    kthreadd</span><br><span class="line">123     1 R    bash</span><br><span class="line">456   123 S    vim</span><br><span class="line">789   456 Z    python</span><br><span class="line">945     1 Ssl  hostguard</span><br><span class="line">1254    1 Ss+  agetty</span><br></pre></td></tr></table></figure><p><strong>解释：</strong></p><ul><li><strong><code>Ss</code></strong>：<code>systemd</code> 是会话首领（s），当前处于可中断睡眠状态（S）。</li><li><strong><code>Ssl</code></strong>：<code>hostguard</code> 是会话首领（s），处于可中断睡眠状态（S），且是多线程进程（l）。</li><li><strong><code>Ss+</code></strong>：<code>agetty</code> 是会话首领（s），处于可中断睡眠状态（S），且是前台进程（+）。</li><li><strong><code>Z</code></strong>：<code>python</code> 进程已变成僵尸进程（Z），等待父进程回收。</li></ul><p><code>STAT</code> 字段可能含有多个字符组合，如 <code>Ss</code>、<code>R+</code>，<strong>额外属性（从第二列字符开始）：</strong></p><table><thead><tr><th>字符</th><th>属性名称</th><th>含义说明</th></tr></thead><tbody><tr><td><strong>s</strong></td><td>会话首领（Session Leader）</td><td>该进程是会话的领导者，通常是终端启动的第一个进程。</td></tr><tr><td><strong>+</strong></td><td>前台进程组（Foreground）</td><td>进程属于前台进程组，能接受来自终端的输入信号。</td></tr><tr><td><strong>l</strong></td><td>多线程（Multithreaded）</td><td>进程是多线程的（用 Linux 的线程实现）。</td></tr><tr><td><strong>L</strong></td><td>内存锁定（Locked in Memory）</td><td>进程有部分内存被锁定，无法被换出。</td></tr><tr><td><strong>N</strong></td><td>低优先级（Low Priority）</td><td>进程运行在低优先级（nice 值大于 0）。</td></tr><tr><td><strong>&lt;</strong></td><td>高优先级（High Priority）</td><td>进程运行在实时优先级（nice 值小于 0）。</td></tr><tr><td><strong>s</strong></td><td>会话首领（Session Leader）</td><td>该进程是会话的领导者（通常是终端启动的第一个进程）。</td></tr><tr><td><strong>n</strong></td><td>优先级降低（Reduced Priority）</td><td>进程的优先级被降低（通过 <code>nice</code> 命令调整）。</td></tr><tr><td>**</td><td>进程被克隆（Cloned Process）</td><td>进程是通过 <code>clone()</code> 系统调用创建的，通常用于线程实现。</td></tr></tbody></table><h4 id="2-使用-top-命令"><a href="#2-使用-top-命令" class="headerlink" title="2. 使用 top 命令"></a>2. 使用 <code>top</code> 命令</h4><p><code>top</code> 命令动态刷新进程状态：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top</span><br></pre></td></tr></table></figure><ul><li><code>S</code> 列表示进程状态，通常会看到 <code>R</code>、<code>S</code>、<code>Z</code> 等状态。</li><li>按 <code>q</code> 键退出。</li></ul><h4 id="3-使用-proc-文件系统"><a href="#3-使用-proc-文件系统" class="headerlink" title="3. 使用 proc 文件系统"></a>3. 使用 <code>proc</code> 文件系统</h4><p>每个进程在 <code>/proc</code> 下有一个专属目录（以 PID 命名），可以直接查看其状态：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/&lt;PID&gt;/status | grep State</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/1234/status | grep State</span><br><span class="line">State:S (sleeping)</span><br></pre></td></tr></table></figure><hr><h3 id="三、进程状态的生命周期"><a href="#三、进程状态的生命周期" class="headerlink" title="三、进程状态的生命周期"></a>三、进程状态的生命周期</h3><p>一个典型的进程生命周期大致如下：</p><ol><li><p><strong>创建（Created）：</strong> 用 <code>fork()</code> 创建进程，父进程复制自身的内存空间。</p></li><li><p><strong>就绪（Ready）：</strong> 进程已准备好运行，等待 CPU 调度。</p></li><li><p><strong>运行（Running）：</strong> 进程正在被 CPU 执行。</p></li><li><p><strong>阻塞&#x2F;睡眠（Blocked&#x2F;Sleeping）：</strong> 进程等待外部事件（如 I&#x2F;O）完成 <strong>（可中断睡眠和不可中断睡眠）</strong>。</p><ul><li><strong>（挂起（Suspended）：通常由用户或调试器主动暂停进程（如 <code>CTRL + z</code>））</strong></li></ul></li><li><p><strong>终止（Terminated）：</strong> 进程执行完成或被强制终止。</p></li><li><p><strong>僵尸（Zombie）：</strong> 子进程结束后，父进程未回收其退出信息，导致子进程残留在进程表。</p></li><li><p><strong>销毁（Dead）：</strong> 僵尸进程被父进程回收后，彻底消失。</p></li></ol><h3 id="四、进程状态转换示意图"><a href="#四、进程状态转换示意图" class="headerlink" title="四、进程状态转换示意图"></a>四、进程状态转换示意图</h3><p><strong><span style="color:#CC0000;">这部分比较抽象，了解部分即可。</span></strong> 典型的转换流程：<strong>新建 (New) → 就绪 (R) → 运行 (R) ↔ 阻塞 (S&#x2F;D) → 终止 (Z&#x2F;X)</strong>，还有</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">+---------------------+         +-----------------------+</span><br><span class="line">|     创建 (New)       |         | 不可中断睡眠 (D)       |</span><br><span class="line">+---------------------+         +-----------------------+</span><br><span class="line">          ↓                              ↑</span><br><span class="line">+---------------------+  等待事件完成      |</span><br><span class="line">| 可运行/运行中 (R)    | ←--------------→ | 可中断睡眠 (S)   |</span><br><span class="line">+---------------------+  调度器分配 CPU   +---------------------+</span><br><span class="line">          |  ↑                   ↑               |</span><br><span class="line">          |  |                   | 等待硬件操作  | 挂起信号</span><br><span class="line">          ↓  |                   ↓               ↓</span><br><span class="line">+---------------------+                  +---------------------+</span><br><span class="line">| 停止 (T)             | ← SIGSTOP/SIGTSTP |  终止/僵尸 (Z)      |</span><br><span class="line">+---------------------+                  +---------------------+</span><br><span class="line">          |                                      |</span><br><span class="line">          | SIGCONT                              ↓</span><br><span class="line">          ↓                              +---------------------+</span><br><span class="line">+---------------------+                  |      回收 (X)         |</span><br><span class="line">| 可运行/运行中 (R)    | → 父进程回收 →    +---------------------+</span><br><span class="line">+---------------------+</span><br></pre></td></tr></table></figure><p><strong>进程的状态模型并没有一个单一的官方标准定义，而是根据不同的操作系统和理论模型有不同的实现。</strong> 不过，通常讨论的 <strong>三态、五态和七态模型</strong> 是基于操作系统的进程管理理论中的常见模型。</p><blockquote><p>  [!WARNING]</p><p>  下面是从网络上找的相关图片，<span style="color:#CC0000;">只是 <strong>偏向正确</strong>，因为没有具体标准定义！</span></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250317165240002.png" alt="image-20250317165239824"></p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250317212904250.png" alt="image-20250317212904093"></p><hr><h3 id="实验-1：僵尸进程的创建与监控"><a href="#实验-1：僵尸进程的创建与监控" class="headerlink" title="实验 1：僵尸进程的创建与监控"></a>实验 1：僵尸进程的创建与监控</h3><h4 id="1-实验步骤"><a href="#1-实验步骤" class="headerlink" title="1. 实验步骤"></a>1. 实验步骤</h4><ol><li><strong>编写僵尸进程代码</strong>：父进程创建子进程后，子进程立即退出，但父进程不调用 <code>wait()</code> 去回收子进程的资源，从而让子进程变成僵尸进程。</li><li><strong>编译与运行</strong>：运行代码后，使用 <code>ps</code> 命令在另一个终端监控进程状态。</li><li><strong>观察现象</strong>：子进程退出后，父进程没有回收它，它的状态会变成 <code>Z</code>（Zombie）。</li></ol><h4 id="2-僵尸进程代码："><a href="#2-僵尸进程代码：" class="headerlink" title="2. 僵尸进程代码："></a>2. 僵尸进程代码：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid = fork();                 <span class="comment">// 创建子进程</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fork失败&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)                  <span class="comment">// 子进程</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;子进程（PID：%d）正在运行...\n&quot;</span>, getpid());</span><br><span class="line">        sleep(<span class="number">5</span>);                       <span class="comment">// 子进程运行5秒后退出</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;子进程（PID：%d）即将退出...\n&quot;</span>, getpid());</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>                                <span class="comment">// 父进程</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;父进程（PID：%d）正在运行...\n&quot;</span>, getpid());</span><br><span class="line">        sleep(<span class="number">30</span>);                      <span class="comment">// 父进程等待30秒（不调用wait()，导致子进程成为僵尸进程）</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;父进程结束。\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-运行步骤："><a href="#3-运行步骤：" class="headerlink" title="3. 运行步骤："></a>3. 运行步骤：</h4><ol><li>编译代码：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc corpse.c -o corpse</span><br></pre></td></tr></table></figure><ol start="2"><li>运行程序：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./corpse</span><br></pre></td></tr></table></figure><ol start="3"><li>在另一个终端用 <code>ps</code> 命令观察：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -eo pid,ppid,<span class="built_in">stat</span>,cmd | grep <span class="string">&#x27;Z&#x27;</span></span><br></pre></td></tr></table></figure><ol><li><p><strong>现象</strong>：你会发现子进程的 <code>STAT</code> 显示为 <code>Z</code>，说明它已变成僵尸进程。</p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250317202057511.png" alt="image-20250317202057393"></p></li><li><p><strong>危害</strong>：</p><ul><li><strong>PID 资源耗尽</strong>：僵尸进程本身不消耗资源，但它的 PID （进程标识符）不会被释放。如果系统产生大量僵尸进程，PID 会被耗尽，导致新进程无法创建！</li><li><strong>内存泄漏</strong>：内核保留僵尸进程的退出状态和资源描述符，直到父进程回收。</li></ul></li><li><p><strong>解决办法</strong>：通过 <code>kill</code> 杀掉父进程，僵尸进程会被 <code>init</code> 进程回收。</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> -9 父进程PID<span class="comment"># 终止父进程，子进程由 init 进程回收</span></span><br></pre></td></tr></table></figure><hr><h3 id="实验-2：孤儿进程的创建与监控"><a href="#实验-2：孤儿进程的创建与监控" class="headerlink" title="实验 2：孤儿进程的创建与监控"></a>实验 2：孤儿进程的创建与监控</h3><h4 id="1-实验步骤："><a href="#1-实验步骤：" class="headerlink" title="1. 实验步骤："></a>1. 实验步骤：</h4><ol><li><strong>编写孤儿进程代码</strong>：父进程创建子进程后，父进程主动退出，子进程被 <code>init</code> 进程接管。</li><li><strong>编译与运行</strong>：运行代码后，用 <code>ps</code> 命令监控子进程的 <code>PPID</code>（父进程 ID）。</li><li><strong>观察现象</strong>：父进程退出后，子进程的 <code>PPID</code> 变成 <code>1</code>（即 <code>init</code> 进程）。</li></ol><h4 id="2-孤儿进程代码："><a href="#2-孤儿进程代码：" class="headerlink" title="2. 孤儿进程代码："></a>2. 孤儿进程代码：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid = fork();                 <span class="comment">// 创建子进程</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fork 失败&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)                  <span class="comment">// 子进程逻辑</span></span><br><span class="line">    &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);                       <span class="comment">// 确保父进程先退出</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;子进程 PID: %d, PPID: %d\n&quot;</span>, getpid(), getppid());</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sleep(<span class="number">10</span>);                  <span class="comment">// 保持子进程存活，方便观察</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>                                <span class="comment">// 父进程逻辑</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;父进程 PID: %d 创建了子进程 PID: %d，然后退出\n&quot;</span>, getpid(), pid);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);                        <span class="comment">// 父进程主动退出，产生孤儿进程</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-运行步骤：-1"><a href="#3-运行步骤：-1" class="headerlink" title="3. 运行步骤："></a>3. 运行步骤：</h4><ol><li>编译代码：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc orphan.c -o orphan</span><br></pre></td></tr></table></figure><ol start="2"><li>运行程序：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./orphan</span><br></pre></td></tr></table></figure><ol start="3"><li>在另一个终端用 <code>ps</code> 命令观察：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -eo pid,ppid,<span class="built_in">stat</span>,cmd | grep 子进程PID</span><br></pre></td></tr></table></figure><ol><li><p><strong>现象</strong>：你会发现子进程的 <code>PPID</code> 变成 <code>1</code>，说明它被 <code>init</code> 进程接管，变成了孤儿进程。</p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250317203906200.png" alt="image-20250317203906101"></p></li><li><p><strong>危害</strong>：<strong>孤儿进程一般不会直接危害系统</strong>，主要分下面几种情况（<strong>这就像一个“扫地机器人”：只有当进程“倒下”（退出）时，<code>init</code> 才来打扫；如果进程一直乱跑或者不断“生孩子”，<code>init</code> 也束手无策。</strong>）：</p><ul><li><p><strong>自动回收机制：</strong></p><ul><li>当父进程退出后，孤儿进程会被 <code>init</code> 进程（PID &#x3D; 1）收养。</li><li><code>init</code> 进程会定期调用 <code>wait()</code> 来回收那些已经结束的子进程，避免出现僵尸进程。</li></ul></li><li><p><strong>陷入死循环的情况：</strong></p><ul><li>如果孤儿进程本身陷入死循环（比如 <code>while (1) &#123; sleep(1); &#125;</code>），它不会退出，自然也不会被 <code>init</code> 回收。</li><li><code>init</code> 只能回收已经 <strong>退出的子进程</strong>。如果孤儿进程一直在运行，<code>init</code> 什么也做不了。</li></ul></li><li><p><strong>大量创建子进程的情况：</strong></p><ul><li><p>孤儿进程本身如果大量 <code>fork()</code> 创建新子进程，这些子进程同样会被它的父进程（即原孤儿进程）管理。</p></li><li><p>如果原孤儿进程随后退出，那么它创建的子进程就会变成新的孤儿进程，<code>init</code> 会接管它们。</p></li><li><p>如果这种行为持续发生，系统的进程表（PID 资源）可能会被快速耗尽，导致系统无法创建新进程，从而影响稳定性。</p></li></ul></li></ul></li><li><p><strong>解决办法</strong>：手动杀掉孤儿进程：</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> -9 子进程PID</span><br></pre></td></tr></table></figure><hr><h4 id="4-对比总结"><a href="#4-对比总结" class="headerlink" title="4. 对比总结"></a>4. 对比总结</h4><blockquote><p>  [!NOTE]</p><ol><li><strong>孤儿进程的资源会被回收吗？</strong><ul><li>是的，<code>init</code> 进程会主动回收孤儿进程。</li></ul></li><li><strong>僵尸进程和孤儿进程哪个更危险？</strong><ul><li>僵尸进程，因为长期占用系统资源。</li></ul></li></ol></blockquote><table><thead><tr><th align="left"><strong>特性</strong></th><th align="left"><strong>僵尸进程</strong></th><th align="left"><strong>孤儿进程</strong></th></tr></thead><tbody><tr><td align="left"><strong>产生条件</strong></td><td align="left">子进程终止，父进程未调用 <code>wait()</code></td><td align="left">父进程终止，子进程仍在运行</td></tr><tr><td align="left"><strong>危害</strong></td><td align="left">占用 PID 和内核资源</td><td align="left">一般无危害（主要由 init 进程自动回收）</td></tr><tr><td align="left"><strong>状态符号</strong></td><td align="left"><code>Z</code> (Zombie)</td><td align="left">无特殊状态，PPID 变为 1</td></tr><tr><td align="left"><strong>处理方式</strong></td><td align="left">终止父进程或修复父进程代码调用 <code>wait()</code></td><td align="left">通常无需处理</td></tr><tr><td align="left"><strong>系统影响</strong></td><td align="left">可能导致 PID 耗尽</td><td align="left">无负面影响</td></tr></tbody></table><hr><h3 id="五、进程的优先级"><a href="#五、进程的优先级" class="headerlink" title="五、进程的优先级"></a>五、进程的优先级</h3><p>在 Linux 系统中，进程的优先级（Priority）决定了调度器（Scheduler）选择哪个进程优先运行。这里有两个关键概念：<strong>PRI（优先级）</strong> 和 <strong>NI（静态优先级&#x2F;Nice 值）</strong>。</p><table><thead><tr><th align="left">名称</th><th align="left">全称</th><th align="left">范围</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left"><strong>PRI</strong></td><td align="left">Priority</td><td align="left"><strong>0~139</strong></td><td align="left">进程的实际优先级，<strong>值越小优先级越高</strong></td></tr><tr><td align="left"><strong>NI</strong></td><td align="left">Nice Value</td><td align="left"><strong>-20~19</strong></td><td align="left">用户可调整的优先级修正值，影响 PRI，NI 是用户可调节的值，<strong>用来“建议”系统优先级，但最终还是由内核决定。</strong></td></tr></tbody></table><hr><h4 id="1-PRI（Priority，优先级）："><a href="#1-PRI（Priority，优先级）：" class="headerlink" title="1. PRI（Priority，优先级）："></a>1. PRI（Priority，优先级）：</h4><ul><li><strong>定义</strong>：表示内核调度时分配给进程的优先级。<strong>数值越小，优先级越高。</strong></li><li>范围：<ul><li><strong>内核视角</strong>：<code>PRI</code> 范围 <code>0 ~ 139</code> 是进程的 <strong>真实优先级</strong>，值越小优先级越高。</li><li><strong>用户视角</strong>：<strong>实时进程的优先级是 <code>0 ~ 99</code></strong>（适合对实时性要求高的任务，如工业控制、音视频处理等），<strong>普通进程的优先级是 <code>100 ~ 139</code></strong>（普通用户任务，如文本编辑器、浏览器等）。</li></ul></li><li><strong>决定因素</strong>：<code>PRI = 20 + NI</code>（普通进程），<code>nice</code> 值影响普通进程的优先级，但 <strong>不会直接影响实时进程的优先级</strong>。</li><li><strong>查看命令</strong>：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -eo pid,pri,ni,<span class="built_in">comm</span></span><br></pre></td></tr></table></figure><p>输出示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> PID PRI NI COMMAND</span><br><span class="line">   1  80  0 systemd</span><br><span class="line">1234  90 10 python</span><br><span class="line">5678  70 -5 nginx</span><br></pre></td></tr></table></figure><p><strong>或者：<code>top</code> 命令</strong>，在 <code>top</code> 界面里：</p><ul><li>按 <strong>f</strong> 键进入字段选择界面，找到 <strong>PRI</strong> 和 <strong>NI</strong>，按空格键选中后回车返回主界面，即可看到优先级信息。</li><li>PRI 和 NI 默认就会显示在列表中。</li></ul><hr><h4 id="2-NI（Nice-值）："><a href="#2-NI（Nice-值）：" class="headerlink" title="2. NI（Nice 值）："></a>2. NI（Nice 值）：</h4><ul><li><p><strong>公式：<code>PRI (新) = PRI (默认) + NI</code></strong></p><ul><li>默认 PRI 通常为 <strong>80</strong>（不同系统可能不同），因此实际 PRI 范围是：<code>80 + (-20) = 60</code>（最高优先级） 到 <code>80 + 19 = 99</code>（最低优先级）。</li></ul></li><li><p><strong>定义</strong>：影响普通进程的优先级（PRI），表示“进程对 CPU 资源的友好程度”。数值越高，优先级越低，越“谦让”。当 <code>nice</code> 值为负值的时候，那么该程序将会优先级值将变小，即其优先级会变高，则其越快被执行。所以，调整进程优先级，在 Linux 下，就是调整进程 nice 值。</p></li><li><p><strong>范围</strong>：<code>-20</code>（最重要）到 <code>19</code>（最不重要），一共 40 个级别。默认值为 <code>0</code>。</p></li><li><p><strong>调整规则：NI 值越低，PRI 越小，进程优先级越高</strong></p><ul><li>普通用户只能 <strong>降低优先级</strong>（NI 值 ≥ 0）</li><li>Root 用户可 <strong>提升优先级</strong>（NI 值 &lt; 0）</li></ul></li><li><p><strong>关系</strong>：$PRI &#x3D; 20 + NI$</p><ul><li><code>NI = -20</code> → PRI &#x3D; 0 + 20 &#x3D; 20（最高优先级）</li><li><code>NI = 0</code> → PRI &#x3D; 0 + 20 &#x3D; 20（默认值）</li><li><code>NI = 19</code> → PRI &#x3D; 19 + 20 &#x3D; 39（最低优先级）</li></ul></li><li><p><strong>调整 NI 值</strong>：</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动时设置 nice 值</span></span><br><span class="line"><span class="built_in">nice</span> -n 10 ./可执行程序</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行中调整 nice 值</span></span><br><span class="line">renice -5 1234  <span class="comment"># 把 PID 为 1234 的进程 NI 调整到 -5</span></span><br></pre></td></tr></table></figure><h4 id="3-注意事项"><a href="#3-注意事项" class="headerlink" title="3. 注意事项"></a>3. 注意事项</h4><ol><li><strong>避免滥用高优先级</strong>：过多高优先级进程可能导致系统不稳定（如 GUI 无响应）。</li><li><strong>NI 值继承</strong>：子进程会继承父进程的 NI 值。</li></ol><h3 id="六、其他概念补充"><a href="#六、其他概念补充" class="headerlink" title="六、其他概念补充"></a>六、其他概念补充</h3><blockquote><p>  [!IMPORTANT]</p><ul><li><strong>竞争性</strong>：进程争抢 CPU、内存等资源。</li><li><strong>独立性</strong>：每个进程互不干扰，资源独立。</li><li><strong>并行</strong>：多核 CPU 下的真正“同时运行”。</li><li><strong>并发</strong>：单核 CPU 下的“快速切换”，让多个进程看似“同时进行”。</li></ul></blockquote><h4 id="1-竞争性（Competitiveness）："><a href="#1-竞争性（Competitiveness）：" class="headerlink" title="1. 竞争性（Competitiveness）："></a>1. 竞争性（Competitiveness）：</h4><ul><li><strong>定义</strong>：由于系统中的进程数量众多，而 CPU 资源有限（甚至可能只有 1 个），所以各个进程需要竞争 CPU 使用权。为了高效完成任务，更合理竞争相关资源，便有了优先级。</li><li>引申含义：<ul><li>系统通过调度算法来决定哪个进程先使用 CPU。</li><li>为了更合理地分配资源，引入了 <strong>优先级（Priority）</strong> 概念，优先级高的进程更有可能被调度运行。</li><li>竞争不局限于 CPU，进程还可能竞争内存、I&#x2F;O 设备等资源。</li></ul></li></ul><h4 id="2-独立性（Independence）："><a href="#2-独立性（Independence）：" class="headerlink" title="2. 独立性（Independence）："></a>2. 独立性（Independence）：</h4><ul><li><strong>定义</strong>：多进程运行时，每个进程都有自己独立的内存空间和资源，彼此不会直接影响。</li><li>特点：<ul><li>每个进程的执行逻辑、变量、文件描述符等都是独立的。</li><li>若需要通信，通常使用 <strong>进程间通信</strong> 机制，例如：管道（Pipe）、共享内存、消息队列等。</li></ul></li><li><strong>意义</strong>：独立性<strong>保证了系统稳定性，即使某个进程崩溃，其他进程也能正常运行</strong>。</li></ul><h4 id="3-并行（Parallelism）："><a href="#3-并行（Parallelism）：" class="headerlink" title="3. 并行（Parallelism）："></a>3. 并行（Parallelism）：</h4><ul><li><strong>定义</strong>：多个进程在多个 <strong>CPU</strong> 核心上<strong>同时</strong>运行，互不干扰，真正实现“同时进行”。</li><li><strong>条件</strong>：需要多核 CPU 或多台机器（分布式系统）支持。</li><li><strong>举例</strong>：在 4 核 CPU 上，4 个进程可以在每个核心上独立运行，互不干扰，实现真正的“并行”。</li></ul><h4 id="4-并发（Concurrency）："><a href="#4-并发（Concurrency）：" class="headerlink" title="4. 并发（Concurrency）："></a>4. 并发（Concurrency）：</h4><ul><li><strong>定义</strong>：多个进程在一个CPU下采用进程切换的方式，在一段时间之内，让多个进程都得以推进，称之为并发。（在单核 CPU 上，多个进程通过频繁的“<strong>时间片切换</strong>”，让每个进程在<strong>宏观上看起来同时执行</strong>）</li><li><strong>原理</strong>：CPU 每隔一段时间（时间片）切换到下一个进程执行，切换速度极快，人眼无法分辨，以为多个进程“同时”运行。</li><li><strong>举例</strong>：在单核 CPU 上运行多个下载任务，CPU 不断在不同任务之间切换，让所有任务都能逐步完成。</li></ul><blockquote><p>  [!NOTE]</p><h4 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h4><ul><li><strong>概念</strong>：在单 CPU 系统中，多个进程通过轮流使用 CPU 资源实现“并发”，这依赖于操作系统的“进程切换”。</li><li><strong>实现方式</strong>：采用调度算法（如<strong>时间片轮转</strong>的调度算法），每个进程被分配固定的时间片。时间片用完后，系统暂停该进程，保存状态，并切换到下一个进程执行。</li></ul><h4 id="上下文保存"><a href="#上下文保存" class="headerlink" title="上下文保存"></a>上下文保存</h4><ul><li><strong>意义</strong>：确保进程被切换时，其运行状态（即“上下文”）被妥善保存，待下次恢复执行。上下文是指进程执行时的环境状态，包括寄存器的值、程序计数器的值等。</li><li><strong>保存内容</strong>：<ul><li><strong>通用寄存器</strong>：如eax、ebx、ecx、edx等，用于存储操作数和计算结果。</li><li><strong>栈指针和基指针</strong>：如ebp、esp，用于管理函数调用和局部变量的存储。</li><li><strong>程序计数器（eip）</strong>：记录当前进程正在执行指令的下一条指令的地址，决定了进程执行的流程。</li><li><strong>状态寄存器（status）</strong>：包含条件码等信息，用于判断指令执行后的状态。</li></ul></li><li><strong>保存时机</strong>：在进程被切换时，需要先保存当前进程的上下文，然后恢复下一个要执行进程的上下文。</li></ul><h4 id="寄存器的作用"><a href="#寄存器的作用" class="headerlink" title="寄存器的作用"></a>寄存器的作用</h4><ul><li><strong>通用寄存器</strong>：用于存储操作数和中间结果，提高数据访问速度，如在算术运算和数据处理指令中使用。</li><li><strong>程序计数器（eip）</strong>：指向进程下次执行的指令地址，是进程执行流程的关键。</li><li><strong>栈指针和基指针</strong>：用于管理函数调用时的参数传递和局部变量存储，维护函数调用栈的结构。</li><li><strong>状态寄存器</strong>：保存CPU的状态信息，如进位标志、零标志等，用于条件判断和跳转指令。</li></ul><h4 id="进程切换的具体步骤"><a href="#进程切换的具体步骤" class="headerlink" title="进程切换的具体步骤"></a>进程切换的具体步骤</h4><ol><li><strong>保存当前进程上下文</strong>：暂停当前进程，将寄存器、程序计数器等保存到该进程的控制块（如 <code>task_struct</code>）中。</li><li><strong>更新进程状态</strong>：将当前进程状态改为“就绪”或“等待”，并加入对应队列。</li><li><strong>选择新进程</strong>：根据调度算法（如优先级调度）选择下一个要执行的进程。</li><li><strong>恢复新进程上下文</strong>：从新进程的控制块恢复寄存器和程序计数器等信息。</li><li><strong>切换至新进程</strong>：CPU 开始执行新进程的指令，完成切换。</li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 进程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>011 Linux进程</title>
      <link href="/posts/4610.html"/>
      <url>/posts/4610.html</url>
      
        <content type="html"><![CDATA[<h2 id="深入理解-Linux-进程管理"><a href="#深入理解-Linux-进程管理" class="headerlink" title="深入理解 Linux 进程管理"></a>深入理解 Linux 进程管理</h2><h3 id="一、管理哲学-本质：先描述，再组织（校长如何管理学校？）"><a href="#一、管理哲学-本质：先描述，再组织（校长如何管理学校？）" class="headerlink" title="一、管理哲学&#x2F;本质：先描述，再组织（校长如何管理学校？）"></a>一、管理哲学&#x2F;本质：先描述，再组织（校长如何管理学校？）</h3><p>一个操作系统不仅仅只能运行一个进程，可以同时运行多个进程。操作系统的进程管理：<strong>先描述，在组织</strong> → 任何一个进程。在操作系统中，管理任何对象，最终都可以转化成为对某种数据结构的增删查改。想象你是一所大学的校长，管理数万名学生。你不需要认识每个学生，只需通过 <strong>学生档案系统</strong> 管理：</p><ul><li><strong>描述</strong>：每个学生有专属档案（学号、姓名、专业、成绩、宿舍号…）</li><li><strong>组织</strong>：档案按学院 → 专业 → 班级形成 <strong>链表结构</strong></li><li><strong>管理</strong>：调整专业只需修改档案中的“专业”字段，开除学生只需删除对应档案（<strong>增删查改</strong>）</li></ul><p><strong>操作系统管理进程同理</strong>：</p><ol><li><strong>描述</strong>：为每个进程创建 <code>task_struct</code>（进程的“档案”）</li><li><strong>组织</strong>：通过链表、队列等数据结构管理所有 <code>task_struct</code></li><li><strong>控制</strong>：调整优先级、终止进程等操作只需修改对应结构体</li></ol><p><strong>数据结构的作用</strong></p><ul><li><strong>学校</strong>：学生档案链表 → 管理学生 <strong>增删查改</strong>（如入学、转班、退学）。</li><li><strong>操作系统</strong>：进程 PCB 链表 → 管理进程的创建、调度、终止等。</li></ul><hr><h3 id="二、进程的定义与核心概念"><a href="#二、进程的定义与核心概念" class="headerlink" title="二、进程的定义与核心概念"></a>二、进程的定义与核心概念</h3><h4 id="1-什么是进程？"><a href="#1-什么是进程？" class="headerlink" title="1. 什么是进程？"></a>1. 什么是进程？</h4><ul><li><span style="color:#CC0000;"><strong>进程 &#x3D; 程序员自己写的代码和数据 + 内核 PCB 数据结构对象（描述进程的所有数据，process ctrl block → 进程控制块）</strong></span><ul><li><strong>程序</strong>：程序员编写的代码（如 <code>hello.c</code> 编译后的可执行文件 <code>hello</code>）。</li><li><strong>进程</strong>：程序被加载到内存中运行的实例（如运行 <code>./hello</code> 后生成的进程）。</li></ul></li><li><strong>关键点</strong>：<ul><li>进程是动态的：程序本身是静态文件，进程是运行时的实体。</li><li>每个进程都有自己的 <strong>PCB</strong>（进程控制块），存储进程的所有信息。</li></ul></li></ul><h4 id="2-进程管理的核心：进程控制块（PCB）"><a href="#2-进程管理的核心：进程控制块（PCB）" class="headerlink" title="2. 进程管理的核心：进程控制块（PCB）"></a>2. 进程管理的核心：进程控制块（PCB）</h4><ul><li><strong>PCB 的作用</strong>：记录进程的所有属性，帮助内核管理进程。</li><li><strong>Linux 中的 PCB</strong>：名为 <code>task_struct</code> 的结构体（C 语言中的结构体）。</li><li><strong>类比</strong>：就像学生的学籍档案，记录了学号、成绩、班级、状态等。</li></ul><hr><h3 id="三、Linux-的-task-struct-详解（进程控制块的实现）"><a href="#三、Linux-的-task-struct-详解（进程控制块的实现）" class="headerlink" title="三、Linux 的 task_struct 详解（进程控制块的实现）"></a>三、Linux 的 <code>task_struct</code> 详解（进程控制块的实现）</h3><h4 id="1-task-struct-的结构（进程的-DNA）"><a href="#1-task-struct-的结构（进程的-DNA）" class="headerlink" title="1. task_struct 的结构（进程的 DNA）"></a>1. <code>task_struct</code> 的结构（进程的 DNA）</h4><p>在 Linux 内核中，进程属性的集合 <code>task_struct</code> 是一个庞大的结构体（约有数百个字段），<code>task_struct</code> 是 Linux 内核的一种数据结构，它会被装载到 RAM(内存)里并且包含着进程的信息。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简化版 task_struct 结构（Linux内核真实结构复杂得多）</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">task_struct</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> pid;                <span class="comment">// 身份证号（进程唯一标识）</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">long</span> state;      <span class="comment">// 当前状态（睡觉/跑步/待机）</span></span><br><span class="line">    <span class="type">int</span> priority;            <span class="comment">// VIP等级（优先级）</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">mm_struct</span> *mm;    <span class="comment">// 家庭住址（内存分配情况）</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">files_struct</span> *files; <span class="comment">// 随身物品（打开的文件）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 相关指针信息：</span></span><br><span class="line">    structPCB *next</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">PCB</span> *queue</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">PCB</span> *xxxxx</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// ... 上百个字段</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="关键字段解析（下面详解）："><a href="#关键字段解析（下面详解）：" class="headerlink" title="关键字段解析（下面详解）："></a>关键字段解析（下面详解）：</h5><table><thead><tr><th>字段</th><th>类比</th><th>作用</th></tr></thead><tbody><tr><td>pid</td><td>学号</td><td>唯一标识进程（<code>ps -ef</code> 查看）</td></tr><tr><td>state</td><td>学生状态（上课&#x2F;请假）</td><td>进程状态：运行（R）、睡眠（S）、僵尸（Z）等</td></tr><tr><td>priority</td><td>奖学金等级</td><td>优先级高的进程优先使用 CPU（<code>nice</code> 命令调整）</td></tr><tr><td>mm_struct</td><td>宿舍分配表</td><td>记录进程使用的内存空间（代码段、数据段、堆栈等）</td></tr><tr><td>files_struct</td><td>书包里的书本</td><td>记录进程打开的所有文件（<code>lsof -p &lt;pid&gt;</code> 查看）</td></tr><tr><td>上下文数据</td><td>课堂笔记</td><td>保存 CPU 寄存器的值，用于中断后恢复现场</td></tr></tbody></table><hr><h4 id="1-标识符（Identity）"><a href="#1-标识符（Identity）" class="headerlink" title="1. 标识符（Identity）"></a>1. 标识符（Identity）</h4><ul><li><strong>pid（进程 ID）</strong>：唯一标识符，类似学生的学号。每个进程有唯一的 PID，通过 <code>ps</code> 命令可见。</li><li><strong>ppid（父进程 ID）</strong>：记录该进程的父进程 PID，形成父子进程关系。类比：学生档案中记录班主任的工号。</li></ul><h4 id="2-状态（State）"><a href="#2-状态（State）" class="headerlink" title="2. 状态（State）"></a>2. 状态（State）</h4><ul><li><p><strong>进程状态</strong>：进程当前所处的阶段，包括：</p><ul><li><strong>运行态（Running）</strong>：正在 CPU 上执行。</li><li><strong>就绪态（Runnable）</strong>：等待调度到 CPU 上运行。</li><li><strong>阻塞态（Blocked）</strong>：等待 I&#x2F;O（如读写文件）、等待信号等。</li><li><strong>终止态（Zombie）</strong>：进程已结束，但父进程未回收其资源（成为“僵尸”）。</li></ul></li><li><p><strong>字段示例</strong>：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">long</span> state;  <span class="comment">// 进程状态（如TASK_RUNNING, TASK_INTERRUPTIBLE）</span></span><br><span class="line"><span class="type">int</span> exit_code;        <span class="comment">// 进程退出时的返回值</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="3-优先级（Priority）"><a href="#3-优先级（Priority）" class="headerlink" title="3. 优先级（Priority）"></a>3. 优先级（Priority）</h4><ul><li><p><strong>调度优先级</strong>：决定进程获得 CPU 时间的“权重”。</p><ul><li><strong>nice 值</strong>：用户可调整的优先级（值越低，优先级越高）。</li><li><strong>实时优先级</strong>：用于需要严格实时性的进程（如音频播放）。</li></ul></li><li><p><strong>字段示例</strong>：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> nice;             <span class="comment">// nice值（-20到19，默认0）</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> policy; <span class="comment">// 调度策略（如SCHED_OTHER普通进程）</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="4-程序计数器（Program-Counter）"><a href="#4-程序计数器（Program-Counter）" class="headerlink" title="4. 程序计数器（Program Counter）"></a>4. 程序计数器（Program Counter）</h4><ul><li><strong>寄存器状态</strong>：记录进程执行到的位置。<ul><li><strong>pc（程序计数器）</strong>：指向当前指令的下一条指令的地址。</li><li><strong>其他寄存器</strong>：如栈指针（<code>rsp</code>）、基指针（<code>rbp</code>）等，保存进程执行现场。</li></ul></li><li><strong>作用</strong>：当进程被中断（如切换到其他进程），内核会保存这些寄存器的值，以便恢复执行。</li></ul><h4 id="5-上下文（Context）"><a href="#5-上下文（Context）" class="headerlink" title="5. 上下文（Context）"></a>5. 上下文（Context）</h4><ul><li><strong>上下文数据</strong>：进程执行时的所有硬件寄存器的值。<ul><li>类比：学生临时离开教室前，记录自己写到哪页笔记、用哪支笔。</li><li><strong>保存场景</strong>：当进程被中断（如 I&#x2F;O 请求），内核将寄存器值保存到 <code>task_struct</code>。</li><li><strong>恢复场景</strong>：当进程重新调度到 CPU 时，内核恢复这些寄存器值，继续执行。</li></ul></li></ul><h4 id="6-内存与资源信息"><a href="#6-内存与资源信息" class="headerlink" title="6. 内存与资源信息"></a>6. 内存与资源信息</h4><ul><li><strong>内存指针</strong>：记录进程的代码、数据、堆栈的内存地址。<ul><li><strong>代码段（text 段）</strong>：程序指令的内存区域。</li><li><strong>数据段（data 段）</strong>：全局变量、堆栈等。</li><li><strong>共享内存</strong>：与其他进程共享的内存块指针。</li></ul></li><li><strong>资源列表</strong>：<ul><li>打开的文件描述符（如 <code>/dev/sda</code>）。</li><li>分配的 I&#x2F;O 设备（如 USB 设备）。</li></ul></li></ul><h4 id="7-I-O-状态"><a href="#7-I-O-状态" class="headerlink" title="7. I&#x2F;O 状态"></a>7. I&#x2F;O 状态</h4><ul><li><strong>I&#x2F;O 请求队列</strong>：记录进程等待的 I&#x2F;O 操作（如读取硬盘）。</li><li><strong>分配的设备</strong>：进程当前占用的硬件设备。</li></ul><h4 id="8-记账信息（Accounting）"><a href="#8-记账信息（Accounting）" class="headerlink" title="8. 记账信息（Accounting）"></a>8. 记账信息（Accounting）</h4><ul><li><strong>CPU 时间统计</strong>：<ul><li><code>utime</code>：用户模式下消耗的 CPU 时间。</li><li><code>stime</code>：内核模式下消耗的 CPU 时间。</li></ul></li><li><strong>时间限制</strong>：如进程允许的最大运行时间。</li><li><strong>记账用户</strong>：记录进程属于哪个用户（如 <code>root</code> 或普通用户）。</li></ul><h4 id="9-其他信息"><a href="#9-其他信息" class="headerlink" title="9. 其他信息"></a>9. 其他信息</h4><ul><li><strong>信号处理</strong>：记录进程如何处理信号（如 <code>SIGTERM</code> 终止信号）。</li><li><strong>线程信息</strong>：如果是多线程程序，记录线程组信息。</li><li><strong>调度队列指针</strong>：指向进程所在的就绪队列或阻塞队列。</li></ul><hr><h3 id="四、组织进程"><a href="#四、组织进程" class="headerlink" title="四、组织进程"></a>四、组织进程</h3><p>可以在内核源代码里找到它。所有运行在系统里的进程都以 <code>task_struct</code> 链表等非常复杂的数据结构的形式存在内核里。</p><hr><h3 id="五、查看进程"><a href="#五、查看进程" class="headerlink" title="五、查看进程"></a>五、查看进程</h3><h4 id="1-查看进程方法"><a href="#1-查看进程方法" class="headerlink" title="1. 查看进程方法"></a>1. 查看进程方法</h4><p>在 Linux 中，进程（Process）是正在运行的程序实例。查看进程的常用命令有：</p><ul><li><strong><code>ps</code></strong>：最常用的进程查看工具，适合快速查看进程快照（<strong>静态结果输出</strong>）。</li><li><strong><code>top</code></strong>：动态监控进程，适合实时观察系统状态（<strong>动态查看进程变化，默认 5 秒更新</strong>）。</li><li><strong><code>htop</code></strong>：增强版 <code>top</code>，界面更友好，适合交互式操作。</li><li><strong>其他命令</strong>：如 <code>pgrep</code>、<code>pidof</code> 等，适合精准定位进程。</li></ul><hr><h5 id="1-ps-相关命令"><a href="#1-ps-相关命令" class="headerlink" title="1. ps 相关命令"></a>1. <code>ps</code> 相关命令</h5><p>当直接输入 <code>ps</code> 而不带任何参数时，命令会：</p><ul><li><strong>仅显示当前终端会话中的进程</strong>，即与当前终端关联的进程。</li><li>输出内容较为简洁，仅包含以下字段：<ul><li><strong>PID</strong>：进程 ID。</li><li><strong>TTY</strong>：进程关联的终端（如 <code>pts/0</code> 表示伪终端）。</li><li><strong>TIME</strong>：进程占用的 CPU 时间。</li><li><strong>CMD</strong>：启动进程的命令名及参数。</li></ul></li></ul><table><thead><tr><th>命令&#x2F;选项</th><th>说明</th><th>示例</th><th>常用度</th></tr></thead><tbody><tr><td><code>ps aux</code></td><td>显示所有用户的进程，包含详细信息（用户、CPU、内存等）</td><td><code>ps aux</code></td><td>⭐⭐⭐⭐⭐</td></tr><tr><td><code>ps -ef</code></td><td>显示全格式进程信息（更详细的进程信息，常用于系统管理和脚本，含 PPID）</td><td><code>ps -ef</code></td><td>⭐⭐⭐⭐⭐</td></tr><tr><td><code>ps -e</code></td><td>显示所有进程</td><td><code>ps -e</code></td><td>⭐⭐⭐</td></tr><tr><td><code>ps -u &lt;用户&gt;</code></td><td>显示指定用户的进程</td><td><code>ps -u root</code></td><td>⭐⭐⭐</td></tr><tr><td><code>ps -p &lt;PID&gt;</code></td><td>显示指定 PID 的进程信息</td><td><code>ps -p 1234</code></td><td>⭐⭐⭐⭐</td></tr><tr><td><code>ps -o</code></td><td>按需展示特定字段，常与 <code>-p</code> 结合使用（如 PID、PPID、CMD 等）</td><td><code>ps -o pid,ppid,cmd,%mem,%cpu</code></td><td>⭐⭐⭐⭐</td></tr><tr><td><code>ps aux --sort</code></td><td>按指定字段排序（如内存、CPU）</td><td><code>ps aux --sort=-%mem</code></td><td>⭐⭐⭐⭐</td></tr><tr><td><code>ps auxf</code></td><td>以树状结构显示进程</td><td><code>ps auxf</code></td><td>⭐⭐⭐⭐</td></tr></tbody></table><h5 id="2-top-相关命令（按-q-退出）"><a href="#2-top-相关命令（按-q-退出）" class="headerlink" title="2. top 相关命令（按 q 退出）"></a>2. <code>top</code> 相关命令（按 <code>q</code> 退出）</h5><table><thead><tr><th>命令&#x2F;选项</th><th>说明</th><th>示例</th><th>常用度</th></tr></thead><tbody><tr><td><code>top</code></td><td>实时动态查看进程状态（类似任务管理器）</td><td><code>top</code></td><td>⭐⭐⭐⭐⭐</td></tr><tr><td><code>top -c</code></td><td>显示完整命令路径</td><td><code>top -c</code></td><td>⭐⭐⭐⭐</td></tr><tr><td><code>top -p &lt;PID&gt;</code></td><td>监控指定 PID 的进程</td><td><code>top -p 1234</code></td><td>⭐⭐⭐</td></tr><tr><td><code>top -u &lt;用户&gt;</code></td><td>监控指定用户的进程</td><td><code>top -u root</code></td><td>⭐⭐⭐</td></tr><tr><td><code>top -b</code></td><td>以批处理模式运行，输出到文件</td><td><code>top -b -n 1 &gt; top.log</code></td><td>⭐⭐⭐</td></tr><tr><td><code>top -n &lt;次数&gt;</code></td><td>指定刷新次数后退出</td><td><code>top -n 3</code></td><td>⭐⭐⭐</td></tr></tbody></table><h5 id="3-htop-相关命令"><a href="#3-htop-相关命令" class="headerlink" title="3. htop 相关命令"></a>3. <code>htop</code> 相关命令</h5><table><thead><tr><th>命令&#x2F;选项</th><th>说明</th><th>示例</th><th>常用度</th></tr></thead><tbody><tr><td><code>htop</code></td><td>增强版 top，支持鼠标操作和颜色高亮（需安装：<code>yum install htop</code>）</td><td><code>htop</code></td><td>⭐⭐⭐⭐⭐</td></tr><tr><td><code>htop -u &lt;用户&gt;</code></td><td>显示指定用户的进程</td><td><code>htop -u root</code></td><td>⭐⭐⭐⭐</td></tr><tr><td><code>htop -p &lt;PID&gt;</code></td><td>显示指定 PID 的进程</td><td><code>htop -p 1234</code></td><td>⭐⭐⭐</td></tr><tr><td><code>htop -d &lt;秒&gt;</code></td><td>设置刷新间隔时间</td><td><code>htop -d 5</code></td><td>⭐⭐⭐</td></tr></tbody></table><h5 id="4-其他进程相关命令"><a href="#4-其他进程相关命令" class="headerlink" title="4. 其他进程相关命令"></a>4. 其他进程相关命令</h5><table><thead><tr><th>命令&#x2F;选项</th><th>说明</th><th>示例</th><th>常用度</th></tr></thead><tbody><tr><td><code>pgrep</code></td><td>根据名称查找 PID（支持模糊匹配）</td><td><code>pgrep sshd</code></td><td>⭐⭐⭐⭐</td></tr><tr><td><code>pgrep -l</code></td><td>显示进程名和 PID</td><td><code>pgrep -l ssh</code></td><td>⭐⭐⭐⭐</td></tr><tr><td><code>pidof</code></td><td>根据精确进程名查找 PID</td><td><code>pidof nginx</code></td><td>⭐⭐⭐</td></tr><tr><td><code>pstree</code></td><td>以树状结构显示进程关系（需安装：<code>yum install psmisc</code>）</td><td><code>pstree -p</code></td><td>⭐⭐⭐</td></tr><tr><td><code>kill &lt;PID&gt;</code></td><td>终止指定进程</td><td><code>kill 1234</code></td><td>⭐⭐⭐</td></tr><tr><td><code>kill -9 &lt;PID&gt;</code></td><td>强制杀死进程</td><td><code>kill -9 1234</code></td><td>⭐⭐⭐⭐</td></tr></tbody></table><h5 id="5-proc-文件系统"><a href="#5-proc-文件系统" class="headerlink" title="5. /proc 文件系统"></a>5. <code>/proc</code> 文件系统</h5><table><thead><tr><th>命令&#x2F;路径</th><th>说明</th><th>示例</th><th>常用度</th></tr></thead><tbody><tr><td><code>/proc/[PID]/status</code></td><td>查看进程的详细状态信息</td><td><code>cat /proc/1234/status</code></td><td>⭐⭐⭐⭐</td></tr><tr><td><code>/proc/[PID]/cmdline</code></td><td>查看进程的启动命令</td><td><code>cat /proc/1234/cmdline</code></td><td>⭐⭐⭐</td></tr><tr><td><code>/proc/[PID]/exe</code></td><td>查看进程对应的可执行文件</td><td><code>ls -l /proc/1234/exe</code></td><td>⭐⭐⭐</td></tr><tr><td><code>/proc/[PID]/fd</code></td><td>查看进程打开的文件描述符</td><td><code>ls -l /proc/1234/fd</code></td><td>⭐⭐⭐</td></tr></tbody></table><hr><h4 id="2-通过系统调用获取进程标识符"><a href="#2-通过系统调用获取进程标识符" class="headerlink" title="2. 通过系统调用获取进程标识符"></a>2. 通过系统调用获取进程标识符</h4><ol><li><strong>C 程序示例</strong></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>  <span class="comment">// 提供 getpid(), getppid(), 和 sleep()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 获取当前进程 ID</span></span><br><span class="line">        <span class="type">pid_t</span> pid = getpid();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;当前进程 ID (PID): %d\n&quot;</span>, pid);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取父进程 ID</span></span><br><span class="line">        <span class="type">pid_t</span> ppid = getppid();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;父进程 ID (PPID): %d\n&quot;</span>, ppid);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 睡眠 1 秒</span></span><br><span class="line">        sleep(<span class="number">1</span>);  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>编译</strong></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o getpid getpid.c</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>运行</strong></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./getpid</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>示例输出</strong></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">当前进程 <span class="built_in">ID</span> (PID): <span class="number">1195</span></span><br><span class="line">父进程 <span class="built_in">ID</span> (PPID): <span class="number">481</span></span><br></pre></td></tr></table></figure><hr><h4 id="3-fork-创建进程详解"><a href="#3-fork-创建进程详解" class="headerlink" title="3. fork() 创建进程详解"></a>3. <code>fork()</code> 创建进程详解</h4><blockquote><p><strong>摘自鸟哥的 <code>Linux</code> 私房菜基础学习篇（第四版）517页：</strong></p><p><strong><code>Linux</code> 的程序调用通常成为 <code>fork-and-exec</code> 的流程。进程都会借父进程以复制（<code>fork</code>）的方式产生一个一模一样的子进程，然后被复制出来的子进程再以 <code>exec</code> 的方式来执行实际要执行的进程，最终就成为一个子进程。</strong></p></blockquote><ol><li><strong>基础示例代码</strong></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;创建子进程失败&quot;</span>);                             <span class="comment">// 将标准错误输出的信息改为中文</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;子进程PID=%d, 父进程PPID=%d\n&quot;</span>, getpid(), getppid());  <span class="comment">// 子进程中打印的信息改为中文</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;父进程PID=%d, 创建的子进程PID=%d\n&quot;</span>, getpid(), pid);   <span class="comment">// 父进程中打印的信息改为中文</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>示例输出：</strong></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">父进程PID=2744, 创建的子进程PID=2745</span><br><span class="line">子进程PID=2745, 父进程PPID=2744</span><br></pre></td></tr></table></figure><p>注意：<strong>输出顺序可能不固定，取决于系统调度</strong>，再看下面一个示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;begin: 我是一个进程，pid: %d, ppid: %d\n&quot;</span>, getpid(), getppid());</span><br><span class="line">    <span class="type">pid_t</span> id = fork();</span><br><span class="line">    <span class="keyword">if</span> (id == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;我是子进程，pid: %d, ppid: %d\n&quot;</span>, getpid(), getppid());</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (id &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;我是父进程，pid: %d, ppid: %d\n&quot;</span>, getpid(), getppid());</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//error</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例输出：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">begin: 我是一个进程，pid: 3721, ppid: 481</span><br><span class="line">我是父进程，pid: 3721, ppid: 481</span><br><span class="line">我是子进程，pid: 3722, ppid: 3721</span><br><span class="line">我是父进程，pid: 3721, ppid: 481</span><br><span class="line">我是子进程，pid: 3722, ppid: 3721</span><br><span class="line">我是子进程，pid: 3722, ppid: 3721</span><br><span class="line">……</span><br></pre></td></tr></table></figure><blockquote><p>  [!IMPORTANT]</p><h4 id="1-为什么-fork-给子进程返回-0，给父进程返回子进程的-PID？"><a href="#1-为什么-fork-给子进程返回-0，给父进程返回子进程的-PID？" class="headerlink" title="1. 为什么 fork() 给子进程返回 0，给父进程返回子进程的 PID？"></a>1. 为什么 <code>fork()</code> 给子进程返回 <code>0</code>，给父进程返回子进程的 <code>PID</code>？</h4><p>  <code>fork()</code> 的目的是创建一个 <strong>几乎完全相同</strong> 的子进程（一般而言 <code>fork</code> 之后的代码父子共享）。让父子进程执行不同的代码分支。通过返回值区分父子进程的身份：</p><ul><li><strong>父进程</strong>：需要知道子进程的 <code>PID</code>，以便后续管理（如等待子进程退出、发送信号等）。</li><li><strong>子进程</strong>：无需知道自己的 <code>PID</code>（可通过 <code>getpid()</code> 获取），但需要明确自己是子进程（返回 <code>0</code> 是最直接的方式）。</li></ul><p>  <strong>实现意义</strong>：</p><ul><li>父进程通过子进程 <code>PID</code> 可以追踪、控制子进程（如 <code>waitpid()</code>）。</li><li>子进程通过返回值 <code>0</code> 知道自己是被创建的一方，从而执行子进程独有的逻辑。</li></ul><p>  <strong>总结：父进程通过返回值区分子进程，子进程通过返回值确认自己是子进程。</strong></p><hr><h4 id="2-fork-作为一个函数为什么能返回两次？如何理解？"><a href="#2-fork-作为一个函数为什么能返回两次？如何理解？" class="headerlink" title="2. fork() 作为一个函数为什么能返回两次？如何理解？"></a>2. <code>fork()</code> 作为一个函数为什么能返回两次？如何理解？</h4><p>  <strong><code>fork()</code> 本质上只调用一次，但返回两次！</strong> <code>fork()</code> 调用后，操作系统会复制父进程，创建一个新的子进程。</p><ul><li><p><strong>父进程</strong>：继续从 <code>fork()</code> 返回，得到子进程的 PID。</p></li><li><p><strong>子进程</strong>：从 <code>fork()</code> 返回，得到 0。</p></li><li><p><strong>示意图</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+----------------+</span><br><span class="line">| 父进程执行 fork() | --&gt; 子进程诞生</span><br><span class="line">+----------------+</span><br><span class="line">       |                  |</span><br><span class="line">       v                  v</span><br><span class="line">返回子进程 PID            返回 0</span><br></pre></td></tr></table></figure></li></ul><p>  看似一次调用返回两次，实际是两个独立的进程分别执行了 <code>fork()</code> 后的代码。可以把 <code>fork()</code> 想象成 <strong>一颗分叉的树</strong>：调用时是同一条路径，但执行后分成了两条路，各自独立运行。</p><hr><h4 id="3-为什么同一个变量在父子进程里内容不同？"><a href="#3-为什么同一个变量在父子进程里内容不同？" class="headerlink" title="3. 为什么同一个变量在父子进程里内容不同？"></a>3. 为什么同一个变量在父子进程里内容不同？</h4><p>  调用 <code>fork()</code> 时，子进程不会立即复制父进程的内存，而是共享同一份物理内存（标记为只读）。当父子进程 <strong>修改内存时</strong>，操作系统才会复制被修改的页（内存页的最小单位）。具体来说就是当 <code>fork()</code> 被调用时：</p><ol><li><strong>代码段（Code Segment）：</strong> 父子进程共享这部分内存，不需要复制。毕竟代码是静态的，读操作不会影响对方。</li><li><strong>数据段、堆、栈（Data, Heap, Stack）：</strong> 父子进程“看起来”各自独立，但实际上，系统不会立刻复制这部分内存！取而代之的是：<ul><li><strong>COW 机制：</strong> 父子进程最开始共享同一片物理内存，这些内存页被标记为 <strong>只读（Read-Only）</strong>。</li><li><strong>写时复制：</strong> 当父或子进程试图写入这片内存时，操作系统才会触发“页面复制”，分配新的内存页，供写操作独享。</li></ul></li></ol><p>  这种机制大幅优化了 <code>fork()</code> 的性能，因为如果父子进程不修改内存，根本就不用复制，节省了大量资源。<strong>综上：<code>fork()</code> 之后，父子进程共享代码段，但数据、堆、栈在写操作时会触发“写时复制”。</strong></p><p>  举个例子：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">100</span>;</span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;子进程 x = %d\n&quot;</span>, x);                <span class="comment">// 共享内存，输出 100</span></span><br><span class="line">        x = <span class="number">200</span>;                                    <span class="comment">// 写操作，触发写时复制，子进程独享这片内存</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;子进程修改后 x = %d\n&quot;</span>, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        sleep(<span class="number">1</span>);                                   <span class="comment">// 让子进程先跑</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;父进程 x = %d\n&quot;</span>, x);               <span class="comment">// 父进程的 x 仍然是 100，未受子进程影响</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">子进程 x = <span class="number">100</span></span><br><span class="line">子进程修改后 x = <span class="number">200</span></span><br><span class="line">父进程 x = <span class="number">100</span></span><br></pre></td></tr></table></figure><p>  <strong>解释：</strong></p><ol><li><code>fork()</code> 之后，父子进程共享内存，<code>x</code> 的初始值对父子都可见（100）。</li><li>子进程写入 <code>x</code> 时，触发 COW：<ul><li>系统为子进程分配新内存页，把原来内存页的值（100）复制过来。</li><li>子进程修改自己的副本，父进程继续使用原来的内存页。</li></ul></li><li>所以，父子进程的 <code>x</code> 从此各自独立，互不干扰。因为它们的内存空间已经分开，各玩各的！</li></ol><p>  <strong>注：如果想让父子进程共享数据，得用专门的共享内存机制（如 <code>mmap()</code>）。</strong></p><hr><h4 id="4-fork-究竟在干什么？系统中多了一个进程吗？"><a href="#4-fork-究竟在干什么？系统中多了一个进程吗？" class="headerlink" title="4. fork() 究竟在干什么？系统中多了一个进程吗？"></a>4. <code>fork()</code> 究竟在干什么？系统中多了一个进程吗？</h4><p>  是的，<code>fork()</code> 让系统里多了一个新进程！可通过 <code>ps</code> 命令观察到子进程的存在：<code>ps -ef | grep &lt;程序名&gt;</code>。它做了这几件事：</p><ol><li><p><strong>复制父进程的内存空间：</strong> 代码段、数据段、堆栈等全部复制，子进程看起来和父进程几乎一模一样。</p><ul><li>复制父进程的 <strong>进程控制块（PCB）</strong>，生成子进程的 PCB。</li><li>复制父进程的 <strong>虚拟地址空间</strong>（通过写时复制优化）。</li></ul></li><li><p><strong>分配新的进程 ID（PID）：</strong> 子进程有独立的 PID，同时保留父进程的 PPID（Parent PID）。</p></li><li><p><strong>独立调度：</strong> 子进程作为独立的进程被调度，和父进程各自执行，互不干扰。</p></li></ol><p>  所以，<code>fork()</code> 之后，系统里确实多了一个进程！但它们起点一致，只是接下来的执行路径可能不同。</p><hr><h4 id="5-为什么要创建子进程？"><a href="#5-为什么要创建子进程？" class="headerlink" title="5. 为什么要创建子进程？"></a>5. 为什么要创建子进程？</h4><p>  创建子进程的目的是 <strong>并行执行不同的任务</strong>，常见用途有：</p><ol><li><strong>后台任务：</strong> 如守护进程、Web 服务器，父进程处理请求，子进程负责具体工作。</li><li><strong>任务分解：</strong> 父进程分配工作，子进程完成任务。</li><li><strong>隔离风险：</strong> 子进程失败不会影响父进程，避免整个程序崩溃。</li></ol><p>  简单来说，<strong>父进程管理，子进程干活</strong>，井井有条！</p><hr><h4 id="6-fork-后，谁先运行？"><a href="#6-fork-后，谁先运行？" class="headerlink" title="6. fork()  后，谁先运行？"></a>6. <code>fork() </code> 后，谁先运行？</h4><p>  这个是 <strong>不确定的</strong>！谁先运行完全取决于操作系统的调度策略：</p><ul><li>父子进程创建完成后，由操作系统的调度器决定执行顺序。</li><li>可能父进程先运行，也可能子进程先运行，甚至交替执行</li></ul><p>  所以，谁先跑？随缘！操作系统说了算，<strong>让操作系统的调度器决定</strong>，它才是“调度大哥”！</p></blockquote><hr><h3 id="六、扩展思考"><a href="#六、扩展思考" class="headerlink" title="六、扩展思考"></a>六、扩展思考</h3><h4 id="Q1：为什么进程不需要直接与内核交互？"><a href="#Q1：为什么进程不需要直接与内核交互？" class="headerlink" title="Q1：为什么进程不需要直接与内核交互？"></a>Q1：为什么进程不需要直接与内核交互？</h4><p>答：内核通过 <code>task_struct</code> 间接管理进程，就像校长通过学生档案管理学生。进程只需执行代码，内核通过数据结构记录状态并决策。</p><h4 id="Q2：如何查看进程的-task-struct？"><a href="#Q2：如何查看进程的-task-struct？" class="headerlink" title="Q2：如何查看进程的 task_struct？"></a>Q2：如何查看进程的 <code>task_struct</code>？</h4><p>答：用户态无法直接访问 <code>task_struct</code>，但可以通过以下命令间接查看：</p><ul><li><code>ps</code>：显示 PID、状态、CPU&#x2F;内存使用。</li><li><code>/proc/[pid]/stat</code>：虚拟文件系统，如 <code>cat /proc/1234/stat</code> 包含进程的详细信息（映射 <code>task_struct</code> 字段）。</li></ul><h4 id="Q3：多个进程如何共享-CPU？"><a href="#Q3：多个进程如何共享-CPU？" class="headerlink" title="Q3：多个进程如何共享 CPU？"></a>Q3：<strong>多个进程如何共享 CPU</strong>？</h4><p>答：通过调度算法在 <code>task_struct </code> 间切换。</p><ul><li><strong>完全公平调度（CFS）</strong>：基于虚拟运行时间（<code>vruntime</code>）决定进程优先级。</li><li><strong>实时调度策略</strong>：如 <code>SCHED_FIFO</code>（先进先出）和 <code>SCHED_RR</code>（时间片轮转）。</li><li><strong>调度相关字段</strong>：<code>task_struct</code> 中的 <code>policy</code>（调度策略）、<code>prio</code>（动态优先级）、<code>static_prio</code>（静态优先级）。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 进程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>010 冯・诺依曼体系结构和操作系统</title>
      <link href="/posts/38654.html"/>
      <url>/posts/38654.html</url>
      
        <content type="html"><![CDATA[<h2 id="冯-・-诺依曼体系结构：计算机世界的基石"><a href="#冯-・-诺依曼体系结构：计算机世界的基石" class="headerlink" title="冯 ・ 诺依曼体系结构：计算机世界的基石"></a>冯 ・ 诺依曼体系结构：计算机世界的基石</h2><p>在计算机科学中，<strong>冯诺依曼体系结构（Von Neumann Architecture）</strong> 是一种广泛采用的计算机架构模型，几乎所有现代计算机系统都基于此架构设计。它是由著名的数学家约翰·冯·诺依曼于 1945 年提出的，至今仍在各类计算机硬件的设计中占据主导地位。冯诺依曼体系结构的核心思想可以简单总结为：<strong>计算机由内存、CPU、输入输出设备、总线和外设组成，且指令和数据存储在同一个内存中</strong>。</p><h3 id="1-冯诺依曼体系结构的组成"><a href="#1-冯诺依曼体系结构的组成" class="headerlink" title="1. 冯诺依曼体系结构的组成"></a>1. 冯诺依曼体系结构的组成</h3><p>冯诺依曼体系结构主要包括以下几个基本组成部分：</p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Blog/20250623200921613.png" alt="图片描述"></p><h4 id="CPU（中央处理单元）"><a href="#CPU（中央处理单元）" class="headerlink" title="CPU（中央处理单元）"></a>CPU（中央处理单元）</h4><p><code>CPU </code> 是计算机的大脑，负责执行程序指令和数据处理。在冯诺依曼架构中，<code>CPU </code> 被分为两个主要部分：</p><ul><li><strong>运算器</strong>（<code>ALU</code>）：负责执行各种算术运算和逻辑运算。</li><li><strong>控制器</strong>：负责指挥计算机其他部分的工作，协调不同部件的操作。</li></ul><h4 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h4><p>内存是冯诺依曼体系结构中存储数据和程序指令的地方。程序在执行时，首先会被加载到内存中，而后由 <code>CPU </code> 进行处理。</p><h4 id="输入输出设备"><a href="#输入输出设备" class="headerlink" title="输入输出设备"></a>输入输出设备</h4><p>输入设备如键盘、鼠标、摄像头等，用于向计算机提供外部数据；输出设备如显示器、打印机、扬声器等，则用于将计算机的处理结果反馈给用户。有的设备是纯的输入或是纯的输出，也有既是输入又是输出设备，输入输出设备统称外设。</p><h4 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h4><p><strong><code>外设</code> 和 <code>CPU</code> 都是独立的个体（独立的硬件组件）</strong>，各个硬件单元必须用 “线” 链接起来，冯诺依曼体系结构中的各个部件（如内存、<code>CPU</code> 和外设）之间需通过总线进行数据交换。总线是由一组传输信号的线路组成，可以分为以下几类：</p><ul><li><strong>系统总线</strong>：连接 <code>CPU </code> 和内存，传输程序指令和数据。</li><li><strong>I&#x2F;O 总线</strong>：连接外部设备和计算机系统，用于数据传输。</li></ul><h3 id="2-冯-・-诺依曼体系结构的工作原理"><a href="#2-冯-・-诺依曼体系结构的工作原理" class="headerlink" title="2. 冯 ・ 诺依曼体系结构的工作原理"></a>2. 冯 ・ 诺依曼体系结构的工作原理</h3><p>冯诺依曼体系结构的核心特点是 <strong>存储程序</strong> 的设计。即程序指令和数据都存储在内存中，这与早期的计算机设计（例如图灵机）不同，图灵机在运行时需要将指令和数据分开存储。在冯 ・ 诺依曼体系结构下，一个程序的运行过程大致如下：</p><h4 id="1-程序加载"><a href="#1-程序加载" class="headerlink" title="1. 程序加载"></a>1. 程序加载</h4><p>一个程序要运行，必须先加载到内存中。这是因为 <code>CPU </code> 只能从内存中读取数据和指令进行处理。存储在硬盘（外存）上的可执行程序文件，需要通过特定的加载机制，将程序的代码和数据复制到内存中。就好比我们要阅读一本书，必须先把书拿到桌子上（内存相当于桌子），才能开始阅读（<code>CPU </code> 处理）。</p><h4 id="2-数据传输与处理"><a href="#2-数据传输与处理" class="headerlink" title="2. 数据传输与处理"></a>2. 数据传输与处理</h4><p>当程序在内存中准备好后，<code>CPU </code> 通过系统总线与内存进行数据交互。系统总线就像是连接 <code>CPU </code> 和内存的高速公路，数据在上面快速传输。<code>CPU</code> 从内存中读取指令和数据，经过运算器进行计算处理，然后再将处理结果写回内存。例如我们进行一个简单的加法运算，<code>CPU</code> 会先从内存中读取两个加数，经过运算器计算出结果后，再将结果存回内存。</p><h4 id="3-外设交互"><a href="#3-外设交互" class="headerlink" title="3. 外设交互"></a>3. 外设交互</h4><p>输入设备将外部数据输入到内存中，例如我们通过键盘输入一段文字，键盘会将这些文字信息转化为电信号，通过 IO 总线传输到内存中。而输出设备则从内存中获取数据并输出，比如显示器从内存中读取图像数据，然后在屏幕上显示出来。在这个过程中，内存起到了一个缓冲和中转的作用，使得 <code>CPU </code> 和外设之间能够高效地进行数据交换。</p><h4 id="冯诺依曼架构的核心思想"><a href="#冯诺依曼架构的核心思想" class="headerlink" title="冯诺依曼架构的核心思想"></a>冯诺依曼架构的核心思想</h4><ul><li><strong>程序存储在内存中</strong>：在冯诺依曼架构中，程序和数据是存储在相同的内存中的。程序是由一条条指令组成，每条指令包含操作码和操作数。<code>CPU</code> 根据程序计数器（PC）的指示，从内存中逐条取出指令，解码并执行。</li><li><strong>存储器访问模式</strong>：<code>CPU</code> 能对内存进行读写，但无法直接与外设交互。所有输入输出设备（如键盘、鼠标、打印机等）只能通过内存与 <code>CPU</code> 进行间接通信。数据从输入设备读取到内存，然后由 <code>CPU</code> 进行处理，处理结果再存入内存，最后通过输出设备显示或打印出来。</li></ul><h3 id="3-程序执行过程中的缓存机制"><a href="#3-程序执行过程中的缓存机制" class="headerlink" title="3. 程序执行过程中的缓存机制"></a>3. 程序执行过程中的缓存机制</h3><p>冯诺依曼架构中的一个显著缺点就是 <strong>冯诺依曼瓶颈</strong>。由于 <code>CPU</code> 和内存之间的数据传输速度有限，导致 <code>CPU</code> 的处理能力无法充分发挥，尤其是在需要频繁访问内存的数据密集型应用中，这种瓶颈尤为明显。为了缓解这一瓶颈，现代计算机系统中引入缓存（<code>Cache</code>）技术、多个处理核心以及更高带宽的内存系统等。在实际运行过程中，程序中的数据常常需要频繁访问，内存的随机访问特性（RAM）使得 CPU 可以快速访问任意位置的数据，而磁盘是顺序访问设备，访问速度较慢，为了提高数据访问效率，缓存机制就起作用了：</p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Blog/20250623201225361.png"></p><h4 id="1-CPU-缓存"><a href="#1-CPU-缓存" class="headerlink" title="1. CPU 缓存"></a>1. CPU 缓存</h4><p><code>CPU </code> 内部有多个级别的缓存（L1、L2、L3 缓存），这些缓存会存储最近访问的数据，以减少 <code>CPU </code> 对内存的访问次数，从而提高程序运行速度。</p><h4 id="2-内存缓存（磁盘缓存-页面缓存）"><a href="#2-内存缓存（磁盘缓存-页面缓存）" class="headerlink" title="2. 内存缓存（磁盘缓存&#x2F;页面缓存）"></a>2. 内存缓存（磁盘缓存&#x2F;页面缓存）</h4><p>操作系统和硬件还会将程序执行过程中常用的数据保存在内存缓存中，这样当程序再次需要这些数据时，可以直接从缓存中获取，避免了频繁地从磁盘或其他慢速设备中读取数据。</p><h4 id="3-数据缓存与进度条"><a href="#3-数据缓存与进度条" class="headerlink" title="3. 数据缓存与进度条"></a>3. 数据缓存与进度条</h4><p>在我们编写进度条时，进度条的显示数据会被缓存。例如，在计算一个大的任务进度时，程序可能会将计算结果缓存到内存中，然后一次性更新进度条的显示。这是为了避免频繁的 <code>UI</code> 更新操作，提高程序的响应速度和流畅性。</p><h3 id="4-为什么程序必须加载到内存中执行？"><a href="#4-为什么程序必须加载到内存中执行？" class="headerlink" title="4. 为什么程序必须加载到内存中执行？"></a>4. 为什么程序必须加载到内存中执行？</h3><p>冯诺依曼架构规定，所有的程序指令和数据都存储在内存中，并由 <code>CPU </code> 执行。这是因为：</p><ol><li><strong>指令和数据存储统一</strong>：冯诺依曼架构的一个关键特性就是指令和数据都存储在内存中，内存的读取速度远高于磁盘，因此程序必须加载到内存中运行，以保证程序能够高效执行。</li><li><strong>CPU 对内存的高速访问</strong>：内存（<code>RAM</code>）的访问速度比磁盘和其他存储设备要快得多。如果程序直接从磁盘运行，不仅速度慢，而且可能导致系统崩溃。</li><li><strong>程序的动态性</strong>：程序的执行涉及多个步骤和多个指令的交替执行，因此必须将这些指令加载到内存中，以便 <code>CPU </code> 可以随时根据程序计数器（PC）来获取和执行指令。</li></ol><h3 id="5-冯诺依曼架构的数据流动过程（以-QQ-聊天为例）"><a href="#5-冯诺依曼架构的数据流动过程（以-QQ-聊天为例）" class="headerlink" title="5. 冯诺依曼架构的数据流动过程（以 QQ 聊天为例）"></a>5. 冯诺依曼架构的数据流动过程（以 QQ 聊天为例）</h3><p>假设你打开 QQ，开始和朋友聊天，从登录到发送消息，数据流动过程可以分为以下几个阶段：</p><h4 id="1-登录-QQ"><a href="#1-登录-QQ" class="headerlink" title="1. 登录 QQ"></a>1. 登录 QQ</h4><ul><li><strong>输入阶段</strong>：你输入账号和密码，键盘将这些数据通过输入单元（键盘）传递给内存，内存将这些输入的数据存储在特定位置。</li><li><strong>处理阶段</strong>：CPU 从内存中读取账号和密码数据，处理登录逻辑，向服务器发送请求，验证账号密码。</li><li><strong>输出阶段</strong>：验证通过后，QQ 界面显示登录成功信息，显示器将数据显示出来。</li></ul><h4 id="2-发送消息"><a href="#2-发送消息" class="headerlink" title="2. 发送消息"></a>2. 发送消息</h4><ul><li><strong>输入阶段</strong>：你在 QQ 聊天框内输入消息，消息通过键盘输入单元传入内存。</li><li><strong>处理阶段</strong>：CPU 读取内存中的消息内容，包装成适合网络传输的数据包，发送给服务器。</li><li><strong>输出阶段</strong>：服务器接收到消息后，发送到朋友的 QQ 客户端。通过网络传输，最后通过朋友的 QQ 软件显示在他的聊天界面中。</li></ul><h4 id="3-发送文件"><a href="#3-发送文件" class="headerlink" title="3. 发送文件"></a>3. 发送文件</h4><ul><li><strong>输入阶段</strong>：你选择一个文件发送，操作系统将文件从硬盘加载到内存中。</li><li><strong>处理阶段</strong>：CPU 将文件内容通过网络传输给服务器，服务器再转发给目标用户的客户端。</li><li><strong>输出阶段</strong>：目标用户收到文件后，QQ 会将文件内容显示在客户端，或者将文件保存到目标用户的硬盘。</li></ul><h3 id="6-小结"><a href="#6-小结" class="headerlink" title="6. 小结"></a>6. 小结</h3><p>冯诺依曼体系结构为现代计算机的设计和操作提供了基础。它的核心思想是将程序指令和数据存储在同一内存中，并通过 CPU 执行这些指令。通过这种结构，计算机能够实现更高效的任务处理，缓存机制则进一步提高了程序的执行速度。为我们理解后续如进程等复杂的计算机概念提供基础。</p><hr><h2 id="操作系统基础：从概念到管理"><a href="#操作系统基础：从概念到管理" class="headerlink" title="操作系统基础：从概念到管理"></a>操作系统基础：从概念到管理</h2><p>操作系统（Operating System, OS）是计算机系统中不可或缺的一部分，它负责管理计算机硬件和软件资源，并为用户程序提供服务。简单来说，操作系统就是一款“管理”软件，负责协调和控制计算机的硬件和应用程序之间的交互。操作系统的主要任务是确保资源的有效利用和系统的稳定运行。</p><h3 id="1-什么是操作系统？"><a href="#1-什么是操作系统？" class="headerlink" title="1. 什么是操作系统？"></a>1. 什么是操作系统？</h3><p>操作系统是计算机系统中的一个基本程序集合，它负责管理计算机的硬件和软件资源，并为用户程序提供一个稳定、高效、安全的执行环境。操作系统包括多个核心组件，其中最重要的有：</p><ul><li><strong>进程管理</strong>：负责控制和调度进程，确保每个程序能在系统中正常运行。</li><li><strong>内存管理</strong>：管理计算机的内存，确保各程序的内存使用不发生冲突。</li><li><strong>文件管理</strong>：提供文件的存储、读取、删除等基本操作，并确保数据的安全性。</li><li><strong>驱动管理</strong>：与硬件设备进行交互，管理硬件设备的驱动程序。</li></ul><h3 id="2-操作系统的设计目的"><a href="#2-操作系统的设计目的" class="headerlink" title="2. 操作系统的设计目的"></a>2. 操作系统的设计目的</h3><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Blog/20250623201102780.png"></p><p>操作系统的设计目标包括：</p><ul><li><strong>稳定性</strong>：确保操作系统的长期运行不崩溃，能够处理各种异常情况。</li><li><strong>效率</strong>：高效地利用硬件资源，减少系统的资源浪费。</li><li><strong>安全性</strong>：保护操作系统和用户数据不受未授权访问或恶意攻击。</li><li><strong>用户友好性</strong>：提供易用的接口，帮助用户和开发者更好地与系统交互。</li></ul><h3 id="3-操作系统的组成"><a href="#3-操作系统的组成" class="headerlink" title="3. 操作系统的组成"></a>3. 操作系统的组成</h3><p>操作系统不仅仅是一个内核（操作系统的核心部分），负责管理硬件资源和提供基本的系统服务。还包括其他组件如函数库、<code>shell</code> 等是用户与内核交互的桥梁。操作系统通过这些组件，为用户程序提供了一个完整的执行环境。然而操作系统通常不会直接暴露其内部实现细节，而是通过一系列接口与上层应用程序进行交互。这些接口被称为 <strong>系统调用</strong>。系统调用是操作系统为应用程序提供的功能入口，允许用户程序访问操作系统的核心服务。</p><ol><li><strong>系统调用</strong>：系统调用是操作系统提供给开发者的基本接口，它们的功能通常比较基础，例如文件读写、内存分配、进程创建与管理等。由于直接使用系统调用会比较繁琐且容易出错，因此开发者可以对系统调用进行封装，形成更加易于使用的 <strong>库函数</strong>。</li><li><strong>库函数</strong>：库函数是对系统调用的封装，旨在简化开发者的使用。例如，C 语言的 <code>printf()</code> 函数可以看作是一个库函数，它内部可能会通过系统调用来实现具体的输出功能。库函数的存在不仅使得开发更加便捷，而且提高了代码的可读性和可维护性。</li></ol><h3 id="4-操作系统的管理功能"><a href="#4-操作系统的管理功能" class="headerlink" title="4. 操作系统的管理功能"></a>4. 操作系统的管理功能</h3><p>操作系统的核心功能之一就是管理计算机的软硬件资源。为了实现有效的管理，操作系统采用了多种技术手段，包括数据结构、接口和算法等。</p><p><strong>1. 数据结构</strong></p><p>在操作系统内部，数据结构起着非常重要的作用。通过设计合理的数据结构，操作系统可以高效地描述和组织资源。例如：</p><ul><li><strong>进程</strong>：操作系统需要描述每个进程的状态，使用 <code>struct</code> 结构体来存储进程信息。</li><li><strong>文件系统</strong>：操作系统使用树、链表等数据结构来组织文件信息，支持高效的文件存取。</li></ul><p><strong>2. 组织与调度</strong></p><p>操作系统不仅需要描述资源，还需要对其进行高效的组织。例如，进程管理不仅仅是维护进程的状态，还需要根据优先级、资源占用等因素来合理安排各进程的执行顺序。这一过程会涉及到非常复杂的调度算法。</p><h4 id="如何理解“管理”"><a href="#如何理解“管理”" class="headerlink" title="如何理解“管理”"></a>如何理解“管理”</h4><p>为了更好地理解操作系统的“管理”功能，我们可以举一个简单的例子：假设你是一个图书馆管理员，你的任务是管理图书馆中的书籍。你需要做以下几件事：</p><ol><li><strong>描述书籍</strong>：你需要记录每本书的信息，如书名、作者、出版日期等。</li><li><strong>组织书籍</strong>：你需要将书籍按照某种规则（如按作者、按主题）进行分类和排列，以便读者能够快速找到所需的书籍。</li></ol><p><strong>计算机中的管理</strong></p><p>在计算机中，操作系统的管理方式与图书馆管理员的管理方式类似：</p><ol><li><strong>描述被管理对象</strong>：操作系统通过数据结构（如结构体）来描述被管理的对象。例如，操作系统使用进程控制块（PCB）来描述一个进程，使用文件控制块（<code>FCB</code>）来描述一个文件。</li><li><strong>组织被管理对象</strong>：操作系统通过链表、树等高效的数据结构来组织被管理的对象。例如，操作系统使用进程队列来组织正在运行的进程，使用文件目录树来组织文件系统中的文件。</li></ol><h3 id="5-进程管理"><a href="#5-进程管理" class="headerlink" title="5. 进程管理"></a>5. 进程管理</h3><p>在操作系统中，进程是程序的一次执行过程。操作系统通过进程管理来确保多个程序能够并发执行，且不会相互干扰。操作系统如何管理进程呢？很简单，先把进程描述起来，再把进程组织起来！</p><ol><li><strong>描述进程</strong>：操作系统通过进程控制块（<code>PCB</code>）来描述一个进程。<code>PCB</code> 是一个数据结构，包含了进程的所有信息，如进程 ID、进程状态、程序计数器、寄存器、内存分配情况等。</li><li><strong>组织进程</strong>：操作系统通过进程队列来组织进程。例如，操作系统会维护一个就绪队列，存放所有准备执行的进程；一个阻塞队列，存放所有等待资源的进程。操作系统通过调度算法从就绪队列中选择一个进程执行。</li></ol><h3 id="6-结论：为进程管理铺路"><a href="#6-结论：为进程管理铺路" class="headerlink" title="6. 结论：为进程管理铺路"></a>6. 结论：为进程管理铺路</h3><p>通过上述介绍，可以看到操作系统的核心功能就是管理计算机的硬件资源，并为应用程序提供执行环境。操作系统的实现依赖于高效的数据结构和算法，而系统调用与库函数为开发者提供了与操作系统交互的便捷接口。下一步，我们将深入探讨进程的相关内容。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>07 STL简介</title>
      <link href="/posts/51552.html"/>
      <url>/posts/51552.html</url>
      
        <content type="html"><![CDATA[<h2 id="STL-简介：从入门到应用全面解析"><a href="#STL-简介：从入门到应用全面解析" class="headerlink" title="STL 简介：从入门到应用全面解析"></a>STL 简介：从入门到应用全面解析</h2><h3 id="一、什么是-STL？"><a href="#一、什么是-STL？" class="headerlink" title="一、什么是 STL？"></a>一、什么是 STL？</h3><p><strong>STL（Standard Template Library，标准模板库）</strong> 是 C++标准库的核心组成部分，它不仅是一个可复用的组件库，更是一个 <strong>集数据结构与算法于一体的软件框架</strong>。STL 的设计理念是“泛型编程”，通过模板技术实现代码的高度复用，使开发者无需重复造轮子即可高效完成开发。</p><h3 id="二、STL-的版本发展"><a href="#二、STL-的版本发展" class="headerlink" title="二、STL 的版本发展"></a>二、STL 的版本发展</h3><ol><li><p><strong>HP 版本</strong><br>由 Alexander Stepanov 和 Meng Lee 在 <strong>惠普实验室</strong> 开发，是 STL 的“始祖版本”，开源且允许自由使用和修改，奠定了 STL 的基础架构。</p></li><li><p><strong>P.J.版本</strong><br>继承自 HP 版本，被 Windows Visual C++采用。缺点是代码可读性较差，符号命名风格独特，且不允许公开修改。</p></li><li><p><strong>RW 版本</strong><br>由 Rouge Wage 公司开发，应用于 C++ Builder，同样闭源，可读性一般。</p></li><li><p><strong>SGI 版本</strong><br>Silicon Graphics 公司的实现版本，被 GCC（Linux）采用，以高可读性、良好的可移植性和开放性著称，是学习 STL 源码的主要参考。</p></li></ol><hr><h3 id="三、STL-的六大组件"><a href="#三、STL-的六大组件" class="headerlink" title="三、STL 的六大组件"></a>三、STL 的六大组件</h3><ol><li><p><strong>容器（Containers）</strong><br>管理数据的集合，如 <code>vector</code>（动态数组）、<code>list</code>（双向链表）、<code>map</code>（键值对集合）等。</p></li><li><p><strong>算法（Algorithms）</strong><br>提供常用算法，如 <code>sort</code>（排序）、<code>find</code>（查找）、<code>merge</code>（合并）等，通过迭代器操作容器。</p></li><li><p><strong>迭代器（Iterators）</strong><br>连接容器与算法的桥梁，包括 <code>iterator</code>、<code>const_iterator</code>、<code>reverse_iterator</code> 等类型。</p></li><li><p><strong>仿函数（Functors）</strong><br>行为类似函数的对象，如 <code>greater</code>、<code>less</code>，用于自定义排序或比较逻辑。</p></li><li><p><strong>适配器（Adapters）</strong><br>修饰容器或仿函数的功能，例如 <code>stack</code>（栈适配器）、<code>queue</code>（队列适配器）。</p></li><li><p><strong>空间配置器（Allocators）</strong><br>负责内存的分配与管理，例如 <code>std::allocator</code>，与智能指针（如 <code>shared_ptr</code>）协同解决内存泄漏问题。</p></li></ol><hr><h3 id="四、STL-的重要性"><a href="#四、STL-的重要性" class="headerlink" title="四、STL 的重要性"></a>四、STL 的重要性</h3><h4 id="1-笔试与面试中的高频考点"><a href="#1-笔试与面试中的高频考点" class="headerlink" title="1. 笔试与面试中的高频考点"></a>1. 笔试与面试中的高频考点</h4><ul><li><strong>笔试</strong>：如“层序打印二叉树”、“两个栈实现队列”等题目，均需借助 STL 容器和算法快速实现。</li><li><strong>面试</strong>：常见问题包括：<ul><li><code>vector</code> 与 <code>list</code> 的区别（连续内存 vs 链式存储）。</li><li><code>map</code> 的底层实现（红黑树）及其与哈希表的差异。</li><li>智能指针的原理（如 <code>auto_ptr</code> 的缺陷及 C++11 中 <code>unique_ptr</code> 的改进）。</li></ul></li></ul><h4 id="2-实际开发中的高效工具"><a href="#2-实际开发中的高效工具" class="headerlink" title="2. 实际开发中的高效工具"></a>2. 实际开发中的高效工具</h4><p>STL 封装了高效的数据结构和算法，例如：</p><ul><li><code>vector</code> 的 <code>capacity</code> 动态增长策略（倍增扩容）。</li><li>单链表逆置（使用迭代器或递归）。</li><li>素数筛法（利用 <code>vector</code> 优化性能）。</li></ul><hr><h3 id="五、如何学习-STL？"><a href="#五、如何学习-STL？" class="headerlink" title="五、如何学习 STL？"></a>五、如何学习 STL？</h3><h4 id="三个境界"><a href="#三个境界" class="headerlink" title="三个境界"></a>三个境界</h4><ol><li><strong>熟用 STL</strong>：掌握常用容器和算法的基本用法。</li><li><strong>明理</strong>：理解泛型编程思想及 STL 源码实现（如迭代器设计、内存管理）。</li><li><strong>扩展</strong>：根据需求定制容器、仿函数或适配器。</li></ol><h4 id="学习路径"><a href="#学习路径" class="headerlink" title="学习路径"></a>学习路径</h4><ul><li><strong>初阶</strong>：通过《C++ Primer》掌握基础语法和 STL API。</li><li><strong>进阶</strong>：阅读《The C++ Standard Library》深入源码，参考 SGI 版本实现。</li><li><strong>实践</strong>：结合项目优化代码，例如实现自定义内存池（空间配置器）或高效算法。</li></ul><hr><h3 id="六、STL-的缺陷"><a href="#六、STL-的缺陷" class="headerlink" title="六、STL 的缺陷"></a>六、STL 的缺陷</h3><ol><li><p><strong>更新缓慢</strong><br>C++98 到 C++11 间隔 13 年，STL 对新特性的支持滞后。</p></li><li><p><strong>线程安全问题</strong><br>STL 未内置线程安全机制，多线程环境下需手动加锁，增加了开发复杂度。</p></li><li><p><strong>代码膨胀</strong><br>模板的实例化可能导致生成多份相似代码（如 <code>vector&lt;int&gt;</code>、<code>vector&lt;double&gt;</code>）。</p></li><li><p><strong>复杂度高</strong><br>过度追求性能使得内部实现复杂（如类型推导和迭代器萃取技术）。</p></li></ol><h3 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h3><p>STL 是 C++开发者必须掌握的“利器”，其高效性与通用性大幅提升了开发效率。尽管存在更新慢、线程安全等缺陷，但通过深入理解其设计思想，开发者可以灵活规避问题并发挥其最大价值。正如业内所言：<strong>“不懂 STL，何以谈 C++？”</strong> 无论是应对面试还是实际开发，STL 都是通往高阶 C++的必经之路。</p><hr><p><strong>扩展阅读</strong>  </p><ul><li>《Effective STL》：掌握 STL 的最佳实践。  </li><li>《STL 源码剖析》：深入理解 SGI 版本的实现细节。  </li><li>C++官方文档：追踪 STL 的最新特性（如 C++20 中的 <code>ranges</code> 库）。</li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>009 进度条的实现</title>
      <link href="/posts/5216.html"/>
      <url>/posts/5216.html</url>
      
        <content type="html"><![CDATA[<h2 id="进度条的实现"><a href="#进度条的实现" class="headerlink" title="进度条的实现"></a>进度条的实现</h2><p>进度条是用户界面中常见的元素，用于显示任务的完成进度。通过实现一个进度条，可以学习如何在 Linux 下进行简单的用户界面设计，同时也能理解文件链接和代码维护的重要性。结合之前讲的倒计时的代码，我们正式来实现我们 Linux 下第一个小程序 —— 进度条。结合之前讲解的 <strong>Linux 文件链接</strong> 和考虑到代码的 <strong>维护性</strong>，依旧采用 <strong>头文件 <code>.h</code>、函数体文件 <code>.c</code>、main 函数文件 <code>.c</code></strong> 的三个文件进行讲解：</p><h3 id="makefile-的配置"><a href="#makefile-的配置" class="headerlink" title="makefile 的配置"></a>makefile 的配置</h3><p>为了方便进度条的运行展示，这里给出我的 <code>makefile</code> 配置（第一种旨在理解编译流程，第二种全自动更方便）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 目标文件 processBar 依赖于 processBar.o</span></span><br><span class="line">processBar: processBar.o</span><br><span class="line">gcc processBar.o -o processBar</span><br><span class="line"></span><br><span class="line"><span class="comment"># 目标文件 processBar.o 依赖于 processBar.s</span></span><br><span class="line">processBar.o: processBar.s</span><br><span class="line">gcc -c processBar.s -o processBar.o</span><br><span class="line"></span><br><span class="line"><span class="comment"># 目标文件 processBar.s 依赖于 processBar.i</span></span><br><span class="line">processBar.s: processBar.i</span><br><span class="line">gcc -S processBar.i -o processBar.s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 目标文件 processBar.i 依赖于 processBar.c</span></span><br><span class="line">processBar.i: processBar.c</span><br><span class="line">gcc -E processBar.c -o processBar.i</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 清理生成的文件</span></span><br><span class="line">.PHONY: clean</span><br><span class="line">clean:</span><br><span class="line"><span class="built_in">rm</span> -f processBar.i processBar.s processBar.o processBar</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义目标和源文件</span></span><br><span class="line">TARGET = processBar</span><br><span class="line">SRCS = processBar.c processBarmain.c</span><br><span class="line">OBJS = $(SRCS:.c=.o)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义编译器和选项</span></span><br><span class="line">CC = gcc</span><br><span class="line">CFLAGS = -I. -Wall -O2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认目标</span></span><br><span class="line">all: $(TARGET)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成目标文件</span></span><br><span class="line">$(TARGET): $(OBJS)</span><br><span class="line">$(CC) $(OBJS) -o $(TARGET)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成对象文件</span></span><br><span class="line">%.o: %.c</span><br><span class="line">$(CC) $(CFLAGS) -c $&lt; -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 清理生成的文件</span></span><br><span class="line">.PHONY: clean</span><br><span class="line">clean:</span><br><span class="line"><span class="built_in">rm</span> -f processBar.i processBar.s processBar.o processBar</span><br></pre></td></tr></table></figure><h3 id="第一版：基础进度条"><a href="#第一版：基础进度条" class="headerlink" title="第一版：基础进度条"></a>第一版：基础进度条</h3><h4 id="1-单个循环打印"><a href="#1-单个循环打印" class="headerlink" title="1. 单个循环打印"></a>1. 单个循环打印</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">100</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\r[%3d%%]&quot;</span>, i); <span class="comment">// 使用\r回车，覆盖之前的输出。注意：在Linux下，我们更倾向于%%这种写法，使用转义符/可能会存在问题。</span></span><br><span class="line">        <span class="built_in">fflush</span>(stdout);         <span class="comment">// 刷新输出缓冲区</span></span><br><span class="line">        <span class="built_in">usleep</span>(<span class="number">20000</span>);          <span class="comment">// 睡眠20ms（单位：微秒）</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);               <span class="comment">// 最后换行</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>问题：</strong></p><ol><li>输出不直观，只是一个百分比数字。</li><li>缺少进度条的视觉表示。</li></ol><h4 id="2-添加进度条显示"><a href="#2-添加进度条显示" class="headerlink" title="2. 添加进度条显示"></a>2. 添加进度条显示</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> bar[<span class="number">101</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">// 数组用于存储进度条内容</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">100</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        bar[i] = <span class="string">&#x27;#&#x27;</span>; <span class="comment">// 使用 &#x27;#&#x27; 或者 &#x27;-&#x27;表示进度</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\r[%-100s][%3d%%]&quot;</span>, bar, i);</span><br><span class="line">        <span class="built_in">fflush</span>(stdout);</span><br><span class="line">        <span class="built_in">usleep</span>(<span class="number">100000</span>); <span class="comment">// 调整速度</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>问题：</strong></p><ol><li>进度条没有动态效果，看起来比较单调。</li><li>缺少加载动画提示。</li></ol><h4 id="3-改进：添加加载动画"><a href="#3-改进：添加加载动画" class="headerlink" title="3. 改进：添加加载动画"></a>3. 改进：添加加载动画</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *label = <span class="string">&quot;|-\\&quot;</span>;<span class="comment">// 动画样式</span></span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processbar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\r[%s] [%3d%%]&quot;</span>, &amp;label[cnt % <span class="number">3</span>], cnt); <span class="comment">// 使用动画符号</span></span><br><span class="line">    <span class="built_in">fflush</span>(stdout);</span><br><span class="line">    cnt++;</span><br><span class="line">    <span class="built_in">usleep</span>(<span class="number">100000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (cnt &lt;= <span class="number">100</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">processbar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>问题：</strong></p><ol><li>动画符号和进度条没有良好结合。</li><li>缺少进度条长度控制。</li></ol><h4 id="4-完善进度条长度与样式"><a href="#4-完善进度条长度与样式" class="headerlink" title="4. 完善进度条长度与样式"></a>4. 完善进度条长度与样式</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *label = <span class="string">&quot;|-\\&quot;</span>;</span><br><span class="line"><span class="type">char</span> bar[<span class="number">101</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">// 数组用于存储进度条内容</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processbar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\r[%-100s][%3d%%][%c]&quot;</span>, bar, cnt, label[cnt % <span class="number">3</span>]);</span><br><span class="line">    <span class="built_in">fflush</span>(stdout);</span><br><span class="line">    bar[cnt++] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">    <span class="built_in">usleep</span>(<span class="number">50000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (cnt &lt;= <span class="number">100</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">processbar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>问题：</strong></p><ol><li>进度条结束时，右箭头没有正确显示。</li><li>变量写“死”，不利于维护。</li><li>没有体现文件之间的链接。</li></ol><h4 id="5-大改文件，将变量写活，添加尾部符号“-”，优化代码"><a href="#5-大改文件，将变量写活，添加尾部符号“-”，优化代码" class="headerlink" title="5. 大改文件，将变量写活，添加尾部符号“&gt;”，优化代码"></a>5. 大改文件，将变量写活，添加尾部符号“&gt;”，优化代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头文件 processBar.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NUM 102</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TOP 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STYLE <span class="string">&#x27;-&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RIGHT <span class="string">&#x27;&gt;&#x27;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">void</span> <span class="title">processbar</span><span class="params">(<span class="type">int</span> speed)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数文件 processBar.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;processBar.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *label = <span class="string">&quot;|-\\&quot;</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processbar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> bar[NUM];</span><br><span class="line">    <span class="built_in">memset</span>(bar, <span class="string">&#x27;\0&#x27;</span>, <span class="built_in">sizeof</span>(bar));</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(label);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (cnt &lt;= <span class="number">100</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%-100s][%d%%][%c]\r&quot;</span>, bar, cnt, label[cnt % len]);</span><br><span class="line">        <span class="built_in">fflush</span>(stdout);</span><br><span class="line">        bar[cnt++] = STYLE;</span><br><span class="line">        bar[cnt] = <span class="string">&#x27;&gt;&#x27;</span>;  <span class="comment">// 在尾部添加&#x27;&gt;&#x27;</span></span><br><span class="line">        <span class="built_in">usleep</span>(<span class="number">50000</span>);   <span class="comment">// 加快速度</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main函数文件 processBarmain.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;processBar.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">processbar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>问题</strong></p><ul><li>进度条完成后，尾部仍然显示“&gt;”，显得不够美观。</li><li>命令提示行会进行覆盖。</li></ul><h4 id="6-修复尾部符号“-”和提示行覆盖的问题"><a href="#6-修复尾部符号“-”和提示行覆盖的问题" class="headerlink" title="6. 修复尾部符号“&gt;”和提示行覆盖的问题"></a>6. 修复尾部符号“&gt;”和提示行覆盖的问题</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> *label = <span class="string">&quot;|-\\&quot;</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processbar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> bar[NUM];</span><br><span class="line">    <span class="built_in">memset</span>(bar, <span class="string">&#x27;\0&#x27;</span>, <span class="built_in">sizeof</span>(bar));</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(label);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (cnt &lt;= <span class="number">100</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%-100s][%d%%][%c]\r&quot;</span>, bar, cnt, label[cnt % len]);</span><br><span class="line">        <span class="built_in">fflush</span>(stdout);</span><br><span class="line">        bar[cnt++] = STYLE;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cnt &lt; <span class="number">100</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            bar[cnt] = <span class="string">&#x27;&gt;&#x27;</span>;  <span class="comment">// 仅在未完成时添加&#x27;&gt;&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">usleep</span>(<span class="number">50000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);  <span class="comment">// 刷新行缓冲区</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-优化代码，提高可维护性-——-第一版进度条诞生！"><a href="#7-优化代码，提高可维护性-——-第一版进度条诞生！" class="headerlink" title="7. 优化代码，提高可维护性 —— 第一版进度条诞生！"></a>7. 优化代码，提高可维护性 —— 第一版进度条诞生！</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头文件 processBar.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NUM 102            <span class="comment">// 进度条数组长度, 代表进度条最大容量</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TOP 100            <span class="comment">// 最大进度, 定义进度条的最大进度（100%）</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BODY <span class="string">&#x27;-&#x27;</span>           <span class="comment">// 进度条主体符号, 用于表示进度的主要部分</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RIGHT <span class="string">&#x27;&gt;&#x27;</span>         <span class="comment">// 进度条尾部符号, 用于显示进度条的结束位置</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">void</span> <span class="title">processbar</span><span class="params">(<span class="type">int</span> speed)</span></span>;     <span class="comment">// 函数声明, 声明一个更新进度条的函数，speed为速度参数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数体文件 processBar.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;processBar.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *label = <span class="string">&quot;|-\\&quot;</span>;              <span class="comment">// 旋转动画符号, 用于表示进度条右侧的动态符号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新进度条函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processbar</span><span class="params">(<span class="type">int</span> speed)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> bar[NUM];                         <span class="comment">// 创建一个字符数组，用来存储进度条的状态</span></span><br><span class="line">    <span class="built_in">memset</span>(bar, <span class="string">&#x27;\0&#x27;</span>, <span class="built_in">sizeof</span>(bar));        <span class="comment">// 初始化进度条数组，填充空字符</span></span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(label);               <span class="comment">// 获取动画符号的长度，label长度用于循环动画符号</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;                           <span class="comment">// 进度条的当前进度，初始为0</span></span><br><span class="line">    <span class="keyword">while</span> (cnt &lt;= TOP)                     <span class="comment">// 当进度小于等于最大值（100%）时，持续循环</span></span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="comment">// 在进度条的前面输出进度状态，格式：[进度条状态][百分比][动画符号]</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%-100s][%d%%][%c]\r&quot;</span>, bar, cnt, label[cnt % len]);</span><br><span class="line">        <span class="built_in">fflush</span>(stdout);                    <span class="comment">// 强制刷新输出缓冲区，以确保进度条实时更新显示</span></span><br><span class="line">        bar[cnt++] = BODY;                 <span class="comment">// 将进度条数组的当前进度位置更新为进度条主体符号</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cnt &lt; TOP)                     <span class="comment">// 如果当前进度小于最大值，则更新尾部符号</span></span><br><span class="line">        &#123;</span><br><span class="line">            bar[cnt] = RIGHT;              <span class="comment">// 在进度条的尾部添加&#x27;&gt;&#x27;符号，表示当前进度</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">usleep</span>(speed);                     <span class="comment">// 使用usleep函数控制更新速度，单位为微秒</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);                          <span class="comment">// 完成进度条后换行，避免覆盖命令行内容</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// main函数文件 processBarmain.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;processBar.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">processbar</span>(<span class="number">50000</span>);                     <span class="comment">// 调用进度条函数，传入速度参数（单位：微秒）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第二版：支持单任务和多任务调用"><a href="#第二版：支持单任务和多任务调用" class="headerlink" title="第二版：支持单任务和多任务调用"></a>第二版：支持单任务和多任务调用</h3><h4 id="1-单任务调用"><a href="#1-单任务调用" class="headerlink" title="1. 单任务调用"></a>1. 单任务调用</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头文件 processBar.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once   <span class="comment">// 防止头文件重复包含</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>   <span class="comment">// 引入标准输入输出库，用于 printf()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>  <span class="comment">// 引入unistd.h库，用于 usleep()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span>  <span class="comment">// 引入字符串处理库，用于 strlen()</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 宏定义常量</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NUM 102      <span class="comment">// 进度条的长度</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TOP 100      <span class="comment">// 进度条的最大值（100%）</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BODY <span class="string">&#x27;-&#x27;</span>     <span class="comment">// 进度条填充的字符</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RIGHT <span class="string">&#x27;&gt;&#x27;</span>    <span class="comment">// 进度条末尾的字符，表示进度的指示符</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">void</span> <span class="title">processbar</span><span class="params">(<span class="type">int</span> rate)</span></span>;<span class="comment">// 声明外部函数 processbar()，用于更新进度条</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数体文件 processBar.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;processBar.h&quot;</span>  <span class="comment">// 引入头文件，声明了 processbar() 和相关常量</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *label = <span class="string">&quot;|-\\&quot;</span>;</span><br><span class="line"><span class="type">char</span> bar[NUM];  <span class="comment">// 存储进度条的字符数组，长度为 NUM（102）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新进度条函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processbar</span><span class="params">(<span class="type">int</span> rate)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (rate &lt; <span class="number">0</span> || rate &gt; <span class="number">100</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;<span class="comment">// 如果进度值不在有效范围内（0 到 100），直接返回</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(label);  <span class="comment">// 获取 label 字符串的长度，用于后续计算进度条的状态显示</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印进度条信息</span></span><br><span class="line">    <span class="comment">// [%-100s] 打印进度条的当前状态（由 bar 数组表示）</span></span><br><span class="line">    <span class="comment">// [%d%%] 打印当前进度百分比</span></span><br><span class="line">    <span class="comment">// [%c] 打印动态变化的进度条符号（`|`, `-`, `\`, 或 `\\`）</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[%-100s][%d%%][%c]\r&quot;</span>, bar, rate, label[rate % len]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fflush</span>(stdout);  <span class="comment">// 刷新标准输出，确保进度条立即显示</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新进度条的当前状态</span></span><br><span class="line">    bar[rate++] = BODY;  <span class="comment">// 填充进度条的当前位置（使用定义的 BODY 字符）</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (rate &lt; <span class="number">100</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        bar[rate] = RIGHT;<span class="comment">// 如果进度没有达到 100%，则在当前进度末尾添加一个 RIGHT 字符（&#x27;&gt;&#x27;）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// main函数文件 processBarmain.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;processBar.h&quot;</span>  <span class="comment">// 引入头文件，声明了 processbar() 函数和其他常量</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> total = <span class="number">1000</span>;  <span class="comment">// 总进度，模拟下载的总大小</span></span><br><span class="line">    <span class="type">int</span> curr = <span class="number">0</span>;      <span class="comment">// 当前进度，从 0 开始</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟进度条更新</span></span><br><span class="line">    <span class="keyword">while</span> (curr &lt;= total)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 根据当前进度计算进度百分比</span></span><br><span class="line">        <span class="type">int</span> rate = (curr * <span class="number">100</span>) / total;<span class="comment">// 进度百分比计算公式</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">processbar</span>(rate);<span class="comment">// 调用 processbar() 函数，更新进度条</span></span><br><span class="line"></span><br><span class="line">        curr += <span class="number">10</span>;  <span class="comment">// 每次增加 10，模拟进度增加</span></span><br><span class="line">        <span class="built_in">usleep</span>(<span class="number">50000</span>);  <span class="comment">// 延迟 50 毫秒（模拟下载延迟）</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);  <span class="comment">// 下载完成后换行，清理输出格式</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 程序正常退出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-多任务调用："><a href="#2-多任务调用：" class="headerlink" title="2. 多任务调用："></a>2. 多任务调用：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义函数指针类型 callback_t，这个指针类型指向一个接受 int 参数并返回 void 的函数。用于作为回调函数，更新和展示进度。</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="type">callback_t</span>)</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下载函数，模拟一个下载过程，接受一个回调函数作为参数。该回调函数用于展示下载进度。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">download</span><span class="params">(<span class="type">callback_t</span> cb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> total = <span class="number">1000</span>;  <span class="comment">// 总下载量，模拟为 1000MB</span></span><br><span class="line">    <span class="type">int</span> curr = <span class="number">0</span>;      <span class="comment">// 当前下载量，初始化为 0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟下载过程，直到下载完成</span></span><br><span class="line">    <span class="keyword">while</span> (curr &lt;= total)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">usleep</span>(<span class="number">50000</span>);  <span class="comment">// 模拟下载过程中每次更新的延迟，50毫秒</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> rate = curr * <span class="number">100</span> / total;<span class="comment">// 计算当前下载进度的百分比</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">cb</span>(rate);<span class="comment">// 调用回调函数 cb，传入当前的进度百分比，例如，调用进度条更新函数 processbar(rate)</span></span><br><span class="line"></span><br><span class="line">        curr += <span class="number">10</span>;  <span class="comment">// 每次模拟下载进度增加 10MB</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);<span class="comment">// 打印换行符，确保下载过程结束后格式正确</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数，演示如何调用 download 函数并传入回调函数。每次调用 download 时，都会传入相同的回调函数 processbar 来展示进度。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;download 1:\n&quot;</span>);<span class="comment">// 输出下载开始的提示信息</span></span><br><span class="line">    <span class="built_in">download</span>(processbar);<span class="comment">// 调用 download 函数，传入 processbar 作为回调函数，显示下载进度</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;download 2:\n&quot;</span>);<span class="comment">// 输出第二次下载的提示信息</span></span><br><span class="line">    <span class="built_in">download</span>(processbar);<span class="comment">// 再次调用 download 函数，继续传入 processbar 作为回调函数</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;download 3:\n&quot;</span>);<span class="comment">// 输出第三次下载的提示信息</span></span><br><span class="line">    <span class="built_in">download</span>(processbar);<span class="comment">// 再次调用 download 函数，继续传入 processbar 作为回调函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 程序执行结束，返回 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次运行，会发现这样的多任务下载的进度条是同步的，不能达到真正的多任务下载，我们添加一个函数解决：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">initbar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(bar,<span class="string">&#x27;\0&#x27;</span>,<span class="built_in">sizeof</span>(bar));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-优化代码-——-第二版进度条诞生！"><a href="#3-优化代码-——-第二版进度条诞生！" class="headerlink" title="3. 优化代码 —— 第二版进度条诞生！"></a>3. 优化代码 —— 第二版进度条诞生！</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头文件 processBar.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NUM 102        <span class="comment">// 进度条数组的长度，定义进度条的最大容量</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TOP 100        <span class="comment">// 最大进度，定义进度条的最大进度（100%）</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BODY <span class="string">&#x27;-&#x27;</span>       <span class="comment">// 进度条主体符号，用于表示进度的主体部分</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RIGHT <span class="string">&#x27;&gt;&#x27;</span>      <span class="comment">// 进度条尾部符号，用于表示当前进度位置的尾部</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="type">callback_t</span>)</span><span class="params">(<span class="type">int</span>)</span></span>;  <span class="comment">// 定义一个函数指针类型，用于回调进度更新的函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processbar</span><span class="params">(<span class="type">int</span> rate)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">void</span> <span class="title">download</span><span class="params">(<span class="type">callback_t</span> cb)</span></span>;<span class="comment">// 函数声明，模拟下载过程并调用回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">void</span> <span class="title">initbar</span><span class="params">()</span></span>;                  <span class="comment">// 函数声明，用于初始化进度条</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数体文件 processBar.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;processBar.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *label = <span class="string">&quot;|-\\&quot;</span>;         <span class="comment">// 旋转动画符号，用于在进度条右侧展示动态符号</span></span><br><span class="line"><span class="type">char</span> bar[NUM];                      <span class="comment">// 全局进度条数组，用来存储当前的进度状态</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化进度条，将进度条数组清空</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initbar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(bar, <span class="string">&#x27;\0&#x27;</span>, <span class="built_in">sizeof</span>(bar));  <span class="comment">// 使用memset将进度条数组全部置为&#x27;\0&#x27;，表示进度条清空</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟下载过程，接受回调函数来更新进度条</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">download</span><span class="params">(<span class="type">callback_t</span> cb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> total = <span class="number">1000</span>;               <span class="comment">// 模拟总任务量（比如：1000MB）</span></span><br><span class="line">    <span class="type">int</span> curr = <span class="number">0</span>;                   <span class="comment">// 当前已完成的任务量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (curr &lt;= total)           <span class="comment">// 当当前进度小于总进度时，继续更新</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">usleep</span>(<span class="number">50000</span>);              <span class="comment">// 模拟一个耗时操作，每次延时50ms</span></span><br><span class="line">        <span class="type">int</span> rate = curr * <span class="number">100</span> / total;  <span class="comment">// 根据已完成的任务量计算当前进度百分比</span></span><br><span class="line">        <span class="built_in">cb</span>(rate);                    <span class="comment">// 调用回调函数更新进度条，传入当前进度百分比</span></span><br><span class="line">        curr += <span class="number">10</span>;                  <span class="comment">// 增量更新，假设每次下载增加10MB</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);                    <span class="comment">// 完成后换行，避免覆盖命令行内容</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新进度条的函数，根据传入的进度百分比显示进度</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processbar</span><span class="params">(<span class="type">int</span> rate)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 如果进度值无效，输出错误信息并返回</span></span><br><span class="line">    <span class="keyword">if</span> (rate &lt; <span class="number">0</span> || rate &gt; TOP)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Invalid rate: %d\n&quot;</span>, rate);  <span class="comment">// 错误输出</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(label);  <span class="comment">// 获取动画符号的长度，用于循环显示</span></span><br><span class="line">    <span class="comment">// 打印当前进度条状态：[进度条状态][百分比][动画符号]</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[%-100s][%d%%][%c]\r&quot;</span>, bar, rate, label[rate % len]);</span><br><span class="line">    <span class="built_in">fflush</span>(stdout);  <span class="comment">// 强制刷新输出缓冲区，确保进度条实时更新</span></span><br><span class="line"></span><br><span class="line">    bar[rate++] = BODY;   <span class="comment">// 在进度条数组的当前进度位置更新为主体符号（&#x27;-&#x27;）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果进度小于最大值，添加尾部符号（&#x27;&gt;&#x27;）</span></span><br><span class="line">    <span class="keyword">if</span> (rate &lt; TOP)</span><br><span class="line">    &#123;</span><br><span class="line">        bar[rate] = RIGHT;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main函数文件 processBarmain.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;processBar.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Download 1:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">download</span>(processbar);  <span class="comment">// 模拟第一个下载过程，并使用processbar回调更新进度条</span></span><br><span class="line">    <span class="built_in">initbar</span>();              <span class="comment">// 重置进度条</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Download 2:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">download</span>(processbar);  <span class="comment">// 模拟第二个下载过程</span></span><br><span class="line">    <span class="built_in">initbar</span>();              <span class="comment">// 重置进度条</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Download 3:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">download</span>(processbar);  <span class="comment">// 模拟第三个下载过程</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="第三版：彩色进度条（C-语言输出颜色）"><a href="#第三版：彩色进度条（C-语言输出颜色）" class="headerlink" title="第三版：彩色进度条（C 语言输出颜色）"></a>第三版：彩色进度条（<a href="https://blog.csdn.net/wuquan_1230/article/details/106077560">C 语言输出颜色</a>）</h3><p>我们以绿色为例，添加以下内容：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> GREEN <span class="string">&quot;\033[0;32;32m&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NONE <span class="string">&quot;\033[m&quot;</span></span></span><br></pre></td></tr></table></figure><p>将颜色渲染到进度条，就得到了最终的彩色进度条：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头文件 processBar.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NUM 102            <span class="comment">// 进度条数组的长度，定义进度条的最大容量</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TOP 100            <span class="comment">// 最大进度，定义进度条的最大值（100%）</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BODY <span class="string">&#x27;-&#x27;</span>           <span class="comment">// 进度条主体符号，用于表示进度的主体部分</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RIGHT <span class="string">&#x27;&gt;&#x27;</span>          <span class="comment">// 进度条尾部符号，用于表示当前进度的尾部</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GREEN <span class="string">&quot;\033[0;32;32m&quot;</span>  <span class="comment">// 设置绿色字体颜色</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NONE <span class="string">&quot;\033[m&quot;</span>          <span class="comment">// 恢复默认字体颜色</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="type">callback_t</span>)</span><span class="params">(<span class="type">int</span>)</span></span>;    <span class="comment">// 定义函数指针类型，用于回调进度更新的函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processbar</span><span class="params">(<span class="type">int</span> rate)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">void</span> <span class="title">download</span><span class="params">(<span class="type">callback_t</span> cb)</span></span>;<span class="comment">// 函数声明，模拟下载过程并调用回调函数更新进度</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">void</span> <span class="title">initbar</span><span class="params">()</span></span>;              <span class="comment">// 函数声明，用于初始化进度条</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数体文件 processBar.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;processBar.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *label = <span class="string">&quot;|-\\&quot;</span>;         <span class="comment">// 动画符号，用于显示进度条右侧的动态效果</span></span><br><span class="line"><span class="type">char</span> bar[NUM];                      <span class="comment">// 全局进度条数组，用于存储进度条的当前状态</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化进度条，将进度条数组清空</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initbar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(bar, <span class="string">&#x27;\0&#x27;</span>, <span class="built_in">sizeof</span>(bar)); <span class="comment">// 使用memset将进度条数组全部置为&#x27;\0&#x27;，表示进度条清空</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟下载过程，接受回调函数来更新进度条</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">download</span><span class="params">(<span class="type">callback_t</span> cb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> total = <span class="number">1000</span>;               <span class="comment">// 模拟总任务量（比如：1000MB）</span></span><br><span class="line">    <span class="type">int</span> curr = <span class="number">0</span>;                   <span class="comment">// 当前已完成的任务量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (curr &lt;= total)           <span class="comment">// 当当前进度小于总进度时，继续更新</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">usleep</span>(<span class="number">50000</span>);              <span class="comment">// 模拟一个耗时操作，每次延时50ms</span></span><br><span class="line">        <span class="type">int</span> rate = curr * <span class="number">100</span> / total;  <span class="comment">// 根据已完成的任务量计算当前进度百分比</span></span><br><span class="line">        <span class="built_in">cb</span>(rate);                   <span class="comment">// 调用回调函数更新进度条，传入当前进度百分比</span></span><br><span class="line">        curr += <span class="number">10</span>;                 <span class="comment">// 增量更新，假设每次下载增加10MB</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);                   <span class="comment">// 下载完成后输出换行，避免覆盖命令行内容</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新进度条的函数，根据传入的进度百分比显示进度</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processbar</span><span class="params">(<span class="type">int</span> rate)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (rate &lt; <span class="number">0</span> || rate &gt; TOP)     <span class="comment">// 如果传入的进度值无效（小于0或大于100），直接返回</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(label);  <span class="comment">// 获取动画符号的长度，用于循环显示旋转符号</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打印当前进度条状态：[进度条状态][百分比][动画符号]</span></span><br><span class="line">    <span class="comment">// 使用绿色显示进度条部分，恢复默认颜色后显示进度百分比和动画符号</span></span><br><span class="line">    <span class="built_in">printf</span>(GREEN <span class="string">&quot;[%-100s]&quot;</span> NONE <span class="string">&quot;[%d%%][%c]\r&quot;</span>, bar, rate, label[rate % len]);</span><br><span class="line">    <span class="built_in">fflush</span>(stdout);      <span class="comment">// 强制刷新输出缓冲区，确保进度条实时更新</span></span><br><span class="line"></span><br><span class="line">    bar[rate++] = BODY;   <span class="comment">// 在进度条数组的当前进度位置更新为主体符号（&#x27;-&#x27;）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rate &lt; TOP)</span><br><span class="line">    &#123;</span><br><span class="line">        bar[rate] = RIGHT;<span class="comment">// 如果进度小于最大值，则在尾部添加&#x27;&gt;&#x27;符号，表示当前进度位置</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main函数文件 processBarmain.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;processBar.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 模拟下载1，调用download函数进行下载并更新进度条</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Download 1:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">download</span>(processbar);    <span class="comment">// 调用download函数，并将processbar作为回调函数传入</span></span><br><span class="line">    <span class="built_in">initbar</span>();                <span class="comment">// 下载完成后重置进度条</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟下载2，重复下载过程并重置进度条</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Download 2:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">download</span>(processbar);    <span class="comment">// 第二次下载</span></span><br><span class="line">    <span class="built_in">initbar</span>();                <span class="comment">// 重置进度条</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟下载3，最后一次下载</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Download 3:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">download</span>(processbar);    <span class="comment">// 第三次下载</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;                 <span class="comment">// 程序结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过本文的实现，我们逐步完成了从基础进度条到支持多任务和彩色进度条的功能扩展。未来，可以进一步优化代码结构，支持更多功能，例如动态调整进度条长度、支持多种颜色等。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>008 Linux 开发工具（下） —— make、Makefile、git和gdb</title>
      <link href="/posts/54699.html"/>
      <url>/posts/54699.html</url>
      
        <content type="html"><![CDATA[<h1 id="Linux-开发工具（下）"><a href="#Linux-开发工具（下）" class="headerlink" title="Linux 开发工具（下）"></a>Linux 开发工具（下）</h1><h2 id="Linux-项目自动化构建工具-——-make-Makefile"><a href="#Linux-项目自动化构建工具-——-make-Makefile" class="headerlink" title="Linux 项目自动化构建工具 —— make &#x2F;  Makefile"></a>Linux 项目自动化构建工具 —— <code>make</code> &#x2F;  <code>Makefile</code></h2><h3 id="1-什么是-make-和-Makefile？"><a href="#1-什么是-make-和-Makefile？" class="headerlink" title="1. 什么是 make 和 Makefile？"></a>1. 什么是 <code>make</code> 和 <code>Makefile</code>？</h3><p>在大型软件项目中，源代码通常散布在多个文件和目录中。为了高效地管理这些文件之间的依赖关系并实现自动化编译，Linux 提供了非常强大的工具 —— <code>make</code>。<code>make</code> 是一个自动化构建工具，它通过读取 <code>Makefile</code> 文件中的规则来决定如何编译和链接程序。<code>Makefile</code> 是一个文本文件，其中定义了项目的依赖关系和构建规则。</p><h4 id="为什么需要-make？"><a href="#为什么需要-make？" class="headerlink" title="为什么需要 make？"></a>为什么需要 <code>make</code>？</h4><ul><li><strong>自动化构建</strong>：手动编译多个源文件并管理它们之间的依赖关系非常繁琐，<code>make</code> 可以自动化这一过程。</li><li><strong>增量编译</strong>：<code>make</code> 只会重新编译那些被修改的文件及其依赖项，从而节省编译时间。</li><li><strong>跨平台兼容</strong>：<code>Makefile</code> 可以在不同的平台上使用，只需稍作修改。</li></ul><h3 id="2-make-的基本工作原理"><a href="#2-make-的基本工作原理" class="headerlink" title="2. make 的基本工作原理"></a>2. <code>make</code> 的基本工作原理</h3><p><code>make</code> 的核心功能是根据文件的修改时间自动判断哪些文件需要重新编译。具体来说，它会根据文件间的依赖关系，确保只有修改过的部分被重新编译，避免无谓的重复编译。</p><h4 id="基本逻辑"><a href="#基本逻辑" class="headerlink" title="基本逻辑"></a>基本逻辑</h4><ul><li><p><strong>目标文件与依赖关系</strong><br> <code>make</code> 通过比较目标文件与依赖文件的修改时间来决定是否需要重新编译。如果目标文件不存在，或者依赖文件较新，<code>make</code> 就会重新执行对应的编译命令。</p></li><li><p><strong>举例说明</strong>：假设我们有如下的依赖关系：</p><ul><li><code>hello</code> 依赖于 <code>hello.o</code>。</li><li><code>hello.o</code> 依赖于 <code>hello.s</code>。</li><li><code>hello.s</code> 依赖于 <code>hello.i</code>。</li><li><code>hello.i</code> 依赖于 <code>hello.c</code>。</li></ul><p>当 <code>hello.c</code> 被修改后，<code>make</code> 会检查文件的修改时间，并按照依赖关系从 <code>hello.c</code> 开始，逐层更新直到最终目标 <code>hello</code>。</p></li></ul><h4 id="规则格式"><a href="#规则格式" class="headerlink" title="规则格式"></a>规则格式</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">目标文件：依赖文件</span><br><span class="line">    命令</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">hello: hello.o</span></span><br><span class="line">    gcc hello.o -o hello</span><br></pre></td></tr></table></figure><p>如果 <code>hello.o</code> 发生了变化，<code>make</code> 会执行 <code>gcc hello.o -o hello</code> 来生成目标文件 <code>hello</code>。</p><hr><h3 id="3-make-的工作流程"><a href="#3-make-的工作流程" class="headerlink" title="3. make 的工作流程"></a>3. <code>make</code> 的工作流程</h3><p><code>Makefile</code> 中的依赖关系往往构成一个“栈式”结构，即从最终目标开始，逐层向下寻找依赖，直到最初的源文件。</p><ol><li><strong>查找文件</strong>：<code>make</code> 会在当前目录下查找名为 <code>Makefile</code> 或 <code>makefile</code> 的文件。</li><li><strong>确定目标文件</strong>：找到文件后，它会查找文件中的第一个目标文件（如示例中的 <code>hello</code>）并将其作为最终的目标文件。</li><li><strong>检查依赖关系</strong>：如果目标文件不存在，或者其依赖文件的修改时间比目标文件更新，则执行相应的命令生成目标文件。</li><li><strong>递归处理依赖</strong>：如果目标文件的依赖文件（如 <code>hello.o</code>）不存在，则会进一步在当前文件中查找该依赖文件的规则，并依此进行生成。</li><li><strong>完成编译</strong>：按照依赖关系一层一层地处理，直到最终生成第一个目标文件。</li><li><strong>错误处理</strong>：如果在依赖关系的查找过程中出现错误（如最后被依赖的文件找不到），<code>make</code> 会直接退出并报错；对于命令执行的错误或编译不成功的情况，<code>make</code> 不会进行处理。</li></ol><p>例如下面这个 <code>Makefile</code> 片段展示的完整依赖链：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 目标文件 hello 依赖于 hello.o</span></span><br><span class="line"><span class="section">hello: hello.o</span></span><br><span class="line"><span class="comment"># gcc 用于编译链接生成可执行文件 (Executable)</span></span><br><span class="line">gcc hello.o -o hello</span><br><span class="line"></span><br><span class="line"><span class="comment"># 目标文件 hello.o 依赖于 hello.s</span></span><br><span class="line"><span class="section">hello.o: hello.s</span></span><br><span class="line"><span class="comment"># -c 表示只编译生成目标文件，不进行链接</span></span><br><span class="line">gcc -c hello.s -o hello.o</span><br><span class="line"></span><br><span class="line"><span class="comment"># 目标文件 hello.s 依赖于 hello.i</span></span><br><span class="line"><span class="section">hello.s: hello.i</span></span><br><span class="line"><span class="comment"># -S 表示生成汇编代码 (Assembly code)</span></span><br><span class="line">gcc -S hello.i -o hello.s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 目标文件 hello.i 依赖于 hello.c</span></span><br><span class="line"><span class="section">hello.i: hello.c</span></span><br><span class="line"><span class="comment"># -E 表示只预处理生成中间文件</span></span><br><span class="line">gcc -E hello.c -o hello.i</span><br></pre></td></tr></table></figure><ul><li><strong>依赖判断</strong>：当修改了 <code>hello.c</code> 后，<code>hello.i</code> 的时间戳就会落后于 <code>hello.c</code>，从而触发后续所有目标的重新编译。</li><li><strong>自动化依赖推导</strong>：<code>make</code> 会根据目标与依赖之间的时间比较，自动“回溯”整个依赖链，直到确定哪些文件需要重新生成。</li></ul><h3 id="4-伪目标-PHONY-与放置位置的讨论"><a href="#4-伪目标-PHONY-与放置位置的讨论" class="headerlink" title="4. 伪目标 .PHONY 与放置位置的讨论"></a>4. 伪目标 <code>.PHONY</code> 与放置位置的讨论</h3><p><strong>定义</strong>：伪目标（如 <code>clean</code>）一般用于清理工程中的目标文件，它们没有被第一个目标文件直接或间接关联。可以通过命令（如 <code>make clean</code>）显式执行其后的命令。伪目标的特性是 <strong>总是被执行</strong>，不会因为文件的存在而被忽略。</p><p>例如在 <code>Makefile</code> 中，我们经常会定义一些不对应实际文件的辅助目标，<code>clean</code> 目标通常用于删除编译产生的中间文件。为避免与同名文件产生冲突，我们使用 <code>.PHONY</code> 声明该目标总是需要执行：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">@rm -f hello.i hello.s hello.o hello</span><br><span class="line"><span class="comment"># 使用 `.PHONY` 声明后，`make clean` 会始终执行清理命令，即使当前目录下存在名为 `clean` 的文件。</span></span><br></pre></td></tr></table></figure><h4 id="关于-PHONY-clean-的放置位置"><a href="#关于-PHONY-clean-的放置位置" class="headerlink" title="关于 .PHONY: clean 的放置位置"></a>关于 <code>.PHONY: clean</code> 的放置位置</h4><p><strong>放在开头或结尾：</strong> 无论将 <code>.PHONY: clean</code> 放在 <code>Makefile</code> 的开头还是结尾，其功能是相同的，都会告诉 <code>make</code> “clean” 不是一个真实存在的文件。然而，从 <strong>代码可读性</strong> 和 <strong>维护性</strong> 的角度来看，通常建议将辅助目标（如 <code>clean</code>）放在文件的末尾。这样做可以：</p><ul><li><strong>保持主构建规则的集中</strong>：主要的目标和依赖关系放在上面，便于开发者快速了解构建流程。</li><li><strong>逻辑分明</strong>：清理等辅助目标作为附加功能放在末尾，形成明显的区分。</li></ul><hr><h3 id="5-常见符号与自动变量的使用"><a href="#5-常见符号与自动变量的使用" class="headerlink" title="5. 常见符号与自动变量的使用"></a>5. 常见符号与自动变量的使用</h3><p>在编写 <code>Makefile</code> 时，合理使用一些特殊符号和自动变量能使文件更加简洁与灵活。</p><h4 id="——-命令隐藏符"><a href="#——-命令隐藏符" class="headerlink" title="@ —— 命令隐藏符"></a><code>@</code> —— 命令隐藏符</h4><p>在规则的命令前加上 <code>@</code> 符号，可以在执行时不将该命令打印到终端。例如：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">clean:</span></span><br><span class="line">@rm -f hello.i hello.s hello.o hello</span><br></pre></td></tr></table></figure><ul><li><strong>作用</strong>：使得执行 <code>make clean</code> 时不会在终端中显示 <code>rm -f ...</code> 这一行命令，从而使命令输出更干净，只显示必要的信息。</li></ul><h4 id="自动变量-与"><a href="#自动变量-与" class="headerlink" title="自动变量 $^ 与 $@"></a>自动变量 <code>$^</code> 与 <code>$@</code></h4><ul><li><strong>$@</strong>：代表规则中的目标文件（Target）。</li><li><strong>$^</strong>：代表规则中所有的依赖文件（Prerequisites），通常用来减少重复输入依赖文件列表。</li></ul><p><strong>示例：</strong> 假设有多个依赖文件构成目标文件，我们可以这样写：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">hello: hello.o util.o</span></span><br><span class="line"><span class="comment"># $^ 表示所有依赖，即 &quot;hello.o util.o&quot;（：右边部分，若有多个，用空格隔开）</span></span><br><span class="line"><span class="comment"># $@ 表示目标，即 &quot;hello&quot;（：左边部分）</span></span><br><span class="line">gcc <span class="variable">$^</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure><p><strong>好处</strong>：使用自动变量能让规则更灵活且易于维护，尤其当依赖项较多时，避免重复书写目标和依赖文件名称。</p><h3 id="6-进阶技巧（了解）"><a href="#6-进阶技巧（了解）" class="headerlink" title="6. 进阶技巧（了解）"></a>6. 进阶技巧（了解）</h3><h4 id="变量定义与使用"><a href="#变量定义与使用" class="headerlink" title="变量定义与使用"></a>变量定义与使用</h4><p>在 <code>Makefile</code> 中，我们可以定义变量来简化重复的代码。例如：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CC = gcc</span><br><span class="line">CFLAGS = -Wall -O2</span><br><span class="line"></span><br><span class="line"><span class="section">myprogram: main.o utils.o</span></span><br><span class="line"><span class="variable">$(CC)</span> <span class="variable">$^</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="section">main.o: main.c utils.h</span></span><br><span class="line"><span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -c main.c -o main.o</span><br><span class="line"></span><br><span class="line"><span class="section">utils.o: utils.c utils.h</span></span><br><span class="line"><span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -c utils.c -o utils.o</span><br></pre></td></tr></table></figure><ul><li><strong><code>CC</code></strong>：定义编译器为 <code>gcc</code>。</li><li><strong><code>CFLAGS</code></strong>：定义编译选项为 <code>-Wall -O2</code>。</li></ul><h4 id="模式规则"><a href="#模式规则" class="headerlink" title="模式规则"></a>模式规则</h4><p>当项目中有多个相似的文件需要编译时，可以使用模式规则来简化 <code>Makefile</code>。例如：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">%.o: %.c</span></span><br><span class="line"><span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure><ul><li><strong><code>%.o</code></strong>：表示所有以 <code>.o</code> 结尾的目标文件。</li><li><strong><code>%.c</code></strong>：表示所有以 <code>.c</code> 结尾的源文件。</li><li><strong><code>$&lt;</code></strong>：表示第一个依赖文件。</li></ul><blockquote><h3 id="传道解惑"><a href="#传道解惑" class="headerlink" title="传道解惑"></a>传道解惑</h3><h4 id="文件-文件内容-文件属性"><a href="#文件-文件内容-文件属性" class="headerlink" title="&#x3D;&#x3D;文件 &#x3D; 文件内容 + 文件属性&#x3D;&#x3D;"></a>&#x3D;&#x3D;文件 &#x3D; 文件内容 + 文件属性&#x3D;&#x3D;</h4><p>在计算机系统中，文件不仅仅是包含数据内容的容器，它还具有一些属性，描述了文件的元数据（metadata）。这些属性包括文件的权限、修改时间、访问时间、所有者、大小等。</p><p>我们可以将文件的概念表示为：<strong>文件 &#x3D; 文件内容 + 文件属性</strong></p><p><strong>1. 文件内容（File Content）</strong></p><p>文件内容是文件实际存储的数据。对于文本文件，它通常是可读的字符串；对于二进制文件，它可以是任意的数据，如图像、音频、视频或程序代码等。文件内容是文件的核心部分，用户创建、编辑和删除文件时，主要涉及文件内容的操作。</p><p>例如，一个文本文件 <code>hello.txt</code> 的内容可能如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;Hello, World!</span><br></pre></td></tr></table></figure><p><strong>2. 文件属性（File Attributes）</strong></p><p>文件属性是描述文件元信息的数据，通常是系统自动管理的。这些属性并不直接涉及文件的内容，但它们在文件的管理、访问和权限控制中起着至关重要的作用。常见的文件属性包括：</p><ul><li><strong>文件权限（Permissions）</strong>：指定哪些用户或用户组可以读取、写入或执行文件。</li><li><strong>所有者（Owner）</strong>：文件的创建者或拥有者。</li><li><strong>创建时间（Creation Time）</strong>：文件首次创建的时间。</li><li><strong>修改时间（Modification Time, mtime）</strong>：文件内容最后一次修改的时间。</li><li><strong>访问时间（Access Time, atime）</strong>：文件最后一次被访问的时间（无论是读取、执行还是其他）。</li><li><strong>改变时间（Change Time, ctime）</strong>：文件的元数据（如权限、所有者、位置）最后一次修改的时间。</li></ul><p><strong>3. 文件属性详解</strong></p><ul><li><p><strong>修改时间（<code>mtime</code>）</strong>：修改时间表示文件内容上次修改的时间。每次文件内容改变时，<code>mtime</code> 就会更新。例如，如果你编辑并保存一个文本文件，那么该文件的 <code>mtime</code> 就会更新为当前时间。</p></li><li><p><strong>访问时间（<code>atime</code>）</strong>：访问时间表示文件上次被访问的时间。访问可以是读取文件内容、执行程序文件等操作。每当文件被读取时，<code>atime</code> 就会更新。需要注意的是，有些操作系统会进行优化，使得访问文件时不更新 <code>atime</code>，从而减少磁盘 I&#x2F;O。例如，使用 <code>cat</code> 命令读取文件内容会更新 <code>atime</code>。</p></li><li><p><strong>改变时间（<code>ctime</code>）</strong>：改变时间表示文件的元数据（如文件权限、文件名、所有者等）最后一次改变的时间。<code>ctime</code> 仅在文件的属性发生变化时更新，而不是文件内容。例如，如果改变了文件的权限或文件的所有者，<code>ctime</code> 会发生变化。</p></li></ul><p><strong>4. 文件操作与属性变化</strong></p><ul><li><p><strong>修改文件内容：</strong> 当我们修改文件内容时，文件的 <strong><code>mtime</code></strong> 会更新，而 <strong><code>atime</code></strong> 和 <strong><code>ctime</code></strong> 通常不变，除非文件本身被移动、重命名或修改其他元数据。例如，使用 <code>echo &quot;new content&quot; &gt; file.txt</code> 命令修改 <code>file.txt</code> 文件内容时，文件内容发生了变化，因此 <code>mtime</code> 会更新。</p></li><li><p><strong>访问文件：</strong> 当我们访问文件（例如读取文件内容）时，文件的 <strong><code>atime</code></strong> 会更新，但 <strong><code>mtime</code></strong> 和 <strong><code>ctime</code></strong> 不会发生变化。例如，使用 <code>cat file.txt</code> 读取文件内容时，文件的 <code>atime</code> 会更新，表示文件被访问了。</p></li><li><p><strong>修改文件属性：</strong> 当我们修改文件的权限、所有者等属性时，文件的 <strong><code>ctime</code></strong> 会更新。这个时间是文件元数据的变化标志，而不是文件内容本身的变化。例如，使用 <code>chmod</code> 修改文件权限时，<code>ctime</code> 会更新，但 <code>mtime</code> 和 <code>atime</code> 不会发生变化。</p></li></ul><p><strong>5. 文件属性的查看与修改</strong></p><p>在 Linux 系统中，可以使用 <code>ls</code> 命令查看文件的基本属性（如权限、所有者、时间等）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="built_in">ls</span> -l file.txt</span><br></pre></td></tr></table></figure><p>输出例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;-rw-r--r-- 1 user user 128 Feb 7 10:15 file.txt</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li><code>-rw-r--r--</code> 是文件的权限。</li><li><code>1</code> 是硬链接数量。</li><li><code>user</code> 是文件的所有者。</li><li><code>user</code> 是文件的所属用户组。</li><li><code>128</code> 是文件的大小。</li><li><code>Feb 7 10:15</code> 是文件的 <code>mtime</code>（修改时间）。</li></ul><p>要查看文件的 <strong><code>atime</code></strong> 和 <strong><code>ctime</code></strong>，可以使用 <code>stat</code> 命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="built_in">stat</span> file.txt</span><br></pre></td></tr></table></figure><p>输出例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;File: file.txt</span><br><span class="line">&gt;Size: 128       Blocks: 8          IO Block: 4096   regular file</span><br><span class="line">&gt;Device: 803h/2051d   Inode: 12345678  Links: 1</span><br><span class="line">&gt;Access: 2025-01-01 10:00:00.000000000</span><br><span class="line">&gt;Modify: 2025-01-01 10:00:00.000000000</span><br><span class="line">&gt;Change: 2025-01-01 10:00:00.000000000</span><br></pre></td></tr></table></figure><ul><li><code>Access</code>：<code>atime</code>（访问时间）</li><li><code>Modify</code>：<code>mtime</code>（修改时间）</li><li><code>Change</code>：<code>ctime</code>（更改时间）</li></ul></blockquote><hr><h2 id="Linux-下第一个小程序——进度条"><a href="#Linux-下第一个小程序——进度条" class="headerlink" title="Linux 下第一个小程序——进度条"></a>Linux 下第一个小程序——进度条</h2><h3 id="1-换行-vs-回车：键盘上的时光机"><a href="#1-换行-vs-回车：键盘上的时光机" class="headerlink" title="1. 换行 vs 回车：键盘上的时光机"></a>1. 换行 vs 回车：键盘上的时光机</h3><ul><li><strong>换行（Line Feed, <code>\n</code>）</strong>：光标移动到 <strong>下一行</strong>，但水平位置不变 。在一些系统中，换行符是 <code>\n</code>，也有的系统中（如 Windows）回车和换行会一起使用。</li><li><strong>回车（Carriage Return, <code>\r</code>）</strong>：光标回到 <strong>当前行的行首</strong>，不换行 。在很多操作系统中，回车是用来将光标重置到行首的位置。换行符通常是 <code>\r</code>。</li></ul><p><strong>生活场景比喻</strong>：想象你用打字机写文章，打完一行字后需要做两个动作：  </p><ul><li><strong>换行</strong>（Line Feed）：把纸向上推一行（对应 <code>\n</code>）  </li><li><strong>回车</strong>（Carriage Return）：把打印头移回最左侧（对应 <code>\r</code>）</li></ul><h3 id="2-行缓冲区：快递员的打包习惯"><a href="#2-行缓冲区：快递员的打包习惯" class="headerlink" title="2. 行缓冲区：快递员的打包习惯"></a>2. 行缓冲区：快递员的打包习惯</h3><p>行缓冲区（Line Buffering）是指输出流的数据并不是直接输出到屏幕或终端，而是先存储在缓冲区中。当缓冲区满时，数据才会被输出。这种方式提升了效率，减少了对系统资源的频繁访问。在 C 语言中，<code>printf()</code> 是行缓冲的典型例子。它的工作原理是：当你调用 <code>printf()</code> 打印一行文本时，数据并不是立刻显示，而是先被放到缓冲区中，直到遇到换行符 <code>\n</code> 时，系统才会将缓冲区的内容真正输出到屏幕上。</p><p><strong>生活场景比喻</strong>：快递员不会每收到一个小物件就立刻送货，而是攒满一车再出发。  <strong>行缓冲区</strong> 就像这个 “攒满一车” 的规则：  </p><ul><li>遇到 <code>\n</code> 换行符时立刻 “送货”（刷新缓冲区）  </li><li>缓冲区满时自动刷新  </li><li>程序正常结束时也会自动刷新</li></ul><p>标准输出（stdout）在终端中是 <strong>行缓冲</strong> 的，如果没有换行符 <code>\n</code>，缓冲区不会自动刷新，导致内容被覆盖或丢失。</p><h4 id="实验验证与现象分析"><a href="#实验验证与现象分析" class="headerlink" title="实验验证与现象分析"></a>实验验证与现象分析</h4><ul><li><p><strong>代码 1</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;123456\rAB&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li><strong>现象</strong>：只显示 <code>AB</code>。实测 <code>window</code> 的 <code>vs 2022</code> 显示 <code>AB 456</code> 应该是属于 <code>vs</code> 的“个人行为”。</li><li><strong>原因</strong>：<code>\r</code> 将光标移回行首，但缓冲区未刷新，内容被覆盖或未输出。</li></ul></li><li><p><strong>代码 2</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;123456\rAB\n&quot;);</span><br></pre></td></tr></table></figure><ul><li><strong>现象</strong>：终端显示 <code>AB3456</code>。</li><li><strong>原因</strong>：<code>\n</code> 触发了缓冲区的刷新，<code>AB</code> 覆盖了 <code>12</code>，然后换行。</li></ul></li></ul><hr><ul><li><p><strong>代码 3</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;123456\rAB&quot;</span>);</span><br><span class="line">fflush(<span class="built_in">stdout</span>); <span class="comment">// 手动刷新缓冲区</span></span><br></pre></td></tr></table></figure><ul><li><strong>现象</strong>：终端显示 <code>AB3456</code>。细节流程：<ul><li><code>123456</code> 被输出到终端，光标停留在 <code>6</code> 后面。</li><li><code>\r</code> 将光标移动到行首（即 <code>1</code> 的位置）。</li><li><code>AB</code> 被输出，覆盖了前两个字符 <code>12</code>，此时终端内容为 <code>AB3456</code>，光标停留在 <code>3</code> 的位置。</li></ul></li><li><strong>原因</strong>：<code>fflush(stdout)</code> 强制刷新缓冲区，<code>AB</code> 覆盖了 <code>12</code>。</li></ul><p><strong>&#x3D;&#x3D;为什么我看到的只有 <code>AB</code>？&#x3D;&#x3D;</strong></p><p>我们不妨修改代码，运行后，3 秒内会看到 <code>AB3456</code>，随后提示符会进行覆盖，这也就是为什么我们看到的只有 <code>AB</code> 了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;123456\rAB&quot;</span>);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    sleep(<span class="number">3</span>); <span class="comment">// 暂停3秒，观察输出</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="Shell-提示符的输出行为"><a href="#Shell-提示符的输出行为" class="headerlink" title="Shell 提示符的输出行为"></a>Shell 提示符的输出行为</h4><ul><li>当程序运行结束后，Shell 会立即在 <strong>当前光标位置</strong> 输出提示符（如 <code>[damai@VM-16-11-centos coding]$</code>）。</li><li>由于程序结束时，光标停留在 <code>3</code> 的位置，Shell 提示符会从 <code>3</code> 的位置开始输出，<strong>覆盖</strong> 掉后面的内容 <code>3456</code>。</li></ul><h4 id="为什么覆盖？"><a href="#为什么覆盖？" class="headerlink" title="为什么覆盖？"></a>为什么覆盖？</h4><ul><li><strong>终端的工作机制</strong>：终端是一个字符设备，它会严格按照光标位置输出内容。如果光标不在行尾，新输出的内容会从光标位置开始覆盖已有的内容。</li><li><strong>Shell 提示符的输出</strong>：Shell 提示符不会主动换行，而是从当前光标位置开始输出。因此，如果程序没有将光标移动到行尾或换行，提示符就会覆盖程序输出的内容。</li></ul><p>知道了这些内容，我们就可以尝试看看下面代码运行的结果了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 实验1：无换行符，无刷新</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;123456\rAB&quot;</span>);</span><br><span class="line">    sleep(<span class="number">2</span>); <span class="comment">// 等待2秒观察现象</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>); <span class="comment">// 换行以刷新缓冲区</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实验2：有换行符</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;123456\rAB\n&quot;</span>);</span><br><span class="line">    sleep(<span class="number">2</span>); <span class="comment">// 等待2秒观察现象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实验3：手动刷新</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;123456\rAB&quot;</span>);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>); <span class="comment">// 手动刷新</span></span><br><span class="line">    sleep(<span class="number">2</span>); <span class="comment">// 等待2秒观察现象</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>); <span class="comment">// 换行</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>在来一遍，深刻理解</strong>：  </p><ol><li><p><strong>现象 1</strong>：没有换行符 <code>\n</code> 的情况下调用 <code>printf()</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello Makefile!&quot;</span>);</span><br><span class="line">    sleep(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>现象</strong>：这时 “hello Makefile!” 会先存入缓冲区，不会立刻显示在屏幕上。直到程序结束，缓冲区中的内容才会被显示出来。所以程序在运行完 <code>sleep(3)</code> 后，才会看到输出结果。</p></li><li><p><strong>现象 2</strong>：加上换行符 <code>\n</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello Makefile!\n&quot;</span>);</span><br><span class="line">    sleep(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>现象</strong>：这时，换行符 <code>\n</code> 会强制刷新缓冲区，所以 “hello Makefile!” 会立即输出，等待 3 秒后程序结束。</p></li><li><p><strong>现象 3</strong>：调用 <code>fflush(stdout)</code> 强制刷新缓冲区：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello Makefile!&quot;</span>);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);  <span class="comment">// 强制刷新缓冲区</span></span><br><span class="line">    sleep(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>现象</strong>：调用 <code>fflush(stdout)</code> 后，<code>printf()</code> 输出的内容会立即显示，无论是否遇到换行符，缓冲区中的内容都会被强制刷新到屏幕上，等待 3 秒后程序结束。</p></li></ol><hr><h3 id="3-倒计时实现"><a href="#3-倒计时实现" class="headerlink" title="3. 倒计时实现"></a>3. 倒计时实现</h3><p>理解了回车换行和行缓冲区的概念后，我们再来做一个倒计时的实现，相信下面的代码很容易理解：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">while</span> (cnt &gt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\r&quot;</span>, cnt);</span><br><span class="line"><span class="built_in">fflush</span>(stdout);</span><br><span class="line">cnt--;</span><br><span class="line"><span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行一下，会发现倒计时的显示效果是：<code>10</code> → <code>90</code> → <code>80</code> → <code>70</code> → <code>……</code>，而不是预期的 <code>10</code> → <code>9</code> → <code>8</code> → ……。<strong>数字宽度不一致</strong>, 当 <code>cnt</code> 为两位数 <code>10</code> 时，输出 <code>10</code>；而当 <code>cnt</code> 变为一位数（如 9）时，输出的是 <code>9</code>。因此，当从两位数输出变为一位数输出时，上一轮输出中的多余字符（例如 <code>10</code> 中的 <code>1</code>）依然残留在屏幕上。我们做以下修改即可：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%2d\r&quot;</span>, cnt);<span class="comment">// 调整输出格式:如果 cnt 只有一位数，则会在数字前补空格</span></span><br></pre></td></tr></table></figure><p>再次运行会发现，倒计时站两个字符，前一个字符空出，只有后一个字符在变化，显得不太正常，我们接着做修改：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%-2d\r&quot;</span>, cnt);<span class="comment">// 修改对其规则：左对齐</span></span><br></pre></td></tr></table></figure><p>于是，我们的倒计时就实现了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> <span class="comment">// 包含 sleep 函数</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">10</span>; <span class="comment">// 初始化倒计时值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (cnt &gt;= <span class="number">0</span>) <span class="comment">// 循环直到倒计时结束</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%-2d\r&quot;</span>, cnt); <span class="comment">// 格式化输出，左对齐，固定宽度为2，并覆盖之前输出中多余的字符</span></span><br><span class="line">        <span class="built_in">fflush</span>(stdout);        <span class="comment">// 强制刷新缓冲区，确保立即输出</span></span><br><span class="line">        cnt--;                 <span class="comment">// 倒计时减1</span></span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);              <span class="comment">// 暂停1秒</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;倒计时结束！\n&quot;</span>); <span class="comment">// 倒计时完成后输出提示信息</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-由于进度条相关文章内容过长，详见下一篇文章！"><a href="#4-由于进度条相关文章内容过长，详见下一篇文章！" class="headerlink" title="4. 由于进度条相关文章内容过长，详见下一篇文章！"></a>4. 由于进度条相关文章内容过长，详见下一篇文章！</h3><hr><h2 id="git-的使用"><a href="#git-的使用" class="headerlink" title="git  的使用"></a><code>git </code> 的使用</h2><p>&#x3D;&#x3D;这里会简单叙述 <strong><code>Git</code> 的诞生与核心价值</strong>，然而关于 <code>git</code> 远远不止于此，需要大量内容才能将 <code>git</code> 讲清楚，所以，未来我会专门出一个专题来对 <code>git</code> 进行详细的讲解！&#x3D;&#x3D;</p><h3 id="一、Git-的本质：时间管理大师的-“时光机”"><a href="#一、Git-的本质：时间管理大师的-“时光机”" class="headerlink" title="一、Git 的本质：时间管理大师的 “时光机”"></a>一、Git 的本质：时间管理大师的 “时光机”</h3><p>要理解 Git，我们可以想象一个科幻场景：假设你正在写一本小说，每天创作的新章节都会生成一个独立的时间胶囊。某天你发现主角设定出了问题，只需打开对应日期的胶囊就能恢复原貌。Git 本质上就是这样一个分布式时光机。它通过记录文件的 “快照” 而非差异（如 SVN），让每个开发者电脑都保存完整的版本库。例如：</p><ul><li><strong>张三改实验报告</strong>：李四作为 “版本管家”，每次收到修改都存档并标注（<code>git commit</code>）</li><li><strong>多人协作写代码</strong>：就像乐队分声部排练，Git 确保所有乐谱修改能精准合并（<code>git merge</code>）</li></ul><h3 id="二、Linus-Torvalds：被逼出来的创新"><a href="#二、Linus-Torvalds：被逼出来的创新" class="headerlink" title="二、Linus Torvalds：被逼出来的创新"></a>二、Linus Torvalds：被逼出来的创新</h3><p>Linux 之父林纳斯·托瓦兹（Linus Torvalds）与 <code>Git</code> 的渊源，堪称技术界的 “<strong>复仇爽文</strong>“：</p><p>在 2002 年以前，lucubrate Linux 的庞大社区还处于一种极度原始的代码管理状态，依靠着手工合并代码来维系项目 Progress。这无疑给参与其中的开发者们带来了巨大的不便与低效，令人不禁联想起原始部落艰难求生的画面。</p><p>随后，商业工具 BitKeeper 的引入仿佛曙光初现，为 Linux 内核的代码管理带来了短暂的清朗时期。却不曾想，因社区成员尝试逆向工程这一敏感行为，(BitKeeper 开发团队)愤然剥夺了 Linux 社区的使用授权。正如同好不容易借到的宝藏工具突然被夺走，开发者们再度陷入了深深的困境，这无疑是压垮骆驼的最后一根稻草。</p><p>在这一刻，Linus Torvalds，Linux 之父，心中愤怒与不甘的火焰熊熊燃烧。他深知，若不能寻得有效的解决之道，Linux 项目的未来将满是荆棘。于是，两周，<strong>仅仅两周的时间</strong>，他凭借着过人的智慧与毅力，完成了 Git 原型的编写。而一个月内，Linux 内核便成功迁移到这个自主开发的全新系统上，整个过程仿若一场奇迹。</p><p><strong>“ 就像被房东赶走的窘迫之人，在绝望之中亲手盖出了一栋更豪华的别墅。” —— 网友评价</strong></p><h3 id="三、Git-的革命性突破"><a href="#三、Git-的革命性突破" class="headerlink" title="三、Git 的革命性突破"></a>三、Git 的革命性突破</h3><p>对比传统版本控制工具，Git 实现了三大飞跃：</p><table><thead><tr><th align="center">特性</th><th align="left">集中式（如 SVN）</th><th>Git 分布式</th></tr></thead><tbody><tr><td align="center">网络依赖</td><td align="left">必须联网提交</td><td>本地即可完成所有操作</td></tr><tr><td align="center">数据安全</td><td align="left">中央服务器故障即丢失历史</td><td>每个副本都是完整备份</td></tr><tr><td align="center">分支管理</td><td align="left">创建&#x2F;合并分支耗时</td><td>轻量级分支秒级切换</td></tr></tbody></table><h3 id="四、Git-的现代发展"><a href="#四、Git-的现代发展" class="headerlink" title="四、Git 的现代发展"></a>四、Git 的现代发展</h3><p>Git 自诞生以来，逐渐在全球范围内普及并成为开发人员的标准工具之一。以下是 Git 现代发展的几个关键点：</p><p><strong>1. GitHub 的崛起</strong></p><p>2008 年，GitHub 上线，它为 Git 提供了一个强大的托管平台，使得开发者可以方便地在线托管代码，并且与其他开发者协作。GitHub 通过引入 Pull Request（PR）功能，让 Git 的协作模式更加高效，推动了开源社区的快速发展。很多知名的开源项目（如 jQuery、Node.js 等）都迁移到了 GitHub。</p><p><strong>2. 中国化适配：Gitee 等本土平台</strong></p><p>由于 GitHub 在中国大陆访问受到一定限制，本土平台如 Gitee 等逐渐兴起。Gitee 不仅解决了访问速度的问题，还提供了针对中国开发者的多种本地化功能，使得 Git 在国内的普及更加顺利。</p><p><strong>3. 可视化工具的普及</strong></p><p>随着 Git 的普及，越来越多的可视化工具如 GitKraken、SourceTree 等应运而生。这些工具通过图形界面简化了 Git 的操作，使得即使是没有命令行经验的开发者也能轻松上手。Git 的复杂操作变得更加直观和易用，降低了学习成本。</p><p><strong>4. 版本控制的精确性和回溯功能</strong></p><p>Git 的最大优势之一就是其强大的回溯能力。当开发者说“我回滚一下”，实际上就是“导演喊‘Cut！’重拍第 3 幕”。每个 <code>commit</code> 就像电影中的一个镜头，都可以精确回溯、查看和恢复，确保每一步的修改都能被追溯和复原。</p><h3 id="五、Git-改变了软件开发的方式"><a href="#五、Git-改变了软件开发的方式" class="headerlink" title="五、Git 改变了软件开发的方式"></a>五、Git 改变了软件开发的方式</h3><p>从 Linus Torvalds 的灵感到 Git 成为全球开发者的标准工具，Git 无疑已经成为软件开发的核心技术之一。Git 的核心价值不仅仅在于它如何管理版本，更在于它如何改变了开发者的工作方式、提高了协作效率，并且推动了开源软件的发展。</p><p>正如 Linus 所说：“Talk is cheap. Show me the code.” Git 用代码改变了世界，它的出现不仅仅是一个工具的革命，更是一种工作方式、协作方式和思想方式的革命。Git 的设计思想和实践，使得开发者能够更加专注于代码的创作，而不必过度担心版本管理的问题。</p><p>Git 不仅是一个技术工具，更是一种创新精神的体现——快速响应变化、追求效率、关注团队协作、并持续优化。它的成功，也象征着开源社区强大的生命力和创新能力。</p><h3 id="六、git-的使用（Git-教程）"><a href="#六、git-的使用（Git-教程）" class="headerlink" title="六、git 的使用（Git 教程）"></a>六、<code>git</code> 的使用（<a href="https://liaoxuefeng.com/books/git/introduction/index.html">Git 教程</a>）</h3><h4 id="Git-的核心概念"><a href="#Git-的核心概念" class="headerlink" title="Git 的核心概念"></a>Git 的核心概念</h4><ol><li><strong>仓库（Repository）</strong>：Git 仓库是项目的核心，包含了项目的所有文件和历史记录。每个开发者都有一个完整的仓库副本。</li><li><strong>提交（Commit）</strong>：每次提交都是项目的一个快照，记录了文件的更改和提交信息。</li><li><strong>分支（Branch）</strong>：分支是开发中的独立线路，允许开发者在不同的分支上并行工作。</li><li><strong>合并（Merge）</strong>：将不同分支的更改合并到一起，确保代码的一致性。</li><li><strong>克隆（Clone）</strong>：从远程仓库复制一个完整的仓库到本地。</li><li><strong>拉取（Pull）</strong>：从远程仓库获取最新的更改并合并到本地分支。</li><li><strong>推送（Push）</strong>：将本地的更改上传到远程仓库。</li></ol><h4 id="Git-的工作流程"><a href="#Git-的工作流程" class="headerlink" title="Git 的工作流程"></a>Git 的工作流程</h4><ol><li><strong>初始化仓库</strong>：使用 <code>git init</code> 命令创建一个新的 Git 仓库。</li><li><strong>添加文件</strong>：使用 <code>git add</code> 命令将文件添加到暂存区。</li><li><strong>提交更改</strong>：使用 <code>git commit</code> 命令将暂存区的更改提交到仓库。</li><li><strong>创建分支</strong>：使用 <code>git branch</code> 命令创建一个新的分支。</li><li><strong>切换分支</strong>：使用 <code>git checkout</code> 命令切换到不同的分支。</li><li><strong>合并分支</strong>：使用 <code>git merge</code> 命令将不同分支的更改合并到一起。</li><li><strong>查看历史</strong>：使用 <code>git log</code> 命令查看提交历史。</li></ol><hr><p>我们在 Linux CentOS 7 云服务器上使用 Xshell 连接并操作 Git 时的一些常用的 Git 命令：</p><h4 id="1-安装-Git"><a href="#1-安装-Git" class="headerlink" title="1. 安装 Git"></a>1. 安装 Git</h4><p>首先，确保你的 CentOS 7 系统上已经安装了 Git。如果没有安装，可以使用以下命令进行安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 更新 yum 软件包</span></span><br><span class="line"><span class="built_in">sudo</span> yum update -y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 Git</span></span><br><span class="line"><span class="built_in">sudo</span> yum install -y git</span><br></pre></td></tr></table></figure><p>安装完成后，可以通过以下命令检查 Git 版本，确认安装成功：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git --version</span><br></pre></td></tr></table></figure><h4 id="2-配置-Git"><a href="#2-配置-Git" class="headerlink" title="2. 配置 Git"></a>2. 配置 Git</h4><p>在 <strong>第一次使用 Git</strong> 之前，需要配置用户名和邮箱，这些信息会出现在每次提交的记录中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;your_name&quot;</span>   <span class="comment"># 设置用户名</span></span><br><span class="line">git config --global user.email <span class="string">&quot;your_email@example.com&quot;</span>  <span class="comment"># 设置邮箱</span></span><br></pre></td></tr></table></figure><p>通过以下命令查看当前的 Git 配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --list</span><br></pre></td></tr></table></figure><h4 id="3-创建-初始化仓库"><a href="#3-创建-初始化仓库" class="headerlink" title="3. 创建&#x2F;初始化仓库"></a>3. 创建&#x2F;初始化仓库</h4><p>在当前目录下创建一个新的 Git 仓库，使用以下命令（这会在当前目录下生成一个 <code>.git</code> 目录，用于存储 Git 的版本控制信息）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><h4 id="4-克隆远程仓库"><a href="#4-克隆远程仓库" class="headerlink" title="4. 克隆远程仓库"></a>4. 克隆远程仓库</h4><p>如果想从远程仓库克隆一个项目到本地，可以使用 <code>git clone</code> 命令，这会将远程仓库的内容克隆到当前目录下的一个新文件夹中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/username/repository.git</span><br></pre></td></tr></table></figure><h4 id="5-查看仓库状态"><a href="#5-查看仓库状态" class="headerlink" title="5. 查看仓库状态"></a>5. 查看仓库状态</h4><p>使用以下命令可以查看当前仓库的状态，包括哪些文件被修改、哪些文件被暂存等：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure><h4 id="6-添加文件到暂存区"><a href="#6-添加文件到暂存区" class="headerlink" title="6. 添加文件到暂存区"></a>6. 添加文件到暂存区</h4><p>在对文件进行修改后，需要将文件添加到暂存区（Stage），以便后续提交：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add file_name<span class="comment"># 例如：git add temp.txt ，添加文件到暂存区</span></span><br></pre></td></tr></table></figure><p>如果想添加所有修改过的文件，可以使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure><h4 id="7-提交更改"><a href="#7-提交更改" class="headerlink" title="7. 提交更改"></a>7. 提交更改</h4><p>将暂存区的文件提交到本地仓库，<code>-m</code> 选项后面跟的是本次提交的描述信息。描述信息就是提交日志，尽量提交有意义的信息！：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">&quot;Your commit message&quot;</span><span class="comment"># 例如：git commit -m &quot;第一次提交&quot; ，提交到本地仓库</span></span><br></pre></td></tr></table></figure><h4 id="8-查看提交历史"><a href="#8-查看提交历史" class="headerlink" title="8. 查看提交历史"></a>8. 查看提交历史</h4><p>使用以下命令可以查看当前仓库的提交历史：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span></span><br></pre></td></tr></table></figure><p>还可以通过 <code>--oneline</code> 选项简化输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --oneline</span><br></pre></td></tr></table></figure><h4 id="9-查看远程仓库"><a href="#9-查看远程仓库" class="headerlink" title="9. 查看远程仓库"></a>9. 查看远程仓库</h4><p>查看当前配置的远程仓库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure><h4 id="10-添加-连接远程仓库"><a href="#10-添加-连接远程仓库" class="headerlink" title="10. 添加&#x2F;连接远程仓库"></a>10. 添加&#x2F;连接远程仓库</h4><p>添加&#x2F;连接一个新的远程仓库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin 远程版本库的URL</span><br><span class="line"><span class="comment"># 例如：git remote add origin https://github.com/your_username/your_repo.git</span></span><br></pre></td></tr></table></figure><h4 id="11-推送本地分支到远程仓库"><a href="#11-推送本地分支到远程仓库" class="headerlink" title="11. 推送本地分支到远程仓库"></a>11. 推送本地分支到远程仓库</h4><p>将本地分支的提交推送到远程仓库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git push origin 分支名称</span><br><span class="line">git push -u origin master<span class="comment"># 将 master 分支推送，并设置默认上游分支（常用）</span></span><br></pre></td></tr></table></figure><h4 id="12-拉取远程仓库的更新"><a href="#12-拉取远程仓库的更新" class="headerlink" title="12. 拉取远程仓库的更新"></a>12. 拉取远程仓库的更新</h4><p>从远程仓库拉取最新的更改并合并到当前分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git pull origin 分支名称</span><br><span class="line">git pull origin master<span class="comment"># 拉取远程仓库的最新代码并合并</span></span><br></pre></td></tr></table></figure><h4 id="13-撤销工作区的修改"><a href="#13-撤销工作区的修改" class="headerlink" title="13. 撤销工作区的修改"></a>13. 撤销工作区的修改</h4><p>撤销工作区中某个文件的修改，恢复到最近一次提交的状态：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- 文件名称</span><br><span class="line"><span class="comment"># 例如：git checkout -- file.txt丢弃工作区修改，恢复到最后一次提交状态</span></span><br></pre></td></tr></table></figure><h4 id="14-撤销暂存区的修改"><a href="#14-撤销暂存区的修改" class="headerlink" title="14. 撤销暂存区的修改"></a>14. 撤销暂存区的修改</h4><p>将某个文件从暂存区撤回到工作区：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD 文件名称</span><br></pre></td></tr></table></figure><h4 id="15-撤销提交"><a href="#15-撤销提交" class="headerlink" title="15. 撤销提交"></a>15. 撤销提交</h4><p>撤销上一次提交，只回退 <code>commit</code>，保留代码修改：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --soft HEAD~1</span><br></pre></td></tr></table></figure><p>撤销最近一次提交，并将更改放回工作区：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --soft HEAD^</span><br></pre></td></tr></table></figure><p>如果你想撤销提交并丢弃更改，可以使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD^</span><br></pre></td></tr></table></figure><h4 id="16-创建标签"><a href="#16-创建标签" class="headerlink" title="16. 创建标签"></a>16. 创建标签</h4><p>创建一个新的标签：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag 标签名称</span><br></pre></td></tr></table></figure><h4 id="17-查看标签"><a href="#17-查看标签" class="headerlink" title="17. 查看标签"></a>17. 查看标签</h4><p>查看所有标签：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag</span><br></pre></td></tr></table></figure><h4 id="18-推送标签到远程仓库"><a href="#18-推送标签到远程仓库" class="headerlink" title="18. 推送标签到远程仓库"></a>18. 推送标签到远程仓库</h4><p>将本地标签推送到远程仓库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin 标签名称</span><br></pre></td></tr></table></figure><h4 id="19-查看差异"><a href="#19-查看差异" class="headerlink" title="19. 查看差异"></a>19. 查看差异</h4><p>查看工作区与暂存区的差异：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff</span><br></pre></td></tr></table></figure><p>查看暂存区与最新提交的差异：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff --cached</span><br></pre></td></tr></table></figure><h4 id="20-查看远程分支"><a href="#20-查看远程分支" class="headerlink" title="20. 查看远程分支"></a>20. 查看远程分支</h4><p>查看远程仓库的所有分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -r</span><br></pre></td></tr></table></figure><h4 id="21-删除远程分支"><a href="#21-删除远程分支" class="headerlink" title="21. 删除远程分支"></a>21. 删除远程分支</h4><p>删除远程仓库的指定分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin --delete 分支名称</span><br></pre></td></tr></table></figure><p><strong>&#x3D;&#x3D;至于分支管理、多人协作和冲突管理等操作暂时用不到，放到以后再说，有兴趣可自行百度。&#x3D;&#x3D;</strong></p><hr><p>除了前面提到的基本操作，<code>Git </code> 在使用时还存在一些常见的注意事项（这里提到部分内容，如有其他问题需勤于百度）：</p><h3 id="1-Git-只会记录已添加到暂存区（staging-area）的修改"><a href="#1-Git-只会记录已添加到暂存区（staging-area）的修改" class="headerlink" title="1. Git 只会记录已添加到暂存区（staging area）的修改"></a>1. Git 只会记录已添加到暂存区（staging area）的修改</h3><p>Git 不会自动跟踪所有修改。它只会跟踪你手动添加到暂存区的修改，即 <strong>默认记录修改部分（工作区和暂存区）</strong>。也就是通过 <code>git add</code> 添加的文件或更改。</p><ul><li><strong>工作区（Working Directory）</strong>：对文件的任何修改都首先体现在工作区。</li><li><strong>暂存区（Staging Area）</strong>：通过 <code>git add</code> 命令将修改暂存到 Git 中的暂存区。</li><li><strong>本地仓库（Repository）</strong>：通过 <code>git commit</code> 命令，将暂存区的修改提交到本地仓库。</li></ul><p><strong>关键点（工作流程）：</strong> 只有 <code>git add</code> 命令添加到暂存区的文件才会被 <code>git commit</code> 提交（修改文件 → <code>git add</code> 添加到暂存区 → <code>git commit</code> 提交到仓库）。</p><p><strong>示例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;This is a test&quot;</span> &gt; file.txt      <span class="comment"># 修改文件</span></span><br><span class="line">git status                            <span class="comment"># 查看状态，file.txt 会显示为修改状态</span></span><br><span class="line">git add file.txt                      <span class="comment"># 添加到暂存区</span></span><br><span class="line">git commit -m <span class="string">&quot;Updated file.txt&quot;</span>      <span class="comment"># 提交修改</span></span><br></pre></td></tr></table></figure><p><strong>忘记 <code>git add</code> 的后果</strong></p><p>如果修改了文件但没有执行 <code>git add</code>，然后直接 <code>git commit</code>，Git 是不会将这些修改提交的。因此，Git 只会记录已经添加到暂存区的修改。</p><h3 id="2-Git-忽略某些文件：-gitignore"><a href="#2-Git-忽略某些文件：-gitignore" class="headerlink" title="2. Git 忽略某些文件：.gitignore"></a>2. Git 忽略某些文件：<code>.gitignore</code></h3><p>如果不希望某些文件被 Git 跟踪（如编译出来的二进制文件、IDE 配置文件等），可以使用 <code>.gitignore</code> 文件来指定不需要跟踪的文件或文件夹。</p><p><strong>创建 .gitignore</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 例如，忽略所有 *.log 文件</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;*.log&quot;</span> &gt;&gt; .gitignore</span><br></pre></td></tr></table></figure><p><strong>然后 <code>git add .gitignore</code> 提交 <code>.gitignore</code> 文件！！！</strong></p><p><strong>关键点：</strong> <code>.gitignore</code> 文件是 Git 跟踪文件的方式之一。</p><h3 id="3-Git-配置文件的管理"><a href="#3-Git-配置文件的管理" class="headerlink" title="3. Git 配置文件的管理"></a>3. Git 配置文件的管理</h3><p>Git 配置文件分为三种层级：</p><ul><li><strong>系统级</strong>：影响系统上所有用户的配置，通常位于 <code>/etc/gitconfig</code>。</li><li><strong>全局级</strong>：影响当前用户的配置，通常位于 <code>~/.gitconfig</code>。</li><li><strong>仓库级</strong>：只对当前仓库生效，位于仓库的 <code>.git/config</code>。</li></ul><p>可以通过以下命令查看和修改 Git 配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;Your Name&quot;</span>     <span class="comment"># 设置全局用户名</span></span><br><span class="line">git config --global user.email <span class="string">&quot;you@example.com&quot;</span>  <span class="comment"># 设置全局邮箱</span></span><br></pre></td></tr></table></figure><p>查看当前配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --list</span><br></pre></td></tr></table></figure><hr><h2 id="Linux-调试器-——-gdb-的使用"><a href="#Linux-调试器-——-gdb-的使用" class="headerlink" title="Linux 调试器 —— gdb 的使用"></a>Linux 调试器 —— <code>gdb</code> 的使用</h2><h3 id="一、背景知识"><a href="#一、背景知识" class="headerlink" title="一、背景知识"></a>一、背景知识</h3><p>在程序开发过程中，为了有效定位和修复代码中的错误，调试工具起着至关重要的作用。程序的发布方式主要有两种：<code>debug</code> 模式和 <code>release</code> 模式。</p><ul><li><strong>debug 模式</strong>：此模式下编译生成的程序包含了丰富的调试信息，例如变量名、函数名、源代码行号等，方便开发者借助调试工具进行错误排查。不过，debug 模式通常会增加程序的体积，并且在一定程度上降低运行效率。</li><li><strong>release 模式</strong>：旨在提供高性能的可执行程序，编译时会进行各种优化，剔除不必要的调试信息，以确保程序运行速度和资源利用率最大化。在 Linux 系统中，使用 gcc 或 g++ 编译器编译出来的二进制程序，默认是 release 模式。</li></ul><p>若要使用 gdb（GNU Debugger）对程序进行调试，必须在源代码生成二进制程序时，加上 <code>-g</code> 选项。这样，编译器会在生成的可执行文件中嵌入调试所需的信息，使得 gdb 能够准确地关联程序运行状态与源代码。</p><p><strong>编译生成调试信息</strong></p><p>假设有一个源文件 <code>temp.c</code>，<code>-g</code> 告诉编译器生成调试信息，<code>-o temp</code> 指定输出文件名。可以通过以下命令编译程序并生成调试信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -g temp.c -o temp</span><br></pre></td></tr></table></figure><p><strong>启动 gdb</strong></p><p><code>gdb</code> 启动时需要提供一个已经编译好的二进制文件。假设我们有一个名为 <code>temp</code> 的程序文件，通过以下命令启动 <code>gdb</code> 准备进行调试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb temp</span><br></pre></td></tr></table></figure><p><strong>退出 GDB</strong></p><p>退出 GDB 的方式有两种：</p><ul><li>输入 <code>quit</code> 或 <code>q</code> 命令（常用）。</li><li>按下 <code>Ctrl + D</code>。</li></ul><h3 id="二、Windows-IDE-对应功能"><a href="#二、Windows-IDE-对应功能" class="headerlink" title="二、Windows IDE 对应功能"></a>二、Windows IDE 对应功能</h3><p>对于 Windows 用户习惯的 IDE 调试工具（如 Visual Studio），<code>gdb</code> 也提供了类似的功能。例如：</p><ul><li><strong>设置断点</strong>：在源代码中设置断点，并在程序执行时停止。</li><li><strong>单步调试</strong>：支持单步执行，可以选择逐行执行代码，或者进入函数内调试。</li><li><strong>变量观察</strong>：支持查看和修改变量的值，并可以在调试过程中动态修改它们。</li><li><strong>堆栈跟踪</strong>：查看当前调用栈以及每个函数的参数。</li></ul><p>与 Windows 中的 IDE 相比，<code>gdb</code> 是命令行工具，因此需要通过命令行输入调试命令，但功能是非常强大的。</p><hr><h3 id="三、gdb-常用命令"><a href="#三、gdb-常用命令" class="headerlink" title="三、gdb 常用命令"></a>三、<code>gdb</code> 常用命令</h3><p><strong>GDB 提示符的作用</strong></p><ul><li>当你启动 GDB 并加载程序后，GDB 会进入交互模式，显示 <code>(gdb)</code> 提示符。</li><li>这个提示符表示 GDB 正在等待你输入命令。</li><li>你只需要在 <code>(gdb)</code> 后面输入命令，按回车执行。</li></ul><p>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) <span class="built_in">break</span> main<span class="comment"># (gdb) 是 GDB 的提示符，只需要输入 break main 并按回车即可</span></span><br></pre></td></tr></table></figure><h4 id="1-查看源代码"><a href="#1-查看源代码" class="headerlink" title="1. 查看源代码"></a>1. 查看源代码</h4><p><strong><code>list</code> 或 <code>l</code></strong>：查看源代码。</p><ul><li><code>list &lt;行号&gt;</code>：从指定行号开始显示源代码。</li><li><code>list &lt;函数名&gt;</code>：显示指定函数的源代码。</li><li>默认每次显示 10 行，按回车键继续显示后续内容。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(gdb) list 10      <span class="comment"># 显示从第 10 行开始的源代码</span></span><br><span class="line">(gdb) list         <span class="comment"># 显示当前行及接下来的 10 行</span></span><br><span class="line">(gdb) l main       <span class="comment"># 显示 main 函数的源代码</span></span><br></pre></td></tr></table></figure><h4 id="2-运行程序"><a href="#2-运行程序" class="headerlink" title="2. 运行程序"></a>2. 运行程序</h4><p><strong><code>run</code> 或 <code>r</code></strong>：从头开始运行程序。</p><ul><li>如果程序需要参数，可以在 <code>run</code> 后面加上参数：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) run           <span class="comment"># 启动程序的执行，不带任何命令行参数</span></span><br><span class="line">(gdb) run arg1 arg2   <span class="comment"># 启动程序的执行，并传递两个命令行参数：arg1 和 arg2</span></span><br></pre></td></tr></table></figure><h4 id="3-单步执行"><a href="#3-单步执行" class="headerlink" title="3. 单步执行"></a>3. 单步执行</h4><ul><li><strong><code>next</code> 或 <code>n</code></strong>：单步执行（不进入函数内部）。</li><li><strong><code>step</code> 或 <code>s</code></strong>：单步执行（进入函数内部）。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) next<span class="comment"># 单步执行</span></span><br><span class="line">(gdb) step<span class="comment"># 进入函数内部</span></span><br></pre></td></tr></table></figure><h4 id="4-设置断点"><a href="#4-设置断点" class="headerlink" title="4. 设置断点"></a>4. 设置断点</h4><p><strong><code>break</code> 或 <code>b</code></strong>：设置断点。</p><ul><li><code>break &lt;行号&gt;</code>：在指定行设置断点。</li><li><code>break &lt;函数名&gt;</code>：在函数入口处设置断点。</li><li><strong><code>info breakpoints</code></strong>：查看当前设置的所有断点及其状态。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(gdb) <span class="built_in">break</span> 20<span class="comment"># 在第 20 行设置断点</span></span><br><span class="line">(gdb) <span class="built_in">break</span> main<span class="comment"># 在 main 函数的开头设置断点</span></span><br><span class="line">(gdb) info breakpoints    <span class="comment"># 查看所有断点信息</span></span><br></pre></td></tr></table></figure><h4 id="5-删除断点"><a href="#5-删除断点" class="headerlink" title="5. 删除断点"></a>5. 删除断点</h4><ul><li><strong><code>delete breakpoints</code></strong>：删除所有断点。</li><li><strong><code>delete breakpoints n</code></strong>：删除序号为 <code>n</code> 的断点。</li><li><strong><code>disable breakpoints</code></strong>：禁用所有断点，使其在下次调试时不起作用。</li><li><strong><code>enable breakpoints</code></strong>：启用所有已禁用的断点。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(gdb) delete breakpoints     <span class="comment"># 删除所有断点</span></span><br><span class="line">(gdb) delete breakpoints 1   <span class="comment"># 删除序号为 1 的断点</span></span><br><span class="line">(gdb) <span class="built_in">disable</span> breakpoints    <span class="comment"># 禁用所有断点</span></span><br><span class="line">(gdb) <span class="built_in">enable</span> breakpoints     <span class="comment"># 启用所有断点</span></span><br></pre></td></tr></table></figure><h4 id="6-继续执行"><a href="#6-继续执行" class="headerlink" title="6. 继续执行"></a>6. 继续执行</h4><p><strong><code>continue</code> 或 <code>c</code></strong>：从当前位置继续执行，直到遇到下一个断点或程序结束。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) <span class="built_in">continue</span>    <span class="comment"># 继续执行程序</span></span><br></pre></td></tr></table></figure><h4 id="7-查看和修改变量"><a href="#7-查看和修改变量" class="headerlink" title="7. 查看和修改变量"></a>7. 查看和修改变量</h4><p><strong><code>print</code> 或 <code>p</code></strong>：打印变量的值。</p><ul><li><code>print &lt;变量名&gt;</code>：打印变量的值。</li><li><code>print &lt;表达式&gt;</code>：计算并打印表达式的值。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) <span class="built_in">print</span> x<span class="comment"># 打印变量 x 的值</span></span><br><span class="line">(gdb) <span class="built_in">print</span> x + y</span><br></pre></td></tr></table></figure><p><strong><code>set var 变量名=值</code></strong>：修改变量的值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) <span class="built_in">set</span> var x=10    <span class="comment"># 将变量 x 的值修改为 10</span></span><br></pre></td></tr></table></figure><h4 id="8-跟踪变量"><a href="#8-跟踪变量" class="headerlink" title="8. 跟踪变量"></a>8. 跟踪变量</h4><ul><li><strong><code>display &lt;变量名&gt;</code></strong>：每次程序暂停时，自动打印变量的值。</li><li><strong><code>undisplay &lt;编号&gt;</code></strong>：取消对变量的跟踪。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) display x     <span class="comment"># 每次停止时显示变量 x 的值</span></span><br><span class="line">(gdb) undisplay     <span class="comment"># 取消所有跟踪变量</span></span><br></pre></td></tr></table></figure><h4 id="9-查看函数调用栈"><a href="#9-查看函数调用栈" class="headerlink" title="9. 查看函数调用栈"></a>9. 查看函数调用栈</h4><p><strong><code>backtrace</code> 或 <code>bt</code></strong>：查看当前函数的调用栈（包括参数和调用位置）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) backtrace      <span class="comment"># 查看函数调用栈</span></span><br></pre></td></tr></table></figure><h4 id="10-查看局部变量"><a href="#10-查看局部变量" class="headerlink" title="10. 查看局部变量"></a>10. 查看局部变量</h4><p><strong><code>info locals</code></strong>：查看当前函数的局部变量。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) info locals<span class="comment"># 查看当前栈帧的局部变量</span></span><br></pre></td></tr></table></figure><h4 id="11-跳转到指定行"><a href="#11-跳转到指定行" class="headerlink" title="11. 跳转到指定行"></a>11. 跳转到指定行</h4><p><strong><code>until &lt;行号&gt;</code></strong>：跳转到指定行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) <span class="keyword">until</span> 30<span class="comment"># 跳转到第30行</span></span><br></pre></td></tr></table></figure><h4 id="12-退出函数"><a href="#12-退出函数" class="headerlink" title="12. 退出函数"></a>12. 退出函数</h4><p><strong><code>finish</code></strong>：执行完当前函数并暂停。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) finish<span class="comment"># 执行完当前函数并暂停</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>006 yum和Linux生态</title>
      <link href="/posts/15646.html"/>
      <url>/posts/15646.html</url>
      
        <content type="html"><![CDATA[<h2 id="Linux-软件包管理器-yum"><a href="#Linux-软件包管理器-yum" class="headerlink" title="Linux 软件包管理器 yum"></a><code>Linux</code> 软件包管理器 <code>yum</code></h2><p>在 Linux 中，安装软件的常见方式主要有三种：源代码安装、<code>rpm</code> 安装和 <code>yum</code> 安装。它们各自有优缺点，适用于不同的场景。</p><table><thead><tr><th>安装方式</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td><strong>源代码安装</strong></td><td>- 高度定制化（调整编译选项、安装路径等）</td><td>- 操作复杂，需要手动执行 <code>./configure</code>, <code>make</code>, <code>make install</code> 等步骤</td></tr><tr><td></td><td>- 软件版本灵活（能获取最新版本或特定版本）</td><td>- 依赖管理困难，需手动解决依赖关系</td></tr><tr><td></td><td>- 跨平台兼容性强（适配不同架构或操作系统）</td><td>- 编译过程时间长，消耗大量计算资源</td></tr><tr><td></td><td></td><td>- 升级和卸载困难，缺乏统一的版本管理</td></tr><tr><td><strong><code>rpm</code> 安装</strong></td><td>- 安装速度快，使用预编译的二进制包</td><td>- 依赖需手动解决，可能出现“依赖地狱”</td></tr><tr><td></td><td>- 安装时自动检查并提示缺少的依赖项</td><td>- 版本受限于本地或下载的 RPM 包，可能无法获取最新版本</td></tr><tr><td></td><td>- 通过 <code>rpm</code> 命令可管理软件包（查询、验证、升级、卸载等）</td><td>- 默认不关联远程仓库，依赖本地或手动下载的 RPM 包</td></tr><tr><td><strong><code>yum</code> 安装</strong></td><td>- 自动解决依赖关系，简化安装过程</td><td>- 需要联网访问仓库（离线环境需配置本地镜像）</td></tr><tr><td></td><td>- 支持多个远程仓库，软件版本经过测试，保证兼容性</td><td>- 仓库中的软件版本可能滞后于上游源码版本</td></tr><tr><td></td><td>- 简化操作，支持一键安装、更新、卸载</td><td></td></tr><tr><td></td><td>- 安全更新，仓库提供数字签名验证</td><td></td></tr><tr><td></td><td>- 版本灵活性，支持快速切换软件版本</td><td></td></tr></tbody></table><p><strong>总的来说：</strong></p><ul><li><strong>源代码安装</strong>：复杂、遥远，普通用户几乎不需要使用。</li><li><strong><code>rpm</code> 安装</strong>：依赖问题复杂，对小白用户不够友好。</li><li><strong><code>yum</code> 安装</strong>：自动解决依赖、操作简单、版本管理方便，是普通用户的最佳选择。</li></ul><hr><h3 id="什么是软件包？"><a href="#什么是软件包？" class="headerlink" title="什么是软件包？"></a>什么是软件包？</h3><p><strong>1. 软件包和软件包管理器的关系</strong></p><ul><li><strong>软件包（Package）</strong>：就像 Windows 下的安装程序一样，软件包是已经编译好的软件，通常包含了可执行程序、配置文件、依赖关系和其他必要的资源。用户只需要通过简单的命令就可以将它们安装到系统中。软件包一般是针对特定操作系统或发行版（如 CentOS、Ubuntu 等）预编译的。</li><li><strong>软件包管理器（Package Manager）</strong>：它就像是“应用商店”，提供一个方便的接口让用户可以搜索、安装、更新和删除软件包。包管理器可以自动处理依赖关系、下载并安装正确的软件版本，同时还能确保系统的其他软件和包的一致性。</li></ul><p><strong>2. <code>yum</code>（Yellowdog Updater, Modified）</strong></p><p><strong>YUM</strong> 是一种在 Linux 下非常常用的包管理工具，它的作用类似于应用商店，让用户能够轻松地安装、更新、卸载软件包。</p><p><strong>主要特点：</strong></p><ul><li><strong>自动化安装和更新</strong>：只需使用简单的命令（如 <code>yum install 软件包名</code>）就能自动获取并安装软件包。包管理器会自动处理依赖关系，确保安装过程的顺利进行。</li><li><strong>依赖关系管理</strong>：在 Linux 中，很多软件都依赖于其他库或软件。<code>yum</code> 会自动检测软件包的依赖，确保安装时不会漏掉必要的组件。</li><li><strong>仓库支持</strong>：<code>yum </code> 通过配置软件仓库（Repository）来获取软件包，仓库相当于存放了大量软件包的 <strong>服务器</strong>。用户无需自己编译软件，只需要指定仓库，<code>yum </code> 就可以从中获取到已经编译好的软件包。</li><li><strong>简便的命令行界面</strong>：<code>yum</code> 提供了简单的命令行接口来处理软件包的安装、更新和卸载。比如：<ul><li><code>yum install &lt;软件包名&gt;</code>：安装软件包</li><li><code>yum update</code>：更新所有已安装的软件包</li><li><code>yum remove &lt;软件包名&gt;</code>：卸载软件包</li><li><code>yum search &lt;软件包名&gt;</code>：搜索软件包</li></ul></li><li><strong>安全性与稳定性</strong>：<code>yum</code> 的仓库中的软件包经过了测试（相当于经过应用商店审核），保证了软件与系统的兼容性。而且，<code>yum</code> 会自动处理安全更新，确保系统和软件的安全。</li></ul><p><strong>3. 对比 Windows 安装软件</strong></p><p>就像在 Windows 系统上，用户经常通过应用商店（例如 Microsoft Store）或者直接从第三方网站下载安装程序来安装软件一样，Linux 系统上的 <code>yum</code> 就是一个类似的工具。区别在于，Linux 下的软件包管理是更集成化和自动化的，依赖关系和版本更新会自动处理，而在 Windows 上，安装程序通常需要手动处理依赖或者更新。</p><p><strong>4. <code>yum</code> 的优势</strong></p><ul><li><strong>省时省力</strong>：不像从源代码编译那样需要手动下载、配置和编译。</li><li><strong>确保兼容性</strong>：<code>yum</code> 通过仓库（厂商或发行版维护者的 <strong>服务器</strong>）提供的软件包保证了软件和操作系统的兼容性，减少了因版本不匹配导致的问题。</li><li><strong>易于管理</strong>：通过 <code>yum</code>，用户可以方便地管理已安装的软件包，无论是安装新软件、更新已有软件，还是卸载不需要的软件，所有操作都可以通过简单的命令完成。</li></ul><hr><h3 id="基于-Linux-系统（CentOS-7）中使用-yum-命令来安装、卸载和管理-lrzsz-工具的步骤和注意事项。"><a href="#基于-Linux-系统（CentOS-7）中使用-yum-命令来安装、卸载和管理-lrzsz-工具的步骤和注意事项。" class="headerlink" title="基于 Linux 系统（CentOS 7）中使用 yum 命令来安装、卸载和管理 lrzsz 工具的步骤和注意事项。"></a>基于 Linux 系统（CentOS 7）中使用 <code>yum</code> 命令来安装、卸载和管理 <code>lrzsz</code> 工具的步骤和注意事项。</h3><p><strong>注意：</strong> 一般 Linux 操作系统，默认配置的 <code>yum</code> 源是国外的，有可能你的 <code>yum</code> 源访问会比较慢，可能需要更新 <code>yum</code> 源 替换 <code>yum</code> 源文件（这里常指使用虚拟机的）， <code>yum</code> <strong>服务器</strong> 一般厂商已经替换了，这就是学习时 <strong>云服务器优于虚拟机</strong> 的一个原因。</p><h4 id="关于-lrzsz-工具"><a href="#关于-lrzsz-工具" class="headerlink" title="关于 lrzsz 工具"></a>关于 <code>lrzsz</code> 工具</h4><p><strong>用途</strong>：<strong><code>lrzsz</code> 是一组用于在 Windows 和远程 Linux 机器之间通过 XShell 传输文件的工具。</strong> 我们可以通过拖拽的方式将文件从 <strong>Windows</strong> 机器上传到远程的 <strong>Linux</strong> 服务器。</p><p>安装了 <code>rzsz</code> 工具后，XShell 会自动识别，并允许我们将文件从 Windows 拖动到终端中，并通过 <code>rz</code>（接收文件）命令将文件上传到 Linux 系统。反过来，也可以从 <strong>Linux</strong> 下载文件到 <strong>Windows</strong>。只需在 Linux 上执行 <code>sz</code>（发送文件）命令，XShell 会自动接收并将文件传输到本地的 Windows 系统。</p><ul><li>在 <strong>XShell</strong> 中，执行 <code>rz</code> 命令（这将启动接收模式）。</li><li>在 <strong>XShell</strong> 中，执行 <code>sz 文件名</code> 命令（这将启动发送模式）。（<strong>通常是 XShell 的默认目录，可以设置特定的路径</strong>）</li></ul><p><strong>注意事项</strong>：确认 <strong>网络连接正常</strong>。在进行任何与 <code>yum</code> 相关的操作前，必须确保主机（或虚拟机）的网络正常工作。可以使用命令 <code>ping www.baidu.com</code> 来验证网络是否畅通。</p><h4 id="查看与筛选软件包"><a href="#查看与筛选软件包" class="headerlink" title="查看与筛选软件包"></a>查看与筛选软件包</h4><ul><li><p>查看可用软件包：使用 <code>yum list</code> 命令可以列出所有可用的软件包。由于软件包列表可能非常长，可以结合 <code>grep</code> 命令筛选出感兴趣的软件包。例如，查找 <code>lrzsz</code> 相关的信息，可以执行：<code>yum list | grep lrzsz</code></p></li><li><p>理解软件包名称：软件包名称一般格式如下：<strong><code>主版本号.次版本号.源程序发行号-软件包的发行号.主机平台.cpu架构</code></strong> 例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">lrzsz.x86_64 0.12.20-36.el7 @base</span><br><span class="line"><span class="comment"># lrzsz：软件包的名称</span></span><br><span class="line"><span class="comment"># x86_64：表示软件包适用于64位架构的CPU</span></span><br><span class="line"><span class="comment"># 0.12.20：软件的主要版本号，lrzsz 的版本是0.12.20</span></span><br><span class="line"><span class="comment"># 36：打包版本号</span></span><br><span class="line"><span class="comment"># el7：el：centos，7：主版本。也就是centos7</span></span><br><span class="line"><span class="comment"># @base：表明了软件包的来源仓库（软件仓库）。理解成厂商即可，例如华为/快手/……</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h4><ul><li><p><strong>安装命令</strong>：通过以下命令可以安装 <code>lrzsz</code> 工具：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> yum install lrzsz</span><br></pre></td></tr></table></figure><p>执行该命令后，<code>yum</code> 会自动解决依赖关系并提示需要下载哪些软件包。确认后（通常按“y”）开始安装。</p></li><li><p><strong>权限要求</strong>：由于安装过程中需要向系统目录写入文件，因此需要使用 <code>sudo</code> 或切换到 <strong>root 账户</strong>。</p></li><li><p><strong>串行安装</strong>：由于 <code>yum</code> 进程锁定，<strong>同一时间只能执行一个安装任务</strong>。一个 <code>yum</code> 安装过程未完成时，尝试启动另一个 <code>yum</code> 安装会导致错误，因此需要 <strong>按顺序进行安装</strong>。</p></li></ul><h4 id="EPEL-仓库（需要-sudo-或-root-账户）"><a href="#EPEL-仓库（需要-sudo-或-root-账户）" class="headerlink" title="EPEL 仓库（需要 sudo 或 root 账户）"></a>EPEL 仓库（需要 <code>sudo</code> 或 root 账户）</h4><p>EPEL 是由 <strong>Fedora</strong> 社区维护的一个额外的软件仓库，专门为 RHEL 和 CentOS 提供额外的软件包。默认情况下，RHEL 和 CentOS 的官方仓库只包含基本的软件包，很多流行的第三方软件包并不包括在其中。而 EPEL 仓库则包含了大量的额外软件包，这些软件包经过测试，适用于 RHEL 和 CentOS 系统。通过启用 EPEL 仓库，可以访问到很多 <strong>非官方但稳定的软件包</strong>，比如开发工具、网络工具、数据库、Web 服务器、数据分析工具等。</p><p><code>yum install -y epel-release</code> 这个命令用于 <strong>CentOS</strong>、<strong>Red Hat</strong> 和其他基于 RHEL（Red Hat Enterprise Linux）的 Linux 发行版上，它的作用是安装 <strong>EPEL（Extra Packages for Enterprise Linux）</strong> 仓库的配置包。<strong>通常有需要的包安装不上和包不在默认仓库中可以使用（多存在虚拟机）。</strong></p><p>假设想安装 <code>htop</code>，这是一个用于查看系统资源使用情况的命令行工具。在 CentOS 中，<code>htop</code> 不在默认仓库中，但它可以在 EPEL 仓库中找到。启用 EPEL 仓库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y epel-release</span><br></pre></td></tr></table></figure><p>然后，可以通过 <code>yum</code> 安装 <code>htop</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install htop</span><br></pre></td></tr></table></figure><h4 id="卸载软件"><a href="#卸载软件" class="headerlink" title="卸载软件"></a>卸载软件</h4><p>卸载命令：要卸载已安装的软件包（如 <code>lrzsz</code>），可以使用以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> yum remove lrzsz</span><br></pre></td></tr></table></figure><h4 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h4><p>如果遇到 <code>yum</code> 相关的错误，需要根据具体的错误信息进行搜索和解决。<code>yum</code> 的错误原因可能有很多种，具体的解决办法可以通过错误信息来判断。</p><blockquote><p>  [!NOTE]</p><p>  <strong>一些好玩软件：</strong></p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y sl</span><br></pre></td></tr></table></figure><p>  效果（命令：<code>sl</code>）：</p><p>  <img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250309134404605.png"></p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install cowsay</span><br></pre></td></tr></table></figure><p>  效果（<code>cowsay “你是一个好人”</code>）：</p><p>  <img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250309134740648.png" alt="image-20250309134740567"></p></blockquote><hr><h2 id="Linux-生态"><a href="#Linux-生态" class="headerlink" title="Linux 生态"></a>Linux 生态</h2><p><strong>1. 开源不等于免费</strong></p><p>开源软件本身是免费提供源代码的，但这并不意味着所有相关的服务、支持和维护都是免费的。许多公司选择开源作为其商业战略的一部分，以吸引更多的用户、开发者或合作伙伴，但背后的成本往往在其他地方。</p><ul><li><strong>技术支持</strong>：开源软件往往需要专业的技术支持和定制化服务。这些服务通常是收费的。</li><li><strong>培训和咨询</strong>：一些开源软件的公司可能提供培训、技术咨询、系统集成等服务，这些都需要付费。</li><li><strong>维护和更新</strong>：开源项目需要持续的开发和维护。虽然代码本身是开放的，但公司通常会雇佣开发人员来维护代码、修复漏洞、添加新特性，这也是一种商业成本。</li></ul><p><strong>2. 吸引用户并从中盈利</strong></p><p>很多公司选择开源是为了吸引广泛的用户基础和社区支持，积累用户基础，然后通过向大公司、企业用户提供高级功能或支持来实现盈利。但他们通常会通过提供增值服务来实现盈利。这些增值服务可能包括：</p><ul><li><strong>云服务</strong>：它们的核心技术是开源的，但公司通过提供托管服务（例如容器编排平台）来盈利。</li><li><strong>专业版</strong>：许多开源项目会提供免费的社区版和付费的企业版。企业版通常包含额外的功能、更高的性能或专属的客户支持服务。</li></ul><p><strong>3. 营销和品牌建设</strong></p><p>开源作为一种商业战略，往往有助于品牌的建立和市场份额的扩展。通过开源，企业能够让更多的开发者和技术人员接触到他们的产品，从而建立品牌认知度，进而吸引更多客户或合作伙伴。然而，这种营销策略本身也需要大量的投入：</p><ul><li><strong>社区建设</strong>：开源项目需要社区的支持，而建立一个活跃的社区需要时间、资金和人员投入。</li><li><strong>文档和教程</strong>：为了让用户能够有效使用开源软件，企业往往需要投入大量资源制作文档、教程、示例代码和开发工具。</li><li><strong>开发者生态系统</strong>：很多公司会通过开源建立强大的开发者生态系统，这样可以在未来通过收取支持、咨询费用、举办培训等方式获利。</li></ul><p><strong>4. 间接盈利和市场控制</strong></p><p>有些公司可能不会直接从开源软件本身盈利，而是通过开源获得更多的市场控制权或客户资源。例如：</p><ul><li><strong>市场领导地位</strong>：通过开源，某家公司可以在某一领域建立市场领导地位，使得其他公司不得不采用他们的产品或服务，间接创造盈利机会。</li><li><strong>数据和分析</strong>：通过开源，企业可以获得大量的使用数据和反馈，这有助于他们改进产品，甚至为其其他商业产品提供数据支持和创新。</li></ul><p><strong>5. 开源的潜在成本</strong></p><ul><li><strong>竞争压力</strong>：开源可能会增加市场上的竞争，因为一旦源代码公开，任何人都可以修改并重用代码，从而可能影响原公司的市场份额。</li><li><strong>开发和维护成本</strong>：持续开发和维护开源项目需要大量的人力和时间，尤其是当项目规模和社区活跃度增加时，这可能变成一项昂贵的长期投资。</li></ul><p>&#x3D;&#x3D;开源软件是一种非常有效的商业战略，能够吸引大量用户并建立广泛的社区基础，但背后的成本往往是隐性的。虽然软件本身免费，但从商业角度来看，开源并不等于廉价，相关的技术支持、增值服务、品牌推广、社区建设和持续维护等方面的投入都可能让开源项目变得非常昂贵。&#x3D;&#x3D;</p><p>&#x3D;&#x3D;一个好的 Linux 软件生态应具备 <strong>丰富的软件选择、高效的包管理、稳定的版本、活跃的社区支持、良好的硬件兼容性、完善的安全机制和高度的灵活性</strong>。这样的生态能够为用户提供 <strong>易用、稳定、安全且自由</strong> 的操作环境，同时吸引更多开发者和用户参与，形成良性循环。&#x3D;&#x3D;</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>007 Linux 开发工具（上）—— vim、解放sudo、gc+</title>
      <link href="/posts/62462.html"/>
      <url>/posts/62462.html</url>
      
        <content type="html"><![CDATA[<h2 id="Linux-开发工具（上）"><a href="#Linux-开发工具（上）" class="headerlink" title="Linux 开发工具（上）"></a>Linux 开发工具（上）</h2><h3 id="Linux-编辑器-——-vim"><a href="#Linux-编辑器-——-vim" class="headerlink" title="Linux 编辑器 —— vim"></a>Linux 编辑器 —— <code>vim</code></h3><p>Vim 是一个强大、多模式的文本编辑器，具有高度的可定制性和丰富的功能。<strong>打开文件</strong>：在命令行中输入 <code>vim filename</code>，打开指定文件。<a href="https://github.com/wsdjeg/vim-galore-zh_cn?tab=readme-ov-file">Vim 从入门到牛逼</a> &#x2F; <a href="https://wsdjeg.net/vim-galore-zh-cn/">Vim 从入门到牛逼（备用）</a></p><p>打开当前目录下的文件 <code>code.c</code>，使用命令：<code>vim code.c</code>，同时 <strong>支持相对路径和绝对路径</strong> 打开：<code>vim home/code.c</code>。</p><h4 id="Vim-的主要模式："><a href="#Vim-的主要模式：" class="headerlink" title="Vim 的主要模式："></a>Vim 的主要模式：</h4><ul><li><strong>命令模式（Normal Mode）</strong>：命令模式是 Vim 的核心模式，几乎所有操作都从这里开始，启动 Vim 后，<strong>默认处于命令模式</strong>。在此模式下，<strong>键盘输入被解释为命令而非文本输入</strong>。只能使用方向键、删除、复制、粘贴等操作用来进行文本的导航、选择、删除、替换等。（按 <code>i</code> 进入插入模式，按 <code>:</code> 进入底行模式，按 <code>Esc</code> 从其他模式返回到命令模式）</li><li><strong>插入模式（Insert Mode）</strong>：按下 <code>i</code> 键进入插入模式。插入模式下可以像普通文本编辑器一样输入文本。按 <code>Esc</code> 键返回命令模式。</li><li><strong>底行模式（Ex Mode 或 Bottom Line Mode）</strong>：底行模式是 Vim 的强大功能之一，支持复杂的文件操作和配置。按下 <code>shift</code>+<code>；</code> （也就是 <code>:</code>） 键进入底行模式。在底行模式下可以执行文件保存、退出、查找替换等命令。例：<code>:wq</code> 保存并退出 Vim。按 <code>Esc</code> 键返回命令模式。（<strong>注意：</strong> <code>Ctrl+C</code> 也可以退出底行模式并返回命令模式，尽量不要使用，可能会出现未知错误）</li></ul><h4 id="Vim-命令模式下的一些常用操作-史上最全-Vim-快捷键键位图（入门到进阶）"><a href="#Vim-命令模式下的一些常用操作-史上最全-Vim-快捷键键位图（入门到进阶）" class="headerlink" title="Vim 命令模式下的一些常用操作: 史上最全 Vim 快捷键键位图（入门到进阶）"></a>Vim 命令模式下的一些常用操作: <a href="https://www.runoob.com/w3cnote/all-vim-cheatsheat.html">史上最全 Vim 快捷键键位图（入门到进阶）</a></h4><p><strong>导航</strong></p><ul><li><code>gg</code>: 定位光标到最开始行。</li><li><code>shift+g</code> 或 <code>G</code>: 定位光标到最结尾行。</li><li><code>n+shift+g</code> 或 <code>nG</code>: 定位光标到任意行——跳到指定行号 <code>n</code>。</li><li><code>shift+$</code>: 定位光标到当前行的结尾。</li><li><code>shift+^</code>: 定位光标到当前行的开始。</li><li><code>w, b</code>: 光标按照单词进行行内移动，分别向右或向左移动一个单词。</li><li><code>h, j, k, l</code>: 分别移动光标左、下、上、右。</li></ul><p><strong>文本编辑</strong></p><ul><li><code>(n)yy</code>: 复制光标所在行或指定行数的内容。</li><li><code>(n)dd</code>: 剪切（删除）当前行或指定行数的内容。</li><li><code>(n)p</code>: 粘贴 <code>n</code> （次数）行到光标所在下一行。</li><li><code>u</code>: 撤销上一步操作。</li><li><code>ctrl+r</code>: 撤销之前的撤销（重做撤销的操作）。</li></ul><p><strong>其他操作</strong></p><ul><li><code>shift+~</code>: 大小写转换。</li><li><code>(n)r</code>: 对光标字符之后的 <code>n</code> 个字符进行批量化替换。</li><li><code>shift+R</code>: 进入替换模式，对内容进行整体替换 → 第四种模式。</li><li><code>(n)x</code>: 对光标后面的 <code>n</code> 个字符进行删除。</li><li><code>:w</code> 保存，<code>:w!</code> 强制保存，<code>:q</code> 退出，<code>:q!</code> 强制退出，<code>:wq!</code> 强制退出并保存</li></ul><p>这两个命令 (<code>shift+$</code> 和 <code>shift+^</code>) 被称为“<strong>锚点</strong>”，因为它们将光标快速固定到行的特定位置——就像锚点固定物体的位置一样。在文本编辑器中，<strong>锚点</strong> 通常指的是可以用来快速定位或固定某个位置的标记。</p><p>为什么 <code>vim</code> 快捷键不像现在键盘的常规操作：主要是因为早期的键盘并不像现在这样有功能键（F1-F12）、方向键或数字小键盘。Vim 的许多快捷键都是为了适应这些限制而设计的。（可以查找一下那个时代的键盘 🤪）</p><h4 id="Vim-多文件编辑与窗口管理"><a href="#Vim-多文件编辑与窗口管理" class="headerlink" title="Vim 多文件编辑与窗口管理"></a>Vim 多文件编辑与窗口管理</h4><p>在 Vim 中，你可以同时打开多个文件，并使用 <strong>分割窗口</strong> 来进行并行编辑。</p><p><strong>打开多个文件 —— 垂直分割窗口 (<code>vs</code>)：</strong></p><ul><li>作用：在当前窗口 <strong>右侧</strong> 打开一个新的窗口，并加载指定的文件。</li><li>用法：<code>:vs file2.c</code>。示例：先打开 <code>file1.c</code>，然后在 Vim 中输入 <code>:vs file2.c</code>，即可在右侧创建一个窗口并打开 <code>file2.c</code>。</li></ul><p><strong>窗口切换 <code>Ctrl+w w</code>：</strong></p><ul><li>作用：在多个窗口之间切换光标位置。</li><li>操作方式：按 <code>Ctrl+w</code>，再按 <code>w</code>，光标会跳到下一个窗口。如果有多个窗口，重复 <code>Ctrl+w w</code> 可以在所有窗口之间循环切换。</li></ul><p><strong>窗口内编辑</strong>：<strong>光标在哪个窗口里面，就对哪一个窗口进行操作</strong>，你可以在当前窗口进行 <strong>插入、删除、复制等编辑操作</strong>，而不会影响其他窗口。</p><ul><li>水平分割窗口：<code>:sp file2.c</code></li><li>调整窗口大小：<code>Ctrl+w +</code>（增加高度）、<code>Ctrl+w -</code>（减少高度）。</li></ul><hr><h4 id="简单的-vim-配置（Vim-改装）"><a href="#简单的-vim-配置（Vim-改装）" class="headerlink" title="简单的 vim 配置（Vim 改装）"></a>简单的 <code>vim</code> 配置（<a href="https://blog.csdn.net/wooin/article/details/1858917">Vim 改装</a>）</h4><p>Vim 的配置文件有两个主要位置，<strong>注意：一个用户配置一个 <code>vim</code> 文件，不会互相影响，不建议给 <code>root</code> 做配置，推荐用普通用户！</strong></p><ol><li><strong>全局配置文件</strong>：<code>/etc/vimrc</code>，对所有用户都生效。</li><li><strong>用户私有配置文件</strong>：每个用户可以在其主目录下创建 <code>.vimrc</code>，仅对该用户生效。例如，<code>/root/.vimrc</code> 适用于 <code>root</code> 用户。</li></ol><p><strong>如何修改 <code>.vimrc</code></strong></p><ol><li>切换到自己的用户目录（确保在自己的 home 目录下）：<code>cd ~</code></li><li>打开 <code>.vimrc</code> 文件（如果不存在，则创建）：<code>vim .vimrc</code></li></ol><p><strong>常用 Vim 配置</strong></p><p>在 <code>.vimrc</code> 文件中添加以下配置：</p><ul><li><strong>设置语法高亮：<code>syntax on</code>，作用：</strong> 开启 Vim 的语法高亮功能，使代码有不同颜色，提高可读性。</li><li><strong>显示行号：<code>set nu</code>，作用：</strong> 开启行号显示，在左侧显示每行的编号，方便定位代码行。</li><li><strong>设置缩进的空格数：<code>set shiftwidth=4</code>，作用：</strong> 设定每次缩进的空格数为 4。适用于代码自动缩进，提高代码可读性。</li></ul><p><strong>测试配置</strong></p><p>修改 <code>.vimrc</code> 文件后，需要重新打开 Vim 或者在 Vim 内输入以下命令让配置生效：<code>:source ~/.vimrc</code> 然后可以在 Vim 中测试：</p><ul><li>输入 <code>:set nu?</code> 检查行号是否开启。</li><li>输入 <code>:set shiftwidth?</code> 检查缩进空格数。</li></ul><p>这样就完成了简单的 Vim 配置！ 🚀 </p><p><strong>使用插件（进阶）</strong></p><p>Vim 支持插件扩展功能，要配置好看的 <code>vim</code>，原生的配置可能功能不全，可以选择安装插件来完善配置，保证用户是你要配置的用户。Vim 的插件管理工具如 Vim-Plug，一些常用的插件如 NERDTree、coc.nvim 等，以增强 Vim 的功能。</p><p>推荐使用 <a href="https://github.com/junegunn/vim-plug">Vim-Plug</a> 作为插件管理器。</p><ol><li><p><strong>安装 Vim-Plug</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -fLo ~/.vim/autoload/plug.vim --create-dirs \</span><br><span class="line">    https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim</span><br></pre></td></tr></table></figure></li><li><p><strong>配置插件</strong>：在 <code>.vimrc</code> 中添加以下内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">call plug#begin(<span class="string">&#x27;~/.vim/plugged&#x27;</span>)</span><br><span class="line">Plug <span class="string">&#x27;插件名称&#x27;</span>  <span class="string">&quot; 例如：Plug &#x27;preservim/nerdtree&#x27;</span></span><br><span class="line"><span class="string">call plug#end()</span></span><br></pre></td></tr></table></figure></li><li><p><strong>安装插件</strong>：<br>在 Vim 中运行 <code>:PlugInstall</code> 安装配置的插件。</p></li></ol><hr><p><a href="https://gitee.com/HGtz2222/VimForCpp">我的 <code>vim</code> 配置</a>：</p><p><strong>安装方法：</strong> 在 <code>shell</code> 中执行指令(想在哪个用户下让 <code>vim</code> 配置生效，就在哪个用户下执行这个指令。强烈 “不推荐” 直接在 root 下执行)，需要按照提示输入 <code>root </code> 密码。您的 <code>root </code> 密码不会被上传，请放心输入。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -sLf https://gitee.com/HGtz2222/VimForCpp/raw/master/install.sh -o ./install.sh &amp;&amp; bash ./install.sh</span><br></pre></td></tr></table></figure><p><strong>&#x3D;&#x3D;注意：安装完成后一定要手动执行 <code>source ~/.bashrc</code> 或重启终端，这样配置才能生效！&#x3D;&#x3D;</strong> 说明：安装完成后，目录下会有一个名为 <code>install.sh</code> 的配套脚本，处于安全考虑，可以执行 <code>mv install.sh .install.sh</code> 进行隐藏。</p><p>默认缩进配置为 <code>2</code> 个字符，将 <code>tab</code> 键换成 <code>4</code> 个字符的方法：到达家目录下执行 <code>vim .vimrc</code>，大概在 50 行进行修改：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> tabstop=4       <span class="string">&quot; 每个制表符占用 4 个空格</span></span><br><span class="line"><span class="string">set softtabstop=4   &quot;</span> 插入制表符时插入 4 个空格</span><br><span class="line"><span class="built_in">set</span> shiftwidth=4    <span class="string">&quot; 自动缩进和文本块操作时使用 4 个空格</span></span><br></pre></td></tr></table></figure><p><strong>&#x3D;&#x3D;卸载方法&#x3D;&#x3D;：</strong> 在安装了 VimForCpp 的用户下执行:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash ~/.VimForCpp/uninstall.sh</span><br></pre></td></tr></table></figure><hr><h3 id="解放-sudo-权限"><a href="#解放-sudo-权限" class="headerlink" title="解放 sudo 权限"></a>解放 <code>sudo</code> 权限</h3><p>使用 <code>root</code> 账户执行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/sudoers</span><br></pre></td></tr></table></figure><p>按下 <code>i</code> 键进入插入模式，找到大约第 100 行左右的位置（附近会有 <code>root    ALL=(ALL)    ALL</code> 的字眼），在其下方添加以下内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">username    ALL=(ALL)    ALL</span><br></pre></td></tr></table></figure><ul><li><code>username</code>：替换为你要授权的账户名。</li><li><code>ALL=(ALL)</code>：允许用户以任何用户身份执行命令。</li><li><code>ALL</code>：允许执行所有命令。</li></ul><p>按 <code>Esc</code> 键返回到默认模式，然后输入 <code>:wq!</code> 强制保存并退出。</p><p><strong>验证</strong>：切换到该用户并测试 <code>sudo</code> 权限：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">su - username</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">ls</span> /root</span><br></pre></td></tr></table></figure><p>如果 <code>sudo</code> 配置正确，系统会提示输入密码，然后执行命令。</p><hr><h3 id="Linux-编译器-——-gcc-g"><a href="#Linux-编译器-——-gcc-g" class="headerlink" title="Linux 编译器 —— gcc &#x2F; g++"></a>Linux 编译器 —— <code>gcc </code>&#x2F; <code>g++</code></h3><h4 id="背景知识回顾-——-C-C-程序的编译流程"><a href="#背景知识回顾-——-C-C-程序的编译流程" class="headerlink" title="背景知识回顾 —— C&#x2F;C++ 程序的编译流程"></a>背景知识回顾 —— C&#x2F;C++ 程序的编译流程</h4><p>C&#x2F;C++ 程序从源代码到可执行文件需经历四个主要阶段：<strong>预处理 → 编译 → 汇编 → 链接</strong>。每个阶段由编译器（如 GCC、Clang 或 MSVC）逐步处理，最终生成可执行文件或库文件。</p><h4 id="1-预处理-Preprocessing"><a href="#1-预处理-Preprocessing" class="headerlink" title="1. 预处理 (Preprocessing)"></a>1. 预处理 (Preprocessing)</h4><p>预处理是编译的第一步，主要处理源代码中的宏、注释、头文件等。预处理的输出是一个经过宏替换、去注释、头文件展开的中间代码。</p><p><strong>主要工作：</strong></p><ul><li><strong>去除注释</strong>：删除代码中的注释部分。</li><li><strong>宏替换</strong>：替换代码中的宏定义（如 <code>#define</code>）。</li><li><strong>头文件展开</strong>：将 <code>#include</code> 指令包含的头文件内容插入到当前文件。</li><li><strong>条件编译</strong>：根据条件编译指令（如 <code>#ifdef</code>、<code>#endif</code>）选择性地包含或排除代码。</li></ul><p><strong>输出：</strong></p><ul><li>预处理后的文件通常是一个 <code>.i</code> 文件，它是源代码经过宏替换和头文件展开后的中间结果。</li></ul><p><strong>命令示例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -E temp.c -o temp.i<span class="comment"># 执行预处理后就停止，`-E` 选项表示只进行预处理，输出 `.i` 文件。</span></span><br></pre></td></tr></table></figure><p><strong>重要说明：</strong> 预处理后的文件仍然是 C 语言代码，因此可以说经过预处理后，程序依然是 C 语言程序。</p><h4 id="2-编译-Compilation"><a href="#2-编译-Compilation" class="headerlink" title="2. 编译 (Compilation)"></a>2. 编译 (Compilation)</h4><p>编译阶段的作用是将预处理后的代码转化为汇编代码。编译器会对代码进行语法分析、语义分析和优化，最终生成与平台架构相关的汇编代码。</p><p><strong>主要工作：</strong></p><ul><li><strong>语法分析</strong>：检查代码是否符合语法规则。</li><li><strong>语义分析</strong>：检查变量类型、函数调用等语义是否正确。</li><li><strong>优化</strong>：对代码进行优化，使得生成的汇编代码更高效。</li></ul><p><strong>输出：</strong></p><ul><li>编译后的文件是一个 <code>.s</code> 文件，包含了平台特定的汇编代码。</li></ul><p><strong>命令示例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -S temp.i -o temp.s<span class="comment"># 执行编译后就停止，`-S` 选项表示将预处理后的文件编译成汇编语言。</span></span><br></pre></td></tr></table></figure><h4 id="3-汇编-Assembly"><a href="#3-汇编-Assembly" class="headerlink" title="3. 汇编 (Assembly)"></a>3. 汇编 (Assembly)</h4><p>汇编阶段的作用是将汇编代码转换为机器可识别的二进制目标代码。汇编器会将汇编代码翻译为机器指令，生成可重定位目标文件。</p><p><strong>主要工作：</strong></p><ul><li><strong>汇编</strong>：将汇编代码转换为目标代码，生成二进制文件。</li></ul><p><strong>输出：</strong></p><ul><li>汇编后的文件是一个 <code>.o</code>（Linux）或 <code>.obj</code>（Windows）文件，这些文件是目标文件，包含机器指令，但尚未链接成最终的可执行文件。</li></ul><p><strong>命令示例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c temp.s -o temp.o<span class="comment"># 执行汇编后停止，`-c` 选项表示只进行汇编，不进行链接，输出 `.o` 文件。</span></span><br></pre></td></tr></table></figure><p><strong>重要说明：</strong> 可重定位目标二进制文件，简称目标文件，<code>.obj</code> 文件不可以独立执行，虽然已经是二进制了，还需要经过链接才能执行！</p><blockquote><h2 id="传道解惑"><a href="#传道解惑" class="headerlink" title="传道解惑"></a>传道解惑</h2><p>在 Linux 中，可重定位目标二进制文件（Relocatable Object File）是一种 <strong>中间二进制文件</strong>，它是由编译器或汇编器生成的，但还 <strong>不能直接执行</strong>，必须经过 <strong>链接（Linking）</strong> 处理后才能成为最终的可执行文件或库文件。</p><h3 id="Q1：什么是可重定位目标文件？"><a href="#Q1：什么是可重定位目标文件？" class="headerlink" title="Q1：什么是可重定位目标文件？"></a>Q1：什么是可重定位目标文件？</h3><p>可重定位目标文件通常以 <strong><code>.o</code></strong> 结尾（Windows 上是 <code>.obj</code>），它包含：</p><ul><li><strong>机器指令（Machine Instructions）</strong>：程序的可执行代码，但未指定最终内存地址。</li><li><strong>符号表（Symbol Table）</strong>：记录函数、变量等符号，供链接器解析。</li><li><strong>重定位信息（Relocation Information）</strong>：用于在链接时调整地址。</li><li><strong>节（Section）结构</strong>：比如 <code>.text</code>（代码段）、<code>.data</code>（已初始化数据段）、<code>.bss</code>（未初始化数据段）等。</li></ul><p>这些文件是 <strong>“可重定位”</strong> 的，因为它们的地址信息 <strong>尚未固定</strong>，而是由 <strong>链接器</strong> 在合并多个目标文件时决定最终的内存布局。</p><h3 id="Q2：为什么需要可重定位目标文件？"><a href="#Q2：为什么需要可重定位目标文件？" class="headerlink" title="Q2：为什么需要可重定位目标文件？"></a>Q2：为什么需要可重定位目标文件？</h3><p>如果编译器直接把 C&#x2F;C++ 源代码编译成最终可执行程序，那么：</p><ul><li><strong>无法将不同的模块（文件）合并</strong>，无法进行大规模项目开发。</li><li><strong>无法使用动态链接库（Shared Library）</strong>，会导致程序体积庞大。</li><li><strong>无法延迟地址分配</strong>，不适用于操作系统的内存管理策略。</li></ul><p>所以，编译器通常 <strong>先</strong> 生成 <strong>可重定位目标文件</strong>，再由 <strong>链接器</strong> 进行 <strong>地址调整和符号解析</strong>，最终得到可执行程序。</p><p><strong>示例：生成可重定位目标文件</strong></p><p>假设我们有一个简单的 C 代码 <code>temp.c</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">&gt;<span class="type">void</span> <span class="title function_">hello</span><span class="params">()</span></span><br><span class="line">&gt;&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Hello, World!\n&quot;</span>);</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p><strong>第一步：编译但不链接</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;gcc -c temp.c -o temp.o</span><br></pre></td></tr></table></figure><p>这样会生成 <code>temp.o</code>，它是一个 <strong>可重定位目标文件</strong>，里面的 <code>hello</code> 还没有绑定到最终的地址。</p><p><strong>第二步：使用 <code>readelf</code> 查看目标文件</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;readelf -h temp.o</span><br></pre></td></tr></table></figure><p>部分输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;Type:           REL (Relocatable file)</span><br><span class="line">&gt;Machine:        x86-64</span><br></pre></td></tr></table></figure><p>可以看到 <code>Type</code> 是 <code>REL</code>，表示它是一个 <strong>可重定位文件</strong>。</p><h3 id="Q3：什么时候会被最终链接？"><a href="#Q3：什么时候会被最终链接？" class="headerlink" title="Q3：什么时候会被最终链接？"></a>Q3：什么时候会被最终链接？</h3><p>可重定位目标文件 <strong>通常不会单独使用</strong>，它最终会：</p><ol><li><strong>静态链接（Static Linking）</strong>：被 <code>ld</code>（链接器）合并到最终的可执行文件中。</li><li><strong>动态链接（Dynamic Linking）</strong>：与共享库（<code>.so</code> 文件）进行链接，在运行时加载。</li></ol><p>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;gcc temp.o -o temp</span><br><span class="line">&gt;./temp</span><br></pre></td></tr></table></figure><p>这时 <code>temp.o</code> 经过链接后变成可执行文件 <code>temp</code>，可以直接运行。</p></blockquote><h4 id="4-链接-Linking"><a href="#4-链接-Linking" class="headerlink" title="4. 链接 (Linking)"></a>4. 链接 (Linking)</h4><p>链接阶段的作用是将多个目标文件（如 <code>.o</code> 文件）和库文件进行链接，生成最终的可执行文件或库文件。链接器会处理符号引用、重定位等工作，确保程序能够正确运行。</p><p><strong>主要工作：</strong></p><ul><li><strong>符号解析</strong>：将不同目标文件中的符号（如函数名、变量名等）进行链接，确保各部分之间的正确引用。</li><li><strong>重定位</strong>：调整代码中地址的引用，使得目标文件能够在内存中正确加载。</li></ul><p><strong>输出：</strong></p><ul><li>链接后的输出通常是一个可执行文件（如 <code>a.out</code> 或 <code>program.exe</code>）或动态链接库（如 <code>.so</code> 或 <code>.dll</code> 文件）。</li></ul><p><strong>命令示例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc source.o -o program<span class="comment"># 默认链接 C 标准库，这条命令将目标文件 `temp.o` 链接为可执行文件 `program`。</span></span><br></pre></td></tr></table></figure><hr><h4 id="为什么我们能在-Windows-或-Linux-上进行-C-C-开发？"><a href="#为什么我们能在-Windows-或-Linux-上进行-C-C-开发？" class="headerlink" title="为什么我们能在 Windows 或 Linux 上进行 C&#x2F;C++ 开发？"></a>为什么我们能在 Windows 或 Linux 上进行 C&#x2F;C++ 开发？</h4><p>在 Windows 和 Linux 上进行 C&#x2F;C++ 开发是因为这些操作系统提供了支持编译和执行 C&#x2F;C++ 代码的工具链。具体而言，需要安装开发环境（如 GCC、Visual Studio 等）以及相关的库文件和头文件。</p><p><strong>1. 头文件和库文件</strong></p><ul><li><strong>头文件</strong>：定义了语言的核心功能、标准库以及外部库的接口（如 <code>stdio.h</code>、<code>stdlib.h</code>）。</li><li><strong>库文件</strong>：包含预编译的二进制代码（如 <code>libc.a</code> 或 <code>msvcrt.dll</code>），在链接阶段与用户代码结合。</li></ul><p><strong>2. 开发工具</strong></p><ul><li><strong>编译器</strong>：如 GCC（GNU Compiler Collection）、g++，以及 Visual Studio（VS）等 IDE，提供了代码编辑、编译、调试等功能。</li><li><strong>语言支持包</strong>：<strong>安装开发工具时，会自动下载头文件和库。</strong> 例如，安装 VS 时选择“C++ 开发”，会附带 C++ 标准库（如 STL）和 Windows API 库。</li></ul><p><strong>3. 跨平台开发</strong></p><ul><li><strong>条件编译</strong>：通过宏（如 <code>#ifdef __linux__</code>）区分不同平台的代码逻辑。</li><li><strong>平台专属库</strong>：Linux 依赖 <code>glibc</code>，Windows 依赖 <code>msvcrt.dll</code>。开发者需调用标准接口或使用跨平台库（如 Qt、Boost）。</li></ul><h4 id="软件版本管理：社区版-vs-专业版"><a href="#软件版本管理：社区版-vs-专业版" class="headerlink" title="软件版本管理：社区版 vs 专业版"></a>软件版本管理：社区版 vs 专业版</h4><p><strong>1. 代码维护策略</strong></p><ul><li><p><strong>单一代码库</strong>：企业无需维护多份代码，而是通过 <strong>条件编译</strong> 控制功能模块的启用或禁用。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PROFESSIONAL_EDITION</span></span><br><span class="line">  enableAdvancedFeatures();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></li><li><p><strong>编译参数控制</strong>：构建时通过宏定义（如 <code>-DPROFESSIONAL_EDITION</code>）选择版本。</p></li></ul><p><strong>2. 功能裁剪 —— 不需要维护两份代码，根据不同的编译条件，会裁剪掉社区版不需要的功能即可</strong></p><ul><li><strong>社区版</strong>：禁用部分高级功能（如性能分析工具、企业级加密）。</li><li><strong>专业版</strong>：包含完整功能，通过编译选项开启。</li></ul><hr><h4 id="关键命令与文件类型总结"><a href="#关键命令与文件类型总结" class="headerlink" title="关键命令与文件类型总结"></a>关键命令与文件类型总结</h4><table><thead><tr><th align="center">阶段</th><th align="center">命令选项</th><th align="center">输入文件</th><th align="center">输出文件</th><th align="center">文件内容</th></tr></thead><tbody><tr><td align="center">预处理</td><td align="center"><code>-E</code></td><td align="center"><code>.c</code></td><td align="center"><code>.i</code></td><td align="center">展开后的 C 代码</td></tr><tr><td align="center">编译</td><td align="center"><code>-S</code></td><td align="center"><code>.i</code></td><td align="center"><code>.s</code></td><td align="center">汇编代码</td></tr><tr><td align="center">汇编</td><td align="center"><code>-c</code></td><td align="center"><code>.s</code></td><td align="center"><code>.o</code>（Linux）</td><td align="center">目标二进制文件</td></tr><tr><td align="center">链接</td><td align="center">无</td><td align="center"><code>.o</code></td><td align="center"><code>a.out</code>（默认）</td><td align="center">可执行文件</td></tr></tbody></table><h4 id="记忆法"><a href="#记忆法" class="headerlink" title="记忆法"></a>记忆法</h4><ul><li><p><strong>ESC 键记忆法</strong>：键盘左上角的 ESC 键可以关联各个阶段的后缀：</p><ul><li><strong>.i</strong> -&gt; <strong>预处理</strong>（Preprocessing）</li><li><strong>.s</strong> -&gt; <strong>汇编</strong>（Assembly）</li><li><strong>.o</strong> -&gt; <strong>目标文件</strong>（Object file）</li></ul></li><li><p><strong>iso → 镜像文件后缀。</strong> 最终的可执行文件或库文件就是链接的结果。</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">编译流程：</span><br><span class="line">.c 源文件 → 预处理 → 编译 → 汇编 → 链接 → 可执行文件</span><br><span class="line">          (-E)     (-S)   (-c)    </span><br><span class="line">        </span><br><span class="line">多文件编译例如：</span><br><span class="line">processBar.c → processBar.o ─┐</span><br><span class="line">                             ├→ processBar</span><br><span class="line">processBarmain.c → processBarmain.o ─┘</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="函数库的概念与作用"><a href="#函数库的概念与作用" class="headerlink" title="函数库的概念与作用"></a>函数库的概念与作用</h3><p>在 C&#x2F;C++语言编程中，函数库（Library）允许开发者复用已有的代码，而不必每次都从头开始编写。函数库通常包含一组预先编写好的函数，这些函数可以被多个程序调用。通过使用函数库，开发者可以节省时间，减少重复劳动，并提高代码的可靠性和可维护性。</p><h4 id="函数库的分类"><a href="#函数库的分类" class="headerlink" title="函数库的分类"></a>函数库的分类</h4><p>函数库主要分为两种类型：<strong>静态库</strong> 和 <strong>动态库</strong>。</p><p><strong>1. 静态库（Static Library）</strong></p><ul><li><strong>定义</strong>：静态库在编译链接时，会将库文件的代码全部加入到可执行文件中。因此，生成的可执行文件会比较大，但在运行时不再需要库文件。</li><li><strong>后缀名</strong>：静态库的后缀名通常为 <code>.a</code>（例如 <code>libmylib.a</code>）。</li><li><strong>优点</strong>：由于库代码被直接嵌入到可执行文件中，程序运行时不需要依赖外部的库文件，因此具有较好的独立性。</li><li><strong>缺点</strong>：生成的可执行文件较大，且如果多个程序使用相同的静态库，每个程序都会包含一份库代码的副本，导致内存浪费。</li></ul><p><strong>2. 动态库（Dynamic Library）</strong></p><ul><li><strong>定义</strong>：动态库在编译链接时并不会将库文件的代码加入到可执行文件中，而是在程序运行时由操作系统的运行时链接器动态加载。这样可以节省系统的开销。</li><li><strong>后缀名</strong>：动态库的后缀名通常为 <code>.so</code>（例如 <code>libmylib.so</code>）。</li><li><strong>优点</strong>：生成的可执行文件较小，多个程序可以共享同一个动态库，节省内存和磁盘空间。此外，动态库可以在不重新编译程序的情况下更新。</li><li><strong>缺点</strong>：程序运行时需要依赖外部的库文件，如果库文件丢失或版本不兼容，程序可能无法运行。</li></ul><h4 id="函数库的命名规则"><a href="#函数库的命名规则" class="headerlink" title="函数库的命名规则"></a>函数库的命名规则</h4><p>函数库的命名通常遵循一定的规则，以便于识别和使用。常见的命名格式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">libname.so.XXX</span><br></pre></td></tr></table></figure><ul><li><code>lib</code> 是前缀，表示这是一个库文件。</li><li><code>name</code> 是库的名称，例如 <code>c</code> 表示 C 标准库。</li><li><code>.so</code> 表示这是一个动态库（静态库通常使用 <code>.a</code>）。</li><li><code>XXX</code> 是版本号，表示库的版本。</li></ul><p>例如，<code>libc.so.6</code> 是 C 标准库的动态库，版本号为 6。</p><h4 id="函数库的使用"><a href="#函数库的使用" class="headerlink" title="函数库的使用"></a>函数库的使用</h4><p>在 C 语言中，常用的函数库如 <code>printf</code> 函数的实现并没有直接包含在源代码中，也没有在头文件 <code>stdio.h</code> 中定义。那么，这些函数是如何被调用的呢？</p><p><strong>1. 头文件的作用</strong>：头文件（如 <code>stdio.h</code>）中只包含了函数的声明（即函数原型），告诉编译器这些函数的存在及其参数和返回值的类型。头文件并不包含函数的实现。</p><p><strong>2. 库文件的作用</strong>：函数的实现通常位于库文件中。例如，<code>printf</code> 函数的实现位于 C 标准库的动态库 <code>libc.so.6</code> 中。编译器在链接阶段会将这些库文件与代码结合起来，生成最终的可执行文件。</p><p><strong>3. 链接过程</strong></p><ul><li><strong>静态链接</strong>：在编译时，静态库的代码会被直接嵌入到可执行文件中。生成的可执行文件不依赖外部的库文件。</li><li><strong>动态链接</strong>：在编译时，动态库的代码不会被嵌入到可执行文件中。程序运行时，动态链接器会根据预定义的路径规则去查找这些库文件。</li></ul><h4 id="函数库的作用-——-不让我们做重复工作，站在巨人的肩膀上享受"><a href="#函数库的作用-——-不让我们做重复工作，站在巨人的肩膀上享受" class="headerlink" title="函数库的作用 —— 不让我们做重复工作，站在巨人的肩膀上享受"></a>函数库的作用 —— 不让我们做重复工作，站在巨人的肩膀上享受</h4><ul><li>代码复用：避免重复造轮子，开发者可以直接使用封装好的函数，而不用自己实现复杂的功能。</li><li>隐藏源码：共享库只提供 <code>.so</code> 文件，而不公开 <code>.c</code> 源文件，保护代码的知识产权。</li><li>提高程序效率：通过动态链接的方式，多个程序可以 <strong>共享同一份库文件</strong>，减少内存占用，提高运行效率。</li></ul><hr><h3 id="Linux-中的可执行文件链接方式：动态、静态与混合链接"><a href="#Linux-中的可执行文件链接方式：动态、静态与混合链接" class="headerlink" title="Linux 中的可执行文件链接方式：动态、静态与混合链接"></a>Linux 中的可执行文件链接方式：动态、静态与混合链接</h3><p>在 Linux 中，<code>gcc</code> 编译形成可执行程序时，<strong>默认采用动态链接</strong>，即程序运行时依赖 <code>.so</code>（共享库），这样可以减少可执行文件的大小，并允许多个程序共享相同的库文件。然而，我们可以通过 <strong>静态链接</strong> 或 <strong>混合链接</strong> 的方式来改变默认的链接行为。</p><blockquote><h3 id="小故事理解动静态链接"><a href="#小故事理解动静态链接" class="headerlink" title="小故事理解动静态链接"></a>小故事理解动静态链接</h3><p>想象一下，你正在设计一款可以快速适应不同地形的汽车。为了实现这一目标，你决定使用一些通用的动态链接库，比如“越野轮子”、“城市轮胎”和“雪地链”。这些组件可以在不同的车型之间共享，并且可以根据需要在车辆启动时或行驶过程中即时替换。如果一个顾客今天想要一辆适合城市驾驶的汽车，你可以安装“城市轮胎”；如果明天他想去越野冒险，只需更换为“越野轮子”。这种灵活性就像动态链接（库），程序运行时按需加载，多个程序共享，节省内存，灵活高效。</p><p>另一方面，有些汽车组件一旦安装就不能轻易更改了，例如车身结构或者发动机。这些是根据特定需求量身定做的。当你选择了一种类型的发动机后，它就永久性地成为汽车的一部分，无法在不拆卸整个汽车的情况下进行更换。静态链接库就像发动机，在编译时整合进程序，成为其固定组成部分，提供稳定功能，但程序体积较大，独立运行。</p></blockquote><h4 id="1-默认情况下，gcc-采用动态链接"><a href="#1-默认情况下，gcc-采用动态链接" class="headerlink" title="1. 默认情况下，gcc 采用动态链接"></a>1. 默认情况下，gcc 采用动态链接</h4><p>当我们编译 C 语言程序：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc hello.c -o hello</span><br></pre></td></tr></table></figure><p>默认情况下，<code>gcc</code> <strong>优先链接动态库</strong>（<code>.so</code>），并在执行时加载库文件。例如，标准 C 库 <code>libc.so.6</code> 是动态链接的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ldd hello</span><br></pre></td></tr></table></figure><p>示例输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">linux-vdso.so.1 =&gt;  (0x00007fffca9fe000)</span><br><span class="line">libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f2a4c3c9000)</span><br><span class="line">/lib64/ld-linux-x86-64.so.2 (0x00007f2a4c788000)</span><br></pre></td></tr></table></figure><p>这表示 <code>hello</code> 依赖 <code>libc.so.6</code>，而不是 <code>libc.a</code>（静态库）。</p><h4 id="2-强制使用静态链接（-static-选项）"><a href="#2-强制使用静态链接（-static-选项）" class="headerlink" title="2. 强制使用静态链接（-static 选项）"></a>2. 强制使用静态链接（<code>-static</code> 选项）</h4><p>如果想让程序采用 <strong>纯静态链接</strong>，可以使用 <code>-static</code> 选项：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc hello.c -o hello -static</span><br></pre></td></tr></table></figure><p>这时，编译器会 <strong>优先查找并链接静态库（<code>.a</code>）</strong>，把所有库代码嵌入可执行文件中，使其不再依赖外部 <code>.so</code> 文件。检查：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ldd hello</span><br></pre></td></tr></table></figure><p>如果是纯静态链接，输出会是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">not a dynamic executable</span><br></pre></td></tr></table></figure><p>这表明 <code>hello</code> <strong>不依赖任何动态库</strong>。</p><h4 id="3-static-的本质：改变库的优先级"><a href="#3-static-的本质：改变库的优先级" class="headerlink" title="3. -static 的本质：改变库的优先级"></a>3. <code>-static</code> 的本质：改变库的优先级</h4><p>使用 <code>-static</code> 选项时，<strong>必须保证所有依赖库的静态版本（<code>.a</code>）都存在</strong>，否则，编译会失败。如果没有静态库，但强制使用 <code>-static</code> 会报错！<strong>如果系统只有静态库，没有动态库</strong>，即使没有 <code>-static</code>，<code>gcc</code> 仍然会成功编译，并采用静态链接。因为它找不到 <code>.so</code> 文件，只能用 <code>.a</code>。</p><ul><li><strong>默认情况下</strong>，<code>gcc</code> <strong>优先选择动态库（<code>.so</code>）</strong>。</li><li><strong>加上 <code>-static</code></strong>，<code>gcc</code> <strong>强制使用静态库（<code>.a</code>）</strong>，如果找不到静态库，则会报错。</li><li>并且 <code>-static</code> 是“一次性”的，即：<ul><li><strong>所有</strong> 需要的库都必须静态链接。</li><li><strong>不能部分使用动态库，部分使用静态库</strong>。</li></ul></li></ul><p>如果 <code>-static</code> 选项下某个库没有 <code>.a</code> 文件，编译就会失败。</p><h4 id="4-混合链接（部分静态，部分动态）"><a href="#4-混合链接（部分静态，部分动态）" class="headerlink" title="4. 混合链接（部分静态，部分动态）"></a>4. 混合链接（部分静态，部分动态）</h4><p>虽然 <code>-static</code> 会让所有库都静态链接，但我们可以通过手动指定库的链接方式，实现 <strong>混合链接</strong>（部分库静态，部分库动态）。</p><p><strong>让特定库使用静态链接</strong>：使用 <code>-Wl,-Bstatic</code> 指定部分库静态链接：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc hello.c -o hello -Wl,-Bstatic -lcustomlib -Wl,-Bdynamic -lc</span><br></pre></td></tr></table></figure><ul><li><code>-Wl,-Bstatic</code> 让 <code>-lcustomlib</code> 采用静态库 <code>libcustomlib.a</code>。</li><li><code>-Wl,-Bdynamic</code> 让 <code>-lc</code> 采用动态库 <code>libc.so</code>（恢复默认动态链接）。</li><li>这样就实现了 <strong>混合链接</strong>（部分库静态，部分库动态）。</li></ul><h4 id="5-static-的优缺点"><a href="#5-static-的优缺点" class="headerlink" title="5. -static 的优缺点"></a>5. <code>-static</code> 的优缺点</h4><table><thead><tr><th>方式</th><th><strong>优点</strong></th><th><strong>缺点</strong></th></tr></thead><tbody><tr><td><strong>动态链接（默认）</strong></td><td>- 可执行文件小，多个程序共享库，节省磁盘、内存、网络等空间  - 库可以独立更新，不需重新编译程序</td><td>- 依赖外部 <code>.so</code> 文件，库缺失时程序无法运行</td></tr><tr><td><strong>静态链接（-static）</strong></td><td>- 程序可以独立运行，无需依赖库文件  - 适用于嵌入式系统或无共享库的环境</td><td>- 可执行文件大（<strong>是动态的几十上百倍！</strong>），占用更多磁盘、内存、网络空间  - 无法通过库更新修复漏洞，需要重新编译</td></tr></tbody></table><h4 id="6-推荐场景"><a href="#6-推荐场景" class="headerlink" title="6. 推荐场景"></a>6. 推荐场景</h4><table><thead><tr><th><strong>场景</strong></th><th><strong>建议链接方式</strong></th></tr></thead><tbody><tr><td>普通 Linux 应用</td><td><strong>默认动态链接</strong>（节省空间，便于更新）</td></tr><tr><td>需要独立运行的程序</td><td><strong>静态链接（<code>-static</code>）</strong>，避免外部依赖</td></tr><tr><td>服务器软件</td><td><strong>混合链接</strong>，关键库静态，其余动态</td></tr><tr><td>嵌入式系统</td><td><strong>静态链接</strong>，减少依赖</td></tr></tbody></table><hr><h3 id="Debug-与-Release-模式-ELF-可执行文件格式"><a href="#Debug-与-Release-模式-ELF-可执行文件格式" class="headerlink" title="Debug 与 Release 模式 &amp; ELF 可执行文件格式"></a>Debug 与 Release 模式 &amp; ELF 可执行文件格式</h3><h4 id="1-Debug-模式（调试模式）"><a href="#1-Debug-模式（调试模式）" class="headerlink" title="1. Debug 模式（调试模式）"></a>1. Debug 模式（调试模式）</h4><ul><li><strong>包含调试信息</strong>（如变量名、函数符号表）。</li><li><strong>没有优化</strong>，代码尽量保持源代码的执行逻辑，方便调试。</li><li><strong>可追踪调试</strong>，可以用 <code>gdb</code>（GNU Debugger）进行断点、变量查看等操作。</li></ul><p><strong>编译方式：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -g hello.c -o hello_debug</span><br></pre></td></tr></table></figure><ul><li><code>-g</code> 选项：生成调试信息，方便 <code>gdb</code> 进行调试。</li><li><code>hello_debug</code>：可执行文件，但体积较大，因为包含了额外的调试信息。</li></ul><p><strong>调试方式：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb ./hello_debug<span class="comment"># 可以设置断点、查看变量值等。</span></span><br></pre></td></tr></table></figure><h4 id="2-Release-模式（发布模式）"><a href="#2-Release-模式（发布模式）" class="headerlink" title="2. Release 模式（发布模式）"></a>2. Release 模式（发布模式）</h4><ul><li><strong>优化代码，提高执行效率</strong>。</li><li><strong>去除调试信息，减小可执行文件大小</strong>。</li><li><strong>适用于正式发布的程序</strong>，但不方便调试。</li></ul><p><strong>编译方式：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -O2 hello.c -o hello_release</span><br></pre></td></tr></table></figure><ul><li><code>-O2</code>（优化等级 2）：让编译器优化代码，提高执行速度（<code>-O3</code> 可进一步优化）。</li><li><strong>没有 <code>-g</code>，不生成调试信息</strong>。</li></ul><h4 id="3-ELF（Executable-and-Linkable-Format，可执行文件格式）"><a href="#3-ELF（Executable-and-Linkable-Format，可执行文件格式）" class="headerlink" title="3. ELF（Executable and Linkable Format，可执行文件格式）"></a>3. ELF（Executable and Linkable Format，可执行文件格式）</h4><p><strong>在 Linux 下，可执行程序形成的时候，不是无顺的二进制构成，可执行程序有自己的二进制格式 —— ELF 格式。</strong></p><ul><li><strong>程序头部</strong>（Program Header）：描述如何加载程序。</li><li><strong>代码段</strong>（.text）：存放程序的可执行代码。</li><li><strong>数据段</strong>（.data、.bss）：存放全局变量、静态变量等。</li><li><strong>符号表</strong>（仅 Debug 模式下存在）：包含函数、变量等信息，方便调试器使用。</li></ul><p><strong>查看 ELF 结构：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">readelf -h hello_debug   <span class="comment"># 查看 ELF 头部信息</span></span><br><span class="line">objdump -d hello_debug   <span class="comment"># 反汇编可执行文件</span></span><br></pre></td></tr></table></figure><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>GCC&#x2F;G++ 在 Linux 下的常用编译选项</strong></p><table><thead><tr><th><strong>选项</strong></th><th><strong>作用</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td><code>-o &lt;文件名&gt;</code></td><td>指定输出的可执行文件名（<code>gcc -o 输出文件 源文件</code> 和 <code>gcc 源文件 -o 输出文件</code> 均可，更推荐后者！）</td><td><code>gcc hello.c -o hello</code></td></tr><tr><td><code>-c</code></td><td>仅编译，不进行链接，生成 <code>.o</code> 目标文件</td><td><code>gcc -c hello.c -o hello.o</code></td></tr><tr><td><code>-g</code></td><td>生成调试信息，便于 <code>gdb</code> 调试</td><td><code>gcc -g hello.c -o hello_debug</code></td></tr><tr><td><code>-O0</code></td><td><strong>不优化</strong>，适用于 Debug</td><td><code>gcc -O0 hello.c -o hello</code></td></tr><tr><td><code>-O1</code></td><td><strong>基本优化</strong>，适用于一般调试</td><td><code>gcc -O1 hello.c -o hello</code></td></tr><tr><td><code>-O2</code></td><td><strong>标准优化</strong>，提高性能，适用于 Release</td><td><code>gcc -O2 hello.c -o hello</code></td></tr><tr><td><code>-O3</code></td><td><strong>高级优化</strong>，可能影响可读性和调试</td><td><code>gcc -O3 hello.c -o hello</code></td></tr><tr><td><code>-Wall</code></td><td>启用所有常见警告</td><td><code>gcc -Wall hello.c -o hello</code></td></tr><tr><td><code>-Wextra</code></td><td>启用额外的警告信息</td><td><code>gcc -Wall -Wextra hello.c -o hello</code></td></tr><tr><td><code>-Werror</code></td><td>把所有警告当作错误</td><td><code>gcc -Werror hello.c -o hello</code></td></tr><tr><td><code>-static</code></td><td>进行 <strong>静态链接</strong>，不依赖 <code>.so</code> 库</td><td><code>gcc -static hello.c -o hello</code></td></tr><tr><td><code>-shared</code></td><td>生成 <strong>共享库（动态库）</strong> <code>.so</code> 文件</td><td><code>gcc -shared -fPIC hello.c -o libhello.so</code></td></tr><tr><td><code>-fPIC</code></td><td>生成位置无关代码（用于动态库）</td><td><code>gcc -fPIC -c hello.c -o hello.o</code></td></tr><tr><td><code>-L&lt;路径&gt;</code></td><td>指定库文件搜索路径</td><td><code>gcc hello.c -L/usr/local/lib -lhello -o hello</code></td></tr><tr><td><code>-I&lt;路径&gt;</code></td><td>指定头文件搜索路径</td><td><code>gcc hello.c -I/usr/local/include -o hello</code></td></tr><tr><td><code>-l&lt;库名&gt;</code></td><td>链接指定的库（默认搜索 <code>/lib</code> 和 <code>/usr/lib</code>）</td><td><code>gcc hello.c -lm -o hello</code>（链接 <code>libm.so</code> 数学库）</td></tr><tr><td><code>-pthread</code></td><td>支持多线程编译</td><td><code>gcc hello.c -pthread -o hello</code></td></tr><tr><td><code>-std=&lt;标准&gt;</code></td><td>指定 C 或 C++ 标准</td><td><code>gcc -std=c99 hello.c -o hello</code></td></tr><tr><td><code>-D&lt;宏定义&gt;</code></td><td>定义宏，等效于 <code>#define</code></td><td><code>gcc -DDEBUG hello.c -o hello</code></td></tr><tr><td><code>-E</code></td><td>仅进行 <strong>预处理</strong>，输出 <code>.i</code> 文件</td><td><code>gcc -E hello.c -o hello.i</code></td></tr><tr><td><code>-S</code></td><td>仅进行 <strong>编译</strong>，输出汇编代码 <code>.s</code> 文件</td><td><code>gcc -S hello.c -o hello.s</code></td></tr><tr><td><code>-v</code></td><td>显示详细的编译过程</td><td><code>gcc -v hello.c -o hello</code></td></tr><tr><td><code>--version</code></td><td>显示 <code>gcc/g++</code> 版本</td><td><code>gcc --version</code></td></tr></tbody></table><p><strong>G++ 额外的选项</strong></p><table><thead><tr><th><strong>选项</strong></th><th><strong>作用</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td><code>-fno-rtti</code></td><td>禁用运行时类型识别（RTTI）</td><td><code>g++ -fno-rtti hello.cpp -o hello</code></td></tr><tr><td><code>-fno-exceptions</code></td><td>禁用异常处理（<code>try/catch</code>）</td><td><code>g++ -fno-exceptions hello.cpp -o hello</code></td></tr><tr><td><code>-std=c++11</code></td><td>使用 C++11 标准</td><td><code>g++ -std=c++11 hello.cpp -o hello</code></td></tr><tr><td><code>-std=c++17</code></td><td>使用 C++17 标准</td><td><code>g++ -std=c++17 hello.cpp -o hello</code></td></tr><tr><td><code>-std=c++20</code></td><td>使用 C++20 标准</td><td><code>g++ -std=c++20 hello.cpp -o hello</code></td></tr></tbody></table><p><strong><code>gcc</code> 与 <code>g++</code> 的关系</strong></p><ul><li><p><code>g++</code> <strong>可以使用 <code>gcc</code> 的全部选项</strong>，因为 <code>g++</code> 本质上是 <code>gcc</code> 的一个前端，专门用于编译 C++ 代码。</p></li><li><p><code>gcc</code> 既可以编译 C 也可以编译 C++，但默认 <strong>不会自动链接 C++ 标准库</strong>。</p></li><li><p><code>g++</code> 默认 <strong>会自动链接 C++ 标准库</strong>（如 <code>libstdc++</code>），并开启 C++ 语法支持。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>005 权限的理解</title>
      <link href="/posts/35315.html"/>
      <url>/posts/35315.html</url>
      
        <content type="html"><![CDATA[<h2 id="shell-命令以及运行原理"><a href="#shell-命令以及运行原理" class="headerlink" title="shell 命令以及运行原理"></a>shell 命令以及运行原理</h2><h3 id="1-Shell-是什么？"><a href="#1-Shell-是什么？" class="headerlink" title="1. Shell 是什么？"></a>1. Shell 是什么？</h3><p><strong>Shell 是用户与操作系统内核（Kernel）之间的“翻译官”。</strong>  </p><p>你可以把操作系统内核想象成一个国家的总统（Kernel），他直接管理国家资源（CPU、内存、磁盘等）。但普通人（用户）无法直接和总统对话，必须通过一个“秘书”（Shell）来传达需求。  </p><ul><li><strong>用户通过 Shell 输入命令</strong>（比如 <code>ls</code>、<code>cd</code>）。  </li><li><strong>Shell 将命令“翻译”成内核能理解的指令</strong>，交给内核执行。  </li><li><strong>内核处理完成后，结果再通过 Shell 返回给用户</strong>。</li></ul><h3 id="2-为什么不能直接操作内核？"><a href="#2-为什么不能直接操作内核？" class="headerlink" title="2. 为什么不能直接操作内核？"></a>2. 为什么不能直接操作内核？</h3><ul><li><strong>内核是操作系统的核心，直接操作风险极高</strong>。比如，直接让内核删除某个文件，就像让总统亲自去处理一个普通任务——虽然高效但风险极高，一旦出错可能导致系统崩溃。</li><li><strong>Shell 的存在是为了安全和易用</strong>：  <ul><li>用户无需理解底层硬件细节（比如如何读写磁盘）。  </li><li>Shell 通过权限控制和语法检查，避免用户误操作导致系统崩溃。</li></ul></li></ul><hr><h3 id="3-Shell-的“媒婆”比喻"><a href="#3-Shell-的“媒婆”比喻" class="headerlink" title="3. Shell 的“媒婆”比喻"></a>3. Shell 的“媒婆”比喻</h3><p><strong>Shell 是“媒婆”，内核是“村花小花”</strong>：你想追求小花（让内核干活），但不好意思直接开口（直接操作内核）。于是你找媒婆王婆（Shell）帮忙：  </p><ul><li>你告诉王婆需求（输入命令）。  </li><li>王婆转达给小花（Shell 解析命令并调用内核）。  </li><li>小花办好后，王婆再把结果告诉你（Shell 返回输出）。</li></ul><p><strong>媒婆的作用</strong>：  </p><ul><li><strong>翻译需求</strong>：用户说“想送花”，媒婆翻译成小花能理解的“执行送花程序”。  </li><li><strong>过滤错误</strong>：用户说“送一车榴莲”，媒婆会提醒“榴莲不在允许的礼物列表”（语法错误提示）。  </li><li><strong>权限检查</strong>：用户想进小花家的后院（系统敏感目录），媒婆会核实身份（权限验证）。</li></ul><p><strong>为什么必须通过媒婆？直接表白行不行？（<em>同为什么不能直接操作内核</em>）</strong></p><ul><li><strong>直接操作内核的风险</strong>：  <ul><li>用户可能说错话（输入错误命令），导致小花误解（系统崩溃）。  </li><li>用户可能要求不合理（删除系统关键文件），小花直接拒绝（权限不足）。</li></ul></li><li><strong>媒婆的安全保障</strong>：  <ul><li><strong>权限控制</strong>：媒婆会检查用户身份，比如普通用户不能修改系统配置（<code>sudo</code> 提权需要密码）。  </li><li><strong>错误拦截</strong>：用户输入“删库跑路”，媒婆会反问“你确定吗？”（<code>rm -rf /</code> 前的确认提示）。</li></ul></li></ul><p><strong>如果媒婆罢工了（Shell 崩溃）？</strong></p><ul><li><strong>用户会陷入沉默</strong>：无法与小花沟通，只能重启终端（找新媒婆）。  </li><li><strong>内核依然在运行</strong>：小花继续管理村庄，但用户无法直接互动。  </li><li><strong>解决方案</strong>：  <ul><li>使用备用媒婆（不同 Shell 类型：Bash、Zsh、Fish）。  </li><li>通过远程媒婆（SSH 连接）继续工作。</li></ul></li></ul><p><strong>终极金句</strong>：  </p><blockquote><p>没有媒婆的牵线，程序员的爱情（操作内核）将寸步难行；<br>没有 Shell 的翻译，用户与内核的对话将鸡同鸭讲。</p></blockquote><hr><h3 id="4-图形界面（GUI）也是-Shell？"><a href="#4-图形界面（GUI）也是-Shell？" class="headerlink" title="4. 图形界面（GUI）也是 Shell？"></a>4. 图形界面（GUI）也是 Shell？</h3><ul><li><strong>无论是命令行（CLI）还是图形界面（GUI），本质都是用户与内核的中介</strong>。  <ul><li><strong>Windows 的 GUI</strong>：双击图标 → 图形界面程序调用内核完成任务。  </li><li><strong>Linux 的 Shell</strong>：输入命令 → Shell 调用内核完成任务。</li></ul></li><li><strong>区别在于交互方式</strong>：  <ul><li>CLI 更高效，适合程序员和自动化脚本。  </li><li>GUI 更直观，适合普通用户。</li></ul></li></ul><h3 id="5-Shell-的高级功能"><a href="#5-Shell-的高级功能" class="headerlink" title="5. Shell 的高级功能"></a>5. Shell 的高级功能</h3><ul><li><strong>脚本编程</strong>：将多个命令写成脚本，一键执行复杂任务。  </li><li><strong>管道（<code>|</code>）</strong>：将一个命令的输出作为另一个命令的输入。例如：<code>ls | grep .txt</code>（列出所有文件，再过滤出 <code>.txt</code> 文件）。  </li><li><strong>重定向（<code>&gt;</code>、<code>&gt;&gt;</code>）</strong>：将命令结果保存到文件。例如：<code>ls &gt; files.txt</code>（将文件列表保存到 <code>files.txt</code>）。</li></ul><hr><h2 id="Linux-权限的概念"><a href="#Linux-权限的概念" class="headerlink" title="Linux 权限的概念"></a>Linux 权限的概念</h2><h3 id="一、用户类型详解"><a href="#一、用户类型详解" class="headerlink" title="一、用户类型详解"></a>一、用户类型详解</h3><h4 id="1-超级用户（root）"><a href="#1-超级用户（root）" class="headerlink" title="1. 超级用户（root）"></a>1. 超级用户（root）</h4><ul><li><strong>权限</strong>：拥有系统的最高权限，可以执行任何操作。包括安装、删除软件、修改系统设置、删除系统文件等危险行为。操作不当可能导致系统崩溃。</li><li><strong>提示符</strong>：<code>#</code>（如 <code>[root@server ~]#</code>），在命令行中，<code>#</code> 表示当前是 root 用户。</li><li><strong>默认路径</strong>：<code>/root</code>，这是 root 用户的家目录。</li><li><strong>危险提示</strong>：建议平时使用普通用户，而非 root 用户，避免误操作导致的系统崩溃或损坏。</li></ul><h4 id="2-普通用户"><a href="#2-普通用户" class="headerlink" title="2. 普通用户"></a>2. 普通用户</h4><ul><li><strong>权限</strong>：只能访问和操作自己的文件目录（默认在 <code>/home/用户名</code> 下），以及有限的系统资源。无法修改系统配置或执行需要高权限的操作。</li><li><strong>提示符</strong>：<code>$</code>（如 <code>[user@server ~]$</code>），表示当前是普通用户。</li><li><strong>默认路径</strong>：<code>/home/用户名</code>，每个普通用户都会有自己的家目录。</li><li><strong>优势</strong>：使用普通用户更安全，避免误操作破坏系统。</li></ul><h3 id="二、用户切换操作详解"><a href="#二、用户切换操作详解" class="headerlink" title="二、用户切换操作详解"></a>二、用户切换操作详解</h3><h4 id="1-su-命令-——-切换用户的命令。"><a href="#1-su-命令-——-切换用户的命令。" class="headerlink" title="1. su 命令 —— 切换用户的命令。"></a>1. <code>su</code> 命令 —— 切换用户的命令。</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su [选项] [用户名]</span><br></pre></td></tr></table></figure><ul><li><strong>不带参数</strong>：默认切换到 root 用户（需要输入 root 密码）。</li><li><strong>带用户名</strong>：切换到指定的用户（需要输入目标用户密码）。</li></ul><p><strong>具体场景（注意各自切换所要输入的密码）：</strong></p><ol><li><p><strong>普通用户 → root</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[user@server ~]$ su -</span><br><span class="line">Password:  <span class="comment"># 输入 root 密码</span></span><br><span class="line">[root@server ~]#  <span class="comment"># 成功切换到 root</span></span><br></pre></td></tr></table></figure></li><li><p><strong>root → 普通用户</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@server ~]# su - user</span><br><span class="line">[user@server ~]$  <span class="comment"># 成功切换到普通用户 user</span></span><br></pre></td></tr></table></figure></li><li><p><strong>普通用户 → 其他普通用户</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[user1@server ~]$ su - user2</span><br><span class="line">Password:  <span class="comment"># 输入 user2 密码</span></span><br><span class="line">[user2@server ~]$  <span class="comment"># 成功切换到 user2 用户</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="2-su-与-su-的区别"><a href="#2-su-与-su-的区别" class="headerlink" title="2. su 与 su - 的区别"></a>2. <code>su</code> 与 <code>su -</code> 的区别</h4><table><thead><tr><th>命令</th><th>环境变量</th><th>工作目录</th><th>使用场景</th></tr></thead><tbody><tr><td><code>su</code></td><td>保留当前环境</td><td>当前目录</td><td>临时执行少量命令</td></tr><tr><td><code>su -</code></td><td>重新加载用户环境</td><td>目标用户家目录</td><td>需要完整用户环境时</td></tr></tbody></table><p><strong>示例对比：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 su</span></span><br><span class="line">[root@server /]# su user</span><br><span class="line">[user@server /]$ <span class="built_in">pwd</span></span><br><span class="line">/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 su -</span></span><br><span class="line">[root@server /]# su - user</span><br><span class="line">[user@server ~]$ <span class="built_in">pwd</span></span><br><span class="line">/home/user</span><br></pre></td></tr></table></figure><h3 id="三、sudo-基础权限配置（了解，后面详讲）"><a href="#三、sudo-基础权限配置（了解，后面详讲）" class="headerlink" title="三、sudo 基础权限配置（了解，后面详讲）"></a>三、sudo 基础权限配置（了解，后面详讲）</h3><h4 id="1-sudo-基础"><a href="#1-sudo-基础" class="headerlink" title="1. sudo 基础"></a>1. sudo 基础</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> &lt;命令&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>作用</strong>：使用 <code>sudo</code> 命令，普通用户可以临时以 root 权限执行特权命令。</li><li><strong>要求</strong>：用户必须在 <code>/etc/sudoers</code> 文件中有权限设置。</li></ul><h4 id="2-配置-sudo-权限（这是一种方法，可以先了解，不建议现在进行配置）"><a href="#2-配置-sudo-权限（这是一种方法，可以先了解，不建议现在进行配置）" class="headerlink" title="2. 配置 sudo 权限（这是一种方法，可以先了解，不建议现在进行配置）"></a>2. 配置 sudo 权限（这是一种方法，可以先了解，不建议现在进行配置）</h4><p>配置 <code>sudo</code> 权限时，建议使用 <code>visudo</code> 命令，因为它可以在保存前检查语法错误，避免不小心出错。</p><ol><li><p><strong>切换到 root 用户</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su -  <span class="comment"># 切换到 root</span></span><br></pre></td></tr></table></figure></li><li><p><strong>使用 visudo 编辑 <code>/etc/sudoers</code> 文件</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">visudo  <span class="comment"># 进入编辑模式，自动检查语法</span></span><br></pre></td></tr></table></figure></li><li><p><strong>配置示例</strong>：</p><ul><li><p>允许普通用户 <code>user</code> 执行所有命令，且无需密码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user    ALL=(ALL)       NOPASSWD: ALL</span><br></pre></td></tr></table></figure></li><li><p>允许 <code>wheel</code> 组的成员使用 <code>sudo</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%wheel  ALL=(ALL)       ALL</span><br></pre></td></tr></table></figure></li></ul></li></ol><h4 id="3-验证配置"><a href="#3-验证配置" class="headerlink" title="3. 验证配置"></a>3. 验证配置</h4><p>如果配置成功，可以通过 <code>sudo</code> 执行命令来验证：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[user@server ~]$ <span class="built_in">sudo</span> systemctl restart sshd</span><br><span class="line"><span class="comment"># 如果配置成功，可以执行命令而无需输入密码</span></span><br></pre></td></tr></table></figure><h4 id="4-典型错误处理"><a href="#4-典型错误处理" class="headerlink" title="4. 典型错误处理"></a>4. 典型错误处理</h4><p>当用户不在 <code>sudoers</code> 文件中时，可能会看到以下错误：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user is not <span class="keyword">in</span> the sudoers file. This incident will be reported.</span><br></pre></td></tr></table></figure><p><strong>解决方法</strong>：</p><ol><li><p>切换到 root 用户：<code>su -</code></p></li><li><p>将用户加入 <code>wheel</code> 组：<code>usermod -aG wheel user</code></p></li><li><p>确保 <code>/etc/sudoers</code> 文件中有以下配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%wheel  ALL=(ALL)       ALL</span><br></pre></td></tr></table></figure></li></ol><h3 id="四、最佳实践建议"><a href="#四、最佳实践建议" class="headerlink" title="&#x3D;&#x3D;四、最佳实践建议&#x3D;&#x3D;"></a>&#x3D;&#x3D;四、最佳实践建议&#x3D;&#x3D;</h3><ol><li><strong>日常使用普通用户</strong>：避免直接以 root 用户登录，普通用户更安全。使用 <code>sudo</code> 执行特权命令。</li><li><strong>重要操作前备份</strong>：在执行任何高风险操作时，尤其是以 root 权限进行修改时，要确保有备份。</li><li><strong>sudo 权限最小化</strong>：只为需要的用户分配 <code>sudo</code> 权限，避免随意赋予 <code>NOPASSWD: ALL</code> 权限。</li><li>会话管理：<ul><li>进入 root 环境后，要及时使用 <code>exit</code> 或 <code>Ctrl+D</code> 退出。</li><li>使用 <code>whoami</code> 命令确认当前用户身份，避免误操作。</li></ul></li></ol><h3 id="五、操作流程图解"><a href="#五、操作流程图解" class="headerlink" title="五、操作流程图解"></a>五、操作流程图解</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">普通用户环境</span><br><span class="line">   │</span><br><span class="line">   ├─ 需要执行特权命令 → sudo &lt;命令&gt;</span><br><span class="line">   │     ├─ 有权限 → 执行成功</span><br><span class="line">   │     └─ 无权限 → 拒绝执行</span><br><span class="line">   │</span><br><span class="line">   └─ 需要切换用户 → su/su -</span><br><span class="line">         ├─ 切换到 root → 输入 root 密码</span><br><span class="line">         └─ 切换其他用户 → 输入目标用户密码</span><br></pre></td></tr></table></figure><hr><h2 id="Linux-权限管理"><a href="#Linux-权限管理" class="headerlink" title="Linux 权限管理"></a>Linux 权限管理</h2><h3 id="一、Linux-权限管理"><a href="#一、Linux-权限管理" class="headerlink" title="一、Linux 权限管理"></a>一、Linux 权限管理</h3><p>Linux 系统中的权限管理决定了文件和目录的访问控制。权限管理涉及两个主要方面：</p><ol><li><strong>权限认证</strong>：确定谁（用户）可以访问文件或目录。</li><li><strong>权限类型</strong>：确定可以对文件或目录执行什么操作（<strong><code>读、写、执行</code></strong>）。</li></ol><h3 id="二、文件的权限和文件属性"><a href="#二、文件的权限和文件属性" class="headerlink" title="二、文件的权限和文件属性"></a>二、文件的权限和文件属性</h3><h4 id="1-文件访问者的分类（“人”）"><a href="#1-文件访问者的分类（“人”）" class="headerlink" title="1. 文件访问者的分类（“人”）"></a>1. 文件访问者的分类（“<code>人</code>”）</h4><p>权限分为三类：</p><ul><li><strong><code>u</code></strong> (User)：文件或目录的 <strong><code>所有者</code></strong>&#x2F;<strong><code>拥有者</code></strong>。即文件的创建者或被赋予所有权的用户。</li><li><strong><code>g</code></strong> (Group)：文件或目录的 <strong><code>所属组</code></strong> 的用户。即拥有该文件或目录的同组成员。</li><li><strong><code>o</code></strong> (Others)：<strong><code>其他用户</code></strong>，指的是既不是文件所有者，也不属于文件所属组的用户。</li></ul><h4 id="2-权限表示方式"><a href="#2-权限表示方式" class="headerlink" title="2. 权限表示方式"></a>2. 权限表示方式</h4><p>举个栗子，并逐一解析：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">drwxrwxr-x 2 hcc hcc 4096 Feb  3 20:26 temp</span><br><span class="line"><span class="comment"># 怎么看：</span></span><br><span class="line">drwxrwxr-x（1 | 9）/（1 | 3|3|3）</span><br><span class="line"><span class="comment"># drwxrwxr-x 对应着 &lt;file-type&gt;&lt;user-permissions&gt;&lt;group-permissions&gt;&lt;other-permissions&gt;</span></span><br></pre></td></tr></table></figure><ol><li><strong>文件类型</strong>（第一个字符）：<ul><li><strong>d</strong>：表示这是一个目录文件。</li></ul></li><li><strong>文件权限</strong>（后面的 9 个字符 3 位一看）：<ul><li><code>rwx</code>：表示 <strong>用户（文件所有者）</strong> 具有读、写、执行权限。</li><li><code>rwx</code>：表示 <strong>组用户</strong> 具有读、写、执行权限。</li><li><code>r-x</code>：表示 <strong>其他用户</strong> 具有读和执行权限，但没有写权限。</li></ul></li><li><strong>其他信息</strong>：<ul><li><code>2</code>：表示该目录下的硬链接数量。</li><li><code>hcc</code> <strong>（前一个）</strong>：表示文件的 <strong>拥有者</strong>（User）是 <code>hcc</code>。</li><li><code>hcc</code> <strong>（后一个）</strong>：表示文件的 <strong>所属组</strong>（Group）是 <code>hcc</code>。</li><li><code>4096</code>：表示该文件（或目录）的大小（单位为字节）。</li><li><code>Feb  3 20:26</code>：表示文件的最后修改时间。</li><li><code>temp</code>：表示文件的名称。</li></ul></li></ol><h4 id="3-文件类型和访问权限（“事物属性”）"><a href="#3-文件类型和访问权限（“事物属性”）" class="headerlink" title="3. 文件类型和访问权限（“事物属性”）"></a>3. 文件类型和访问权限（“事物属性”）</h4><p><strong>文件类型（第一位字符）：</strong></p><table><thead><tr><th align="center">文件类型字符</th><th>含义</th><th>示例</th></tr></thead><tbody><tr><td align="center"><strong><code>d</code></strong></td><td><strong>目录文件（Directory）</strong></td><td><code>drwxr-xr-x</code>（表示这是一个目录文件）</td></tr><tr><td align="center"><strong><code>-</code></strong></td><td><strong>普通文件（Regular file）</strong></td><td><code>-rwxr-xr-x</code>（表示这是一个普通文件）</td></tr><tr><td align="center"><strong>l</strong></td><td>软链接（Symbolic link）</td><td><code>lrwxrwxrwx</code>（类似于 Windows 的快捷方式）</td></tr><tr><td align="center"><strong>b</strong></td><td>块设备文件（Block device file）</td><td><code>brw-rw----</code>（如硬盘、光驱等）</td></tr><tr><td align="center"><strong>p</strong></td><td>管道文件（Pipe file）</td><td><code>prw-r--r--</code>（用于进程间通信）</td></tr><tr><td align="center"><strong>c</strong></td><td>字符设备文件（Character device file）</td><td><code>crw-rw----</code>（如终端设备、打印机等）</td></tr><tr><td align="center"><strong>s</strong></td><td>套接口文件（Socket file）</td><td><code>srwxrwxrwx</code>（用于网络通信等）</td></tr></tbody></table><p><strong>权限（后三位字符）：</strong></p><table><thead><tr><th align="center">权限字符</th><th>含义</th><th align="center">对应数字</th><th>说明</th></tr></thead><tbody><tr><td align="center"><strong>r</strong></td><td>读权限（Read）</td><td align="center">4</td><td>对文件：允许读取文件内容；对目录：允许列出目录中的文件。</td></tr><tr><td align="center"><strong>w</strong></td><td>写权限（Write）</td><td align="center">2</td><td>对文件：允许修改文件内容；对目录：允许创建、删除、移动目录中的文件。</td></tr><tr><td align="center"><strong>x</strong></td><td>执行权限（Execute）</td><td align="center">1</td><td>对文件：允许执行文件；对目录：允许进入该目录。</td></tr><tr><td align="center"><strong>-</strong></td><td>没有权限</td><td align="center">0</td><td>表示没有该项权限。</td></tr></tbody></table><p><strong>权限的组合（后三位字符表示权限）：</strong></p><table><thead><tr><th align="center">权限组合</th><th>含义</th><th align="center">数字表示</th><th>说明</th></tr></thead><tbody><tr><td align="center"><strong>rwx</strong></td><td>读、写、执行权限（可完全访问）</td><td align="center">7</td><td>用户&#x2F;组&#x2F;其他均有读、写、执行权限。</td></tr><tr><td align="center"><strong>rw-</strong></td><td>读、写权限（没有执行权限）</td><td align="center">6</td><td>用户&#x2F;组&#x2F;其他可以读取和修改文件，但不能执行。</td></tr><tr><td align="center"><strong>r-x</strong></td><td>读、执行权限（没有写权限）</td><td align="center">5</td><td>用户&#x2F;组&#x2F;其他可以读取和执行文件，但不能修改。</td></tr><tr><td align="center"><strong>r–</strong></td><td>只有读权限</td><td align="center">4</td><td>用户&#x2F;组&#x2F;其他只能读取文件，无法修改或执行。</td></tr><tr><td align="center"><strong>wx-</strong></td><td>写、执行权限（没有读权限）</td><td align="center">3</td><td>用户&#x2F;组&#x2F;其他可以修改文件并执行文件，但不能读取文件。</td></tr><tr><td align="center"><strong>x–</strong></td><td>只有执行权限</td><td align="center">1</td><td>用户&#x2F;组&#x2F;其他只能执行文件，无法读取或修改文件。</td></tr><tr><td align="center"><strong>—</strong></td><td>没有任何权限</td><td align="center">0</td><td>用户&#x2F;组&#x2F;其他没有任何权限。</td></tr></tbody></table><p>每个权限都有两个状态：<strong>有权限</strong> 或 <strong>没有权限</strong>，这恰好对应了二进制的 <code>1</code> 和 <code>0</code>，所以数字表示的由来是二进制：</p><table><thead><tr><th align="center">权限符号（读写执行）</th><th align="center">八进制（数字表示）</th><th align="center">二进制</th></tr></thead><tbody><tr><td align="center">r</td><td align="center">4</td><td align="center">100</td></tr><tr><td align="center">w</td><td align="center">2</td><td align="center">010</td></tr><tr><td align="center">x</td><td align="center">1</td><td align="center">001</td></tr><tr><td align="center">rw</td><td align="center">6</td><td align="center">110</td></tr><tr><td align="center">rx</td><td align="center">5</td><td align="center">101</td></tr><tr><td align="center">wx</td><td align="center">3</td><td align="center">011</td></tr><tr><td align="center">rwx</td><td align="center">7</td><td align="center">111</td></tr><tr><td align="center">—</td><td align="center">0</td><td align="center">000</td></tr></tbody></table><hr><h3 id="三、文件访问权限的相关设置方法"><a href="#三、文件访问权限的相关设置方法" class="headerlink" title="三、文件访问权限的相关设置方法"></a>三、文件访问权限的相关设置方法</h3><h4 id="1-chmod-设置文件的访问权限"><a href="#1-chmod-设置文件的访问权限" class="headerlink" title="1. chmod - 设置文件的访问权限"></a>1. <code>chmod</code> - 设置文件的访问权限</h4><p><code>chmod</code> 命令用于设置文件的访问权限。它允许你改变文件或目录的权限，分为两种方式：使用符号表示法和使用八进制表示法。</p><ul><li><strong>普通用户</strong>：普通用户只能修改自己拥有的文件或目录的权限。如果普通用户尝试修改其他用户的文件或目录权限，会提示 <code>Permission denied</code>（权限被拒绝）。</li><li><strong>root 用户</strong>：<code>root</code> 用户是系统管理员，具有所有权限，因此 <code>root</code> 可以修改任何文件或目录的权限。</li></ul><p><strong>语法格式：<code>chmod [参数] 权限 文件名</code></strong></p><p><strong>常用选项：<code>-R</code>：递归地修改目录和其中所有文件的权限。</strong></p><p><strong>权限的表示方法：</strong></p><table><thead><tr><th align="center">符号</th><th>描述</th></tr></thead><tbody><tr><td align="center"><code>+</code></td><td>向权限范围增加权限</td></tr><tr><td align="center"><code>-</code></td><td>向权限范围取消权限</td></tr><tr><td align="center"><code>=</code></td><td>设置权限，覆盖现有权限</td></tr></tbody></table><p><strong>用户符号：</strong></p><table><thead><tr><th align="center">符号</th><th>描述</th></tr></thead><tbody><tr><td align="center"><code>u</code></td><td>拥有者（user）</td></tr><tr><td align="center"><code>g</code></td><td>所属组（group）</td></tr><tr><td align="center"><code>o</code></td><td>其他用户（others）</td></tr><tr><td align="center"><code>a</code></td><td>所有用户（all）</td></tr></tbody></table><p><strong>权限符号：</strong></p><table><thead><tr><th align="center">符号</th><th>描述</th></tr></thead><tbody><tr><td align="center"><code>r</code></td><td>读取权限（read）</td></tr><tr><td align="center"><code>w</code></td><td>写入权限（write）</td></tr><tr><td align="center"><code>x</code></td><td>执行权限（execute）</td></tr></tbody></table><p><strong>示例：</strong></p><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>chmod u+w /home/abc.txt</code></td><td>给文件 <code>/home/abc.txt</code> 的拥有者添加写权限。</td></tr><tr><td><code>chmod o-x /home/abc.txt</code></td><td>去掉其他用户的执行权限。</td></tr><tr><td><code>chmod a=x /home/abc.txt</code></td><td>给所有用户赋予执行权限，其他权限被去除。</td></tr></tbody></table><h4 id="八进制表示法："><a href="#八进制表示法：" class="headerlink" title="八进制表示法："></a>八进制表示法：</h4><table><thead><tr><th align="center">权限组合</th><th align="center">八进制数字</th><th>说明</th></tr></thead><tbody><tr><td align="center"><code>rwx</code></td><td align="center">7</td><td>读取、写入、执行权限（4+2+1）</td></tr><tr><td align="center"><code>rw-</code></td><td align="center">6</td><td>读取、写入权限（4+2）</td></tr><tr><td align="center"><code>r-x</code></td><td align="center">5</td><td>读取、执行权限（4+1）</td></tr><tr><td align="center"><code>r--</code></td><td align="center">4</td><td>读取权限（4）</td></tr><tr><td align="center"><code>wx-</code></td><td align="center">3</td><td>写入、执行权限（2+1）</td></tr><tr><td align="center"><code>w--</code></td><td align="center">2</td><td>写入权限（2）</td></tr><tr><td align="center"><code>x--</code></td><td align="center">1</td><td>执行权限（1）</td></tr><tr><td align="center"><code>---</code></td><td align="center">0</td><td>无权限</td></tr></tbody></table><p><strong>示例：</strong></p><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>chmod 664 /home/abc.txt</code></td><td>设置文件权限为 <code>rw-rw-r--</code>，即拥有者和所属组有读写权限，其他用户只有读权限。</td></tr><tr><td><code>chmod 640 /home/abc.txt</code></td><td>设置文件权限为 <code>rw-r-----</code>，即拥有者有读写权限，拥有者有读写权限，所属组有读权限，其他用户没有权限。</td></tr></tbody></table><hr><h4 id="2-chown-修改文件的拥有者"><a href="#2-chown-修改文件的拥有者" class="headerlink" title="2. chown - 修改文件的拥有者"></a>2. <code>chown</code> - 修改文件的拥有者</h4><p><code>chown</code> 命令用于修改文件的所有者和所属组。</p><ul><li><strong>普通用户</strong>：普通用户只能更改自己拥有的文件的所有者。如果尝试更改其他用户的文件或目录的拥有者，普通用户会看到 <code>Permission denied</code>。</li><li><strong>root 用户</strong>：<code>root</code> 用户能够修改任何文件或目录的拥有者，不受任何限制。</li></ul><p><strong>语法格式：<code>chown [参数] 用户名 文件名</code></strong></p><p><strong>常用选项：<code>-R</code>：递归地修改目录和其中所有文件的权限。</strong></p><p><strong>示例：</strong></p><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>chown user1 f1</code></td><td>将文件 <code>f1</code> 的拥有者更改为 <code>user1</code>。</td></tr><tr><td><code>chown -R user1 filegroup1</code></td><td>递归地将目录 <code>filegroup1</code> 及其子文件的所有者更改为 <code>user1</code>。</td></tr></tbody></table><hr><h4 id="3-chgrp-修改文件或目录的所属组"><a href="#3-chgrp-修改文件或目录的所属组" class="headerlink" title="3. chgrp - 修改文件或目录的所属组"></a>3. <code>chgrp</code> - 修改文件或目录的所属组</h4><p><code>chgrp</code> 命令用于修改文件或目录的所属组。</p><ul><li><strong>普通用户</strong>：普通用户只能更改自己拥有的文件或目录的所属组。如果尝试更改其他用户的文件或目录的所属组，则会提示 <code>Permission denied</code>。</li><li><strong>root 用户</strong>：<code>root</code> 用户可以修改任何文件或目录的所属组，无论该文件是否属于 <code>root</code> 或其他用户。</li></ul><p><strong>语法格式：<code>chgrp [参数] 用户组名 文件名</code></strong></p><p><strong>常用选项：<code>-R</code>：递归地修改目录和其中所有文件的权限。</strong></p><p><strong>示例：</strong></p><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>chgrp users /abc/f2</code></td><td>将文件 <code>/abc/f2</code> 的所属组更改为 <code>users</code>。</td></tr></tbody></table><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><table><thead><tr><th>操作类型</th><th>普通用户能否执行</th><th>root 用户能否执行</th><th>执行成功&#x2F;失败</th></tr></thead><tbody><tr><td><code>chmod</code> 修改权限</td><td>只能修改自己拥有的文件</td><td>可以修改任何文件</td><td>普通用户成功：文件属于自己；失败：<code>Permission denied</code></td></tr><tr><td><code>chown</code> 修改拥有者</td><td>只能修改自己拥有的文件</td><td>可以修改任何文件</td><td>普通用户成功：文件属于自己；失败：<code>Permission denied</code></td></tr><tr><td><code>chgrp</code> 修改所属组</td><td>只能修改自己拥有的文件</td><td>可以修改任何文件</td><td>普通用户成功：文件属于自己；失败：<code>Permission denied</code></td></tr></tbody></table><hr><h3 id="file-命令"><a href="#file-命令" class="headerlink" title="file 命令"></a><code>file</code> 命令</h3><p><code>file</code> 命令用于识别文件的类型。它会根据文件的内容、格式以及文件头部的标识来判断分析文件内部的结构来推测其类型，不依赖于文件的扩展名，非常有用。</p><p><strong>语法：<code>file [选项] 文件或目录...</code></strong></p><p><strong>常用选项</strong>：</p><ul><li><code>-c</code>：显示详细的执行过程，帮助你分析程序的执行情况。例如，它可以显示 <code>file</code> 命令如何判断文件类型，通常在调试时很有用。</li><li><code>-z</code>：尝试解压缩压缩文件，并分析压缩文件中的内容。如果你有一个 <code>.tar.gz</code> 或 <code>.zip</code> 文件，使用 <code>-z</code> 可以让 <code>file</code> 查看并识别压缩文件内部的内容类型。</li></ul><p><strong>示例</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">file test.txt      <span class="comment"># 输出 test.txt 文件的类型（如：ASCII text）</span></span><br><span class="line">file -z archive.gz <span class="comment"># 解压并识别压缩文件内容类型</span></span><br></pre></td></tr></table></figure><blockquote><h3 id="传道解惑"><a href="#传道解惑" class="headerlink" title="传道解惑"></a>传道解惑</h3><h4 id="Q1：起始权限问题：普通文件：664，目录文件：775，为什么我们创建文件的默认权限是我们现在看到的样子？"><a href="#Q1：起始权限问题：普通文件：664，目录文件：775，为什么我们创建文件的默认权限是我们现在看到的样子？" class="headerlink" title="Q1：起始权限问题：普通文件：664，目录文件：775，为什么我们创建文件的默认权限是我们现在看到的样子？"></a>Q1：起始权限问题：普通文件：664，目录文件：775，为什么我们创建文件的默认权限是我们现在看到的样子？</h4><p>默认权限的设置与 <strong>umask（文件创建权限掩码）</strong> 有关系，它控制了文件或目录在创建时默认的权限。我们创建普通文件和目录时，通常会看到不同的权限，这是因为操作系统使用了一种“减法”策略（<strong>最终权限 &#x3D; 起始权限 &amp; (~umask)</strong>），根据 <strong>umask</strong> 来修改文件和目录的默认权限。</p><p><strong>umask</strong> 决定了文件和目录创建时权限的“减法”规则，我们最终看到的其实是已经套公式算好的。</p><ul><li><strong>普通文件（664）</strong>：默认给普通文件的起始权限其实是 <code>666</code>，<code>666 &amp; (~0002)</code> → <code>666 &amp; 7754</code> &#x3D; <code>664</code>。</li><li><strong>目录文件（775）</strong>：默认给目录文件的起始权限其实是 <code>777</code>，<code>777 &amp; (~0002)</code> → <code>777 &amp; 7754</code> &#x3D; <code>775</code>。</li></ul><h3 id="umask-是什么？"><a href="#umask-是什么？" class="headerlink" title="umask 是什么？"></a>umask 是什么？</h3><p><code>umask</code> 是一个权限掩码，它定义了在文件或目录创建时，通过从系统的默认权限中 <strong>“去除”</strong> 权限来决定最终的权限。 <strong>umask 的值</strong> 表示哪些权限会被“去除”，而 <strong>最终权限</strong> 是通过使用按位与（<code>&amp;</code>）操作来计算的。</p><ul><li>默认的权限是固定的，即普通文件的起始权限为 <code>666</code>，目录的起始权限为 <code>777</code>。</li><li><code>umask</code> 用来“去除”权限，使用的规则是按位与：<strong>最终权限 &#x3D; 起始权限 &amp; (~umask)</strong>。</li><li><code>~umask</code> 是对 <code>umask</code> 值取反，即对 <code>umask</code> 中的每一位进行反转（0 变成 1，1 变成 0），然后与默认权限进行按位与运算。</li></ul><p>如果需要查看当前的 <strong>umask</strong> 值，可以运行 <code>umask</code> 命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="built_in">umask</span></span><br></pre></td></tr></table></figure><p><strong>常见的 umask 值</strong>：<code>umask</code> 的值虽然会显示 <code>0002</code>，<code>umask</code> 的四位数字中，第一位表示特殊权限（如粘滞位），后三位才是基本权限。但普通文件&#x2F;目录的默认权限计算时通常只关注后三位。常见的 <code>umask</code> 值：</p><table><thead><tr><th>umask 值</th><th>解释</th><th>结果权限（普通文件）</th><th>结果权限（目录文件）</th></tr></thead><tbody><tr><td><code>0002</code></td><td>所有者、组、其他用户都没有限制</td><td>664</td><td>775</td></tr><tr><td><code>0022</code></td><td>其他用户没有写权限</td><td>644</td><td>755</td></tr><tr><td><code>0077</code></td><td>只有文件拥有者有权限</td><td>600</td><td>700</td></tr></tbody></table><p><strong>umask 设置与效果</strong>：<strong>umask</strong> 的值会影响文件和目录的默认权限。当你修改 <code>umask</code> 时，操作系统会自动改变你创建的文件和目录的默认权限。</p><p>例如：如果设置 <code>umask 0022</code>，则：</p><ul><li>普通文件的权限会变为 <code>644</code>（去除其他用户的写权限）。</li><li>目录的权限会变为 <code>755</code>（去除其他用户的写权限）。</li></ul><p>可以通过以下命令查看和设置 <code>umask</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;# 查看当前 <span class="built_in">umask</span> 值</span><br><span class="line">&gt;<span class="built_in">umask</span></span><br><span class="line"></span><br><span class="line">&gt;# 设置 <span class="built_in">umask</span> 为 0022</span><br><span class="line">&gt;<span class="built_in">umask</span> 0022</span><br></pre></td></tr></table></figure><h3 id="Q2：关于文件权限-r-rw-1-a-a-的情况怎么解释？"><a href="#Q2：关于文件权限-r-rw-1-a-a-的情况怎么解释？" class="headerlink" title="Q2：关于文件权限 -r--rw---- 1 a a ... 的情况怎么解释？"></a>Q2：关于文件权限 <code>-r--rw---- 1 a a ...</code> 的情况怎么解释？</h3><p>在文件权限系统中，<strong>拥有者的权限</strong> 和 <strong>所属组的权限</strong> 是独立的，因此可能会出现拥有者的权限比所属组更少的情况。文件的权限可能是通过某些命令错误地配置的。例如，管理员或拥有者可能故意将拥有者的权限设置得比所属组的权限少。这种情况可能是在文件创建时，由于错误的 <code>chmod</code> 命令或文件权限管理不当造成的。当然也有可能是必须的，因为这种现象并非错误。</p><p><strong>关键点：拥有者权限和所属组权限独立</strong></p><ul><li><strong>拥有者权限（a）：</strong> 只能读取文件，但不能修改（没有写权限）。</li><li><strong>所属组权限（a 组）：</strong> 可以读写文件（<code>rw-</code>），但不具有执行权限。</li></ul><h4 id="权限判断顺序："><a href="#权限判断顺序：" class="headerlink" title="权限判断顺序："></a>权限判断顺序：</h4><p>在 Linux 系统中，<strong>在进行认证的时候只能选择一个角色进行认证</strong>，文件的权限是根据三种不同的身份来判断的：<strong>文件拥有者</strong>、<strong>文件所属组</strong> 和 <strong>其他用户</strong>。系统在判断文件权限时会先检查文件拥有者的权限，如果拥有者权限不足，再检查所属组的权限，最后才检查其他用户的权限。</p><ol><li><strong>文件拥有者权限</strong>（User 权限）：系统首先会检查当前操作用户是否是文件的拥有者，如果是，则优先使用文件拥有者的权限来进行访问判断。</li><li><strong>所属组权限</strong>（Group 权限）：如果当前用户不是文件的拥有者，但属于文件的所属组，则会检查文件所属组的权限。</li><li><strong>其他用户权限</strong>（Other 权限）：如果当前用户既不是文件的拥有者，也不属于文件的所属组，那么就会检查其他用户的权限。</li></ol><p><strong>解决方法</strong></p><ol><li><strong>检查文件的权限设置</strong>：首先确认文件的权限是如何设置的。如果文件的拥有者权限被误设为 <code>r--</code>，而所属组权限是 <code>rw-</code>，可以使用 <code>chmod</code> 修改文件的拥有者权限：</li></ol>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> u+w filename</span><br></pre></td></tr></table></figure><ol start="2"><li><p><strong>角色切换</strong>：如果你仅能选择一个角色进行认证，但需要更高权限来修改文件，考虑切换到具有更高权限的角色（例如通过 <code>sudo</code> 进行管理员认证）。</p></li><li><p><strong>文件所有权调整</strong>：如果你不是文件的拥有者，但需要进行修改，考虑使用 <code>chown</code> 或 <code>chgrp</code> 更改文件的拥有者或所属组，或者请求管理员为你添加权限。</p></li></ol></blockquote><hr><h2 id="目录的权限"><a href="#目录的权限" class="headerlink" title="目录的权限"></a>目录的权限</h2><p>理解目录权限的三个关键点：</p><ol><li><strong>可读权限（<code>r</code>）</strong>：<strong>决定是否允许我们查看指定目录下的文件内容。</strong> 如果没有读权限，即使目录本身是可执行的，用户也无法看到目录中的文件列表。例如，无法用 <code>ls</code> 查看该目录下的文件。</li><li><strong>可写权限（<code>w</code>）</strong>：<strong>决定是否允许我们在当前目录下进行创建、更改、<code>删除（主要）</code>。</strong> 如果没有写权限，用户就不能在该目录中创建新文件，不能删除文件，也不能重命名文件 &#x3D;&#x3D;（<strong>一个文件能否被删除，并不由文件本身决定，由这个文件所处的目录决定！</strong>）&#x3D;&#x3D;。</li><li><strong>可执行权限（<code>x</code>）</strong>：<strong>决定是否允许用户进入对应的目录！</strong> 如果一个目录没有执行权限，即使你有其他权限，也无法进入该目录进行任何操作。比如无法 <code>cd</code> 进入该目录。</li></ol><h3 id="权限细节及例子-——-想要保护多人-共享-文件数据"><a href="#权限细节及例子-——-想要保护多人-共享-文件数据" class="headerlink" title="权限细节及例子 —— 想要保护多人 共享 文件数据"></a>权限细节及例子 —— 想要保护多人 <code>共享</code> 文件数据</h3><p>假设用户 <strong>张三</strong> 在自己的目录下创建了一个文件 <code>temp</code>，并且给自己设置了文件权限（例如 <code>rw-r--r--</code>）。这意味着张三可以读写文件，而其他用户只能读取文件。看起来应该是其他用户不能删除 <code>temp</code> 文件，对吧？但是，实际上 <strong>其他用户仍然可以删除 <code>temp</code> 文件</strong>，即使他们没有写权限。这是因为文件的删除权限是由 <strong>目录的权限</strong> 决定的，而不是文件的权限。（张三在自己的文件夹里放了一本书（文件 temp），即使没有给其他人修改这本书的权限，如果他们对张三存放书的那个房间（目录）有写入权限，他们仍然能够把张三的书从房间里移除或删除。这看起来不太公平，因为张三并没有允许别人动他的东西）。</p><p>如果去掉了共享目录的 <code>w</code> 权限，张三同时也无法创建文件啦！共享目录，共享体现在哪里呢？</p><h3 id="解决方案：引入“粘滞位”"><a href="#解决方案：引入“粘滞位”" class="headerlink" title="解决方案：引入“粘滞位”"></a>解决方案：引入“粘滞位”</h3><p>为了避免一个用户删除其他用户创建的文件，Linux 引入了 <strong>粘滞位（sticky bit）</strong> 的概念。</p><p><strong>粘滞位（Sticky Bit）</strong> 是一个特殊的权限，用来限制在目录中删除文件的权限。具体来说，只有以下三类用户才能删除目录中的文件：</p><ol><li><strong>超级管理员（root）</strong>：<code>root</code> 用户可以删除任何文件，不受限制。</li><li><strong>目录的所有者</strong>：目录的拥有者可以删除该目录中的文件。</li><li><strong>文件的所有者</strong>：文件的拥有者可以删除自己创建的文件。</li></ol><p><strong>如何设置粘滞位？</strong> 可以使用 <code>chmod +t</code> 命令来给目录设置粘滞位：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> +t /path/to/directory</span><br></pre></td></tr></table></figure><p><strong>示例：</strong> 假设我们有一个目录 <code>/shared</code>，这是一个共享目录，所有用户都可以在其中创建文件。如果没有粘滞位，任何具有写权限的用户都可以删除目录中的文件，即使文件是由其他用户创建的。但如果我们给目录设置了粘滞位：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> +t /shared</span><br><span class="line">drwxrwxrwt    <span class="comment"># 粘滞位生效，末尾为 t</span></span><br></pre></td></tr></table></figure><p>设置了粘滞位后，只有以下三类用户可以删除文件：</p><ul><li><code>root</code> 用户可以删除目录中的任何文件。</li><li>该目录的所有者（例如管理员）可以删除文件。</li><li>文件的拥有者（例如，创建文件的用户）可以删除自己的文件。</li></ul><p>这样，即使其他用户拥有对目录的写权限，也无法删除其他用户创建的文件，增强了安全性。</p><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>目录权限：</strong></p><ol><li><strong>可读权限（<code>r</code>）</strong>：是否可以列出该目录中的文件。没有 <code>r</code> 权限，即使有 <code>x</code> 权限，也无法执行 <code>ls</code> 或查看目录中的内容。</li><li><strong>可写权限（<code>w</code>）</strong>：是否可以在目录中创建、删除或重命名文件。没有 <code>w</code> 权限，用户无法创建、删除或重命名目录中的文件。</li><li><strong>可执行权限（<code>x</code>）</strong>：是否可以进入该目录。没有 <code>x</code> 权限，即使有读权限，也无法 <code>cd</code> 进入目录。</li></ol><p><strong>家目录权限：</strong></p><ul><li>通常情况下，用户的家目录权限是 <code>700</code>，即只有该用户和 <code>root</code> 用户能访问和操作其家目录中的文件。其他用户无法访问、查看或修改这些文件。</li><li>这种权限设置通常用于保护用户的个人文件，使其不被其他用户看到或修改。</li></ul><p><strong>共享目录中的权限管理：</strong></p><ul><li>在共享目录中，其他用户通常有读取、创建和修改文件的权限。但 <strong>为了避免文件被随意删除</strong>，可以设置 <strong>粘滞位</strong>。</li><li>如果去掉共享目录的写权限，用户将无法在目录中创建文件或删除文件。这也意味着，如果一个目录没有写权限，那么所有用户都不能在其中创建或删除文件，目录就无法作为有效的共享目录。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>004 Linux基本指令</title>
      <link href="/posts/9242.html"/>
      <url>/posts/9242.html</url>
      
        <content type="html"><![CDATA[<h2 id="写在最前"><a href="#写在最前" class="headerlink" title="写在最前"></a>写在最前</h2><h3 id="一、Linux-指令的本质与执行逻辑"><a href="#一、Linux-指令的本质与执行逻辑" class="headerlink" title="一、Linux 指令的本质与执行逻辑"></a>一、Linux 指令的本质与执行逻辑</h3><ol><li><p><strong>指令与可执行程序的关系</strong>  </p><ul><li><strong>指令即程序</strong>：用户输入的指令（如 <code>ls</code>、<code>cp</code>）本质是 <strong>可执行程序或脚本</strong>，以文件形式存储在系统路径中（如 <code>/bin</code>、<code>/usr/bin</code>）。</li><li><strong>位置依赖</strong>：指令执行前需在系统预设路径（由 <code>$PATH</code> 环境变量定义）中查找对应文件。若未找到，提示 <code>command not found</code>。</li></ul></li><li><p><strong>指令执行流程</strong>  </p><ul><li><strong>查找与验证</strong>：系统按 <code>$PATH</code> 路径顺序搜索可执行文件，并检查文件权限（需具备可执行权限）。</li><li><strong>执行过程</strong>：找到文件后，操作系统加载程序至内存运行，用户通过命令行解释器间接与内核交互。</li></ul></li></ol><h3 id="二、核心设计哲学：Linux-下一切皆文件"><a href="#二、核心设计哲学：Linux-下一切皆文件" class="headerlink" title="二、核心设计哲学：Linux 下一切皆文件"></a>二、核心设计哲学：Linux 下一切皆文件</h3><ol><li><p><strong>抽象统一性</strong>  </p><ul><li><strong>硬件设备抽象为文件</strong>：<ul><li><strong>显示器</strong>：通过 <code>fwrite</code> 写入数据（如 <code>echo &quot;Hello&quot; &gt; /dev/tty</code>）。</li><li><strong>键盘</strong>：通过 <code>fread</code> 读取输入（如 <code>cat /dev/input/eventX</code>）。</li></ul></li><li><strong>统一操作接口</strong>：无论是硬件设备（如显示器、键盘）还是普通的文件，都可以通过文件操作进行读 <code>read()</code>、写 <code>write()</code> 等系统调用，简化编程与设备管理，更证实了 Linux 下一切皆文件。</li></ul></li><li><p><strong>文件系统层级</strong>  </p><ul><li><strong>普通文件</strong>：文本、二进制等常规数据。</li><li><strong>特殊文件</strong>：设备文件（如 <code>/dev/sda</code>）、管道文件、套接字文件等。</li></ul></li></ol><h3 id="三、用户与操作系统的交互机制"><a href="#三、用户与操作系统的交互机制" class="headerlink" title="三、用户与操作系统的交互机制"></a>三、用户与操作系统的交互机制</h3><ol><li><p><strong>命令行解释器（Shell）的核心作用</strong>  </p><ul><li><strong>功能分层</strong>：<ul><li><strong>命令解析</strong>：将用户输入的字符串解析为可执行操作。</li><li><strong>系统保护</strong>：拦截非法操作（如权限不足的命令、危险系统调用）。</li></ul></li><li><strong>必要性</strong>：直接操作内核复杂度高，Shell 提供安全且易用的交互层。</li></ul></li><li><p><strong>命令行提示符详解</strong>  </p><ul><li>示例：<code>[damai@VM-16-11-centos ~]$</code><ul><li><strong>用户名</strong>：<code>damai</code>（当前登录用户）。</li><li><strong>主机名</strong>：<code>VM-16-11-centos</code>（标识运行环境）。</li><li><strong>当前目录</strong>：<code>~</code>（用户家目录的简写，如 <code>/home/damai</code>）。</li><li><strong>提示符</strong>：<code>$</code> 表示普通用户，<code>#</code> 表示管理员（root）。</li></ul></li></ul></li></ol><h3 id="四、系统管理与高效操作技巧"><a href="#四、系统管理与高效操作技巧" class="headerlink" title="四、系统管理与高效操作技巧"></a>四、系统管理与高效操作技巧</h3><ol><li><p><strong>历史命令管理</strong>  </p><ul><li><strong>记录与搜索</strong>：<ul><li>默认保存最近 1000 条命令（通过 <code>HISTSIZE</code> 变量可调整）。</li><li>快捷键 <code>CTRL + r</code>（支持模糊搜索）快速定位历史命令。</li></ul></li><li><strong>持久化存储</strong>：历史记录保存在 <code>~/.bash_history</code>，便于审计与回溯。</li></ul></li><li><p><strong>环境变量与路径管理</strong>  </p><ul><li><strong>PATH 变量</strong>：定义可执行文件的搜索路径，可通过 <code>export PATH=$PATH:/custom/path</code> 扩展。</li><li><strong>查看路径</strong>：使用 <code>which ls</code> 或 <code>whereis ls</code> 定位指令的存储位置。</li></ul></li><li><p><strong>系统运行模式</strong>  </p><ul><li><strong>常开性设计</strong>：Linux 服务器通常长期运行（不关机），依赖以下特性：<ul><li>高稳定性内核与进程管理。</li><li>日志系统（如 <code>journalctl</code>）与监控工具（如 <code>top</code>）保障运维。</li></ul></li></ul></li></ol><h3 id="五、总结与核心理念"><a href="#五、总结与核心理念" class="headerlink" title="五、总结与核心理念"></a>五、总结与核心理念</h3><ol><li><strong>指令本质</strong>：用户输入字符串 → Shell 解析 → 执行对应可执行文件。</li><li><strong>文件抽象哲学</strong>：硬件、数据、操作均通过文件接口统一管理（<strong>Linux 中的一切皆文件</strong>）。</li><li><strong>用户隔离设计</strong>：Shell 作为安全屏障，防止直接内核操作引发系统风险。</li><li><strong>操作习惯</strong>：<ul><li>善用历史命令提升效率。</li><li>理解环境变量配置优化工作流。</li></ul></li></ol><hr><h2 id="重要的几个热键"><a href="#重要的几个热键" class="headerlink" title="重要的几个热键"></a>重要的几个热键</h2><table><thead><tr><th align="center"><strong>热键</strong></th><th><strong>功能描述</strong></th></tr></thead><tbody><tr><td align="center"><strong>&#x3D;&#x3D;Tab&#x3D;&#x3D;</strong></td><td>&#x3D;&#x3D;自动补全&#x3D;&#x3D; 命令或文件名</td></tr><tr><td align="center"><strong>&#x3D;&#x3D;Ctrl + C&#x3D;&#x3D;</strong></td><td>&#x3D;&#x3D;终止&#x3D;&#x3D; 当前正在运行的命令（中断）</td></tr><tr><td align="center"><strong>&#x3D;&#x3D;Ctrl + D&#x3D;&#x3D;</strong></td><td>&#x3D;&#x3D;退出&#x3D;&#x3D; 当前 shell（相当于 <code>exit</code> 命令）</td></tr><tr><td align="center"><strong>&#x3D;&#x3D;Ctrl + L&#x3D;&#x3D;</strong></td><td>&#x3D;&#x3D;清屏&#x3D;&#x3D;，类似于 <code>clear</code> 命令，但不会清除历史记录</td></tr><tr><td align="center"><strong>Ctrl + Shift + C</strong></td><td>&#x3D;&#x3D;复制&#x3D;&#x3D; 选中的文本</td></tr><tr><td align="center"><strong>Ctrl + Shift + V</strong></td><td>&#x3D;&#x3D;粘贴&#x3D;&#x3D; 剪贴板中的内容</td></tr><tr><td align="center"><strong>Ctrl + A</strong></td><td>移动光标到当前行的开头</td></tr><tr><td align="center"><strong>Ctrl + E</strong></td><td>移动光标到当前行的结尾</td></tr><tr><td align="center"><strong>Ctrl + U</strong></td><td>删除光标到行首的内容</td></tr><tr><td align="center"><strong>Ctrl + K</strong></td><td>删除光标到行尾的内容</td></tr><tr><td align="center"><strong>Ctrl + W</strong></td><td>删除光标前的单词</td></tr><tr><td align="center"><strong>Ctrl + Z</strong></td><td>将当前进程挂起并放入后台</td></tr><tr><td align="center"><strong>Ctrl + Shift + T</strong></td><td>新建一个终端标签页</td></tr><tr><td align="center"><strong>Ctrl + Shift + W</strong></td><td>关闭当前的终端标签页</td></tr></tbody></table><hr><h2 id="Linux-指令"><a href="#Linux-指令" class="headerlink" title="Linux 指令"></a>Linux 指令</h2><h3 id="touch-——-创建文件-修改文件时间戳"><a href="#touch-——-创建文件-修改文件时间戳" class="headerlink" title="touch —— 创建文件&#x2F;修改文件时间戳"></a><code>touch</code> —— 创建文件&#x2F;修改文件时间戳</h3><p><strong>1. 语法：<code>touch [选项] 文件名...</code></strong></p><p><strong>2. 常用选项</strong></p><table><thead><tr><th align="center">选项</th><th>作用</th></tr></thead><tbody><tr><td align="center"><code>-a</code></td><td>仅修改文件的 <strong>访问时间</strong>（Access Time）</td></tr><tr><td align="center"><code>-c</code></td><td><strong>不创建</strong> 新文件（如果文件不存在，则不会创建）</td></tr><tr><td align="center"><code>-d &quot;时间字符串&quot;</code></td><td>以指定时间字符串设置时间戳（支持相对时间）</td></tr><tr><td align="center"><code>-f</code></td><td>兼容性选项，通常无实际作用（可忽略）</td></tr><tr><td align="center"><code>-m</code></td><td>仅修改文件的 <strong>修改时间</strong>（Modify Time）</td></tr><tr><td align="center"><code>-r 参考文件</code></td><td>使用参考文件的时间戳</td></tr><tr><td align="center"><code>-t [[CC]YY]MMDDhhmm[.ss]</code></td><td>以指定格式手动设置时间戳</td></tr></tbody></table><p><strong>3. 使用示例</strong></p><p><strong>① 创建一个新文件</strong>：<code>touch newfile.txt</code>，如果 <code>newfile.txt</code> 不存在，则创建一个空文件；如果已存在，则更新时间戳。</p><p><strong>② 仅修改文件的访问时间</strong>：<code>touch -a file.txt</code>，只更新 <code>file.txt</code> 的访问时间，修改时间不变。</p><p><strong>③ 不创建新文件，仅更新时间</strong>：<code>touch -c file.txt</code>，如果 <code>file.txt</code> 不存在，则不创建新文件。</p><p><strong>④ 使用时间字符串</strong>：<code>touch -d &quot;2025-01-01 00:00:00&quot; file.txt</code>，将 <code>file.txt</code> 的时间戳修改为 <strong>2025 年 01 月 01 日 00:00:00</strong>。</p><p><strong>⑤ 仅修改文件的修改时间</strong>：<code>touch -m file.txt</code>，只更新 <code>file.txt</code> 的修改时间，访问时间不变。</p><p><strong>⑥ 使用参考文件的时间戳</strong>：<code>touch -r reference.txt target.txt</code>，让 <code>target.txt</code> 的时间戳与 <code>reference.txt</code> 相同。</p><p><strong>⑦ 指定时间戳</strong>：<code>touch -t 202501011230.45 file.txt</code>，设置 <code>file.txt</code> 的时间为 <strong>2025 年 01 月 01 日 12:30:45</strong>。</p><p><strong>⑧ 查看文件的时间戳：</strong> <code>stat file.txt</code>。</p><hr><h3 id="man-——-访问-Linux-手册页（重要）"><a href="#man-——-访问-Linux-手册页（重要）" class="headerlink" title="man —— 访问 Linux 手册页（重要）"></a><code>man</code> —— 访问 Linux 手册页（重要）</h3><p><code>man</code> 是用来查看 Linux 命令、程序、配置文件等的手册页的工具。通过它，你可以快速了解命令的用法、选项、示例等详细信息。<strong>在命令行中输入 <code>man man</code> 的作用是显示 <code>man</code> 命令自身的手册页。</strong></p><p><strong>1. 语法：<code>man [选项] 命令</code></strong></p><p><strong>2. 常用选项：</strong></p><table><thead><tr><th align="center"><strong>选项</strong></th><th><strong>解释说明</strong></th><th><strong>示例与说明</strong></th></tr></thead><tbody><tr><td align="center"><code>-k</code></td><td>根据关键词搜索命令或手册内容</td><td><code>man -k copy</code>：搜索所有与“copy”相关的命令，如 <code>cp</code>。</td></tr><tr><td align="center"><code>-f</code></td><td>显示命令的简短描述</td><td><code>man -f ls</code>：显示 <code>ls</code> 命令的简短描述（类似 <code>whatis</code>）。</td></tr><tr><td align="center"><code>-a</code></td><td>打开所有相关的手册页</td><td><code>man -a ls</code>：打开所有与 <code>ls</code> 相关的手册页。</td></tr><tr><td align="center"><code>-s</code></td><td>指定章节号查看手册</td><td><code>man -s 5 passwd</code>：查看 <code>passwd</code> 的第 5 章手册页（文件格式）。</td></tr><tr><td align="center"><code>-c</code></td><td>清除缓存并打开手册页</td><td><code>man -c ls</code>：清除缓存并打开 <code>ls</code> 的手册页。</td></tr></tbody></table><p><strong>3. 查阅命令的不同部分</strong>：手册页通常会分为几个部分，不同章节对应不同类型的命令。常见的部分包括：</p><ul><li><strong>1</strong>：用户命令（User Commands）</li><li><strong>2</strong>：系统调用（System Calls）</li><li><strong>3</strong>：库函数（Library Functions）</li><li><strong>4</strong>：设备（Devices）</li><li><strong>5</strong>：文件格式（File Formats）</li><li><strong>6</strong>：游戏（Games）</li><li><strong>7</strong>：杂项（Miscellaneous）</li><li><strong>8</strong>：系统管理命令（System Administration Commands）</li></ul><p><strong>4. 分页浏览</strong>：手册页通常是通过分页器（如 <code>less</code>）显示的，浏览时不能使用鼠标滚轮，&#x3D;&#x3D;<strong>推荐直接使用方向键</strong>&#x3D;&#x3D;，以下是一些常用的分页操作：</p><table><thead><tr><th><strong>操作</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>空格键</strong></td><td>向下滚动一页。</td></tr><tr><td><strong>B</strong></td><td>向上滚动一页。</td></tr><tr><td><strong>Enter</strong></td><td>向下滚动一行。</td></tr><tr><td><strong>&#x2F;关键词</strong></td><td>搜索关键词。在 <code>man</code> 命令的输出中，按 <code>/</code> 键进入搜索模式，查找手册页中的特定内容。例如：按下 <code>/</code> 键后输入 <code>-l</code>，搜索 <code>ls</code> 手册页中的 <code>-l</code>。</td></tr><tr><td><strong>N</strong></td><td>查找下一个匹配的关键词。</td></tr><tr><td><strong><code>Q</code></strong></td><td>退出手册页。</td></tr></tbody></table><hr><h3 id="cp-——-复制文件或目录（重要）"><a href="#cp-——-复制文件或目录（重要）" class="headerlink" title="cp —— 复制文件或目录（重要）"></a><code>cp</code> —— 复制文件或目录（重要）</h3><p><code>cp</code> 是 Linux 系统中用来复制文件或目录的命令。它可以复制单个文件、多个文件以及整个目录，并且支持多种选项来定制复制行为。<strong>说明: 如同时指定两个以上的文件或目录，且最后的目的地是一个已经存在的目录，则它会把前面指定的所有文件或目录复制到此目录中。若同时指定多个文件或目录，而最后的目的地并非一个已存在的目录，则会出现错误信息。</strong></p><p><strong>1. 语法：<code>cp [选项] 源文件 目标文件</code></strong></p><p><strong>2. 常用选项：</strong></p><table><thead><tr><th><strong>选项</strong></th><th><strong>解释说明</strong></th><th><strong>示例与说明</strong></th></tr></thead><tbody><tr><td><code>-r</code> 或 <code>-R</code> 或 <code>--recursive</code></td><td>递归复制目录及其内容（适用于目录）</td><td><code>cp -r /source/dir /dest/dir</code>：复制整个目录及其内容到目标目录。<code>-r</code> 和 <code>-R</code> 都是递归选项，用来复制目录及其内容。它们的功能是完全相同的，因此你可以根据自己的喜好选择使用大写或小写。</td></tr><tr><td><code>-f</code> 或 <code>--force</code></td><td>&#x3D;&#x3D;强制复制&#x3D;&#x3D;，覆盖目标文件时不询问</td><td><code>cp -f file1 file2</code>：如果目标文件已存在，则直接覆盖，不询问。</td></tr><tr><td><code>-i</code> 或 <code>--interactive</code></td><td>覆盖文件之前 &#x3D;&#x3D;提示&#x3D;&#x3D; 用户确认</td><td><code>cp -i file1 file2</code>：如果 <code>file2</code> 已存在，系统会提示是否覆盖。</td></tr><tr><td><code>-v</code> 或 <code>--verbose</code></td><td>显示详细的输出，列出每个复制的文件</td><td><code>cp -v file1 file2</code>：复制时显示文件复制过程。</td></tr><tr><td><code>-p</code> 或 <code>--preserve</code></td><td>保持文件的属性（如修改时间、权限等）</td><td><code>cp -p file1 file2</code>：复制时保留文件的时间戳和权限。</td></tr></tbody></table><p><strong>3. 示例：</strong></p><ul><li><strong>复制文件：<code>cp file1.txt file2.txt</code></strong>，这个命令将 <code>file1.txt</code> 复制到 <code>file2.txt</code>，如果 <code>file2.txt</code> 已存在，它会被覆盖。</li><li><strong>复制目录：<code>cp -r /home/user/dir /home/user/backup/</code></strong>，这个命令将目录 <code>/home/user/dir</code> 及其所有内容递归地复制到 <code>/home/user/backup/</code> 目录下。</li><li><strong>递归复制并显示详细输出：<code>cp -rv /home/user/dir /home/user/backup/</code></strong>，这个命令会递归地复制目录，并显示每个文件和目录的复制过程。</li><li><strong>复制文件，覆盖前询问确认：<code>cp -i file1.txt file2.txt</code></strong>，如果 <code>file2.txt</code> 已存在，<code>-i</code> 选项会提示你是否覆盖该文件。</li></ul><p><strong>4. 其他说明：</strong> <code>cp</code> 命令支持多种组合选项，可以根据需要灵活使用，结合不同选项可以实现很多高级操作。它是一个非常常见且实用的命令，几乎在所有 Linux 系统中都可以找到它。</p><hr><h3 id="mv-——-移动或重命名文件和目录（重要）"><a href="#mv-——-移动或重命名文件和目录（重要）" class="headerlink" title="mv —— 移动或重命名文件和目录（重要）"></a><code>mv</code> —— 移动或重命名文件和目录（重要）</h3><p><code>mv</code> 是 Linux 中用来移动文件或目录的命令，也可以用来重命名文件或目录。它非常常用，通常用于将文件从一个位置移动到另一个位置，或者给文件和目录重新命名。</p><p><strong>1. 语法：<code>mv [选项] 源文件/目录 目标文件/目录</code></strong></p><ul><li><strong>移动文件</strong>：将源文件移动到目标位置。</li><li><strong>重命名文件</strong>：将源文件重命名为目标文件。</li><li><strong>移动目录</strong>：将源目录及其内容移动到目标位置。</li></ul><p><strong>2. 常用选项：</strong></p><table><thead><tr><th><strong>选项</strong></th><th><strong>解释说明</strong></th><th><strong>示例与说明</strong></th></tr></thead><tbody><tr><td><code>-i</code> 或 <code>--interactive</code></td><td>在覆盖文件之前询问用户确认</td><td><code>mv -i file1.txt file2.txt</code>：如果 <code>file2.txt</code> 已存在，系统会询问是否覆盖。</td></tr><tr><td><code>-f</code> 或 <code>--force</code></td><td>强制执行，不询问用户直接覆盖文件</td><td><code>mv -f file1.txt file2.txt</code>：如果目标文件已存在，则直接覆盖。</td></tr><tr><td><code>-u</code> 或 <code>--update</code></td><td>仅在源文件比目标文件新时才进行移动或重命名</td><td><code>mv -u file1.txt file2.txt</code>：如果 <code>file1.txt</code> 比 <code>file2.txt</code> 新，则移动。</td></tr><tr><td><code>-v</code> 或 <code>--verbose</code></td><td>显示详细的输出，列出每个移动或重命名的文件操作</td><td><code>mv -v file1.txt /home/user/backup/</code>：移动文件并显示操作过程。</td></tr><tr><td><code>-n</code> 或 <code>--no-clobber</code></td><td>不覆盖已存在的目标文件，若目标文件已存在则不进行操作</td><td><code>mv -n file1.txt file2.txt</code>：如果 <code>file2.txt</code> 已存在，不会覆盖。</td></tr><tr><td><code>-b</code> 或 <code>--backup</code></td><td>在覆盖文件之前，先备份目标文件（备份文件名后缀为 <code>~</code>）</td><td><code>mv -b file1.txt file2.txt</code>：覆盖时会保留 <code>file2.txt~</code> 作为备份文件。</td></tr></tbody></table><p><strong>3. 重要说明：</strong></p><ul><li><code>mv</code> 可以用来重命名文件和目录，因此可以简单地通过给目标文件&#x2F;目录提供新名称来完成重命名操作（<strong>重命名</strong>：当第二个参数是文件时，<code>mv</code> 会将源文件重命名为目标文件名。<strong>移动文件或目录</strong>：当第二个参数是已存在的目录时，<code>mv</code> 会将源文件或目录移动到该目录中）。</li><li>如果目标位置已经存在一个同名文件或目录，默认情况下，<code>mv</code> 会覆盖它。</li><li><code>mv</code> 操作的结果是原文件或目录会从原位置移除，而不会再保留一份副本。</li><li><code>-i</code> 选项非常有用，它在移动或重命名时会提示你确认是否覆盖已有文件，防止误操作。</li><li><code>-f</code> 是强制选项，它会直接覆盖文件或目录，避免询问确认。</li></ul><p><code>mv</code> 是一个非常强大且灵活的命令，适用于文件和目录的移动、重命名等常见操作，尤其在文件管理、备份和文件系统操作中常用。</p><hr><h3 id="cat-——-查看目标文件的内容（不适合看大文本，适合看小文本）"><a href="#cat-——-查看目标文件的内容（不适合看大文本，适合看小文本）" class="headerlink" title="cat —— 查看目标文件的内容（不适合看大文本，适合看小文本）"></a><code>cat</code> —— 查看目标文件的内容（不适合看大文本，适合看小文本）</h3><p><strong>1. 语法：<code>cat [选项] [文件]...</code></strong></p><p><strong>2. 常用选项：</strong></p><table><thead><tr><th><strong>选项</strong></th><th><strong>解释说明</strong></th><th><strong>示例与说明</strong></th></tr></thead><tbody><tr><td><code>-n</code> 或 <code>--number</code></td><td>给每一行加上行号</td><td><code>cat -n file.txt</code>：为 <code>file.txt</code> 的每行添加行号后输出。</td></tr><tr><td><code>-b</code> 或 <code>--number-nonblank</code></td><td>只给非空行加上行号</td><td><code>cat -b file.txt</code>：只为 <code>file.txt</code> 的非空行添加行号后输出。</td></tr><tr><td><code>-s</code> 或 <code>--squeeze-blank</code></td><td>压缩连续的空行成一行</td><td><code>cat -s file.txt</code>：如果 <code>file.txt</code> 中有连续的空行，则将其压缩成一行。</td></tr><tr><td><code>-E</code> 或 <code>--show-ends</code></td><td>在每行结尾显示 <code>$</code> 字符</td><td><code>cat -E file.txt</code>：在 <code>file.txt</code> 每一行末尾加上 <code>$</code> 后输出。</td></tr></tbody></table><p><strong>3. 重要说明：</strong></p><ul><li><code>cat</code> 最常见的用途是显示文件内容，例如 <code>cat file.txt</code> 会将 <code>file.txt</code> 的内容输出到终端。</li><li>它也可以用于一次性查看多个文件的内容，例如 <code>cat file1.txt file2.txt</code> 会依次显示这两个文件的内容。</li><li><strong>输入重定向</strong>：<code>cat</code> 还能用于创建文件，如 <code>cat &gt; newfile.txt</code> 然后输入内容，按 <code>Ctrl+D</code> 结束输入并保存；<code>cat &lt; temp.txt</code> <strong>默认行为</strong>：<code>cat</code> 从键盘（标准输入）读取内容并显示，使用 <code>&lt;</code>，<code>cat</code> <strong>从指定的文件读取内容</strong>，而不是从键盘。</li><li>当使用 <code>cat</code> 连接文件时，比如 <code>cat file1.txt file2.txt &gt; combined.txt</code>，它会将两个文件的内容合并到一个新的文件中。</li><li><code>cat</code> 可以通过组合选项来执行更多功能，比如显示行号、显示制表符、查看不可打印字符等，这对于调试文件、查看格式化问题等非常有用。</li><li><code>cat</code> 通常用来快速查看文件的内容，适合小文件。如果文件内容较长，使用 <code>cat</code> 可能会导致终端滚动过快，难以阅读，此时可以考虑使用 <code>less</code> 或 <code>more</code> 命令。</li></ul><hr><h3 id="echo-——-输出文本或变量的值"><a href="#echo-——-输出文本或变量的值" class="headerlink" title="echo —— 输出文本或变量的值"></a><code>echo</code> —— 输出文本或变量的值</h3><p><code>echo</code> 用于在终端中输出文本或变量的值。它常用于脚本中打印调试信息、向用户显示提示信息，或将输出写入文件。</p><p><strong>1. 语法：<code>echo [选项] [文本]</code></strong></p><p><strong>2. 常用选项：</strong></p><table><thead><tr><th><strong>选项</strong></th><th><strong>解释说明</strong></th><th><strong>示例与说明</strong></th></tr></thead><tbody><tr><td><code>-n</code></td><td>不在输出的末尾添加换行符</td><td><code>echo -n &quot;Hello&quot;</code>：输出 <code>Hello</code>，但不换行。</td></tr><tr><td><code>-e</code></td><td>启用转义字符解析（如 <code>\n</code>、<code>\t</code> 等）</td><td><code>echo -e &quot;Line1\nLine2&quot;</code>：输出两行 <code>Line1</code> 和 <code>Line2</code>，用换行符分隔。</td></tr><tr><td><code>-E</code></td><td>禁用转义字符解析（这是默认行为）</td><td><code>echo -E &quot;Line1\nLine2&quot;</code>：输出 <code>Line1\nLine2</code>，不会换行。</td></tr><tr><td><code>--help</code></td><td>显示 <code>echo</code> 命令的帮助信息</td><td><code>echo --help</code>：显示 <code>echo</code> 命令的帮助文档。</td></tr><tr><td><code>--version</code></td><td>显示 <code>echo</code> 命令的版本信息</td><td><code>echo --version</code>：显示 <code>echo</code> 命令的版本信息。</td></tr></tbody></table><p><strong>3. 常见用法：</strong></p><ul><li><strong>输出文本</strong>：<code>echo &quot;Hello, World!&quot;</code>：输出 <code>Hello, World!</code>。</li><li><strong>显示变量的值</strong>：<code>name=&quot;Alice&quot;; echo $name</code>：输出变量 <code>name</code> 的值，结果为 <code>Alice</code>。</li><li><strong>输出带换行符的文本</strong>：<code>echo &quot;Hello\nWorld&quot;</code>：输出 <code>Hello</code> 和 <code>World</code>，并换行。若使用 <code>-e</code> 选项才能正确解析换行符。</li><li><strong>不换行输出</strong>：<code>echo -n &quot;Hello&quot;</code>：输出 <code>Hello</code>，但不自动换行。</li><li><strong>启用转义字符解析</strong>：<code>echo -e &quot;Hello\tWorld&quot;</code>：输出 <code>Hello</code> 和 <code>World</code>，并在它们之间加入一个制表符（tab）。</li><li><strong>重定向输出到文件</strong>：<ul><li><strong>示例</strong>：<code>echo &quot;Hello&quot; &gt; file.txt</code>：将 <code>Hello</code> 写入 <code>file.txt</code> 文件中。如果文件已存在，则会覆盖它。</li><li><strong>示例</strong>：<code>echo &quot;Hello&quot; &gt;&gt; file.txt</code>：将 <code>Hello</code> 追加到 <code>file.txt</code> 文件末尾。</li></ul></li></ul><p><strong>4. 重要说明：</strong></p><ul><li><code>echo</code> 默认会在输出内容的末尾添加换行符。如果不需要换行符，可以使用 <code>-n</code> 选项。</li><li>启用转义字符解析时，<code>echo</code> 会识别诸如 <code>\n</code>（换行符）、<code>\t</code>（制表符）、<code>\r</code>（回车符）等特殊字符，需要使用 <code>-e</code> 选项才能生效。</li><li>如果你需要在脚本或命令行中快速查看某个变量的值，<code>echo</code> 是一个非常方便的工具。</li></ul><hr><h3 id="more-——-分页显示文件内容（功能类似-cat-适用于查看较长的文件）"><a href="#more-——-分页显示文件内容（功能类似-cat-适用于查看较长的文件）" class="headerlink" title="more —— 分页显示文件内容（功能类似 cat 适用于查看较长的文件）"></a><code>more</code> —— 分页显示文件内容（功能类似 <code>cat</code> 适用于查看较长的文件）</h3><p><code>more</code> 是 Linux 中用来分页显示文本文件内容的命令，通常用于查看较长的文件，逐页显示文件内容，直到文件结束。当文件内容过长时，<code>more</code> 会将内容分成一页一页地显示，你可以通过键盘命令逐页查看文件内容。</p><p><strong>1. 语法：<code>more [选项] 文件</code></strong></p><p><strong>2. 常用选项：</strong></p><table><thead><tr><th><strong>选项</strong></th><th><strong>解释说明</strong></th><th><strong>示例与说明</strong></th></tr></thead><tbody><tr><td><code>-n</code></td><td>设置每页显示的行数</td><td><code>more -5 file.txt</code>：每页显示 5 行，文件内容逐页显示。</td></tr><tr><td><code>+NUM</code></td><td>从文件的第 <code>NUM</code> 行开始显示</td><td><code>more +10 file.txt</code>：从第 10 行开始显示文件内容。</td></tr><tr><td><code>-c</code></td><td>清屏显示（每次显示内容前先清屏）</td><td><code>more -c file.txt</code>：显示文件内容时，每一页都会先清屏。</td></tr><tr><td><code>-s</code></td><td>压缩连续的空白行，显示为一行</td><td><code>more -s file.txt</code>：显示文件时连续的空行会被压缩成一行。</td></tr><tr><td><code>-d</code></td><td>在文件结束时显示 <code>--More--(next)</code> 提示符（可以使用 <code>q</code> 退出）</td><td><code>more -d file.txt</code>：结束时显示提示符，用户可以按 <code>q</code> 退出。</td></tr><tr><td><code>-p</code></td><td>在显示内容时，保持当前页面的显示，不使用滚动条</td><td><code>more -p file.txt</code>：显示文件时，每页会直接覆盖，不滚动。</td></tr></tbody></table><p><strong>3. 分页浏览操作：</strong> <code>more</code> 通过分页器显示文件内容，<strong>推荐使用方向键</strong>，也可以使用以下键进行浏览：</p><table><thead><tr><th align="center"><strong>操作</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td align="center"><strong>空格键</strong></td><td>向下翻一页</td></tr><tr><td align="center"><strong>Enter</strong></td><td>向下滚动一行</td></tr><tr><td align="center"><strong>B</strong></td><td>向上翻一页</td></tr><tr><td align="center"><strong>&#x2F;关键词</strong></td><td>搜索关键词，在文件内容中查找。</td></tr><tr><td align="center"><strong>N</strong></td><td>查找下一个匹配的关键词</td></tr><tr><td align="center"><strong><code>Q</code></strong></td><td>退出 <code>more</code>，停止文件浏览</td></tr><tr><td align="center"><strong>H</strong></td><td>显示 <code>more</code> 命令的帮助信息</td></tr><tr><td align="center"><strong>D</strong></td><td>向下滚动半页</td></tr><tr><td align="center"><strong>U</strong></td><td>向上滚动半页</td></tr></tbody></table><p><strong>4. 管道用法与分页显示</strong></p><p><code>more</code> 命令不仅限于直接显示文件内容，它还可以与其他命令结合使用，通过管道（pipe）将命令的输出分页显示。管道符号 <code>|</code> 是用来将前一个命令的输出作为输入传递给后一个命令的。这意味着，第一个命令的标准输出（<code>stdout</code>）被“传递”到第二个命令的标准输入（<code>stdin</code>）。例如：</p><ul><li><strong><code>ls -l / | more</code></strong>：<code>ls</code> 命令列出 <code>/</code> 目录下的文件和子目录，<code>-l</code> 选项让 <code>ls</code> 显示文件的详细信息，包括权限、拥有者、大小等。<code>more</code> 命令接收从 <code>ls -l /</code> 命令输出的数据，并分页显示它。因为 <code>/</code> 目录下通常包含很多文件，使用 <code>more</code> 可以让你逐页查看输出。</li><li><strong><code>ps aux | more</code></strong>：分页显示所有当前运行的进程。</li></ul><p><strong>&#x3D;&#x3D;管道（Pipe）概念：&#x3D;&#x3D;</strong></p><p>管道符号 <code>|</code> 用来将前一个命令的输出传递给下一个命令作为输入。也就是说，<code>more</code> 可以接收其他命令的输出并逐页显示，而不是单独显示文件内容。通过管道可以方便地查看大量命令输出的内容。</p><p><strong>&#x3D;&#x3D;为什么使用管道？&#x3D;&#x3D;</strong></p><p><code>ls -l /</code> 的输出可能很长，直接在终端中显示出来可能会很难查看。通过管道将输出传递给 <code>more</code> 命令，可以让你一页一页地查看内容，避免内容溢出屏幕。</p><hr><h3 id="less-——-分页显示文件内容（比-more-更强大）（重要）"><a href="#less-——-分页显示文件内容（比-more-更强大）（重要）" class="headerlink" title="less —— 分页显示文件内容（比 more 更强大）（重要）"></a><code>less</code> —— 分页显示文件内容（比 <code>more</code> 更强大）（重要）</h3><p><code>less</code> 与 <code>more</code> 相似，都是用来分页显示文件内容，但 <code>less</code> 提供了更多的控制和操作选项。与 <code>more</code> 相比：<code>less</code> 提供了更高的灵活性，可以向前和向后翻阅文件内容，同时支持更丰富的搜索功能。与 <code>more</code> 不同：<code>less</code> 会在查看文件时不会一次性加载整个文件，而是按需加载数据，这样更加高效。</p><p><strong>1. 语法： <code>less [选项] 文件</code></strong></p><ul><li><code>less</code> 工具也是对文件或其它输出进行分页显示的工具，应该说是 linux 正统查看文件内容的工具，功能极其强大。</li><li><code>less</code> 的用法比起 <code>more</code> 更加的有弹性。在 <code>more</code> 的时候，我们并没有办法向前面翻， 只能往后面看</li><li>但若使用了 <code>less</code> 时，就可以使用 【<code>pageup</code>】【<code>pagedown</code>】 等按键的功能来往前往后翻看文件，更容易用来查看一个文件的内容！</li><li>除此之外，在 <code>less</code> 里头可以拥有更多的搜索功能，不止可以向下搜，也可以向上搜</li></ul><p><strong>2. 常用选项：</strong></p><table><thead><tr><th align="center"><strong>选项</strong></th><th><strong>解释说明</strong></th><th><strong>示例与说明</strong></th></tr></thead><tbody><tr><td align="center"><code>-i</code></td><td>搜索时忽略大小写</td><td><code>less -i file.txt</code>：在搜索时忽略大小写。</td></tr><tr><td align="center"><code>-N</code></td><td>显示每行的行号</td><td><code>less -N file.txt</code>：显示每行内容时，在行首显示行号。</td></tr><tr><td align="center"><code>/字符串</code></td><td>向下搜索指定的字符串</td><td><code>/error</code>：在文件中向下搜索并定位到包含 “error” 的行。</td></tr><tr><td align="center"><code>?字符串</code></td><td>向上搜索指定的字符串</td><td><code>?warning</code>：在文件中向上搜索并定位到包含 “warning” 的行。</td></tr><tr><td align="center"><code>n</code></td><td>重复上次的向下搜索</td><td><code>n</code>：再次向下查找上次搜索的字符串。</td></tr><tr><td align="center"><code>N</code></td><td>反向重复上次的搜索</td><td><code>N</code>：反向查找上次搜索的字符串。</td></tr><tr><td align="center"><code>q</code></td><td>退出 <code>less</code>，停止文件浏览</td><td><code>q</code>：退出 <code>less</code>，停止文件的浏览。</td></tr></tbody></table><p><strong>3. 分页浏览操作：</strong> 与 <code>more</code> 类似，<code>less</code> 也支持分页显示文件内容，且可以使用更多的翻页和搜索操作。以下是常用的分页浏览操作：</p><table><thead><tr><th align="center"><strong>操作</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td align="center"><strong>空格键</strong></td><td>向下翻一页</td></tr><tr><td align="center"><strong>Enter</strong></td><td>向下滚动一行</td></tr><tr><td align="center"><strong>B</strong></td><td>向上翻一页</td></tr><tr><td align="center"><strong>PageUp</strong></td><td>向上翻一页</td></tr><tr><td align="center"><strong>PageDown</strong></td><td>向下翻一页</td></tr><tr><td align="center"><strong><code>Q</code></strong></td><td>退出 <code>less</code>，停止文件浏览</td></tr><tr><td align="center"><strong>H</strong></td><td>显示 <code>less</code> 命令的帮助信息</td></tr><tr><td align="center"><strong>G</strong></td><td>跳转到文件末尾</td></tr><tr><td align="center"><strong>g</strong></td><td>跳转到文件开头</td></tr><tr><td align="center"><strong>D</strong></td><td>向下滚动半页</td></tr><tr><td align="center"><strong>U</strong></td><td>向上滚动半页</td></tr></tbody></table><p><strong>4. 管道用法与分页显示</strong></p><p>与 <code>more</code> 一样，<code>less</code> 也支持管道操作，可以将其他命令的输出通过管道传递给 <code>less</code> 进行分页显示。例如：</p><ul><li><strong><code>ls -l / | less</code></strong>：通过管道将 <code>ls -l /</code> 的输出传递给 <code>less</code>，实现分页显示 <code>/</code> 目录下的详细文件信息。</li></ul><p>管道符号 <code>|</code> 用来将前一个命令的输出传递给下一个命令作为输入。通过管道，可以方便地查看其他命令的输出，而不必一次性加载全部内容。</p><hr><h3 id="head-——-显示文件的开头内容"><a href="#head-——-显示文件的开头内容" class="headerlink" title="head —— 显示文件的开头内容"></a><code>head</code> —— 显示文件的开头内容</h3><p><code>head</code> 命令用于显示文件的开头部分内容，默认情况下，<code>head</code> 会显示文件的前 10 行。你可以通过 <code>-n</code> 选项来指定显示更多或更少的行。</p><p><strong>1. 语法： <code>head [选项]... [文件]...</code></strong></p><p><strong>2. 常用选项：</strong></p><table><thead><tr><th><strong>选项</strong></th><th><strong>解释说明</strong></th><th><strong>示例与说明</strong></th></tr></thead><tbody><tr><td><code>-n &lt;行数&gt;</code></td><td>指定要显示的行数</td><td><code>head -n 20 file.txt</code>：显示 <code>file.txt</code> 的前 20 行。</td></tr><tr><td><code>-c &lt;字节数&gt;</code></td><td>显示文件的前 <code>&lt;字节数&gt;</code> 个字节</td><td><code>head -c 50 file.txt</code>：显示 <code>file.txt</code> 的前 50 个字节。</td></tr><tr><td><code>-q</code></td><td>不显示文件名（用于多个文件时）</td><td><code>head -n 10 file1.txt file2.txt</code>：默认会显示文件名，<code>-q</code> 选项可以去除文件名。</td></tr></tbody></table><p><strong>3. 示例：</strong></p><ul><li><strong><code>head -n 10 file.txt</code></strong>：显示文件 <code>file.txt</code> 的前 10 行（默认行为）。</li><li><strong><code>head -n 50 file.txt</code></strong>：显示 <code>file.txt</code> 的前 50 行。</li><li><strong><code>head -c 100 file.txt</code></strong>：显示 <code>file.txt</code> 的前 100 字节。</li></ul><h3 id="tail-——-显示文件的尾部内容"><a href="#tail-——-显示文件的尾部内容" class="headerlink" title="tail —— 显示文件的尾部内容"></a><code>tail</code> —— 显示文件的尾部内容</h3><p><code>tail</code> 命令用于显示文件的尾部内容，通常用来查看日志文件的最新内容。默认情况下，<code>tail</code> 会显示文件的最后 10 行。你可以通过 <code>-n</code> 选项来指定显示的行数，使用 <code>-f</code> 选项可以实时查看文件内容的变化（常用于查看实时日志）。</p><p><strong>1. 语法： <code>tail [选项] [文件]</code></strong></p><p><strong>2. 常用选项：</strong></p><table><thead><tr><th><strong>选项</strong></th><th><strong>解释说明</strong></th><th><strong>示例与说明</strong></th></tr></thead><tbody><tr><td><code>-n &lt;行数&gt;</code></td><td>显示文件的最后 <code>&lt;行数&gt;</code> 行内容</td><td><code>tail -n 20 file.txt</code>：显示 <code>file.txt</code> 的最后 20 行。</td></tr><tr><td><code>-f</code></td><td>实时跟踪文件内容的变化，常用于查看日志文件</td><td><code>tail -f file.log</code>：实时显示 <code>file.log</code> 文件的最新内容。</td></tr><tr><td><code>-c &lt;字节数&gt;</code></td><td>显示文件的最后 <code>&lt;字节数&gt;</code> 个字节</td><td><code>tail -c 100 file.txt</code>：显示 <code>file.txt</code> 的最后 100 个字节。</td></tr></tbody></table><p><strong>3. 示例：</strong></p><ul><li><strong><code>tail -n 10 file.txt</code></strong>：显示 <code>file.txt</code> 的最后 10 行（默认行为）。</li><li><strong><code>tail -n 50 file.txt</code></strong>：显示 <code>file.txt</code> 的最后 50 行。</li><li><strong><code>tail -f /var/log/syslog</code></strong>：实时显示 <code>syslog</code> 文件的新内容，适用于查看实时日志。</li><li><strong><code>tail -n 20 file.txt | head -n 10</code></strong>：先显示 <code>file.txt</code> 的最后 20 行，再从中显示前 10 行。</li></ul><h3 id="结合使用-head-和-tail-——-提取文件的指定行"><a href="#结合使用-head-和-tail-——-提取文件的指定行" class="headerlink" title="结合使用 head 和 tail —— 提取文件的指定行"></a>结合使用 <code>head</code> 和 <code>tail</code> —— 提取文件的指定行</h3><p>在某些情况下，我们需要从文件中提取指定行。<code>head</code> 和 <code>tail</code> 结合使用可以很方便地实现这一功能。</p><p><strong>举例：</strong> 假设有一个文件 <code>test</code>，它有 100 行内容，如果我们想要提取第 50 行，可以使用以下方法：</p><h4 id="方法-1：-使用临时文件"><a href="#方法-1：-使用临时文件" class="headerlink" title="方法 1： 使用临时文件"></a>方法 1： 使用临时文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">head</span> -n 50 <span class="built_in">test</span> &gt; tmp    <span class="comment"># 将前 50 行存入临时文件 tmp</span></span><br><span class="line"><span class="built_in">tail</span> -n 1 tmp            <span class="comment"># 获取临时文件 tmp 的最后一行，即第 50 行</span></span><br></pre></td></tr></table></figure><h4 id="方法-2：使用管道"><a href="#方法-2：使用管道" class="headerlink" title="方法 2：使用管道"></a>方法 2：使用管道</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">head</span> -n 50 <span class="built_in">test</span> | <span class="built_in">tail</span> -n 1    <span class="comment"># 先用 head 提取前 50 行，再用 tail 提取最后一行（即第 50 行）</span></span><br></pre></td></tr></table></figure><p>这种方法可以灵活提取文件中间的指定行，通过 <code>head</code> 和 <code>tail</code> 的组合，方便地提取任何位置的内容。</p><hr><h3 id="时间相关的指令"><a href="#时间相关的指令" class="headerlink" title="时间相关的指令"></a>时间相关的指令</h3><p>在 Linux 中，时间相关的操作可以通过 <code>date</code> 命令进行。<code>date</code> 命令用于显示和设置系统的日期和时间，同时它也支持转换时间戳，格式化输出等功能。</p><h3 id="date-——-显示和设置日期与时间"><a href="#date-——-显示和设置日期与时间" class="headerlink" title="date —— 显示和设置日期与时间"></a><code>date</code> —— 显示和设置日期与时间</h3><p><code>date</code> 命令用于显示当前的日期和时间，或者设置系统的时间。</p><p><strong>1. 显示当前时间：</strong> <code>date</code> 可以按照指定的格式显示当前的日期和时间。语法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">date</span> [OPTION]... [+FORMAT]</span><br></pre></td></tr></table></figure><ul><li><code>+FORMAT</code> 可以自定义显示的时间格式，格式由一系列标记组成，常见的标记有：</li></ul><table><thead><tr><th><strong>标记</strong></th><th><strong>含义</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td><code>%H</code></td><td>小时（00..23）</td><td><code>date +%H</code> → <code>14</code></td></tr><tr><td><code>%M</code></td><td>分钟（00..59）</td><td><code>date +%M</code> → <code>30</code></td></tr><tr><td><code>%S</code></td><td>秒（00..61）</td><td><code>date +%S</code> → <code>15</code></td></tr><tr><td><code>%X</code></td><td>相当于 <code>%H:%M:%S</code></td><td><code>date +%X</code> → <code>14:30:15</code></td></tr><tr><td><code>%d</code></td><td>日（01..31）</td><td><code>date +%d</code> → <code>23</code></td></tr><tr><td><code>%m</code></td><td>月份（01..12）</td><td><code>date +%m</code> → <code>02</code></td></tr><tr><td><code>%Y</code></td><td>完整年份（0000..9999）</td><td><code>date +%Y</code> → <code>2025</code></td></tr><tr><td><code>%F</code></td><td>相当于 <code>%Y-%m-%d</code></td><td><code>date +%F</code> → <code>2025-02-23</code>（这样的格式更 &#x3D;&#x3D;<strong>常用</strong>&#x3D;&#x3D;）</td></tr></tbody></table><p><strong>示例：</strong></p><ul><li><strong><code>date +%Y-%m-%d</code>：</strong> 显示当前日期，格式为 <code>年-月-日</code>，如 <code>2025-02-23</code>。</li><li><strong><code>date +%H:%M:%S</code></strong>：显示当前时间，格式为 <code>小时:分钟:秒</code>，如 <code>14:30:15</code>。</li><li><strong><code>date +%F</code></strong>：显示当前日期，格式为 <code>年-月-日</code>，如 <code>2025-02-23</code>。</li></ul><p><strong>2. 设置时间：</strong></p><p><code>date</code> 命令也可以用来设置系统的日期和时间。此功能通常需要 root 权限才能执行。</p><p><strong>语法：<code>date -s &quot;YYYY-MM-DD HH:MM:SS&quot;</code></strong></p><p><strong>设置日期和时间：</strong> 可以用 <code>-s</code> 选项设置日期和时间。例如：</p><ul><li><strong><code>date -s &quot;2025-02-23 01:01:01&quot;</code></strong>：将系统时间设置为 <code>2025-02-23 01:01:01</code>。</li><li><strong><code>date -s &quot;01:01:01&quot;</code></strong>：设置具体的时间（日期保持当前系统时间）。</li><li><strong><code>date -s &quot;2025-02-23&quot;</code></strong>：仅设置日期为 <code>2025-02-23</code>，时间默认为 <code>00:00:00</code>。</li><li><strong><code>date -s &quot;01:01:01 2025-02-23&quot;</code></strong>：设置日期和时间为 <code>2025-02-23 01:01:01</code>。</li></ul><p><strong>3. 时间戳相关操作：</strong></p><p><code>date</code> 命令可以方便地在日期和时间与 Unix 时间戳之间进行转换。</p><ul><li><p><strong>日期转换为时间戳：<code>date +%s</code></strong>：这将输出当前时间的 Unix 时间戳，表示从 <code>1970年1月1日 00:00:00 UTC（协调世界时）</code> 到当前时间所经过的秒数。<strong>示例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">date</span> +%s</span><br><span class="line"><span class="comment"># 输出类似: 1738486946</span></span><br></pre></td></tr></table></figure></li><li><p><strong>时间戳转换为日期：</strong> 使用 <code>-d</code> 选项和 <code>@&lt;时间戳&gt;</code>，可以将 Unix 时间戳转换为可读的日期和时间。<code>date -d @1738486946</code>：这将输出 Unix 时间戳 <code>1738486946</code> 对应的日期和时间。<strong>示例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">date</span> -d @1738486946</span><br><span class="line"><span class="comment"># 输出类似: Sun Feb  2 17:02:26 CST 2025</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">date</span> -d @0</span><br><span class="line">Thu Jan  1 08:00:00 CST 1970</span><br><span class="line"><span class="comment"># 这里日期其实应该是1970年1月1日 00:00:00，但是由于CST（中国标准时间）是 UTC +8 时区，所以它比 UTC 时间快 8 小时。</span></span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="cal-——-显示日历"><a href="#cal-——-显示日历" class="headerlink" title="cal —— 显示日历"></a><code>cal</code> —— 显示日历</h3><p><code>cal</code> 命令是 Linux 中用来显示公历（阳历）日历的命令，广泛用于查看某个月或某一年的日历。<code>cal</code> 显示的日历基于公历（格列历），通常用于日常的时间安排或日期查询。</p><p><strong>1. 语法：<code>cal [参数] [月份] [年份]</code></strong></p><ul><li><strong>月份</strong>：指定某个月的日历，1 到 12 的整数，表示月份。</li><li><strong>年份</strong>：指定某一年的日历，1 到 9999 的整数，表示年份。</li></ul><p><strong>2. 常用选项：</strong></p><table><thead><tr><th><strong>选项</strong></th><th><strong>解释说明</strong></th><th><strong>示例与说明</strong></th></tr></thead><tbody><tr><td><code>-3</code></td><td>显示系统前一个月、当前月和下一个月的月历</td><td><code>cal -3</code>：显示当前月及前后一个月的日历。</td></tr><tr><td><code>-j</code></td><td>显示当前日期在当年中的第几天（默认显示当前月在一年中的天数）</td><td><code>cal -j</code>：显示当前月份和当前日期在一年中的第几天。</td></tr><tr><td><code>-y</code></td><td>显示当前年份的完整日历</td><td><code>cal -y</code>：显示当前年份的完整日历。</td></tr><tr><td><code>-m</code></td><td>显示指定月份的日历（不指定年份默认当前年份）</td><td><code>cal 6</code>：显示当前年份的 6 月份日历。</td></tr><tr><td><code>-A</code></td><td>显示当前月份及其后 <code>A</code> 个月的日历</td><td><code>cal -A 3</code>：显示当前月份及之后 3 个月的日历。</td></tr><tr><td><code>-B</code></td><td>显示当前月份及其前 <code>B</code> 个月的日历</td><td><code>cal -B 2</code>：显示当前月份及之前 2 个月的日历。</td></tr></tbody></table><p><strong>3. 示例：</strong></p><ul><li><p><strong>查看当前月份的日历：<code>cal</code></strong>：默认显示当前月的日历。</p></li><li><p><strong>查看指定月份和年份的日历：<code>cal 12 2025</code></strong>：显示 2025 年 12 月的日历。</p></li><li><p><strong>查看当前年份的完整日历：<code>cal -y</code>：</strong> 显示完整的当前年份的日历。</p></li><li><p><strong>查看当前月、前一个月和下一个月的日历：<code>cal -3</code></strong>：显示当前月、前一个月和下一个月的日历。</p></li><li><p><strong>查看当前日期是今年的第几天：<code>cal -j</code></strong>：显示当前日期是当前年份的第几天。</p></li><li><p>如果你只输入一个数字 <code>cal 12</code>，它会默认显示当前年份的指定月份 <code>12</code> 的日历。</p></li><li><p><code>cal -A</code> 和 <code>cal -B</code> 可以让你一次性查看前后的月份。</p></li></ul><hr><h3 id="指令（通配符）"><a href="#指令（通配符）" class="headerlink" title="* 指令（通配符）"></a><code>*</code> 指令（通配符）</h3><p>在 Linux 中，<code>*</code> 并不是一个命令，而是一个常用的通配符（wildcard），表示匹配任意数量的字符（包括零个字符）。它在文件名扩展（glob）操作中被广泛使用，特别是在命令行中与其他命令一起使用，它可以用于匹配文件或目录的名称，常用于文件查找、复制、删除等操作。</p><p><strong>常见用途：</strong></p><ol><li><p><strong>匹配所有文件</strong>：<code>*</code> 可以用来匹配当前目录下所有的文件和子目录（包括隐藏文件和目录除外）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> *</span><br></pre></td></tr></table></figure></li><li><p><strong>匹配特定类型的文件</strong>：使用 <code>*</code> 来匹配特定类型的文件，例如所有 <code>.txt</code> 文件，该命令会列出当前目录下所有扩展名为 <code>.txt</code> 的文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> *.txt</span><br></pre></td></tr></table></figure></li><li><p><strong>匹配多个字符</strong>：<code>*</code> 可以替代文件名中的任意字符（包括多个字符），比如查找包含特定前缀或后缀的文件，该命令会列出所有以 <code>file</code> 开头的文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> file*</span><br></pre></td></tr></table></figure></li><li><p><strong>与其他命令结合使用</strong>：<code>*</code> 可以与其他命令结合使用来实现批量操作，该命令会删除当前目录下所有扩展名为 <code>.log</code> 的文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> *.<span class="built_in">log</span></span><br></pre></td></tr></table></figure></li></ol><p><strong>注意事项：</strong></p><ul><li><code>*</code> 只匹配非隐藏文件。如果你需要包括隐藏文件，可以使用 <code>.*</code> 或 <code>.* *</code> 来匹配。</li><li><code>*</code> 不匹配目录结构中的分隔符 <code>/</code>，即它不会匹配子目录的名字。</li><li>如果文件名中包含特殊字符（如空格、星号、问号等），你可能需要用引号或转义字符来处理这些字符。</li></ul><hr><h3 id="whereis-指令-——-查找命令的相关文件"><a href="#whereis-指令-——-查找命令的相关文件" class="headerlink" title="whereis 指令 —— 查找命令的相关文件"></a><code>whereis</code> 指令 —— 查找命令的相关文件</h3><p><code>whereis</code> 是 Linux 中用来查找命令的二进制文件、源代码文件和手册页位置的命令。它不会像 <code>which</code> 命令那样仅搜索 <code>PATH</code> 环境变量指定的目录，而是搜索一些常见的系统路径。通常用于快速定位某个命令或程序的安装位置，尤其是二进制文件和相关文档。</p><p><strong>语法：<code>whereis [选项] [命令或文件]</code></strong></p><p><strong>常用选项：</strong></p><table><thead><tr><th align="center"><strong>选项</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td align="center"><code>-b</code></td><td>查找命令的二进制文件（binary files）。</td></tr><tr><td align="center"><code>-m</code></td><td>查找命令的手册页（man pages）。</td></tr><tr><td align="center"><code>-s</code></td><td>查找命令的源代码文件（source files）。</td></tr><tr><td align="center"><code>-u</code></td><td>显示未找到命令的路径。</td></tr></tbody></table><p><strong>基本用法：</strong></p><ol><li><p><strong>查找命令的二进制文件、源代码和手册页：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whereis <span class="built_in">ls</span></span><br></pre></td></tr></table></figure><p>该命令会查找 <code>ls</code> 命令的相关文件，输出类似：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span>: /bin/ls /usr/share/man/man1/ls.1.gz</span><br></pre></td></tr></table></figure><p>这表示 <code>ls</code> 的二进制文件位于 <code>/bin/ls</code>，手册页位于 <code>/usr/share/man/man1/ls.1.gz</code>。</p></li><li><p><strong>仅查找命令的二进制文件：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whereis -b <span class="built_in">ls</span></span><br></pre></td></tr></table></figure><p>该命令只查找 <code>ls</code> 的二进制文件，输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span>: /bin/ls</span><br></pre></td></tr></table></figure></li><li><p><strong>仅查找命令的手册页：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whereis -m <span class="built_in">ls</span></span><br></pre></td></tr></table></figure><p>该命令只查找 <code>ls</code> 的手册页，输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span>: /usr/share/man/man1/ls.1.gz</span><br></pre></td></tr></table></figure></li><li><p><strong>仅查找命令的源代码文件：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whereis -s <span class="built_in">ls</span></span><br></pre></td></tr></table></figure><p>该命令查找 <code>ls</code> 的源代码文件，如果系统中有相关源代码，则会输出相关路径。</p></li><li><p><strong>查找命令或程序是否安装：</strong> 如果你 <strong>不知道某个命令是否安装</strong>，可以用 <code>whereis</code> 检查该命令的位置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whereis xyz</span><br></pre></td></tr></table></figure><p>如果返回为空，说明该命令或文件在系统中未找到。</p></li></ol><p><strong>注意事项：</strong></p><ul><li><code>whereis</code> 搜索的目录是固定的，主要包括系统的标准目录，比如 <code>/bin</code>、<code>/usr/bin</code>、<code>/sbin</code>、<code>/usr/sbin</code> 等，因此它可能不会显示在其他非标准路径上的文件。</li><li>与 <code>which</code> 命令不同，<code>whereis</code> 搜索的范围更广，包含了手册页和源代码等信息。</li></ul><hr><h3 id="find-——-在文件系统中查找文件（非常重要）"><a href="#find-——-在文件系统中查找文件（非常重要）" class="headerlink" title="find —— 在文件系统中查找文件（非常重要）"></a><code>find</code> —— 在文件系统中查找文件（非常重要）</h3><p><code>find</code> 是一个功能强大的 Linux 命令，用于在文件系统中查找文件或目录，并对它们执行指定的操作。由于 Linux 的文件系统通常包含大量文件，<code>find</code> 命令提供了高效的查找功能，并支持多种条件和操作，非常适用于搜索文件、管理文件、批量处理文件等任务。</p><p><strong>1. 语法：<code>find [路径] [选项] [条件] [操作]</code></strong></p><ul><li><strong>路径</strong>：指定查找的目录路径，如果不指定路径，默认为当前目录。</li><li><strong>选项</strong>：用于修改 <code>find</code> 命令的行为。</li><li><strong>条件</strong>：定义查找的条件，例如按文件名、修改时间、文件大小等查找。</li><li><strong>操作</strong>：在查找到符合条件的文件后，执行相应的操作，如显示文件、删除文件、修改文件权限等。</li></ul><p><strong>2. 常用选项和条件：</strong></p><table><thead><tr><th><strong>选项&#x2F;条件</strong></th><th><strong>解释说明</strong></th><th><strong>示例与说明</strong></th></tr></thead><tbody><tr><td><code>-name</code></td><td>按文件名查找文件，支持通配符 <code>*</code>、<code>?</code> 等匹配方式。</td><td><code>find /home -name &quot;*.txt&quot;</code>：在 <code>/home</code> 目录下查找所有 <code>.txt</code> 文件。</td></tr><tr><td><code>-type</code></td><td>按文件类型查找文件，常用类型有 <code>f</code>（普通文件）、<code>d</code>（目录）、<code>l</code>（符号链接）等。</td><td><code>find / -type f</code>：查找系统中所有普通文件。</td></tr><tr><td><code>-size</code></td><td>按文件大小查找文件，支持指定文件大小单位（<code>b</code>、<code>c</code>、<code>k</code>、<code>M</code> 等）。</td><td><code>find /var -size +10M</code>：查找 <code>/var</code> 目录下大于 10MB 的文件。</td></tr><tr><td><code>-mtime</code></td><td>按修改时间查找文件，单位为天数，<code>+</code> 表示大于指定天数，<code>-</code> 表示小于指定天数。</td><td><code>find /tmp -mtime -7</code>：查找最近 7 天内修改过的文件。</td></tr><tr><td><code>-atime</code></td><td>按访问时间查找文件，单位为天数，<code>+</code> 和 <code>-</code> 与 <code>-mtime</code> 类似。</td><td><code>find /home/user -atime +30</code>：查找 30 天前访问过的文件。</td></tr><tr><td><code>-exec</code></td><td>对查找到的文件执行指定的命令，常用于批量处理文件。</td><td><code>find /home -name &quot;*.log&quot; -exec rm -f &#123;&#125; \;</code>：查找并删除所有 <code>.log</code> 文件。</td></tr><tr><td><code>-print</code></td><td>显示查找到的文件，默认情况下会显示。</td><td><code>find /home -name &quot;*.txt&quot; -print</code>：查找 <code>.txt</code> 文件并显示它们。</td></tr><tr><td><code>-maxdepth</code></td><td>限制查找的目录层级，防止遍历过深的目录结构。</td><td><code>find / -maxdepth 2</code>：查找 <code>/</code> 目录下最多 2 层的文件。</td></tr><tr><td><code>-mindepth</code></td><td>限制查找的最小目录层级。</td><td><code>find / -mindepth 2</code>：查找 <code>/</code> 目录下从第二层开始的文件。</td></tr></tbody></table><p><strong>3. 示例：</strong></p><ul><li><p><strong>按文件名查找文件：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /home/user -name <span class="string">&quot;*.txt&quot;</span><span class="comment"># 查找 `/home/user` 目录下所有扩展名为 `.txt` 的文件</span></span><br></pre></td></tr></table></figure></li><li><p><strong>查找特定类型的文件：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -<span class="built_in">type</span> d -name <span class="string">&quot;Documents&quot;</span><span class="comment"># 查找系统中所有名为 `Documents` 的目录</span></span><br></pre></td></tr></table></figure></li><li><p><strong>查找最近 7 天内修改过的文件：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /tmp -mtime -7<span class="comment"># 查找 `/tmp` 目录下最近 7 天内修改过的文件</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /var/log -name <span class="string">&quot;*.log&quot;</span> -mtime +7 -<span class="built_in">exec</span> <span class="built_in">rm</span> &#123;&#125; \;<span class="comment"># 查找并删除7天前的日志文件</span></span><br></pre></td></tr></table></figure></li><li><p><strong>查找并删除文件：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /home/user -name <span class="string">&quot;*.bak&quot;</span> -<span class="built_in">exec</span> <span class="built_in">rm</span> -f &#123;&#125; \;<span class="comment">#查找 `/home/user` 目录下所有扩展名为 `.bak` 的文件，并删除它们</span></span><br></pre></td></tr></table></figure></li><li><p><strong>查找并显示所有文件的大小：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /var -<span class="built_in">type</span> f -<span class="built_in">exec</span> <span class="built_in">du</span> -h &#123;&#125; \;<span class="comment"># 查找 `/var` 目录下所有的普通文件，并显示它们的大小</span></span><br></pre></td></tr></table></figure></li><li><p><strong>查找并显示文件的权限：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -name <span class="string">&quot;*.sh&quot;</span> -<span class="built_in">exec</span> <span class="built_in">ls</span> -l &#123;&#125; \;<span class="comment"># 查找所有 `.sh` 文件，并显示它们的详细权限和属性</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>4. 小技巧：</strong></p><ul><li><p><strong>使用 <code>-prune</code> 跳过某些目录：</strong> 如果你想跳过某些目录，可以使用 <code>-prune</code> 选项。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">find /home -path <span class="string">&quot;/home/user/ignore&quot;</span> -prune -o -name <span class="string">&quot;*.txt&quot;</span> -<span class="built_in">print</span></span><br><span class="line"><span class="comment"># 这个命令会跳过 `/home/user/ignore` 目录，只查找其他 `.txt` 文件</span></span><br></pre></td></tr></table></figure></li><li><p><strong>结合 <code>-exec</code> 使用 <code>&#123;&#125; \;</code> 或 <code>+</code>：</strong> <code>-exec</code> 后面可以跟 <code>&#123;&#125;</code> 来代表当前查找到的文件。</p><ul><li><code>\;</code>：每找到一个文件，执行一次命令。</li><li><code>+</code>：将多个文件作为一次命令的参数传递，效率更高。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">find /home -name <span class="string">&quot;*.txt&quot;</span> -<span class="built_in">exec</span> <span class="built_in">cat</span> &#123;&#125; \;</span><br><span class="line">find /home -name <span class="string">&quot;*.txt&quot;</span> -<span class="built_in">exec</span> <span class="built_in">cat</span> &#123;&#125; +</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="grep-指令-——-搜索文件中的字符串"><a href="#grep-指令-——-搜索文件中的字符串" class="headerlink" title="grep 指令 —— 搜索文件中的字符串"></a><code>grep</code> 指令 —— 搜索文件中的字符串</h3><p><code>grep</code> 是一个强大的文本搜索工具，通过指定的字符串（或模式）来查找文件中的匹配内容，并打印出匹配到的行。它的名字来源于 “global regular expression print”，意味着支持使用正则表达式，根据正则表达式搜索内容并打印匹配的行。</p><p><strong>1. 语法：<code>grep [选项] 搜寻字符串 文件</code></strong></p><ul><li><strong>选项</strong>：用于修改 <code>grep</code> 的行为。</li><li><strong>搜寻字符串</strong>：指定需要查找的模式或字符串。</li><li><strong>文件</strong>：指定要搜索的文件，支持多个文件。</li></ul><p><strong>2. 常用选项</strong>：</p><table><thead><tr><th><strong>选项</strong></th><th><strong>解释说明</strong></th><th><strong>示例与说明</strong></th></tr></thead><tbody><tr><td><code>-i</code></td><td>忽略大小写，匹配时不区分大小写</td><td><code>grep -i &quot;pattern&quot; file.txt</code>：搜索文件中的 “pattern”，忽略大小写。</td></tr><tr><td><code>-n</code></td><td>显示匹配行的行号</td><td><code>grep -n &quot;pattern&quot; file.txt</code>：输出匹配行和相应的行号。</td></tr><tr><td><code>-v</code></td><td>反向选择，显示不包含匹配字符串的行</td><td><code>grep -v &quot;pattern&quot; file.txt</code>：输出不包含 “pattern” 的行。</td></tr><tr><td><code>-r</code> 或 <code>-R</code></td><td>递归查找目录下的文件，<code>-r</code> 和 <code>-R</code> 功能相同，保留两者仅为兼容性考虑。</td><td><code>grep -r &quot;pattern&quot; dir/</code>：在 <code>dir/</code> 目录及其子目录下查找 “pattern”。</td></tr><tr><td><code>-l</code></td><td>只输出包含匹配字符串的文件名，而不是具体内容</td><td><code>grep -l &quot;pattern&quot; *.txt</code>：列出包含 “pattern” 的所有 <code>.txt</code> 文件。</td></tr><tr><td><code>-w</code></td><td>只匹配整个单词（完全匹配）</td><td><code>grep -w &quot;word&quot; file.txt</code>：只匹配整个 “word”，而不是 “wording”。</td></tr><tr><td><code>-c</code></td><td>显示匹配行的数量</td><td><code>grep -c &quot;pattern&quot; file.txt</code>：显示文件中 “pattern” 出现的次数。</td></tr><tr><td><code>-H</code></td><td>显示匹配内容的文件名（默认启用，仅针对多个文件）</td><td><code>grep -H &quot;pattern&quot; *.txt</code>：显示文件名和匹配内容。</td></tr><tr><td><code>-A NUM</code></td><td>显示匹配行之后的 <code>NUM</code> 行</td><td><code>grep -A 3 &quot;pattern&quot; file.txt</code>：显示匹配行及其后的 3 行内容。</td></tr><tr><td><code>-B NUM</code></td><td>显示匹配行之前的 <code>NUM</code> 行</td><td><code>grep -B 2 &quot;pattern&quot; file.txt</code>：显示匹配行及其前的 2 行内容。</td></tr><tr><td><code>-C NUM</code></td><td>显示匹配行前后的 <code>NUM</code> 行</td><td><code>grep -C 3 &quot;pattern&quot; file.txt</code>：显示匹配行及其前后的 3 行内容。</td></tr></tbody></table><p><strong>3. 使用示例</strong>：</p><ol><li><p><strong>忽略大小写查找</strong>：在 <code>file.txt</code> 文件中查找 “hello”（忽略大小写），无论是 “Hello”、”HELLO” 还是 “hElLo” 都会匹配：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -i <span class="string">&quot;hello&quot;</span> file.txt</span><br></pre></td></tr></table></figure></li><li><p><strong>显示行号</strong>：查找 <code>file.txt</code> 中的 “pattern”，并输出匹配行的行号：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -n <span class="string">&quot;pattern&quot;</span> file.txt</span><br></pre></td></tr></table></figure></li><li><p><strong>反向选择（显示不匹配的行）</strong>：显示 <code>file.txt</code> 中不包含 “pattern” 的所有行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -v <span class="string">&quot;pattern&quot;</span> file.txt</span><br></pre></td></tr></table></figure></li><li><p><strong>递归查找目录中的文件</strong>：在指定的目录及其子目录下递归查找包含 “pattern” 的文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -r <span class="string">&quot;pattern&quot;</span> /path/to/directory/</span><br></pre></td></tr></table></figure></li><li><p><strong>只显示匹配行的文件名</strong>：列出当前目录下所有包含 “pattern” 的 <code>.txt</code> 文件，不显示具体的匹配内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -l <span class="string">&quot;pattern&quot;</span> *.txt</span><br></pre></td></tr></table></figure></li><li><p><strong>显示匹配行及其上下文</strong>：在 <code>file.txt</code> 中查找 “pattern”，并显示匹配行及其后面 2 行的内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -A 2 <span class="string">&quot;pattern&quot;</span> file.txt</span><br></pre></td></tr></table></figure></li></ol><hr><h3 id="zip-unzip-指令-——-压缩和解压缩文件"><a href="#zip-unzip-指令-——-压缩和解压缩文件" class="headerlink" title="zip &#x2F; unzip 指令 —— 压缩和解压缩文件"></a><code>zip</code> &#x2F; <code>unzip</code> 指令 —— 压缩和解压缩文件</h3><p>Linux 中压缩文件的格式非常多，需要时查找对应的资料即可。虽然有多种压缩格式，但 <code>.zip</code> 格式却是最常用的之一，它广泛用于存储和传输多个文件和目录。<code>zip</code> 和 <code>unzip</code> 是 Linux 系统中用于压缩和解压缩 <code>.zip</code> 格式文件的常用工具，<code>.zip</code> 常用主要原因如下：</p><ul><li><strong>广泛兼容</strong>：<code>.zip</code> 格式几乎可以在所有操作系统（Windows、Linux、macOS）中轻松打开和创建，因此跨平台兼容性非常强。</li><li><strong>简便易用</strong>：使用 <code>zip</code> 和 <code>unzip</code> 命令在 Linux 中非常简单，且支持压缩多个文件和目录。</li><li><strong>易于理解</strong>：<code>.zip</code> 格式的操作相对直观，且不需要额外的工具或插件，特别适合日常使用。</li></ul><table><thead><tr><th>多种压缩格式</th><th>说明</th><th>常用工具</th><th>备注</th></tr></thead><tbody><tr><td><code>.zip</code></td><td>最常用的压缩格式，广泛兼容于不同操作系统</td><td><code>zip</code>, <code>unzip</code></td><td>适合日常使用，跨平台支持好</td></tr><tr><td><code>.tar</code></td><td>归档格式，不进行压缩，常与其他压缩工具结合</td><td><code>tar</code></td><td>常与 <code>gzip</code> 或 <code>bzip2</code> 一起使用</td></tr><tr><td><code>.gz</code></td><td><code>gzip</code> 压缩格式，通常与 <code>.tar</code> 配合使用</td><td><code>gzip</code>, <code>gunzip</code></td><td>适合单个文件压缩</td></tr><tr><td><code>.bz2</code></td><td><code>bzip2</code> 压缩格式，比 <code>gzip</code> 压缩率更高</td><td><code>bzip2</code>, <code>bunzip2</code></td><td>常与 <code>tar</code> 一起使用</td></tr><tr><td><code>.xz</code></td><td><code>xz</code> 压缩格式，压缩率非常高</td><td><code>xz</code>, <code>unxz</code></td><td>适用于大文件压缩，压缩率高</td></tr><tr><td><code>.7z</code></td><td><code>7zip</code> 压缩格式，压缩比非常高</td><td><code>7zip</code></td><td>常用于 Windows 和 Linux 之间交换文件</td></tr><tr><td><code>.rar</code></td><td><code>RAR</code> 压缩格式，通常需要额外工具来解压</td><td><code>rar</code>, <code>unrar</code></td><td>常用于 Windows 环境</td></tr><tr><td><code>.tar.Z</code></td><td>旧的 <code>compress</code> 工具格式，逐渐被替代</td><td><code>compress</code>, <code>uncompress</code></td><td>已被 <code>gzip</code> 和 <code>bzip2</code> 替代</td></tr></tbody></table><p><strong>对于其他压缩格式的使用：</strong></p><ul><li><strong><code>.tar.gz</code> &#x2F; <code>.tar.bz2</code> &#x2F; <code>.tar.xz</code></strong>：这些格式在 Linux 环境下非常流行，尤其在打包和备份数据时。如果你不熟悉这些格式，查阅相关文档即可。</li><li><strong><code>.7z</code></strong>：虽然这个格式在 Linux 上也支持，但它主要用于高压缩率需求的场景，或者作为 Windows 环境中的常用格式。</li><li><strong><code>.rar</code></strong>：对于 <code>.rar</code> 文件，Linux 默认没有支持解压的工具，但可以通过安装 <code>unrar</code> 工具来支持。</li></ul><p><strong>&#x3D;&#x3D;在 Linux 上，某些解压工具默认可能没有安装，你可以百度一下安装命令进行安装，注意：根据不同的 Linux 发行版，使用的包管理器不同！&#x3D;&#x3D;</strong></p><p><strong>1. <code>zip</code> 指令 —— 压缩文件</strong>，用于将文件或目录压缩成 <code>.zip</code> 格式。</p><p><strong>语法：<code>zip [选项] 压缩文件.zip 文件或目录</code></strong></p><ul><li><strong>选项</strong>：用于指定压缩时的行为。</li><li><strong>压缩文件.zip</strong>：指定压缩后的文件名。</li><li><strong>文件或目录</strong>：指定要压缩的文件或目录，可以是多个文件或目录。</li></ul><p><strong>常用选项</strong>：</p><table><thead><tr><th><strong>选项</strong></th><th><strong>解释说明</strong></th><th><strong>示例与说明</strong></th></tr></thead><tbody><tr><td><code>-r</code></td><td><strong>支持递归</strong> 处理目录，包含子目录及其中的文件</td><td><code>zip -r archive.zip folder/</code>：压缩 <code>folder</code> 目录及其所有文件和子目录。</td></tr><tr><td><code>-e</code></td><td>在压缩时加密，要求输入密码</td><td><code>zip -e archive.zip file.txt</code>：压缩文件并加密，需要输入密码。</td></tr><tr><td><code>-q</code></td><td>静默模式，不输出任何压缩过程信息</td><td><code>zip -q archive.zip file1.txt file2.txt</code>：压缩文件，不显示进度信息。</td></tr><tr><td><code>-x</code></td><td>排除某些文件或目录</td><td><code>zip -r archive.zip folder/ -x &quot;*.bak&quot;</code>：压缩 <code>folder</code> 目录，但排除 <code>.bak</code> 文件。</td></tr><tr><td><code>-9</code></td><td>使用最佳压缩级别（最慢但最小文件）</td><td><code>zip -9 archive.zip folder/</code>：使用最强压缩来压缩 <code>folder</code> 目录。</td></tr><tr><td><code>-j</code></td><td>不保存文件的路径信息，只保存文件本身</td><td><code>zip -j archive.zip file1.txt file2.txt</code>：只压缩文件，不保存目录结构。</td></tr></tbody></table><p><strong>示例</strong>：</p><ol><li><p><strong>压缩文件</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zip archive.zip file1.txt file2.txt<span class="comment"># 将 `file1.txt` 和 `file2.txt` 压缩成 `archive.zip` 文件</span></span><br></pre></td></tr></table></figure></li><li><p><strong>递归压缩目录</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zip -r archive.zip folder/<span class="comment"># 将 `folder/` 目录及其中的所有文件和子目录压缩为 `archive.zip` 文件</span></span><br></pre></td></tr></table></figure></li><li><p><strong>排除文件</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zip -r archive.zip folder/ -x <span class="string">&quot;*.bak&quot;</span><span class="comment"># 压缩 `folder/` 目录，但排除所有 `.bak` 文件</span></span><br></pre></td></tr></table></figure></li><li><p><strong>使用加密</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zip -e archive.zip file1.txt<span class="comment"># 压缩 `file1.txt` 并加密，要求输入密码</span></span><br></pre></td></tr></table></figure></li></ol><p><strong>2. <code>unzip</code> 指令 —— 解压缩文件</strong>，用于解压 <code>.zip</code> 格式的压缩文件。</p><p><strong>语法：<code>unzip [选项] 压缩文件.zip</code></strong></p><ul><li><strong>选项</strong>：用于指定解压缩时的行为。</li><li><strong>压缩文件.zip</strong>：&#x3D;&#x3D;指定&#x3D;&#x3D; 要解压的 <code>.zip</code> 文件。</li></ul><p><strong>常用选项</strong>：</p><table><thead><tr><th><strong>选项</strong></th><th><strong>解释说明</strong></th><th><strong>示例与说明</strong></th></tr></thead><tbody><tr><td><code>-d</code></td><td>指定解压的目标目录</td><td><code>unzip archive.zip -d /path/to/destination/</code>：将文件解压到指定目录。</td></tr><tr><td><code>-l</code></td><td>列出 <code>.zip</code> 文件中的文件内容，而不解压</td><td><code>unzip -l archive.zip</code>：列出压缩包中的文件，不进行解压。</td></tr><tr><td><code>-o</code></td><td>解压时覆盖现有文件，不询问</td><td><code>unzip -o archive.zip</code>：解压时如果文件已存在，则自动覆盖。</td></tr><tr><td><code>-q</code></td><td>静默模式，不输出解压过程信息</td><td><code>unzip -q archive.zip</code>：解压时不显示进度或文件信息。</td></tr><tr><td><code>-j</code></td><td>解压时不保存文件的路径结构，只解压文件本身</td><td><code>unzip -j archive.zip</code>：解压时不保留目录结构。</td></tr><tr><td><code>-n</code></td><td>如果文件已经存在，不解压该文件</td><td><code>unzip -n archive.zip</code>：解压时如果文件已存在，不会覆盖它。</td></tr></tbody></table><p><strong>示例</strong>：</p><ol><li><p><strong>解压 <code>.zip</code> 文件</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip archive.zip<span class="comment"># 将 `archive.zip` 文件解压到当前目录</span></span><br></pre></td></tr></table></figure></li><li><p><strong>指定解压到目标目录</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip archive.zip -d /path/to/destination/<span class="comment"># 将 `archive.zip` 解压到 `/path/to/destination/` 目录</span></span><br></pre></td></tr></table></figure></li><li><p><strong>列出 <code>.zip</code> 文件中的内容</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip -l archive.zip<span class="comment"># 列出 `archive.zip` 文件中包含的所有文件，而不进行解压</span></span><br></pre></td></tr></table></figure></li><li><p><strong>解压时自动覆盖现有文件</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip -o archive.zip<span class="comment"># 解压时，如果目标目录已有同名文件，会自动覆盖现有文件</span></span><br></pre></td></tr></table></figure></li></ol><hr><h3 id="tar-指令-——-打包和解包文件"><a href="#tar-指令-——-打包和解包文件" class="headerlink" title="tar 指令 —— 打包和解包文件"></a><code>tar</code> 指令 —— 打包和解包文件</h3><p><code>tar</code> 是 Linux 中一个非常重要的命令，通常用来打包（归档）和解包（提取）文件。它不仅可以压缩文件，还可以将多个文件或目录合并成一个文件，便于传输和存储。<code>tar</code> 通常与其他压缩工具（如 <code>gzip</code>、<code>bzip2</code>）结合使用，以减少文件大小。</p><p><strong>语法：<code>tar [选项] [文件名] [目录或文件]</code></strong></p><p><strong>常用选项</strong>：</p><table><thead><tr><th align="center"><strong>选项</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td align="center"><code>-c</code></td><td>创建一个新的压缩包（create）。</td></tr><tr><td align="center"><code>-x</code></td><td>解压文件（extract）。</td></tr><tr><td align="center"><code>-t</code></td><td>列出压缩包中的文件内容（list）。</td></tr><tr><td align="center"><code>-z</code></td><td>使用 <code>gzip</code> 压缩或解压缩文件。</td></tr><tr><td align="center"><code>-j</code></td><td>使用 <code>bzip2</code> 压缩或解压缩文件。</td></tr><tr><td align="center"><code>-v</code></td><td>显示详细信息（verbose），即在压缩或解压过程中显示文件。</td></tr><tr><td align="center"><code>-f</code></td><td>指定压缩包的文件名（file）。</td></tr><tr><td align="center"><code>-C</code></td><td>解压时指定目录，将文件解压到指定的目录。</td></tr><tr><td align="center"><code>-p</code></td><td>保持文件的原始权限。</td></tr><tr><td align="center"><code>--exclude</code></td><td>排除指定的文件或目录。</td></tr><tr><td align="center"><code>-N</code></td><td>只备份比指定日期更新的文件。</td></tr></tbody></table><p><strong>基本用法：</strong></p><ol><li><p><strong>将目录打包成 <code>.tar</code> 文件</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -cvf etc.tar ./etc    <span class="comment"># 打包当前目录下的 `etc` 目录</span></span><br></pre></td></tr></table></figure></li><li><p><strong>将目录打包并压缩成 <code>.tar.gz</code> 文件</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zcvf /tmp/etc.tar.gz /etc<span class="comment"># 将 `/etc` 目录打包并使用 `gzip` 压缩，生成 `.tar.gz` 文件</span></span><br></pre></td></tr></table></figure></li><li><p><strong>将目录打包并压缩成 <code>.tar.bz2</code> 文件</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -jcvf /tmp/etc.tar.bz2 /etc<span class="comment"># 将 `/etc` 目录打包并使用 `bzip2` 压缩，生成 `.tar.bz2` 文件</span></span><br></pre></td></tr></table></figure></li><li><p><strong>查看 <code>.tar.gz</code> 文件中的内容</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -ztvf /tmp/etc.tar.gz<span class="comment"># 列出压缩包 `etc.tar.gz` 中的文件内容。`z` 选项是因为使用了 `gzip` 压缩</span></span><br></pre></td></tr></table></figure></li><li><p><strong>解压 <code>.tar.gz</code> 文件到指定目录</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf /tmp/etc.tar.gz -C /usr/local/src<span class="comment"># 解压 `etc.tar.gz` 文件并将内容解压到 `/usr/local/src` 目录下</span></span><br></pre></td></tr></table></figure></li><li><p><strong>只提取 <code>.tar.gz</code> 文件中的某一特定文件</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf /tmp/etc.tar.gz etc/passwd</span><br><span class="line"><span class="comment"># 解压 `etc.tar.gz` 文件中的 `etc/passwd` 文件到当前目录。注意，在 `tar` 文件内的路径可能去除了前导的 `/`，这也是为何没有 `/etc/passwd` 这样的绝对路径</span></span><br></pre></td></tr></table></figure></li><li><p><strong>备份文件时保留文件权限</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvpf /tmp/etc.tar.gz /etc<span class="comment"># 使用 `-p` 选项来确保在备份过程中保留文件的权限</span></span><br></pre></td></tr></table></figure></li><li><p><strong>备份特定日期之后的文件</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -N <span class="string">&quot;2025/12/31&quot;</span> -zcvf home.tar.gz /home<span class="comment"># 备份 `/home` 目录下自 2025 年 12 月 31 日以来的文件。</span></span><br></pre></td></tr></table></figure></li><li><p><strong>排除某个目录或文件进行备份</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar --exclude=/home/user/temp -zcvf mybackup.tar.gz /home<span class="comment">#备份 `/home` 目录，但排除了 `/home/user/temp` 目录</span></span><br></pre></td></tr></table></figure></li><li><p><strong>在没有生成文件的情况下直接解压到目标目录</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar -cvf - /etc | tar -xvf - -C /tmp</span><br><span class="line"><span class="comment"># 使用管道（`|`）来传递输出，这样就可以直接将 `/etc` 目录的内容解压到 `/tmp` 目录，而无需在中间创建一个 `.tar` 文件</span></span><br></pre></td></tr></table></figure></li></ol><p><strong>注意事项：</strong></p><ul><li><code>tar</code> 默认会保留文件的权限、时间戳等属性，特别是在备份系统文件时非常重要。</li><li>使用 <code>-C</code> 选项时，解压内容会被放置在指定的目录中，而不是当前工作目录。</li><li><code>tar</code> 解包时，如果文件已存在，会覆盖原有文件，使用时需要小心。</li><li><code>.tar</code> 文件本身并不压缩，通常是用来打包多个文件和目录。如果需要压缩，应该使用 <code>gzip</code>（<code>.tar.gz</code>）或 <code>bzip2</code>（<code>.tar.bz2</code>）等工具。</li></ul><hr><h3 id="bc-指令-——-命令行计算器"><a href="#bc-指令-——-命令行计算器" class="headerlink" title="bc 指令 —— 命令行计算器"></a><code>bc</code> 指令 —— 命令行计算器</h3><p><code>bc</code> 是 Linux 系统中一个非常强大的命令行计算器，能够执行任意精度的数学运算。它不仅支持整数运算，还支持浮点数、算术运算、逻辑运算、条件判断、循环等，功能非常强大。你可以使用 <code>bc</code> 来进行简单的计算，也可以用它执行复杂的数学表达式，甚至用于脚本编程或需要高精度运算的场景。（<strong>计算器的功能 <code>bc</code> 基本上都支持，更多高级功能请自行百度</strong>）</p><p><strong>语法：<code>bc [选项] [文件]</code></strong></p><ul><li><p>如果没有指定文件，<code>bc</code> 会进入交互模式，等待用户输入表达式进行计算。</p></li><li><p>如果指定了文件，<code>bc</code> 会读取该文件并执行其中的命令。</p></li><li><p>可以执行数学计算，包括整数、浮点数、十六进制、八进制和二进制运算。</p></li><li><p>支持标准的算术运算、数学函数、变量、控制语句（如条件判断和循环）。</p></li><li><p>具有任意精度运算的能力，可以设置计算精度。</p></li></ul><p><strong>常用选项：</strong></p><table><thead><tr><th><strong>选项</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><code>-l</code></td><td>启动数学库，包含常用的数学函数（如 <code>sqrt</code>、<code>sin</code>、<code>cos</code> 等）。</td></tr><tr><td><code>-q</code></td><td>禁止显示提示符。</td></tr></tbody></table><p><strong>基本用法：</strong></p><ol><li><p><strong>进入 <code>bc</code> 交互模式：</strong> 直接运行 <code>bc</code>，进入交互式计算模式。此时你可以直接输入数学表达式，计算结果会立即返回。在进入 <code>bc</code> 后，你可以进行算术运算。例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3 + 2<span class="comment"># 输出：5</span></span><br><span class="line">7 / 3<span class="comment"># 输出：2</span></span><br></pre></td></tr></table></figure></li><li><p><strong>设置精度：</strong> 默认情况下，<code>bc</code> 只执行整数运算。如果需要更高的精度，可以设置小数点后的位数。使用 <code>scale</code> 来指定小数位数，精度可以设置为非常高的值：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scale=10</span><br><span class="line">10 / 3<span class="comment"># 输出：3.3333333333</span></span><br></pre></td></tr></table></figure></li><li><p><strong>执行数学表达式：</strong> 你可以在 <code>bc</code> 中输入复杂的数学表达式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(5 + 3) * 2<span class="comment"># 输出：16</span></span><br></pre></td></tr></table></figure></li><li><p><strong>使用数学函数：</strong> 如果启动了 <code>-l</code> 选项，可以使用内置的数学函数，如 <code>sqrt</code>（平方根）、<code>sin</code>（正弦）、<code>cos</code>（余弦）等：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bc -l</span><br><span class="line">sqrt(16)<span class="comment"># 输出：4</span></span><br></pre></td></tr></table></figure></li><li><p><strong>从文件读取命令：</strong> 你可以将一系列的计算命令保存到文件中，使用 <code>bc</code> 执行。</p></li><li><p><strong>条件语句和循环：</strong> <code>bc</code> 还支持条件语句和循环控制结构。</p></li><li><p><strong>支持进制转换：</strong> <code>bc</code> 支持不同进制之间的转换，例如从二进制到十进制、十六进制到十进制等。二进制转十进制：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ibase=2</span><br><span class="line">1010<span class="comment"># 输出：10</span></span><br></pre></td></tr></table></figure></li></ol><hr><h3 id="uname-r-指令-——-查看内核版本"><a href="#uname-r-指令-——-查看内核版本" class="headerlink" title="uname -r 指令 —— 查看内核版本"></a><code>uname -r</code> 指令 —— 查看内核版本</h3><p><code>uname</code> 命令用于显示系统的相关信息，包括操作系统、内核、硬件平台等。而 <code>uname -r</code> 特别用来显示当前操作系统的 <strong>内核版本</strong>。</p><p><strong>语法：<code>uname -r</code></strong></p><p><strong>示例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">uname</span> -r</span><br><span class="line">3.10.0-1160.119.1.el7.x86_64<span class="comment"># 有兴趣的可以查一下相关内核说明</span></span><br></pre></td></tr></table></figure><p><strong>常见选项：</strong></p><table><thead><tr><th align="center"><strong>选项</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td align="center"><code>-r</code></td><td>显示内核版本。</td></tr><tr><td align="center"><code>-a</code></td><td>显示所有信息（内核名称、主机名、内核版本、硬件平台等）。</td></tr><tr><td align="center"><code>-s</code></td><td>显示内核名称。</td></tr><tr><td align="center"><code>-n</code></td><td>显示网络主机名称（主机名）。</td></tr><tr><td align="center"><code>-v</code></td><td>显示内核版本号及版本信息。</td></tr><tr><td align="center"><code>-m</code></td><td>显示机器硬件名称（比如 <code>x86_64</code>）。</td></tr></tbody></table><p><strong>查看所有系统信息示例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">uname</span> -a</span><br><span class="line">Linux VM-16-11-centos 3.10.0-1160.119.1.el7.x86_64 <span class="comment">#1 SMP Tue Jun 4 14:43:51 UTC 2024 x86_64 x86_64 x86_64 GNU/Linux</span></span><br></pre></td></tr></table></figure><p>其中，<code>uname -a</code> 会输出系统的更多信息，包括：</p><ul><li><strong>内核名称</strong>：<code>Linux</code> 表示操作系统的内核类型。</li><li><strong>主机名</strong>：<code>hostname</code> 为该系统的主机名。</li><li><strong>内核版本</strong>：<code>5.10.0-8-amd64</code> 表示使用的是 Linux 5.10 版本的内核，且支持 AMD64 架构（64 位）。</li><li><strong>内核编译信息</strong>：<code>#1 SMP Debian 5.10.17-1 (2021-03-07)</code> 表示该内核是 Debian 5.10.17-1 版本的编译，构建日期为 <code>2021-03-07</code>，且支持对称多处理（SMP）。</li><li><strong>硬件架构</strong>：<code>x86_64</code> 表示该系统是 64 位架构。</li><li><strong>操作系统</strong>：<code>GNU/Linux</code> 表示该系统是 GNU 操作系统与 Linux 内核组合构成的操作系统。</li></ul><hr><h3 id="shutdown-指令（关机命令）"><a href="#shutdown-指令（关机命令）" class="headerlink" title="shutdown 指令（关机命令）"></a><code>shutdown</code> 指令（关机命令）</h3><p><strong>语法：<code>shutdown [选项] [时间] [原因]</code></strong></p><p><strong>常见选项：</strong></p><table><thead><tr><th align="center"><strong>选项</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td align="center"><code>-h</code></td><td>关闭系统（关机）。停掉系统所有服务后关闭计算机。</td></tr><tr><td align="center"><code>-r</code></td><td>重启系统。停掉系统服务后重新启动计算机。</td></tr><tr><td align="center"><code>-t sec</code></td><td>指定延迟时间（以秒为单位），过 <code>sec</code> 秒后执行关机或重启。</td></tr><tr><td align="center"><code>-c</code></td><td>取消已经计划的关机操作（如果有的话）。</td></tr><tr><td align="center"><code>-P</code></td><td>执行关机后停止电源（适用于支持的硬件）。</td></tr></tbody></table><p><strong>例子：</strong></p><ul><li><strong>立即关机：<code>shutdown -h now</code></strong></li><li><strong>重启系统：<code>shutdown -r now</code></strong></li><li><strong>计划 10 分钟后关机：<code>shutdown -h +10</code></strong></li><li><strong>立即关机并指定原因：<code>shutdown -h now &quot;System maintenance&quot;</code></strong></li><li><strong>取消已经计划的关机：<code>shutdown -c</code></strong></li><li><strong>过 30 秒后关机：<code>shutdown -h -t 30</code></strong></li></ul><hr><h3 id="以下命令作为扩展："><a href="#以下命令作为扩展：" class="headerlink" title="以下命令作为扩展："></a>以下命令作为扩展：</h3><p><strong>◆ 安装和登录命令</strong>：<code>login、shutdown、halt、reboot、install、mount、umount、chsh、exit、last；</code></p><p><strong>◆ 文件处理命令：</strong> <code>file、mkdir、grep、dd、find、mv、ls、diff、cat、ln；</code></p><p><strong>◆ 系统管理相关命令</strong>：<code>df、top、free、quota、at、lp、adduser、groupadd、kill、crontab；</code></p><p><strong>◆ 网络操作命令</strong>：<code>ifconfig、ip、ping、netstat、telnet、ftp、route、rlogin、rcp、finger、mail、 nslookup；</code></p><p><strong>◆ 系统安全相关命令：</strong> <code>passwd、su、umask、chgrp、chmod、chown、chattr、sudo ps、who；</code></p><p><strong>◆ 其它命令：</strong> <code>tar、unzip、gunzip、unarj、mtools、man、unendcode、uudecode。</code></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>06 模板初阶</title>
      <link href="/posts/53002.html"/>
      <url>/posts/53002.html</url>
      
        <content type="html"><![CDATA[<h2 id="C-模板概述"><a href="#C-模板概述" class="headerlink" title="C++ 模板概述"></a>C++ 模板概述</h2><blockquote><p><a href="https://blog.csdn.net/chenlong_cxy/article/details/117629686">C++模板详解 —— 函数模板与类模板 | CSDN</a></p></blockquote><p>在 C++ 中，模板（<strong>Template</strong>）是一个非常强大的特性，它可以让我们编写与特定数据类型无关的代码，最终由编译器根据实际的类型生成特定的代码。模板主要分为两类：<strong>函数模板</strong> 和 <strong>类模板</strong>。模板的引入大大增强了 C++ 语言的灵活性和代码复用性，减少了重复代码的编写。</p><h3 id="1-为什么需要模板？"><a href="#1-为什么需要模板？" class="headerlink" title="1. 为什么需要模板？"></a>1. 为什么需要模板？</h3><p>假设你想编写一个通用的函数来交换两个变量的值。最初，你可能会想到通过函数重载来实现，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">(<span class="type">int</span>&amp; left, <span class="type">int</span>&amp; right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = left;</span><br><span class="line">    left = right;</span><br><span class="line">    right = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">(<span class="type">double</span>&amp; left, <span class="type">double</span>&amp; right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> temp = left;</span><br><span class="line">    left = right;</span><br><span class="line">    right = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">(<span class="type">char</span>&amp; left, <span class="type">char</span>&amp; right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> temp = left;</span><br><span class="line">    left = right;</span><br><span class="line">    right = temp;</span><br><span class="line">&#125;</span><br><span class="line">……</span><br></pre></td></tr></table></figure><p>虽然使用函数重载可以满足不同数据类型的需求，但这种方法存在一些问题：</p><ol><li><strong>代码重复</strong>：每增加一个新的类型（例如 <code>float</code> 或 <code>long</code>），都需要为其编写一个新的 <code>Swap</code> 函数。这使得代码复用性差。</li><li><strong>可维护性差</strong>：如果 <code>Swap</code> 函数的实现出现错误，可能需要修改每个重载版本，这会导致错误传播并增加维护的复杂度。</li><li><strong>扩展性差</strong>：当需要处理的新类型增多时，维护这些重载函数的工作量也随之增加。</li></ol><h4 id="如何解决这些问题？"><a href="#如何解决这些问题？" class="headerlink" title="如何解决这些问题？"></a>如何解决这些问题？</h4><p>可以通过 <strong>函数模板</strong> 来解决这些问题。模板可以让你编写通用的函数或类，这些函数或类在编译时根据实际使用的类型生成特定的版本。</p><h3 id="2-函数模板"><a href="#2-函数模板" class="headerlink" title="2. 函数模板"></a>2. 函数模板</h3><p><strong>函数模板</strong> 允许你定义一个蓝图或框架，它并不依赖于某种特定的数据类型，而是通过在编译时根据传入的类型生成具体类型的函数。这样你就能够编写一个函数来处理所有类型的参数，而无需手动为每个类型编写不同的函数。</p><h4 id="2-1-函数模板的定义"><a href="#2-1-函数模板的定义" class="headerlink" title="2.1 函数模板的定义"></a>2.1 函数模板的定义</h4><p>一个典型的函数模板定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">(T&amp; left, T&amp; right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T temp = left;</span><br><span class="line">    left = right;</span><br><span class="line">    right = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong><code>template&lt;typename T&gt;</code></strong>：声明了一个模板，<code>T</code> 是一个类型参数，表示可以接受任何数据类型，<code>T</code> 是自己命名的，可以是 <code>TY</code>、<code>A</code> 等等（同时也可以使用 <strong><code>template &lt;class T&gt;</code></strong>，<strong>二者是等价的</strong>，这里先知道可以使用 <code>class</code>，至于为什么，以后再讨论）。</li><li><code>void Swap(T&amp; left, T&amp; right)</code>：这是模板函数的定义，<code>T</code> 会根据调用时传入的参数类型来具体化。</li></ul><p>这段代码可以交换任意类型的两个变量，不需要为每种类型单独写一个函数。</p><h4 id="2-2-模板的使用"><a href="#2-2-模板的使用" class="headerlink" title="2.2 模板的使用"></a>2.2 模板的使用</h4><p>当我们使用模板时，编译器会根据传递给模板的实际类型来生成相应的代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">对于不同的类型（如 `<span class="type">int</span>`、`<span class="type">double</span>`），编译器会自动根据传入的类型生成不同版本的 `Swap` 函数，而不需要手动为每个类型编写不同的函数。</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 泛型 Swap 函数，接受任意类型的引用参数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">(T&amp; left, T&amp; right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T temp = left;</span><br><span class="line">    left = right;</span><br><span class="line">    right = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>, b = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">Swap</span>(a, b);  <span class="comment">// 使用 int 类型生成 Swap(int&amp; left, int&amp; right)</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;, b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> x = <span class="number">1.1</span>, y = <span class="number">2.2</span>;</span><br><span class="line">    <span class="built_in">Swap</span>(x, y);  <span class="comment">// 使用 double 类型生成 Swap(double&amp; left, double&amp; right)</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;x = &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, y = &quot;</span> &lt;&lt; y &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>多个参数的模板函数（多类型支持）：</strong> 模板函数可以支持多个模板参数类型，通过模板参数列表可以定义多个不同类型的参数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> T1&amp; left, <span class="type">const</span> T2&amp; right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; left &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; right &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">1</span>, <span class="number">2</span>);         <span class="comment">// 整型参数</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="number">1</span>, <span class="number">2.2</span>);       <span class="comment">// 整型和浮点型参数</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello&quot;</span>, <span class="number">2.2</span>); <span class="comment">// 字符串和浮点型参数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>模板函数推导类型（自动推导）：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">Add</span><span class="params">(<span class="type">const</span> T&amp; left, <span class="type">const</span> T&amp; right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> left + right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a1 = <span class="number">10</span>, a2 = <span class="number">20</span>;</span><br><span class="line">    <span class="type">double</span> d1 = <span class="number">10.1</span>, d2 = <span class="number">20.2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编译器自动推导类型</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">Add</span>(a1, a2) &lt;&lt; endl;       <span class="comment">// 使用 int 类型</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">Add</span>(d1, d2) &lt;&lt; endl;       <span class="comment">// 使用 double 类型</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">Add</span>(a1, (<span class="type">int</span>)d1) &lt;&lt; endl;  <span class="comment">// 混合类型时自动推导为 int 类型</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">Add</span>((<span class="type">double</span>)a1, d1) &lt;&lt; endl; <span class="comment">// 混合类型时自动推导为 double 类型</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>显式指定模板类型：</strong> 有时需要显式指定模板类型，尤其是在类型推导无法正确推导时。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当参数类型不一致时，必须显式指定或强制类型转换</span></span><br><span class="line"><span class="built_in">Add</span>(<span class="number">10</span>, <span class="number">20.5</span>);          <span class="comment">// 错误：T 无法推导为两种不同类型</span></span><br><span class="line"><span class="built_in">Add</span>&lt;<span class="type">int</span>&gt;(<span class="number">10</span>, <span class="number">20.5</span>);     <span class="comment">// 正确：T 显式指定为 int，第二个参数隐式转换为 int</span></span><br><span class="line"><span class="built_in">Add</span>&lt;<span class="type">double</span>&gt;(<span class="number">10</span>, <span class="number">20.5</span>);  <span class="comment">// 正确：T 显式指定为 double，第一个参数隐式转换为 double</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">Add</span><span class="params">(<span class="type">const</span> T&amp; left, <span class="type">const</span> T&amp; right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> left + right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a1 = <span class="number">10</span>;</span><br><span class="line">    <span class="type">double</span> d1 = <span class="number">10.1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显式转换 int 类型进行计算</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">Add</span>(a1, (<span class="type">int</span>)d1) &lt;&lt; endl;  <span class="comment">// 将 double 类型 d1 显式转换为 int 类型进行加法运算</span></span><br><span class="line">    <span class="comment">// 显式转换 double 类型进行计算</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">Add</span>((<span class="type">double</span>)a1, d1) &lt;&lt; endl;    <span class="comment">// 将 int 类型 a1 显式转换为 double 类型进行加法运算</span></span><br><span class="line">    <span class="comment">// 显式指定模板类型为 int，进行计算</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">Add</span>&lt;<span class="type">int</span>&gt;(a1, d1) &lt;&lt; endl;    <span class="comment">// 显式指定 Add 模板为 int 类型，但会进行隐式转换，最终结果为 int 类型</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>模板函数返回指针（返回类型为指针）：</strong> 模板函数不仅能返回基本类型的值，还可以返回指针类型（如动态分配内存时）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">T* <span class="title">Alloc</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> T[n];                        <span class="comment">// 动态分配数组</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 使用模板函数分配数组</span></span><br><span class="line">    <span class="type">double</span>* p1 = <span class="built_in">Alloc</span>&lt;<span class="type">double</span>&gt;(<span class="number">10</span>);         <span class="comment">// 分配 10 个 double 类型的元素</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以在这里操作 p1 数组，记得使用完后 delete[] 释放内存</span></span><br><span class="line">    <span class="keyword">delete</span>[] p1;                            <span class="comment">// 释放动态分配的内存</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>混合类型进行计算（加法操作等）：</strong> 当我们进行加法操作时，如果参数类型不同，C++ 可以通过类型转换处理不同类型之间的计算。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">Add</span><span class="params">(<span class="type">const</span> T&amp; left, <span class="type">const</span> T&amp; right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> left + right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a1 = <span class="number">10</span>;</span><br><span class="line">    <span class="type">double</span> d1 = <span class="number">10.1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 混合类型计算</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">Add</span>(a1, (<span class="type">int</span>)d1) &lt;&lt; endl; <span class="comment">// 转换为 int 类型后进行加法</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">Add</span>((<span class="type">double</span>)a1, d1) &lt;&lt; endl; <span class="comment">// 转换为 double 类型后进行加法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-隐式实例化与显式实例化"><a href="#2-3-隐式实例化与显式实例化" class="headerlink" title="2.3 隐式实例化与显式实例化"></a>2.3 隐式实例化与显式实例化</h4><ul><li><strong>隐式实例化</strong>：编译器根据你传入的实参类型自动推导出模板参数的具体类型。例如，<code>Swap(a, b)</code> 会自动推导出 <code>T</code> 为 <code>int</code>，生成一个 <code>Swap(int&amp; left, int&amp; right)</code> 的函数。</li><li><strong>显式实例化</strong>：你也可以显式地指定模板参数类型。例如：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 显式实例化的典型场景（在源文件中使用）</span></span><br><span class="line"><span class="keyword">template</span> <span class="type">void</span> <span class="built_in">Swap</span>&lt;<span class="type">int</span>&gt;(<span class="type">int</span>&amp;, <span class="type">int</span>&amp;);      <span class="comment">// 生成 int 版本</span></span><br><span class="line"><span class="keyword">template</span> <span class="type">void</span> <span class="built_in">Swap</span>&lt;<span class="type">double</span>&gt;(<span class="type">double</span>&amp;, <span class="type">double</span>&amp;); <span class="comment">// 生成 double 版本</span></span><br></pre></td></tr></table></figure><p>这种方式可以避免编译器自动推导模板参数的类型，而是由你明确指定。</p><h4 id="2-4-模板的匹配与优先级"><a href="#2-4-模板的匹配与优先级" class="headerlink" title="2.4 模板的匹配与优先级"></a>2.4 模板的匹配与优先级</h4><p>C++ 在选择函数时有一套匹配规则：</p><p><strong>函数模板与非模板函数共存</strong>：当你既有非模板函数又有模板函数时，C++ 编译器会根据传入参数的类型优先选择非模板函数。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">(<span class="type">int</span>&amp; left, <span class="type">int</span>&amp; right)</span></span>;  <span class="comment">// 非模板函数</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">(T&amp; left, T&amp; right)</span></span>;  <span class="comment">// 模板函数</span></span><br></pre></td></tr></table></figure><p>当你传入 <code>int</code> 类型时，编译器会优先选择 <code>Swap(int&amp; left, int&amp; right)</code>。</p><p><strong>模板函数匹配规则</strong>：如果模板能够提供更好的匹配，编译器会优先选择模板函数。模板函数通常会考虑类型转换，而非模板函数则不会进行自动类型转换。</p><h3 id="3-模板的优势"><a href="#3-模板的优势" class="headerlink" title="3. 模板的优势"></a>3. 模板的优势</h3><ul><li><strong>提高代码复用性：</strong> 使用函数模板的最大好处是可以大大减少重复代码。例如，使用模板函数可以避免为每个数据类型编写多次相同的代码，只需要编写一次模板函数，编译器会根据不同的类型实例化出对应的代码。</li><li><strong>代码的可维护性：</strong> 当你需要修改 <code>Swap</code> 函数的实现时，只需要修改模板函数本身。所有使用了这个模板的地方，编译器会自动更新生成的代码，这大大提高了代码的可维护性。</li><li><strong>自动类型推导：</strong> 模板能够通过类型推导来决定类型，使得调用者不必显式指定类型。这不仅简化了代码，还减少了出错的可能性。</li><li><strong>避免错误：</strong> 模板的另一个好处是，可以避免因手动编写多个重载函数而导致的错误。例如，模板函数不会被错误地应用于不兼容的类型，而编译器会在编译时进行类型检查，确保类型安全。</li></ul><h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h3><p>C++中的模板是一种非常强大的特性，它能够实现与类型无关的通用代码，从而提高代码复用性、可维护性和扩展性。模板函数尤其适合用于处理不同类型但逻辑相同的代码，它允许编写一个蓝图或模具，编译器根据实际传入的类型生成具体的函数或类实例。通过模板，程序员可以避免冗余代码的编写，减少出错的可能，同时保持代码的简洁和高效。</p><hr><h2 id="类模板：提高代码复用性与灵活性"><a href="#类模板：提高代码复用性与灵活性" class="headerlink" title="类模板：提高代码复用性与灵活性"></a>类模板：提高代码复用性与灵活性</h2><p>在 C++ 中，类模板是一个强大的工具，它允许我们编写通用的类，而不依赖于特定的类型。通过类模板，我们可以提高代码的复用性，减少冗余代码，并且使得代码更加灵活易于扩展。</p><h3 id="代码重构：从重复代码到通用模板"><a href="#代码重构：从重复代码到通用模板" class="headerlink" title="代码重构：从重复代码到通用模板"></a>代码重构：从重复代码到通用模板</h3><p>在实际开发中，我们经常遇到需要为不同数据类型编写类似代码的情况。假设我们需要实现一个栈类，并且这个栈类要处理多种数据类型，比如 <code>int</code> 和 <code>double</code> 类型。最初的做法可能是为每种数据类型写一个新的类：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// int 类型栈</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StackInt</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">StackInt</span>(<span class="type">size_t</span> capacity = <span class="number">3</span>) &#123;</span><br><span class="line">        _array = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>) * capacity);</span><br><span class="line">        _capacity = capacity;</span><br><span class="line">        _size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Push</span><span class="params">(<span class="type">int</span> data)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _array[_size] = data;</span><br><span class="line">        _size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">StackInt</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">free</span>(_array);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span>* _array;</span><br><span class="line">    <span class="type">int</span> _capacity;</span><br><span class="line">    <span class="type">int</span> _size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// double 类型栈</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StackDouble</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">StackDouble</span>(<span class="type">size_t</span> capacity = <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        _array = (<span class="type">double</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">double</span>) * capacity);</span><br><span class="line">        _capacity = capacity;</span><br><span class="line">        _size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Push</span><span class="params">(<span class="type">double</span> data)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _array[_size] = data;</span><br><span class="line">        _size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">StackDouble</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">free</span>(_array);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span>* _array;</span><br><span class="line">    <span class="type">int</span> _capacity;</span><br><span class="line">    <span class="type">int</span> _size;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="问题分析："><a href="#问题分析：" class="headerlink" title="问题分析："></a>问题分析：</h4><p>虽然 <code>StackInt</code> 和 <code>StackDouble</code> 做的工作基本相同，唯一的区别是它们处理的类型不同（<code>int</code> 和 <code>double</code>）。但是，这种做法导致了冗余的代码。每增加一个新的数据类型，我们都需要为其编写一个类似的类，这样代码就会变得越来越冗长，维护起来也变得更为困难。</p><hr><h4 id="类模板的引入："><a href="#类模板的引入：" class="headerlink" title="类模板的引入："></a>类模板的引入：</h4><p>为了避免这种冗余代码，并提高代码的复用性，我们可以使用 C++ 的类模板来解决这个问题。类模板允许我们为不同的数据类型生成相同功能的类，而无需重复编写相似的代码。</p><p>通过类模板，我们可以将 <code>StackInt</code> 和 <code>StackDouble</code> 合并为一个通用的栈类 <code>Stack&lt;T&gt;</code>，其中 <code>T</code> 代表数据类型。通过实例化类模板，编译器会根据我们提供的类型自动生成不同版本的栈类。</p><p>下面是通过类模板重构后的栈类代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;  <span class="comment">// 定义一个类模板，T 是类型参数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Stack</span>(<span class="type">size_t</span> capacity = <span class="number">3</span>) : _capacity(capacity), _size(<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        _array = <span class="keyword">new</span> T[capacity];   <span class="comment">// 使用 T 类型动态分配内存</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Push</span><span class="params">(<span class="type">const</span> T&amp; data)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _array[_size++] = data;  <span class="comment">// 将数据压入栈</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Stack</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] _array;  <span class="comment">// 释放内存</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* _array;  <span class="comment">// 存储数据的数组，类型由模板参数决定</span></span><br><span class="line">    <span class="type">int</span> _capacity;  <span class="comment">// 栈的最大容量</span></span><br><span class="line">    <span class="type">int</span> _size;  <span class="comment">// 栈当前的元素个数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">通过类模板，我们可以在 `main` 函数中实例化栈类，指定具体的类型：</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Stack&lt;<span class="type">int</span>&gt; s1;    <span class="comment">// 创建一个存储 int 类型的栈</span></span><br><span class="line">    Stack&lt;<span class="type">double</span>&gt; s2; <span class="comment">// 创建一个存储 double 类型的栈</span></span><br><span class="line"></span><br><span class="line">    s<span class="number">1.</span><span class="built_in">Push</span>(<span class="number">10</span>);      <span class="comment">// 向 int 类型栈中压入整数</span></span><br><span class="line">    s<span class="number">2.</span><span class="built_in">Push</span>(<span class="number">3.14</span>);    <span class="comment">// 向 double 类型栈中压入浮点数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="代码解析："><a href="#代码解析：" class="headerlink" title="代码解析："></a>代码解析：</h4><ol><li><strong>模板定义</strong>：<code>template&lt;class T&gt;</code> 定义了一个类模板，其中 <code>T</code> 是类型参数，表示栈中元素的类型。在实例化时，<code>T</code> 会被替换为具体的类型。</li><li><strong>通用数据类型</strong>：类模板中的 <code>_array</code> 被定义为 <code>T*</code>，这使得我们可以使用任意类型的数据。无论是 <code>int</code>、<code>double</code> 还是其他自定义类型，类模板都会根据我们指定的类型生成相应的栈类。</li><li><strong>内存分配</strong>：在构造函数中，我们使用 <code>new T[capacity]</code> 来动态分配内存，<code>T</code> 会根据实际类型决定内存的大小。例如，当 <code>T</code> 是 <code>int</code> 时，会分配一个 <code>int</code> 类型的数组；当 <code>T</code> 是 <code>double</code> 时，会分配一个 <code>double</code> 类型的数组。</li><li><strong>入栈操作</strong>：<code>Push</code> 方法接受一个 <code>const T&amp;</code> 类型的参数，允许我们将任何类型的数据压入栈中。</li><li><strong>析构函数</strong>：使用 <code>delete[]</code> 来释放栈的内存，避免内存泄漏。</li></ol><p>在上面的代码中，我们通过指定不同的模板参数（<code>int</code> 和 <code>double</code>）来创建不同类型的栈实例。每个栈都具有相同的功能，但能够处理不同的数据类型。</p><hr><h3 id="类模板的优势"><a href="#类模板的优势" class="headerlink" title="类模板的优势"></a>类模板的优势</h3><ul><li>提高代码复用性：类模板允许我们编写一次通用代码，而不需要为每种数据类型编写独立的类。只需定义一个模板，编译器会根据实际使用的类型自动生成不同类型的类。这使得代码更加简洁并减少了冗余。</li><li>更加灵活：类模板的一个显著优点是它的灵活性。你可以根据需要创建不同类型的栈（或其他数据结构）。例如，可以创建 <code>Stack&lt;int&gt;</code> 来存储整数，创建 <code>Stack&lt;double&gt;</code> 来存储浮点数，甚至可以用自定义类作为模板参数来存储自定义对象。</li><li>易于维护：使用类模板时，修改模板代码会自动影响所有实例化的类。这意味着当我们需要支持新的数据类型时，只需修改模板定义，而无需修改现有的类定义，从而减少了重复工作。</li><li>避免冗余代码：每种数据类型都写一个独立的类会导致代码冗长，且容易出错。类模板提供了一个统一的代码框架，减少了冗余代码，提高了代码质量。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>类模板是 C++ 的一项强大特性，它允许你编写通用的类，并且能够处理不同类型的数据。通过类模板，我们可以避免冗余代码，提高代码复用性和可维护性，并使代码更加灵活。类模板在 C++ 标准库（如 STL）中广泛应用，特别是在实现容器类和算法时。掌握类模板的使用，能够帮助开发者编写更加简洁、灵活、易于扩展的代码。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 模板 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>05 C/C++内存管理</title>
      <link href="/posts/38295.html"/>
      <url>/posts/38295.html</url>
      
        <content type="html"><![CDATA[<h2 id="C-C-内存管理"><a href="#C-C-内存管理" class="headerlink" title="C&#x2F;C++内存管理"></a>C&#x2F;C++内存管理</h2><h3 id="C-C-内存分布"><a href="#C-C-内存分布" class="headerlink" title="C&#x2F;C++内存分布"></a>C&#x2F;C++内存分布</h3><p>问题引入：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> globalVar = <span class="number">1</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> staticGlobalVar = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> staticVar = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> localVar = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> num1[<span class="number">10</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;;</span><br><span class="line"><span class="type">char</span> char2[] = <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* pChar3 = <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line"><span class="type">int</span>* ptr1 = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>) * <span class="number">4</span>);</span><br><span class="line"><span class="type">int</span>* ptr2 = (<span class="type">int</span>*)<span class="built_in">calloc</span>(<span class="number">4</span>, <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="type">int</span>* ptr3 = (<span class="type">int</span>*)<span class="built_in">realloc</span>(ptr2, <span class="built_in">sizeof</span>(<span class="type">int</span>) * <span class="number">4</span>);</span><br><span class="line"><span class="built_in">free</span>(ptr1);</span><br><span class="line"><span class="built_in">free</span>(ptr3);</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1.</span> 选择题：</span><br><span class="line">选项 : A.栈 B.堆 C.数据段(静态区) D.代码段(常量区)</span><br><span class="line">globalVar在哪里？____ staticGlobalVar在哪里？____</span><br><span class="line">staticVar在哪里？____ localVar在哪里？____</span><br><span class="line">num1 在哪里？____</span><br><span class="line">char2在哪里？____ * char2在哪里？___</span><br><span class="line">pChar3在哪里？____ * pChar3在哪里？____</span><br><span class="line">ptr1在哪里？____ * ptr1在哪里？____</span><br><span class="line"><span class="number">2.</span> 填空题：</span><br><span class="line"><span class="built_in">sizeof</span>(num1) = ____;</span><br><span class="line"><span class="built_in">sizeof</span>(char2) = ____; <span class="built_in">strlen</span>(char2) = ____;</span><br><span class="line"><span class="built_in">sizeof</span>(pChar3) = ____; <span class="built_in">strlen</span>(pChar3) = ____;</span><br><span class="line"><span class="built_in">sizeof</span>(ptr1) = ____;</span><br><span class="line"><span class="number">3.</span> <span class="keyword">sizeof</span> 和 strlen 区别？</span><br></pre></td></tr></table></figure><h3 id="变量存储位置分析"><a href="#变量存储位置分析" class="headerlink" title="变量存储位置分析"></a>变量存储位置分析</h3><table><thead><tr><th align="left">变量名</th><th align="left">存储位置</th><th>解释</th></tr></thead><tbody><tr><td align="left"><strong><code>globalVar</code></strong></td><td align="left">数据段(静态区)</td><td><code>globalVar</code> 是全局变量，它存储在数据段中。数据段存储了全局变量和静态变量。</td></tr><tr><td align="left"><strong><code>staticGlobalVar</code></strong></td><td align="left">数据段(静态区)</td><td><code>staticGlobalVar</code> 是一个静态全局变量，存储在数据段，它的生命周期是整个程序执行期间。</td></tr><tr><td align="left"><strong><code>staticVar</code></strong></td><td align="left">数据段(静态区)</td><td><code>staticVar</code> 是一个局部静态变量，使用 <code>static</code> 修饰，存储在静态区而不是栈中，生命周期为整个程序执行期间。</td></tr><tr><td align="left"><strong><code>localVar</code></strong></td><td align="left">栈</td><td><code>localVar</code> 是普通局部变量，存储在栈上，生命周期是函数调用期间。</td></tr><tr><td align="left"><strong><code>num1</code></strong></td><td align="left">栈</td><td><code>num1</code> 是一个局部数组，存储在栈上，数组元素按顺序存储。</td></tr><tr><td align="left"><strong><code>char2</code></strong></td><td align="left">栈</td><td><code>char2</code> 是局部字符数组，存储在栈上，包含字符串 <code>&quot;abcd&quot;</code> 及其结束符 <code>&#39;\0&#39;</code>。</td></tr><tr><td align="left"><strong><code>char2[0] (即 char2)</code></strong></td><td align="left">栈</td><td><code>char2[0]</code> 是字符数组的第一个元素，存储在栈上。</td></tr><tr><td align="left"><strong><code>pChar3</code></strong></td><td align="left">栈</td><td><code>pChar3</code> 是一个指针，指向常量字符串 <code>&quot;abcd&quot;</code>，指针本身存储在栈上。</td></tr><tr><td align="left"><strong><code>pChar3[0] (即 pChar3)</code></strong></td><td align="left">常量区</td><td><code>pChar3[0]</code> 指向的字符 <code>&quot;a&quot;</code> 存储在常量区，常量区用于存储不可修改的数据。</td></tr><tr><td align="left"><strong><code>ptr1</code></strong></td><td align="left">栈</td><td><code>ptr1</code> 是一个指针，指向堆上动态分配的内存，但指针本身存储在栈上。</td></tr><tr><td align="left"><strong><code>ptr1[0] (即 ptr1)</code></strong></td><td align="left">堆</td><td><code>ptr1[0]</code> 是堆上动态分配的内存中的数据。</td></tr></tbody></table><h3 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h3><h4 id="1-globalVar-和-staticGlobalVar"><a href="#1-globalVar-和-staticGlobalVar" class="headerlink" title="1. globalVar 和 staticGlobalVar"></a>1. <strong>globalVar 和 staticGlobalVar</strong></h4><p>这两个变量是全局变量，并且具有静态存储期。它们存储在 <strong>数据段</strong>（静态区），这是 C 语言中用于存储静态和全局变量的区域。全局变量在程序开始时分配内存，并且在程序结束时才释放。</p><h4 id="2-staticVar"><a href="#2-staticVar" class="headerlink" title="2. staticVar"></a>2. <strong>staticVar</strong></h4><p><code>staticVar</code> 是一个局部静态变量，尽管它是在函数 <code>Test()</code> 内声明的，但由于 <code>static</code> 关键字的作用，它的生命周期贯穿整个程序的运行，而不是函数调用期间。因此，它被存储在 <strong>数据段(静态区)</strong> 中，而非栈中。其作用范围仍然局限于函数内。</p><h4 id="3-localVar"><a href="#3-localVar" class="headerlink" title="3. localVar"></a>3. <strong>localVar</strong></h4><p><code>localVar</code> 是一个普通局部变量，声明在 <code>Test()</code> 函数内部。局部变量会分配在 <strong>栈</strong> 上，每次函数调用时，栈为局部变量分配内存，函数返回后内存释放。</p><h4 id="4-num1-和-char2"><a href="#4-num1-和-char2" class="headerlink" title="4. num1 和 char2"></a>4. <strong>num1 和 char2</strong></h4><p>这两个变量分别是局部数组和字符数组，它们存储在 <strong>栈</strong> 上。由于它们是局部变量，所以栈内存会在函数调用时分配，并在函数返回时释放。</p><h4 id="5-char2-0-和-char2"><a href="#5-char2-0-和-char2" class="headerlink" title="5. char2 [0] 和 *char2"></a>5. <strong>char2 [0] 和 *char2</strong></h4><p><code>char2[0]</code> 是字符数组的第一个元素，直接存储在栈上。而 <code>*char2</code> 是通过指针访问的第一个元素，也存储在栈上的 <code>char2</code> 数组内。</p><h4 id="6-pChar3"><a href="#6-pChar3" class="headerlink" title="6. pChar3"></a>6. <strong>pChar3</strong></h4><p><code>pChar3</code> 是一个指向常量字符串的指针，它本身存储在 <strong>栈</strong> 上，指向的字符串 <code>&quot;abcd&quot;</code> 存储在 <strong>常量区</strong>（常量区用于存储程序中的常量字符串）。指针本身存储在栈上，但它指向的内存位置位于常量区。</p><h4 id="7-ptr1-和-ptr1-0"><a href="#7-ptr1-和-ptr1-0" class="headerlink" title="7. ptr1 和 ptr1 [0]"></a>7. <strong>ptr1 和 ptr1 [0]</strong></h4><p><code>ptr1</code> 是一个指针，它是局部变量，存储在 <strong>栈</strong> 上。<code>ptr1</code> 通过 <code>malloc</code> 分配了堆上的内存，指针指向堆上分配的内存区域，而 <code>ptr1[0]</code> 是堆上分配内存中的数据。</p><h3 id="填空题答案表格"><a href="#填空题答案表格" class="headerlink" title="填空题答案表格"></a>填空题答案表格</h3><table><thead><tr><th align="left"><strong>题目</strong></th><th align="left"><strong>答案</strong></th><th><strong>原因</strong></th></tr></thead><tbody><tr><td align="left"><strong><code>sizeof(num1)</code></strong></td><td align="left"><code>40</code></td><td><code>num1</code> 是 <code>int[10]</code> 类型数组，包含 10 个 <code>int</code>，每个占 4 字节，总大小为 <code>10*4=40</code>。</td></tr><tr><td align="left"><strong><code>sizeof(char2)</code></strong></td><td align="left"><code>5</code></td><td><code>char2</code> 是字符数组，初始化为 <code>&quot;abcd&quot;</code>，包含 <code>&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;\0&#39;</code>，共 5 个字符。</td></tr><tr><td align="left"><strong><code>strlen(char2)</code></strong></td><td align="left"><code>4</code></td><td><code>strlen</code> 计算字符串长度时，不包含终止符 <code>&#39;\0&#39;</code>，因此为 <code>4</code>。</td></tr><tr><td align="left"><strong><code>sizeof(pChar3)</code></strong></td><td align="left"><code>4</code>&#x2F;<code>8</code></td><td><code>pChar3</code> 是指针，32 位系统占 4 字节，64 位系统占 8 字节（题目未明确系统位数）。</td></tr><tr><td align="left"><strong><code>strlen(pChar3)</code></strong></td><td align="left"><code>4</code></td><td><code>pChar3</code> 指向常量字符串 <code>&quot;abcd&quot;</code>，<code>strlen</code> 计算结果为 <code>4</code>。</td></tr><tr><td align="left"><strong><code>sizeof(ptr1)</code></strong></td><td align="left"><code>4</code>&#x2F;<code>8</code></td><td><code>ptr1</code> 是指针，32 位系统占 4 字节，64 位系统占 8 字节（与 <code>pChar3</code> 一致）。</td></tr></tbody></table><hr><h2 id="C-C-内存区域的划分"><a href="#C-C-内存区域的划分" class="headerlink" title="C&#x2F;C++内存区域的划分"></a>C&#x2F;C++内存区域的划分</h2><p>在 C&#x2F;C++编程中，程序的运行是通过内存来实现的。操作系统在程序执行时会将程序加载到内存中，并且将程序划分成不同的内存区域，每个区域有其特定的用途和特点。这些内存区域不仅影响程序的效率，还直接关系到程序的运行过程和内存管理。</p><h3 id="1-代码段-Code-Segment-——可执行代码-只读常量"><a href="#1-代码段-Code-Segment-——可执行代码-只读常量" class="headerlink" title="1. 代码段 (Code Segment)——可执行代码&#x2F;只读常量"></a>1. 代码段 (Code Segment)——可执行代码&#x2F;只读常量</h3><p><strong>位置</strong>：代码段通常位于内存的高地址部分。</p><p><strong>用途</strong>：代码段存储程序的机器代码，即经过编译后的可执行指令。程序执行时，CPU 将从代码段中取出指令并按顺序执行。</p><p><strong>特点</strong>：</p><ul><li><strong>只读性</strong>：代码段是只读的，程序在执行过程中不能修改代码内容。这是为了防止程序错误地修改自己的执行代码。</li><li><strong>保护性</strong>：由于代码段的内容不能被修改，它也常常受到操作系统和硬件的保护，防止出现不可预期的行为。</li><li><strong>静态性</strong>：代码段在程序运行时不会发生变化，程序的机器代码在加载后是固定的（少数情况下，JIT 编译器或自修改代码除外）。</li><li><strong>扩展功能</strong>：支持动态生成代码，例如通过 JIT 编译生成和执行指令。</li></ul><h3 id="2-数据段-Data-Segment-——全局数据-静态数据"><a href="#2-数据段-Data-Segment-——全局数据-静态数据" class="headerlink" title="2. 数据段 (Data Segment)——全局数据&#x2F;静态数据"></a>2. 数据段 (Data Segment)——全局数据&#x2F;静态数据</h3><p><strong>位置</strong>：数据段位于代码段下方。</p><p><strong>用途</strong>：数据段用于存储程序的全局变量、静态变量和常量数据。它被进一步划分为两个子区段：</p><ul><li><strong>已初始化的数据区</strong>：存储已初始化的全局变量和静态变量。</li><li><strong>未初始化的数据区 (BSS 段)</strong>：存储未初始化的全局变量和静态变量，程序启动时会将这些变量初始化为零。</li></ul><p><strong>特点</strong>：</p><ul><li><strong>生命周期</strong>：数据段在程序的整个运行过程中存在，直到程序退出时才释放。</li><li><strong>内存管理</strong>：数据段的内存分配由编译器或操作系统自动管理。程序员无需手动分配和释放。</li><li><strong>常量数据</strong>：一些编译器会将全局 <code>const</code> 常量数据放在一个只读数据区，该区域通常也属于代码段的一部分。</li></ul><h3 id="3-堆-Heap"><a href="#3-堆-Heap" class="headerlink" title="3. 堆 (Heap)"></a>3. 堆 (Heap)</h3><p><strong>位置</strong>：堆位于数据段下方，通常随着程序的运行动态增长。</p><p><strong>用途</strong>：堆用于动态内存分配。通过 <code>malloc()</code>、<code>calloc()</code>、<code>realloc()</code> 等函数，程序可以向堆申请内存空间，并在不再需要时通过 <code>free()</code> 函数释放内存。</p><p><strong>特点</strong>：</p><ul><li><strong>动态性</strong>：堆内存是动态分配的，可以在程序运行时根据需要申请或释放，大小在运行期间可变化。</li><li><strong>程序员控制</strong>：堆内存的管理由程序员控制，程序员需要显式地申请和释放内存。如果忘记释放，会导致内存泄漏。</li><li><strong>灵活性</strong>：堆适合存储生命周期不固定的数据，例如大型数据结构或需要在函数间共享的资源。</li><li><strong>增长方向</strong>：通常向上增长（从低地址到高地址），但具体取决于操作系统和硬件架构。</li></ul><h3 id="4-栈-Stack"><a href="#4-栈-Stack" class="headerlink" title="4. 栈 (Stack)"></a>4. 栈 (Stack)</h3><p><strong>位置</strong>：栈位于堆的上方，通常向下增长。</p><p><strong>用途</strong>：栈用于存储局部变量、函数参数以及函数调用时的返回地址。每当函数被调用时，栈会为该函数分配一块内存区域，函数执行完后，这部分内存会被自动回收。</p><p><strong>特点</strong>：</p><ul><li><strong>自动管理</strong>：栈的内存分配和释放是自动的，通常由编译器或操作系统管理。每次函数调用时，栈内存会自动分配，函数返回时会自动回收。</li><li><strong>生命周期短</strong>：栈内存的生命周期通常与函数的调用和返回紧密相关，内存的分配和回收速度非常快。</li><li><strong>空间限制</strong>：栈的空间是有限的，过多的递归调用或过大的局部变量可能导致栈溢出（stack overflow）错误。</li><li><strong>增长方向</strong>：通常向下增长（从高地址到低地址），具体取决于硬件和操作系统。</li></ul><h3 id="5-内存映射区-Memory-Mapped-Region-——文件映射、动态库、匿名映射"><a href="#5-内存映射区-Memory-Mapped-Region-——文件映射、动态库、匿名映射" class="headerlink" title="5. 内存映射区 (Memory Mapped Region)——文件映射、动态库、匿名映射"></a>5. 内存映射区 (Memory Mapped Region)——文件映射、动态库、匿名映射</h3><p><strong>位置</strong>：内存映射区位于栈的下方。</p><p><strong>用途</strong>：内存映射区用于映射文件、共享内存等资源。此区域存储的是映射到内存的文件或程序中需要访问的共享资源。例如，动态链接库（DLL）或共享库（so）就是通过内存映射来实现的。</p><p><strong>特点</strong>：</p><ul><li><strong>文件映射</strong>：程序可以通过内存映射区直接对映射文件进行读写操作，而无需通过标准的文件 I&#x2F;O 操作，这通常能提高访问效率。</li><li><strong>共享资源</strong>：内存映射区可以映射各种资源，包括文件、设备、共享内存等，这对于实现进程间通信（IPC）和文件缓存等操作非常重要。</li><li><strong>匿名映射</strong>：可以分配不对应实际文件的匿名内存区域，常用于动态分配额外的内存。</li></ul><h3 id="各个区域的总结"><a href="#各个区域的总结" class="headerlink" title="各个区域的总结"></a>各个区域的总结</h3><table><thead><tr><th><strong>区域</strong></th><th><strong>用途</strong></th><th><strong>特点</strong></th></tr></thead><tbody><tr><td><strong>代码段</strong></td><td>存储程序的执行代码</td><td>只读、静态，程序无法修改代码；支持动态生成代码。</td></tr><tr><td><strong>数据段</strong></td><td>存储全局变量、静态变量等静态数据</td><td>包括已初始化数据区和未初始化数据区 (BSS)；程序运行期间长时间存在，由系统管理。</td></tr><tr><td><strong>堆</strong></td><td>用于动态内存分配</td><td>程序员手动管理，生命周期灵活；需要注意内存泄漏问题。</td></tr><tr><td><strong>栈</strong></td><td>存储局部变量和函数调用信息</td><td>自动分配和释放，速度快，空间有限，可能发生栈溢出。</td></tr><tr><td><strong>内存映射区</strong></td><td>用于文件映射、共享内存等资源</td><td>直接内存操作，提高效率；支持进程间通信和动态库加载。</td></tr></tbody></table><hr><h3 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h3><ol><li><strong>栈与堆的增长方向</strong>：栈通常向下增长，堆通常向上增长，但这取决于系统实现。</li><li><strong>BSS 段零初始化</strong>：未初始化的全局和静态变量在程序启动时会被自动初始化为零，这一行为由语言标准规定。</li></ol><hr><h2 id="C-动态内存管理：new、delete-与-malloc、free-的比较"><a href="#C-动态内存管理：new、delete-与-malloc、free-的比较" class="headerlink" title="C++ 动态内存管理：new、delete 与 malloc、free 的比较"></a>C++ 动态内存管理：new、delete 与 malloc、free 的比较</h2><p>C++ 提供了一套独特的内存管理机制，相较于 C 语言的 <code>malloc</code> 和 <code>free</code> 更加灵活和强大。通过 <code>new</code> 和 <code>delete</code>，C++ 可以在进行动态内存分配的同时，还能自动调用构造函数和析构函数，这使得 C++ 在管理对象生命周期时更加安全和高效。<code>operator new</code> 和 <code>operator delete</code> 是底层实现内存分配与释放的关键函数，而 <code>new[]</code> 和 <code>delete[]</code> 使得我们可以管理数组类型的对象。定位 <code>new</code> 则提供了在已分配内存中初始化对象的能力，常常与内存池一起使用。</p><h3 id="C-语言与-C-中内存管理的区别"><a href="#C-语言与-C-中内存管理的区别" class="headerlink" title="C 语言与 C++ 中内存管理的区别"></a>C 语言与 C++ 中内存管理的区别</h3><p>在 C 语言中，内存管理通常依赖于 <code>malloc</code> 和 <code>free</code> 函数。<code>malloc</code> 用于申请动态内存，而 <code>free</code> 用于释放这些内存。然而，C 语言的内存管理不适合处理 C++ 中的对象，因为它不考虑对象的构造和析构。因此，C++ 提出了新的内存管理方式：</p><ul><li><strong>new</strong>：用于动态分配内存并调用构造函数。（开空间 –&gt; <code>operator new</code> –&gt; <code>malloc</code> + 构造函数）</li><li><strong>delete</strong>：用于释放内存并调用析构函数。（析构函数 + 释放空间 –&gt;  <code>operator delete</code> –&gt; <code>free</code>）</li><li><strong>new []</strong>：用于分配数组内存并调用多个构造函数。</li><li><strong>delete []</strong>：用于释放数组内存并调用多个析构函数。</li></ul><p><strong>注意：</strong></p><ul><li>使用 <code>new</code> 和 <code>delete</code> 进行单个对象的内存管理。</li><li>使用 <code>new[]</code> 和 <code>delete[]</code> 进行数组的内存管理。</li><li>确保配对使用：<code>new</code> 配对 <code>delete</code>，<code>new[]</code> 配对 <code>delete[]</code>。</li></ul><h3 id="C-的内存管理机制"><a href="#C-的内存管理机制" class="headerlink" title="C++ 的内存管理机制"></a>C++ 的内存管理机制</h3><h4 id="new-和-delete"><a href="#new-和-delete" class="headerlink" title="new 和 delete"></a>new 和 delete</h4><p>C++ 中的 <code>new</code> 和 <code>delete</code> 操作符不仅仅负责内存的分配和释放，它们还会自动调用对象的构造函数和析构函数。<strong>与 C 语言的 malloc&#x2F;free 对比：</strong></p><ul><li><strong>malloc&#x2F;free</strong> 仅负责内存的分配和释放，不考虑对象的构造和析构。</li><li><strong>new&#x2F;delete</strong> 除了分配和释放内存，还会自动调用构造函数和析构函数，适用于 C++ 中的类和对象。</li></ul><hr><h3 id="new-和-delete-对于自定义类型的特殊性"><a href="#new-和-delete-对于自定义类型的特殊性" class="headerlink" title="new 和 delete 对于自定义类型的特殊性"></a>new 和 delete 对于自定义类型的特殊性</h3><p>对于 C++ 中的自定义类型，<code>new</code> 和 <code>delete</code> 在底层会执行构造和析构操作，这与 <code>malloc</code> 和 <code>free</code> 的区别十分明显。例如，<code>new</code> 会在分配内存后调用对象的构造函数，<code>delete</code> 会在释放内存之前调用析构函数。</p><p><strong>示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;构造函数已调用！&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    ~<span class="built_in">MyClass</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;析构函数已调用！&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MyClass* obj = <span class="keyword">new</span> <span class="built_in">MyClass</span>();  <span class="comment">// 调用构造函数</span></span><br><span class="line">    <span class="keyword">delete</span> obj;  <span class="comment">// 调用析构函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，<code>new</code> 分配了内存并调用了 <code>MyClass</code> 的构造函数，而 <code>delete</code> 释放内存并调用了析构函数。</p><hr><h3 id="operator-new-和-operator-delete"><a href="#operator-new-和-operator-delete" class="headerlink" title="operator new 和 operator delete"></a><code>operator new</code> 和 <code>operator delete</code></h3><p><code>new</code> 和 <code>delete</code> 操作符是用户用于内存管理的工具，而 <code>operator new</code> 和 <code>operator delete</code> 是系统提供的全局函数，它们实现了内存分配和释放的底层逻辑。具体来说：</p><ul><li><strong>operator new</strong>：负责申请内存空间，实际是通过 <code>malloc</code> 来分配空间。</li><li><strong>operator delete</strong>：负责释放内存空间，实际是通过 <code>free</code> 来释放空间。</li></ul><p><strong><code>operator new</code> 的工作原理</strong></p><ol><li>调用 <code>malloc</code> 来申请内存空间。</li><li>如果 <code>malloc</code> 成功返回内存地址，<code>operator new</code> 返回该地址；如果失败，<code>operator new</code> 会通过用户定义的应对措施继续尝试分配内存，否则抛出 <code>std::bad_alloc</code> 异常。</li></ol><p><strong><code>operator delete</code> 的工作原理</strong></p><ol><li>调用 <code>free</code> 来释放内存空间。</li><li>如果需要，执行额外的清理工作，如释放与内存块相关的资源。</li></ol><hr><h3 id="new-和-delete-：处理数组"><a href="#new-和-delete-：处理数组" class="headerlink" title="new [] 和 delete []：处理数组"></a>new [] 和 delete []：处理数组</h3><p>C++ 还提供了 <code>new[]</code> 和 <code>delete[]</code> 用于分配和释放数组。这些操作符与 <code>new</code> 和 <code>delete</code> 类似，但会针对数组元素执行额外的构造和析构操作。</p><p><strong><code>new[]</code> 和 <code>delete[]</code> 的原理</strong></p><ul><li><strong>new []</strong>：申请连续的内存空间，并对每个元素调用构造函数。</li><li><strong>delete []</strong>：释放连续的内存空间，并对每个元素调用析构函数。</li></ul><p><strong>示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* arr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];  <span class="comment">// 使用 new [] 申请数组</span></span><br><span class="line"><span class="keyword">delete</span>[] arr;  <span class="comment">// 使用 delete [] 释放数组</span></span><br></pre></td></tr></table></figure><p>初始化：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span>* arr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>] &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;;<span class="comment">// 申请并初始化</span></span><br><span class="line"><span class="keyword">delete</span>[] arr;<span class="comment">//释放</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="定位-new-Placement-new"><a href="#定位-new-Placement-new" class="headerlink" title="定位 new (Placement new)"></a>定位 new (Placement new)</h3><p>C++ 提供了定位 <code>new</code> 表达式，允许我们在已经分配的内存空间上调用构造函数。这通常用于内存池中，因为内存池管理的内存块不会自动初始化，所以需要显式调用构造函数来初始化对象。</p><p><strong>使用格式：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> (place_address) type;  <span class="comment">// 在指定地址 place_address 上构造对象</span></span><br><span class="line"><span class="keyword">new</span> (place_address) <span class="built_in">type</span>(initializer-list);  <span class="comment">// 在指定地址并用初始化列表构造对象</span></span><br></pre></td></tr></table></figure><p><strong>定位 new 的常见场景</strong></p><ul><li><strong>内存池管理</strong>：内存池为对象分配原始内存，但并不初始化对象。定位 <code>new</code> 可用于在这些原始内存块上调用构造函数，从而初始化对象。</li></ul><blockquote><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><h3 id="1-malloc-calloc-realloc-的区别？"><a href="#1-malloc-calloc-realloc-的区别？" class="headerlink" title="1. malloc&#x2F;calloc&#x2F;realloc 的区别？"></a>1. malloc&#x2F;calloc&#x2F;realloc 的区别？</h3><p><strong><code>malloc</code></strong></p><ul><li><p>用于分配一块指定大小的内存，但 <strong>不会初始化这块内存</strong>，因此分配的内存中可能包含随机值（内存的旧数据）。</p></li><li><p>返回一个 <code>void*</code> 类型的指针，需要显式地转换为所需的指针类型。</p></li><li><p>示例：</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* ptr = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="number">10</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>)); <span class="comment">// 分配 10 个 int 大小的内存</span></span><br></pre></td></tr></table></figure><p><strong><code>calloc</code></strong></p><ul><li>与 <code>malloc</code> 功能相似，但有两个主要区别：</li></ul><ol><li><code>calloc</code> 会将分配的内存初始化为零。</li><li><code>calloc</code> 需要两个参数：第一个参数是分配的元素数量，第二个参数是每个元素的大小。</li></ol><ul><li>示例：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* ptr = (<span class="type">int</span>*)<span class="built_in">calloc</span>(<span class="number">10</span>, <span class="keyword">sizeof</span>(<span class="type">int</span>)); <span class="comment">// 分配 10 个 int 大小的内存，并初始化为 0</span></span><br></pre></td></tr></table></figure><p><strong><code>realloc</code></strong></p><ul><li><p>用于重新调整由 <code>malloc</code> 或 <code>calloc</code> 分配的内存大小。</p></li><li><p>如果新大小比原来的小，则多余的内存会被释放；如果新大小比原来的大，系统会尝试扩展内存，如果无法扩展，会分配新的内存块并复制旧内存的数据。</p></li><li><p>注意：<code>realloc</code> 可能返回一个新的指针地址，因此需要重新赋值，并小心处理内存泄漏。</p></li><li><p>示例：</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* ptr = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="number">5</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">ptr = (<span class="type">int</span>*)<span class="built_in">realloc</span>(ptr, <span class="number">10</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>)); <span class="comment">// 调整大小为 10 个 int</span></span><br></pre></td></tr></table></figure><p><strong>小结</strong></p><ul><li><code>malloc</code>：分配内存但不初始化。</li><li><code>calloc</code>：分配内存并初始化为零。</li><li><code>realloc</code>：调整已分配内存的大小。</li></ul><hr><h3 id="2-malloc-的实现原理？（glibc-中-malloc-实现原理）"><a href="#2-malloc-的实现原理？（glibc-中-malloc-实现原理）" class="headerlink" title="2. malloc 的实现原理？（glibc 中 malloc 实现原理）"></a>2. malloc 的实现原理？（<a href="https://www.bilibili.com/video/BV117411w7o2/?vd_source=47fe2fe2f10c4e806e38c62553037767">glibc 中 malloc 实现原理</a>）</h3><p><strong>核心机制</strong></p><ol><li>堆区内存管理：</li></ol><ul><li>程序运行时，操作系统会为进程分配一个堆区，堆区的大小通常是动态调整的。<code>malloc</code> 通过管理堆区来实现动态内存分配。</li><li>操作系统的系统调用（如 <code>brk</code> 或 <code>mmap</code>）是 <code>malloc</code> 的底层实现工具。</li></ul><ol start="2"><li>内存分配算法：</li></ol><ul><li><strong>首次适配 (First Fit)</strong>：寻找第一个大小合适的空闲块分配内存。</li><li><strong>最佳适配 (Best Fit)</strong>：寻找最接近所需大小的空闲块分配内存。</li><li><strong>最差适配 (Worst Fit)</strong>：寻找最大的空闲块分配内存。</li></ul><ol start="3"><li>内存碎片：</li></ol><ul><li>长时间运行的程序中，频繁的内存分配和释放可能会造成 <strong>内存碎片</strong>（许多小的、无法使用的空闲块）。</li><li>为减少碎片，<code>malloc</code> 通常会合并相邻的空闲块（内存回收时）。</li></ul><p><strong>实现注意点</strong></p><ul><li><strong>对齐</strong>：分配的内存通常按照特定字节对齐（如 8 字节或 16 字节对齐），以提高内存访问效率。</li><li><strong>元数据</strong>：<code>malloc</code> 会在分配的内存块中存储一些元数据（如块大小、状态等），以便管理分配和释放。</li></ul><hr><h3 id="3-malloc-free-和-new-delete-的区别？"><a href="#3-malloc-free-和-new-delete-的区别？" class="headerlink" title="3. malloc&#x2F;free 和 new&#x2F;delete 的区别？"></a>3. malloc&#x2F;free 和 new&#x2F;delete 的区别？</h3><h4 id="malloc-free"><a href="#malloc-free" class="headerlink" title="malloc&#x2F;free"></a><strong>malloc&#x2F;free</strong></h4><ol><li><code>malloc</code> 和 <code>free</code> 是标准库中的函数，属于 C 语言内存分配机制。</li><li><code>malloc</code> 只分配内存，不会调用构造函数或初始化对象。</li><li><code>free</code> 只释放内存，不会调用析构函数。</li><li><code>malloc</code> 的返回值是 <code>void*</code>，需要显式类型转换。</li></ol><h4 id="new-delete"><a href="#new-delete" class="headerlink" title="new&#x2F;delete"></a><strong>new&#x2F;delete</strong></h4><ol><li><code>new</code> 和 <code>delete</code> 是 C++ 中的运算符，用于分配和释放内存。</li><li><code>new</code> 会为对象分配内存并调用构造函数进行初始化。</li><li><code>delete</code> 会释放对象的内存并调用析构函数。</li><li><code>new</code> 返回的是指定类型的指针，无需类型转换。</li><li><code>new</code> 失败时会抛出 <code>std::bad_alloc</code> 异常（可以用 <code>std::nothrow</code> 避免抛出异常，改为返回 <code>nullptr</code>）。</li></ol><p><strong>示例代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// malloc/free 示例</span></span><br><span class="line">&gt;<span class="type">int</span>* arr = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="number">10</span> * <span class="built_in">sizeof</span>(<span class="type">int</span>)); <span class="comment">// 分配 10 个 int 的内存</span></span><br><span class="line">&gt;<span class="built_in">free</span>(arr);                                 <span class="comment">// 释放内存</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// new/delete 示例</span></span><br><span class="line">&gt;<span class="type">int</span>* arr_new = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>]; <span class="comment">// 分配 10 个 int 并初始化为默认值（未定义行为）</span></span><br><span class="line">&gt;<span class="keyword">delete</span>[] arr_new;           <span class="comment">// 释放数组内存</span></span><br></pre></td></tr></table></figure><hr><h3 id="4-malloc-free-和-new-delete-的共同点？"><a href="#4-malloc-free-和-new-delete-的共同点？" class="headerlink" title="4. malloc&#x2F;free 和 new&#x2F;delete 的共同点？"></a>4. malloc&#x2F;free 和 new&#x2F;delete 的共同点？</h3><ul><li>都从 <strong>堆区</strong> 分配内存。</li><li>都需要程序员手动释放内存，避免内存泄漏。</li></ul><hr><h3 id="主要区别总结"><a href="#主要区别总结" class="headerlink" title="主要区别总结"></a>主要区别总结</h3><table><thead><tr><th>特性</th><th>malloc&#x2F;free</th><th>new&#x2F;delete</th></tr></thead><tbody><tr><td><strong>类型</strong></td><td>函数</td><td>运算符</td></tr><tr><td><strong>初始化</strong></td><td>不初始化内存</td><td>初始化内存（调用构造函数）</td></tr><tr><td><strong>类型转换</strong></td><td>返回 <code>void*</code>，需强制转换类型</td><td>返回指定类型指针，无需强制转换</td></tr><tr><td><strong>失败处理</strong></td><td>返回 <code>NULL</code>，需手动检查</td><td>抛出 <code>std::bad_alloc</code> 异常（或返回 <code>nullptr</code>）</td></tr><tr><td><strong>构造和析构函数</strong></td><td>不调用构造或析构函数</td><td>自动调用构造函数和析构函数</td></tr><tr><td><strong>数组内存管理</strong></td><td>需要手动计算大小</td><td>自动计算大小（支持 <code>new[]</code>&#x2F;<code>delete[]</code>）</td></tr></tbody></table><p><strong>注意事项</strong></p><ol><li><strong>混用问题</strong>：</li></ol><ul><li><p>不要混用 <code>malloc</code> 和 <code>delete</code>，或 <code>new</code> 和 <code>free</code>，否则可能导致未定义行为。</p></li><li><p>示例（错误用法）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* ptr = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="keyword">delete</span> ptr; <span class="comment">// 错误：malloc 分配的内存不能用 delete 释放</span></span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li><strong><code>new[]</code> 和 <code>delete[]</code> 的配对</strong>：</li></ol><ul><li>如果通过 <code>new[]</code> 分配数组，必须使用 <code>delete[]</code> 释放；否则可能导致析构函数未被正确调用或内存泄漏。</li></ul></blockquote><h2 id="C-C-的内存泄漏"><a href="#C-C-的内存泄漏" class="headerlink" title="C&#x2F;C++的内存泄漏"></a>C&#x2F;C++的内存泄漏</h2><p>C&#x2F;C++中的内存泄漏是指程序在运行时动态分配的内存没有正确释放，导致无法再使用这些内存，从而浪费了宝贵的系统资源。这类问题尤其在使用堆内存分配时比较常见。</p><h3 id="堆内存泄漏（Heap-Leak）"><a href="#堆内存泄漏（Heap-Leak）" class="headerlink" title="堆内存泄漏（Heap Leak）"></a>堆内存泄漏（Heap Leak）</h3><p>堆内存是程序在运行时通过动态内存分配（如 <code>malloc</code>, <code>calloc</code>, <code>realloc</code>, <code>new</code> 等）从操作系统的堆区分配的内存。当程序使用完这些内存后，必须显式地通过 <code>free</code> 或 <code>delete</code> 来释放内存。如果程序没有正确释放这些内存，它们将无法再被使用，就会导致堆内存泄漏。</p><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* ptr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>]; <span class="comment">// 分配堆内存</span></span><br><span class="line"><span class="comment">// ... 使用 ptr</span></span><br><span class="line"><span class="comment">// 忘记调用 delete [] ptr;</span></span><br></pre></td></tr></table></figure><p>在这个例子中，如果程序员忘记调用 <code>delete[] ptr</code> 来释放分配的内存，程序会导致堆内存泄漏。每次这样的错误都会导致系统中未被使用的内存空间增加，从而影响程序的性能，甚至可能导致程序崩溃。</p><h3 id="系统资源泄漏"><a href="#系统资源泄漏" class="headerlink" title="系统资源泄漏"></a>系统资源泄漏</h3><p>除了内存泄漏外，还有一种资源泄漏的情况，即程序未能释放操作系统分配的资源。比如文件描述符、套接字、管道等系统资源，在使用后应通过适当的关闭操作释放。否则，这些资源也会被“泄漏”，占用有限的系统资源，可能导致系统性能降低或崩溃。</p><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FILE* file = <span class="built_in">fopen</span>(<span class="string">&quot;somefile.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"><span class="comment">// ... 操作文件</span></span><br><span class="line"><span class="comment">// 忘记关闭文件</span></span><br><span class="line"><span class="comment">// fclose(file);</span></span><br></pre></td></tr></table></figure><p>在上面的例子中，如果忘记关闭文件，文件描述符将会被泄漏，可能最终耗尽可用的文件句柄，导致程序无法打开更多的文件。</p><h3 id="普通程序与长期运行程序中的内存泄漏影响"><a href="#普通程序与长期运行程序中的内存泄漏影响" class="headerlink" title="普通程序与长期运行程序中的内存泄漏影响"></a>普通程序与长期运行程序中的内存泄漏影响</h3><ul><li><strong>普通程序</strong>：对于普通程序，内存泄漏的影响通常比较小。如果程序运行完毕后正常退出，操作系统会回收所有分配的资源。虽然内存泄漏会导致程序占用多余的内存，但由于程序在结束时释放了所有资源，通常不会造成太大影响。此类程序通常在一次运行中分配和释放内存，相对较短生命周期，内存泄漏的问题不容易显现。</li><li><strong>长期运行的程序</strong>：对于长期运行的程序，内存泄漏的影响则非常严重。例如，<strong>游戏服务</strong>、<strong>电商服务</strong>、<strong>金融系统</strong> 等，这些程序需要长时间稳定运行。如果发生内存泄漏，随着时间的推移，未释放的内存会不断积累，导致程序占用的内存越来越大，从而可能导致系统资源耗尽，程序崩溃，甚至系统崩溃。长期运行的服务需要特别关注内存泄漏问题，因为它们的稳定性和高效性至关重要。</li></ul><hr><h3 id="如何检测内存泄漏"><a href="#如何检测内存泄漏" class="headerlink" title="如何检测内存泄漏"></a>如何检测内存泄漏</h3><h4 id="1-使用-CrtDumpMemoryLeaks-在-Visual-Studio-中"><a href="#1-使用-CrtDumpMemoryLeaks-在-Visual-Studio-中" class="headerlink" title="1. 使用 _CrtDumpMemoryLeaks() (在 Visual Studio 中)"></a>1. 使用 _CrtDumpMemoryLeaks() (在 Visual Studio 中)</h4><p>在 Visual Studio 中，可以使用 <code>_CrtDumpMemoryLeaks()</code> 函数来简单检测内存泄漏。它会在程序退出时输出所有泄漏的内存块大小，但不会提供泄漏的详细位置信息，因此仅能检测到大概的泄漏情况，无法精确找到具体发生泄漏的代码行。</p><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;crtdbg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    _CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span>* p = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>]; <span class="comment">// 动态分配内存</span></span><br><span class="line">    <span class="comment">// 不释放内存，程序退出时会报告内存泄漏</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-使用第三方工具"><a href="#2-使用第三方工具" class="headerlink" title="2. 使用第三方工具"></a>2. 使用第三方工具</h4><p>对于复杂的项目，可能会有多个地方发生内存泄漏，手动追踪泄漏点非常困难。这时，可以借助一些内存泄漏检测工具，如 Valgrind、AddressSanitizer 等，来帮助定位内存泄漏。这些工具能提供更准确的泄漏位置，帮助开发人员快速定位问题。</p><hr><h3 id="如何避免内存泄漏"><a href="#如何避免内存泄漏" class="headerlink" title="如何避免内存泄漏"></a>如何避免内存泄漏</h3><h4 id="1-良好的设计规范"><a href="#1-良好的设计规范" class="headerlink" title="1. 良好的设计规范"></a>1. 良好的设计规范</h4><p>在程序设计初期，养成良好的内存管理规范至关重要。所有分配的内存都应当在合适的时机释放。如果可能，避免手动内存管理，使用智能指针来自动管理内存。</p><h4 id="2-使用-RAII（资源获取即初始化）思想"><a href="#2-使用-RAII（资源获取即初始化）思想" class="headerlink" title="2. 使用 RAII（资源获取即初始化）思想"></a>2. 使用 RAII（资源获取即初始化）思想</h4><p>RAII 是一种编程思想，在这种思想中，资源的获取与对象的生命周期绑定，资源在对象创建时分配，在对象销毁时释放。C++中的智能指针（如 <code>std::unique_ptr</code>, <code>std::shared_ptr</code>）可以自动管理内存，避免内存泄漏。</p><p>例如，使用 <code>std::unique_ptr</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;<span class="type">int</span>[]&gt; <span class="title">arr</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>])</span></span>; <span class="comment">// 内存由 unique_ptr 自动管理</span></span><br><span class="line">    <span class="comment">// 不需要手动释放内存，智能指针会在超出作用域时自动释放</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-内存管理库"><a href="#3-内存管理库" class="headerlink" title="3. 内存管理库"></a>3. 内存管理库</h4><p>一些公司或项目会实现私有的内存管理库，这些库通常带有内存泄漏检测的功能，可以在运行时监控内存分配和释放，及时发现和报告内存泄漏。</p><h4 id="4-使用内存泄漏工具"><a href="#4-使用内存泄漏工具" class="headerlink" title="4. 使用内存泄漏工具"></a>4. 使用内存泄漏工具</h4><p>如前所述，当内存泄漏发生时，使用工具来检测和分析程序是一个有效的方式。这些工具可以帮助开发人员准确找出泄漏的内存块，并进行修复。</p><hr><p>内存泄漏是 C&#x2F;C++ 编程中常见的问题，它会导致程序占用越来越多的内存，影响系统性能，甚至导致系统崩溃。解决内存泄漏的方法可以分为两类：</p><ol><li><strong>事前预防型</strong>：通过良好的设计规范，使用智能指针等资源管理技术避免内存泄漏。</li><li><strong>事后查错型</strong>：使用内存泄漏检测工具来发现和修复内存泄漏。</li></ol>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 内存管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>003 系统和入门指令</title>
      <link href="/posts/42463.html"/>
      <url>/posts/42463.html</url>
      
        <content type="html"><![CDATA[<h2 id="操作系统（OS）的基础概念"><a href="#操作系统（OS）的基础概念" class="headerlink" title="操作系统（OS）的基础概念"></a>操作系统（OS）的基础概念</h2><p>操作系统是计算机硬件和软件之间的中介，它负责管理计算机硬件资源并为应用程序提供一个运行环境。简单来说，操作系统的目标是使计算机变得更好用。它使得硬件的复杂性对用户透明，提供更高效的资源管理，并使应用程序能够正常运行。</p><h3 id="1-操作系统的层次结构"><a href="#1-操作系统的层次结构" class="headerlink" title="1. 操作系统的层次结构"></a>1. 操作系统的层次结构</h3><p>操作系统通常由多个层次构成，每一层提供不同的功能：</p><ol><li><strong>硬件层（硬件）</strong><br> 这是计算机的基础物理部分，包括 CPU、内存、硬盘、显示器、键盘等。硬件直接提供计算和存储资源。</li><li><strong>设备驱动层</strong><br> 这一层负责控制和管理硬件设备，如声卡、显卡、打印机等。操作系统通过设备驱动程序与硬件进行通信，确保硬件的正常运行。</li><li><strong>操作系统层</strong><br> 这一层是操作系统的核心部分，负责管理硬件资源，调度进程，提供文件管理、内存管理等基本功能。常见的操作系统包括 Windows、Linux、macOS 等。</li><li><strong>应用软件层</strong><br> 最顶层是应用软件，它包括各种应用程序，如 Word、Matlab 等。用户通过这些软件与计算机互动，完成各种任务。</li></ol><h3 id="2-操作系统的功能"><a href="#2-操作系统的功能" class="headerlink" title="2. 操作系统的功能"></a>2. 操作系统的功能</h3><ol><li><strong>资源管理</strong><br> 操作系统需要高效管理计算机的资源，如 CPU 时间、内存、磁盘存储等。它通过调度算法分配资源，确保每个进程能够公平、高效地使用资源。</li><li><strong>进程管理</strong><br> 操作系统负责管理和调度各个运行的进程，确保它们按优先级运行，并避免资源冲突。</li><li><strong>文件系统管理</strong><br> 操作系统提供一个文件系统，用于组织和管理存储在磁盘上的数据。它确保数据能够有效地存储和检索。</li><li><strong>用户界面</strong><br> 操作系统提供一个用户界面，让用户能够与计算机交互。传统的图形用户界面（GUI）或命令行界面（CLI）让用户输入指令并接收反馈。</li></ol><h3 id="3-常见操作系统"><a href="#3-常见操作系统" class="headerlink" title="3. 常见操作系统"></a>3. 常见操作系统</h3><ul><li><strong>Windows</strong>：广泛应用于个人电脑和办公环境，是最常见的桌面操作系统。</li><li><strong>Linux</strong>：一个开源的操作系统，具有高度的可定制性，广泛应用于服务器和嵌入式系统。</li><li><strong>macOS</strong>：苹果公司开发的操作系统，具有优雅的图形界面和强大的开发工具，广泛应用于苹果设备。</li></ul><h3 id="4-一个好的操作系统衡量指标："><a href="#4-一个好的操作系统衡量指标：" class="headerlink" title="4. 一个好的操作系统衡量指标："></a>4. 一个好的操作系统衡量指标：</h3><ol><li><strong>性能</strong>：快速响应、有效的资源利用、高吞吐量。</li><li><strong>稳定性</strong>：高可靠性、容错能力强、进程隔离良好。</li><li><strong>安全性</strong>：强大的权限管理、数据保护、及时的漏洞修复。</li><li><strong>可扩展性</strong>：支持多种硬件、兼容多种软件、有效管理多任务。</li><li><strong>易用性</strong>：直观的用户界面、完善的文档支持、灵活的配置管理工具。</li><li><strong>支持和维护</strong>：强大的社区支持、定期更新、丰富的开发者生态。</li><li><strong>兼容性</strong>：跨平台兼容和向后兼容，确保广泛的软件和硬件支持。</li><li><strong>资源管理</strong>：高效的内存、磁盘和 CPU 调度管理。</li></ol><h4 id="我们的所有的软件行为，全部都要-自顶向下（应用软件-–-操作系统-–-设备驱动-–-硬件）-贯穿-计算机的软硬件结构，几乎我们的所有的软件行为，未来都和操作系统直接或者间接相关！"><a href="#我们的所有的软件行为，全部都要-自顶向下（应用软件-–-操作系统-–-设备驱动-–-硬件）-贯穿-计算机的软硬件结构，几乎我们的所有的软件行为，未来都和操作系统直接或者间接相关！" class="headerlink" title="我们的所有的软件行为，全部都要 自顶向下（应用软件 –&gt; &#x3D;&#x3D;操作系统&#x3D;&#x3D; –&gt; 设备驱动 –&gt; 硬件）&#x3D;&#x3D;贯穿&#x3D;&#x3D; 计算机的软硬件结构，几乎我们的所有的软件行为，未来都和操作系统直接或者间接相关！"></a>我们的所有的软件行为，全部都要 <strong>自顶向下（应用软件 –&gt; &#x3D;&#x3D;操作系统&#x3D;&#x3D; –&gt; 设备驱动 –&gt; 硬件）&#x3D;&#x3D;贯穿&#x3D;&#x3D;</strong> 计算机的软硬件结构，几乎我们的所有的软件行为，未来都和操作系统直接或者间接相关！</h4><blockquote><h2 id="传道解惑"><a href="#传道解惑" class="headerlink" title="传道解惑"></a>传道解惑</h2><h3 id="Q1：为什么要有操作系统？"><a href="#Q1：为什么要有操作系统？" class="headerlink" title="Q1：为什么要有操作系统？"></a>Q1：为什么要有操作系统？</h3><ul><li><strong>操作系统的核心工作</strong>：操作系统通过管理硬件资源（如 CPU、内存、硬盘等）来保证计算机的高效运行。</li><li><strong>目标</strong>：通过良好的资源管理，提供给用户一个稳定、快速且安全的工作环境。</li><li><strong>稳定、快速、安全</strong>：这三个关键词表明，操作系统不仅要确保系统不容易崩溃，还要在处理任务时迅速反应，并保护用户数据的安全性。</li></ul><p>简而言之，操作系统的核心任务是协调硬件和软件的交互，确保计算机可以高效、稳定并安全地执行任务。</p><p>操作系统的发展历史表明，<strong>先有指令</strong>（即命令行界面），再有图形用户界面（GUI）。这是因为操作系统最初的设计目标是通过命令行接口与计算机进行交互，而图形界面是为了提高用户体验而逐渐发展出来的。</p><h3 id="Q2：为什么先有指令，再有图形界面？"><a href="#Q2：为什么先有指令，再有图形界面？" class="headerlink" title="Q2：为什么先有指令，再有图形界面？"></a>Q2：为什么先有指令，再有图形界面？</h3><h4 id="1-指令先行："><a href="#1-指令先行：" class="headerlink" title="1. 指令先行："></a>1. 指令先行：</h4><ul><li>早期的计算机操作系统（如 UNIX、DOS 等）主要依赖命令行界面（CLI）。用户通过输入指令（如 <code>ls</code>、<code>dir</code> 等）来与操作系统进行交互。这种方式对计算机硬件的控制更加精确、灵活，适用于开发人员和技术人员。</li></ul><h4 id="2-图形界面后发展："><a href="#2-图形界面后发展：" class="headerlink" title="2. 图形界面后发展："></a>2. 图形界面后发展：</h4><ul><li>随着计算机技术的发展，尤其是在个人计算机普及后，用户开始需要更加直观和易用的操作方式。图形用户界面（GUI）应运而生，典型的例子如 Mac OS、Windows 等。GUI 通过图标、窗口、按钮等元素提供了更为友好的用户体验。</li></ul><h4 id="3-为什么？"><a href="#3-为什么？" class="headerlink" title="3. 为什么？"></a>3. 为什么？</h4><ul><li><strong>技术限制</strong>：早期的计算机资源有限，硬件和图形显示技术还不成熟，因此以文字和命令行的方式与计算机交互是最有效的。</li><li><strong>用户群体</strong>：早期计算机主要用于科研、军事和技术开发，用户多为专业人员，他们更习惯于通过指令行与计算机沟通。</li><li><strong>演化需求</strong>：随着计算机的普及，更多非技术用户开始使用计算机，需求变得更加注重易用性，于是图形界面得以逐渐发展并成为主流。</li></ul><p>因此，指令是操作系统的基础，而图形界面是在后期发展起来的，目的是让操作系统更加易用、亲民。</p></blockquote><hr><h2 id="Linux-下基础命令详解"><a href="#Linux-下基础命令详解" class="headerlink" title="Linux 下基础命令详解"></a>Linux 下基础命令详解</h2><p>在 Linux 操作系统中，有许多常用的命令帮助用户管理文件系统、执行操作及进行系统管理。本文将介绍一些常见的命令以及如何使用它们，帮助初学者更好地理解和使用 Linux。</p><p><strong>初见：</strong></p><ul><li><strong>ls</strong>：显示当前文件夹下的文件和目录。</li><li><strong>pwd</strong>：显示当前所在的目录路径。</li><li><strong>mkdir 新文件夹名称</strong>：在当前位置创建一个新的文件夹。</li><li><strong>cd 目录</strong>：进入指定目录。</li></ul><p>如果你想创建的是文件而非文件夹，可以使用命令 <code>touch 文件名称</code> 来创建一个空文件。</p><h3 id="1-ls-指令——文件和目录的显示命令"><a href="#1-ls-指令——文件和目录的显示命令" class="headerlink" title="1. ls 指令——文件和目录的显示命令"></a>1. ls 指令——文件和目录的显示命令</h3><p><strong>语法</strong>: <code>ls [选项] [目录或文件]</code>  </p><ul><li><p><strong>ls</strong>：列出当前目录下的文件和目录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span></span><br></pre></td></tr></table></figure></li><li><p><strong>ls -l</strong>：以长格式显示目录内容，包含详细的文件信息（如权限、所有者、文件大小等）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -l</span><br></pre></td></tr></table></figure></li><li><p><strong>ll</strong>：<code>ll</code> 是 <code>ls -l</code> 的简写，执行结果相同。它是许多 Linux 系统中为了简化命令输入而创建的别名。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ll</span><br></pre></td></tr></table></figure></li><li><p><strong>ls -a</strong>：显示包括隐藏文件在内的所有文件（以 <code>.</code> 开头的文件为隐藏文件）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -a</span><br></pre></td></tr></table></figure></li><li><p><strong>ls -al 或 ls -la</strong>：这两个命令等价，表示显示所有文件，包括隐藏文件，且以长格式显示。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -al</span><br></pre></td></tr></table></figure></li></ul><table><thead><tr><th align="center"><code>ls</code> 命令</th><th>说明</th></tr></thead><tbody><tr><td align="center"><code>ls -a</code></td><td>列出目录下的所有文件，包括以 <code>.</code> 开头的隐藏文件。</td></tr><tr><td align="center"><code>ls -d</code></td><td>将目录像文件一样显示，而不是显示其内容。例如：<code>ls -d 指定目录</code>。</td></tr><tr><td align="center"><code>ls -i</code></td><td>输出文件的 inode 节点的索引信息。例如：<code>ls -ai 指定文件</code>。</td></tr><tr><td align="center"><code>ls -k</code></td><td>以 k 字节的形式显示文件大小。例如：<code>ls -alk</code> 指定文件。</td></tr><tr><td align="center"><code>ls -l</code></td><td>列出文件的详细信息。</td></tr><tr><td align="center"><code>ls -n</code></td><td>用数字的 UID、GID 代替名称（介绍 UID、GID）。</td></tr><tr><td align="center"><code>ls -F</code></td><td>在每个文件名后附加一个字符以说明该文件的类型，<code>*</code> 表示可执行的普通文件，<code>/</code> 表示目录，&#96;</td></tr><tr><td align="center"><code>ls -r</code></td><td>对目录反向排序。</td></tr><tr><td align="center"><code>ls -t</code></td><td>以时间排序。</td></tr><tr><td align="center"><code>ls -s</code></td><td>在文件名后输出该文件的大小（大&#x2F;小排序，如如何找到目录下最大的文件）。</td></tr><tr><td align="center"><code>ls -R</code></td><td>列出所有子目录下的文件（递归）。</td></tr><tr><td align="center"><code>ls -1</code></td><td>一行输出一个文件。</td></tr></tbody></table><h3 id="2-文件类型说明"><a href="#2-文件类型说明" class="headerlink" title="2. 文件类型说明"></a>2. 文件类型说明</h3><ul><li><strong>d</strong>：表示一个目录。</li><li><strong>-</strong>：表示一个普通文件。</li><li><strong>以 . 开头的文件</strong>：这些文件是隐藏文件，通常用于存储配置或系统信息。</li></ul><h3 id="3-路径说明"><a href="#3-路径说明" class="headerlink" title="3. 路径说明"></a>3. 路径说明</h3><ul><li>相对路径与绝对路径：<ul><li><strong>绝对路径</strong>：从根目录 <code>/</code> 开始的路径，具有唯一性。在任何环境中都能准确指向一个文件或目录。例如：<code>/home/user/docs/file.txt</code>。</li><li><strong>相对路径</strong>：相对于当前所在目录的路径。路径会根据当前所在目录的不同而有所变化。相对路径更短，但在路径变动时可能失效。</li></ul></li><li>. 和 .. 的含义：<ul><li><code>.</code>：表示当前目录。</li><li><code>..</code>：表示上一级目录。</li></ul></li></ul><h3 id="4-用户管理命令和-cd-指令"><a href="#4-用户管理命令和-cd-指令" class="headerlink" title="4. 用户管理命令和 cd 指令"></a>4. 用户管理命令和 <code>cd</code> 指令</h3><ul><li><strong>whoami</strong>：显示当前登录的用户名。</li><li><strong>家目录</strong>：在 Linux 系统中，每个用户都有一个家目录。普通用户的家目录通常位于 <code>/home/用户名</code>，而超级用户（root）的家目录通常是 <code>/root</code>。</li></ul><table><thead><tr><th align="center"><code>cd</code> 命令</th><th>描述</th></tr></thead><tbody><tr><td align="center"><code>cd ..</code></td><td>返回上级目录</td></tr><tr><td align="center"><code>cd /home/litao/linux/</code></td><td>绝对路径</td></tr><tr><td align="center"><code>cd ../day02/</code></td><td>相对路径</td></tr><tr><td align="center"><code>cd ~</code></td><td>进入当前用户家目录，<code>~</code> 是当前用户家目录的快捷表示</td></tr><tr><td align="center"><code>cd -</code></td><td>返回最近访问目录（切换回上一次所在的目录）</td></tr></tbody></table><h3 id="5-文件和目录操作命令"><a href="#5-文件和目录操作命令" class="headerlink" title="5. 文件和目录操作命令"></a>5. 文件和目录操作命令</h3><ul><li><p><strong>touch 文件</strong>：创建一个空文件。如果文件已经存在，<code>touch</code> 会更新文件的访问时间和修改时间。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">touch</span> newfile.txt</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">touch 命令</th><th>描述</th></tr></thead><tbody><tr><td align="center"><code>-a</code></td><td>–time &#x3D; atime 或 –time &#x3D; access，只更新访问时间。</td></tr><tr><td align="center"><code>-c</code></td><td>–no-create，不创建任何文件。</td></tr><tr><td align="center"><code>-d</code></td><td>使用指定的日期时间，而非当前时间。</td></tr><tr><td align="center"><code>-f</code></td><td>该参数将忽略不予处理，仅负责解决 BSD 版本的 touch 命令的兼容性问题。</td></tr><tr><td align="center"><code>-m</code></td><td>–time &#x3D; mtime 或 –time &#x3D; modify，只更新修改时间。</td></tr><tr><td align="center"><code>-r</code></td><td>把指定文件或目录的日期时间，统一成文件或目录的日期时间。</td></tr><tr><td align="center"><code>-t</code></td><td>使用指定的日期时间，而非当前时间。</td></tr></tbody></table></li><li><p><strong>mkdir 目录名</strong>：创建一个新目录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> newdir</span><br></pre></td></tr></table></figure></li><li><p><strong>mkdir –p test&#x2F;test1 :</strong> 递归建立多个目录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> –p <span class="built_in">test</span>/test1</span><br></pre></td></tr></table></figure></li></ul><p><strong>rmdir 目录名</strong>：删除一个空目录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rmdir</span> emptydir</span><br></pre></td></tr></table></figure><ul><li><p><strong>rm 文件</strong>：删除指定文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> file.txt</span><br></pre></td></tr></table></figure></li><li><p><strong>rm -f 文件</strong>：强制删除文件，不会提示确认。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> -f file.txt</span><br></pre></td></tr></table></figure></li><li><p><strong>rm -r 目录</strong>：递归删除目录及其中的所有文件和子目录。注意：使用 <code>rm</code> 删除文件时不能直接删除目录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> -r directory</span><br></pre></td></tr></table></figure></li><li><p><strong>rm -rf 目录</strong>：强制递归删除目录及其内容，不会询问是否确认删除。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> -rf directory</span><br></pre></td></tr></table></figure></li></ul><h3 id="6-安装与显示目录结构"><a href="#6-安装与显示目录结构" class="headerlink" title="6. 安装与显示目录结构"></a>6. 安装与显示目录结构</h3><ul><li><p><strong>yum install -y tree</strong>：安装 <code>tree</code> 命令（需要 root 权限）。<code>tree</code> 命令用于以树状图形式显示目录结构。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y tree</span><br></pre></td></tr></table></figure></li><li><p><strong>tree</strong>：显示目录结构的树状图。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tree</span><br></pre></td></tr></table></figure></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Linux 提供了一系列强大的命令帮助用户管理文件和目录。理解这些命令的功能及使用场景，将极大提高操作效率。本文介绍了一些基本的命令，它们包括文件和目录的查看、管理、删除命令以及路径的操作方式。掌握这些命令是使用 Linux 系统的基础，并为更高级的操作奠定了基础。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>002 创建普通账户（为朋友创建、删除账户）</title>
      <link href="/posts/55415.html"/>
      <url>/posts/55415.html</url>
      
        <content type="html"><![CDATA[<h1 id="在-Linux-系统中管理用户账户：创建、设置密码及删除操作"><a href="#在-Linux-系统中管理用户账户：创建、设置密码及删除操作" class="headerlink" title="在 Linux 系统中管理用户账户：创建、设置密码及删除操作"></a>在 Linux 系统中管理用户账户：创建、设置密码及删除操作</h1><h2 id="1-创建新用户"><a href="#1-创建新用户" class="headerlink" title="1. 创建新用户"></a>1. 创建新用户</h2><p>在 Linux 系统中，我们可以使用 <code>adduser</code> 或 <code>useradd</code> 命令来创建新用户。推荐使用 <code>adduser</code> 命令，因为它相对简单，且可以交互式地引导你完成用户创建过程。</p><h3 id="创建新用户命令："><a href="#创建新用户命令：" class="headerlink" title="创建新用户命令："></a>创建新用户命令：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adduser 用户名</span><br></pre></td></tr></table></figure><p>这里，<code>用户名</code> 是您自定义的用户名称。假设我们要创建一个名为 <code>friend</code> 的新用户，那么命令应该是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adduser friend</span><br></pre></td></tr></table></figure><p>执行该命令后，系统将自动创建一个新的用户账户。具体操作步骤如下：</p><ol><li>在 <code>/home</code> 目录下为该用户创建一个子目录（即 <code>home/friend</code>）。</li><li>配置默认的 shell（通常是 <code>/bin/bash</code>）。</li><li>创建该用户的相关信息文件，并将用户信息记录到 <code>/etc/passwd</code> 文件中。</li></ol><h3 id="示例输出："><a href="#示例输出：" class="headerlink" title="示例输出："></a>示例输出：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@server]# adduser friend</span><br></pre></td></tr></table></figure><p>执行该命令后，系统会创建新用户，并在终端中显示相关信息。</p><h2 id="2-为新用户设置密码"><a href="#2-为新用户设置密码" class="headerlink" title="2. 为新用户设置密码"></a>2. 为新用户设置密码</h2><p>在创建新用户后，我们需要为该用户设置一个密码。可以使用 <code>passwd</code> 命令来设置用户密码。</p><h3 id="设置密码命令："><a href="#设置密码命令：" class="headerlink" title="设置密码命令："></a>设置密码命令：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd 用户名</span><br></pre></td></tr></table></figure><p>对于我们刚刚创建的 <code>friend</code> 用户，设置密码的命令是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd friend</span><br></pre></td></tr></table></figure><p>系统会提示你输入密码，并要求重新输入确认密码。在输入密码时，注意密码不会 &#x3D;&#x3D;回显&#x3D;&#x3D;，即 <strong>不会显示在终端</strong> 上，这是出于安全考虑。系统会根据输入的密码自动进行验证，确保密码符合要求（如长度、复杂度等）。</p><h3 id="示例输出：-1"><a href="#示例输出：-1" class="headerlink" title="示例输出："></a>示例输出：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@server]# passwd friend</span><br><span class="line">Changing password <span class="keyword">for</span> user friend.</span><br><span class="line">New password: *******  (输入密码)</span><br><span class="line">Retype new password: *******  (确认密码)</span><br><span class="line">passwd: all authentication tokens updated successfully.</span><br></pre></td></tr></table></figure><p>如果密码强度不符合要求，系统会给出相应的提示，例如：“密码过短”或“密码不符合复杂度要求”。确保输入一个符合规则的密码。</p><h2 id="3-删除用户"><a href="#3-删除用户" class="headerlink" title="3. 删除用户"></a>3. 删除用户</h2><p>当某个用户不再需要时，我们可以通过 <code>userdel</code> 命令将其从系统中删除。若要同时删除该用户的家目录和相关文件，可以使用 <code>-r</code> 选项。</p><h3 id="删除用户命令："><a href="#删除用户命令：" class="headerlink" title="删除用户命令："></a>删除用户命令：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">userdel -r 用户名</span><br></pre></td></tr></table></figure><p>对于我们之前创建的 <code>friend</code> 用户，删除该用户并清理相关文件的命令是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">userdel -r friend</span><br></pre></td></tr></table></figure><p>该命令执行后，系统会删除 <code>friend</code> 用户，并且连同该用户的家目录（即 <code>/home/friend</code>）和其他相关文件一并删除。</p><h3 id="示例输出：-2"><a href="#示例输出：-2" class="headerlink" title="示例输出："></a>示例输出：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@server]# userdel -r friend</span><br></pre></td></tr></table></figure><p>执行删除命令后，用户和其相关文件将永久删除。请小心使用此命令，因为删除操作是不可恢复的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过以上三个命令，你可以轻松地在 Linux 系统中管理用户账户：</p><ol><li><strong>创建用户</strong>：使用 <code>adduser friend</code> 命令创建新用户。</li><li><strong>设置密码</strong>：使用 <code>passwd friend</code> 命令为用户设置密码。</li><li><strong>删除用户</strong>：使用 <code>userdel -r friend</code> 命令删除用户及其相关文件。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>001 环境搭建</title>
      <link href="/posts/49772.html"/>
      <url>/posts/49772.html</url>
      
        <content type="html"><![CDATA[<h3 id="Linux-环境搭建全解析：从历史到实践"><a href="#Linux-环境搭建全解析：从历史到实践" class="headerlink" title="Linux 环境搭建全解析：从历史到实践"></a>Linux 环境搭建全解析：从历史到实践</h3><p>Linux 作为开源操作系统，已经成为了当今信息技术领域的重要组成部分。无论是服务器、桌面，还是嵌入式设备，Linux 的身影几乎无处不在。那么，Linux 究竟是如何发展而来的？它又是如何在当今的技术世界中占据一席之地的？本篇博客将从 Linux 的历史背景出发，逐步讲解如何在 Linux 环境下进行开发与管理，最后提供具体的 Linux 环境搭建教程。</p><h4 id="一、Linux-的起源与发展"><a href="#一、Linux-的起源与发展" class="headerlink" title="一、Linux 的起源与发展"></a>一、Linux 的起源与发展</h4><p><strong>1.1 UNIX 的历史背景</strong></p><p>在深入探讨 Linux 之前，我们需要了解它的前身——UNIX。UNIX 的诞生始于 1969 年，由 AT&amp;T 贝尔实验室的 Ken Thompson 和 Dennis Ritchie 等人开发。最初，UNIX 被设计为一种多任务、多用户的操作系统，能够有效地支持科研工作。UNIX 继承了当时 Multics 操作系统的部分思想，但它的设计更加简洁和高效，这使得 UNIX 逐渐成为主流操作系统之一。</p><p>随着 UNIX 的逐步发展，不同的版本也相继诞生，包括伯克利软件发行版（BSD）和 System V。这两个版本代表了 UNIX 的不同发展方向，并为后来的 Linux 打下了基础。</p><p><strong>1.2 Linux 的诞生与成长</strong></p><p>1991 年，芬兰赫尔辛基大学的学生 Linus Torvalds 在 Usenet 新闻组发布了自己开发的 Linux 操作系统的早期版本。尽管最初的版本非常基础，但它在接下来的几年中迅速发展，吸引了全球程序员的贡献与支持。1994 年，Linux 发布了 1.0 版本，这标志着其成为成熟的操作系统。</p><p>Linux 的发展离不开开源社区的支持，其强大的开发社区和活跃的贡献使得 Linux 得以迅速成熟，并在全球范围内获得广泛应用。</p><h4 id="二、开源的力量"><a href="#二、开源的力量" class="headerlink" title="二、开源的力量"></a>二、开源的力量</h4><p>Linux 作为一个开源操作系统，采用了 GNU 通用公共许可证（GPL）。这意味着用户可以自由地使用、修改和发布 Linux 的源代码，并且任何基于 Linux 的修改版也必须遵循相同的开源协议。这种开源理念促进了技术的迅速发展，并使得 Linux 成为了全球技术创新的推动者。</p><p>随着时间的推移，Linux 不仅在服务器领域取得了巨大成功，还逐渐渗透到桌面、嵌入式、移动设备等多个领域，证明了开源软件的强大生命力和适应性。</p><h4 id="三、Linux-的应用现状"><a href="#三、Linux-的应用现状" class="headerlink" title="三、Linux 的应用现状"></a>三、Linux 的应用现状</h4><p><strong>3.1 服务器领域</strong></p><p>Linux 在服务器领域的地位几乎是无可替代的。根据统计数据，Linux 在全球服务器市场的占有率已超过 75%，成为各大云计算服务商和企业数据中心的首选操作系统。它在政府、金融、电信等关键行业中得到了广泛应用。此外，Linux 在云计算和大数据平台上也有着举足轻重的地位，86%的企业选择 Linux 作为其云平台的基础操作系统。</p><p><strong>3.2 桌面领域</strong></p><p>尽管 Linux 在桌面市场的份额相对较低，但它在特定场景下，如政府机构和企业内部，正在逐渐获得认可。特别是在中国，许多本土厂商推出了定制化的 Linux 桌面版本，例如中标麒麟、红旗 Linux 等。这些版本在本地市场表现良好，并在政府、企业等领域得到了广泛应用。</p><p>然而，从整体而言，Linux 桌面系统仍然面临一定的挑战，尤其是在用户易用性和软件兼容性方面。与 Windows 相比，Linux 在硬件支持、软件兼容性等方面还存在一定差距。</p><p><strong>3.3 移动嵌入式领域</strong></p><p>Linux 在嵌入式系统中具有无可比拟的优势。由于其低成本、高度可定制性和良好的移植性，Linux 广泛应用于移动设备、路由器、智能家居等领域。例如，Android 操作系统就是基于 Linux 内核开发的，它已经成为全球最流行的智能手机操作系统。</p><p>不仅如此，Linux 还被广泛应用于数字电视、路由器、网络防火墙等设备中，这一切都得益于 Linux 的开放性和高度定制化。</p><h4 id="四、主流-Linux-发行版介绍"><a href="#四、主流-Linux-发行版介绍" class="headerlink" title="四、主流 Linux 发行版介绍"></a>四、主流 Linux 发行版介绍</h4><p>Linux 的开源特性使得各种 Linux 发行版层出不穷。以下是几种主流的 Linux 发行版及其特点：</p><ul><li><strong>Debian</strong>: 以稳定性著称，适合用于服务器环境。它拥有庞大的社区支持和丰富的软件包资源，适合需要长期稳定支持的用户。</li><li><strong>Ubuntu</strong>: 基于 Debian，用户友好，易于安装和使用。Ubuntu 广泛应用于个人计算和云计算领域，尤其适合 Linux 初学者。</li><li><strong>红帽企业级 Linux (RHEL)</strong>: 针对企业环境设计，提供商业级支持。RHEL 适用于对安全性和稳定性要求较高的企业。</li><li><strong>CentOS</strong>: RHEL 的免费重构版，几乎完全兼容 RHEL，适合希望体验 RHEL 特性的用户，但不愿支付高额费用。</li><li><strong>Fedora</strong>: 一个小巧灵活的发行版，适合那些希望体验前沿技术的开发者。Fedora 是 RHEL 的测试平台，许多新技术会首先在 Fedora 中出现。</li><li><strong>Kali Linux</strong>: 专为渗透测试和网络安全设计，预装了大量安全工具。它是网络安全专家和渗透测试人员的首选操作系统。</li></ul><h4 id="五、Linux-环境搭建指南"><a href="#五、Linux-环境搭建指南" class="headerlink" title="五、Linux 环境搭建指南"></a>五、Linux 环境搭建指南</h4><p>对于新手来说，搭建 Linux 环境是一个非常好的学习机会。以下是通过云服务器搭建 Linux 环境的详细步骤。</p><p><strong>5.1 购买云服务器</strong></p><ul><li><strong>选择云服务商</strong>：可以选择腾讯云、阿里云、华为云等提供的学生优惠套餐，价格实惠且无需担心物理硬件维护。</li><li><strong>登录账号</strong>：使用 QQ、微信等账号登录云服务商官网。</li><li><strong>选择配置</strong>：选择适合自己的操作系统（例如 CentOS 7.6 64 位）和配置，购买时长建议至少一年。</li><li><strong>获取服务器信息</strong>：记录下服务器的公网 IP、管理员账户（通常为 root）及密码，这些信息是远程登录服务器所必须的。</li></ul><p><strong>5.2 设置服务器</strong></p><ul><li><strong>设置 root 密码</strong>：进入控制台后，选择服务器并重置 root 密码，确保密码复杂度较高，以保证安全。</li><li><strong>配置安全组规则</strong>：调整安全组规则，仅开放必要的端口和服务，如 SSH（22 端口）、HTTP（80 端口）等。</li></ul><p><strong>5.3 安装 XShell</strong></p><ul><li><strong>下载安装 XShell</strong>：XShell 是一款流行的 SSH 客户端，可以通过官方网站下载并安装。</li><li><strong>新建会话</strong>：创建新的会话，输入服务器的公网 IP 地址，选择 SSH 协议进行连接。</li><li><strong>登录服务器</strong>：首次登录时，确认主机指纹并输入用户名（root）和密码，成功后即可开始操作。</li></ul><p>&#x3D;&#x3D;<strong>连接：ssh root@……（ssh + 空格 + root@ + 自己的公网 IP），输入自己的密码，如果跳出像乱码的弹窗选择信任并接受即可</strong>&#x3D;&#x3D;</p><p><strong>5.4 使用 XShell 进行日常操作</strong></p><ul><li><strong>基本命令</strong>：熟悉常用的 Linux 命令，如文件管理命令（ls、cd、cp、mv）、文本编辑命令（vi、vim）等。</li><li><strong>复制粘贴技巧</strong>：在 XShell 中使用 Ctrl+Insert 复制，Shift+Insert 粘贴，而不是 Windows 常用的 Ctrl+C&#x2F;V。</li><li><strong>常用工具安装</strong>：使用命令安装软件包（如 Apache、MySQL 等），常用命令包括 <code>yum</code>、<code>apt-get</code> 等。</li></ul><h4 id="六、结语"><a href="#六、结语" class="headerlink" title="六、结语"></a>六、结语</h4><p>Linux 已经不仅仅是一个操作系统，它是开源、自由、创新的象征。通过本篇博客的介绍，相信你对 Linux 有了更深入的了解。无论是在服务器管理、软件开发，还是在日常操作中，Linux 都能够提供高效、稳定的支持。而通过云服务搭建 Linux 环境，你可以轻松快速地开始你的 Linux 之旅。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>04 类与对象（下）</title>
      <link href="/posts/10381.html"/>
      <url>/posts/10381.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-再谈构造函数"><a href="#1-再谈构造函数" class="headerlink" title="1. 再谈构造函数"></a>1. 再谈构造函数</h2><p>在面向对象编程中，<strong>构造函数</strong> 是一种特殊的成员函数，它在对象创建时自动调用，负责初始化对象的成员变量（创建对象时赋初值），确保对象在创建时有一个有效的状态。接下来，我们将详细讲解关于构造函数的几个重要概念。</p><h3 id="1-1-构造函数体赋值"><a href="#1-1-构造函数体赋值" class="headerlink" title="1.1 构造函数体赋值"></a>1.1 构造函数体赋值</h3><p>当我们创建一个对象时，构造函数会被自动调用，用来给对象的各个成员变量提供一个初始值。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="built_in">MyClass</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        a = <span class="number">10</span>;  <span class="comment">// 这里是构造函数体中的赋值操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这个例子中，构造函数的作用是将 <code>a</code> 赋值为 10。然而，这里要注意，<strong>构造函数体中的赋值操作和初始化是有区别的</strong>。构造函数体中对成员变量的赋值只能算是给成员变量“赋初值”，而不是“初始化”。因为初始化是指给成员变量设置一个初始值，而且初始化只能发生一次，而赋值操作可以发生多次。</p><p>再例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> _x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> x)</span><br><span class="line">    &#123;</span><br><span class="line">        _x = x; <span class="comment">// 赋值操作：_x 在此之前已经默认初始化（如果有的话），然后被赋值为 x。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">上述代码中，`_x = x;`是赋值，而非初始化，因为初始化只能通过构造函数外部的初始化列表来完成。</span><br><span class="line"></span><br><span class="line">在构造函数体中对成员变量的赋值操作，实际上是先通过默认初始化（如果有的话），然后通过赋值操作覆盖初始值。这与初始化列表直接初始化成员变量有本质区别。</span><br></pre></td></tr></table></figure><p>换句话说，<strong>初始化只能在构造函数中通过初始化列表来进行一次，而构造函数体中的赋值可以反复进行</strong>。</p><p>所以，<strong>赋值与初始化的区别</strong> 在于：</p><ul><li><strong>初始化</strong>：是在对象创建时为成员变量设置初始值的过程，每个成员变量只能被初始化一次，通常在构造函数的初始化列表中进行（只能进行一次）。</li><li><strong>赋值</strong>：是在对象创建后对成员变量进行值的修改，可以发生多次，可以在构造函数体中，也可以在对象的生命周期中的任何时候进行（可以重复进行）。</li></ul><hr><h3 id="1-2-初始化列表"><a href="#1-2-初始化列表" class="headerlink" title="1.2 初始化列表"></a>1.2 初始化列表</h3><p>初始化列表是构造函数中的一种写法（直接初始化类的成员变量的一种方式），允许我们在构造函数调用之前就给成员变量提供初始值。语法是在构造函数的括号后加冒号和成员变量列表，其基本格式是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">MyClass</span>() : <span class="built_in">a</span>(<span class="number">10</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 构造函数体</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">这里的:`<span class="built_in">a</span>(<span class="number">10</span>)`就是初始化列表，它会在构造函数体执行之前初始化成员变量`a`为<span class="number">10</span>。</span><br></pre></td></tr></table></figure><p>再或者：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> _x;</span><br><span class="line">    <span class="type">int</span> _y;</span><br><span class="line">    <span class="type">int</span> _val;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> x)</span><br><span class="line">        : _x(x), </span><br><span class="line">          _y(<span class="number">0</span>), </span><br><span class="line">          _val(<span class="number">0</span>)</span><br><span class="line">    &#123;&#125; <span class="comment">// 初始化列表</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>注意事项</strong>：</p><ol><li>每个成员变量在初始化列表中只能出现一次。初始化列表的目的是对成员进行一次初始化。</li><li>对于某些特殊类型的成员变量，必须使用初始化列表来进行初始化。例如：<ul><li><strong>引用成员变量</strong>：引用一旦初始化就不可更改，只能在初始化列表中赋值。</li><li><strong>const 成员变量</strong>：常量变量（const 变量）在对象创建时必须初始化，且不可更改；必须在声明时初始化，不能通过构造函数体赋值。</li><li><strong>自定义类型成员</strong>&#x2F;<strong>没有默认构造函数的自定义类型</strong>：自定义类型变量如果没有默认构造函数，只能通过初始化列表初始化。</li></ul></li><li>尽量使用初始化列表初始化，因为不管你是否使用初始化列表，对于自定义类型成员变量，一定会先使用初始化列表初始化。</li><li><strong>初始化列表的顺序</strong>：初始化列表中的成员变量的初始化顺序 <strong>和它们在类中声明的顺序一致</strong>，而不是按照初始化列表中出现的顺序（编译器会按照成员变量在类中声明的顺序进行内存布局，因此初始化顺序也必须与之匹配）。</li></ol><p><strong>推荐使用初始化列表的原因</strong>： 对于自定义类型，编译器会自动调用其构造函数完成初始化，不使用初始化列表而采用先默认构造再赋值可能导致性能浪费。</p><p><strong>类的成员变量初始化顺序</strong> 取决于 <strong>成员变量的声明顺序</strong>，而不是初始化列表的顺序：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 此处先声明 a, 再声明 b</span></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> b;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> x) : <span class="built_in">b</span>(<span class="number">20</span>), <span class="built_in">a</span>(x) <span class="comment">// 初始化列表：b 在 a 之前初始化（就会导致一些奇怪的错误：未定义行为（UB））</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// b 在 a 之后声明，所以 a 会先被初始化，b 才会初始化！</span></span><br><span class="line"><span class="comment">// 如果 b 的初始化依赖 a，就会导致意外的错误或 UB！</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;, b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">MyClass <span class="title">obj</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">// 输出：a = 10, b = 20</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="1-3-explicit-关键字"><a href="#1-3-explicit-关键字" class="headerlink" title="1.3 explicit 关键字"></a>1.3 explicit 关键字</h3><p>如果构造函数接收单一参数，它可能会被编译器用于隐式类型转换。而 <code>explicit</code> 关键字则用来标记构造函数，防止它参与隐式类型转换。 隐式类型转换可能导致临时对象的创建和销毁，增加不必要的性能开销，或者在代码中引入难以察觉的错误。</p><p>在 C++中，构造函数不仅可以用来构造和初始化对象，还可以在特定条件下用作类型转换的“隐式转换构造函数”。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 构造函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// error: conversion from &#x27;int&#x27; to non-scalar type &#x27;MyClass&#x27; requested</span></span><br><span class="line">MyClass obj = <span class="number">10</span>;  <span class="comment">// 编译器会用构造函数将10转换为MyClass对象</span></span><br><span class="line"></span><br><span class="line">在上述代码中，`<span class="built_in">MyClass</span>(<span class="type">int</span> x)`构造函数是一个单参构造函数，可以将`<span class="type">int</span>`类型的<span class="number">10</span>隐式转换为`MyClass`类型的对象。</span><br><span class="line">为防止这种类型转换，我们可以在构造函数前加上`<span class="keyword">explicit</span>`关键字，这样就禁止了隐式转换：</span><br><span class="line">    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MyClass</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 构造函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MyClass obj = <span class="number">10</span>;  <span class="comment">// 错误：不能隐式转换</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> x) &#123;&#125; <span class="comment">// 单参构造函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A obj = <span class="number">10</span>; <span class="comment">// 隐式调用构造函数</span></span><br><span class="line"></span><br><span class="line">**<span class="keyword">explicit</span>的作用**： 使用`<span class="keyword">explicit</span>`关键字禁止隐式类型转换：</span><br><span class="line">    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">A</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A obj = <span class="number">10</span>; <span class="comment">// 错误，禁止隐式转换</span></span><br><span class="line"><span class="function">A <span class="title">obj2</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> x) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyExplicitClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MyExplicitClass</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MyClass obj1 = <span class="number">10</span>;  <span class="comment">// 隐式类型转换</span></span><br><span class="line">    MyExplicitClass obj2 = <span class="number">10</span>;  <span class="comment">// 错误：禁止隐式类型转换</span></span><br><span class="line">    <span class="function">MyExplicitClass <span class="title">obj3</span><span class="params">(<span class="number">10</span>)</span></span>;  <span class="comment">// 显式类型转换</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;obj1 created successfully.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; &quot;obj2 created successfully.&quot; &lt;&lt; endl;  // 编译错误</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;obj3 created successfully.&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>explicit</code> 关键字后，只有明确调用构造函数时才能进行类型转换，不能再进行隐式转换。所以，构造函数不仅仅负责创建对象，它还通过初始化列表给对象成员变量赋初值。通过 <code>explicit</code> 关键字，我们可以禁止单参构造函数的隐式类型转换，确保代码的类型安全。</p><hr><h2 id="2-static-成员"><a href="#2-static-成员" class="headerlink" title="2. static 成员"></a>2. static 成员</h2><h3 id="2-1-概念"><a href="#2-1-概念" class="headerlink" title="2.1 概念"></a>2.1 概念</h3><p>在 C++中，类成员可以被声明为 <code>static</code>，这样的成员称为 <strong>静态成员</strong>。静态成员包括静态成员变量和静态成员函数。</p><ul><li><strong>静态成员变量</strong>：使用 <code>static</code> 修饰的类成员变量，所有对象共享这个变量，不属于某个特定的对象。静态成员变量必须在类外进行初始化（被修饰的变量属于类本身，而不是某个对象）。</li><li><strong>静态成员函数</strong>：使用 <code>static</code> 修饰的成员函数，它是属于类的，而不是类的某个对象（修饰的函数属于类本身，可以直接通过类名调用）。</li></ul><h4 id="2-2-特性"><a href="#2-2-特性" class="headerlink" title="2.2 特性"></a>2.2 特性</h4><ol><li><p><strong>静态成员的共享性</strong>： 静态成员变量为所有对象共享，修改其中一个对象的静态成员变量值，会影响其他对象。</p><ul><li>静态成员变量和静态成员函数是属于类本身的，而不是类的某个特定对象。</li><li>所有类对象共享静态成员，这意味着静态成员的值对所有对象是相同的。</li><li>静态成员并不存储在每个对象中，而是存放在一个全局的静态区。</li></ul><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> _count;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Increment</span><span class="params">()</span> </span>&#123; _count++; &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">GetCount</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _count; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> A::_count = <span class="number">0</span>;<span class="comment">//  静态变量必须在类外定义/初始化</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A::<span class="built_in">Increment</span>();</span><br><span class="line">    cout &lt;&lt; A::<span class="built_in">GetCount</span>() &lt;&lt; endl; <span class="comment">// 输出1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>静态成员变量的初始化</strong>：</p><ul><li><p>静态成员变量在类外进行定义和初始化，而在类内部仅声明。</p></li><li><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> count;  <span class="comment">// 静态成员变量声明</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> MyClass::count = <span class="number">0</span>;  <span class="comment">// 静态成员变量初始化</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>访问静态成员</strong>：</p><ul><li>可以通过类名直接访问静态成员：<code>类名::静态成员</code>。</li><li>也可以通过对象访问静态成员：<code>对象.静态成员</code>。但是，通常推荐通过类名来访问，保持代码的清晰和一致性。</li></ul></li><li><p><strong>静态成员函数没有 <code>this</code> 指针</strong>：</p><ul><li>静态成员函数与类的对象无关，静态成员函数属于类本身，而不是某个对象，因此它没有隐藏的 <code>this</code> 指针。</li><li>由于没有 <code>this</code> 指针，静态成员函数无法访问类的非静态成员变量或非静态成员函数（只能访问静态变量，不能访问非静态成员）。</li><li>非静态成员属于对象，而静态成员函数与对象无关，因此无法通过 <code>this</code> 指针访问非静态成员。</li></ul></li><li><p><strong>访问权限</strong>：</p><ul><li>静态成员仍然受类的访问控制（<code>public</code>、<code>protected</code>、<code>private</code>）的限制。</li></ul></li></ol><h3 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h3><p>假设我们要实现一个类，统计类的对象创建次数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> count; <span class="comment">// 静态成员变量，属于类本身</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">MyClass</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        count++; <span class="comment">// 每创建一个对象，静态变量 count 加 1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">getCount</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count; <span class="comment">// 静态成员函数，返回静态变量的值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> MyClass::count = <span class="number">0</span>; <span class="comment">// 类外初始化静态成员变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MyClass obj1, obj2, obj3;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;创建的对象数：&quot;</span> &lt;&lt; MyClass::<span class="built_in">getCount</span>() &lt;&lt; endl; <span class="comment">// 输出：创建的对象数：3</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态成员函数和非静态成员函数的区别：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> staticVar;</span><br><span class="line">    <span class="type">int</span> nonStaticVar;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">staticFunction</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;static 函数，staticVar =&quot;</span> &lt;&lt; staticVar &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; &quot;非静态 var =&quot; &lt;&lt; nonStaticVar &lt;&lt; endl;  // 编译错误</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">nonStaticFunction</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;非静态函数，nonStaticVar =&quot;</span> &lt;&lt; nonStaticVar &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;静态 var =&quot;</span> &lt;&lt; staticVar &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> MyClass::staticVar = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MyClass::<span class="built_in">staticFunction</span>();  <span class="comment">// 静态函数调用</span></span><br><span class="line">    MyClass obj;</span><br><span class="line">    obj.<span class="built_in">nonStaticFunction</span>();  <span class="comment">// 非静态函数调用</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h3 id="传道解惑："><a href="#传道解惑：" class="headerlink" title="传道解惑："></a>传道解惑：</h3><h4 id="Q1：静态成员函数可以调用非静态成员函数吗？"><a href="#Q1：静态成员函数可以调用非静态成员函数吗？" class="headerlink" title="Q1：静态成员函数可以调用非静态成员函数吗？"></a>Q1：静态成员函数可以调用非静态成员函数吗？</h4><p><strong>不可以</strong>。静态成员函数没有 <code>this</code> 指针，它与对象无关。因此，它无法访问类的非静态成员变量和非静态成员函数。如果静态成员函数试图访问非静态成员函数或成员变量，会导致编译错误。</p><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&gt;&#123;</span><br><span class="line">&gt;<span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">nonStaticFunction</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;这是一个非静态函数。&quot;</span> &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">staticFunction</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">          <span class="comment">// 不能访问非静态成员函数</span></span><br><span class="line">          <span class="comment">// nonStaticFunction();  // 错误：静态成员函数不能访问非静态成员函数</span></span><br><span class="line">   &#125;</span><br><span class="line">&gt;&#125;;</span><br></pre></td></tr></table></figure><h4 id="Q2-非静态成员函数可以调用类的静态成员函数吗？"><a href="#Q2-非静态成员函数可以调用类的静态成员函数吗？" class="headerlink" title="Q2: 非静态成员函数可以调用类的静态成员函数吗？"></a>Q2: 非静态成员函数可以调用类的静态成员函数吗？</h4><p><strong>可以</strong>。非静态成员函数属于某个对象，可以访问类的静态成员变量和静态成员函数。非静态成员函数是通过对象的 <code>this</code> 指针来访问类的成员的，所以它可以直接访问静态成员。</p><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&gt;&#123;</span><br><span class="line">&gt;<span class="keyword">public</span>:</span><br><span class="line">   <span class="type">static</span> <span class="type">int</span> staticVar;</span><br><span class="line">   <span class="type">int</span> nonStaticVar;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">nonStaticFunction</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">          <span class="comment">// 可以访问静态成员函数</span></span><br><span class="line">          <span class="built_in">staticFunction</span>();</span><br><span class="line">          cout &lt;&lt; <span class="string">&quot;静态变量：&quot;</span> &lt;&lt; staticVar &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">staticFunction</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;这是一个静态函数。&quot;</span> &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="type">int</span> MyClass::staticVar = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">&gt;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">&gt;</span>&#123;</span><br><span class="line">   MyClass obj;</span><br><span class="line">   obj.<span class="built_in">nonStaticFunction</span>();  <span class="comment">// 调用非静态成员函数，内部可以访问静态成员函数</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;这是一个静态函数。</span><br><span class="line">&gt;静态变量：10</span><br></pre></td></tr></table></figure></blockquote><hr><h2 id="3-友元（Friend）"><a href="#3-友元（Friend）" class="headerlink" title="3. 友元（Friend）"></a>3. 友元（Friend）</h2><p><strong>友元</strong> 是一种打破封装的方式，它允许特定的函数或类访问类的私有成员和保护成员。通常情况下，类的私有成员是只能通过类的成员函数来访问的，但友元提供了一个特例，使得外部函数或类可以访问这些私有成员。尽管友元能提供便利，但它也会增加类之间的耦合度，破坏封装性，因此在设计时应当小心使用。</p><p>友元可以分为两种类型：<strong>友元函数</strong> 和 <strong>友元类</strong>。</p><h3 id="3-1-友元函数"><a href="#3-1-友元函数" class="headerlink" title="3.1 友元函数"></a>3.1 友元函数</h3><ul><li><p><strong>友元函数的定义</strong>： 友元函数是定义在类外的普通函数，但可以访问类的私有成员和保护成员。它并不是类的成员函数，因此没有 <code>this</code> 指针。虽然它是类外的函数，但为了让它可以访问类的私有成员，必须在类内声明为友元函数，使用 <code>friend</code> 关键字。</p></li><li><p><strong>友元函数的特性：</strong></p><ul><li><strong>声明位置</strong>：可以在类定义的任何地方声明，只要在类内部用 <code>friend</code> 关键字。</li><li><strong>访问权限</strong>：友元函数可以访问类的私有和保护成员，但它并不属于类的成员函数。</li><li><strong>不属于类的成员函数</strong>：友元函数的调用和普通函数一样，不通过对象调用，没有 <code>this</code> 指针。</li><li><strong>不能用 <code>const</code> 修饰</strong>：友元函数不能被声明为 <code>const</code>，因为它可能会修改类的私有成员。</li></ul><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>;  <span class="comment">// 前向声明类 A</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> _y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>(<span class="type">int</span> y) : _y(y) &#123;&#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">A</span>;  <span class="comment">// 友元类：A 类可以访问 B 的私有成员</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> _x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> x) : _x(x) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">Print</span><span class="params">(<span class="type">const</span> A&amp; a)</span></span>;  <span class="comment">// 友元函数声明</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 友元类 A 可以访问 B 的私有成员</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(<span class="type">const</span> B&amp; b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Friend class: &quot;</span> &lt;&lt; b._y &lt;&lt; endl;  <span class="comment">// 访问 B 的私有成员</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(<span class="type">const</span> A&amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Friend function: &quot;</span> &lt;&lt; a._x &lt;&lt; endl;  <span class="comment">// 访问 A 的私有成员</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="built_in">Print</span>(a);  <span class="comment">// 调用友元函数</span></span><br><span class="line"></span><br><span class="line">    <span class="function">B <span class="title">b</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line">    a.<span class="built_in">Print</span>(b);  <span class="comment">// 调用友元类中的成员函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>友元函数的使用场景</strong>：</p><ul><li>当需要定义一个全局函数，并且需要访问类的私有数据时。</li><li>常用于重载操作符 <code>&lt;&lt;</code> 和 <code>&gt;&gt;</code>。</li></ul></li></ul><blockquote><h3 id="传道解惑"><a href="#传道解惑" class="headerlink" title="传道解惑"></a>传道解惑</h3><h4 id="Q1：为什么使用友元函数？"><a href="#Q1：为什么使用友元函数？" class="headerlink" title="Q1：为什么使用友元函数？"></a>Q1：为什么使用友元函数？</h4><p>友元函数常用于那些不能作为成员函数实现的操作。例如，重载输入输出运算符 <code>&lt;&lt;</code> 和 <code>&gt;&gt;</code> 时，<code>cout</code> 和 <code>cin</code> 对象是流对象，需要通过全局函数进行操作，而不能作为类的成员函数。</p><h5 id="示例：重载-operator"><a href="#示例：重载-operator" class="headerlink" title="示例：重载 operator&lt;&lt;（输出流）为友元函数"></a>示例：重载 <code>operator&lt;&lt;</code>（输出流）为友元函数</h5><p>假设我们有一个 <code>Box</code> 类，想要重载 <code>&lt;&lt;</code> 运算符来输出 <code>Box</code> 的内容，<code>cout</code> 需要是左操作数，因此 <code>&lt;&lt;</code> 不能作为成员函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">&gt;<span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">Box</span></span><br><span class="line">&gt;&#123;</span><br><span class="line">&gt;<span class="keyword">private</span>:</span><br><span class="line">       <span class="type">int</span> length;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">       <span class="built_in">Box</span>(<span class="type">int</span> l) : <span class="built_in">length</span>(l) &#123;&#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 声明友元函数</span></span><br><span class="line">       <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os, <span class="type">const</span> Box&amp; box);</span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 友元函数的定义</span></span><br><span class="line">&gt;ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os, <span class="type">const</span> Box&amp; box)</span><br><span class="line">&gt;&#123;</span><br><span class="line">       os &lt;&lt; <span class="string">&quot;箱长：&quot;</span> &lt;&lt; box.length;</span><br><span class="line">       <span class="keyword">return</span> os;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">&gt;</span>&#123;</span><br><span class="line">       <span class="function">Box <span class="title">box</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">       cout &lt;&lt; box &lt;&lt; endl;  <span class="comment">// 使用重载的operator&lt;&lt;</span></span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;箱长：10</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>operator&lt;&lt;</code> 是一个友元函数，它被声明为 <code>Box</code> 类的友元，因此它可以访问 <code>Box</code> 类的私有成员 <code>length</code>。</p></blockquote><hr><h3 id="3-2-友元类"><a href="#3-2-友元类" class="headerlink" title="3.2 友元类"></a>3.2 友元类</h3><p><strong>友元类</strong> 是指一个类的所有成员函数都可以成为另一个类的友元函数，因此友元类的所有成员函数都可以访问当前类的私有成员和保护成员。</p><h4 id="友元类的特性："><a href="#友元类的特性：" class="headerlink" title="友元类的特性："></a>友元类的特性：</h4><ul><li><strong>单向关系</strong>：如果类 A 声明类 B 为友元类，那么类 B 的成员函数可以访问类 A 的私有成员，但类 A 的成员函数不能访问类 B 的私有成员。友元关系是单向的（声明友元类 B 后，B 能访问 A，但 A 不能访问 B）。</li><li><strong>不能继承</strong>：友元关系不能被继承，如果类 A 是类 B 的友元类，那么类 B 的派生类不会自动成为类 A 的友元类。</li><li><strong>关系不可传递</strong>：如果 B 是 A 的友元，C 是 B 的友元，那么 C 并不是 A 的友元。</li></ul><h4 id="示例：友元类"><a href="#示例：友元类" class="headerlink" title="示例：友元类"></a>示例：友元类</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> _x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> x) : _x(x) &#123;&#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">B</span>; <span class="comment">// 声明B为友元类</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AccessA</span><span class="params">(<span class="type">const</span> A&amp; a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; a._x &lt;&lt; endl; <span class="comment">// 访问A的私有成员</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>再假设我们有 <code>Time</code> 类和 <code>Date</code> 类，并希望 <code>Time</code> 类可以访问 <code>Date</code> 类的私有成员。我们可以在 <code>Time</code> 类中声明 <code>Date</code> 为友元类。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Time</span>; <span class="comment">// 前向声明</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printTime</span><span class="params">(<span class="type">const</span> Time&amp; t)</span></span>; <span class="comment">// 声明函数，访问 Time 类的私有成员</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Time</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> hour;</span><br><span class="line">    <span class="type">int</span> minute;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Time</span>(<span class="type">int</span> h, <span class="type">int</span> m) : <span class="built_in">hour</span>(h), <span class="built_in">minute</span>(m) &#123;&#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Date</span>; <span class="comment">// 声明 Date 类为友元类</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Date::printTime</span><span class="params">(<span class="type">const</span> Time&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Time: &quot;</span> &lt;&lt; t.hour &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; t.minute &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Time <span class="title">t</span><span class="params">(<span class="number">10</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">    Date d;</span><br><span class="line">    d.<span class="built_in">printTime</span>(t); <span class="comment">// 输出：Time: 10:30</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>Time</code> 类声明了 <code>Date</code> 类为友元类，这样 <code>Date</code> 类的成员函数 <code>printTime</code> 就能够访问 <code>Time</code> 类的私有成员（如 <code>hour</code> 和 <code>minute</code>）。</p><h3 id="SO："><a href="#SO：" class="headerlink" title="SO："></a>SO：</h3><ul><li><strong>友元函数</strong>：允许非成员函数访问类的私有和保护成员。它不是类的成员函数，通常用于操作符重载等场景。</li><li><strong>友元类</strong>：允许一个类的所有成员函数访问另一个类的私有和保护成员。它们的关系是单向的。</li><li><strong>使用场景</strong>：友元可以提高代码的灵活性和可操作性，但过多使用会增加类之间的耦合度，破坏封装，因此要谨慎使用。</li></ul><hr><h2 id="4-内部类（Nested-Class）"><a href="#4-内部类（Nested-Class）" class="headerlink" title="4. 内部类（Nested Class）"></a>4. 内部类（Nested Class）</h2><h3 id="4-1-概念："><a href="#4-1-概念：" class="headerlink" title="4.1 概念："></a>4.1 概念：</h3><p><strong>内部类</strong> 是定义在另一个类内部的类。它是一个独立的类，和外部类没有直接的归属关系，即它并不属于外部类的对象。外部类不能直接访问内部类的成员，反之，内部类可以访问外部类的成员，特别是当外部类的成员是 <code>static</code> 时（内部类天然是外部类的友元，可以访问外部类的私有成员）。</p><p><strong>内部类</strong> 有时也被称为 <strong>嵌套类</strong>，通常用于将一个类作为一个辅助工具类嵌套在另一个类中，通常与外部类的功能紧密相关。</p><p><strong>例如：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> _count;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">ShowCount</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            cout &lt;&lt; _count &lt;&lt; endl; <span class="comment">// 直接访问静态成员</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> A::_count = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A::B b;</span><br><span class="line">    b.<span class="built_in">ShowCount</span>(); <span class="comment">// 输出10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="关键点："><a href="#关键点：" class="headerlink" title="关键点："></a>关键点：</h4><ol><li><strong>独立性</strong>：内部类是一个完全独立的类，它不属于外部类的对象。因此，外部类不能通过自身的对象直接访问内部类的成员。</li><li><strong>友元关系</strong>：虽然外部类不能直接访问内部类的成员，但内部类可以通过外部类的对象访问外部类的所有成员（包括私有成员）。从这个角度来看，内部类可以看作外部类的友元类（<strong>内部类天然具有可以访问外部类的私有成员这种访问权限，而不是因为它是友元类</strong>）。</li></ol><h3 id="4-2-内部类的特性"><a href="#4-2-内部类的特性" class="headerlink" title="4.2 内部类的特性"></a>4.2 内部类的特性</h3><ol><li><strong>访问权限</strong>：<ul><li>内部类可以定义在外部类的 <code>public</code>、<code>protected</code>、<code>private</code> 等任何区域，和外部类的访问权限相同。</li><li>但外部类不能直接访问内部类的成员，除非通过内部类的对象来访问。</li><li>内部类可以访问外部类的非静态成员，但需要通过外部类的对象来访问。</li></ul></li><li><strong>访问外部类的静态成员</strong>：<ul><li>内部类可以直接访问外部类中的 <code>static</code> 成员，无需外部类的对象或类名。这是因为静态成员是属于类本身的，而不是某个特定对象的。</li></ul></li><li><strong><code>sizeof</code> 外部类和内部类</strong>：<ul><li>外部类和内部类是两个独立的实体，它们占用不同的内存空间。通过 <code>sizeof</code> 计算外部类的大小时，和内部类没有直接关系。</li></ul></li></ol><h3 id="4-3-内部类的分类"><a href="#4-3-内部类的分类" class="headerlink" title="4.3 内部类的分类"></a>4.3 内部类的分类</h3><ul><li><strong>静态内部类</strong>（<code>static</code> nested class）：内部类是静态的，意味着它不需要外部类的实例就可以访问。静态内部类不能访问外部类的实例成员，但可以访问外部类的静态成员。</li><li><strong>非静态内部类</strong>（普通内部类）：需要通过外部类的实例来创建实例，且能够访问外部类的所有成员（包括非静态成员）。</li></ul><h3 id="示例：内部类的使用"><a href="#示例：内部类的使用" class="headerlink" title="示例：内部类的使用"></a>示例：内部类的使用</h3><p>下面我们通过一个例子，详细讲解内部类的使用。</p><h4 id="1-普通的内部类"><a href="#1-普通的内部类" class="headerlink" title="1. 普通的内部类"></a>1. 普通的内部类</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> outerVar = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Inner</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">accessOuter</span><span class="params">(Outer&amp; outer)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="comment">// 内部类可以访问外部类的私有成员</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;访问外部类 private 成员：&quot;</span> &lt;&lt; outer.outerVar &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Outer outer;</span><br><span class="line">    Outer::Inner inner;  <span class="comment">// 创建内部类对象</span></span><br><span class="line">    inner.<span class="built_in">accessOuter</span>(outer);  <span class="comment">// 通过内部类访问外部类的成员</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">访问外部类 private 成员：10</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>Inner</code> 是 <code>Outer</code> 类的内部类。<code>Inner</code> 类可以访问 <code>Outer</code> 类的私有成员 <code>outerVar</code>，并且我们通过 <code>Outer</code> 类的对象来访问外部类的成员。</p><h4 id="2-静态内部类"><a href="#2-静态内部类" class="headerlink" title="2. 静态内部类"></a>2. 静态内部类</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> staticVar;  <span class="comment">// 静态成员</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="keyword">class</span> <span class="title class_">Inner</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">accessOuter</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="comment">// 静态内部类可以访问外部类的静态成员</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;访问外部类 static 成员：&quot;</span> &lt;&lt; staticVar &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Outer::staticVar = <span class="number">20</span>;<span class="comment">// 类外初始化静态成员变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Outer::Inner inner;  <span class="comment">// 创建静态内部类对象</span></span><br><span class="line">    inner.<span class="built_in">accessOuter</span>();  <span class="comment">// 静态内部类访问外部类的静态成员</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">访问外部类 static 成员：20</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>Inner</code> 是 <code>Outer</code> 类的静态内部类。静态内部类可以直接访问 <code>Outer</code> 类的静态成员 <code>staticVar</code>，不需要外部类的对象。</p><h4 id="3-普通内部类和静态内部类的区别："><a href="#3-普通内部类和静态内部类的区别：" class="headerlink" title="3. 普通内部类和静态内部类的区别："></a>3. 普通内部类和静态内部类的区别：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> outerVar = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Inner</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">accessOuter</span><span class="params">(Outer&amp; outer)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;非静态内部类：&quot;</span> &lt;&lt; outer.outerVar &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="keyword">class</span> <span class="title class_">StaticInner</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">accessOuter</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;static 内部类：&quot;</span> &lt;&lt; outerVar &lt;&lt; endl;  <span class="comment">// 编译错误</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Outer outer;</span><br><span class="line">    Outer::Inner inner;</span><br><span class="line">    inner.<span class="built_in">accessOuter</span>(outer);  <span class="comment">// 非静态内部类访问外部类成员</span></span><br><span class="line"></span><br><span class="line">    Outer::StaticInner staticInner;</span><br><span class="line">    <span class="comment">// staticInner.accessOuter();  // 编译错误</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SO"><a href="#SO" class="headerlink" title="SO:"></a>SO:</h3><ul><li><strong>内部类</strong> 是定义在另一个类内部的类。它是独立的类，外部类不能直接访问内部类的成员，内部类可以通过外部类的对象访问外部类的所有成员。</li><li><strong>友元关系</strong>：从某种角度看，内部类可以访问外部类的私有成员，所以可以视作外部类的友元类。</li><li>内部类可以是 <strong>静态的</strong>（<code>static</code>），也可以是 <strong>非静态的</strong>，它们的访问权限和行为有所不同。</li></ul><p>内部类通常用于处理一些与外部类紧密相关的功能，帮助将代码组织得更好。</p><hr><h2 id="5-匿名对象（Anonymous-Object）"><a href="#5-匿名对象（Anonymous-Object）" class="headerlink" title="5. 匿名对象（Anonymous Object）"></a>5. 匿名对象（Anonymous Object）</h2><p>在 C++中，匿名对象指的是没有明确名称的对象。它通常用于函数返回、临时数据传递、类型转换等场景，它们的生命周期仅限于它们所在的表达式或者函数调用，执行完毕后即被销毁。通过合理使用匿名对象，可以简化代码、减少不必要的对象创建，提高程序的效率。下面我将详细讲解匿名对象的相关知识点及其使用。</p><h3 id="5-1-匿名对象的定义和创建"><a href="#5-1-匿名对象的定义和创建" class="headerlink" title="5.1 匿名对象的定义和创建"></a>5.1 匿名对象的定义和创建</h3><p>匿名对象是没有名字的临时对象。在 C++中，匿名对象通常出现在以下场景：</p><ul><li><strong>作为函数返回值：</strong> 当函数返回一个对象时，C++会创建一个匿名对象来接收返回值。</li><li><strong>临时对象：</strong> 用作表达式的操作数时，编译器会创建一个临时对象。</li><li><strong>类型转换：</strong> 在类型转换过程中，C++会临时创建匿名对象。</li></ul><h3 id="5-2-匿名对象的生命周期"><a href="#5-2-匿名对象的生命周期" class="headerlink" title="5.2 匿名对象的生命周期"></a>5.2 匿名对象的生命周期</h3><p>匿名对象的生命周期非常短，通常只在一个表达式或者函数调用期间有效。它们会在表达式结束后立即销毁。这是因为它们没有名字，无法直接引用它们。</p><h3 id="5-3-匿名对象的使用示例"><a href="#5-3-匿名对象的使用示例" class="headerlink" title="5.3 匿名对象的使用示例"></a>5.3 匿名对象的使用示例</h3><h4 id="示例-1：作为函数返回值的匿名对象"><a href="#示例-1：作为函数返回值的匿名对象" class="headerlink" title="示例 1：作为函数返回值的匿名对象"></a>示例 1：作为函数返回值的匿名对象</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;MyClass 构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">MyClass</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;MyClass 析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sayHello</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Hello from MyClass!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数返回匿名对象</span></span><br><span class="line"><span class="function">MyClass <span class="title">createObject</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">MyClass</span>();  <span class="comment">// 返回一个匿名对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">createObject</span>().<span class="built_in">sayHello</span>();  <span class="comment">// 创建一个匿名对象并调用它的方法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解释：</strong></p><ul><li>在 <code>createObject</code> 函数中，<code>return MyClass();</code> 创建了一个匿名对象并返回。</li><li>在 <code>main</code> 函数中，调用 <code>createObject().sayHello()</code> 时，匿名对象在 <code>createObject</code> 函数返回时创建，并且调用 <code>sayHello()</code> 方法。</li><li>程序运行时，首先会打印构造函数的消息，接着打印 <code>sayHello()</code> 的消息，然后销毁匿名对象，打印析构函数的消息。</li></ul><h4 id="示例-2：作为临时对象"><a href="#示例-2：作为临时对象" class="headerlink" title="示例 2：作为临时对象"></a>示例 2：作为临时对象</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;MyClass 构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">MyClass</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;MyClass 析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sayHello</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Hello from MyClass!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MyClass obj;</span><br><span class="line">    obj.<span class="built_in">sayHello</span>();</span><br><span class="line">    <span class="built_in">MyClass</span>().<span class="built_in">sayHello</span>();  <span class="comment">// 这里是一个匿名对象调用方法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解释：</strong></p><ul><li>在 <code>main</code> 函数中，<code>MyClass().sayHello();</code> 创建了一个匿名对象并调用了 <code>sayHello</code> 方法。</li><li>这个匿名对象仅在该行代码执行时有效，执行完后立即销毁。</li></ul><h4 id="示例-3：通过类型转换创建匿名对象"><a href="#示例-3：通过类型转换创建匿名对象" class="headerlink" title="示例 3：通过类型转换创建匿名对象"></a>示例 3：通过类型转换创建匿名对象</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> value) : <span class="built_in">m_value</span>(value)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;MyClass 构造函数：&quot;</span> &lt;&lt; m_value &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">MyClass</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;MyClass 析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="number">10</span>);  <span class="comment">// 创建一个匿名对象并传递给构造函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解释：</strong></p><ul><li><code>MyClass(10);</code> 创建了一个匿名对象，并且传递了参数 <code>10</code> 给构造函数。</li><li>这个匿名对象在创建后立即销毁，生命周期仅限于该行代码。</li></ul><h3 id="5-4-匿名对象的应用场景"><a href="#5-4-匿名对象的应用场景" class="headerlink" title="5.4 匿名对象的应用场景"></a>5.4 匿名对象的应用场景</h3><p>匿名对象有很多实际应用，下面列出一些常见的场景：</p><ol><li><p><strong>临时数据传递：</strong> 在函数调用时传递临时对象，避免了不必要的对象复制。</p><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">processObject</span><span class="params">(<span class="type">const</span> MyClass&amp; obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 处理传入的对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">processObject</span>(<span class="built_in">MyClass</span>(<span class="number">5</span>));  <span class="comment">// 创建一个匿名对象并传递</span></span><br></pre></td></tr></table></figure></li><li><p><strong>简化代码：</strong> 当不需要重复使用对象时，可以通过匿名对象来简化代码，避免创建多余的变量。</p></li><li><p><strong>链式调用：</strong> 匿名对象可以用于链式调用多个函数。</p><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">MyClass</span>().<span class="built_in">sayHello</span>().<span class="built_in">anotherFunction</span>();  <span class="comment">// 链式调用匿名对象的方法</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="5-5-注意事项"><a href="#5-5-注意事项" class="headerlink" title="5.5 注意事项"></a>5.5 注意事项</h3><ul><li><strong>内存管理：</strong> 匿名对象通常是自动管理的，C++会在它们超出作用域后自动销毁。这意味着开发者不需要手动释放内存，但如果匿名对象涉及到动态内存分配（如 <code>new</code>），则需要特别注意内存管理。</li><li><strong>避免悬挂引用：</strong> 由于匿名对象的生命周期很短，必须避免在它销毁后访问它。</li></ul><blockquote><h2 id="传道解惑-1"><a href="#传道解惑-1" class="headerlink" title="传道解惑"></a>传道解惑</h2><h3 id="Q1：为什么匿名对象加-const-可以延长生命周期"><a href="#Q1：为什么匿名对象加-const-可以延长生命周期" class="headerlink" title="Q1：为什么匿名对象加 const 可以延长生命周期?"></a>Q1：为什么匿名对象加 <code>const</code> 可以延长生命周期?</h3><p>将匿名对象加上 <code>const</code> 修饰符，<strong>可以延长其生命周期</strong>。但这种延长的生命周期并不是无条件的，它的背后有一些特定的规则和原理。</p><p>在 C++中，匿名对象的生命周期是由它们的 <strong>作用域</strong> 决定的，通常在一个表达式或函数调用结束时，匿名对象会被销毁。但是，如果将匿名对象声明为 <code>const</code> 类型，它将与一个 <strong>引用</strong> 绑定，从而延长其生命周期。这是因为 <code>const</code> 引用允许我们在对象生命周期结束后，依然通过引用来使用它。</p><h4 id="具体解释："><a href="#具体解释：" class="headerlink" title="具体解释："></a>具体解释：</h4><ol><li><strong>匿名对象与临时对象的生命周期：</strong></li></ol><ul><li><p>默认情况下，匿名对象（临时对象）的生命周期通常非常短，仅限于它的表达式或语句的结束。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">MyClass</span>().<span class="built_in">doSomething</span>();  <span class="comment">// 匿名对象在 doSomething() 执行完后销毁</span></span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li><strong>使用 <code>const</code> 引用延长生命周期：</strong></li></ol><ul><li>当匿名对象绑定到一个 <code>const</code> 引用时，C++会保证匿名对象的生命周期至少延长到该引用的生命周期结束。也就是说，这个引用会“延迟”对象销毁的时机，直到引用被销毁。</li><li><strong>关键点：</strong> <code>const</code> 引用可以延长临时对象的生命周期，使其存在于引用的作用域中，直到引用超出作用域。</li></ul><p>  示例：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">const</span> MyClass&amp; obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    obj.<span class="built_in">doSomething</span>();  <span class="comment">// obj 是对匿名对象的引用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">foo</span>(<span class="built_in">MyClass</span>());  <span class="comment">// 匿名对象绑定到 const 引用 obj</span></span><br><span class="line">    <span class="comment">// 匿名对象在 foo() 返回时才销毁</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  在这个例子中：</p><ul><li><code>MyClass()</code> 创建了一个匿名对象。</li><li>这个匿名对象会被传递给 <code>foo()</code> 函数，并绑定到 <code>const MyClass&amp; obj</code> 上。</li><li>匿名对象的生命周期被延长，直到 <code>obj</code> 超出作用域，也就是 <code>foo()</code> 函数结束。</li></ul><p><strong>临时对象的绑定规则：</strong></p><ul><li>当临时对象（匿名对象）被绑定到一个 <code>const</code> 引用时，C++会延长临时对象的生命周期，直到引用超出作用域。</li><li>这样做的目的是为了避免因临时对象提前销毁而导致引用悬挂问题（即引用一个已销毁的临时对象）。</li></ul><h3 id="例子：匿名对象与-const-引用"><a href="#例子：匿名对象与-const-引用" class="headerlink" title="例子：匿名对象与 const 引用"></a>例子：匿名对象与 <code>const</code> 引用</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">&gt;<span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&gt;&#123;</span><br><span class="line">&gt;<span class="keyword">public</span>:</span><br><span class="line">   <span class="built_in">MyClass</span>()</span><br><span class="line">   &#123;</span><br><span class="line">       cout &lt;&lt; <span class="string">&quot;MyClass 构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   ~<span class="built_in">MyClass</span>()</span><br><span class="line">   &#123;</span><br><span class="line">       cout &lt;&lt; <span class="string">&quot;MyClass 析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">doSomething</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       cout &lt;&lt; <span class="string">&quot;做点什么！&quot;</span> &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="function"><span class="type">void</span> <span class="title">processObject</span><span class="params">(<span class="type">const</span> MyClass&amp; obj)</span></span></span><br><span class="line"><span class="function">&gt;</span>&#123;</span><br><span class="line">   obj.<span class="built_in">doSomething</span>();  <span class="comment">// 这里 obj 是对匿名对象的引用</span></span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">&gt;</span>&#123;</span><br><span class="line">   <span class="built_in">processObject</span>(<span class="built_in">MyClass</span>());  <span class="comment">// 匿名对象绑定到 const 引用 obj</span></span><br><span class="line">   <span class="comment">// 匿名对象的生命周期会被延长，直到 processObject 返回</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;MyClass 构造函数</span><br><span class="line">&gt;做点什么！</span><br><span class="line">&gt;MyClass 析构函数</span><br></pre></td></tr></table></figure><p><strong>解释：</strong></p><ul><li>在 <code>processObject</code> 函数中，<code>MyClass()</code> 创建了一个匿名对象，它被传递并绑定到 <code>const MyClass&amp; obj</code>。</li><li>由于 <code>obj</code> 是 <code>const</code> 引用，匿名对象的生命周期被延长，直到 <code>processObject</code> 函数返回。</li><li>匿名对象的析构函数只会在 <code>processObject</code> 函数结束后调用。</li></ul><h3 id="重要说明："><a href="#重要说明：" class="headerlink" title="重要说明："></a>重要说明：</h3><ul><li><strong><code>const</code> 引用延长生命周期的作用范围：</strong> <code>const</code> 引用的作用是延长临时对象的生命周期，<strong>直到引用超出作用域</strong>。这意味着匿名对象在引用的作用域内存在，引用超出作用域后，匿名对象才会销毁。而这样做是为了避免临时对象在使用时被提前销毁，确保引用对象的有效性。这种机制是 C++中的一种特性，它通过引用的生命周期来保证匿名对象在函数作用域内的安全访问。</li><li><strong>非 <code>const</code> 引用不允许绑定临时对象：</strong> 如果你尝试用一个非 <code>const</code> 引用绑定临时对象，C++ 编译器会报错，因为非 <code>const</code> 引用无法延长临时对象的生命周期。</li></ul><hr><h3 id="Q2：匿名对象-VS-有名对象"><a href="#Q2：匿名对象-VS-有名对象" class="headerlink" title="Q2：匿名对象 VS 有名对象"></a>Q2：匿名对象 VS 有名对象</h3><p><strong>匿名对象</strong> 和 <strong>有名对象</strong> 在 C++中的最大区别在于命名、生命周期以及访问方式。匿名对象通常用于临时需要的场合，生命周期短，而有名对象则用于需要在多个地方访问和操作的情形，生命周期较长。下面我将详细解释：</p><p><strong>命名</strong></p><ul><li><p>匿名对象（Anonymous Object）：顾名思义，它没有明确的名称，通常是临时创建的对象，不会绑定到变量上。</p></li><li><p>例如：<code>MyClass().doSomething();</code>，在这里 <code>MyClass()</code> 创建了一个匿名对象，它没有名称，仅用于调用 <code>doSomething()</code> 方法。</p></li><li><p>有名对象（Named Object）：有明确的名称，可以通过变量名访问。</p></li><li><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyClass obj;  <span class="comment">// obj 是有名对象</span></span><br><span class="line">obj.<span class="built_in">doSomething</span>();</span><br></pre></td></tr></table></figure></li></ul><p><strong>生命周期</strong></p><ul><li>匿名对象：生命周期非常短暂，仅存在于当前表达式或者语句中，一旦使用完毕，匿名对象会被销毁。</li><li>例如：<code>MyClass().doSomething();</code> 中，匿名对象会在调用 <code>doSomething()</code> 后立刻销毁。</li><li>有名对象：生命周期通常由它的作用域决定。对象在创建时分配内存，并在其作用域结束时被销毁。如果对象在栈上创建，它会在离开作用域时销毁；如果在堆上创建，则需要手动释放内存。</li><li>例如：<code>MyClass obj;</code> 在 <code>obj</code> 离开作用域时销毁。</li></ul><p><strong>访问方式</strong></p><ul><li><strong>匿名对象</strong>：不能通过变量名访问，因为它没有名称。只能在它创建的上下文中直接使用它。</li><li>例如：<code>MyClass().doSomething();</code> 中没有 <code>MyClass</code> 对象的名称，无法在之后访问它。</li><li><strong>有名对象</strong>：可以通过对象的名称来引用和访问对象的成员。</li><li>例如：<code>obj.doSomething();</code> 中，<code>obj</code> 是有名对象，可以在之后的代码中多次使用。</li></ul><p><strong>内存管理</strong></p><ul><li><strong>匿名对象</strong>：由于没有名称，它通常是栈上分配的，编译器在合适的时候自动管理内存。对于返回值优化（RVO&#x2F;NRVO）等，编译器会优化创建匿名对象的内存管理，避免不必要的拷贝。</li><li><strong>有名对象</strong>：有名称，可以显式创建在栈上或堆上。栈上的对象在作用域结束时自动销毁，而堆上的对象则需要手动 <code>delete</code>。</li></ul><p><strong>应用场景</strong></p><p><strong>匿名对象</strong>：</p><ul><li><p>适用于 <strong>临时使用</strong>，例如一次性计算或者在函数调用中使用临时对象。</p></li><li><p>常见于函数返回值、类型转换、临时数据传递等场景。</p></li><li><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">processObject</span><span class="params">(MyClass obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    obj.<span class="built_in">doSomething</span>();</span><br><span class="line">&#125;</span><br><span class="line">                     </span><br><span class="line"><span class="built_in">processObject</span>(<span class="built_in">MyClass</span>());  <span class="comment">// 匿名对象作为参数传递</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>有名对象</strong>：</p><ul><li><p>适用于 <strong>需要多次访问</strong> 的场景，或者需要在多个地方使用该对象。</p></li><li><p>典型用法是作为类的实例，创建时需要明确的对象名来进行后续操作。</p></li><li><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyClass obj;  <span class="comment">// 有名对象</span></span><br><span class="line">obj.<span class="built_in">doSomething</span>();  <span class="comment">// 可以在后续访问该对象</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>返回值优化（RVO&#x2F;NRVO）</strong></p><ul><li><p><strong>匿名对象</strong> 在函数返回值时，编译器会尽可能优化，避免多余的拷贝操作，这被称为 <strong>返回值优化</strong>（RVO）或者 <strong>命名返回值优化</strong>（NRVO）。这意味着，返回匿名对象时，编译器会直接在调用位置构造返回对象，而不会创建临时对象。</p></li><li><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MyClass <span class="title">createObject</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">MyClass</span>();  <span class="comment">// 匿名对象直接返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>有名对象</strong> 没有这样的优化问题，通常会被拷贝或者移动到调用处，特别是在涉及对象返回时。</p></li></ul><p><strong>性能差异</strong></p><ul><li>匿名对象：由于其生命周期非常短，编译器有时能够优化它们的创建和销毁过程，避免不必要的复制。</li><li>在某些场景中，匿名对象能避免额外的内存分配和释放开销，提升性能。</li><li><strong>有名对象</strong>：虽然生命周期较长，但如果不合理使用，有时会增加额外的开销，尤其是在传递大对象时，可能会发生不必要的拷贝操作。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><table><thead><tr><th>特性</th><th>匿名对象</th><th>有名对象</th></tr></thead><tbody><tr><td><strong>命名</strong></td><td>没有名称，仅为临时对象</td><td>有名称，可以通过变量名访问</td></tr><tr><td><strong>生命周期</strong></td><td>短暂，仅在表达式或函数调用期间存在</td><td>生命周期由作用域决定，作用域结束时销毁</td></tr><tr><td><strong>访问方式</strong></td><td>不能直接访问，通常仅在当前表达式中使用</td><td>可以通过名称多次访问</td></tr><tr><td><strong>内存管理</strong></td><td>编译器自动管理内存，通常是栈上分配</td><td>可以是栈上或堆上，需要显式管理堆对象的内存</td></tr><tr><td><strong>应用场景</strong></td><td>临时数据传递、返回值、一次性计算等</td><td>需要多次使用、存储数据或状态等</td></tr><tr><td><strong>性能差异</strong></td><td>编译器优化可能避免不必要的复制</td><td>如果不小心使用，可能有不必要的拷贝操作### 总结</td></tr></tbody></table></blockquote><hr><h2 id="6-再次理解类和对象"><a href="#6-再次理解类和对象" class="headerlink" title="6. 再次理解类和对象"></a>6. 再次理解类和对象</h2><p>理解 <strong>类</strong> 和 <strong>对象</strong> 的概念，能帮助我们更好地理解面向对象编程（OOP）的核心思想。为了更通俗地讲解这个内容，我们可以通过一个现实中的例子来帮助理解。</p><h3 id="1-类是对事物的抽象"><a href="#1-类是对事物的抽象" class="headerlink" title="1. 类是对事物的抽象"></a>1. 类是对事物的抽象</h3><p>类就像是对某种 <strong>事物</strong>（例如洗衣机）的 <strong>抽象描述</strong>。它是 <strong>对现实中事物的建模</strong>，在程序中描述这个事物的 <strong>属性</strong> 和 <strong>行为</strong>。</p><ul><li><strong>属性</strong>：就是这个事物的特征，比如洗衣机的品牌、颜色、容量等。</li><li><strong>行为</strong>：就是这个事物可以做的事情，比如洗衣机可以“启动”、“停止”、“洗衣服”等。</li></ul><p>举个例子，洗衣机这个事物可以用类来描述：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WashingMachine</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string brand;      <span class="comment">// 洗衣机的品牌</span></span><br><span class="line">    string color;      <span class="comment">// 洗衣机的颜色</span></span><br><span class="line">    <span class="type">int</span> capacity;      <span class="comment">// 洗衣机的容量（比如5kg、10kg）</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Washing machine started.&quot;</span> &lt;&lt; endl;    <span class="comment">// 启动洗衣机</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">stop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Washing machine stopped.&quot;</span> &lt;&lt; endl;      <span class="comment">// 停止洗衣机</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>WashingMachine</code> 类描述了一个洗衣机的 <strong>属性</strong>（<code>brand</code>, <code>color</code>, <code>capacity</code>）和 <strong>行为</strong>（<code>start()</code>，<code>stop()</code>）。这个类的作用就是 <strong>抽象化</strong> 洗衣机，将它的特征和行为描述给计算机。</p><h3 id="2-对象是类的实例化"><a href="#2-对象是类的实例化" class="headerlink" title="2. 对象是类的实例化"></a>2. 对象是类的实例化</h3><p>类是对现实事物的抽象描述，但计算机无法直接“认识”类，必须通过 <strong>实例化</strong> 类来创建 <strong>对象</strong>，而对象才是计算机可以操作的具体实体。</p><ul><li><strong>实例化</strong>：就是通过类创建具体的对象的过程。</li><li><strong>对象</strong>：是类的具体实例，表示现实世界中的某个具体的事物。比如，你可以通过 <code>WashingMachine</code> 类创建多个洗衣机对象，每个对象代表一个具体的洗衣机。</li></ul><p>例子继续，假设我们现在创建了一个洗衣机对象：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WashingMachine</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string brand;      <span class="comment">// 洗衣机的品牌</span></span><br><span class="line">    string color;      <span class="comment">// 洗衣机的颜色</span></span><br><span class="line">    <span class="type">int</span> capacity;      <span class="comment">// 洗衣机的容量（单位：kg）</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Washing machine started.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">stop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Washing machine stopped.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">wash</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Washing clothes...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    WashingMachine wm1;</span><br><span class="line">    wm<span class="number">1.</span>brand = <span class="string">&quot;小米&quot;</span>;</span><br><span class="line">    wm<span class="number">1.</span>color = <span class="string">&quot;白色&quot;</span>;</span><br><span class="line">    wm<span class="number">1.</span>capacity = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    wm<span class="number">1.</span><span class="built_in">start</span>();  <span class="comment">// 启动洗衣机</span></span><br><span class="line">    wm<span class="number">1.</span><span class="built_in">wash</span>();   <span class="comment">// 洗衣服</span></span><br><span class="line">    wm<span class="number">1.</span><span class="built_in">stop</span>();   <span class="comment">// 停止洗衣机</span></span><br><span class="line"></span><br><span class="line">    WashingMachine wm2;</span><br><span class="line">    wm<span class="number">2.</span>brand = <span class="string">&quot;格力&quot;</span>;</span><br><span class="line">    wm<span class="number">2.</span>color = <span class="string">&quot;黑色&quot;</span>;</span><br><span class="line">    wm<span class="number">2.</span>capacity = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    wm<span class="number">2.</span><span class="built_in">start</span>();</span><br><span class="line">    wm<span class="number">2.</span><span class="built_in">wash</span>();</span><br><span class="line">    wm<span class="number">2.</span><span class="built_in">stop</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>wm1</code> 和 <code>wm2</code> 是 <code>WashingMachine</code> 类的两个 <strong>对象</strong>。它们分别代表两个不同的洗衣机，每个对象的属性（<code>brand</code>, <code>color</code>, <code>capacity</code>）可以有不同的值。通过这些对象，我们可以模拟现实中的多个洗衣机。</p><h3 id="3-通过类创建对象"><a href="#3-通过类创建对象" class="headerlink" title="3. 通过类创建对象"></a>3. 通过类创建对象</h3><p>从以上的例子可以看出，类只是描述了洗衣机的属性和行为，而对象才是 <strong>具体的实例</strong>。你可以通过类创建出多个对象，每个对象都代表一个具体的事物。类就像是一个模板或蓝图，具体的对象是根据这个模板生成的。</p><h3 id="4-类和对象的关系"><a href="#4-类和对象的关系" class="headerlink" title="4. 类和对象的关系"></a>4. 类和对象的关系</h3><ul><li><strong>类</strong> 是对 <strong>事物</strong> 的一种描述，它定义了这个事物的 <strong>属性</strong> 和 <strong>行为</strong>。</li><li><strong>对象</strong> 是类的 <strong>实例</strong>，是计算机可以直接操作的具体实体。通过类可以创建多个对象，每个对象都有不同的属性值和方法。</li></ul><p>总结一下，类和对象的关系可以类比为：</p><ul><li><strong>类</strong>：就像是一本 <strong>描述洗衣机的说明书</strong>，它告诉我们洗衣机有哪些属性（品牌、颜色、容量）和行为（启动、停止）。</li><li><strong>对象</strong>：就像是根据这本说明书实际生产出来的 <strong>具体洗衣机</strong>。每一台洗衣机都有自己的品牌、颜色、容量等信息，并可以执行启动、停止等操作。</li></ul><h3 id="5-现实中的例子：洗衣机类"><a href="#5-现实中的例子：洗衣机类" class="headerlink" title="5. 现实中的例子：洗衣机类"></a>5. 现实中的例子：洗衣机类</h3><p>让我们通过现实中的洗衣机来进一步理解。</p><ol><li><strong>抽象洗衣机</strong>：当我们想到洗衣机时，我们并不会想到具体某一台洗衣机，而是先想到了“洗衣机”这个概念。它有品牌、颜色、容量这些特征，并且有启动、停止这些操作。这就是 <strong>类</strong> 的作用：把这些共性的特征和行为总结出来。</li><li><strong>创建洗衣机对象</strong>：当你去买洗衣机时，你选择了一个品牌、颜色、容量等具体参数的洗衣机。每一台洗衣机就是一个 <strong>对象</strong>，它是类的实例化。</li><li><strong>操作洗衣机</strong>：当你开始使用这台洗衣机时，你可以通过按按钮来“启动”和“停止”，这就是对象通过类提供的操作（方法）来实现的行为。</li></ol><hr><h3 id="SO-1"><a href="#SO-1" class="headerlink" title="SO:"></a>SO:</h3><ul><li><strong>类</strong> 是对现实世界中事物的抽象描述，它总结了事物的 <strong>属性</strong> 和 <strong>行为</strong>。</li><li><strong>对象</strong> 是类的具体实例，是计算机能够识别和操作的实体。</li><li><strong>类</strong> 是对事物的抽象描述，而 <strong>对象</strong> 是根据类创建的具体实例。</li><li>通过 <strong>类</strong>，我们可以创建多个不同的 <strong>对象</strong>，每个对象具有类中定义的属性和行为。</li></ul><p>通过理解类和对象的关系，你将能够更好地理解面向对象编程（OOP）的核心思想，这对于学习和使用 C++、Java 等面向对象语言非常重要。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 类与对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>03 类与对象（中）</title>
      <link href="/posts/30432.html"/>
      <url>/posts/30432.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-类的-6-个默认成员函数"><a href="#1-类的-6-个默认成员函数" class="headerlink" title="1. 类的 6 个默认成员函数"></a>1. 类的 6 个默认成员函数</h2><p><strong>默认成员函数的含义</strong>：<br> 即使一个类什么都不写，编译器也会默认生成 <code>4</code> 以下个成员函数：</p><ol><li><strong>默认构造函数</strong>（初始化对象时调用）。</li><li><strong>拷贝构造函数</strong>（用已有对象创建新对象时调用）。</li><li><strong>析构函数</strong>（对象生命周期结束时调用）。</li><li><strong>赋值运算符重载</strong>（用 <code>=</code> 赋值时调用）。</li></ol><p>可以直接使用的操作符：</p><ol><li><strong>取地址操作符</strong> <code>&amp;</code>。</li><li><strong>常量取地址操作符</strong> <code>const &amp;</code>。</li></ol><p><strong>代码示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 空类，未显式定义任何成员函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Example e1;  <span class="comment">// 调用默认构造函数</span></span><br><span class="line">    Example e2 = e1;  <span class="comment">// 调用拷贝构造函数</span></span><br><span class="line">    Example* ePtr = &amp;e1;  <span class="comment">// 调用取地址操作符</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 在程序结束时，e1 和 e2 调用析构函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h2 id="传道解惑："><a href="#传道解惑：" class="headerlink" title="传道解惑："></a>传道解惑：</h2><h3 id="Q1：e1——类的实例化："><a href="#Q1：e1——类的实例化：" class="headerlink" title="Q1：e1——类的实例化："></a>Q1：<code>e1</code>——类的实例化：</h3><ul><li><strong>实例化</strong>（Instantiating）指的是通过类来创建对象的过程。当你写出类似 <code>Example e1;</code> 的代码时，<code>e1</code> 就是 <code>Example</code> 类的一个实例（对象）。实例化的本质就是通过类（<code>Example</code>）来创建一个具体的对象（<code>e1</code>）。</li><li><strong>类</strong> 是一种模板或者蓝图，它描述了对象的属性和行为，但它本身不是一个具体的对象。类可以看作是定义对象的结构和功能，而实例化就是将类的结构和功能变成一个可以使用的具体对象。</li></ul><p><strong>举个例子</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">Example</span></span><br><span class="line">&gt;&#123;</span><br><span class="line">&gt;<span class="keyword">public</span>:</span><br><span class="line">   <span class="type">int</span> value;  <span class="comment">// 类的成员</span></span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">&gt;</span>&#123;</span><br><span class="line">   Example e1;  <span class="comment">// 创建一个名为 e1 的 Example 类对象</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><ul><li><code>Example</code> 是一个类，定义了一个成员变量 <code>value</code>。</li><li><code>e1</code> 是通过 <code>Example</code> 类进行实例化的对象。它是 <code>Example</code> 类的一个具体实例。</li></ul><hr><h3 id="Q2：ePtr-——-Example-类的指针："><a href="#Q2：ePtr-——-Example-类的指针：" class="headerlink" title="Q2：ePtr —— Example 类的指针："></a>Q2：<code>ePtr</code> —— <code>Example</code> 类的指针：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;Example* ePtr = &amp;e1;</span><br></pre></td></tr></table></figure><ul><li><code>ePtr</code> 是一个指向 <code>Example</code> 类对象的指针。<code>Example*</code> 表示“指向 <code>Example</code> 类的指针”。</li><li><code>&amp;e1</code> 表示取 <code>e1</code> 对象的地址，也就是 <code>ePtr</code> 指向 <code>e1</code> 的内存位置。</li><li><code>ePtr</code> 可以通过指针操作访问 <code>e1</code> 对象的成员（虽然在这个示例中 <code>Example</code> 类没有成员）。</li></ul></blockquote><p>&#x3D;&#x3D;<strong>注意</strong>&#x3D;&#x3D;：如果用户显式定义任何一个成员函数，编译器将不再生成对应的默认版本。</p><hr><h2 id="2-构造函数"><a href="#2-构造函数" class="headerlink" title="2. 构造函数"></a>2. 构造函数</h2><p><strong>构造函数</strong>（Constructor）：是类的一个特殊成员函数，用于在创建对象时进行初始化。构造函数的名字与类名相同，并且没有返回值。它可以是 <strong>无参构造函数</strong>（即默认构造函数）或者 <strong>带参构造函数</strong>（即带参数的构造函数），主要是用于初始化对象的成员函数，可以有参数。</p><ul><li><strong>无参构造函数</strong>（Default Constructor）：也称作 <strong>默认构造函数</strong>，是一种特殊类型的构造函数，<strong>没有参数</strong>。它用于当创建对象时不需要传递任何参数，如果类没有其他构造函数，编译器通常会自动提供一个默认的版本。（<strong>所以</strong>，默认构造函数是一种特殊的构造函数，是构造函数的一种形式，可以是显式定义的，也可以是编译器自动生成的，通常在创建对象时，如果没有传递任何参数，就会调用它）</li><li><strong>带参构造函数</strong>（Parameterized Constructor）：是另一种构造函数，它 <strong>带有参数</strong>，在创建对象时，通过传递不同的参数来定制对象的初始化。</li></ul><blockquote><p>构造函数是 C++ 中用于初始化对象的特殊函数。它的名字虽然叫“构造”，但它的主要任务不是开辟内存空间，而是初始化对象的成员变量。以下是构造函数 <code>7</code> 个特征：</p><h4 id="1-函数名与类名相同"><a href="#1-函数名与类名相同" class="headerlink" title="1. 函数名与类名相同"></a>1. 函数名与类名相同</h4><ul><li><p>构造函数的名字和类名完全一样，这是 C++ 的规定，用于识别构造函数。</p></li><li><p>例子：</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&gt;&#123;</span><br><span class="line">&gt;<span class="keyword">public</span>:</span><br><span class="line">   <span class="built_in">MyClass</span>()</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="comment">// 初始化代码</span></span><br><span class="line">   &#125;</span><br><span class="line">&gt;&#125;;</span><br></pre></td></tr></table></figure><h4 id="2-无返回值"><a href="#2-无返回值" class="headerlink" title="2. 无返回值"></a>2. 无返回值</h4><ul><li>构造函数没有返回值，也不能定义返回类型（包括 <code>void</code>）。</li><li>理由：构造函数的目的是初始化对象，不需要返回任何东西，调用它的结果就是一个已初始化的对象。</li></ul><h4 id="3-对象实例化时，自动调用构造函数"><a href="#3-对象实例化时，自动调用构造函数" class="headerlink" title="3. 对象实例化时，自动调用构造函数"></a>3. 对象实例化时，自动调用构造函数</h4><ul><li>构造函数会在对象创建时由编译器自动调用，无需显式调用。例如：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&gt;&#123;</span><br><span class="line">&gt;<span class="keyword">public</span>:</span><br><span class="line">   <span class="built_in">MyClass</span>()</span><br><span class="line">   &#123;</span><br><span class="line">       cout &lt;&lt; <span class="string">&quot;构造函数被调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;MyClass obj; <span class="comment">// 自动调用构造函数</span></span><br></pre></td></tr></table></figure><h4 id="4-构造函数可以重载"><a href="#4-构造函数可以重载" class="headerlink" title="4. 构造函数可以重载"></a>4. 构造函数可以重载</h4><ul><li><p>构造函数支持重载（即可以有多个构造函数，但参数列表必须不同）。</p></li><li><p>通过重载，用户可以根据需要初始化对象：</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&gt;&#123;</span><br><span class="line">&gt;<span class="keyword">public</span>:</span><br><span class="line">   <span class="built_in">MyClass</span>()</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="comment">// 无参构造函数</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">MyClass</span>(<span class="type">int</span> x)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="comment">// 带参数的构造函数</span></span><br><span class="line">   &#125;</span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;MyClass obj1;     <span class="comment">// 调用无参构造函数</span></span><br><span class="line">&gt;<span class="function">MyClass <span class="title">obj2</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">// 调用带参构造函数</span></span><br></pre></td></tr></table></figure><h4 id="5-默认构造函数的生成规则"><a href="#5-默认构造函数的生成规则" class="headerlink" title="5. 默认构造函数的生成规则"></a>5. 默认构造函数的生成规则</h4><ul><li><p>如果类中没有显式定义无参构造函数，编译器会自动生成一个默认无参构造函数。</p></li><li><p>如果用户显式定义了任意构造函数（无论是否带参数），编译器将不再生成默认无参构造函数，除非显式定义一个无参构造函数。</p></li><li><p>例子：</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&gt;&#123;</span><br><span class="line">   <span class="type">int</span> x;</span><br><span class="line">&gt;&#125;;</span><br><span class="line">&gt;MyClass obj; <span class="comment">// 自动生成无参默认构造函数</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">MyClass2</span></span><br><span class="line">&gt;&#123;</span><br><span class="line">&gt;<span class="keyword">public</span>:</span><br><span class="line">   <span class="built_in">MyClass2</span>(<span class="type">int</span> y) &#123;&#125;</span><br><span class="line">&gt;&#125;;</span><br><span class="line">&gt;MyClass2 obj2; <span class="comment">// 错误，因为没有无参构造函数</span></span><br></pre></td></tr></table></figure><h4 id="6-默认构造函数对内置和自定义类型的处理"><a href="#6-默认构造函数对内置和自定义类型的处理" class="headerlink" title="6. 默认构造函数对内置和自定义类型的处理"></a>6. 默认构造函数对内置和自定义类型的处理</h4><ul><li><p><strong>内置类型（如 <code>int</code>, <code>char</code>）</strong>：</p></li><li><p>默认构造函数不会初始化内置类型成员，成员变量可能是随机值。例如：</p></li></ul> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x; <span class="comment">// 默认值是随机的</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>解决方法：使用 C++11 提供的默认值：</li></ul> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>; <span class="comment">// 默认值为 0</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p><strong>自定义类型（如 <code>class</code>, <code>struct</code>）</strong>：</p></li><li><p>编译器生成的默认构造函数会调用这些类型成员的默认构造函数。</p></li><li><p>例子：</p></li></ul> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Inner</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Inner</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Inner 构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span></span><br><span class="line">&#123;</span><br><span class="line">    Inner obj; <span class="comment">// 自定义类型成员</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Outer obj; <span class="comment">// 实例化自定义类型成员</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：Inner 构造函数</span><br></pre></td></tr></table></figure><h4 id="7-默认构造函数的种类"><a href="#7-默认构造函数的种类" class="headerlink" title="7. 默认构造函数的种类"></a>7. 默认构造函数的种类</h4><p><strong>无参的构造函数</strong> 和 <strong>全缺省的构造函数</strong>（所有参数都有默认值的构造函数）都称为 <strong>默认构造函数</strong>，并且默认构造函数只能有一个。</p><p>注意：无参构造函数、全缺省构造函数、我们没写编译器默认生成的构造函数，都可以认为是默认构造函数。</p><ul><li><p><strong>无参构造函数</strong>：没有任何参数的构造函数。</p></li><li><p><strong>全缺省构造函数</strong>：所有参数都有默认值的构造函数。 两者都属于默认构造函数的范畴，但它们的定义和使用场景有所不同。</p></li><li><p>例子：</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&gt;&#123;</span><br><span class="line">&gt;<span class="keyword">public</span>:</span><br><span class="line">   <span class="built_in">MyClass</span>() &#123;&#125; <span class="comment">// 无参构造函数</span></span><br><span class="line">   <span class="built_in">MyClass</span>(<span class="type">int</span> x = <span class="number">0</span>) &#123;&#125; <span class="comment">// 全缺省构造函数</span></span><br><span class="line">&gt;&#125;;</span><br></pre></td></tr></table></figure><hr><p>构造函数的核心是初始化对象的成员，而非创建内存空间。默认构造函数的行为取决于对象成员的类型：</p><ul><li>内置类型成员默认不初始化，可能是随机值。</li><li>自定义类型成员会自动调用其默认构造函数。</li></ul><p>通过合理设计构造函数，可以确保对象在创建时处于有效的初始状态。（在 C++11 及更高版本中，编译器还会生成 <strong>移动构造函数</strong> 和 <strong>移动赋值运算符</strong>，用于优化资源管理。这些函数允许对象在移动语义下高效地转移资源，而不是进行拷贝。例如，移动构造函数可以将一个临时对象的资源直接转移给新对象，避免不必要的拷贝操作。这些内容将在后续章节中详细介绍。）</p></blockquote><h3 id="2-1-无参构造函数（默认构造函数）"><a href="#2-1-无参构造函数（默认构造函数）" class="headerlink" title="2.1. 无参构造函数（默认构造函数）"></a>2.1. 无参构造函数（默认构造函数）</h3><p>没有参数，创建对象时会被默认调用。</p><ul><li>如果用户没有定义任何构造函数，编译器会生成一个无参构造函数。</li><li>一旦用户定义了任何构造函数，编译器将不再生成。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Date</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        year = <span class="number">2025</span>;</span><br><span class="line">        month = <span class="number">1</span>;</span><br><span class="line">        day = <span class="number">1</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;无参构造函数被调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; year &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; month &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; day &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> year, month, day;<span class="comment">// 私有成员变量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Date d;  <span class="comment">// 调用无参构造函数，注意：如果通过无参构造函数创建对象时，对象后面不用跟括号，否则就成了函数声明</span></span><br><span class="line">    d.<span class="built_in">Print</span>();  <span class="comment">// 输出：2025-1-1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-带参构造函数"><a href="#2-2-带参构造函数" class="headerlink" title="2.2 带参构造函数"></a>2.2 带参构造函数</h3><p>可接受参数，并根据用户输入初始化对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Date</span>(<span class="type">int</span> y, <span class="type">int</span> m, <span class="type">int</span> d)</span><br><span class="line">        : <span class="built_in">year</span>(y), </span><br><span class="line">    <span class="built_in">month</span>(m), </span><br><span class="line">    <span class="built_in">day</span>(d)</span><br><span class="line">        &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 如果只定义了带参构造函数，编译器不会生成默认无参构造函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123; cout &lt;&lt; year &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; month &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; day &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> year, month, day;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Date <span class="title">d</span><span class="params">(<span class="number">2025</span>, <span class="number">1</span>, <span class="number">1</span>)</span></span>; <span class="comment">// 正常调用</span></span><br><span class="line">    <span class="comment">// Date d2; // 错误：没有默认无参构造函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h2 id="传道解惑：-1"><a href="#传道解惑：-1" class="headerlink" title="传道解惑："></a>传道解惑：</h2><h3 id="Q1：公有（public）私有（private）部分的关系："><a href="#Q1：公有（public）私有（private）部分的关系：" class="headerlink" title="Q1：公有（public）私有（private）部分的关系："></a>Q1：公有（public）私有（private）部分的关系：</h3><p>在 C++ 中，类的成员（变量和函数）可以被指定为 <strong>公有（public）</strong> 或 <strong>私有（private）</strong>，这些访问控制符决定了成员的访问权限。接下来，我会详细讲解 <strong>公有部分</strong> 和 <strong>私有部分</strong> 的作用和关系。</p><p><strong>公有部分（public）</strong></p><ul><li><strong>访问权限：</strong> 任何外部代码（比如 <code>main()</code> 函数）都可以直接访问和修改公有成员。简单来说，<strong>公有部分</strong> 的成员对外部可见。</li><li><strong>适用场景：</strong> 一般情况下，我们会将类中的 <strong>接口函数</strong> 或 <strong>需要外部访问的数据</strong> 声明为公有，以便外部能够与对象交互。</li></ul><p><strong>私有部分（private）</strong></p><ul><li><strong>访问权限：</strong> 私有成员 <strong>只能在类内部的成员函数中访问</strong>，外部的代码无法直接访问或修改这些成员。<strong>私有部分</strong> 用于隐藏类的内部实现细节，只允许通过公有的接口与外部交互。</li><li><strong>适用场景：</strong> 私有成员通常是 <strong>类的内部数据</strong>，这些数据不希望被外部代码随意修改。通过这种方式，我们可以控制数据的访问权限和保证数据的正确性（通过公有函数进行访问或修改）。</li></ul><p><strong>关系</strong></p><ul><li><strong>数据封装（Encapsulation）：</strong> 这就是面向对象编程的核心之一，即将数据和操作数据的代码封装在一起。私有成员数据保护了对象的内部状态，避免了外部对数据的不恰当修改。公有函数则为外部提供了访问和修改数据的接口。</li><li><strong>分离接口与实现：</strong> 通过将接口函数（如 <code>Print()</code>）放在公有部分，类的使用者只需关心接口如何使用，而不需要知道具体的实现方式。私有部分负责实现细节，公有部分提供与外界的交互。</li><li><strong>保护：</strong> 私有成员提供类的内部实现，而公有成员则提供与外部的交互接口。这种设计有助于 <strong>封装</strong> 和 <strong>数据保护</strong>，确保类的使用者不破坏对象的状态。</li></ul><hr><h3 id="Q2：私有变量是否必须在公有部分出现？"><a href="#Q2：私有变量是否必须在公有部分出现？" class="headerlink" title="Q2：私有变量是否必须在公有部分出现？"></a>Q2：私有变量是否必须在公有部分出现？</h3><p><strong>不需要。</strong></p><p>类中的私有变量 (<code>private</code>) 是可以仅供类内部使用的，它们不一定需要通过公有部分 (<code>public</code>) 暴露出来。私有成员通常是不公开给外部的，所以是非必须出现在公有部分的。实际上，<strong>类的设计应该遵循数据隐藏原则</strong>：即只有通过公有函数，外部才能间接地访问或修改私有数据。这样能保护数据的完整性，避免外部代码直接改变私有数据。如果你希望外部能够访问和操作这些私有变量，通常会提供一些公有方法（如 <code>getter</code> 和 <code>setter</code>）来间接操作它们，但这不是强制的。</p><h3 id="Q3：关于编译器生成的默认成员函数，在不实现构造函数的情况下，编译器会生成默认的构造函数。但是看起来默认构造函数又没什么用？对象调用了编译器生成的默认构造函数，但是对象里依旧是随机值。也就是说，在这里编译器生成的默认构造函数并没有什么用？"><a href="#Q3：关于编译器生成的默认成员函数，在不实现构造函数的情况下，编译器会生成默认的构造函数。但是看起来默认构造函数又没什么用？对象调用了编译器生成的默认构造函数，但是对象里依旧是随机值。也就是说，在这里编译器生成的默认构造函数并没有什么用？" class="headerlink" title="Q3：关于编译器生成的默认成员函数，在不实现构造函数的情况下，编译器会生成默认的构造函数。但是看起来默认构造函数又没什么用？对象调用了编译器生成的默认构造函数，但是对象里依旧是随机值。也就是说，在这里编译器生成的默认构造函数并没有什么用？"></a>Q3：关于编译器生成的默认成员函数，在不实现构造函数的情况下，编译器会生成默认的构造函数。但是看起来默认构造函数又没什么用？对象调用了编译器生成的默认构造函数，但是对象里依旧是随机值。也就是说，在这里编译器生成的默认构造函数并没有什么用？</h3><p>解答：C++把类型分成内置类型(基本类型)和自定义类型。内置类型就是语言提供的数据类型，如：<code>int/char...</code>，自定义类型就是我们使用 <code>class/struct/union</code> 等自己定义的类型，编译器生成默认的构造函数会对自定义类型成员调用的它的默认成员函数。<strong>即编译器生成的默认构造函数在类的成员变量是自定义类型（非内置类型）时，会自动调用这些自定义类型的默认构造函数。这是 C++ 的一个机制，用于确保对象的每个成员都得到正确的初始化。</strong></p><p><strong>具体解释</strong></p><ol><li><strong>内置类型（如 <code>int</code>、<code>float</code> 等）：</strong></li></ol><ul><li><p>编译器生成的默认构造函数不会对内置类型成员进行初始化，这些成员会是随机值。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x; <span class="comment">// 内置类型成员</span></span><br><span class="line">&#125;;</span><br><span class="line">                                            </span><br><span class="line">MyClass obj; <span class="comment">// 编译器生成的默认构造函数不会初始化 x</span></span><br><span class="line">cout &lt;&lt; obj.x; <span class="comment">// 随机值</span></span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li><strong>自定义类型（如 <code>class</code> 或 <code>struct</code>）：</strong></li></ol><ul><li><p>如果类中包含自定义类型的成员变量，编译器生成的默认构造函数会自动调用这些成员的默认构造函数，以初始化它们。</p></li><li><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Inner</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Inner</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Inner 的默认构造函数被调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Inner innerMember; <span class="comment">// 自定义类型成员</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Outer obj; <span class="comment">// 自动调用编译器生成的默认构造函数</span></span><br><span class="line"></span><br><span class="line">输出：Inner 的默认构造函数被调用</span><br></pre></td></tr></table></figure></li><li><p>在这个例子中，<code>Outer</code> 类没有显式定义构造函数，但编译器生成了一个默认构造函数。而这个默认构造函数在初始化 <code>innerMember</code> 时，自动调用了 <code>Inner</code> 类的默认构造函数。</p></li></ul><p><strong>为什么这样设计？</strong></p><ul><li>自定义类型的对象可能需要复杂的初始化工作，比如为动态分配内存、初始化状态等。默认构造函数确保这些工作在创建对象时正确完成。</li><li>内置类型如 <code>int</code>、<code>float</code> 等通常不需要调用构造函数，默认值可以通过 C++11 中的默认值赋予。</li></ul><p>当类中有自定义类型的成员变量时：</p><ol><li>如果没有显式定义构造函数，编译器会生成一个默认构造函数。</li><li>这个默认构造函数会对 <strong>自定义类型成员变量</strong> 调用它们自己的默认构造函数，确保它们被正确初始化。</li></ol><p>这意味着你无需手动初始化这些成员，自定义类型的构造函数会自动运行完成初始化工作。</p></blockquote><hr><h2 id="3-析构函数"><a href="#3-析构函数" class="headerlink" title="3. 析构函数"></a>3. 析构函数</h2><p>析构函数：与构造函数功能相反，析构函数不是完成对对象本身的销毁，局部对象销毁工作是由编译器完成的。而 <strong>对象在销毁时会自动调用析构函数，完成对象中资源的清理工作</strong>。即用于释放资源。</p><p>析构函数是 C++中的一个特殊成员函数，专门用于对象生命周期结束时释放资源。以下是对上述特征的通俗易懂的解释：</p><blockquote><h3 id="3-1-析构函数的-6-个特征："><a href="#3-1-析构函数的-6-个特征：" class="headerlink" title="3.1 析构函数的 6 个特征："></a>3.1 析构函数的 <code>6</code> 个特征：</h3><h4 id="1-析构函数的命名规则：类名前加字符"><a href="#1-析构函数的命名规则：类名前加字符" class="headerlink" title="1. 析构函数的命名规则：类名前加字符 ~"></a>1. 析构函数的命名规则：类名前加字符 <code>~</code></h4><p>析构函数的名字和类名类似，但前面加了一个波浪号 <code>~</code>，它是 C++的规定，用来显式区分析构函数。比如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&gt;&#123;</span><br><span class="line">&gt;<span class="keyword">public</span>:</span><br><span class="line">   ~<span class="built_in">MyClass</span>()</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="comment">// 析构代码</span></span><br><span class="line">   &#125;</span><br><span class="line">&gt;&#125;;</span><br></pre></td></tr></table></figure><h4 id="2-无参数、无返回值类型"><a href="#2-无参数、无返回值类型" class="headerlink" title="2. 无参数、无返回值类型"></a>2. 无参数、无返回值类型</h4><p>析构函数不接受任何参数，也不能返回任何值。它的作用是清理资源，而不是用来进行复杂的逻辑处理，因此不需要参数或返回值。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;~<span class="built_in">MyClass</span>(); <span class="comment">// 不允许带参数或返回值</span></span><br></pre></td></tr></table></figure><h4 id="3-一个类只能有一个析构函数，且不能重载"><a href="#3-一个类只能有一个析构函数，且不能重载" class="headerlink" title="3. 一个类只能有一个析构函数，且不能重载"></a>3. 一个类只能有一个析构函数，且不能重载</h4><p>析构函数唯一且不能有多个版本。C++编译器在编译时，知道如何自动调用析构函数，因此多版本没有意义。</p><h4 id="4-对象生命周期结束时，自动调用析构函数"><a href="#4-对象生命周期结束时，自动调用析构函数" class="headerlink" title="4. 对象生命周期结束时，自动调用析构函数"></a>4. 对象生命周期结束时，自动调用析构函数</h4><p>当一个对象不再需要时（如超出作用域、程序结束或显式删除时），C++编译器会自动调用析构函数，无需手动调用。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&#123;</span><br><span class="line">   MyClass obj; <span class="comment">// 创建对象，调用构造函数</span></span><br><span class="line">&gt;&#125; <span class="comment">// 作用域结束，析构函数自动调用</span></span><br></pre></td></tr></table></figure><p>如果对象是动态分配的，用 <code>delete</code> 释放时也会调用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;MyClass* p = <span class="keyword">new</span> <span class="built_in">MyClass</span>(); <span class="comment">// 动态创建对象</span></span><br><span class="line">&gt;<span class="keyword">delete</span> p; <span class="comment">// 自动调用析构函数</span></span><br></pre></td></tr></table></figure><h4 id="5-默认析构函数：处理类中自定义类型成员的析构"><a href="#5-默认析构函数：处理类中自定义类型成员的析构" class="headerlink" title="5. 默认析构函数：处理类中自定义类型成员的析构"></a>5. 默认析构函数：处理类中自定义类型成员的析构</h4><p>如果没有显式定义析构函数，编译器会生成一个 <strong>默认析构函数</strong>。它会对类中所有非基本类型的成员调用其析构函数，比如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&gt;&#123;</span><br><span class="line">   std::string str; <span class="comment">// 自定义类型成员</span></span><br><span class="line">&gt;&#125;;</span><br></pre></td></tr></table></figure><p>编译器生成的默认析构函数会自动调用 <code>std::string</code> 的析构函数，释放其内部的资源。</p><h4 id="6-没有资源时可以不写，有资源时必须写"><a href="#6-没有资源时可以不写，有资源时必须写" class="headerlink" title="6. 没有资源时可以不写，有资源时必须写"></a>6. 没有资源时可以不写，有资源时必须写</h4><ul><li><strong>没有资源</strong>：如果类中没有动态分配的资源，直接使用编译器生成的默认析构函数即可，在这种情况下，系统生成的默认析构函数已经足够。比如：</li></ul> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> year, month, day; <span class="comment">// 无动态资源</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>有资源</strong>：如果类中有动态分配的资源（如 <code>new</code> 申请的内存），一定要定义析构函数，手动释放这些资源，否则会造成 <strong>内存泄漏</strong>：</li></ul> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span>* arr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Stack</span>(<span class="type">int</span> size)</span><br><span class="line">    &#123;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="type">int</span>[size]; <span class="comment">// 动态分配内存</span></span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Stack</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] arr; <span class="comment">// 释放内存，避免泄漏</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>析构函数的核心作用是 <strong>清理资源</strong>，尤其是在有动态分配资源的情况下。如果没有动态资源，则可以省略不写。C++的编译器会在合适的时候自动调用析构函数，无需我们手动干预。<strong>记住</strong>：如果忘记写析构函数释放资源，程序可能会导致 <strong>内存泄漏</strong>，尤其是当类中包含动态内存时！</p></blockquote><blockquote><h3 id="3-2-示例："><a href="#3-2-示例：" class="headerlink" title="3.2 示例："></a>3.2 示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">&gt;<span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">Example</span></span><br><span class="line">&gt;&#123;</span><br><span class="line">&gt;<span class="keyword">public</span>:</span><br><span class="line">       <span class="built_in">Example</span>()</span><br><span class="line">       &#123;</span><br><span class="line">           cout &lt;&lt; <span class="string">&quot;构造函数被调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       ~<span class="built_in">Example</span>()</span><br><span class="line">       &#123;</span><br><span class="line">           cout &lt;&lt; <span class="string">&quot;析构函数被调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">       &#125;</span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">&gt;</span>&#123;</span><br><span class="line">       Example e;  <span class="comment">// 创建对象时调用构造函数</span></span><br><span class="line">       <span class="comment">// 程序结束时，e 被销毁，析构函数自动调用</span></span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;构造函数被调用</span><br><span class="line">&gt;析构函数被调用</span><br></pre></td></tr></table></figure></blockquote><h2 id="4-拷贝构造函数"><a href="#4-拷贝构造函数" class="headerlink" title="4. 拷贝构造函数"></a>4. 拷贝构造函数</h2><p>拷贝构造函数是 C++ 中的一个特殊构造函数，用于 <strong>通过已有对象初始化一个新对象</strong>（创建一个与已有对象内容完全相同的新对象）。</p><blockquote><h2 id="4-1-拷贝构造函数的-5-个特征："><a href="#4-1-拷贝构造函数的-5-个特征：" class="headerlink" title="4.1 拷贝构造函数的 5 个特征："></a>4.1 拷贝构造函数的 <code>5</code> 个特征：</h2><h4 id="1-拷贝构造函数是构造函数的一个重载形式"><a href="#1-拷贝构造函数是构造函数的一个重载形式" class="headerlink" title="1. 拷贝构造函数是构造函数的一个重载形式"></a>1. 拷贝构造函数是构造函数的一个重载形式</h4><ul><li><p>拷贝构造函数和普通构造函数一样是初始化对象的，但它专门用于用 <strong>另一个对象</strong> 初始化当前对象。</p></li><li><p>它是构造函数的一种重载形式，形式如下：</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&gt;&#123;</span><br><span class="line">&gt;<span class="keyword">public</span>:</span><br><span class="line">   <span class="built_in">MyClass</span>(<span class="type">const</span> MyClass&amp; obj); <span class="comment">// 拷贝构造函数声明</span></span><br><span class="line">&gt;&#125;;</span><br></pre></td></tr></table></figure><ul><li>注意：拷贝构造函数的名字和类名一样，只是参数是当前类对象的引用。</li></ul><h4 id="2-参数必须是类类型的引用"><a href="#2-参数必须是类类型的引用" class="headerlink" title="2. 参数必须是类类型的引用"></a>2. 参数必须是类类型的引用</h4><ul><li>拷贝构造函数的参数只能是 <strong>类类型的引用</strong>，不能用 <strong>值传递</strong>，否则会导致编译器报错或发生死循环：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="built_in">MyClass</span>(<span class="type">const</span> MyClass obj); <span class="comment">// 错误，值传递会导致递归调用</span></span><br></pre></td></tr></table></figure><ul><li>这是因为：</li></ul><ol><li>如果参数使用值传递（<code>MyClass obj</code>），在传递参数时会调用拷贝构造函数。</li><li>拷贝构造函数又会调用自己，导致无限递归，最终栈溢出。</li></ol><ul><li>正确形式：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="built_in">MyClass</span>(<span class="type">const</span> MyClass&amp; obj); <span class="comment">// 使用引用，避免递归</span></span><br></pre></td></tr></table></figure><h4 id="3-默认拷贝构造函数"><a href="#3-默认拷贝构造函数" class="headerlink" title="3. 默认拷贝构造函数"></a>3. 默认拷贝构造函数</h4><ul><li>如果用户没有显式定义拷贝构造函数，<strong>编译器会自动生成一个默认的拷贝构造函数</strong>。</li><li>默认拷贝构造函数会逐字节拷贝对象的成员变量，这种拷贝被称为 <strong>浅拷贝</strong>。</li></ul><p><strong>浅拷贝的含义：</strong></p><ul><li>对于 <strong>内置类型</strong>（如 <code>int</code>、<code>float</code>），直接复制值。</li><li>对于 <strong>自定义类型</strong> 成员，编译器会调用这些成员自己的拷贝构造函数。</li><li>例子：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">&gt;<span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&gt;&#123;</span><br><span class="line">&gt;<span class="keyword">public</span>:</span><br><span class="line">   <span class="type">int</span> a;</span><br><span class="line">   <span class="type">int</span>* p;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">MyClass</span>() : <span class="built_in">a</span>(<span class="number">0</span>), <span class="built_in">p</span>(<span class="literal">nullptr</span>) &#123;&#125;<span class="comment">// 默认构造函数</span></span><br><span class="line">   <span class="built_in">MyClass</span>(<span class="type">const</span> MyClass&amp; other) : <span class="built_in">a</span>(other.a), <span class="built_in">p</span>(other.p) &#123;&#125;<span class="comment">// 拷贝构造函数（浅拷贝）</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 析构函数，用于释放动态分配的内存</span></span><br><span class="line">   ~<span class="built_in">MyClass</span>()</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">if</span> (p != <span class="literal">nullptr</span>)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">delete</span> p;<span class="comment">// 如果 p 指向动态分配的内存，释放它</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">&gt;</span>&#123;</span><br><span class="line">   MyClass obj1;</span><br><span class="line">   obj<span class="number">1.</span>a = <span class="number">10</span>;</span><br><span class="line">   obj<span class="number">1.</span>p = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">20</span>); <span class="comment">// 动态分配内存</span></span><br><span class="line"></span><br><span class="line">   MyClass obj2 = obj1; <span class="comment">// 浅拷贝：obj2 会与 obj1 共享相同的指针 p</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 输出 obj1 和 obj2 的值</span></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;obj1.a = &quot;</span> &lt;&lt; obj<span class="number">1.</span>a &lt;&lt; <span class="string">&quot;, obj1.p = &quot;</span> &lt;&lt; *obj<span class="number">1.</span>p &lt;&lt; endl;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;obj2.a = &quot;</span> &lt;&lt; obj<span class="number">2.</span>a &lt;&lt; <span class="string">&quot;, obj2.p = &quot;</span> &lt;&lt; *obj<span class="number">2.</span>p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 手动释放 obj1 的动态内存</span></span><br><span class="line">   <span class="keyword">delete</span> obj<span class="number">1.</span>p;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 现在 obj2.p 是悬空指针，访问它会导致未定义行为</span></span><br><span class="line">   <span class="comment">// cout &lt;&lt; &quot;obj2.p after obj1.delete: &quot; &lt;&lt; *obj2.p &lt;&lt; endl; // 危险！</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p><strong>问题</strong>：如果类中有指针等动态资源，浅拷贝会导致问题。比如 <code>obj1.p</code> 和 <code>obj2.p</code> 指向同一块内存，释放时可能导致重复释放（<strong>悬空指针</strong>）。</p><h4 id="4-是否需要显式定义拷贝构造函数？"><a href="#4-是否需要显式定义拷贝构造函数？" class="headerlink" title="4. 是否需要显式定义拷贝构造函数？"></a>4. 是否需要显式定义拷贝构造函数？</h4><ul><li><p><strong>没有动态资源时（不涉及指针或资源申请）：</strong> 编译器生成的默认拷贝构造函数已经可以正常工作，可以不写。</p></li><li><p><strong>有动态资源时（涉及指针或资源申请）：</strong> 必须显式定义拷贝构造函数，完成深拷贝，避免内存管理问题。</p></li><li><p><strong>深拷贝的实现：</strong> 深拷贝指的是重新分配内存，并复制内容，而不是直接复制指针地址：</p></li></ul> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span>* p;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自定义拷贝构造函数</span></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">const</span> MyClass&amp; obj)</span><br><span class="line">    &#123;</span><br><span class="line">        a = obj.a;</span><br><span class="line">        p = <span class="keyword">new</span> <span class="built_in">int</span>(*obj.p); <span class="comment">// 深拷贝，重新分配内存</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">MyClass</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> p;  <span class="comment">// 释放动态资源</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="5-拷贝构造函数的典型调用场景"><a href="#5-拷贝构造函数的典型调用场景" class="headerlink" title="5. 拷贝构造函数的典型调用场景"></a>5. 拷贝构造函数的典型调用场景</h4><ul><li><strong>场景 1：使用已有对象创建新对象</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;MyClass obj1;       <span class="comment">// 普通构造函数</span></span><br><span class="line">&gt;MyClass obj2 = obj1; <span class="comment">// 拷贝构造函数</span></span><br></pre></td></tr></table></figure><ul><li><strong>场景 2：函数参数为类类型对象</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(MyClass obj)</span></span>; <span class="comment">// 如果不使用引用，会调用拷贝构造函数</span></span><br></pre></td></tr></table></figure><ul><li><strong>场景 3：函数返回类类型对象</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="function">MyClass <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">&gt;</span>&#123;</span><br><span class="line">   MyClass obj;</span><br><span class="line">   <span class="keyword">return</span> obj; <span class="comment">// 返回时可能调用拷贝构造函数</span></span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><h4 id="提高效率的建议"><a href="#提高效率的建议" class="headerlink" title="提高效率的建议"></a>提高效率的建议</h4><ol><li><strong>传参时使用引用</strong>：避免拷贝对象的开销。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">const</span> MyClass&amp; obj)</span></span>; <span class="comment">// 使用引用，不调用拷贝构造函数</span></span><br></pre></td></tr></table></figure><ol start="2"><li><strong>返回值优化（C++11 的移动语义）：</strong> 对于返回值尽量结合移动构造函数使用，减少不必要的拷贝。</li></ol><p><strong>综上：</strong></p><ul><li>拷贝构造函数是用已有对象初始化新对象的工具。</li><li>编译器默认的拷贝构造函数使用浅拷贝，只能处理简单类（没有动态资源）。</li><li>对于涉及动态资源的类，必须显式定义拷贝构造函数，确保深拷贝，避免内存泄漏或重复释放。</li></ul></blockquote><h3 id="4-2-默认拷贝构造函数"><a href="#4-2-默认拷贝构造函数" class="headerlink" title="4.2 默认拷贝构造函数"></a>4.2 默认拷贝构造函数</h3><p>编译器默认会生成一个浅拷贝版本：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Date</span>(<span class="type">int</span> y, <span class="type">int</span> m, <span class="type">int</span> d) : <span class="built_in">year</span>(y), <span class="built_in">month</span>(m), <span class="built_in">day</span>(d) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123; cout &lt;&lt; year &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; month &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; day &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> year, month, day;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Date <span class="title">d1</span><span class="params">(<span class="number">2025</span>, <span class="number">1</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">    Date d2 = d1;  <span class="comment">// 调用默认拷贝构造函数</span></span><br><span class="line">    d<span class="number">2.</span><span class="built_in">Print</span>();  <span class="comment">// 输出：2025-1-1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-自定义拷贝构造函数"><a href="#4-3-自定义拷贝构造函数" class="headerlink" title="4.3 自定义拷贝构造函数"></a>4.3 自定义拷贝构造函数</h3><p>当对象包含动态资源时，必须显式定义深拷贝逻辑。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Example</span>(<span class="type">int</span> size)</span><br><span class="line">    &#123;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="type">int</span>[size];</span><br><span class="line">        <span class="keyword">this</span>-&gt;size = size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自定义拷贝构造函数</span></span><br><span class="line">    <span class="built_in">Example</span>(<span class="type">const</span> Example&amp; other)</span><br><span class="line">    &#123;</span><br><span class="line">        size = other.size;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="type">int</span>[size];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            arr[i] = other.arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Example</span>() &#123; <span class="keyword">delete</span>[] arr; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span>* arr;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="5-赋值运算符重载"><a href="#5-赋值运算符重载" class="headerlink" title="5. 赋值运算符重载"></a>5. 赋值运算符重载</h2><blockquote><p>C++ 中的 <strong>运算符重载</strong> 允许我们为类或对象定义新的运算符行为，使代码更直观和可读。</p><h2 id="5-1-对运算符重载关键点解释："><a href="#5-1-对运算符重载关键点解释：" class="headerlink" title="5.1 对运算符重载关键点解释："></a>5.1 对运算符重载关键点解释：</h2><h4 id="1-运算符重载的本质"><a href="#1-运算符重载的本质" class="headerlink" title="1. 运算符重载的本质"></a>1. 运算符重载的本质</h4><ul><li><p>运算符重载是通过定义一个特殊的函数，改变运算符对类对象的行为。</p></li><li><p><strong>函数名称：</strong> <code>operator</code> 后接具体运算符。例如：<code>operator+</code> 是用来重载加法运算符的函数。</p></li><li><p><strong>函数原型：</strong></p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;返回值类型 <span class="keyword">operator</span>操作符(参数列表);</span><br></pre></td></tr></table></figure><ul><li>例子：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&gt;&#123;</span><br><span class="line">&gt;<span class="keyword">public</span>:</span><br><span class="line">   MyClass <span class="keyword">operator</span>+(<span class="type">const</span> MyClass&amp; obj);</span><br><span class="line">&gt;&#125;;</span><br></pre></td></tr></table></figure><h4 id="2-运算符重载规则"><a href="#2-运算符重载规则" class="headerlink" title="2. 运算符重载规则"></a>2. 运算符重载规则</h4><ul><li><strong>不能创建新的运算符：</strong> 只能重载已有运算符，不能重载不存在的符号（如 <code>operator@</code> 是非法的）。</li><li><strong>内置类型的运算符不能改变其含义：</strong> 例如整数相加（<code>3 + 5</code>）的行为不能被改变。</li><li><strong>某些运算符不能被重载：</strong> <code>.</code>, <code>.*</code>, <code>::</code>, <code>sizeof</code>, <code>?:</code> 不能被重载。</li><li><strong>至少有一个操作数是类类型：</strong> 不能对完全是内置类型的运算符重载，比如试图重载 <code>int + int</code>。</li></ul><h4 id="3-成员函数-vs-全局函数重载"><a href="#3-成员函数-vs-全局函数重载" class="headerlink" title="3. 成员函数 vs 全局函数重载"></a>3. 成员函数 vs 全局函数重载</h4><ul><li>运算符重载可以是类的 <strong>成员函数</strong> 或 <strong>全局函数</strong>。</li><li><strong>成员函数重载：</strong> 第一个操作数是当前对象，编译器会将操作数传递给隐藏的 <code>this</code> 指针。</li><li><strong>全局函数重载：</strong> 需要将两个操作数都作为参数传递。</li><li><strong>注意：赋值运算符重载（<code>operator=</code>）必须是成员函数，不能是全局函数。</strong></li></ul><h4 id="4-常见运算符重载的实现"><a href="#4-常见运算符重载的实现" class="headerlink" title="4. 常见运算符重载的实现"></a>4. 常见运算符重载的实现</h4><hr><h4 id="赋值运算符重载（operator-）"><a href="#赋值运算符重载（operator-）" class="headerlink" title="赋值运算符重载（operator=）"></a>赋值运算符重载（<code>operator=</code>）</h4><p><strong>特点：</strong></p><ol><li><strong>参数类型：</strong> <code>const T&amp;</code>，避免不必要的拷贝，传引用效率更高。</li><li><strong>返回值类型：</strong> <code>T&amp;</code>，返回对象的引用支持连续赋值（如 <code>a = b = c</code>）。</li><li><strong>检测自赋值：</strong> 检查是否给自己赋值（<code>if (this == &amp;obj)</code>）。</li></ol><ul><li>自赋值检查非常重要，因为如果不检查自赋值，可能会导致资源被错误释放或重复释放。例如，如果 <code>this == &amp;obj</code>，则 <code>delete data;</code> 会释放当前对象的资源，导致后续操作无法正确执行。</li></ul><ol start="4"><li><strong>返回 <code>*this</code>：</strong> 让赋值语句返回当前对象。</li></ol><p><strong>实现：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&gt;&#123;</span><br><span class="line">&gt;<span class="keyword">public</span>:</span><br><span class="line"> <span class="type">int</span>* data;</span><br><span class="line"></span><br><span class="line"> MyClass&amp; <span class="keyword">operator</span>=(<span class="type">const</span> MyClass&amp; obj)</span><br><span class="line"> &#123;</span><br><span class="line">     <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;obj) <span class="comment">// 检测是否自赋值</span></span><br><span class="line">     &#123;</span><br><span class="line">         <span class="keyword">delete</span> data;    <span class="comment">// 释放已有资源</span></span><br><span class="line">         data = <span class="keyword">new</span> <span class="built_in">int</span>(*obj.data); <span class="comment">// 深拷贝，避免共享指针导致问题</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">// 返回当前对象的引用</span></span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;;</span><br></pre></td></tr></table></figure><hr><h4 id="前置-和-后置-重载"><a href="#前置-和-后置-重载" class="headerlink" title="前置++ 和 后置++ 重载"></a>前置++ 和 后置++ 重载</h4><ul><li><strong>前置++（<code>++obj</code>）：</strong> 返回增加后的值。</li><li><strong>后置++（<code>obj++</code>）：</strong> 返回增加前的旧值，调用时会多传一个 <code>int</code> 参数（编译器自动处理）。</li></ul><p><strong>实现：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&gt;&#123;</span><br><span class="line">&gt;<span class="keyword">public</span>:</span><br><span class="line"> <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 前置++，返回引用</span></span><br><span class="line"> MyClass&amp; <span class="keyword">operator</span>++()</span><br><span class="line"> &#123;</span><br><span class="line">     ++value; <span class="comment">// 自增</span></span><br><span class="line">     <span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">// 返回当前对象</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 后置++，返回值</span></span><br><span class="line"> MyClass <span class="keyword">operator</span>++(<span class="type">int</span>)</span><br><span class="line"> &#123;</span><br><span class="line">     MyClass temp = *<span class="keyword">this</span>; <span class="comment">// 保存当前对象</span></span><br><span class="line">     ++value;              <span class="comment">// 自增</span></span><br><span class="line">     <span class="keyword">return</span> temp;          <span class="comment">// 返回旧值</span></span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;;</span><br></pre></td></tr></table></figure><hr><h4 id="加法运算符重载（operator-）"><a href="#加法运算符重载（operator-）" class="headerlink" title="加法运算符重载（operator+）"></a>加法运算符重载（<code>operator+</code>）</h4><p>加法运算符重载支持对象间的相加操作。</p><p><strong>实现：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&gt;&#123;</span><br><span class="line">&gt;<span class="keyword">public</span>:</span><br><span class="line"> <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 重载加法运算符</span></span><br><span class="line"> MyClass <span class="keyword">operator</span>+(<span class="type">const</span> MyClass&amp; obj) <span class="type">const</span></span><br><span class="line"> &#123;</span><br><span class="line">     MyClass result;</span><br><span class="line">     result.value = <span class="keyword">this</span>-&gt;value + obj.value; <span class="comment">// 两个对象相加</span></span><br><span class="line">     <span class="keyword">return</span> result;</span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;;</span><br></pre></td></tr></table></figure><hr><h4 id="5-默认运算符重载-vs-自定义实现"><a href="#5-默认运算符重载-vs-自定义实现" class="headerlink" title="5. 默认运算符重载 vs 自定义实现"></a>5. 默认运算符重载 vs 自定义实现</h4><p><strong>默认行为：</strong></p><ul><li>如果不显式实现赋值运算符（<code>operator=</code>）或拷贝构造函数（<code>operator=</code>），编译器会生成默认版本，逐字节拷贝。</li><li>默认行为对于 <strong>内置类型</strong>（如 <code>int</code>、<code>char</code>）完全适用。</li><li>对于 <strong>动态资源</strong>（如指针），默认行为可能导致 <strong>浅拷贝</strong> 问题（资源共享导致重复释放或悬空指针）。</li></ul><p><strong>是否需要自定义实现：</strong></p><ul><li>如果类中没有动态资源（如只包含内置类型或 STL 容器），默认生成的运算符重载就够用。</li><li>如果类中有动态资源（如指针），必须自定义运算符重载，确保深拷贝和正确释放资源。</li></ul><h4 id="6-为什么返回引用？"><a href="#6-为什么返回引用？" class="headerlink" title="6. 为什么返回引用？"></a>6. 为什么返回引用？</h4><ul><li><p>在运算符重载中，返回引用（<code>T&amp;</code>）有助于提高效率，并支持连续赋值操作（如 <code>a = b = c</code>）。</p></li><li><p>例如赋值运算符：</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;MyClass&amp; <span class="keyword">operator</span>=(<span class="type">const</span> MyClass&amp; obj)</span><br><span class="line">&gt;&#123;</span><br><span class="line">   <span class="comment">// 处理赋值逻辑</span></span><br><span class="line">   <span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">// 返回当前对象的引用</span></span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><ul><li>如果返回值而非引用，则每次赋值都会产生一个临时对象，效率低。</li></ul><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>运算符重载让类对象可以像内置类型一样进行操作，提升了代码的可读性。但以下几点需要注意：</p><ol><li>只有已有的运算符可以被重载，且至少有一个操作数是类类型。</li><li>对于有动态资源的类，必须重载运算符以避免浅拷贝问题。</li><li>返回引用是为了支持连续赋值和提高效率。</li><li>某些运算符不能被重载，比如 <code>.</code>、<code>::</code>、<code>sizeof</code> 和 <code>?:</code>。</li></ol><p>通过合理设计运算符重载，可以让类使用起来更像内置类型，从而写出更加优雅和简洁的代码。</p></blockquote><blockquote><h2 id="5-2-示例："><a href="#5-2-示例：" class="headerlink" title="5.2 示例："></a>5.2 示例：</h2><h4 id="1-默认实现"><a href="#1-默认实现" class="headerlink" title="1. 默认实现"></a>1. 默认实现</h4><p>编译器默认按字节拷贝，可能造成资源冲突。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">Date</span></span><br><span class="line">&gt;&#123;</span><br><span class="line">&gt;<span class="keyword">public</span>:</span><br><span class="line">   <span class="built_in">Date</span>(<span class="type">int</span> y, <span class="type">int</span> m, <span class="type">int</span> d) : <span class="built_in">year</span>(y), <span class="built_in">month</span>(m), <span class="built_in">day</span>(d) &#123;&#125;</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123; cout &lt;&lt; year &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; month &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; day &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> year, month, day;</span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">&gt;</span>&#123;</span><br><span class="line">   <span class="function">Date <span class="title">d1</span><span class="params">(<span class="number">2025</span>, <span class="number">1</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">   <span class="function">Date <span class="title">d2</span><span class="params">(<span class="number">2024</span>, <span class="number">12</span>, <span class="number">31</span>)</span></span>;</span><br><span class="line">   d2 = d1;  <span class="comment">// 调用默认赋值运算符</span></span><br><span class="line">   d<span class="number">2.</span><span class="built_in">Print</span>();  <span class="comment">// 输出：2025-1-1</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><h4 id="2-重载赋值运算符"><a href="#2-重载赋值运算符" class="headerlink" title="2. 重载赋值运算符"></a>2. 重载赋值运算符</h4><p>当对象管理动态资源时，需要自定义赋值运算符。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">Example</span></span><br><span class="line">&gt;&#123;</span><br><span class="line">&gt;<span class="keyword">public</span>:</span><br><span class="line">   <span class="built_in">Example</span>(<span class="type">int</span> size)</span><br><span class="line">   &#123;</span><br><span class="line">      arr = <span class="keyword">new</span> <span class="type">int</span>[size];</span><br><span class="line">      <span class="keyword">this</span>-&gt;size = size;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   Example&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Example&amp; other)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other)<span class="comment">// 防止自赋值</span></span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">delete</span>[] arr;</span><br><span class="line">          size = other.size;</span><br><span class="line">          arr = <span class="keyword">new</span> <span class="type">int</span>[size];</span><br><span class="line">          </span><br><span class="line">          <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">          &#123;</span><br><span class="line">              arr[i] = other.arr[i];</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">Example</span>() &#123; <span class="keyword">delete</span>[] arr; &#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">private</span>:</span><br><span class="line">   <span class="type">int</span>* arr;</span><br><span class="line">   <span class="type">int</span> size;</span><br><span class="line">&gt;&#125;;</span><br></pre></td></tr></table></figure><h4 id="重载"><a href="#重载" class="headerlink" title="重载 +"></a>重载 <code>+</code></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">Date</span></span><br><span class="line">&gt;&#123;</span><br><span class="line">&gt;<span class="keyword">public</span>:</span><br><span class="line">   <span class="built_in">Date</span>(<span class="type">int</span> y, <span class="type">int</span> m, <span class="type">int</span> d) : <span class="built_in">year</span>(y), <span class="built_in">month</span>(m), <span class="built_in">day</span>(d) &#123;&#125;</span><br><span class="line">   Date <span class="keyword">operator</span>+(<span class="type">int</span> days) &#123; <span class="keyword">return</span> <span class="built_in">Date</span>(year, month, day + days); &#125;</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123; cout &lt;&lt; year &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; month &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; day &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> year, month, day;</span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">&gt;</span>&#123;</span><br><span class="line">   <span class="function">Date <span class="title">d</span><span class="params">(<span class="number">2025</span>, <span class="number">1</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">   Date d2 = d + <span class="number">5</span>;  <span class="comment">// 日期加5天</span></span><br><span class="line">   d<span class="number">2.</span><span class="built_in">Print</span>();  <span class="comment">// 输出：2025-1-6</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><h4 id="重载-1"><a href="#重载-1" class="headerlink" title="重载 =="></a>重载 <code>==</code></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">Date</span></span><br><span class="line">&gt;&#123;</span><br><span class="line">&gt;<span class="keyword">public</span>:</span><br><span class="line">   <span class="built_in">Date</span>(<span class="type">int</span> y, <span class="type">int</span> m, <span class="type">int</span> d) : <span class="built_in">year</span>(y), <span class="built_in">month</span>(m), <span class="built_in">day</span>(d) &#123;&#125;</span><br><span class="line">   <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Date&amp; other)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">return</span> year == other.year &amp;&amp; month == other.month &amp;&amp; day == other.day;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> year, month, day;</span><br><span class="line">&gt;&#125;;</span><br></pre></td></tr></table></figure></blockquote><h2 id="6-const-成员"><a href="#6-const-成员" class="headerlink" title="6. const 成员"></a>6. <code>const</code> 成员</h2><p>将 <code>const</code> 修饰的“<strong>成员函数</strong>”称之为 <code>const</code> 成员函数，<code>const</code> 成员函数修饰了隐含的 <code>this</code> 指针为 <code>const</code> 类型（<code>const ClassName* this</code>），表示该函数不能修改类的成员变量。但可以通过 <code>mutable</code> 修饰的成员变量在 <code>const</code> 成员函数中进行修改。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Date</span>(<span class="type">int</span> year, <span class="type">int</span> month, <span class="type">int</span> day)</span><br><span class="line">    &#123;</span><br><span class="line">        _year = year;</span><br><span class="line">        _month = month;</span><br><span class="line">        _day = day;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Print()&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;year:&quot;</span> &lt;&lt; _year &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;month:&quot;</span> &lt;&lt; _month &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;day:&quot;</span> &lt;&lt; _day &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PrintConst</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Print(const)&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;year:&quot;</span> &lt;&lt; _year &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;month:&quot;</span> &lt;&lt; _month &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;day:&quot;</span> &lt;&lt; _day &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _year;   <span class="comment">// 年</span></span><br><span class="line">    <span class="type">int</span> _month;  <span class="comment">// 月</span></span><br><span class="line">    <span class="type">int</span> _day;    <span class="comment">// 日</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Date <span class="title">d1</span><span class="params">(<span class="number">2025</span>, <span class="number">1</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">    d<span class="number">1.</span><span class="built_in">Print</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">const</span> Date <span class="title">d2</span><span class="params">(<span class="number">2025</span>, <span class="number">1</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">    d<span class="number">2.</span><span class="built_in">Print</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让我们逐步理解上面代码：</p><ol><li>定义了两个 <code>Print</code> 函数：<ul><li><code>void Print()</code>：普通成员函数，允许修改对象。</li><li><code>void Print() const</code>：<code>const</code> 成员函数，不能修改对象。</li></ul></li><li><code>Test</code> 函数中：<ul><li><code>Date d1(2022, 1, 13);</code> 是普通对象，调用 <code>d1.Print()</code> 时，编译器会选择非 <code>const</code> 版本的 <code>Print()</code>。</li><li><code>const Date d2(2022, 1, 13);</code> 是 <code>const</code> 对象，调用 <code>d2.Print()</code> 时，编译器会选择 <code>const</code> 版本的 <code>Print()</code>。</li></ul></li></ol><h3 id="6-1-总结规则："><a href="#6-1-总结规则：" class="headerlink" title="6.1 总结规则："></a>6.1 总结规则：</h3><ol><li><strong>非 <code>const</code> 对象</strong>：<ul><li>可以调用普通成员函数。</li><li>可以调用 <code>const</code> 成员函数。</li></ul></li><li><strong><code>const</code> 对象</strong>：<ul><li>只能调用 <code>const</code> 成员函数。</li></ul></li><li><strong>普通成员函数</strong>：<ul><li>可以调用普通成员函数。</li><li>不能调用 <code>const</code> 成员函数。</li></ul></li><li><strong><code>const</code> 成员函数</strong>：<ul><li>不能调用普通成员函数。</li><li>可以调用 <code>const</code> 成员函数。</li></ul></li></ol><hr><h3 id="6-2-适用场景："><a href="#6-2-适用场景：" class="headerlink" title="6.2 适用场景："></a>6.2 适用场景：</h3><ul><li>当你希望某个成员函数不修改对象的任何成员变量时，应将其声明为 <code>const</code> 成员函数。</li><li>这样可以确保该函数在 <code>const</code> 对象上调用时不会破坏对象的不可变性。</li><li>例如，<code>Print()</code> 函数通常不需要修改对象状态，因此可以声明为 <code>const</code> 成员函数。</li></ul><hr><h3 id="6-3-关键知识点："><a href="#6-3-关键知识点：" class="headerlink" title="6.3 关键知识点："></a>6.3 关键知识点：</h3><ul><li><strong><code>const</code> 修饰的成员函数</strong>：会将隐含的 <code>this</code> 指针转换为 <code>const</code> 类型（<code>const ClassName* this</code>）。</li><li>编译器通过 <code>const</code> 限定符，保证不会在 <code>const</code> 成员函数中修改成员变量。</li><li>如果非 <code>const</code> 成员变量必须在 <code>const</code> 成员函数中被修改，可以使用 <code>mutable</code> 关键字修饰这些变量，使其在 <code>const</code> 上下文中也可变（但要谨慎使用）。</li></ul><hr><blockquote><h2 id="传道解惑：-2"><a href="#传道解惑：-2" class="headerlink" title="传道解惑："></a>传道解惑：</h2><h3 id="Q1：-const-对象可以调用非-const-成员函数吗？"><a href="#Q1：-const-对象可以调用非-const-成员函数吗？" class="headerlink" title="Q1： const 对象可以调用非 const 成员函数吗？"></a>Q1： <code>const</code> 对象可以调用非 <code>const</code> 成员函数吗？</h3><p><strong>不可以</strong>。</p><p><code>const</code> 对象意味着这个对象的任何成员都不能被修改。非 <code>const</code> 成员函数没有限制修改成员变量的行为，因此 <code>const</code> 对象无法调用非 <code>const</code> 成员函数，否则会破坏 <code>const</code> 对象的不变性。</p><p>在上面代码中，<code>const Date d2</code> 是一个 <code>const</code> 对象，只能调用 <code>Print(const)</code>，不能调用 <code>Print()</code>（非 <code>const</code> 成员函数）。编译器会通过检查 <code>const</code> 属性阻止这种调用。</p><hr><h3 id="Q2：const-对象可以调用-const-成员函数吗？"><a href="#Q2：const-对象可以调用-const-成员函数吗？" class="headerlink" title="Q2：const 对象可以调用 const 成员函数吗？"></a>Q2：<code>const</code> 对象可以调用 <code>const</code> 成员函数吗？</h3><p><strong>可以</strong>。</p><p><code>const</code> 成员函数会修饰 <code>this</code> 指针为 <code>const Date* this</code>，表示该函数内部不会修改类的成员变量。因此 <code>const</code> 对象可以调用 <code>const</code> 成员函数，因为这不会破坏 <code>const</code> 对象的不可变性。</p><p>在上面代码中，<code>d2.Print()</code> 调用的就是 <code>Print(const)</code>，因为 <code>Print(const)</code> 是 <code>const</code> 成员函数。</p><hr><h3 id="Q3：const-成员函数内可以调用其它的非-const-成员函数吗？"><a href="#Q3：const-成员函数内可以调用其它的非-const-成员函数吗？" class="headerlink" title="Q3：const 成员函数内可以调用其它的非 const 成员函数吗？"></a>Q3：<code>const</code> 成员函数内可以调用其它的非 <code>const</code> 成员函数吗？</h3><p><strong>不可以</strong>。</p><p>因为 <code>const</code> 成员函数的 <code>this</code> 指针是 <code>const</code> 的，即 <code>const Date* this</code>，表示它不能修改成员变量。而非 <code>const</code> 成员函数默认的 <code>this</code> 指针是 <code>Date* this</code>，允许修改成员变量。<br>因此，<code>const</code> 成员函数无法调用非 <code>const</code> 成员函数，因为这样可能导致间接修改成员变量，从而违反了 <code>const</code> 的约束。</p><hr><h3 id="Q4-const-成员函数内可以调用其它的-const-成员函数吗？"><a href="#Q4-const-成员函数内可以调用其它的-const-成员函数吗？" class="headerlink" title="Q4: const 成员函数内可以调用其它的 const 成员函数吗？"></a>Q4: <code>const</code> 成员函数内可以调用其它的 <code>const</code> 成员函数吗？</h3><p><strong>可以</strong>。</p><p><code>const</code> 成员函数的 <code>this</code> 指针是 <code>const</code> 的，调用其他 <code>const</code> 成员函数不会违反 <code>const</code> 的约束，因为 <code>const</code> 成员函数保证不修改成员变量。</p></blockquote><h2 id="7-取地址及-const-取地址操作符重载"><a href="#7-取地址及-const-取地址操作符重载" class="headerlink" title="7. 取地址及 const 取地址操作符重载"></a>7. 取地址及 <code>const</code> 取地址操作符重载</h2><p>在 C++中，取地址操作符 <code>&amp;</code> 不能被真正重载。但可以通过定义特殊的成员函数来改变其行为。这种实现方式类似于运算符重载，但并非真正的重载。结合 <code>const</code>，它的行为会更有针对性。（取地址操作符 <code>&amp;</code> 不能被重载的原因是，它是一个基础操作符，用于获取对象的地址。如果允许重载，可能会导致地址获取的语义混乱。）</p><h3 id="7-1-取地址操作符-默认行为"><a href="#7-1-取地址操作符-默认行为" class="headerlink" title="7.1 取地址操作符 &amp; 默认行为"></a>7.1 取地址操作符 <code>&amp;</code> 默认行为</h3><p>默认情况下，<code>&amp;</code> 操作符返回对象的内存地址。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>* px = &amp;x; <span class="comment">// px 获取了 x 的地址</span></span><br></pre></td></tr></table></figure><p>在类中，取地址操作符通常也可以被用来获取对象的地址。</p><h3 id="7-2-取地址操作符的重载"><a href="#7-2-取地址操作符的重载" class="headerlink" title="7.2 取地址操作符的重载"></a>7.2 取地址操作符的重载</h3><p>C++中无法重载取地址操作符 <code>&amp;</code>，但可以通过定义成员函数来改变其行为。例如通过返回自定义指针对象，而不是直接返回 <code>this</code>。重载时可以区分：</p><ol><li>普通对象的取地址。</li><li><code>const</code> 对象的取地址。</li></ol><h3 id="7-3-代码示例与解释"><a href="#7-3-代码示例与解释" class="headerlink" title="7.3 代码示例与解释"></a>7.3 代码示例与解释</h3><p>重载取地址操作符的代码，以下是一个简单示例，展示如何通过 <code>const</code> 和非 <code>const</code> 版本的重载来实现不同的行为。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> value) : _value(value) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非 const 版本的取地址操作符重载</span></span><br><span class="line">    MyClass* <span class="keyword">operator</span>&amp;()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;非 const 取地址操作符被调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// const 版本的取地址操作符重载</span></span><br><span class="line">    <span class="type">const</span> MyClass* <span class="keyword">operator</span>&amp;() <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;const 取地址操作符被调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Display</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; _value &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">MyClass <span class="title">obj</span><span class="params">(<span class="number">10</span>)</span></span>;            <span class="comment">// 普通对象</span></span><br><span class="line">    <span class="function"><span class="type">const</span> MyClass <span class="title">constObj</span><span class="params">(<span class="number">20</span>)</span></span>; <span class="comment">// const 对象</span></span><br><span class="line"></span><br><span class="line">    MyClass* addr1 = &amp;obj;          <span class="comment">// 调用非 const 版本的取地址操作符</span></span><br><span class="line">    <span class="type">const</span> MyClass* addr2 = &amp;constObj; <span class="comment">// 调用 const 版本的取地址操作符</span></span><br><span class="line"></span><br><span class="line">    addr1-&gt;<span class="built_in">Display</span>();</span><br><span class="line">    addr2-&gt;<span class="built_in">Display</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Test</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出结果</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">非 const 取地址操作符被调用</span><br><span class="line">const 取地址操作符被调用</span><br><span class="line">Value: 10</span><br><span class="line">Value: 20</span><br></pre></td></tr></table></figure><p><strong>代码解释</strong></p><ol><li><strong>普通对象调用非 <code>const</code> 版本的取地址操作符</strong>：<ul><li>当我们对普通对象 <code>obj</code> 使用 <code>&amp;</code> 时，调用的是 <code>MyClass* operator&amp;()</code>。</li><li>返回类型是一个非 <code>const</code> 指针，即 <code>MyClass*</code>。</li><li>这意味着我们可以通过这个指针修改 <code>obj</code>。</li></ul></li><li><strong><code>const</code> 对象调用 <code>const</code> 版本的取地址操作符</strong>：<ul><li>当我们对 <code>const</code> 对象 <code>constObj</code> 使用 <code>&amp;</code> 时，调用的是 <code>const MyClass* operator&amp;() const</code>。</li><li>返回类型是 <code>const MyClass*</code>，即一个不可修改的指针。</li><li>这保证了通过返回的地址无法修改 <code>constObj</code>。</li></ul></li></ol><blockquote><h2 id="传道解惑"><a href="#传道解惑" class="headerlink" title="传道解惑"></a>传道解惑</h2><h3 id="Q1：两种版本为什么重要？"><a href="#Q1：两种版本为什么重要？" class="headerlink" title="Q1：两种版本为什么重要？"></a>Q1：两种版本为什么重要？</h3><ul><li>如果只有普通的非 <code>const</code> 重载（<code>MyClass* operator&amp;()</code>），<code>const</code> 对象调用时会报错，因为无法确保 <code>const</code> 对象的不可变性。</li><li>如果只有 <code>const</code> 版本重载（<code>const MyClass* operator&amp;() const</code>），普通对象也只能得到一个 <code>const</code> 指针，限制了可操作性。</li></ul><p>因此，同时提供两个版本：</p><ul><li>普通对象取地址时返回普通指针，灵活操作。</li><li><code>const</code> 对象取地址时返回 <code>const</code> 指针，保护不可变性。</li></ul><hr><h3 id="Q2：取地址操作符重载的应用场景？"><a href="#Q2：取地址操作符重载的应用场景？" class="headerlink" title="Q2：取地址操作符重载的应用场景？"></a>Q2：取地址操作符重载的应用场景？</h3><ol><li><strong>调试日志</strong>：可以在取地址时打印出信息，便于调试。</li><li><strong>对象管理</strong>：可以控制对象暴露出去的指针，避免外部直接操作原始地址。</li><li><strong>定制行为</strong>：对于特定的类，可以在取地址时返回自定义指针对象，而不是直接返回 <code>this</code>。</li></ol><hr><h3 id="Q3：为什么需要区分-const-对象的取地址？"><a href="#Q3：为什么需要区分-const-对象的取地址？" class="headerlink" title="Q3：为什么需要区分 const 对象的取地址？"></a>Q3：为什么需要区分 <code>const</code> 对象的取地址？</h3><p>假如我们不区分 <code>const</code> 和非 <code>const</code> 对象取地址操作，就会产生如下问题：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="function"><span class="type">const</span> MyClass <span class="title">constObj</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line">&gt;MyClass* ptr = &amp;constObj; <span class="comment">// 如果没有 const 重载，这会破坏 constObj 的不可变性</span></span><br></pre></td></tr></table></figure><p>通过引入 <code>const</code> 版本的取地址操作符重载，编译器可以在 <code>const</code> 对象中强制返回 <code>const</code> 指针，保护数据安全。</p><ol><li>取地址操作符重载的作用：</li></ol><ul><li>自定义取地址操作符的行为。</li><li>区分普通对象和 <code>const</code> 对象的地址获取方式。</li></ul><ol start="2"><li>注意事项：</li></ol><ul><li>对普通对象，返回普通指针。</li><li>对 <code>const</code> 对象，返回 <code>const</code> 指针，确保不可变性。</li></ul><p>这是一种增强代码灵活性与安全性的手段，同时对复杂场景（如调试或资源管理）非常有用。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 类与对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>02 类与对象（上）</title>
      <link href="/posts/24103.html"/>
      <url>/posts/24103.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、本节目标"><a href="#一、本节目标" class="headerlink" title="一、本节目标"></a>一、<strong>本节目标</strong></h2><ol><li><strong>面向过程和面向对象初步认识</strong></li><li><strong>类的引入</strong></li><li><strong>类的定义</strong></li><li><strong>类的访问限定符及封装</strong></li><li><strong>类的作用域</strong></li><li><strong>类的实例化</strong></li><li><strong>类的对象大小的计算</strong></li><li><strong>类成员函数的 <code>this</code> 指针</strong></li></ol><h2 id="二、面向过程和面向对象初步认识（过程与面向对象编程）"><a href="#二、面向过程和面向对象初步认识（过程与面向对象编程）" class="headerlink" title="二、面向过程和面向对象初步认识（过程与面向对象编程）"></a>二、面向过程和面向对象初步认识（过程与面向对象编程）</h2><p><strong>面向过程编程（ProceduralProgramming）</strong>：</p><ul><li>关注“<strong>过程</strong>”或“步骤”。</li><li>将问题分解为函数，每个函数执行一个特定的任务。</li><li>主要依赖函数调用，常见于 C 语言。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 面向过程编程: 通过函数处理数据</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">int</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Processing data: %d\n&quot;</span>, data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> data = <span class="number">42</span>;</span><br><span class="line">    <span class="built_in">process</span>(data);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>面向对象编程（Object-OrientedProgramming）</strong>：</p><ul><li>关注“<strong>对象</strong>”，将数据与操作数据的方法结合。</li><li>通过对象之间的交互解决问题，常见于 C++。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Processor</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">int</span> data)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Processing data: &quot;</span> &lt;&lt; data &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Processor p;</span><br><span class="line">    p.<span class="built_in">process</span>(<span class="number">42</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>C 语言是 <strong>面向过程</strong> 的，<strong>关注</strong> 的是 <strong>过程</strong>，分析出求解问题的步骤，通过函数调用逐步解决问题。</li><li>C++是 <strong>基于面向对象</strong> 的，<strong>关注</strong> 的是 <strong>对象</strong>，将一件事情拆分成不同的对象，靠对象之间的交互完成。</li></ul><h2 id="三、类的引入（Introduction-to-Classes）"><a href="#三、类的引入（Introduction-to-Classes）" class="headerlink" title="三、类的引入（Introduction to Classes）"></a>三、类的引入（Introduction to Classes）</h2><p><strong>C 语言结构体中只能定义变量，在 C++中，结构体内不仅可以定义变量，也可以定义函数。</strong> 例如： 之前在数据结构初阶中，用 <strong>C 语言方式实现的栈，结构体中只能定义变量</strong>；但在 C++中，<code>struct</code> 和 <code>class</code> 都可以包含 <strong>变量</strong> 和 <strong>函数</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span> <span class="comment">// for malloc and free</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> DataType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Stack</span></span><br><span class="line">&#123;</span><br><span class="line">    DataType* array;</span><br><span class="line">    <span class="type">size_t</span> capacity;</span><br><span class="line">    <span class="type">size_t</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">(<span class="type">size_t</span> cap)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        array = (DataType*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(DataType) * cap);</span><br><span class="line">        <span class="keyword">if</span> (!array)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;malloc failed&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        capacity = cap;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 压栈操作</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Push</span><span class="params">(<span class="type">const</span> DataType&amp; data)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        array[size++] = data; <span class="comment">// 简化的例子，未考虑扩容</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取栈顶元素</span></span><br><span class="line">    <span class="function">DataType <span class="title">Top</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> array[size - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁栈</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Destroy</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (array)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">free</span>(array);</span><br><span class="line">            array = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Stack s;</span><br><span class="line">    s.<span class="built_in">Init</span>(<span class="number">10</span>);</span><br><span class="line">    s.<span class="built_in">Push</span>(<span class="number">1</span>);</span><br><span class="line">    s.<span class="built_in">Push</span>(<span class="number">2</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Top element: &quot;</span> &lt;&lt; s.<span class="built_in">Top</span>() &lt;&lt; endl;</span><br><span class="line">    s.<span class="built_in">Destroy</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面结构体的定义，<strong>在 C++中更喜欢用 <code>class</code> 来代替</strong>。</p><h2 id="四、类的定义（Defining-a-Class）"><a href="#四、类的定义（Defining-a-Class）" class="headerlink" title="四、类的定义（Defining a Class）"></a>四、类的定义（Defining a Class）</h2><p><strong>类的定义</strong>：<code>class</code> 是定义类的关键字。类是对象的蓝图，包含成员变量（属性）和成员函数（方法）。</p><ul><li><strong>类定义语法</strong>：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ClassName</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 成员变量</span></span><br><span class="line">    <span class="comment">// 成员函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span>为定义类的关键字，ClassName为类的名字，&#123;&#125;中为类的主体，</span><br><span class="line">注意类定义结束时后面分号不能省略。</span><br><span class="line"> </span><br><span class="line">类体中内容称为类的成员：类中的变量称为类的属性或成员变量; </span><br><span class="line">类中的函数称为类的方法或者成员函数。</span><br></pre></td></tr></table></figure><p><strong>两种定义方式</strong>：</p><ol><li><strong>在类体中定义成员函数</strong>：这样的函数可能被编译器视为 <code>inline</code> 内联函数。</li><li><strong>类声明与定义分离</strong>：通常将类的声明放在 <code>.h</code> 文件中，成员函数的定义放在 <code>.cpp</code> 文件中。注意：<strong>成员函数名前需要加类名::</strong></li></ol><p><strong>示例 1：类体中定义所有内容</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">(<span class="type">int</span> year, <span class="type">int</span> month, <span class="type">int</span> day)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _year = year;</span><br><span class="line">        _month = month;</span><br><span class="line">        _day = day;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; _year &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; _month &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; _day &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _year, _month, _day;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Date today;</span><br><span class="line">    today.<span class="built_in">Init</span>(<span class="number">2024</span>, <span class="number">9</span>, <span class="number">22</span>);</span><br><span class="line">    today.<span class="built_in">Print</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例 2：类声明与定义分离</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Date.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">(<span class="type">int</span> year, <span class="type">int</span> month, <span class="type">int</span> day)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _year, _month, _day;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// Date.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Date.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Date::Init</span><span class="params">(<span class="type">int</span> year, <span class="type">int</span> month, <span class="type">int</span> day)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    _year = year;</span><br><span class="line">    _month = month;</span><br><span class="line">    _day = day;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Date::Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; _year &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; _month &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; _day &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Date today;</span><br><span class="line">    today.<span class="built_in">Init</span>(<span class="number">2024</span>, <span class="number">9</span>, <span class="number">22</span>);</span><br><span class="line">    today.<span class="built_in">Print</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五、类的访问限定符及封装（Access-Specifiers-and-Encapsulation）"><a href="#五、类的访问限定符及封装（Access-Specifiers-and-Encapsulation）" class="headerlink" title="五、类的访问限定符及封装（Access Specifiers and Encapsulation）"></a>五、类的访问限定符及封装（Access Specifiers and Encapsulation）</h2><p><strong>访问限定符</strong> 用于控制类的成员是否能够在类外部访问：</p><ul><li><code>public</code>：类外可以访问。</li><li><code>private</code>：类外部不能直接访问，只能通过类的内部方法操作。</li><li><code>protected</code>：类外部无法访问，但在继承中可以访问。</li></ul><p><strong>封装（Encapsulation）</strong>：隐藏类的实现细节，仅对外提供公共接口，保证数据的安全性。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">(<span class="type">int</span> year, <span class="type">int</span> month, <span class="type">int</span> day)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _year = year;</span><br><span class="line">        _month = month;</span><br><span class="line">        _day = day;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; _year &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; _month &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; _day &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _year, _month, _day;  <span class="comment">// 这些变量无法在类外直接访问</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Date today;</span><br><span class="line">    today.<span class="built_in">Init</span>(<span class="number">2024</span>, <span class="number">9</span>, <span class="number">22</span>);</span><br><span class="line">    today.<span class="built_in">Print</span>();  <span class="comment">// 只能通过Print()访问日期信息</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="六、类的作用域（Class-Scope）"><a href="#六、类的作用域（Class-Scope）" class="headerlink" title="六、类的作用域（Class Scope）"></a>六、类的作用域（Class Scope）</h2><p>类的成员定义在类的作用域内，在类外部使用成员函数时，必须用域操作 <code>::</code> 指定该成员属于哪个作用类。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetName</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PrintName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span> _name[<span class="number">20</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类外定义成员函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Person::SetName</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">strcpy</span>(_name, name);  <span class="comment">// 设置名字</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Person::PrintName</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Name: &quot;</span> &lt;&lt; _name &lt;&lt; endl;  <span class="comment">// 打印名字</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Person p;</span><br><span class="line">    p.<span class="built_in">SetName</span>(<span class="string">&quot;Alice&quot;</span>);</span><br><span class="line">    p.<span class="built_in">PrintName</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="七、类的实例化（Instantiation-of-Classes）"><a href="#七、类的实例化（Instantiation-of-Classes）" class="headerlink" title="七、类的实例化（Instantiation of Classes）"></a>七、类的实例化（Instantiation of Classes）</h2><p>类的 <strong>实例化</strong> 是指 <strong>通过类的定义创建对象</strong>，分配实际的内存空间给成员变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetBrand</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* brand)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">strcpy</span>(_brand, brand);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Car brand: &quot;</span> &lt;&lt; _brand &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span> _brand[<span class="number">20</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Car car1, car2;  <span class="comment">// 实例化两个对象</span></span><br><span class="line">    car<span class="number">1.</span><span class="built_in">SetBrand</span>(<span class="string">&quot;Toyota&quot;</span>);</span><br><span class="line">    car<span class="number">2.</span><span class="built_in">SetBrand</span>(<span class="string">&quot;Honda&quot;</span>);</span><br><span class="line"></span><br><span class="line">    car<span class="number">1.</span><span class="built_in">Print</span>();</span><br><span class="line">    car<span class="number">2.</span><span class="built_in">Print</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>类是对对象进行描述的</strong>，是一个 <strong>模型</strong> 一样的东西，限定了类有哪些成员，定义出一个类 <strong>并没有分配实际的内存空间</strong> 来存储它；比如：入学时填写的学生信息表，表格就可以看成是一个类，来描述具体学生信息。</li></ol><p>​类就像谜语一样，对谜底来进行描述，谜底就是谜语的一个实例。</p><p>​谜语：”年纪不大，胡子一把，主人来了，就喊妈妈” 谜底：山羊</p><ol start="2"><li>一个类可以实例化出多个对象，<strong>实例化出的对象 占用实际的物理空间，存储类成员变量</strong></li></ol>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     Person._age = <span class="number">100</span>;   <span class="comment">// 编译失败：error C2059: 语法错误:“.”</span></span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">Person类是没有空间的，只有Person类实例化出的对象才有具体的年龄。</span><br></pre></td></tr></table></figure><ol start="3"><li>做个比方。<strong>类实例化出对象就像现实中使用建筑设计图建造出房子，类就像是设计图</strong>，只设计出需要什么东西，但是并没有实体的建筑存在，同样类也只是一个设计，实例化出的对象才能实际存储数据，占用物理空间</li></ol><h2 id="八、类对象模型（Class-Object-Model）"><a href="#八、类对象模型（Class-Object-Model）" class="headerlink" title="八、类对象模型（Class Object Model）"></a>八、类对象模型（Class Object Model）</h2><p><strong>类对象的大小</strong> 由成员变量的大小决定，成员函数的代码不会占用对象的存储空间。</p><ul><li><strong>空类</strong> 的大小为 1 字节，确保每个对象都有唯一标识。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Empty</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _x;</span><br><span class="line">    <span class="type">char</span> _y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Size of Empty class: &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(Empty) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Size of A: &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(A) &lt;&lt; endl;  <span class="comment">// 由于内存对齐的影响，可能比预期的更大</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结论：一个类的大小，实际就是该类中”成员变量”之和，当然要注意内存对齐。注意空类的大小，空类比较特殊，编译器给了空类一个字节来唯一标识这个类的对象。</strong></p><h3 id="结构体内存对齐规则（Struct-Memory-Alignment-Rules）"><a href="#结构体内存对齐规则（Struct-Memory-Alignment-Rules）" class="headerlink" title="结构体内存对齐规则（Struct Memory Alignment Rules）"></a>结构体内存对齐规则（Struct Memory Alignment Rules）</h3><p><strong>内容对齐</strong> 的规则(<a href="https://blog.csdn.net/Huangcancan666/article/details/140896458?spm=1001.2014.3001.5501">【C 语言】结构体内存布局解析——字节对齐_字节对齐规则-CSDN 博客</a>)：</p><ol><li>第一个成员从偏移量为 0 的位置开始。</li><li>其他成员遵循它们大小的整数倍对齐。</li><li>总大小为最大对齐数的整数倍。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">S1</span> &#123;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">S2</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Size of S1: &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(S1) &lt;&lt; endl;  <span class="comment">// 8字节，内存对齐使得char占4字节</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Size of S2: &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(S2) &lt;&lt; endl;  <span class="comment">// 8字节</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="九、this-指针"><a href="#九、this-指针" class="headerlink" title="九、this 指针"></a>九、this 指针</h2><p>在 C++中，<code>this</code> 指针是一个特殊的指针，用于指向调用成员函数的当前对象（当前对象）。它只在类的非静态成员函数下面可用，是传递方式的。是对 <code>this</code> 指针隐式的详细讲解，包括特性、与 C 语言的对比，以及常见的易错点。</p><h3 id="1-引出：什么是-this-指针？"><a href="#1-引出：什么是-this-指针？" class="headerlink" title="1. 引出：什么是 this 指针？"></a>1. 引出：什么是 <code>this</code> 指针？</h3><p>当一个对象调用其类的非静态成员函数时，编译器会自动传递该对象的地址给函数。<code>this</code> 指针就是该对象的地址的成员函数。它可以用于在成员函数中调用该函数的对象的地址成员。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setValue</span><span class="params">(<span class="type">int</span> value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;value = value;  <span class="comment">// 使用this指针，避免成员变量与参数重名冲突</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="2-特性："><a href="#2-特性：" class="headerlink" title="2. 特性："></a>2. 特性：</h3><ul><li><p><strong>隐式传递</strong>：<code>this</code> 指针不需要显式声明，它在所有非静态成员函数中隐式可用。</p></li><li><p><strong>常量性</strong>：<code>this</code> 指针是常量指针，无法修改其指向的对象。即 <code>this</code> 类型为 <code>MyClass* const</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// this = nullptr; // 错误！无法修改this指针的指向</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>指向当前对象</strong>：<code>this</code> 指向调用该成员函数的当前对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyClass obj;</span><br><span class="line">obj.<span class="built_in">func</span>();  <span class="comment">// this指针指向obj</span></span><br></pre></td></tr></table></figure></li><li><p><strong>在常量成员函数中的 <code>this</code> 指针</strong>：在常量成员函数中，<code>this</code> 指针是指向常量的指针，其类型为 <code>const MyClass* const</code>，表示不能 <code>this</code> 修改对象的数据成员。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// this-&gt;value = 10;  // 错误！无法修改常成员函数中的对象数据</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-与-C-的对比："><a href="#3-与-C-的对比：" class="headerlink" title="3. 与 C 的对比："></a>3. 与 C 的对比：</h3><p>C 语言本身不支持类和对象的概念，因此也不存在 <code>this</code> 指针。在 C 中，要模拟类似的行为，通常需要显式传递结构体指针来访问结构体的成员。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">C++中的<span class="keyword">this</span>指针对应于在C语言中手动传递对象指针给函数的做法：</span><br><span class="line"><span class="comment">// C语言模拟对象方法</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setValue</span><span class="params">(<span class="keyword">struct</span> MyClass* self, <span class="type">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    self-&gt;value = value;</span><br><span class="line">&#125;</span><br><span class="line">在C++中，这种显着式的传递结构指针的方式通过<span class="keyword">this</span>指针抓取方式和自动化，简化了编程。</span><br></pre></td></tr></table></figure><h3 id="4-常见易错点："><a href="#4-常见易错点：" class="headerlink" title="4. 常见易错点："></a>4. 常见易错点：</h3><ul><li><p><strong>修改 <code>this</code> 指针</strong>：<code>this</code> 是常量指针，不能修改其指向对象，错误的代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// this = nullptr; // 错误！无法修改this指针的指向</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>在静态成员函数中使用 <code>this</code></strong>：静态成员函数属于类本身，而不是某个特定对象，因此，静态成员函数中没有 <code>this</code> 指针。如果尝试在静态成员函数中使用 <code>this</code>，会出现编译错误。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">staticFunc</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// this-&gt;value = 10;  // 错误，静态成员函数没有this指针</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>返回 <code>*this</code></strong>：在链式调用时，经常会返回当前对象的引用，返回 <code>*this</code> 是合法的用法。常见的用法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">MyClass&amp; <span class="title">setValue</span><span class="params">(<span class="type">int</span> value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;value = value;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;  <span class="comment">// 返回当前对象的引用，支持链式调用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>在构造函数或解析构造函数中使用 <code>this</code></strong>：在构造函数中使用 <code>this</code> 指针是安全的，但需要注意不要在构造函数中将 <code>this</code> 指针导出出去（比如在构造函数中调用虚函数）。在构造函数中，<code>this</code> 指向即将被关注的对象，因此要小心避免对已关注的资源操作。</p></li></ul><h3 id="5-小结："><a href="#5-小结：" class="headerlink" title="5. 小结："></a>5. 小结：</h3><ul><li><code>this</code> 指针用于指向当前对象，并在非静态成员函数中隐式传递。</li><li>它是一个常量指针，不能修改指向的对象。</li><li>静态成员函数中没有 <code>this</code> 指针。</li><li><code>this</code> 在 C++中简化了对象成员的访问，而在 C 语言中，需要手动传递结构体指针。</li></ul><p>掌握 <code>this</code> 指针有助于理解对象成员的访问方式和 C++类的工作原理。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍了对象编程中的类、对象、封装、作用域、实例化、对象模型、内存定位和 <code>this</code> 指针的详细内容和代码示例。你可以通过编写这些代码加深理解，并尝试修改运行和它们来更好地掌握这些概念。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 类与对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网站搭建</title>
      <link href="/posts/55028.html"/>
      <url>/posts/55028.html</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="0ee4d7a08552d50bbb7479657be27ff661436512a0b755b0c243f0761c140b52">4630436162ade97ba2718b7d0c4b3b6351ade09e539dfebeb5402828e29e64b00862fd9fee4bff3b78a043694af87db91ab2367d0a0d6c9a7707a5102f929bd93874aa1ec8eaa9a52faa7de80e37c1381652388ee8c84a82ba81757f67e055c3f7238c9da64553ca66e38fd3717e8748af1ee4e5eb8f261c8497c813cfd711c68c8e56b114c3e5091c65757a01977a243d64c01844806ac54edbcc2a5db52c2cad4bb1a106f1617870bc6ddca66ba31ea266013bd2d2062c1f8d4c352382e8e3f8470c45090f818c69095af48fb74015b3388d94775f38f1abcad35e26ddb7430d8d2b7e0976d10e1134abedb5d3e36992de610df949deb6a0a8b56f3b339c489dffda0279eeff46b3bfa078a857ad0be63b34b76a86dcf2b4da46dad0af495f2ed9dd96378115d605750541bf9e445463da07bd53d9fd0a3ee0a7b10497fb52b07411fbff5b190c791af46826d348b3b023c721de7862248b75d69a26835975e08e6b923e9411b32c8230e565a75f85aee5b24e60c063aff26e93ee676fcb47aee9f24127357f7a74d235937521c8ffd964ef7ca6bd7da8f3a981e06fa0ebe73e7d665a60fed3c5df32108678c74516e0dd6dff50c6efd3401c87d21a3d9bf46ac88feaaadf32ad560073446440e26fe0289caa9a43a3287ecb5ee1001216e9b217ccb2aebe8b217a3b985623b478eb6b03dc34b45c510d9f27a0fb1cf4b2af5b16907347a33e0514f1600179c8daa04f742138db105349d0872346989a5339a68b8b63d6ec464c8977d1f12dfa58bc21d2142998214afadd73cf8ec2612859502b3ff178a2e5f5046b2124c899c9b0a34c312bb52d6378cd1db1b92ad64d1fa0cf0a3381e6c1f97602e2155e5464fdb6efa7a12219d1dc8053ff599dccafd9878a3d2da5845eba817eba453445f883202e9bb643ff070299a3482ac0103fe814d5d7cad153cfc7318f2f6a17fab0959784068345520056471387cf4eff329ef04afa28b7e58baf3105ef9ff45b55c7483c477d6f055ca0ad5802ad312f8294c6a61b0620a57d24a4d6264a80c36802e1ff94b159ec2b876f90cc0b3fcd79b17074dc5434a19f855d246260803e6e27bb21f52e6664f59dec8cfa2b4c97d68163aab27d3e0d1bd255f4eecd896492e7bf1e78bb70d1de3a6058512fdb8bf03ed71753fe3c37ca2d67ddaab8bf0ed91fe573bab30f005017c033dca4dce4d2e4cde520a9962106211c6fc0522ab5ea247e3e6fa5837f3363f5396c685ef956db4bef42b3e93cb1393adf324a5183b6c189046540d4f1782a6a3804d04b797ae47451705a5671246af0547f6b28c9d864011fdf522b56a7021fa05e925d0b97cbc7042e3c011abc9551e090f2dd0a64a2c789da88d8ede226adac3f11a8001175c586b10051bcc2d074a3fdedb2482bbcf2a9c9c2fb3c57b2f3c21762dbf5c2654f7f4964a453c4e2fb1f51cc6a5102c59206d83e32f6babf870284502a5af3b35b2fd8c79b46879e48a2a60aaf51cfff60815a99e3208a6f635d2ed0a789e0e12b289c30a16de5ad9acb6575202a4e587190b0a6d3532a810059d78bc9cd4118000996bf7995355f06de4c70d7d0d8c1b141367968de08c1c6464b7ce7e5575be432df5b4e47602f3128428203ec159377ffd2ab67f5eff231c6c69bf9ba73dfb0b688b9662f0c1ad6dca10f2dcf1aa28feae9c81e814c7095f8d93248789646a9b20a1226808eeac0c2c617875da5e44f24f105c32ae45243121850f8e8c7f2d1d566bbc1b1c80af1d278eb165cd7ab2bb943816685ccaeb0908feb2c262e84f743f49920e9c4b7393fbf2bdd7125eed6d18b97a6b5d20983388b037e07707dc823fd9c4b2b576513ff855a5987310e9c76f265f167b2a8437a8585d155d84cf365c32d18e1048049043a4f64804b52b7df00142a1608e969e8fb7c93d2026f06e7f17d38c186e2f25de138b13d5f5cde6e296347c0f2ecd56c2f978441d5c8b796c56deff872dc258a9629763d9f346bf475c8852ef74e5603f3f1ff40fda94848be73f053a22c1391778a273c45deed56fb137b5a365a66a5df6706982c9a8e07714064c33d704d442557d752bd80128f8ba9975b2dae5de841fe2297b344d28cb7d61a85d188ec38eabb5e13b8bd2c20c53f8a8fdf1800ae60c1396a4f7d5d37fd0107b399fba077b2e97f579ff509cb1b41bac699141d2e997fe9c7461c0652109c5eba795a20fb235065fa1bd0d074002c4846c159c827f52b5f4b2a1eafa8d39b0af5fb7a1d11f4eb5f5dca266ebd5de7b29bd5ede8c5c05fd5b29fe67c758dbcd76bae445c0c688604dc2e2e1861e48f0f478ea42b3934f4da6c9ef270af698a3773eb16adb8353c406d6404fc8ce4013bc9353328b128f0c46d81841b849aa4b729e29f0fd412483dee1b811dce885d6f84a1ee7ecc0fe662a04b16544bdaa01cdd09766afca2106610cfbf1260a13937f31fa58222231e50d7a858b0f75b8d79277c41d1a65a0eb48f83da62c487182565ed4235efa9320504c8ae581ccd03d15d0b6c6e3fc2984d4cbda8de8f84ca09400165556ff1c17da2718e55693859936816afc4c1aede741bf6b3161404d1fbad4b026e614462f3b106d0aec1c14756fb93066bdbd69660a616c88a12dd8f8a4103dd788416715d62fe4599849c36330ef3c1c172ee38631dc1e1648bb7d2bc1e94bd8ee9adc302333f07ac129c05d3b482adc8a669a600025629b4d8f6034bd4081d538b1478d72450218995bd54ee23e807ba7131e620b304d38609cfdd0ffce5b8380c2d0f4574f9da170a2b5857ab48e066b4d86472308a2d13f88e3096f37cc5f3d48a02cd2ae8408771ba74a1bf0a2a337a7cd2fd8c314c3970b475f9abb17675adce00cc777e094ba72763a7ad09fb990f981a270ab8353e7f094cc398ec9cb24b48e76e378abadd320eacaa078ba5b0cf2011b53c687c639bfb394469269cd3f5982c8f5876bf23e15c219f58aa768939df8cea2393a5f8492a62d967ec06bfd6391f4e163b8cba90b48fac7878dc243e6306954914c8460d0cfec0528cfc804693d1199debd21a4f382747ebcbff881434894b5f00f8b59e8551e52153790f21aa75f2654a97759e659d4b47c0ffb3288d4738dc4b5ddea51108aaafc96a4ef3615b257bf0664813fe44f55bbdc02822c288206ade38e475d99c328afcb5fbbc558e58979b83718f0ad8287c9c719f4777e672b0f1289fc11ea7e2f23fc161d745d0e5b673d52a174b9700c0c580decf29d59b9ca9c835c74fd0fe36bf7a2242081756a2a4ce4232b6368d29d9fe466cbf38a5e663c640f6f69d1b0e80ac4949a4b0458223952140f1883a2c292e07c23959addc21e0c323d61e4a4d8ab0e5b3b8808ffa8fa3f3c1ca531e5140c87a3961bdc53f6154ef347d4e87d6b62137355fc9a311b673b549fa2d0bf7d9da0d1b521da824c3095d2249911860db601d79044417c38242d69b982dd140a3ae6a15a3584d12ae43085994d9a002830da6debd6a9e7784bda648b61098a1a022935b1a53576ea91afd7841e67ecf3e7542aea1463c092e5541a8c42052f34ad2a112482f4ee6d57530bdd37bd936757fb28dca7760aeb66456a48ad4cfe6bf2ab02631b417a261d4c2cf7c6a5e142a03987e57d6682adb6c3915c7803893c3b5af7c55b40e113e0c54bb07e245c3b281344aeee35eab88b14cac54ae97aa7769cefe5d901af6a8a41e6ed09c946a80f15f9a855de0715a2d733ed190d54b08ae33b6980752d8bdaf2290a795ff63640bad00d4c2433814cba8fbc15de2e9e67cf9299fadbc9f415930f46d86e911166c09bff70903fafe22f69266db79164d07da130df254b44214f5c1181083ea29d8caa69a54c2e3e0c9286b21e489e80bae2de04dea2fee6b8cf630ce8e825f05cb6d058b18e35be69cac4e6be2a044b73bf377addc78901da70f5b0247b3161ecf0c5ebfa66343af220a5ae14ce29f37733fba4dfcc85f11e0600912ecba1743bc5cba68f1c34c1014ed5c5ad5f9d62479e58d1a36e04b302954124aea63c9a9e7bcfa09cd8e117741677edac5edcfa3610ae9fab66da3411e1e15a5dcec87e972f378a2d13073a6779acdb0f4d35e064dc18793e0d313626b31b43fccfe12f5a64d0ee25cc2d9ecf858f90990373164159ab463cfe6e4d9122c7f755d06800e69e4a5e8234844c90774d1db87ce50f9eb365d452958095c3ec3b6558edd70b8b77d16eac1470c8af2cf57482eb020e7f7212c152b90998c2f2da48595b5b7b9eac45a40e92951f09f14790559b50b0baeadbdb41b1ae31d5c485383ebb8eb0663ca00c90a7df42f1414f16153f58e53a7cc67ba086d03c21f21711470b4d4907b70f1743b8bc7a70a7fac5273e544d6f394f41b49749b9e029cc5c54ec380e9e425602ee547585dc250ddd824b6a7f8d3b508987bbfdb55596c6083c4ce5bc791c8685f941feaa88136864beafe0a5550f2a6524a607b5df33c438d799faa8f1f93fabfe5b71b8538ae29f43277b8ca4a035dcd16ca3bdb503b13a916359a592616e14ba8c3a4d3c1240ad2042512e557ff79820207a2129c7189e2d58bb5de5e261615d9f950589ea94ca82c8f0d8248c09bc7a973ce86999fdf0e0cbc362b235619d4b3ded9345c9cb12e55c1d41a392e47dc8bbf52a00dfdf8bbeadf531e1b66efaec99faa4b2658b3af7374af9a0b2c770ca46ec512ce1376e7b03b5085bc6e7d5c7cd70d43c92f6df9f344404d398bb14b2550c07fd17dc8aa0418c874427ba7bf44f9b63436cb000f1e3125094a55b9fe61725e0da6265c5f163c14cb9cb67435e93650eca4d2e5f3de8c6a1710641d347656a35f886fdb183c8e2909b377ba156d78874852721dea143f837c3a6d2e9e7e74bdbce21940bd2bec119608ba130fa130e6237127c543fa14cca90fd29f00a0c9f4eaefaad97953bcb40052d4eaf4a6918853be97fec66da4ffdaf887fb2a7d12c03a246361482a7508b4190499c6ae020bff9e114f41df0243a657e7f35dfadb67d0d5f6373f51cfc2451e32a67456c2d1791d908bdf07c77bc041401431a24cf020c325aec6023dd2a73fe4324ddd3f80f833c1c9f3fbbaa56865af6f602cd3178fd95b99bbbe3979b802210aae30a118d27e17c2b60b49abacb6d7a3ffd674300661f5fe20e3b355fd2fe701251cc3df0fecef66666a68a659b0211863326ad825624f76fd9a39651074c7493dddaf37c9393cbcc83b5037c3bf1a84368f2f2b9c77b68fd0a58971293c154c61de637cfad305877f05ddba1fa98d3faf8960c516df85dfd68f7b526321846f2e06964db0a6e97d4c30901fff65b8304af6859d9260a79a70c20293e731e8bad2ca6969e4a9d01b12f7912dde3f98a83d00eb91ef6089d0e3418aabe4b04411aa2b427eadda9bf5318779b528193b8a224ec4c7825c2b740346b4fc97d101796d97d35cbcb2b15c572f196e6005076004e8a098f38d52786bba4219d0e5134964408bae0fac136cc6092b82f798a8b1ffb13a9f871b97654531a7f840b37e6bd354d350b269b5569fd3136a1ebca48e55dcc5282e7a622ed7a56e5d8412d51bb882402216b1497788f5dcbba1b7915f1f2bba8510ef55c341c433be5a0c784d60ba29636bf96d940ef8f04127efbdb1502d57bc481d8997a3cac32db3ca695fc0aed90f63de85283b2d8437711cd294e8a580355419c3dea1907a8a689d0e11ad40f9a5239c538806c4b05c0697f15fcf310b93d85db97e155919b8ad36dde8fb603b286ffc242ad899eb11c6fa9afc7812020e15540e0c8699cd595f568927fd7d0a0b2ab0974fbc72b71987cfb193041a7082041b7ed8238930dbd6bd519004d1c42884ff3a0414553e28f1efe64c894d9cd6109199646d6ae629bfdf911a98c575f1f7ee3e4b58ee5087a1d49f4ac3589cc5d9b35786281fa47f6ae109bea3a8ffc67977bbc94094385853457e42b021ff6f5113ccfbf206990bb981229de7d90df3a1292ca42aeb732e2416e368aff7efd130140bc9fb7483f0a47781fa3daa364e25cc99748e2117ca047c1620c1ddb4c1ed54f52974ade119f9872f471ad753e2a6fecbf8e40b320bc6c9bdb6752d7d05d6fda06f1a5a63772579ab9fef3c2d1ca81df7effc894349901ca9b5fbbf6ab94479a2e02f1a3217b79b8a571f85d70ccacf907e084064e60620e76c7258ff201266e7892217e0c8f38d0ff31d288ccb3525019c1e5e324b21c847db59186829cfd04e5aff2e26ab1616f70c45cde1ac7af1be6bf86203c9ee86a3e568272feeda2e7b91b700d3e7e40226cd51e197097bc93f0e65092d2cdc6b5b975c5496def88e532438e75a963a3139ac4890b434e851700dd18ddcdd3afab9cbcc89e3b016d457b10d8552e2eb974af89a56462701290bd2236ee708782ec695eed73f44873a48b0e12302f9a25a6c0c2d9d3a7752989ae7a9814e74e025909db445ec5577cfc5f9d8b797c759d21ffc0b28fbf82822499aaad70ea9b81b140e8b21dd6ae228f333525fa51885c08fb407047ebd337934161ac62b5e107ad6b5f292c5cf9b0066b1229aefc463d8215618c357c370f46f36447cd534bd13515b70757f4922365912092fdf3b196547452acd4415b7b0524e7ac67fa2311bbc240ba61759cf5694f19a58c6206000e394b72169866208b00caf68dba6e01cee9f6c136b1ae3ff0fbe8c17d00ce4565fc881bd6b4eda01eae5e1f32f5067c0775ee3364f7afa1c55a971acdff3e9c81a9e9d3965d410fe17611e95284747ede3a1fb9d6152f5d65808f0cefea183c3083116bc55063dfb1cbb719c429d9ebf4f392e47a4fba6bb743bc837015258305f26914aed61ceabd59f0e9db788d0137138b53d7babf90062db144f21e4daa607e474b6d4f58be8df335503a41938bf4c277e2c3a7ecfab0fba0c6beb6d4af501e5a2ffea2500c53206fe15bca16ce0570a7b92ecb7f33c00a619c245beee60010af5d54fe971408f982a9d9038d176b1b5409d7ee8edc97233c6738f94f04b3d98187a7ee6e91c85eb77cf7492ad1f5318e25fbaad4b1fbc2ed00d68b0cf742fea9016a8be795b974884c425707145a9468435d659301168b2b1afa7145c336d0741612bd4ec15c123a91b6b7f94a6b580f56633dc6ef8663f853f09aa9514d9808a9c9a767514818d7ef2ddf1e68b0b9fbdf5875499b110c74c109299d421a35e9ccd7474f58738e2f0abb2d0b08e186b2b3be23c8cac9eb107c128cf9f1688f2defdf3250b7c7f6a407cd0f7fbc3c4692561baf66f60a2fbe63f6523e6f7cb28cc7d4076500d3e16fe8ab39b897f5bd413ed1d36f181d17405b0ed5b9e11cd28b343a9513d0b3a2aed08a2a20711d035eb78ce9e339908d00afb09946d264cf2a07e254e266b3f36bc3fb846cc26125e894239226705d7889da2e5b395219212662ad340baa75c32b3af13c67d6e494de9a42a4b9305d254e81a66c4aef311aae136cb9d9fc04f01ab236a1edbaed3bb6858f3aa3ccbe749b67508d8650c4f017b92dfffff3617c20ee4a5075a65500308c11f08646c699146f5c44c737beb5b0fe524461ba77a3054f76faa0306d733ac5e4e73e1b01833c6e01d70edf36870fd152770f55599cd0341428021b84801c17713f9a29a090f23c2e478b0cd054b7b9b5ef3f0da779fe7a931dc84fa4fc6578f8172cf3a5bf25ecd90d0690c1f091667cdbf6f7ad28734cc73116e332800d5798396952276bd8b7d6e7aaea24703503c283247a4f44fee3a443e76876424fd97fc0a0d571b19bde37c75c7009d3cd5201d3560ba2f78d0d475a6d608e66175a7ff29f5b8eae47d1dfe204c8fe2778afbed9394eeb7b4b071ff4be7921d6c88f7825da86ceea6b4c56ee4a6a3ccd7378bd69a40ab50006bb7c457fb94a9820a5003209db94cbf79f19707ac852eab04e76de5b17269746fdf68e3ff37f019609add86855b935a01726945bde00769d340153d551f1a4a6f89b9d16a47c0cd15f684ceac5d193d125525b29778ed475bf71ed1a7e5c534106d2df160bf30cce8314761f07c9eb0f2db1cb707ab48c705267b16039aca464bf451915fe1a13847f22e441a75a8ea202868a3114549f2b4f6063422a5c8eb788ad7d386a29e90022b5df7ffa89b3b009935c7e5fe84427ec3f345c2cc3da1a20b450f94e8c642b38a4d9ee587bf6b4d8a4075a0848572e690e42d7c9382d6c8de61a1875ff7b99a915a6a4bd9f922fa65ea02d5509d135c8d21fe903fbb52e9a9d98b85c8cb97eee64b4438c0e807a43f90b0d464041bb779b95a435eb1cb7d6bf62cc4b3a774bb281b7bd937a8c4067601993ebe37f72443b4bf024053f913087b2bc5c7a44c76d4251ba5dd029159813569d0eb0b4cf826aab29f3469331d509993d11470f92572b39c45b74240d940729ea9a390de72f4fdc04d87eacaa3f24fccb4d3b93a8e2c116aae77b0263a87809a989844410d113c3d30127381ede5682c63ea8ef27d372a5b2394c722f1d863e2059a334446b757c1784645168f50cdfb22d5c9c595245744b9846978835f6057bdc25d19d87c1a848386c59d1fa38104141c225d878275646afebbc868cbfc261baf4f6b737c7c4006da85af89df57172321334bbb5553e74d60ff7a59dad001f12f046dafe7143aa56091c9e770eec3efe9f66e9d6cea1c051c7793da7ce7976cf2d450d7637804ae15fc49a73974859c311effca417282cd01aea451c110af1c65bbc40ebacdd5ceade5a148860028214b5584c08139b4b28912b75f84e7a6b425e248cbd6694416bbd31a91b963927510e0d21779191de8beafdcd311dc085c8319f13ac2f397fd886350165f4e0fffe2f03fc49aa68dd49ef9fd8e07a7642627d048a818ed122ded93b2558e74b17c67c134c1b0c055d77c23c2d7ae7a89c93b1c85ec14ccf02d0e9880db8fa197af80f7c974a23914df4b8f83635d1e4b2c4eabda01b7ba64008143cd87280314c5854deb27278528267782aeee9df125335b8d4f3b98cb3ac3a8e47df899436a59c6dad728aa40ad0d41e00db8d7e6726cf955e0ac32dfaae0eb2e39fd1290fa810065ac3e54e928cb383eb820d11f11f6b19ac7679e3b695f6ce4a7b1a2e68ab607e5739e3d87b7157b56e4492a054e3a483f38325ff400885dd3428887f2c5a786dc1f47ee1ac0db39d54620ffbb7a7f4451b2a7c67d4c6b451ce8b8ce281c4baf78e054ba696f4370871440dba3d06ae50e3a3b8b8bdd975591aaf8cb691792c16504febb87c44040197198503f0bf4a64ba34dafc77a5e1ff56bda9f202c72dc77c1bda021e26d7f335f222c93251a1dc5b99e8f2ed031003d686f0a70f3a5c652293656e53b5adae19a5bd7f7fad891ba7aefec4fa744369db83b1df34636a3e390d7a2227a8061b0180831ba02096b1fb68aa8ec2f05cff6e0899711b274b219425104e282e6d890d53d1b5f83f4c5e080c2501a438fc23b6e0a152dc365c915fbe6abebba28aa2d1ab413a74ce3542be86e80bfaf5de0ac16aee2e7604d3327ecb571142bd4eb9677e1739ade2e3f0d7a813112b8faa514369e10154393e10e5a81b76150431a986f5ef5672635e3ef709907c53bffe834a256cb8f20d14a63bb3317c0d9d8f9d752efd85623739c06f46b9a6bc18808907435cdbaefe846bcda8c1b374b82f1e0b38421dca81dc10d6dc00c7ef61cbcf51ff38e523987c92ea7c1f708b688ead78ed9496b41ad6bb1601823da26c87652c6f09ab3eaed2fa3c2b6624dac5874a8cdf6e6f711ac4d782bf1a050067bdde35457ed7b1250fadf5e85ac85f75f48ccf3d1ac7fd1a9b9d722e44bf68d4541811039ae11ca7a8f7436b663b00a8ef22950fb2b650b9f5e7b1c59e6cfe4cdc25338a0f97622cba06efce60738381b4273805a315a2c229fa8b598755ed4c0544af8d607678cd6e3d8b3a888bf0f2b13a68afbe1835e120411cd99a6d7685607ffe2282736c9f119d1c4e9a4e93bba4a4fb96bfa3a6b87c4209e105ec887245a232613d1466b6c62e6ac76393b3db96d20d440ffa03062b3150dfb754dd567df3cb4d67d38de802ce78842086a4491b095b561f21578311bbedcc65076a279208c2fd1f9a1d6727267103eb8cbff5d2a05a683ffdb3f7bd3bc918d1d0edd1b0072102530b7389e3b23796b0185c417ccac7c6848fbcfadb424b4f6a631606101fdd4aa3158151711700e8d38fd00fa4ff24089c8d8bd15802ce19dc2174fc22b4e5e005172663c09d14d4a89fec50395e8dee9abead76de599313ac7815dc8b47c57b3422f29a9dfcc0601d694cc259a70f25b0c60e3f8a70fcac4e1d7c57f26882df681c1553220526f4ac465f82a93d7ef6d6962a59ef560e739bc76a5fc29acaf8eebe4e1f5baa7d2851e43648dba1fdf6e5b6921e62d806aa7ed5584ed6d7e90144bc95518341818197008ed8c5b650db8fd6ae757e3dd75bb42bc98c9a06a78b3f653dfe785c290cf4073b790db1a797f0bb2c31f84dc900836d9f19f248219c3a6a3aaaab35dfaff79b7501a5d18f3f56621c94a95ab92d97543f6ecdb061b7ad29cd2849c68d2bccd1c6f58f801b35eadb5cd051d86d61d70ba6bd2c00aa6cfdd02da7a773854ee3c01178615e286e1dacb2482e8496a7ed2f04dc2e3c492896a39cea51580b6637b4940c572f71c7781b954848db23553e54e4d8652873e502b6b5c39702f7468845917978891334aa8fb8e417f5e7cb4390058fc628dd922a4f1d1886ce298e6ca45d2841aace4cd1070a921c2560215134c88af54a96aa837879fb76082d353fbf5a14aa878624292bccb3d07e66dfb831379ec3d9a77711956651ee7a4f666a320f2a25514da25a017baa71580b629f937ddba87f4bedfc6f83244f20f010550c4cb733d1e66cb98d18d7467aa110de0263a97564ca7e036c390fed340414db01d84805f4ce5fb7820b132e813d30cc7bf7461cb1c814c345f2bb13ab721a782dfdf2d5f41636d25c9d48870dc99acec23330bbc24ee8cf3c498c136cd208e87f92edb4890fc9cfd2cb828bcff518df40537b431ef99cc58053d7b7a5224486e9a1f74c395f2338247566e02d76b22b67ad1960c60c2b1507545ff96fc80bd508d59763ac8db5a292addd42e13362a17060293fcd1039508461af12e3c554a2ac35142a8ff3df1b0ea196e5a7168f4b768981a118835b16ec085ce1d946d5357521ac350521b32f9adc4c9de9a938faf5178d919aa49d888fcc00e4690083fa7af8a46d85fa5c7161836f8bedf666912d85b6b4c9daddd3db4a503d7fdfdfb58cb66ce10dca0146f97ca520995040efac40af753d6bf259972ec369d26a4d7ff6d5160ce552ba3217bfe3a2b7ff17efaff62043cd5ffa0266720c07105b161d0a3d971e5b4e2578be088f63ed8c4b07cc7b30aae741acc158c1e44b9b6eb04bdf0edbece6ebfd93e77e10636abc30b8b7552d8d717367291fea8b15346632f3590db5b9657a59944827e9c8226c94a488690953fbeca662c07b6e1f8b26a36ad8cd5cc752b3720a32ebdeea6e805eab723ed010cdd85ce686ac2b4e684bce8c112c5d45fdab77669db996128bdd4a4b990f5acee33dca5652ebc15d079785f6e4900796de6c6e68a628bd0d1750a559f5499a9fe10b4630fa0b72c9e0ff39bde8ef598373569c31e29703242ae6f9ab95a9347ef9beeb1038e2f1707fef14230b1535c74133d8dae368fbab9a1c3a874b3403f5f242a238ee1881f3e9b9275343bba6b280a25dff87a8eda48794487b4d5e6c80ad41a19c65a15feb31584fbcfd92aeecf2789fedff6686a7dd3dac4cc87ac1bbedcc387eceb6cdac3cb5b6fe07fbd5220ea82cb38c1ccf12e7d01a4bcc768d57123d5526660097262cc99435183f47af2b762166218da273bf14f891a46b9b0cb670e1f74a9bc3ee1de59d5763842551287df4dc657bfc21a02d8d468837d655f36e32244a62ed7fc11e645aae3646dc88320393669887a2094ee7d02ace08c610a05a8ee3d54435f3392b5e760145d9da18219d73f0aa934892852bd151bdcce353f97efa94a0babf435f9819c6c87608dd31f66670590028a19eae8b361aa2820bccea8d922344a5ab883ceb6d2553ab75de638b0a7cc70cc07abeaaf0e31f08b7c5e01cefa27a927029ca2bc9490b6537c07016f4d10cfb41b9c21ff77dc1072524d6c5e29bd6fc88af281318e904c79938c2978e95df3d456fe3e6151d3731f0ddb46e32b114b41bb2ab216232f95e62cfc8400c969d7eca2dc7a25cc8c9c518f01eded70c8746d8cb399836a19798e07a697c4c5afd8368de949791f79c0af6d3fc95e2fb24c710384fb05ab7709708239792f4fdddff5074ed6d62ae1087a72f8ff2e5134de5e5901ee96bf237853517afb5526b0b10ae65022ecd56fbad9d82df8fc200141777654f68b1de3c7b43b825de3bead327007e36b2bdf3d19e3876f10a00c977236de7a130c682f76a10af0b387f0f2240b5220fc9c87d3b1ea212b4b9c41084850bd300cb6d90d46169da2daa746fd625f455f9d8346a3ff2a2ce07dbd77387e219562605ea692ee701a7512976c24d192b4d6a0f786ea880106997433641eb9f05d49d5db210159d6290a1c6b9b28909d6528087f004dc5f11ba49ee70e8689569bb1288f272169f8554dda63fdafc4f01ae617598711ddc8354367ad836c3b1bf2ea443c059415024c08671006e140fb54b36c90591d180d58adb18ab1d1f0c2fe820e7fd27a6e10f67800886c6c45c2d41117c55239306a06fc8671d1254ab3feb6dab43a02d0874c4c214e0855b695a9e355769d262fb8c3763d470b5084a1862fedb8e0c40107466f1ce7c3d6a158bae8a1613d6bc7c097bb2874057b04af58f0b85fd517def92e67c149017376aefb276caf424e4d47d8644fb66c333189a312f736a127e69fc4e452ef04eb7e183918e0f8825605e2ef61ab68860a90a601f3cbd13ee543e5dc33fe9b3b4da9ccb4a7d2e4bef20cd6bb48c66abf2e61e0e1d88e07cf3d215581a0308e796a8b7f43a2ba7031878ddf1aaafde7b54e934553eaf596f9caaa522af515e33805dafb231a1f22285d7f9eb4a9e9058dc06208f820cdc31c1852698c84cb848e36d865772df9c16057b4f16b0c59baea238e513403d327c5e7dd058bd49e9dd58b06ef72b72a6cc76077789a5f0140ab988fca446b45a8f175a5787e5e7004738c2c0e792b03741a1234244294cad0e720902c006d7682db164a51cedb7f0d03c2e43d5fcce387e35538339a36405101e0aa59be97d960af767f655a4bcde473ccc9d440bcfd562772f56ce14edb0ea9cc441e98906c2c55264a3ddbe532e8d161d219021f8ae574a466075a64a3fe91c18a68f2d924481f19632f7502249cb436b51625e8f3eadefe6b37ae6b3151aa19552c07f0f96dd8d28e47871c5bc09bbf9fb662b0f90bea8337d91213d867d9ff7ff311f34fc6b1ce68c9b6f08265d9b2bbdb3fc1efcb300469c1537d74970cbbaa3e9b45d3ab643c5a7114f895c40abddad64c529abec9eea2a72309fb640dc9b4d26d5f52caf06eb450db15e28e32ef28ce7252e7698feed4888c98cf013f47505f0ff5d8a46a71b39751fa2ec9885d10f103daf76fdc77864ab11642d632b5e03bc1e4e3a2a570eaeaaff4c6b74dcc22ce448c6e99f88cc84e7417aa088c6084c9690a965293b4dd5d2c74a89c786fa8fdea47420154a626f3de84efc0a69e6afd4a11d02d9314ecde6a2fad1d5be1372ab40625492074b34abf7692b8f9616e1f4dedf4b3af5c84228c0871e534048ac27d3ac5b94959f822d022dfa3d73967cdc9ddebb8b4ca17216d107b90dd33c0bf5be8b3042223437f808946ddda1088875fbf824db48ed84ab53e30515798262fb48d063286e89f946c0ecfea3628f17df5fa3ddef26403e19796681e5f35af9a285b8e354f1ba61a64493e6811aec53a38fdcadd2cef939b6d0fc902ce3d0218b0655da88dbc81d2842e2df814b04d5742c653488fba95bfffda893d56ced46375a9d6a75a6e8c7440425c799c8037c13545f1ae44cfacfb777dfd9e1e684292567542183a24047ccc0d80d50a824d5bfba91374f1602ad48ce45305a68896d854f12e71f8caa35545bae405f51064b337b5562a31238c6d7c8fe675ac744b2e27c4e38c354a473b1101d7924792543745c979bc754c048df6014e6c7a667527e70fea238884bbe073aab13502b10f60fb88be5f2e9fe3fb43e9146340271afa91e5716c0b091116cfaee341e2b02d855022f30d4646b0f95f958d58588d3f03c5e87e50704b3ad97d77cba2801d09772e7559a12faee39abc7f75b531436ed01ad88a44a7488340686e99ae201a3341dbe8cd6c1b5fdb03c9db3af49127b3c3a28b2c085d42e609976fbdd3de74f7a06c06771cfa60b12f610cd11db5511b8313efaf89e081050e910dde03c4eb1d7ed45cee4b049a102021231918544a6340b1747a3c15d0e11bb7d5820ae4d8a068b6315cce384eb3205f6459bed183ab8346effbdce87480247bf7eabed467907b1209dcf4e7ef13947818489f607b3c09806cd95e9ab3ad34169a883e166ff57769b6c1bccb98d03b2987b4d3ecf74bf9cdf926a49fa47487fe27bf4cf7f822e52ab6bb6f4979c3a30e50e578cbe1667e1247248156a48403a60378f2568b782a47dec73e19bbb509fc034b16dcd07732f66211682a9ee0cb63f03ad3badda2fa592eb89a0afd3908cf14e61bd521f825ecf9269065fb030fcfe4362ce8b5f46ae181e6e99a226267767cb415b29d9248c22a8ff0d24ace481a403a85424ab94a8171d7509d6e24cffafe580d6cd2165ca71467bb37ed4fa3308bcd97e302e24475082ef2c7e02e6ca5077f6ad3215c68870b3bc97af7a59842e72d3e38693c3ce8f52681961f7eaa0bb83e7f46f08e4287172f3888f5a9539207b171b1d32f7c2d4e370fc5d49ceca6e7f64ab450ec52c594ae97b630e19aada5cf920c23ffb6f47c787198467dc75a452ec29772b22bc67f212b700b3b60edb0f3af57617da7496bc4fde6ed343308a4dd4eefc11f77ba57727532ad0f8d0aaa96a1235230ca546b2e330dfef178d8fed205963783a6d6bdc22709d33c24381d44f1955dcca3bf58089e89cb59bd075264c671e11e7397d7416bd3cd4fd10acb04442d82dd22f81a639c09308a28ba08c175b52c9e2c582e9d69ac564a9f732ddff32d8bb1014216394aedb45643490e7c36f140049d289b863adb383bbdfd45a8adcf10e6f49c6a186bd78c2c7df8393576487b784fa18c651575e21d3df462bc3cc9b49665c16cf1725220ef89f22f5830fc26911b1daa045c883d500a63fc7ffc24c1ac39792f404bd76b16a7d03fc1fe97b63111dca2b4c359275b8f70c87898008242556a146cada0b799b843dbc8079cfb81c5df7dba245aede142407be5b3be84719caafd194967d2d6e7eda4a8ebe1d87e04de732886c96b4dbbdbeb2d002fd6b729b0c54469ec7daa8bf2d6560f3bd90032a7d545a0bf3afdc4729eeaa5973e406e297fef8e98e294780576143b6a174acee9ff3ff8a4a9e6dd561fc12067faaa541ae47151283736be4972d9afab9ac0ee0c2772823048d1281f493d1bce3fb024d8812d5ed2da651c0becafc8cfe228931d5bb68130a37095db075c3d50c58a2c56eff5e509a99c81a6faa5acb76fd2fe12f94070c3bed5c224f7e453fcbfaee57457c926eaf2e9b190a26b8a9924a71159aa460404467a7a95b56fa6d29278fcb63a312b02d9b798b7ebf11de6ec99bb36646e19a286c4944b325944de3ec4502f2eb1840ee608e7cecbdf4288090cf0543338ac5cf3f333b7a8923324fe2d53a7233c98e208e630a6e8c13d99883199d157d113c726159b8de249014941fc75cfdb54b120bc726373e9441b547f0d23267be615bda79f69d1b78386c392f0f0380b249da8434b621e079f2dc60346932207a1025b1d864b0906e134952e6772039396d40b3181dad20c81e8810de3ff2ffcc7e87e1447c18a2798ae3c069a77f38b95b83137dcd91111a449634c133bea33a0f3a2cd4b1a3bd6f2875c1d50b49f91de14b65d92f2fa9fb43ab782c8f7f84ef4f06a7ff8450f28df8dea8b9a8c97007ffaa085779c5395920c07f3d5b4c704fc4a26488490b38de4d2734fe6c81e295b78e16f13d85521b3086274c4d832ff08170c901aabc3951da39af4f0700703f3584bb0af2ffcd9090196266da64a1890001a838cefbc0b4b60710ecf574094df64748e89e8ea83615a44c1fcc4ca79bd832ce7a9e73d3bb5451aa9386143be5997138fff02eeb775d14397efffd33c6a3696b9059fe21833f438ded1eb58929088c02afc8c399918dfb5810c73733c9a31c9078f37dcd80ff1534733f98d1c06c7e732e4e346352e9f793cd058f098b16ef92748af54b708b5946c0a036d062baeaa21c4e5cc3168e51b41b6337f982b5498a79268b5b46200372543550eedbec94f0b551a379f894d57caca5723e801601857818579b28d76d58732bb28110e4712955db669a5c6be2d588f54e40a3a09b07feaf5497aa2d3cd51e50470385fe316aedd6abca45a38cb17cc2d2b8344476c6a0cb38757ebb6505d37d6729ef426f2d684c0bbd6f6144f94757982718be1d74cb3e47ca12827462fc84153169a99552367272bcb87b3af32fb9b201645a90a4f7c433c360495062f47766d82585ee8195dbf5a1670a054c6dab950d38a6214d38fc74f3de145176df44e3300bce54558617bfc3c98e026faacefa9a31d26111bf299d6d8c8d0def3d492e2f1b8151c8a726e4b3b218b97160f18d3ff42d8296851f894aedda7f0937f17f2e17e5adb30b1de20a55c0413496cd970a078427e8667cc99a119d928dd0ad134fc0aaa01ee1fddebbadab0a9a209282b849846c2a71eb5b1129e39d9baaae95ffd5b46b6ee7ac55b9b863b3a5f51e7a79ea23fbbe5a0c1a24d6c44a8aefb9ed64fa6ccde0a3331f085d5ce851f4d45c04e8b147e9c15ffaeb148827b4cad0ada308fce745c653b5d6feedd5fc0561cea2157f8ba2dbc752f102614c396a67d7230fa8214ae4c668b23325e81e2514dd958720b5104443decbbdff1b3dafbb7b6b40497cb17daed02d863c0d9d569f7b287af956547f0901485cf4a36492d4a8336e285568f808e31a183d178b649a3a1f91a8efd99f97b3f9544137d6b6a2d3b69e944832abaa36ad737ccada9154835aa40801d82de84ffcc1f14df41596c04f4f4db9a94122aaeb60a4bd59a65a840627c9f3940b6a750ea416fb727c00d2f5790ac11d9c1bee592cbe5422be35cd684adb1822a06b086b5c2a38f65559c5e5886a1c0572e8055ca74b1bc0e42d91fcde22e0b2ae6a3e5c161a117c777eacf4fe4354f07c8ac167e5e0d97c10d0eb9b61488cae17746840ca40830287e2afa7d73628da52704cb8607af8de8af2b3fba0c6dc2d235bffeafbf04f36e29201b1fa26e3ede7e976f364624c10939afd9f96e090ed68c6750e0aa89ca19c1720d7d5b209137606a430c3c6bb0646e3923369e7794473d99d784ccb6bf47f9811c9fb62da58d9f42905c662c87e950812fd1ee6e3cef942e049a28e91410006acdd3040d9fed9d57cbbb227fcc27be4fda5ef5195ed79d4a0488dc98a0793b7869327e809b84c17cdf5fcf1910817ca9071a973bde8b579a81a317c07bf34f490e6952811112898d7bba1596ae974639995af75f9b317c747242526b5251eb126388230540bb58491262f78d0775c79e914bb43afb841d91547df1f9956afd0d8fe16b51c982b29fff5a375b921ff0e2c756c142d4dc823b5064e2852f184e3199b0d026589c30742a7168901e0fa240c2a76d8a6473ef120081189955a4adf4b103b9a3c368decc89f339648a8c7cdc8c140e3794f5659282479b260559aeb8981f95039c8535fc9beac4cc8e7be3422b54a092884c24ef3c99c9cf97a35f0e4ef205dbecf336bc2e46d888f9a1ed88022bb892d7b03525bc8cb4c9328ac47a28964ed391de80083090cc1785a6ddfbd04ce51f0de775806897f54a246d5a286f10ed55c7087986ac63855434566c9fe146e707c0f8b41b5cfbf182d9d0396ac3fe331a9fd84cccc7ba64a5cde31d2ca71c84339657c1313b699b3ca36d79783ab6e47c548dddf0f15aef99f69f2cb0ea0521e88af91c637b9b0419cf8532272ba4c85b544284fb0d0a23dbe4d9be866d0a90f2c8857da01855a5a907d1b256a55351041390391db45612972f777392d595e3e05cf4cb1d6220f2743274eb67bf9cb755ab0c1ec5a54e0291688b2537e51af15aeae4e4aa0b2601305429022e1bbf4137b123c2c76c5500ba97e999a43a022dd41a1596b5ebd30b12c266c4227e57cdcefa2a286b42cec44564ced42d05338f970fe88217ca341bbf726b3c86fb503d6cd3f7078a19d9a9bf76e3d568975a1f9884e8bda2c535084f2e181203627f88399915b4dbf7963a57757d02cb5e48ca0417fcfac874aefb1a1177b1887e58371b012e268dda0cada453dcdb52059f11ef4bdeafb1e5b3d0a12dd63d869c73c3f7cfbe65558371766010ba6022cf11bd0af01dc112542b18d0edf507aab9446aa4d8c3a20bfa6d83f83a93caf4b63132e9ef54a1328b47d039c4c09f908505507db003376d4cf747d700054691e08093e27a1a17447eac86feab0fcf3af3fa67c0c4b099547d5b080302865a50c6b1547e7268d06e8cadd7d0441edbf8b7c37ff5efa15c47c065f6b029f20a24dfe21dab6ff65a4f18925488d7a12a13e754b78dd5982760a30ea404610036d26392f76d2aee89add692b80879e62e38505e5ffc3e01d305c3f37e992656d576e5891693c5701ce77d548c053bbecfcc24647cdf06e2cf5916e38cb4ce2f7cef470ab5a6f6b0a5a74227efdb48e0d86e316fc9202249aedfbdcec7b86f7069cc61f37d92c9d8d105ea80183c9c58ed434f68a073ad4b850475d323c8df6c6315c7561a82b7a5ff7df7b172c64638eeca4bc84f3274b3d84d99bcf6ffb039040ed479f7ceeb730f9c2339913259a989cf0ca1a8a8e91fe729987b314e37d49447d56cb8e4690277a577737984fa3333eaecd035c74c12f493edc18438635bfb576837ced5a965652a75163e1e5604503fbe46cccce0e8756a9dcfed5c861f7cd91598db3bb04e734e6400205250692c564198e7c2d63a5be23c9d0261e6c2d0be6278deb7f1f66400e540889dfa3f7175767e0a33f274182da1eec7a7c3809ec19dccfa475e3e033042eba875bd5876cb131a8c08148946191ce04630aefb6e94ff7cd6ae4a12646479c50efe8fef45a54e4392797a04cdbce96786d0defb3bcb1902686e62cb203d5a8a7b18a5e3d930ac9125966d72eb169680c0d543cef61ad1961e2acb32c32cdf3a2a783119f8bd2709d9b0cedd2971df72d10e166842612d1130320683349ae459934f7bcdc528c4183fbc5a0465eabac43be518a3a2f09c05cb979fc23dbdb4afd1162a400f980e15f1ef5ac0f972ccdc56acef5ecfc20cf16ea05e9c83285e6d45b31e69513e49b03de19293b247d645d80e0299c64a5a2000f6de656ccd195b1b16dc970139642d5af2b9d7f36c7b5070aaa8a0aa0b788677162d51f9441f200331e49c9f66c8cc00714063d70902eec481bc05145b961a6a82e56c2c8cb0e2cf9e48bae9679fd32db6c68788d029c96dd2d1407fb8dca5c0df69d54c9593ac81ef7b0e6425698a078182658b0eb2dd1df8de8a29440393b58dd2f5103596bd2d1c23c1c52a1a7c2e4d214907ecc498959ce1c35b00a6245d78bfa8cd9de237970497a18ad463d7a4dcf3619ca45b04529030171c78ff2645364c876f60893c04e1f5d8b8dd28929bde1433338fb58f4fbd28f4b192259cc23a7e394bb44fbffd39ce10c1d5bf29640d081ac603fdc2d88ddc422601e390b70b122e34e716c62cfadd3aeb20d1b452f241bf774d6c22351f1093aa5d7a4af4033f55c500b873c3c76c603a30041b2992901311ad83dd4fd27d33d5810bf55f878e1afdaa90eb6a46ed573f6b7775d2878a26323c2ba257f651209130f91841d3f2273ff0f754ee9e7ec68880fb41f884ff53091ec0e1442c3ee73a9be8f4d77903c084ff575faed1ed3ba5981f5d6657982dd96d8377f347e1191684f5fccf6c47f14543564f2d4d0429d26f9a7135710d37dd834e7759ff8dfd09a1a73c7cbcf7af0dcb5df5132270e7a40c3441c0948c25d99f57a0a896f511dc11bfe3e348035d8b39e476670d865ba7b3739d86f9af1358c592b3ea9f0d049cec6b1d0d9d9f589401daf02dad25e5fcae27af0a4ef8196bebfa4f0183f7768a1cc85eb778dba1db3a259be69c66f22de5cffd5eb1599f522d06008eb33a5b5b38017cb29c70994fc4145a7ebaffd296d5d994b76a1ba9f5c78b1e879778114c93cfdf80a3a13d9b43f0268b8f2ab51d06d009afd54b3fa3bf71c9d433b28157326906454321e237fb5179c2001ebc758691d2fffb9819cf0c07631c32f64901c5abf1f4888145a89102716b5c69721e68f43811d78c1ac7a039bef111f666918e3774b6f6dd370966afda746089f65f83d1cdd2934bfedd4eebb50e90a86f856abe61fd8cd8bd18f459c6b70a5babfe76aee09a0995fe9d6e1ca7cba2b5214f2b19a537134f78a087901fa394f77e2f6f521a7149dc049fda2ad45d63d157a618f2567ac664c718f2384e1c54206a1bd299021b8251fd9c1c344ecf09d47e279acc5b04e8084c8dd0d6982966b5485dbfb291366172f95f95d38cff345f6f2ba73a22eb69329c79a00e1bbdce10d195f0aaac457010cca4302454a74e03b84dda4deb86570042fe5cbd35c1ff6ad37aa8b3cdf95e2cc1ef136c8326b52d0caf3579fa08cd04e254ad3e9b01394413ea8d4e530980bf33ea2af64b70f8b24b17e9ad8cf7872e16b4749b51f8b2429f6c25eb8ec58d36b703dbd9dd5d617a598551b91d5d720a3e82a0bb72dfc34c32223262a23aaf8557d7c0235b76d2db0895a606b7d5b3ae56e900cc31759898d71c4bf4127c0cb567c69ad3f3dedc4643a3adeaaf8f36fb5bdfb3f176be6a27e5bf1de3741304ccec0cc570084808570bfc27cb49194429e0a1355adbe71bab57f05d1e7211a06d470b14ecbb98d62c29a28029e732d4efc2e29fe546f161706e7eae94627297a70da1ba16efd9c99134f0b435b09ee9e7b1198b1e84b636bf360cb5b37c28b7cd38e0901eec491a72b2c24dca98fdc027c273ee6d843eaeb46a837de3f378c061cc82bc9dab263f9b675478564dbf6a5d830c3198b01c057fc850108dc1df80c75dde476c28ddb55cf3b4f578fb2289b558942b4a2b66d3df11b6d08e8164da18f1108e4fa14d7525346696b4bc6493226c6d1b71622b349edc1177306ac02659b726a109e5d27f9e6ec8994015693861d9ed461f2086b4d147e89e7ba47b7d580f1f9aae48098a6d2045ae5888b785bb16c03b9108d839b9ca43b3586c6bc26f8cdd0649c13c46bc4236cefed2357420476d0990c32b9699eb57c322faa53851ab362abb8bd448b5bf170cec7c54b60f858bd844529122bcc1975079b416ca23973a579f1fb71ff2dc332083563eba538cac22a35e24b1495444d62fc9fa8dd17f31a6ab830651b2e3f88a3299fb3060ab0c8d1abc241b53b027fd6f19535a68525aba0fa74df093c7b6a1fd90d3b8c4c58e737bdff9970f0721e35f4c1872192bff76476a87bde61ce4037b2c389056d41e1c63813f5b0dbf47da3fbbb5e02d58bfe193aae7b7885e56c6e4f739580db1873b35c4faeb1aa5b45548e1e868ddf913c0d8b49962fafbb6e53b1d1f62caff072b7cd8ec9b1caf8e926fff4389fe84c7658f4061de64aedfdb49fe2f7b2d3d599e1ca16109aef1fef31cc120fc4b25fbf795065d66cef9d95b82f749a424960da66d1f222b6799016e16c08e3574379abf099589cbc42281a5ca11569ad7dc778b634504e3579aa5cb38b5ad9d8474ab228a866c13df83a3f5e944c7f2e1cb0015c53e2196e9816eef11e3fd4f101098dd825308ee7ec914a8d0a056a0ec7cb55fc165f945e449fce2ce00a561a8fc26d83e1e26f85a4f385ad1f37350e62d4ccd86ee59b3cf1803413e8bb7710c93fd482201f53ee92c920957de1583feabb14978619a8d5f0e9de6a77ad935160f2606628bceb1f284a86b34b7ad63bb7bb13f6cc627199d3e210b75192f43a9d20b63c385bdcd2c6953168ab57b4a492ecb6579e0299537aec7bd37c75c095d186bdec93936dad612e828eeff7646f3d8c86ef19049ca5fe659066a8a0e2dd06b668e4226afde03a34edb64f9e43f70a54be620aff56ced91cbc6a5aa0339f8bfb8c287b152a92248287c31ad7f06e28d4232a725691dab1a3b826df2aa46d2aa82ec76606483e3aff3716b195ea02b6e04ede630c9f081adb92ceefcfcce1fbacec26fc4355eac25ae1cd72551e968886e5391250ee11d02010d8da85bf05486ceee6ad7ef55db9c845dafb303988c55f3e5a8c24f97b6e4ccb831c96938d928eed7af8c86e985a2a50132fc7e08aeb7435f51f82139a54490749eea6ccf462f7cad11cf73edece272a9db22f13eb9bb044e08ab52c1f12441d720266f3dd726b8a82e7615859de0239375e806936526eb6618a1c5974dde41124583d120da599ff6c536a0923cb85ddf92eb216dba1574ac5f6faf563231ed57d8a0d6255ea264ab4c5724800784a51064d77f77ac1ff576e5055d5550f5bfedcc97faf8c842d976dd4a6d98828e000bf85bc694886c728afabcb6fedf4765bbbf19893e4a8a2ea0e735f5d8f9951ac1536185e89f5aea2f7a23fe0bf461b2fb63c79ef749241d59d65d03faf7df6452bd01d24b29de6b865b847cdbe12758d889ef786862560b39befb2baa9e86da4fead2a84f20563f04b90ed9dabef9559eaf6a0080b5a2975c6a465a112b1db61a0c8830d3fd0e596ac75bcb71390da799bb293c1f5678e7c73872f93affbae5de6c84fa056a5032c107762d49c2b60b1147c89f724852d3e29f7b47b8909bf8cbd5d1464cb8e8fdd34386a02f04a1a9802cc3421ce169f0bd16cd3451b447b93de377b69629cb44911f7156cab9654b538925c3ddc68b66fd12633a318001a652fa53344f0f278ee5432b48e3f52739d98bf26b777c12582dd847ac868ea063f3c02ca5c7bf186a86364dc757b0e94e3d1ad484a6c211813b1a47648ad06fb2f2b3bf79f9883e6307ef707f112d2956823a7ff90d03b62f034c8c13340bd44b299affb0ae7d96fe3e1c4832d01415e45622f2567b175ef81791ebfaa3db2f2295f402168a6147834c5da7217db21694cf782a1f60b791bb1ca051dcfc4fd93299fb1047365ddd81a315957850a1eee25df83c2a5fdded21befe105bce6d503a6795fbf5a74b7b40c956a89be8284094d55629e85da3fdc5e834a1e988231da2613a9ea347d9fca04419cf63bf87f6a26f996708cb43eeaef2d40d80aa19072b956191f1d6753c82a8067f2bc92974be80adfd144836c59afb15f497d2db82e708ca0c77b34ffe945ec1a826d8ea9b143654494356d7623b905258c1f27dd65301fcbf59b4793714007ae6594492ca813d6460491ce82b0ad583d6f82c6f6e95a03af2fcfc2461208d049a94979cd0a99981bd2fe0a28b366bc44b717861bba5b31b3d90d20eac4e03f8c84b067d7bc86041581264b5eba364c4c6c7097f63ef2c143a2b116e7c205a24b91e9bfc2fd6f24f346c972c619ad732e7e126cd5cbc8292a6607318d0269819160eae7355d9b3f3db8d25ebf70e17e6261fb1dbacbfadb31dcdb5eeae3b14f36fbcd7ded81195e9a1a41515dafaf0958cd290be46b3cbc8d4ee11efe051dff747ee547553397e7d8b7f2b5eeb4c1138c270e5fb408a9691029e75bb6e1e3757c0892d94fdb343498e2d286916d0946712608c6c2c75764ca05013a838b1536ebb1f246b9b2b29d7b709a3ad3a152c3fc887390a3f8515eebc12b2f01cd13e142f0a3343668e8bbeda431b37fdf70d745daf440d560929b02df0b81bacd43c67e0aa3f3d3b38861eb3c037c260cb0e0099cb463efeee59b771e5c0f40b2af1737303d21d4624aab19fd2cb34e0ae887b8f7a3fdb740cf7f4b12aa91736c7e8ceca1afa618dc118dbae526ef037c3c3b94dd7da2394c02902f253c7af01afdc30e74aff51175502ee7b73d097a6a165daa9a96fa3b41ab4d0d67547cb76a14eaa6c0d37195d8a264751083731457a00d0c242f9213bd03effa3dfb1c9c3b120f6235d1f8e3aaf7c8ab0d769e589c83c92ad731b6533e2ba0ec8b9d3dbdaf5d0343233ecc7fb8bdfe46c4c01f8d8d56b10ec921c35b9cc1df08a34e180f6918ce78eea19212152f8246499de7faf36e04640e248d79c4cf73f949b055fe4485bc86d37657ffc10cff0ce6a3d8e96c8358bb711fca16ccd41187a90982a87b1af465387b22492381ae2d86054e935f841f3c7aa35b6f626d35e15d7a6202f071e544dc227d495412f56c198d9125f3f05853393818c4a560f53e2bd95720428845e1145aff1d43bc8cad14632bce0590a26bab0745f8d7e6bd665224c315107899558870d51b560248bf5ed525ff347fe69d96192cbc679e6ade6c311485665b235e7b28ea937236f9a625c7765c77a24ec7eb6ae0b92189b99fa78f96a07c4416e3ba0224e7147e1e2c764ef57c829a82d888bcbd7b8d0353eb9712a31db70dab3c017b88d20f3d6a027282163b60d2693cb0e9740fef586d1e2a7ab5e7afb876c3e3b878267d68ecd6e12de2ad0826a5f2c3d2eb68aca54618ad4c5a16d30e049f1a465fc13d34fb9d4b0354ff69cca82a79a1e97e327e45d9e19db2b9e124cf95e2b5f879151705144c2a4e3a45c8e7bb3dec7936ab9cab6a382725f07d8c1c3f31f4b4444e117e80cd35c84d02f184acb01352d8c8347f835effb2842c94aab998cbc7f0226a849391ff8f2bc2fccd7aec9115dc674268034ef1690acdf9c6d48551a7fc20edbd16f4633f5f1f7cea0bf5cc23fa4ed516158bb900fca5533e023a6dad8fffd1969c97bbd9e0e4caa110a11e4b2bbdeb81ed45129ad523d2fb3f5488f3422947091e083ce6c5898d5204ad66fe953952e08a26fd02cdc0a320d162d55d0fa7c2601ab953ee6245605016c1b206f615e81416a930aecfc0c1a3a07f45f224b6fa3cf0759c21f6f6d849c660196f2c787dda0ced3bb9afb1cd49f30d70012798ae5fe5189ab0aa4d950eaa13e294dbb4045be0509aaa26fbe6cbdd323eaceb296d20313f9fc8cba7d219e8e997145c783900e21883cb815f33dd022c6c27a677defff8a718be35722cf0bababdf854e6ddf1ed33b48261f2bcd6779c55bf862cb5da87d50295532e8960e0b71725ac473bbd44b31feae1b9f9bcaeea8f5eec40fcf8d3adc7c2a9e63c07e13fc08f35c57a816a912ec50d1ffd5f6bd317416dc3abcf1d7e6f94eb5fe7b14d48b1cb2b27ffdc97757994a6688dbe00314016fe8f1e7f8935f1d6e63e6c6333758905d292a86c26db9cb71010075e8e0ea05e7cf49a74e44853b70fe3d4b6f247d78f87bec027bb00a391f9bdf42b61bdc16ebf91d088635a29224338fff25231a77f37cb9596b9a3c4a95375fc25e555c23822567199ab86aae7b40423cdde2079e4a6bb3a800d6c96cb4d8745cfbcbb7b4d9f55b55b93c552fd9ace9dfad610808e40e23d375d4c8627f0abbade42f3815ded5bd4fbd5ff4d939be4c2663845476a94e1e0096e9e309034ae7d62512eac043015588cfc0672fc1040d99097bd8b333e6ac4522421b3bfcc15f85f114cbf143afa28612b92bfc741418088f40ca37495a2479b1c6b5d8c154002809ecc4a70ea3087a358d52c5233f0c30622601f6cb44359b3dc4f17ee6c23b2d91e95bf122149ae6e4be636a16bbc76aefee98c969a4f04e3d652f54cd2686e3f70dea29ca347bcd74b634566e62f242c23a2bb27d3c3d85821c5aa2615e3ede731b656725f996c44a5e6ee9c9087d4e19adf22e58ecea0d5b8f1c327c89ffa39aaafc37c23a707fb6dc6adc0eabccb8b50820013fb5924967e84713367bcc8ff150f00387d69c1b438feff9c11e9667cf326b1fa4150ec0560941cf74ae7ae9ae9dc29a223675a786ec18505e046b694bcbd11815f858ef0361ad9577c0047e34496395197b45d6ed94c57f30a9f5d7e0255b83170c7c61f21ce0df5827247208ba2d65ffcb648ddb2c9c44919458ccdf188721639db1eaf2efd0a7f10440595c626864ad27beeba54ec222f5b0ded1b7a0439c0e7e014fc435f853132fe1ec6f9550a896ff24a1340b337fd37a2568e00fa551f159385384cd4e53cf0deb4c59f1d21383f1a0bf7537db0090f63ded476d52851d8bccfbb243e438d867187a622fe98859630683f052e56f6ed5b7f460e889b3d69af6caf1916cd00d48ed3f44fe48d74d282acdd7b2019b3c8fbc335e4ef88436fd4aaab78f4945a177b91f008767f15223e66617df1f20bbc1c46fa929b38d3040efc4dc61e3c2f624aa95f6bbc991281c7d0653496841139f692ebe00e9bd2cad8a800a275cda493a011a4a6052ee94bebcfabc21a574d0a0abb3376b16a8779702d83a06efa15c728e3ed1d091b80e017544daafc2d1cde8293519bf0d8d4bb06c1889a99a2cf32f829893abc12cffaccf26a2c338b2e49a8f002d88d93cca34a289674492947b1a41ad320507793af3e43be6e2684231934ae553fb0dd3ccd7b8c8c238e2bbdaaf6919f9db514cb0ce2fd315e2a5fe3234cd174b02ad49d46a35901800144428dbb8bbc16a47a49705cbdc2d7daf598c2ff01e002fa01092c36616de05d73dce7e6cf5747c0ab801575186fc1887cc73cad2d8662463a640fb4e00a43ec1dde98a8acae3d1c42992e19ff0d27e6eef1e0a5986c154d069a736d594b9822c68c17882b1a35f5a6037a0d594fb478a20bf11477c1b909fb8dd6fada215f8a04d375261e6f42ebc88cd3628437885f88a6affceda7278455ee24bc9c13bc42dc48fb5deec2ce92ebfffd2028c57dffcc01289ef8c4d5e14b88eda13aad4e8fa4f1bbb53d52e168a746b8d363f4d91a855da66c4290941230ebc560a291e87c7f858380baa82621ec1b54d4396ed63dea0655fb6a91dffc1bf63f0615ddba87fc4130b7515231ab62f7de4e3b73bd3aa58af1f2fb03610e8ff7483368fcfb09ab7fe6f5b7b7a6fb74a6f5839ed800c8273715fec4b53ef3e13f956b17486474f345d944838abde176cf6a15c035146a305fc0962787f088b0cdf4c660acd898b1af6e022aa02c06d30a74d338d66de71fc6ec90b34b761d20ff859e65744ef2dd9929d0f515020a85e388684059d96284f4dd310c6ebe1f72e187b9603007fd5d393ec8aa449b2967dc810c89b05a873aad76bb3d53e108d8d6d407782fa0e624eb9f8bd48269acdc4a94e163571039edcabad5b8b73b60c2a1cf810cd2567820275403786bfcfed8b46bff51621807c94b6d76d13e104f416e8b231779797ba56fd0d847452b0e62917265c184d9ac7247f97451319b641770c9c9ba00cacc0cf00dc86b4011330182e045951f0089d2ebffe9ea1c10978dcc7e4d061acd4aa5a1ed29d2eb794da8d3bf37014686c8b02142d1ed7b20de526f58280957e6385b5042588bd2c3217eb192d088b207814c745c22045db87c81a219eaec2bb6a437b3b2407243b1d85b15213a24553a1138739af4b1cfb41cea4516e7e9acb59bb0ea18a849c13c16d7eae090aebbb5e1aa06bce078249adc4917973c2139fa82d5656d4236b67de01ab1456130093b783ecfdb76e1aa2d3bcbd355eebd62c8241b24d4dee120e0b9f9c244de4203de1758ddeae2a156d10a8823483bb2fcfab29549bac2e7ec53f1f6151d676a567cbfc3cd89d4940b220cd92b691b61501b2f8925117db3cda98c5c61dc74273ec1fe70a20fd91823b5c8bf281af75aac0f93bccbdcc24de2b4394610d724456e99c929c9016f6f8fc521757686bc44f09c5de4bafaa7761dba175d5ce9f858177d74512586e4db696365779cc95dabe7f2e1000234d6daed3c26f520c2857ccd99af4f621f9bc7c003c8af978fac9bffb4833db39e7335977a24e88622d27af39c834612a26278c386d8622e50d3d11b05af1b8bcde269a0fd61c7ada9edc28a2b739780979e1c512e1bfb22808ff9fcd66f6a5d81139d2234e56d346705a3fc75a0fcec85a06c359e93fa18d27b9a58ddd7a32b6ee16fb326e190c4e5e0f8e1abc7e31e603b1e95e4922d811f356e23a914c85d6460a72012dddad20ed25872c5d146fff14a59a6fa0d62f5780f5a51eec53850b74367c264b861c34f59d812dd2bd649df550e26573656a67b9b6aabf413507033c271a2b91c5598fc312715dbdfd705536cd0e45616d39a852bf92231032fc7afa480e87e8fb44b11f4135cfd066a45f1e258b0eb7394b80126806a848d86631fde68b44d3245cbf6be800cb2064695564a99549faf93bde3849d6dfe63d171cd229ce429d80a80a05e278e56f23223f169cc334937df2582c88599bc080edbe831b1903d0a81448b40f6a096ce967b82143c1a0ff20cd118eac957c2a08b43e104a5a7927fb57f0f2fe88117e8e3cb93e1a9ba6fc6eec0e010dcc4d1c82fea34b5bdda425c9c2d1502e5b771f19dd6a47e0eb81cc45cdc0b1a67b0bd0a4ba3285a5d06a596da4102e44c8d60143cc58cbf02865b99dc325d308aa5d8397cd4cb22f1415db60c264c22377eb0600668e4bf9312d359c6c21541534d0ec347dddfcf5e0124d98664ebb533b339ae63d24eafbc474762c01335567f5b16d548acfaf69d2a30c1c2a530eda82419dc6a6dac58b4732bb72c6821a16c656c19cde5066f16014f3b57e540711f06991ff0edcce510ae7860498ea495cd1e8768ff093e199f081587e01714b3e9e1a70a3d14e3714548f2936e4e4a2ed985da0e50820831d3afd8b59dee854a809067cf5f5470239f1bea9c1538c244f53082c93caf74c2c6685c711ece045e1db5870b20d97c2d8a8547511e1998e6301e50659df75f653d35aed9566024bb292075eb2efea714c618da5358b8f3d42a7cef27bfed5bb7cee7b372a4e12359ebfe6a49cdab55d8b87549e6e0566c0196e582669434cb758c30152ab55179a5b9591738022ba2856dedc945213f64690b6ae2d5dfb207e721a53910d2a33d132f1ecd39330a54e1515f2a93756d0a6a6346c2c7712cd241946f380c86f103ebf91f74d78dba2a8f0f093f31b08b0d3491ce17692aa8e7270294e6dd2fcf00f07ec382a0b4b36b294e8479d612d95227ee7dcad2f266dc3eadeb688457d87b881ca1f21a1d66650abc2eb11649a0d62cf98d2f47fb61569c17e8a53ef9e201a4d9fa4d7c273e6fba51bc27b2835aafdba4dfb89228d74017029382f7d74e158058baf9aad094e25d6dadc6b03d5979f4edaee5e7c12bf5f0142c90a1a024bca7e508fba97d7b1960879a128d4abb2df0527729417d866e29556a026d3579dfd0bce31ef93319180942e9810795377e25dccbea34779152eb9070c3f563754f5bbe8a2cab36a1ee58b7c1b01864816a2c8af733cb792140e934983f099ff586be1411a1ff677d93e2847155ba13847340795d6082aa686fbf853ee9b04a976fd69081602fcd41bf63742438ba06715fa379242f9d64c6780f2ed1ac89c5cd192ddb689d3b481b7e7df911ef4c4b2f3c8110902ecf53c7753f18574eed135f9f40d2f6074861508a77445ee828eca61a6c236cefa8d07dbe459fd996f81b9f9a5242096ae664fad0a92f33d27c117cce7482b9e712a4fd251c6792a666950e3b44fe33b9ba061545a2e12dde1b82c5afb90e9f8c036b06856a36aae78be016d8cd7cfb938d6f928bee064659591168fa4249ce130d1319ebe4cf53079cfaa5d4a448160fbc8742fd9d30e11b0c02aa7297f7e641a59e2f9c5cd5d9ed1a842c5c3df3452a1b5bdae8a88f3044084f99ad298f3369c937f617cba3d821ee53a1a3b9a52f4877641c8f49d8e7705e17a842e6261262d2d3b5f2cfbe0e225428ba29cbe2d18cfdadb13fa1d94e37cb7665428ae4ec10e019900ee54943786ad6a7e369048bbc1cfd315d5437d968aaf0093c8693f96fc981aedfcb18d91ddee4e4b7c3de6c9c55802b37b753c86aa5e5a984cac081f41dbd4dbf876eb3efcc53ea812890ae1ab2e54cdc32bebd3f48502ff94fac30c8fa3000aa0bdfc64a4035c224884664cc280fe568275eb9bd8d8c8ccc143c441b98f45d0323605e63433517931f13aaf8cc13520ca4c0e18ae03329677645327db4ef1dc757b1c8aa78433ef8b15086ae32717f53a2c47021eb519b52658fd5ef4e2eb5bf8702976473bf2dd86bfc5bb09517b818b62531c443df2132d7b2328c1a1f3653df2cde17d8bf7240a1c2f08a01dba7cd5e3ec96523f3749f87a6637fe14ce8312d1397970d05e06009358681c0dd0aa932e933ef341eb9f22a5697a2b2154cb5a34f10ccdee164556b68e18fd8b60037704b9c3c1fdbb7a169a6803f582cfb3bfc350df8c35fdecd4c24db722652d151100fd6cf48fdca3ffbafb02b11012e0ae2448fecc688d0d043d0ed721c8c3c07934edc611f49a3f70d8a1d5a54e20147e39ddd33ce2f1563399e2d321b938d2e3078bf16036944430903bb3954e90457ccbd88cdcdbdf29ba5e41dc40ce385eed1a3e05214d6f5167a12a084e48ee46c09290e508935fe84b1da976d227f46a39de082ca9da0ffd71c45f5834949b5f721a11d63a9b809a6ccb66e05f985ba902960ddd1485a8e9102289f5d7b08fcc7fc2dea3f869ed208008849ef9a1649784601252fbd797070f2cbf6bb2770e04029cfeb76ad842f6958e7bad7a9827b2d667ccdf5fa794d61afe60bb025fa9d06224ee3698c15b66baa055571134da7bbe6ca6b1f5489c4ba655a1d7198029fe3dd7351e33d5811991bb9241b0ecfb151eb787bbdb0f877b5c65d75cf77620ce1a4a2336ee6297ce65d949097025c85c498b5b9cf97554591032ec73aa88eebdf79f11b703eb031dc8349913b7cad6c7238cf36c3fcc90babb56432b520d711402db02e649270ea542de724f5c3aa10b9d3c04635c931e9c648dd9fdbc8fb0dc5da8d74a437cf2ae9b1289aa295014c344294d8b0d2d772f1e0b9471299bf2f3cbdb3d085a97dbc58b0ff6994793aaea155102bfbde73ba11881b444d55c207044e68da173fa9f99eae29ba0ae7772fa70375002960122ce25b07647ed957385f1a5920ac27be3ff41bcb28620afecedf92bf034c8093277ebfbad56751a3438985ffbb4992c3c00e074006b8ced2caa6e95fb9d6dab6688a74f1306b459a50a0c61e2e71a9011ba4907c2fa049041b42b15003c84abaa2f68f8ae098a4203d0cdd8352e9fb2ecfe908889d8e52ddbf3adef5c97e41598bf70fa579043ce1016ad3a0ba3a028c437806d87aae6436dcb6cafefcc1ba037a961df8aefb7dc2e832858ef56d9c6e40fddd30a12860ee265e28edef2775db29effbc3adffd8f86c8c905b238e64cd1ce4299db186d073ab84311446773a394e79e349ef65590a95934c2858b1197969a9f72c87196dc24386ec50003505840ea90c01c999702daee912eb5f97f3954c58dd7c6822493e634469ab96097d5d3feecc17581d33c6eb906d2ea97be5279912fe94be08ce1183c1587ad15d0b8fe807c4a1b4917efcddff8f1313710bcd9211118358d83424e3b3597847bb7b0f1aad9a0e3ff671d848eb3661681d0a3f0d8ef221906c68c30a1a61f242a9fd1b530b466ba55ceff931601352153fa1fd4fac66153ded15291f9039b5aa9f3a5f25ab175d98697770e939aa05cf95039df3728898e35fe41c3ce26c9b29376d3e8eed17d5ceef8a80352a2895917ae5430374bb2857b7fb30805ec8c077bd30f424cc99e2de0b6334631924fe7e20deeb7d25c581c863c7a641378e2d32ac714969b1ba7a74c73cb8e64594a84c1c20a098b4be3afff6d167c40b6ab77acf6cea5379587e674d8570adc11a168b51647c56ec188c1891455f92236ab10ca72da3148d058a1642d651c94fe60c297858eefec0fce68b690bf098d28708be84679ad2a1fbfe76e211916b79a31720af27c783e5dca2939f23a3a395aed5bf103f73f29ff4c36e9b8c3484f0e70def386607802ba5b6d3626f7087d059da498ff24bf18abb4d0a2c9e076372286459eeb61ec4faaaff3e5d0f4b4328febec5fc30d689ed20951e714474ba020567152f162960e3cfa7815e0db38fed985a55a1e9f08da907faa9e6b6102a2c099b89d03a27d91dab084efadb073744466264cf64958b67a60bc1c7a5ff29943fc83ffe3d1747cf067abf99db035bb31206a316e5efcf373dc8cfbb99c3047ba83ed1ba62df289fec11cfb26b858fbd458bc316a0a41cbd470b99f19ac0d650fe03dfb510f5eac2f59f17db603f82f9739a9e542376b33d8b0610ab028f64773effd6d5b8b20f89377501701a346999a327657dbf839195be4afac5cb06f17737fa05f8d4de963a7cb089c23c59e4ee69ca71293b4c4801cd3bf8eeafe9c357ca8e88fbb12340a6a01caf4ccd3768153e3fed2fc6a80ebf944d5d18c28e69ee0ed29c189c1fe4da72cc86a05c769541f1caf1d6a9576f572003c533b8f88ab0af11e012f50120c936def83acd6138129c0e56d107e922bb8b2e3c29519f5677cc4dd447ef69ade3a8227543a5cf46dab64155e6f010e1d8ba0d987dd2a81c79d1a2ab16937496fa90776784a9d7bcce673518e9598cf1e38ecc2856ea947545f3c17d9f54b9d65258ad80d1976cf835945c14e366d6b0b94a9cf42b8ba8618ed70ba8b73308a6a50aa20b60144899a7c511c53f740a626793f3e079f363ecdff918c1c705814d3079e57f9d3ec3e2166a5acbd558841a8f06443485154b8813237c77c94e33576cb7a6049fe3dc6cf74c08aedcac33ae12ad27673559ad3f8d1b40309c6788aa7e50b8f7a41276a66ff05bf98214d94860a94632d1c980c395d50489d8ae906378f0068fe7ea48c98bec0231bf1f0e2e48c40bbba71c81ede4fd80abf4fa9e2e75a921f4b3dfa5b4b0752c83bbf26b52f3316c7fbbe7d93ff10436276b689c13ba7464f7f2c3b2b73d6cbfcbb7c6117623effdf2c9d4cbc62adcbff6003fb2896a94380f062ce510c2d7c93ca8e4164a6a281f185e5270696c8fb5cdb288f6366aba2485e75a632ed4cbfcb5399661271eca17e7c60988403f4acb4e725859d3ab329a1cde16174bd937a09122be86aa5abc8dbf5a98534029e12a2872ccd62dd840827ecd00bd9eb5535d7c8675b8d6dd21b0559b930978f19ff13eb1bbde5fef7e0639f3dfd57457a5397bdf66b5f0f657cac20eb11b3a0a540dfbce91f1bfda5a36aa1d76e3c2e5e6c662ae216b1323d9cd706606e72388aba6d11f3a4bb38cdb477b964861d9d050069d82d8870b1d7cabccc82b2bc16a26967c9bd8f2584e1e7d86773cb19aaf213e429933a581f668fd97b4f1d0d150c606928f1cba8a304588ae5760e17177d810ec9bf1dbe5149cf5d78713b88b0030f2d9e7e2147edc44c9917ecd83b2efd0e5f354275c2dda517d477fb05f47f7c14460460600872992a7295d238897f7bab720cba08df3e82bd57a9a4dcfaaa9b3a2b21754f0ef4a67177f203ba0a3e943bea2b83f780854133c8d72a027376eca06ccd8825022f499831c4d1d3e06e6d74eaf81743fde78928eaa7ff343f620aeab8e5ae1b0d05c95efc3254252c07c5bef1b66daeff54f73a995eca656c6e2598be97df650fa60e17baf216cff9c69c76cf3402360e719cadee179f709be470b1f7f4eaec5302c0f911fe258092777c89c346d7bc748c210f3416127b2318bd6fee3314ccfb0bbc776ddbff68b0e59feb2f7c27fcfa10aaf4fa436066b0f5fb819595374be60b018cb4a494c4bcb7d6708766fee0a40d849f43edfaecdb7d456816d1f77d10187d619c0a531c828121c11ef7a2d3a836031fb326c4cd63ea6078406f9c91473bca52b02f176e4aba0bc09c3ab8e4154850bdda4bb26af6488a42c112fd9f9ce6b38e90a7bd0f8e49fbbfeca4993722892486edc008b41851394b91fd1b99245e8d435b569ec86fdf010e637997b257a55cf0b1219282ca85f76669704f4e1e1fc9a6be4d5e539f3a78c27c68d2ea5ff0d27ffcd19b98d989bc440d627119fddbc2c993fc0ec07aed4f586388dda86a31a2385e45771e12ee11a6e9b9cff201f98db7d74a2a34c5b1eb6b72ea344fcde08e1dbaf1846267db60b4a94a39aaf9fa51c2b7d44e9af628ddf5bc2600c9e65789026e3232bf67dc6bb78db5767c8e9dcf2ab1cd1a7ac61fcd92a5585e4ede880da0b6d1ad83763647b96c12ba73935bce6b53682744b1dbb87e5447c5dbc9588850e81bd367f0e10ea331bf71a59d4326e7da3f114c10cf16a73fb2185373082ed2e1153673529f7a109179f29ef8f6798f8ccb86c6d6f63e22c2d57496f898ba0927c3795bbca0981028d2f1e9e32e19d40547ef16820fec56f9f103bf63464119954c2e336eff07ae3ae2616bd717356081b1db2762051aca35f57df04eb59f4da423dba854891121998f4b29a701fa4dfe47ac1233d131fdae8740df0affbc20dc2838374ada6b3506b513acef74cb09cde556068d2ba8ed9ff3bde34ec2659a01cd10477aa4688ba5ec9a4efe5cd690821a936518046d755b128aa5f598e3b65fc5eb3505fec3e9ae48970aee29f338d05f13f3d02fd9f183b7c53a586768b0d964f0043af61b95fdabe6af76838cd37a6073b8166e7a3121580ed711d8d7ddaacbeb7bf9570b2bda776d506e66fcbb0ab1338f8f667ca197c9cf2388bde0c4ef887efe4a8d07f1498be3de9f23b665d005ddbbfd7bc506122857ce7ce9ed0634eb92f0fadf863b94cc94d9548ad99f187eaa5e6aca4137e1761b94d8680cb54b8d441a08cac810bf6ee42d7c169ef436db1adc3f1437285b83fda34106f8cd3890a9350f40ca1d7fef56ef0d6dcebc952d8929f75df445068dbc293296a46aa364018c01304ca967d2d479517b817b2cd96040f5e8c6a185497787a6a65d2a4364356dc623b9d1f488410d1b47bd5b8a72d42bd56e384c7ab2be6234aa10f87462dd5945e42d6cf4027bc89e08cd7246c9dcd48c52a1dc0c51f6a207c82aef65c0f2691b3b7d5581b5e73c4098156d0e5d5e40b3df2b1d1c700b4d4f2195c33cf455a03dc06c50af36d28cde362414f06f629372629256a2ca17ec9748be103d57226615ab3ba229f388feaa04b6f8770462530effa88cfb3ebad0fb90fbd15eff311a409f8ddc68155b7e346e3cc80fd8b91885b5b6e7be3d312b6374a29bb0130e6522eafcdbbd0545397c38c0a1d514ece6cbf46866527e2eedd0e5736e62f8cb456f23bcae17309a0762665dcd6e8e5f473c6d911a0fa6b963d638b291b6165b1b4fcaed1f3fc3c82246108af9099549f7eb9e7b2710f9592d88bb5ffc73a0766e882e19afd3c2838f64e19a751d6c1deabb6f322cb2ec0c8aa440e2c190737b352b80a28d965bd697920291599c1a29465a33eda8c3f8e9a3774c333606692b6e419f08a617df5fd7bdbaf4e2ab9415dc5373ad5c638c7fbbbbbd57d59c9d286b73b0bafd5b7a49f1b950c8245ba0962ac1089e69dea5018bf5e5eb88c9c03697af1896bfee1fbe66f87fe10031a7f2195b77f763a3a5a81e46d9a72fcefcc5733c3e90c8f04d623c75c833c97dd3b60649aba485fd6a880289664e83e1036323b999f8f27a9a0872e538d666e6da540f1c167231683ef1d9543a950582f7265fad95c411e895f6a43e0db07f323fe38dfa7d2a695c25b8a2533e4b0908eb4d6d9b5203f230594fba4bcab93aeed08dfa7e942acb6a5fb4c0c837721207d7d891b100bf912c4d01c8c105983e6b219eaa89ed29df0674a555e386092635ac25a3136325d03fa0e32dd95b1c1dcb93bb5d59c254974b107ec87926d47fd4e7c597a35aa5fcd4faf02b4ada90c65f7b5def6751da971d98391462f893a217a435aea04ddadf71e2dee3f7242a4357f1dccf485545cf2265475dce02cef6c561fad6a160ce191807981e3ddebaddfa86cdbbf2970e014f367c87b57c9fe197c5e16926824393e2787007af8bfb07d546bc0d1cba07116458a11989b736f2a4665db9219c1b7f4f302718895517194323cfed592127266d466afe0ed1d7157c466e7659fdace34649e57fec6b01de71260736e7e50e9a32be182b534749b1094d52c0868711061b389cfa2249e587f17e744e269294c4dbb005846da6103a18db0f5411c7be990061dade6976ca16a918dc0c74a840c168c39a9cb91b5c2584a0e354bbd5719119005f205e3c3c4ecdd624e898113cf3b880f3934064b24d1f14dc68e6eea9561700950d4cb9966edd2cabe610fdc16c95b01a4dea82a5f4e9b7e711fd839d480ad7c2946ad68e814d8a84231989e7ba15a420bbe4667fada6658304cd318e152ca14c53dc39bf869761ccdcb13fe0d8add604a089c8a3ee67657824c3367e3bfbc649d6c0eb2261e767b0dd2f5c59b03168c4eb8be83775e747520d186430e8c5b51eb5fcf3758a7ab6fdf4e5fb2c6e51ed4ed10808266c2add6bab5465c2482bc6f25a715a3fb21be6942702883343df0bb3ba9fa6fb0279ee30d30e0d9756feeaf1d9f75386dc12de0447af26e90f03a39c83b6ee3354aee46163a415218df02e0837a71e5fb92293df7f667df9338be5c638f5e390ac10cc96a2ade81eb3bc1a66c4374eac8af396216e8e15873098cb913e67e5cc4dcb2cda17d60b824025ebfbb923c62057dcb130281a2627c1c7e4f9a4006344066ac279063954bda4dadbf1c6dba6dafc4061881b6d38e7af783f2f08aaa2969eb480485053ff419d1a8dbc57b09b5d244b202d888c35d3ed68d584df9793d47996d9447ea91162448ca56a6fb64164387af675d0aab0b943e0943bd2e9d731056f2df5bf6a7c495ac8dc0db631350a81b9368029b8cc1f797a644a0e3b1f5f26045cd8c02d08bab019081d64bd186f05cfc90df3dc1df4a574001f8ebf6827ac8f5fac4be73842adc6798e5c78dd69ac5fd21cefadf93d54b018860a1c07e2ded28dc7edcafa0f54a18d7a8d6d0ad7922160cea8470299025094fa390cda5e45c3b84ef4949e4ab3c3c750f1dc032622f7239c2012ce9c6330443599f9ec6542957fc0bb6db12867fa78059637bff9461c13850dd81f3c37273fe5a2283eb07b0ad11b5c506ea82e03885b86347a22e95b1afbf87efd75a5473aa35f2f2babb5f1df4a06933a7519ae71980be1cf988a85296742acb3a1eb4a733069fe278e7283a9a8bed983d1231244cf72ddec0f43dd78848ba80d9a92ad2a6ed05a1db84fe1bbf36b929ddda9e97b51f24e5be32e14de75e692b032dc6742ff5b737635632c0606ff71a1299d671102ac840948cfad699c06ce0a4a5e5dfa13d5cc86ed54f815a6f6ba142b88e05bdc4825b4a49ed9bfb50646df6610f70ec66bc1b2356d27e9cce9bdaa1fcc079b30e66325529070fc74846765041dba0253fa1c7d06e2f6754c38af37c9833a52ffa11d81d27a19bb84efa773c923f0e47f5a3189a4157dcf2d8a32095d7c7af4d2a1c1e809fdc368a3c6c65582312f176069ed7c091791fc0ea2eb3f58259d05d6b52b63e727e4a1c655cc32d349605d58fc13d6dd0f12f2f0524c77c1276c2179afc0fec417a43030b356ae2df024cb103f322bb77c7d82a1a92891f3a006c146ada64546e660ac0c1288d75e20a7b454549cd0881e457aee2fdd5b44222a15ec12b0552842eb1b64f13b2771b1f8e8714916240abacba198b5bf4b32b433ea2dde425b40e89df965292b1775a49fd873a0dba78679e2c714e3c5cec317fe9208a9a3ad3a20b1cbdf24850074f782a6c387cfdeac99f421840c2bf693ada48f29eff788975d95535828da407796dee19350d6b59b7af478045ccda513165bee1c22a3426872c6d84f8b50617ad6b0db5c7f29320802c905df888e9037ff18ed5572bfc23ff19f2be01a4011f1324a96ffa55ea299bd49c4f9bb40d4b0334ce1c7a682f962f608699feaa47bba1f57acd7b7b6253892394d36c1964de6248ca633e6183557d0202706ec3e5fd764eed150de1f85be1d627c450d173b83a4de57d978c4b9baceab8f4cad7fc564e55e967c6344dfb4e99a80ffb240d0944eb645da482398fdec33b0a1fa2e7e5fb168e62e4be556fe89fc0c1a4b16824c790bd21df319f2396b626b3555cb6813d1e0c4e458201c8643cf4160b568e449088fd7acb91d688bcf016926be2c81f722077982eb6140ba295a090fde1cda16bf68bff2ef68527c72c504e287befcb01a2ae14ff1fb226bac0de6861c98a7aea85e766c7e2397d6f0fd6cc438e00e18899e018cdc8e24f37ebdc572cbf56cf0211abbfa55c10ddee3bb4e00b1d952ecbf72ccc1a04ec70404c94251ce9361fcfa03667e739a2bd256e37f0cc027712c4efed7122a5000ec8b305a1c2bcae5e0ea7ef7b754970007b26b7a4d1a73ff78ffa39c23d27e906d0e06d36d153278332322dffce776c95e84a4a9e767495326c8640e1387ab5926c521f68c3def3ae5d4fb02547b57b785c06e30f1c2369b353a871c429da16b79dee0e56c995faf665747acb5f7f4eaa89d562f5de44e863a8e4686412510f158be8de004d6a86fc1a7856327534ceeec8661f93260b1de033ba367e24062294b08b7fc31579a34cfa1f97ba0a744d3d7f3e3a5a09fab0a16b3f39872d0972abacf2d5cec790c25b43bd099a51aa98871d8a1096e25f61393867dc0fe0e8702ab34e81151fddce7c1f1e33a7e9ebb97d57c28ef725f1bc40bc776317dd19d73158d3435a0334ee0fd430d26a4fe6dfa8e3530b0c4e0ed43c3a18e37215d39b5bc8b9f7a40c5680f2db9fc3fabbfde42fbd737cea4218b91c877335bd1be6029ae49f5222d18975c00ba6e099f6035fc80cfe2f4bd39ce4df4609a13fe48675a3f083b226d3310736b8b63c299b8062979b82678d013ef03667dbdd8fc4028c6a50137af88f4e7e84149df24578eb734b4c967dc30bfa2fc5cc75aa91d88aca504f3e6d6a8213a1778de5e9fe2aacc3f218d9b819fcc54037f14bc316e17f5e45f136bbd0ba079df8c90b87c20e99aa5e5c08950378bac75eb6c1c87002dbf90d78b129f18ded46e99dfbad80e2321657ceff3754ee6d3fe563b5dc4c2e8e83bb8ebf29bfa768232b6ed2c273cd95a0cf6c21c53b79e607c126c9ba8959a8fd15c9ddc8f566272f238d365608fa58d095b190e8aeea7aeafdd63af2ab9aa57ba57872c59f06257fdf81407551c9f98ac91ef5749eab57eaf68808ccdd0d730fda7e0aac94da5eb93c533a6915d7f158b1edbc9d73975f8f67d9797242b28b07dc5509e9f31c67267deac44ce245c9c014cdb093938219a04cc1504a69309dc2428a551d3169842ad8ccff887f1e72deabbdd8ade5dcfbc14037f8e28246516d28e74eae1911a4846bc2309338871062b49414e675297a5fe2d5e2453997f6bfac2ba76ea2b79c83dc8fb7d4c24063a49e91816bd58767bb72994585995d7e809aeafb9986d6619f19a32a97e126cc17a8f065915af8ffbf327c9f036a833e2f8c537ff472d5abbf60d5df46e77b3b2733ff50e72fdee9dfd6e7c46b4354654cc856c7bc19b418d52ea1b74dd08dfb8a295ee8f38e03cf019f7b30efb26f4170965af80abae7a7f48831f4c0e443a7e31bf817eaf12cd569f324b9d806e787bf4d3cce59d93e28a49806ca6469504d3f18511c4b0f818323c9b793c4916b0ded6f170d304af4db9d095ef3959ffdabaf323439e631a0b76f2c0315608d14dfab11b49375b6e247ccf106588699198d524e8cd757a6396a631a510552f9a46b2a4e770cf996750f4f82f2e8b3bcf5951f7ff35e797a269e6c00e9801b67556969c2e616f20f6545f8912de54f900133b8fe596fd44eb9dcd64d45384b473859b7474c2711ce47f0c1a626ed0f237c8f9f9a0f54839035ea340cb5441a8558f44078bf8eb55aeee1aec2f261eb13c7f1bc973851aa8e86c524269e2e4c6c16ac0ec5b08790da53ee1877da82abb50b9ca8cab8b045c2bf862cbc4ad3d48a439c097a38f829d84fc649a3d6b10049115fd00569eba61331739b5e2babbd2cbeaf19ea135e890af41fca06884be325c709f2db7b9ca6e35a7100586aba3c287af1952e02f86e1c1fb997c90a1aa02addde4340337d327860f859df9284d01f867ceab2c7f2da553c5c81b536df38f149865ed446bca8cd26d0495b0c9e45506b633e236347e010be26791a3a3cc1f603934a2d74ee53bb1069db9d703bfda5ca14cee00afa0c5b7ce8d2593a1cd198e7d0f3837b77d993e392bd3c85bc0aebc1f653d4f38f9e2a3586f3778494ff0a8c1f813525b549598617f621ada7da523855e0f13094a25051522f81398f7552b2b20c80e109bf6a52a3a3e212c37f1c0fbf44aecc77b7a5ff507a247df4c83429275428607645917ff48437768f6ddf1b1163f6134f96c71eb6157b5636a5ad10620dd56988c31c1f729898525601c988255012026760dc831f8eb616ba78d7b6557ebfc46217338954cbdeefae881d90b727685b34d0ccad9c598b67d9783c5ec55e3387bef6b6742d1fc2acf8c4342ecd648e474f9f053b63ebe7621a60e76dd50ab4b3d0060010d539ec1c9ff96448da081283d5c8450f18df00263d5ecb2a92b4b24b117dff0c9749c723d22e82b167e19ec14eab6322d5de6a097b03078e0e1726d859c12ad7793c3c54ff7fa0a7882197cf6540d34f535e311cb03ba024e7f233a37af53c5b4e0f10afb063a38c48eb3e92302ecefe0434644db5a848f6c32874ac87e0112c413511bffaaeda0c1ba7ba2f80efbaa6984a400b399ad760adef5a67ac5f709cb6b1ceb55bd666f96a0420ebeae70433f2c5fec2951ba4e476bc979822675c73b73f907202d6e5b279a3e2c183c0b5bd7e2b67a0a2007d29e9fff72df56475e774d131cd4587ca041410e9d280702f1093639dec38878419776c05c8db10e256bf765ab920ca4b2b28e291770a6ff388c0bc6ff33f27c627aa2087463c96b1631570b82d7838359b4787dc786540840b80218d987736e97e785a016374d4721a635a14c5eaa5432e6954b36a19781a542ddce64780f7b8848cc8a8dc51e699982e1f38398122e94ab967124abeea240ff1478060965275f4691ee0496d7fc2e7570eff2e15194215b5d70f6ec4622512ba75c52cd2a0c68f10cabcea1fa4dd4c46ce68fc7893a384602f48c4bac367ab4b3beab11399c4098b1992597c8eec122371bbbbe25a706a495c3dfe21f037344ccebc5c41f681aee7002feeb28e94d5dcff4adfd717c1dec095c702027a79663d05575aa3aaecbb54f66e2e2ff571767540d245374e99147ee48c875336bb6bab009b7a75c42d78b203e3922cde48041b845aa85869f2608af140345e55b6b7e584cc1859311f7ce0c9b0d1da2b1f0eb585dd030575e0d3d1a974c90ce862e58eaabd0d40726573b119d3689df0b3e7aeed90c194598b88cad4ddb200e2e25f655f43c73adde9106b32cbc826f0a71c221efbca198fce49ab75c10a4e6f3f28e61bc1a021fa2c974d10bbb43b2c435bc715b123799be8f85950aef0df781a4be0ea1a602a83db077163910686b074acfe1cb9bbe3df3b67947ba53044930226c97e15ca851944f3dfb77da65742549e70c133fba77f918fd1a684b9edeb3fd818af28cc056cb64fbbfdacc9d6d26728fd1708079822ffa525a44824bcf878d6bd96d9943d7076873ce4e82d475f4263f2e964c609c1b8cc869567f6cff1721d6d92a765787c95032c91aab0ab4dee7c8589acf75b439df174ebe05c9eb623d29dbdb2fdf326a4ed8f0b0fea0b1330a692dc51061252c42d63e04ccada9b3c6f733fe77b837ac08854e38777bb6637e7b8542c05aa352abc272592df11a09b7ad73166c34d747d01e76cc524e29169ab83592423a5dd7839c2f1850a095e4b661e784cfc195a6f505dd4fd420a18f0f0b53f11c561fb1ca4d7d6f0424a0ca0c3cdb1fe3b19fd6746a1db03b074c184fe4137ac055808164a9ae63aeecd05c4011bc69f3cb974072cd238e20ef8599f5823987a4a97f0f991a8d8f7a78f596772fe57efc1c56d6552411723b34d660023fe7638ca962c0aa7146d094ce6182e664c97acc729d283e421b5c96b551a7c718dc4890569a89fa434fa0bffaf04938267787db6ce56b8a6466ee921d19add72b243e7f505ff5395ab1e7dc46255c02cfcdc17ef2eef130bc6c97cd5f28efc7796153c71cba4e8c6907589dbcf061cfab2f419600d1ecbad66fbea00bf9cf60f32b72dbc0992da02f6b10a8ed3a2b3f9f6285a41f502eb90ccf5a03fe51c9d6df4dd43dfa7eb39eff7349e33ad512e68a381bdc94c01d6505ae54a2abecd914c09da12437dbe21541837388c4ebfa74a5ba00ca1e0ea9c75a8c64007083653500e8f1f4e0b93e1e5cf579dd478a8dc389da346a423ada1d752e381cd6e424705b8563a6046aac11b3d3976ec1899b1d17cc9fdea0bda07395cc3345789446b07b072269a429a9d6f82bcfe8f7e0f1290b97c5f80d31c724e2474a7ef929723eda7f80a28c1bdb650c1fb6d5c8cfc605c3903deddf06a13a0560eae6cb4988825db9eba87bf59375de0579e4803363b52cc51d0a2c683b27d4a5422e27888a16ca39a0552aaf6ea0dcb6cb5a625b0b2887162172e8f01f1b4877d801cf88687e38186de75986b818072c0268e3f4f5160cebb0c9e1fb162a709fbd8f9412442eaeb5269f77d5669f7cc37ab60dc02915a0172e67452d88ec2c84b5c699083223236a959481f06fe08e496ca339736aaee6b3b3b8d9842f1754e42ca75e9bc175d5f5f6fc5fb3ade92e080f2fc2117492738cc1674df8b783b81073c9cae410e33fbfad601f823022e1b3959f0ba3ba45932e7c41336aeba4c94a21261a998c1767307950b4c3dc8b5d30603bc51716cca42e50e929c9be9260930f99c606dba701a063c57434940e370e794d67efbeffee12f7866ae91f7fa9de7d5693026f3d8a5a1ec9817782c9f3ef05775941b480cec662634ae8ca7be887da8c3232c515e5a620ce545986146539196f464bafa788bdf9bc65d1dbc0215f31340ed38f6eb3cec5b89d204a827982dde4f4c07cf5bd783f15f0faa28f550d64c084eb9067a2e0659d7f069b1a6fc46760c73808a137b73ecb026dba0094302363d328487d9d3b9820cd17f687e25b73f58e15f9cdd77f414b7fd0c2e74e8150157a1e09c13ef2886e6cb5d08c23fd0e09e85e6237b204ced3b1ee83806893f967033097f63e3291bb5013b711acd7ffe74cb217a8770787e75a4c5d66fe40ab94c9a8011633bdb8e06bdd23bffd147e9316074463130cf2b438060186799720ca7bbbffdc50d5a89ac97bb79c1fbb667406450da33132debd538c020b1a97bf482b69e76e698d39f195832a12c32d457cc33d02f917f14626685a017929664dd0cdfe61f63745ddc276a818f252a47c3cc324648f455cb46409ca988cfd4df8178d1ed7c764955ec5ca94248e615c447381a951b243ff0ebc1372c7a5c4939ef5302fcf489706039e449b0a71e426d1de986edd3ef5ccd714fbcf3881b910457e1155b5ef81f638a4898ae60e08788e6bdb7a4e8a17301e6d2bad4861e453d26250340a184873d877fd814f3e7daab7e2d98baa55c9deb2d7c207e675cfde60ff9511764c72bd910a6b9a69431fd0cfb5df48c8cf80ddfea1ca38a5f9933f08088592ba4ee942de4d3ca3bea1535ea540ac51422700ef518abd72b675b5709034d201382ce57c899c57df4e933a770fff54adfd704cb0d0d3cdeda299ab1719ba2d57dd1ef688f6cb0de63ea83a2b572f04844bb0d642c8e105772f9edeef590d53b4cffa2427be70204f4ae1da6538c7001f7a4da4330a73001f82e7869bad46e843cee71044e96f82881e301f9a155e5839292755f3e0d085b7eb915a7d870deb4a22c3d33fea3aa7f486caa49bc88f8d381b0f787e100d50a1b327bb40c0cac9dce24b9258fb67b19b4d5218757c46913a17e6c5e18be44725f91415431a2a636628f1a9b56a46272f7d93cc2e1d4e17a572c853b1ce384d662a07e9ee582a2d02c5117498c53d8a3a8e55550b786c73fc183c3de79f614c760f852eaea81a982f2ea38538087e4bc64ac516f88bc3c83ca54b62cd48a92f7fbadae3c5f1251cbe0402634fce1c1ab4b3308c53449790cf715bd9175fab238865a74e459492ca39c3cfe5b997962e3535998890f1f0abc92d6ecc5f76cdb4c3297c91eb73f0b128f4c776fe99032cc9d5ae6a2ef69941ef5ce5455da376058975313c5c4a0bcbc26b5a8ca41d98a7f83c270c4d7990ced91d0bde83ab3f7d4cd407d533fec791a2637cf58eba19a0c996554ef348bad80f6eef3ee8972f797136c632e814721d0a48700ef80520aa391b109826d49db3ebc401a5a3594d0cb390a86e7cc57b9d160ee73f08cbb5f59289d4f09a78389813b30aaad268631719c921028820d43aaa48c46c1881e5e6cb8bdd9ed3e83bf3545f53ca124068ea6e274320f2fc5be3e2d563ca0e13bf50ef36b1df74645ab23cc4633b77bd36d92248d262963cc480f7d8ca094222e2adfa7563b5ae922ce41c18698ba408044e655cb648924d7dedd4c923dd03dff4af002e67785495308e557e142bf519d0d19d462efd1f87ee925edecd7016652189583e41ac1facea5c9ca82d36d8a547efc6633d8057a113ddb48872ff339372296151d54228cd932acc85787ae8323769001fd8e1517786343f3f8d35bd6d9089702964623e890d7e0e10bdeed4bf1122f63cd31f2d1e04a0d1d771d1f309c4f0dacbadeb519126ceed6d0624455a00dadd67d926a1c7f49639529feaf794dbc497c7a61067cc1bda6cc0bd2c92dcabbda3859946f2faf7addba93a5858ab891bf2649e8bf75b801242696902abb6f36e9c528fd74d0cca1af7db89b5662a52d48e673926af486ecb347bc0af17b6704817f7a0ad28b244781fcd197220871992d7f3ea7f75b902f281b28338f3dd077dc39af3edddd29ea55374e7f567bd85a853118c3b6265334b3f9385146f25652c397ea1a488cc7bb228171e610a109d7ddb59d08b870ae251502570061f1a9fbf523e4c7cd394baa6afd833e36102957c0bece614a33ecd65b6c886b04058675f2a074c7b289455ce6dbcb5823cb5309d98c722e17cd62f3c802a5788dbce582197f1b9ae9246bbd3a56487495b0107f0bce0de52dd754da4f3ebc4a82fbf3bed6e32b518f12fee0fe89b357a47708dd79c1ebd474fe0cf25f52f5f3e82caaf60987f4161715a4836024f5b37f7bf8a2b80554cf064eb899b5d4591a548e9eb5b808e9eabc90d2385d4037226bb412131099396efde0725eace2ce3a79026c3b4ba4b8cefd658f5d3e6b6b189644af205faac727073f76367a729d11adb9538bff4e709839b38b054761f09f74d301519bb11be527f743fc6c85d61838943cbf30f138a1f3510b163f15d757cc72ea1ddff33db724dacc020d26d22bbd1648595a5bc65ab9fd83aed2f9bb151a270dacc5ca35e7f002022357ac58c9391254867fd5ba39ae7d5c68b77f3d9e3df4653dd74f1147d51f3dc4eaf8ae831f725703723cd2d9a1510cb3c0a1d0dc845e3ef9a0afe693e55abda11708b01cb390f737e31dad6da6f0f3e31a7c9cbc4f48d0f5e71d6c089a902eff309b00354206a3ae9a05ce62b341ace73d9cefb8ad4433855debf773160d6fafb0e8e1fae09097a751415bf7c440b5598c81bdd313b6644f0eae942e726d9ef6fbb1e904e2fe60b1ac7582e83c63e3b4576f3161b6ae2eb0dcd7234b25064b7c1dace9b8fa9abc0888df3c5383f5da6acb67bb966e82911922c417493aa8561e2eba53f09e2cab3e39c3d6ada16b52f36c49abdac8f25654d190cef767213c46f68cdc118481362255ba649b6b8aab9ad5e23a01c67df60136946bec4e9ddab32e6cd6954fa5b34b40f9c4e9e07f0703deb65c0d484088aed8b44e6434aca5a8cdb9922df02f65a163f42dddb5bca921db65bbf08824c9e02df7c71ad255ecbbe12d0aa6e9aa41021d0b4ae6e6407cd35cf807b7117956e247bd5e5ea0a7f53d854332cddadf3793610916544ace311c0bbb2c5edf4e32af7c66994eed3056f3ffe978bc343343ea2ab14e12404a236ddfde1147235e9168cfc7c2d76c2ba16dec3c233a0e4b925e21016ee6e5747d116e354e20c69e63369c04fa0a85319b9338c539cd969553f95c01ad8b9a143f3fa22a0cb5f01c40000854e0edf50dfd1e788e3fdbfbeaabd22e215b5db16bc2e4236a5a3d7f031575df8f81f8a457e9b2db9d2c018d5755dabc94c3212505dfd97e5ff4ef6cbb9bec642e883930ca59ddb66629137afe3455e3890b7651f73ca3235e8734b53b9115ec2b3dd49e587a639dd4ee08e3aa540a90e6c27bfb0cbe0cef810063a113612ac1c404b49be85833ada4c6ac37ab437afd0bc2bbaad2cba1b1f13e9e4f4d31f7032d83fc8596a68ffba022b6bebb5cae33dd4e94a4c155c14de521dc8e77085327b7b489249cb987f4e48b2ccd98ac91bf9ba48f37da3e606fbb1f5587492d6a2cd76b8116284fc85f2ba29937178950602ef9423fc1ff7bdd93277e4fac2edc1f2d9caf38424c9b7fb43d5e692ce4e5aea57b80347e0c1108b1fd984561414ec2b352a59fca9e891c36f6a14c121e0c9f6cf5836f11afbbb7ebe5e8e44019f3d54fcabd5e05d93424809ee7510cd4dd7d3474aa180985adafc49e76a4eb5aa8954e597b139311f7d50168cea59797125e2667e7a3760414292f714b2160b2658dc1b25b5110efcf64de5173fc7494b2e0464a1cd44f83e37f223de2e95e84c6df7a829a85e550ce50915a214c52533a3be6ca190748b94244a6c51614fe1480a814422353e33b5063af937e0459ccbd6f94fed381767873618fe2a6ee5709d1ae4887753c386fca7ad25596f88321b805e38586e7d6506dda3cec0b9165606f5b6dccfa8a8b854b08773138f8b0edec500f28f94076a7cac75e79d98d990fe2a29d69e6f9f985b05225f9b379a3d7a355f5fda1bc383ee0684cc70fba234877b04dcc51eaf455883ddbdedb5158bba993d95d5e1d84d519cd7cb1c914d3d19e04cfd3cdc3a89d342be75970f182291954303d761599d118a9f422a591319127a4735692bc464612599c73e094152460a7dccf6c56a0e86b6d3d419c8ef52764d5c9c30f2f4cd2566e308c62b4ec99db8253a5114eee4fd7a358e382405b013aef4ae3f548df5f505bd4b38805779eb607efe73e72fc067db847e528484f879962878e3b14a8deb3915137c705b996cbeff1415f864141ae84ae342ed8f68d179af23a40f3b47295f81a5de9162e6a67ff3c8d281ae4e0d80e45b68a5c8a8e6d2a077f7af1bb599bcb678ebad5bba2c2c09376cde31dfbd69994376f5fdbbf167138859645dede01bdc11d53cf5705f3c54a61453b1b3c100699a316c64befbe32e6ccd8416db79fdc8fd581d59c2d2ace2a2d7cdb1ad98177a740db0d8cc1cb996344743ef716bb858a95760180026bc02ed9ca64ca32c3b308494ef50285c0d2f20295ee883e3bbd3f660fcfdb4fce5d81344137b7f435d19fb3a1f8a27b46594a59ee02d55909019c616da278d8355a26f36cc01851ea300ff2e998db6d55af2f400d3af18c51e1ef6f4fe7b508dbb9fae378b84e1447ba7f735f7c5fb3726a63f817c59ea5c0131dd11e7eb1fb9e91f8c3fd6fecc5b816c2bb26cf513bc4f0af718c317132ba7e33515cdb8cde2b5d046fb3d4c0dfd4f640b758b8d07f127ad772bf8c133fc6c44ac1a00e4c525ec8a8aa023bb8fe3e8cf439b13d0ffe8fd211c14ed07e4661ba80fb1103b2da1f9b0a913b99ce708df91376493190853bc01e6157f70c1004c62da5aba7b97a20c4f2f2e0e0f6c97c5a47d8fe165b36d265eb1f576ca4fcf0bc48a8c3fa056f0b13ac71c0124d6df1c2c78eb8a5f0746aa2a554f4a294ffa5337cb5f63e6d2e9105b1ad95f4d8f01ec54cdd31606dccfcbccb0ba5cd0500458f13f5f3d89d690f2d29038f45f3258226530b353d50198e3e972fd256e31121f945b16f545a025748120b5ab1dbc6d9d36d3cee24d91b0c077e12faedac9895822668ddd6213332efb15c524b97bedf6a704ec217ab9249aea6c0b4f544e302605882236a14b9590dead3c7b9f58c383d2a21081840f323c35563f15aac746291b0112f70f1f16801bd9641d76d101e9ec4d921802c9864dbec9ca97fadc7f6ce3aa690ffecc39f462436a0a86ea040a8aaffb2d5303c96abc144557a864dc25ce3f6a386d7d1f1c448082d84b809fa32e200963961e35ada9495a2e49ade82f60eea7f9a28aa6e932720c6fe5c5706a7aced569732dac8e4d91b8762737b8c43878852f4f1db7871aea31fe5b4b25e440212e9f5faf89da7a6eec81cc20072ab4e34a8cce3a9c46bba34f2bcba70fe51fd05c1e6332bd36f5771a79586f5c1bd58ca642e3d1521d522e2bd66a1c68b0132758f99abd3d407a84ba6e3651a7988b04ed48ed4174bf44cda5b9984674b08534197178626ad9235f82a8bbb69882f0ff6b06e3d98722e98a5afc62b40821e32e4a5ef44789d4aad6e58ffbc18f3e30ce6767c883bee81c3efcfad108a69f002c912ca0f0b40d0db315a2c26e8d8b44d5be2d96bf999d84e1067731ef9f408005ae37b5a26dc96f960e51b412d9286aef306768df995266261c3ed9e887b858f6656bc5caf7f424e0bbb26ff5d18f70f8a6a945646f81c37b35673e073333bf8a8ec1cbbecd59d1d017829d6632d80b7b2dac045815ec29b77fc149fb186e848f4727c0f71b71509c61e0d22aee4d14ffc8813fd0639e6abd229f0c351ff76a080a9947fe1c40b0cd63c9dc94d10b6ad1b1442709668ce3f56412394dfe954fdc02a11a452465ec90dde3614ce7634c993456ffba59d8b83f5fb61137d1530ae35c0ce8dc266ad5daf0ff7903f3dc6c2214880de80802c63a537502c50bca11ff6dfd4659f68d6a130199d6058452c1bfd116459760b0ac5c1e9839b7499b14a869df46db943aa706f43961ae138399134ee7d31b67d686ee9086fe9e0722fcd0375510f2ca29136ad118b8c1de68b94dfc9ae29f1bc2ed2e58598dc07288ba9d139816563ec7182d35a2d308d24dc717ed28f368bace676ed578a567fa12675ca1966fc4deb1fab4f5f3c67f1133e3deb53dc56346c86278dad49d3ac055a5eb561d48aedceb0378d22f688525e7f3a6857411c13dfbbb0dab928fe1393a09d0573eedb677f3699f448afbe98671067a355629dc7cd23c42ce4a2a8963e591b61b394e530453ab40cfbfd70ffd4eaa2924a902a51731865bc2764743c8ceadf18e54d6f5bac1c91b82712bf203ac6fcb7975e3155e1f07b1ee7d61ccfb97768da5bf0aba09d348c99dd41f2fc7306d910696589a0852ffee0cdab7003fe941ec8335bca554d03f7ba26e47261c61b181b7aa5ccf18773447ed55d285e12f49637d8a11125cbe1c670198695d2bd0c3496583b037bc0a9b923ef04c3038a242b2b6f32cd6b8a8990ef10214cd5c92c9d94c46aeeae878334316466ea3ce0bc7eca1a130771619e75745d9e9575bafe5682019a1a0975516a8c45c8c389ee7d0c52c460925d46eab5996b38868a9c0ea3d326f408284c9230450b7c01b8834fac4003fd41e2ccb70f330cb30279440cb8c62bd651e23260dac49afb038e467f7374306a51ccad3f9f11d74d80ab0102c8555c9de4dfc66b6d071e0d9aa2e3463051293a49de9c01822fe9ccb83c0f328d94f8e6ce6e01eb3d45e14854ecfc6d1c321e832ee2d77749e7489b28877a5bea03839a64b7d5abf748bb69766e5c2f7b1325a27f9b17a6be5859144366d689bbd1f88158c668f824e93c8a444a7433d43b19cd5a63e1fffa904416a82ae2fa1b9606be9b3a46d2e3af504c5db52a8159e2a08ab3e56e0cafc8aac7d6e1182f7b2c2ecd343fc77937160e656dbc788b40d50d4151cf577ccc25cab473344229ac66dcff76f8afbf888d61b2a51014df2684a052bbbf4b0bd1ad78e50c597d3ec7b7c3029a550d346923cf78b23b71ac77b8b5c75315132a88a29d272e6b834669433fc282e50cd25bbbe5a1669bf573db73abb1f92253c0b37f0be72d93276f00e2493077a14ae91fcb93bac8efa4d4d78b22dc7addf7e13a57a6e7a3624313ad530287ec3a28a62c52963b52c8380dd6fba0ec786cc985fd42417d4dcbbd9c4f85ce2db3a4a449ff509e7fd51f2e7f2bca4eec92fbb81d1563d0f8efc254c905316a4da9150d8fc362bb8228b4ab14e73b7a292bfa5fbce93471c349755ec7d4065435beea10c282859e1e6c917456e6ad605bbee9959e5bcaa60f9a08cb92e5d206fd9613afcdc2d71b155927f346d65364d93a2bb26e72efee30559daec5299019f07217e649daac19c286a742738798ce13ec2754086913c5577f5d451f55a914d8e6681bba8e1748029f4ff6dcfe781e34c0819adc0f11dd59098d5192a63783b521077f1b5b4664e1675c43ee2537b28f775e97e0d83daaa381cbf1c3e627f4b7bb3b28aa3317c863035e7aaed2dbba01e3345673c140383b53ab1e767d5d1a06c27ece8def4d7585767a8c8918dbb8c3d5fd2d71fcceec896b43f3f243bc38714d3cd46683acd347839e9bc42616601e4da95a8e8fce579392284d777c4a02f18635e1b51e24ccb44d5c83c8ed79bfb790011cb8b0ccff04a89c2e6340a35075305cdc938d0afcc2639b4e7bcfb6ab92322db3c93290d116bf6703b268d23cce9b4c8bf1ade02d49fc9c95b27bf674ca9d4d7f97820a1f448653ed6bc17ce436cbcd3faed45fb7d818e541d8af1c9e2642d0a8b5ec682c0b4be7709d38005a47c56f065ca94a1dce335216b775734d6d4aabe956f5f31fd4f84931b3f0fd89ad79a8f3fa59ea982ee95c8338959eb4c8f46b86b694684191b81d97980cfe6fd6ac1de5e323a270b6d309610ee31121854e0cdc5e4cf4e02f3ffaae3cf09fdaa90a39cc27c4ae7df7c0ccc5813718b86429c9217cc1e718933f06b1190e27ca52c9219a7c7070de23c1406a1463e8bd90beb91fc96569cc6d7f27a532f6d4cbb5b8ca01e978df85ca860f8bc3611e4548b0a59b813abf6af00a5e395578be871d7cb398bf91364fe59f8401f3fd6f0ad69a9bdaf53b11aa395d551975e2979234f0a2606afa781cdaaec0029a4b51c29c2c551c686ec49e426d97a143e7f8eff1d7e704966c20dbdfa07d999ca0caad32a7b01a8b4c4ad2acfd2c1ecb9c4c249878d198c2f0df279d992b6212a7d7e10df2127cdb66fb4900e9b8fc9b47f3f7051ba4a56e2f3088412975388d4118b64b269dfd14eb7a29b3dea3993e4163204f5178565722e580ef54f1ec2d38e8dee4e4734d80718bfb71c5a1cd0ad77c08bd7fd305cc9420d7cbb3ececffffb59feff09a0d07fe86f6342e972c7e0a6a871e96f98d66579e92765c5c553f5d76927a3acdac0fbb171f76201d0a495e0c4431fa91c4de810ec9c2e72ad2447ffb4ceaa8d3ec135885966c577c5cf557431ab4dc29653c007dd600e148c22dc91c51bf6b1ed18cdd47baefdd2cf6cf3dd850cca0d563aae812a0bfdeceb75f60a1eb09d6dcdba58214818cdcc46d8be5e612544706f2b1fa822c014bd844ed34a715ccc19698ee40bfa6114d4d7c0598755f4460974e423896b365632c501554aa00c15d4329939e71bb0391a55731ad15e7fe9b328dc023e2717c884cd268c9b29b2f567704d2b7f7f680b22714f8d5fb482898332a0378f6e0b241f3b20c032f373970d37772f4151d000fde66046c3bf9cb56b64f1f5abb9a079323909afeac636d78ba9ad8c35e8a6c59c4e9d51bc9747db77f388cb7caa5ba133f97c32e87659035e7ef621122cd67746e9b7adf630284791ff28e90965a51673324f0dc1c5672218c4cc4f5ca50900451f2123a34ac30e2c0b8421fc378bd35ba52f031f1cc518d9f8deffb1db911e5255c69dfed2687be887033d6f69aa4df64cee06ba986793ba023ce1720212ab2426f6bff7e7aad711a26c70bd092d01a823d150deec1ed048a81330994a0d406dc4495ca2aa76d55b9ead6c52d5bd32ac409c29eaf33534615c5eea73a5bc4bc10b74eaecd34fb29d1904c382ffce71c5767f081c815f9520bd0db439be8f0d3627458946b0db08b52b2731242b41aefbcc6aae10cad76aaa12a3c96d9ae1a61b588fc45dc57b9fedba3aca4538c06bf5d342f4bf93d9c96544c4bb2a7d85e03946a10bfb14c2eab1e92a05f4d356a01760d064e879336739cf1dc1762337174db20b41cec58b07584443d5bd5642b17680952c28aabac1b4a1a83cd87853fb7099a5c7d7f4d4bef9fae8cf5e567f851bcf768ee51db09e658dadcca4f9f19f0de9efe7a9418ff62e788d7a0bce9c69629c0caeab1ea19ef7283eb93620372647d5df0c2f25c4cc92a9a6b1d21f70b28285c8d1b670ebcdd18fc7781b0062d14e32f5877cebfc00d702680d7d9a74114b991536a99238cf40decc509e5e486f1927799d8a71b260535d365c21c4926e9cc1497f4c7efb5fd97f7d47c999c496aa5cd0ef56af3956844f655e663eb10b8b621ab6e3a3cfcfb43636727526d96b85c365eba31e812dd66199c702ee1162e877bd95762c05d65968caff6283d6485ed30fe9a68cadc3b1e17330837dc2da757fa87dda08144d7b50e1c78e6ff74822e37c3b1d93e201a5c770f5febd8862538a87b6f104313efe7d73bb5698ee3efdeaf8d830c8a7837ade5908b41b1be8da310578d5fcb66af3d687956383bd9ea729af1015fc76e1341cb20b5740c66f20609e9578359212a9b817c1376369574722db7bd45e93ed35f2664b3d88fd7b65df5b6886f56580e75ae0cbbc5cd88546b9971543f1107735d400c5f9d487fa354539ff0223192ddb6e1ea81397a7828a7864c22c9e1beed23d3fc126698045a3be52508bb50de319ebc2eafd5c17f2902390618a7dbd44b546279325c75a64298c9b5753f6e28073917d387b1101e22448add32a13b335bf0d4fc97e4cdd9625836b84986cc10e5ccf3b72f99871d6784b69fb5f1827bdd627cc4777832d3814715cadd0ae7878e5cd5a3ec1d031be00f1976cb1ae734bb5d6d0d04d121a40788d001030578e562ce9a095920130d6fc622263d1aaac156245a4afb756349d7034140398f02b461a95de4578143c5f24456979e4d7cb7271eeef8ed48139a11ad2b760cc012ed7abf1a7fe1a683dfc10c59b626f2cf92cfee562c6ee7fb1f8e2059bae853e55d82053c739299ffefca19965568e6d6c779e272ff4f7ba2cbcea591f7f0d35faf22d1ce0192b7b8c5185f345d6c6c570e9781bdda6bfa619ced1eb5b80bd2edb0e7e6cd399cffe662b078c1d79d0f8dc8ee5cb5166e9b6df127ad3a28702ab39ec91a528105558312b21ebbcb902d8ac47b6f352c37ea2ef485e19141b2ac066fe10c9eba86bb8553a512ae42572f666de28dd411c28b02d1d9e201503a9d7ebdeeca85d76ff0163d284cd8fa5dbfc83ad66a6da0ebb7d56f74bbb4a91f30373383cc116a0e38ef000c08f4e670d82180203b558f46ce115efcc16eb6eac3dff70f74890cddad32cb8ee9855d5a7011b0036d18552804daae73712e8d2577b7958d9c4051e544aaa651ef450252aa2c454effc4ff7461189d924702cf080029d89f3b524d3257c63f7bd4fcb3fbe4ddc106490107dcb7dfd0ac831b44e47b3f246055d979eb26a5692341394367f59e6baac0ca0863fd9f64c4ec415483e4d880606e7404c72bee11cc1529301c788e240e70a6c0b3dfa36d6b684c7dc1745ef8ba5a60be6c25b948325796d619ea68557cf5f935f3ea41afcfae38c4e374facb63175bf547efbc79b38e004b9a6ecd20a0adf2a2f2acefd046be87b728e1cdb1c82fa2a47889f0fd39b93bafda41029f29dd4a992e4bc7d67cb91dcec7a15543b94b8d6c8f7f57ec72a669542b8c01e70461734bcfadc1a5ce20377307c3f0c7b33bc470c41600806a76d81be73ade87d18425c12788a8ac60e8f280d6e4c1a9b4d4f31f9725ffc9d843921bd585c73e1e17ccce692d55ffe09233c375c91db31da763e7ae6745edc2b9add3e4ce3c4b6c6b5fabb3d0a6a04be45ff09753c925a35028176eac7485b9fe351fd05c8ed7596e1b7c20c298ff84cfabeadc89aaed6674eb5284cc12d65aca95917bd49beca50586d7550d649308a8ca34997e56561e75abd0e2851888b8527d8acc62bfe0335626fc75fae52c4c21137c4b2c5c807f9d1bc02ab364bad45736fb9d3faa61600ab002da072783b114cfd9d646087229ce185137922a7566dd63606a1619d6dfc47a0416435c7c721d5bf2e8eb40eeda9b5cc29fd0813b41702fb5998593ea9edefc97e9dfc06532708215d1b0eb4eb7d90b238445e34c9013ab18f6df9792ef8dce1905fca23111635557756bed9235067142d08d4d9fe59d4684fbfb0d0d730cf7b4234a648c569ae8b6448680e34371d1dab1b7a2f211a2227a341f39fb16285a4199cd018a4f7db1fc6ce45ffd884aae35cfa2cdf646cfe21cd8120feccefb3fb5dd4b9bdb26210ccdf353a296d4b449cb0bca234e982326d083dfb8edfd3345014d07c8ab5985074ec52700120797e94e04acf8021864f4e1ec40453c93ca3cf6f2444f255b05a951ff35d2e3d1f1639dcb8166685355a463228d661ce50fe82cc513e70afdc2cdacd3b3ec339b43eaec46bce5713db892239ad13cd75e8ca231524b8515e9cd080a0b3b2e9f48619dbf5ca5c701c668ac749f19cbe47ec1c238e46ae80df262cf9deeae18a80355cba50e2b9645902c7747f08dd0d087b35b5e467962d9ae1671023ffb83c90a5589a2a8fa3e92f451cce0e06201d340252d5c93b52956b86efe7f90c69a8c2233e9f0f3d3120da6a5d2835994d2cc6af958e4815917b77d67a2afa10aa74f811a43923e3924a04e20679beb7299917129ce2e84ee1bb7399213e910b19fe374fcd14724e1318b54dbb867967504b0580b8bdc369eeff1ff33f4e4599f1d82aec6dbeab2b1653a39168fb0e78b708cff5fc76ed54b535de971bec6c8f2b19986aadcec6806dd926c0e51af5e164aaf9ec19fb8831b58090e0a8f9fc73a8e0d02369440d24641b9ecd6cd41a2d2f49821fca9979d9f2fc0f063148029da0cfb155e0bbbc23e6599f7daee9263c2bb002108d19f671fb5a0f65e8924879a956e1439d22262a3b44be29d8cd0c7ae3f9d6ee048b31aeebfc8de93974c3243057dbd07a7af196c19f9405f4ff0b7b8a282bb231fe0daac46222cb868867c72928093b531ca417d16ee1f4c535a48da8c83b397ac39e20315e55b591a690eccf41c5931e95b35edcfc0167016271239be979af78f4eb548464923e19b5666882aaf729ddb9166add9c8e645c72764e3e4a9cfed415314bce9e1c96ce1132e76f4ce6ddb915092294510348270019c8bf952cb92ba2abaa6705e23f845b8a40eddea88a634ad9e9b7a5b3174806124ca17a50c63ee55291405519616d1a6fc90c90aed732d5fe6f66979cbe3b56c6370aed5e77f76f59a88c8273ff06fbd3b717e26184db847e649da76e0699906def9496a3801443196911500e1874a51f004ed6088150920cb20562189d5e6c0ceb560f8162ba0b417ca7a8dd9134c9923911cfdfed4175589c0e6cd3c7f6cccecad2a44a4016dd3da5a42840aa42a6dda8c7543874e64f6372073e757593a18632cf13f1fa43ab7db26cfc1b81d68cef0e6322c00ffbb08a3cecd5c2d69293556b4b53fb015cb1ca9d176492938e140113ac684a776003e62854f15bf3f409b125b094b4dcbca5d85296079197bbe892d40919990912257266def350a52354df015eb0bcf96f48b2080353194f66f541cebee186a3854139b83d062c0dc29479e9835971455ddc8676e5e9f542535acbef542eb73d54c2ad45af5b834876e31eb006027088d16129687114dadc74fe58435313fdfc328bdd72675a95ab0ef76a6bae3d024f19f89961aed5d5b7e5231e168221c64ec04c0813748da2fcbf7993b55982efe6fe431b60203673cd0ffe8ba6d5d546754ec8da511de4bb0cfb5354feda8a8ec19a50d071d9feb040012a16ef6dda75e9aa89c7ce5435b060b5a69eacda96d7a2822e906894b20abf97327b23848ceeadb79f7c67c2e5258a319c583a4828fea142896e3aaf0d80135c675d580e023dfa486c73dfcad6278086a424b4901bf3f8ed2f34ea9eee82450a69732e9344bdf15e8e9b0fc9ccd961dca95e79bf6ddd64d143492c8b206baa327446cba7ca6b4f2ae29a573892cbda13c7417b15ea915e270eaa38127ef3176eee696262358b23eca4b0747ed294d8c76b9644f2efd823b2d70c0e787d1691dc93c2c164955664b26bfe77a6719f6464d28682eef18a60905eab6e7ed3de7fd32d76c942ef749be50702b8d837e4d8ce448dc49b377c2a2495b37ca3319e4cd596e703491aed1600b6ef147e56bd716408474dfc051e5d30bf9deaa634ed9da1764ba1087056be599aed0f01de6294c47b63b12a23e1aeee1c2f2ce85b548c73c293bff0c59abdf1d928e0024c87652cab0d55f8f65965972cb0de054c3ef462c8868eb765185eb7858305e35b358a7814b947f403d03dbc072ae6eb98cbf2ec96196af390996242d4360cb331a117c582417278f65e0593575955b72581bccf1e108f921e3398a91e0cf639bb73799a5ceac86869f02076831d1e661fa5a9affa832e3fc947ab110b204ac2d88acfa65c032e420468a32f87d5cc8df39d735ed85c42893637a8e3efa46a578c46b6c7b85e88156cd636610a26fc75a9288787189d56aa5961c19ff6a20910f5c735bed98ccaf3c8acab33dbbb2b9a8eb58a97e64fa44af9d51c291fe75683bdce59700da437f7905025ad38d44f5d20299f69b047e52a2b7fdb976c049195f83bb9b093aac1cc0d4d2155e66aff1bad78f7a059f739da91b053d7e87da730bffcef608cdb23b3ecc0f7f153ece25c40fd295c8fb97519958312c868fa60dbc592e1fb3485ecc93c300ec0d81d384831d29b51d65f1b3acd6837f4dc2ae1561a3fe11883211e581e5a3f8570b6f35d7e9727c589465368b3062ce875cdf45c09f794508ff226d6c6f20044a66d0e24405e9ee3ad40b2ea96235c0c6c55e1deca3286fc7a6e3fca2d876026aad3fcfd54f819e1f527cd729a5f7e8d01d87fd26efe57fbbad7f5a9ba1af119723bff45ec33acca1ce5b0c6ce56e1612a52e07ad21f81e8b5df806e64d0dd6decbc0b1a2453d2a2c4ae35b10e6cf6bde76a56afc212958def18b57e1a12283bf65cd4b39e52445d8aa1d162b436088866bd20e73fb5956876a2907e87310ed0d857f619444f456620c7d6df57b1a2fe21695a52e99888240b5ebf51d1e0d90ea9cc4bf31208f64e77c69c35d8cfc486efa5fad42f2ad46c36dfcbef0a45d9c9b24a726e3b9bebddcb3ea582e3ddab430e82c045a56b71647f963517656d615f87a392ac4e3d823bcd88727885c87073bcf1bf25f2a4c04ef4247b18d8e57f7365f16c54de74743643c447334f7e9465b57409cc5b804c9ebf3754d7f97aabac091863e285fd386626b1a64908aa4c7c0c9b63e022a26ac2ea517b281991fed4079ee1286d0a45fa13e8d07b7345e8b9d9ef74e7e845eef1072ba0f3945885768e5d3c7a2920f59bf25063eea86c874ec07f802f0bfca5a540190a95db30655f25433923e66a2c3120e035ba11e9d0dd32bfc907de3b9d711c72fbc8258cb1e1f7d432d6e8f08bec54d495ba6a58f369e6d579154ee461b664a25448c4676935c30168e4aa564cc87f48113c5308017ca3e48e812828d65db83133d6a02a5b5edc9373fbf65a3470ec89d5ff1f9084b50c25e74922cd65d4c57dd5e22a7327d236bc31605ac2e6813b052f8082038b6b5ab7b1f9e3e62bd4b744b297c0a1d2b857256a622c1b83c689ff7004079bb489cdba1fe0fc364c06f80f9e0f4974da048504cd847f2427041fcc0da0af410a197cbe021617dc47e1f0cc2b76183810ba2e957a632d17839a1af9c3761758d1d1e8d94e52b5bc70fabd70db3b4248a8929a3c061d5c58acb4a885d6c62b3ce7c0d35b8eb2541c47a5f79b95e860e3b9fdd6aa097058d606ae9278cc31c3211388bcbd27c1d115eb3d3d6e3e086cab7514b65b4ad2e49d03ff254a7d16a447f5b279d6ee12a6cf94cd7e5a889e66f24183afdb1d70e52f25c7f93ac1b61fb8ff52cd34802aa00e7add700cfaee18ba17f6ca71388103fa4dc63981d043c7bdf7550f91faeba9382c1e864bd8ac04d5a883cfd60190670b5e579bc6dfd84db5d3ae57cadcb41db1f8a7c316a4b6c9e283a8584c283756026138d74706cf350bbe99971a25cbb7c0338f63dd6df0b019cea3afdf723863717739fd04180a6f0ad4ef2085734b0b5695c11751bc370e6701a49ae588815cab9fae20901f525148d17e418f3453bed46ceba6b69f3ee56475ecc6bc99ca0bbf5a9f4f830db0f1ece5b5aa7c402d2d1f6e82ff5561ba277e81c5d84b8f67c6b0e59ffdb23576b3b9cdc2ec204ae240a1bf7ccd4250104e3c94f38443ccc4aff17ec3d402f01e3b1c6fcfb3fd350ffdf185bbcefa7ba2b7b04aaa7cefa4fb9190874809f4c05d007ebb80c5de7e82de28d96ddf2d4338afcdab75176aa45f7eedfe74ff71600bb6843cac7fe46a3ae45cde88c8ca0d9e3e4047cb510e1cb2395e4c03be162fbc06d6169959b6cfc1c5fffad39db81dca837480c6f1b8a2bf43a41fc9934f39edd5bba6c94ae212fb6b8ec14aba0375d856205260ee2c37a34780ad3fa8ea4d3da99e25cc5c019fc1acf4f9b17d3856a7d627be42df755dbe5e09bcafa774bb28046323bd35d35537223077e34f77776b5f3585115a3e0e9f06e7fdac79dac3839c41a3e739c01524e5299a50fc195409099620ea67cafdd869eaaa58c1f4816bd5e058f350eadaee7657f8f745f17eb5c8c7dbe0c7d63ccb07a7bcdbe2ef961065e84e571a624b1790426573c08cb3be33a51929c08ff481103701d20211c9d34466302e1fc95747249a696ceef5efe99b36dc9e27bf529215381e4fbf9628054042063b428e6dbd0e69353798cc158a92e55dc6703d6e8c548aa18abb4d958009b9faef4b0b46011413340536cf3536402f724f8d82ad00ad0af0c617f0407bb9bda24aa890ea15335b3508cf653fb4bde074fdbac3fcb97c3fda1f5e86c9e812b4ce3d74b102e18a662c30bf5697b45bdf57b6ed8418fa91bb59369d89c0bffd7b595270422a2d8a497e71de090a1da025015ca1b6d2c110a9b767a4d19d6ac0b115b097d1fcae2df89c47b8a6651843152d6237026bdd45056da5dc38cf1694d4692bac97637f2a674994fc037909486380e0b58277abf5b02a7a30d5e48043b398fdaefe16badd6eb8131d650a0e3afeffdd3e8852f650041872212d4ad145f08ba2ca45bdf86f813c600f64e1ed95128a78387e7a089fc72acf79897627ce8cf0a84fde4805ed2b9fe4e8a4fb365e5f70704f6c1bcaf2a109217e014fe6c193bbab420affe838cb8360b286a9c43dd93c8b63997e54129b4b1ad99e6e092b3a3834b6838f6801d369aa2c716a8114b26b020f26566f5c3d245942dafc7a5c8f930bb4a7db0b45a0782a05959cbb056c3afc1da6952a00cd21a139ad60d882444eb6ffe9c29bcf49fd6247f062488c2526fcca733642843702da31d6105095df1635959c830c5dbe821988a46d0069d728667296b3351aef8773534ffa64b432c2bfb0353a80c422382a49519e8327d69ab84bb65011efaff3e39c42334f4a81b953038e786322ba648ce67525f73867615f3b0c51750e1d52022492b5bbc2218dcdbe5e2fd1b90201d0aee5113d66e7c6ee6ae87e55c5451dabce136abe23182e72b6ca71da2e4b5e09621de5bb674471590d5241c0f980231f3bfb3510141940133212c7b0210431e2434a49bc1817b25d72ba02257459cbcaa58f0f0e9fc02ed4d0ba4f35c7bd664bd8a6271789888825aeb04a77f034fca87f3522589e7c223c908e05225d79d19e9aecba4e1a1b1f5357934b82402c04f5892c9ae845838add9e62bbc6144fc0a2671202190c7bdf408032f2661ab941f959d50435bf82618b93e297ab3a5fed0556b4c410fb31339a2fb5c363f02ee5290bee5a8e744433623aff9c7816af592133bf2742a8a8efcf19092d44aa6e4316c0dd5b6a46ba1ccb9453b01d2fff7157aeb27048d7715cb436c0fe87e63b56e1c6a0153889564501dcd33e0cf39af7cced59adfad0acb3beac5af8480edcc3ac00140f9cb09dcc68ecefb4e4289c4d59ca6215c2c0cd2ffd03a30ad1c081bc0c9dfb89aafd5041d299d8af5ad8fd34684aff03b572b56c09fde47941ffee25e60fc0ae1404222baf968b8851030f0074dd1a18ee1c2ebc9aebb77a6c487762f463e756e54869b68edcbb59cf24daf013a0d92130d8b84060dc8d6ea08417ea923e9efdc06b25c79cff7f2d0ad80ce4e25ec80a425b343082835ea4fed5285b52ed17ec0f2f03e379d9e7e4a933941dad1d9e20d34c551ff0390d16531ffafbe787158b51612235e1b3a71da4fcb824fde85bb37ae6b855c527b1b46667a69c5508374769c160747b1ede6972b9eb41821fce0bf1556bf132ac38b82fb5719158be83ed243b4e11fdf089b1a88f32dfe5dc849849bb5a5760594985115f422fa6cb1706787cdd06a47615110d8e40a5793c775196fbd7adef39cdc206eba92cf126a453720e810ad4add48e54ebcc2bfccd7e141002a18e55095a12d3df2d187e5b6f6dff56ea4a7c4ed2c386a7973122143bf7a214363acc2d05631ced09813263d01dc7aab1118bc917a8a03a0f4c8046ea44ca66432ef03c489e83bc2ef458d8932cfc2ff8cfd72f3218511f68f92ada06b85d2e3ab0c8b4ed8ae0f4f47c93ddcb527c28ce360c35abf79f7268fd6e863b71a500e6a03d5855b1b1f333465a24c27f8dcf8d55921f8baef2fabc9bb09e4fa88bdfa0dfba0d92d936dcd57d917ab4e6dfad65d602b48d3632e0dd627db952e9f3b2cb17cd189e42238151aa1aa682aea854388140ea8c014b25e337178aeb2c76f23f39bc61540f63cc9f2146430f57a7b589bbd9db23540a795520309feb8cf944d3e9d297b27423ed09b8fb56f647bc9ae9b7ea2a8daaaaa85a8d9fa902bb3ea53ee87c9361814c4163d9bc087ed9c64d7aa3c7f4d012bfb2fac7461803e9b620e7e6269e6ead211427a5f74041962c0f77f6c98fe87117f2273c8992363e9c05208ab45520dcaa44f3722427cb75a9f9fbe34c257c495a2b865228812190366267433eea06843b72ed2142f7d9cd7063a472e162bb1566451dfdc3eee1497bb88d928da4fb7e8c7b51134dc019d36e7abd51711964598f80927dbcf6fa92df4530cab1146536d35aa2e50d9279c521e9ce7c35f7ec7009467b078863384674d8b93a5e18a929340fb3cdc17e1e0b614c505bc5ee9af15d88ba85bec7e5f9dc0ca01dbd51959c18a067fe13b53ea4edd7ca978afe56730f898208dd66fb2ff1242ce1b43a8e7512c82950b42d7f2eae97edbc41b2ed33d855dabd1894e668109b0937765cc097147abd058eed028c37fd977d4cab9aaa24689a0532ccd025df11bfed82cadbb8e30c828e11ec2288b3ca5b6031187876231c3ad2e48a1680c9dccb6cc121baa62d3e647e9626839b80c129043a2f3fef6ef051a5e1200b25a96de5ea81bc796da87157466da5276be9f0297621f1bbba53ec306796f09e7589b9d318387d7041e21d583774d616fda6430e565e6883715c53f67aab51509efdaeae3f51bb6208d6cc313d51b83a58cdfe476309c49c750499737153c3c1ab71f29f58daa770ecc2171035c083d60bdbb13122807e95749c08ceb0ad7e4bd3fde5b37cdb023cfa0882a346c6db5604dd381a6523d7d91aba444585179ea3e07a663b2e982dbfd889b3609cf527f07fb74de935f1098e436bd4f0d455f3da1d4398ccf871836cf88ac1869d2e17b152c8e05ef8e6d5ecbb1dc7cbb5da62a024b310185b60828ff65988cb8d1db9c5661c0fd97ab4d61ca60cc2f1e54ded74d5b2b72b9ea71e636b9b21acdd21994d17362d055a3365ed169c6dee9488dcc3afb5686de8cec6e33579848af3e6224ef98057003d6f0944d307bfcdaf2031c102d40b36a9390d27f6b05bbc141573c96f182033b3f15c0aba25214da266cff5ffadcf2707b94c8e9c56191876fa5d36fe0ccc6ae2d39ec85507684fd78f119ac70cf67f30cddb9563c7113ffd5d0fae7a95ff7910e3ddf9ae6a677e4f701ae3939ee535ca880ae3e9cd44a55263a72b1365c3787746574d30c5c01a701f5c19f72fc713d9c538a1244e80626cfb8b0d69dcf5cc701520a06d0053d273279a11a5d4acd2a9bd13867cf7e6b649018fc8c3f34f597099c0abfb880bb767d799a46f0de0dfd2294b5406274be16b7abd14e83ba22b32e83fe12ba039cc10995a4436c966d272c8ec703c98a209389fefef2c88b6bf5bbdd2ff3d10fe71bf353c05936170dbede5f8f0e739197bd7c1cc1cf7081ef865dcc3a1d2d5bd9679b5a4f5498e12ba4f997ac7a12f0805f9f454a93b2794c2fad381e8a4b981adfff3ec0b9e4a88909df912d12e3b7abd2a940fa3921dfaf6e819e48fa3979cd3a23711bcb97e6a7859b01746026b30c1e8a35a52d2d63fe7a7a2da7417fd4b5bf65567cddc932f1c3d67cfb306fb7690460c44c83e4ca7df47b856e4f7d2d7c39bdeed1e82a88a12e5f985a27a1239d7990fdeaaa3e3ff5b193a5738667a30c7770465a30fd1133607aaf5f4aa4baba9c62370d24be08bf67e1ca7b6c1b7f12634d9958e4f81fbd61b7f6bd9b7dd2d2addf927186a31106c75a247557c5774591b67f4d8d0265cdd3acf62b6f273a393aa88f80cf3ae3aba3901254092ff0ab55af3a81f8910a03ce708aeed3e4bcd712fd11c0beb3a1a1cbec778310ef7898508b53cfe7a4147f5ac36e1ecf655f140a337269bd1d2893be04142f5309c7dc706a10c54fdd5e2c8da2838294b6a7df76673d570753865dc9279be4e6d7897ef94e4fdb6a64ba32ead5f1f00b567b18e7f4befacf977d44d19965f6f8d2d05dc83cb6e152d53820a36bb4c8c219a92197b1984694c39ef45727d773f8dddb2bca5ea7c0a2b8249aed493a956fb15289802148c02b541edd058dc972085a0b034f351d958a2390e05544ec49c9ddb99f844e4547e64abe2e245d9bd0d6163c307cc4f11a4e33d3e3f3d4beda407e9d0c1eea235dc0184e1e90de032261b16b88143f0264d758c3b7fa3699efebbe84a6313d14ac8f3a6a63f57ecbd858800e852821ee95e9f2f3710a453cf7cdb569032501a5db2364b5ae68a12f7c362763c7267c4abe60a2a0437f120ac77f4ff141b55d54aa578b52d0e40f1d3fc28f3e3d9a4d6ef09599dd165e0a7737bb2d7a83a844cff5139ba3b6fc4aeb531005df63623365f535da4ec3c745799ecec228f5f499d71b7213935305216569be8bf794690ebd2e31278bc78c29f7339336971ab887c76f88807626982a8a49a9fd8332a02ea4582f843ef813547096f382a2d3ac21c1205e874254a01227b6d9ea672616a01cb5f6122a76724edd69d01b65872382509ab4b8058daa33c930781496d7ac5152d64e9ddfd0d475829a733bf68d813810df9c69fe75b81d19670203ceb2effc430660629fb77014dd7cb89f7cdda41bdae687cace4be4a4b76bb0079cf2db09a121f2b27cd948d92da7b381489801e8abcb125f15ad07abc21f2dd99aafb923b9e279ad22646b8ead4bc6673448b6cc89d2a8e20ddc6ecb619f8c8ad713c98bf1e393565c02453b48df5d1612f20c9acf595e46451968174129fed2c4240e6244a4d9e143477bf02a64ff791a2922c978b06c2a8cc1264d2894be7e96d3618dc4f1ed6f72f275c4b08b62f1bc26b9852251e6634c0a21ec61b67f21b0c2145ae9a7fb7d61377dbbf9e718a8df1ae3c8554e0a39963dda67527847eac9e6418db3f9097145b15e5ff2619f72936e57dd86a0b28905e98ea623e44da4c7e7693559044e1468cb51fd46c75153a121072456ca064184eaa5860a525631fb29b561baf5426d605d9dbaf81df9ea8eecda9c4bbef8f8401b7cc90d4dfb84dc6c3c612f7699f8f3efb0f65209698d54484e88f72ef1d68ac4cdbf03fadf9dd4dcf88f2aa066642898103edd5e354523d4a844bcf310873626df49f46cb716beb2d8f2c1ad661f83e36b11deaab3817e28185805e7429073f9cc3f6f752a26f4f531c49e7a264b248f3ce0d60e79f100659ccda7131a83f100543b8b04326d00b7f6b89ba4949d4b725617bf72774e509e8c06601f8f873765a16d88e9d232171d99f5c34235899e12fc5ae7866b7a0a7870fe35bb161d018a720d996acf053c3deae609af29c9e1322c2d7f502d475f1169de8af6f5e3c5b9906f61857a9fa287a454f286b4d674bc612055b2fdf20ddf0886691995e9a3b94f9904934d9b44dd31a7829330bd1305cb80bbb852b8a0e3ebe94aaa8a6c44caf456139ad89ea91a399d6ddc29e70ac5bbcd1d766a3696145f98a64929c0d9b60a04949b792fb1b9046bd1a2c5270fd9aec7bf0f1327e10c1fb32958fa7c56de2b16a14ed87ac86cc0ac35c9729f3fa5ece0dc6dc63e3917de48a1b6de23c2d1e804d58c8e186a564c25f182cbe8526612134b130ed262269d286ae80fe1b16089c1fcc875809c434a5b947fa0bc40aec98757074e783e0656ddcfc962024a341a5730cf1b5e049c3f643f031a1fc226f0dd322dfa37c1887bd465cb5193a8c73b693c16b524d045041a67f64b39d7bacfd001a440c435064fdba3cbfcf160d79a1e996763b4bf32297142191b154984818eafd0066e9e25e7bbd014b87527d9934da1d07d86d0b0360f68dad351f9c94b174d5194c3adcf14b4f11fd6e61398eb58df752799de72b605d7a946cfd1f0616afa47e9a75a072e5f5b32e45fe383ce6d8553ae8c75634f483975180d96b133269c0f697273f5498ec55f72a86098831ac818095d3a974b28c2b0ed9520032d65500cb11567752b4e1a8dbb6d79e5b50a401d0df2900a540fe58590da8661bb383e9bee796791ab8c0dffbb21d1cc3649ce3959fb6beb78862734f1da9d8167918b03690788d68be4c2fd00170b1b112b270a51152017c32bab25f93c9c8cea0bb610e607ff5666710e131aa6619e33acb5e3b6c45df7635cedc057581383e2f984c8e61c6bffe2836a8253ae8e06e204482858765160e0355f05da7b62bb6a934c9300e22a63dba4b29143096940fc11423ae121680c68e2ef874d116dbd631750ceaf3b416f0d62643cab93e94c62673465902804a676aaec8c36a8e915dec851977fcb440a330a8c91df012d6366f29988ce98b997f6955ffb2478ab6cbf66f77fa71ed292e31ca57f66769189cbcdc7814d75b7ea98fb8210ee25122f4288073093a5a4a34a4efff4db2365d55f3dbfddb8f3332596eed9005e5880624dd7e88d37aab48899d81c0bcd6d34d567dde18fca45a3f7a1e06728afc32de99f119e86b5e6febd6b6d718eddbd26a2ee44476e54d21fd948a64f856945f5b215db601095d12274cf303edbe5607cf4e072a09a8809e0e99b8debf6893b9460eb2e72a18d8d190d112e66fa4ac7a921517fa3fb95f2215497cf84e169d20eb1269a5787207bf4bcd0532fe8b1e745187b5c7549475bfa884f79383f9c1c3ca09f019a9200bb7ea21e7c60c291cc822d7e630687943e0c48f55cb9eb99f7cd249d727f6789642a44fd0801dd3139e65094d4bef19e6f649742f2eb6b1ff5abb08933d719163307ba3ec4cb1910aa59580f6e293e3d1c27016c92152c623bb7a2e926177600b4165f2e1af455a54aea1345b85de5ec16b39bb32ea6048f0ef8c034aaec29e21199c7fd0a6b940199111424bbf2f4728f1189c3c5086628441b1def73f7034f56a03cd5aafd8d636275521c19e776415c4944d177ce9b05ea10fda32ac6d27d205508c377a0677044234dd13da5611b940bf6b041f6c04b86e993835a107390f12ea5967c97cc865de04b8fbefab15df78f7590f42e9389111d67cbae3edd09f52faaa068c34bac87286ffe7b922280cb3719695a887dc06017dc972f1b3f1a52369e5bf787765579b60bd36f14f35eda01188847cf3c28ca129f22baa4ae1001119fa9e86d4d2b404c306ce9ed198a48202565257cf9bd775f31d24211b63bdf096ac29f28fbf33a49bcb22209b07d2423181777133fd69aee9fa59c260e150ca1ea1812d6f673e50110834f6221491bed1028eede95c23f7b9491aad005b939f51a4f21006b3e41921b5a7a5645ca6f38491e923551d8f85fd229bfce6d2efcabe1e1fd39ab90379452bbbacec97126d7e332befea0c0301fe0c3de802cb53e5f2aae691cd5da73ac57fa8044331daa69ce0ff577c41cdc7d3b37587c320cb655c075393b6558b15cca7df42e9e86bb340570cda41d9ae8b47844def50617aff1780de0dc6268f6135a2f256ef09f1312cb165cc92f64f7edc539ea924d8aa94ba0cf05007864a0ab799128802098e8b6b1725b6ac13edac75a2dbb39bf4c1b4c92111bc0affa23be48c4757bd260ba9f090bbe2a47c3fb89d1b4cff866c66f4868d90fc11e818f83393888cd514f5fbf367ddff2665b9109e4eb5fc2eecb24c1317f719a72b9c4cd4dc3ed95ed59e7d20e7d5878ddbaa79688562b5d671d1731e42fc22b839236732c4b55f2ad16f6a506b83271e72e4e2d7df95d18b85c4acdb1eb6c55cd1a1758653c4f68702c723d1bccac7a011465e1bd39f80a0bad940561f0a7b5e8012bafb9ec3d15d2c266b37fdd7eddd931ef47269cffa5659d8047f6ccaff12d92561953a3185e60a0988e96f816fd79bd2e94a829f6ec61ff58fc9c3dcfbbae219e9560da5f1ac5df4fc29e37e939c8a62e06650363357f0abee6a2fef13180578c04f6ea456ed24fe905411beb6a4a241e94589d58cac32145da2ee26261c98994d8e3c2c2a6d6bf25292bdd6c67bad4a9dc3b2912ed27229afa2cc6342245e9a0a05b3ba210c5ddab924b42326ee86d0afe04da5931dc2cb6c8d8d32ef2ad8e547213fe723e52ca14f4b62988925dac3fc696f20de0e0966161f4326dd6a09547abe9fa93b3a4d9018a12c2bcf95ed72d6e989cb884218e8f45fe8f1fd4f3fe060de0ca234c6ecb251ff0250c8b3bf05a94545bc3c894ddfd31ffa321f6ff82e6bb30cd216673fce1ee413fc73f9dce3980973b71e2bfc35b2c933634499d3b2de7a405a93e3b27bd1cf2fbd5059a1a175054e1b0ba3a24cc213716d200e4fcb53414cfc06969001e08de170e5bffade06d61286d71bc23c203eddf8dfb4746a8bd1e6bad0a5b8a87d9bcf76f76925fd5a79baf9d3878b9d11d543b5ecaf90077319ec53fd1b062abe19c50be01436da68bb24458683bc89324a48a75476a8a4ec4881d536aca941c9f0664ea3871d431b7ef2f7abd54a2cf08c75f31a6fb94df838e54e45f61c2883da0e3cfb9afceb76c92c840e1ca1f1cbba4d73e2cb471e19a08f8b8160309c901bf43a8f92dc0288ee871987d4da5dd5350ef07375418bf593f9d362919aba4009f130decd3f181b12168bfd2a710e9739060e56b67c090d35d95a0d48d2c7b62f3432f96073d402573401828fe3d4e6bc1affe19ed47aacdf686591ccff91573150bdfc80069a74cee65da9fb422bce363144b43f4a037354596a93d71791bc107621eab47c73e3e9053d640c4c2fdbddd07d61a809cc42bc4d8135a181ab3432aa799abb031aa63654a4cb32e603ea9720be55269591dc1ab85d82f8853ad511f7a6141b5d5ff0c3358267163c64fa6ca9d85c61f8353eeabf754b819812969b4d904e1054ad9adc624f5c740b3fbed5b53804cf5b920e5d5384b88bffb5d359454d032bc8188497b30674fbc9016c1167d836fb7a1d1eef7bd4a735c82841854c37608d09d5f8869a758bb73aab84f66336eaf6f4842196d5fa93dd774e3d408f23f4f6b1f2af006afd1fc18888319fa9baa31b7051746d855cfd9c1d7f14e388b9148fcf327dc3bfec21b0f9351c88dc70dfc3170e809621039d30771abed666db243a3d7d4af4b13b79048f35fe68c3fcfc723fb6f96d99724de62ae645d36fe2a83e9c650ee4e1da4827889c89c5ffaf5a7a74ff3216947a9b057e9f0f6f27da9b79529d5a1232ab52aea36ebc051dbd0fe02278eb0ef0f8fee71730dc9aa4a68f7a08fb35091762afb140f673974dbe85c34f2c126c3e5d04d128e6fcdf25515105ec05c59081e6cb41b302d77bc3afefb44aeb586458214030c340f8bad4c9450f5501b9d795ee1565852995d533ce4d0402244ae0504c9365e7eb3f1e70c4c88c6e1c254e158e4f9c00bf2555695cbb39dc8c0d6edbabe0f9b61b68ac65e81d662587d3c39e92cd5874f1186dffbaf2a60964bd05b2aca3ad60c28326691893878ac712c104cd7c9d07fac5fcf961c8d1023803dd2fdf09ff286766c7d7fd43b613e6ce585528367fe1830742fe60de542751cdcb35ca3f69dd8ef236b78e923b6b4e3af8ad4fad605128b8744817f4b16d7f0c59a50c7f06bd2c999619b6b5799a0621d117e03abc8d81934bf3f7b2ac4882c31008e4e2d76be050cc973b9113e97ee151c7c64e720515a9ac06c7ed499f5caba6821da30d28648a9050c09a785d9e557d18ca32491886545e7de0abbe6d13c713856fcb0c6c7db93d7be707b544380714ae56d8aaea656b62957e24d944bb4b77a9122cab3e474a326db5ec13d3753e214a187cb66b4eb07cacc8e729f888d42ca9e81799f2be80eed5442aa17e16ebd347b45f36a8e75c6bcdf84a8bdf97902fc02befc68e88d87e1ec189ead1c655719858f606c1109309a594ce95464c529934cd25029ad75800903335db7549ebce93e07d0a1a919e333c5da0db54e91547977dcf64685ea92bc5a6d385c372ff94720ba99b246ce2bdf75ba6a0abe03d3f761d0b01ded517022956492b3f050018a28c85f09aa1de648357d4b5ba7d0935a5bee261d7fa3bb779186c924b7ac17707d6ed076b4f79fdc44f2863540898571c8db45e8048b2c9b115bdb78c72a0ddfc059ab783e63b8a20f13d47024671e6e1d58a41857832b79829cccd1355bd301180e05a7ffc98db319e6d26f9deec09f47ed2058322678280508a89dcfd0ccca13ab907adff63bf04b3269d4ac692b197be45a4e67f1a82093a4d9e661c9d098fa45f7bdc59bbbe74fecf199218c7ea648f473dbc217ce6f806e1d92876f724093b074feb7686dd8d876468eaaaa084aec83b101f23f0f214b897e0ada425a4bb9be68c6ca17ab215db670b79bd6e241d33fbdee54566f61a5a47518d1eac4a38886fdad6887b6638bb4855969387436f1dcc83218b242d2cd794187e4f858f865e6e0b6190faec668abd45206ad64c27aa4775005a8cde561019590bdc75d144af288f4c3b64d543d1aadc8e0cb94449471dfbf35d38f53120f24bf5c4929c7cae7f1d7ae794a3b8cba42c7461c9e42d8582c7864b1c2cf7e09bde7c57c1f0169dcfa817f872a00b01418a922e4ff3445dfd761249b4f8934a28c8e858a9ef02ba9a2123deedbf5c751e5d1c9cf771784565065b729134cda50c89247033d2e73985877091b3e82bf4c279e0e67193128d36f655739bdbedc03cb248bbef81a706da1c19f93fab8a594cfebc6ce454923f182a4452d4843dffcfd576a7902c8d9fb738b0aa394312fd13990b78904874f23aae5ecb39d48fd09ef91780be4235c1ce38f13390bb6f1ba2dd9159f7d45853b1a5f74e442775d3f3a7dfb773e2c3c2150a3dad54f2832240026c1db8cbeefa1dd8338ff6a55987e7dbe47f2024f193ad32c17323575f8e990baa0fdea0aa705132d69aaa71fcd6e468e646de1f0047bc78329ea874b46cf16c329b73c0a9ee0f45f72d89f90024746551ceea9bd3e49eb4774bb08d9f5759fe51116e5217a7e28aaae55802599fe4393d0a7528594fbd6c646668fba2ea196474f970bd7fec922e56ad5f3c17bfc9bf38877dfb5ce3ec2e66de942c7e5b7c1d249663f3527f4a60a226504120edff1c22eeb33dda484f986f1db99756bcedf25c1fe76ec7fbb68282e2ba118ed36c9d6e5d76ecc465f94010c3c5d2d5a704bcd454a00256a6d861d588ead4e4c4e8225b11cac1b02c0cd2783a13eb9540802de0b0f2deb3d13ad3ab787a211c9968c173b12635decec6f0879c386789728a30222b2fe89a1e9f0208465b81551cd1170f1aa05439d2a64952d9660a11cc491fb8cfc684d033f7757448fdbf440345ed2ff1ccadaa13bcdc153847f9193e3ce064bf3525ead8d25694c6ea12c5f76547c727ba0653585bf887b9955f39af20efdfec621765330099db1ee9e409c26bfaaade9167947c0fcf448cea99d12a442243fe853b0beaf35851c881c6c3f2b1fbc39a07b2095764d3881890ff05dc32c659caa25e357cdada2b76ae0856fa8612341968a4b8d2154f8690c7d578de559cfffcd7e7030a585c62c7a3a79eb5d9b5bcc8ccecb3bfd16d2f24847ed4269b52eb3d389c94243366c0459da6b997efd5a44b1866cd4e39f1910cc73421dc6e507d0148e96c705a031a2ca42b6eead4a63da922228e119afaa49c951096e68cd5fb9a7c0aa9006fe2751f4dcfce9138bb39533fbd0218357a9b437dd7b6653bc797c0cdd4073cfdc0b603d088ab2787ce5155399920dcec7d6b48b094ca161e2f8954aef214c64bd8e746f0544aeb30f4c97dd31832281afcc76ccc571e77ce954d314bfb425c85c883256314804e3ea6ff9123f95e0484f7abfb80ceddf6962ab2705e0b6edda5fec75064bdbd004fcb878ac63aa7b68b493b80fe9e696ebcf0683f727b518fab92b54216de08524b0a7469a7ee07f2364c561f16b4e52fdbc204155984c25f4564985dadef544a3dbee7f74d259127127cebe371a2b90cbdaea4f5d7d6fcfba7d4956a883d4b2f50b6c6984a8cb606923d573209000eab6a9fd20ee9da0ba102159528858b7a9175a6f148e31841dcaec6845b95ff45eff6aff9211ea293933ba512b4f82b7985c5ba77670ed3edf5cfdcf61241d00afaded5f140e587854ceda3f09f7744d78d63fd508b6f949bc28fb3c6882d145cb07b32464c016008f831151a1320fdefe19dab29e2bf4b0145a00432ed20028baee9b76a3c4bc425801e31a0637f6868ee32347a860dca80173897fe59b6b680b1e2841c34a98a7cd93500df8031ea529977d54bce906f698c199a35a5eeccbfbd33aed9460c8c7782dde5748f32d982e4b5634e239c56d1fe0b9c69a6a215bc64603ec0a1bfa5c7ca3cb95069867f9e63b0456a1a127d68fb4b8785a525fa1cd441e6374c6cbe407e360317c6f484b00870e7a9a55c9a6e639c64b259a030aebbfbabb504e36037b2961684ada58cac843b891e9aa777c2dd3224b1a6e26febb94912b2ad16ea7f8cb42009ad6802a658c53ade477dfda8b7e5633b4435ab0764b5d04ad26b45b042b9492accaeabde465ddc634d411dead0a81b746552e2f3ea4935a85567a0e85d46ff3eafead48d745cb2b55c7db55d1e6f002f1ca89d51524c03aa0bd73cb2887d18a49a8d05e048f0db4e26b0f4810036668506c0c1c38425a0812148d2d05c8833316e9351239b72ab601b9ab7295d6b623cf53ce0794c3f41bb53221606953cc34d1b35d06ea4435799e4555c3b2aa58e2a4954193c266929b5e7e3278cf8ee6d457ef358508e604621721ad88bf1e4660d7d125804b95d0504ed64e2cb0d753d36d26982070e716b93525a331d6a2ee858f0e8e59fbd60dbf3dbe545584caa2436ab223d0cf60195710dad1b3a1cd9b47779bd52a6723cded2e0e12d0228310a51fee23f5f02e1c5deb3563c323020cf86c27967fdb4009e8bc82dd743e2b1861e7c7b4c4afe19e136c526403c17cf6b798082621018aa4358b23d1f3c26c061f89b2773086a02731995163341f47ec2b7f3d6e098bbd0d6f6a0b80cc48d3db32cdf01c0c1f138d13fd03991d5e00f47333daccc70261fc39d99a2accbb7ee634fea57dbba26b6d944ea6206e4263078115f33efb7d2bd7759b8744b1b09a0d316e070528fc3ad1c76663a035aafb5f1173abcfedaa527535115d0eb6e9df178fd42178496728575f5b0dfde97a92d6473449d18406361fa55328bb91322d71b170de1f3ba6f2c987df22a3bf8f6f0d45b45ffa704a2cf7fe226e71aea1f482627626a16744df8e3f713af8d611de1f98a6171e271b497eb7251ac96b1c757b07b82c4a006d35949d8321971a6ca387d6afd8ae7c78c66dca9447a15b93cf558202fef95b9d3a9a42847b95a076553e3b64558022ed47175fc7a3051629c4b8c669f2b8c971113d96d9329528c01c8b8c4baad323b055a1be8b5f43a325fb9b984f1470eff69065f34996109f2d1c3dbe1c3b08a467da126cac08c8e0b43fd9715b31ce258cd314c2e7b8287c25f4d3d863ec227b7a2fd3f7e2a03019609df32312a4a5f3dbe0a204bc3bfabd1df1517b40bb8939fb0c072e65d7b868a9020aa47aa5ac4e59269f2013301ce4a0ed3394a3459e0a2b05024617cd764e7ab96e2c38559c989fca0167a69d97bacb44a361e6c91fef80920c31d6cef229ce01752ec003c35d29c5e1e002e852e2bfa2232ef82fab524f1e509e00575d38781fc0175fab47e9eb94742510dc651146a48fd8b3a225d5d1f9f089eeaf0b2737a6be9589bcdd94500eb16ddb7219a07aea80e3dbd8e2570088b225d35da2616b8a1aaa92acdb89b9d4daa5a4f31e30e6e9a13ee5695a5def57d3c144ff736159d518f22736fccb9bb86c2c7e30ec7cf1e5e2cadd72312e1af3b4180ab879294ef8f5f3d21b0ab963314d233c80ae50869046d6359f961707614071ef056831815ccacd2cedc731147cf90e448e87155ae897154df6f8fe4d2c9fd250434f3e1158daf65883dd155b09470ef0520a29c2677f128f1b6df92850e8bc2740438c913a3aea74cca39ffb7bbefd25c204b6f9b17de772ef8f4579f84ae1cb868bc938d38f320d9f25548247406a4db66eac7c74e37b514131cb8b6cacb6a13856e63a0c5c32d1f19a6b5ea19a5f4b36fd94cb6d535fc0adcf4e1d4b95fedd8c11cca64adef3dc3c4bd479da4ce35b36712ee3e9ef1b3c244d991195641c140457e95f9efd37872531f11eba934c5c19da36e48ba152cf5a2438ccc7c91cb127dff306ea097dabbaeb5c1c6d9bbdf3a3bafbcf69b2135d2da4d49114662ac02f15f8a4e058a2b4871052d5269b271c2ebaa45398560c057af2dbcc89166903c4a0f1e94f5338915e3393fa02785d924d814a055b089588fb14afdc62fee8be19f2f949479ffd47643ae2f7841aa4b18927f968cec8c5d426a9107c86606e93cc721e6d7ffb389157658264487514d4f7322f70f1488a6fdab82f614d684b807cf07569f00d7c820c3bdbd65c2330f5d4687d7086a005940bd47b2af3f6c57baaf6e535f18501c9f022b5ef2271899f63c54e1917553c0d51d90c53e316ad29755ad8eb946cfbb8d857ec31c278993614d59db06dbc0aaa8ec7db424b0100d03a180304e4f14810ad20f12179dadaf5306eb90e3803749534f3c26b37909a74bb9d3c388ffe3411fa489164299c3c1de5d5b398bbb6095a0d99f4e17a0391686a1b3c7f2e30b29071e7bfa3ff524535e4ee0ad7d0d24d5fb942f455900bba4331b76f9cd86876c1ea43baf8a60324053fcd820a7425dcbd30822e6aa05e8f40c90ecf62cd4152bd86951b23b7a29239f578a7acc0de7ec294e3c6ab0a0b997c46b8dddfde072a8a4677ba3933cc5b0b52a378abcc8f4fcc8bcda7a0538835924e901be29084e88fa58a523bf7baa54e8d4b414351a338cea3f5bc56ee8bc809e1f6258de53940178c74f4bea188f37e2550a356a0a264c3cca6a174b98975dc5f815e83368690b4594536b1a8f4cfc256f230a9974868667859be442f1779388f3e1185aef89adb79d29277a0b986b447fb8748b6eefc4da9dfa440c1677f26b6b999a15499c31fd8c5416a12f0431cb455fc9f4be9b81031fc9afe9cf3527c275349a41883bfb567faca287e3fa8fb6be44931fc49b108fa301d453ac17bdf7b2dbdfa85554d13df7998a76658d8150f8e65c1bb6542ec678186b95c9932b317fbc5c82701eae012044bc390f4989dcc371e29b53a5d3f51af46439990d746be0977dcd53b443ad080a66d8d575722d718eaa0ee645021c592aaa9b90d37135c7c21571aa9e307ed2f24de94219898c7e99efb6c8c1dd1b5facb199fdf74c3868db9a8549d337213216c79a91ffa1cc3eeb29b57fd8a1750d68222eaeb88c71ca94c05d181294f56626aadaf17bd472128a25334e324e427699448e993164bcd5ff40beeea1016ce612f0186b3dc3664d66f1132e32b5c6f63ba22bb50d8237350b61070989a7aec06e6ee73543e7e41d9fc3d26667b2cf606a8d7824aae0954ad86241ad97aa0ded6443e9a25170452085ced9a7f2ca97639b553cf2624a7904015dae519d2e933060a1da318841d9431c8614689efe850ec08f08e432068d059cf490a65b4969951989053d056c63e526f512b9e1716e07f60eee0b7a70dce0f9ca47fe272dec5e258b798ce5184cc3c70488df271b6d61f3a13ac3b4e4eb969dd90f8b60970a7adb9129cb878786c7b1a56072cd3ebd1320da959cfd6474b8a07d4fa35771dd0f5bda7f540700febb639dcde479de3cc5c5c8b99ca111c3f852c479afa4dc3d49f5aa9962a80e27a3e8bc64bded36c179f9cd1d9dad0481c36a23ab66fdfdbd7f353b63cd16bee42ee573c4f89e79ddf6247e8a5747c45a31438e0208b2666e76b9cb1284b3446f18e973824bbb4a5a62f72d51b619e17861960687cde0913a678fcea3697956af4443dcf191d7ec0e6b2b7ec6bfac1a1d940fea26361da3415941f5178abb39d9dcec9aba49c956ca3cf6a80bc2110f9bd34f5f88504179b6c888c953b1afa3187072b4b838ee003da484ef078a6bed0428e49273cdd2b3c135853676009b12a099604774f0c4484040687e79c90c833a3bec408543ae1b225fe358f6089bcdbc1a4d078ebf49fcc02affd3a5bc5e90b6041305d47329cee678f097fd5b3758822dd23a5701ce49d893120ffb31a7fb8c507a8fa8493ad709f6ab3148dba61a6bbe2eb4d2e20eb663b98e9cb6c22161a99bad0bbdfe36a4d8a74bb88bcbc185cfe1f5f07465296b2c0a49812399e8bddaf5f1024db5f6ff3e0e4e70935e65232420cac42cdff7b8499dc9e2a77e4b1500a49922c18f1f121fc48cb4730cd151164b67309487e69a94493b82fd600a3cbde13314f2e625b33e69eb9580c6ce7611fdea3c323acfbaa7e0f535aee711e7b0acb4247197a879c8cb0a20aa8679f6836eae433563163dfd0b3e0d97bd4d85963a12b7ff16c7b68d599b44896b17656ef0c32fc29c9421b54a3d165fa288fdf6801a58d3ea8cafd0c25b51ca38ce25d47f97d55f273e968f7af6edcc6fe0c3292db68b751a8662401bfb3c17435c95081f6cbfb4dbf99fa673e8b36fe48ab0bdd81cd9248f67bca32b6b1aec9a4249b144736af8b7e2d4eee03817373d2fd4bd9afa4fd38caa1914a8230585328c40d9585c6143749bc89316647dadbd6ec95ea1fb8b571fe0fcc7102c035ff6de38bdb59f2e870de6f03b2331722594d7ec4afc8db739a917576ebba3d1050ea01240ae629015b6ee88b5bfa2fec55d78ae51cd50f682b06cee10ac6641a57bcf5b9901b11d2f2120fce36010394698f040246fcc32a60cc385ccb0cd04993e1c5c03c604aa02dad1a78b4e6d4de83d5ef3de1bb2f3d9ea618bf45561ee6cea702c2eab47f1c2d637411603f3b9552a431eaaefe4615069d45e969b41e0c0a3022da8afecbe0be5014bb84d789f99ea814a6ebf14c1ac83f31fce587e34bd50e6b42eeef75802da35499f3dba43baeb7c2d756ecbdeeb8fe2c281ece38fa95bbe799f0f11e11972f5cf19c183e044a7e8a12f59dff4fe1221bf4e895fde15d5725ab76e8a47eec646d9d92e42d2951765f26f1d8ca1f608b0a75e2bc0c2f5be766964c15f72e332d33bf047225b0c7263402166633beb8b062ed670cd396167c33af1440386510d8da7fc4cefb1bb5a017c0c1e431d66e2434166c1a38549fe9bcadd2e15f275e76612a63c46901a7be7ae552e30b182d36145177315b25429f8d36c8ca7cdf4d64971368b12fc839bc7139199612e2937194810ef4e5c800bd1d52830fb51a8bafc139e5d6a1bbe1184d78f8dd9d38858054ff89e88e9e4b7dcde311c3e85541bab357974c8f100afe6ba4de3f908ba725576b85da9ccb669a38a15d87fb87b55a76341afcdce907d6275c8647046e772cab2dbf59cfcc41d1eb630767ac331a636269fbd39218ce244eb49f152e7a47713d134626d1491f37b149ff7cfb9fab030c81f60e7cf7fd48f810b2f177cd6ed3d6cdfe701968749fdd7be557b703268a7522f7b85f0e36b834b258482cdfac89eeff1482eb5f1920b2dd2475db5d5660521a56085d311794968e9afab7e45c1e324d50b63d51a6a49933db82eed4e15488185509ddbccef217b2a8bf95ce1697bfd7499b70be4b7495552cff8d405397477828bdbb3aa30bc009ad56405a7419208ba42c638d8e59b12633af230d9a0101661cac2f685aa4a986d54c15c307a25545b8b32e24ec397944fa7bfbfdc24c42e65c8e2d779ead83ce4e459d5bf6a2d160245bae93b5c47c28a5528047f9e2ba3dc49f13b6f68079e2e61e49928be3caeb4e36e564cbb13e91e6620610de2afd70ff39299f8e7b0a1a5d23f00e879a3acc97f76c3ca3a00fef3a00a4f139daca6e92c9dd7ece6c4dc4f2002e5e696f363101cdf50650ceab5ac1faf874157bfd782524c3e88408b52179bcce13ac24b32c95adc8b8495f2a70dc2b702f96e978245eaaf6caf9cda18bb30e8577d3584e8c49d50c390f163bb499925663f8c533b149cdb2cbb2cc2cefb5608e1efd37417953343b32175363fa17a6cb319a38723dbd53800bc5f841e76a481197515fd5bcf746f9da53db4e7efcfd366751a00e59eef1bef36478f69baf6bb49d0795d3ed96b686a8424d8ccff28eb13604f54c6254ad9bfc953a3dab31ea41654a859334c75432528e7d769ae4662b3d43c22624f9a8ed2878ad3d0541f2c0c188ab693cc84ff9fe0afe13fd6901cc612689acf50a2bfad20c226434ddb12112b5305def5d2ae6c9ed1a13d1ad063e6fcb289bb7dade21613361c25dcc81042fb15c2383c2c1579cd0024a3198fa774f3b268a5433d1e5de11b71efd0197e25b999c3454e0fe0307157b8408607e4b7176e0a98aadee35ae13f6c44ad568dbe89b5a527dedcffba6f1d1beb786f53a1d23158307ffcb0b65815fa5cf79b70121fb14c668336208ff0cac7fe26fb0525584fa7ac07aa437ea5ff4a3be30a3b3b300c484b7d44feea9c40e8b85972fb1c54a678e23b4aaa233e684dda3fe6b7972b2f9fdba363584aeee2a5f6130c0d705d81dbd480bf2ba55a6b8a4fd25a11bc2b5ebc8e1c5872179997f27980cc6e486dbae920b0344dcbdc8636f785ea02de071a4b47502683124f3bc5e463b911af22f7504c6b796f0658794d4a3e75f760ffa1879a91fa70ea98aeb6c1938ab3f41c8c43ac6dc0c525d87df7e69edc881dc109ee856dc77ec7b0f3d83976367ef1bbfc65e60e4a8444391cfd3aec5ab4ad861795104b710e5c5fb14e38d6ac50d934472ed7df7bc823afcda857595e7aa35516d59f93f5021a2cfd1548f91c81c965a2993add3811e32bd887a482cc8f8f273b19bec2088e7f792843245acb33caab4df50f3737131932616215ce0652680c5db8d2f504277a690a252a211800ce5e2b409a9eb9dfa53be87650408c91e3ad4b75373497ad314ada2fdfe5d073ba92626a0ac1ce6f648b0b4f99a00ac5d6ed187b6bdc329007ad82f363bf120bd5dbaea13927abaadb901a423e6df8e36aac3b1d519527664648485d344c46adc2fa271fc4127f5e8a4203d4b871bfafa65e7dc188ae9585b3a3fc9277dbf48339a5748105539ca1d8a8179b16f20af1c6daafe29e5e1971ddafcd7db06ddf8dc324246687fc3c6bdd0ecc944792d8f3cf4926c618b28284e58d66a28c28c0f202c3e08bed434d21541421d636d09b20e0e21305cdb2dc2cdbc19e765c62b66016076ed11d527c2047556001531b77319eb26e19d22ea99e60525c705652d2091995c45ebca8799e9f60268c5251ab42cc83a78e0a9be713fc6649998dc6404feaa405cf85fd9b322e2185e90da92d2de44ee2832e125a8f1f81531f1f306bc02f1efea73ebd859f886b590b0360a8ae8b40fe3f2d5d9474515d463a133abaf620a66c0750888521e95852420b36e3f7f23bc9283fc31a9068314043159fda85b9c77c93d43dc7250efdee5f20eea454c0f32048cd8b14f88b546ac6bc20b8e57aa3caeacc91679fea1b7e8f70e360ab1c490fb5c617e6107879a6b6fff2ee8eb214536853dad51f4a460addd3577f65c431410627ccf03db2789c573c4018019d6b5d2f43438706f5e91fad5684ac04e7691674291c111cebe61936f2a2d70e4a15d29f87b9ef6c69b355072026ff542e4db55a3c2f16029ee92ce9390d9f35a3fd488651770543f3b46f9d34e458963daf610450bff5d1201aa545780067c01b6e065a0cc27aab45347b1f103560b0f27e6fb0b544143cc688da130ce5edefbc3169f0ba7cc09416ab694a42e3d66d54920cac5b85de328e993df55108e3eaf928e00045fcc82550bbd3944318cb5a1a034b63216b3ad0a27ec8645abacc2d9bfca502a80ecb04ef7c201da3cbb4d8e91e25c2831c19b959d8a555ea4c67c226f0bef56f89470e94656ab303620dbe2e448ff66e72fdc7597cda9d7960cf43f9fca27f7aa4c51526f89b38081a758f298fabfd142f2830004f5e6473340f6f0ff36104957ebfff606396594d2a32a59ff3010a1768fe340222edd93094b7d00fce0c687dc7fa238bf1e0ffc691799750f532144a71fd1bf4cf312250c2c8d3c42e51dd1031c19c378b39d72bb011384daddcbcc19d7698a21d5742d71cb7b75f5456ef157d333f4df2f79cba9b1ed897b33808d09495b0cae7fd816767cefcd0b94b4cfe8c494bc2108c29e67f278c85fc85b33c6e94cc56225229cf791b0d9f6feba7688befe3fe100bd67451c924378b29cbebc83f43ce8f56c4e206a09ee634c0ab39e1a7305ff4bc73e089f31ff1873317f8acd98e993e0e81c912038f137c664720311207aa6ed0e742954c3f44ed83b54b592ce05089fcc9299248f965c8183fa993ca5eea26d79372c33389a9d3b3ef7c9f7669578d9f505cdcb59a3202b3e90b60a2ab5321a748d404ad612d2c5cfb0f3ae9bcd8fbfc58fe4236b5c51cf1f5850af759888207804698967533e0ecf4a7ebb42d4580e5670084bed255c196b0c72bc18ecc99be72fb8959d3be1da9cfef49f408dcf72ed89736daa898aa4e2c99afde24c0b63ac4260e96f0ab9b75eff76e242d0bceb96b77f327a4204e83bc14b0a7da41337eb4626d045bac7a5ffffe625f2af7b8153ebe36043e1b4be767b20e3b075860d248fd5560a375b868fdcb95714dd0e27a31f0bafd66f5e24391963be1a26230e52a2c7de42a78f0b9e2733bd46239334e6f7bca24a93852fedb7400ba3925a9ba4c61660e42a5d59fa4682c0088ccf3da331dfa7d6ff3c7b4ffe73fc4638a4fdf9c32e77c44d4281e614d3a775579229275c9987d467061b7732b8e79474b6635aac1a11480109119f458ff1a50bf88f494eed27c0a4e63e897b07df16ef7e01972ceda1c27d314db74451107889b41648cd61304a8d5abac6806f22c1106f43e5e5a47829ceb6f2ad27babd179faaf1591a3a020fa92709ebe18e8c3da1a802ce0861519cec4d3bacef79e963af2379d64d7f14816a86419813a669009050e7885beb353dbca5056b904531a9687d5236f6fd3a67fd347a95c704f9aac97187ee1851866a81e67a2874959afd973ad97e0e791ebbcfcd5e7a37471bc55e92ea667fc194c935f8c058df98626916289b14cbf3401aa0f8fafbfaca8cbfcd79bc1186f16dffa5ef6ccc6fbdf424ecacce1e294e99e98fab0ad35915afb07ae1d3d2d470b31f57a9f05456863089434277727d304904c4797a988bb1dc8701369475cfb8ec5ef138b60345203c6e2380aed54ad4a6692cc461c3b3367cf81a069b0f99623d86711dc8729d9e4fff50a9382ba64003f40a13b59028bdf62ef1d25f97dfedc7ead9afa1cc445c173621faf93786eb3f37c894372510721ac3f20fa2bcfe0f63310372aa2957232646b7aa36a82ce879932598516d259e58a64925e32c5cee27e4c5505e80a3d985b5a7d3b0e7d8270164ed36a973cc25aa73a7f8102882e7a2f7dde1a8f2ce9b2aa26a937e43f26a7f445bc53b341034ba18a63be8d152e78d83fc2a689a21adfe0203676b88df7cd6cbe78abd08cf3c45e221e68a096bca10ca3f6a91f8af5f768d779866cc685501fc807a651b91dbe181eeab674f7cfead3c6aa8ba493cadde2608270d6e5e9bb10029c25d638f7b0da398b0ccfae291378d3d834e73f22998871fe9142d1c25548087c5414b1d90b2e3794dfa9411b548eb63021c2084e081644e8e22ebb0cee4c1f3fc38c764c0cbd1b0fde46ec26d8af1d5933dfe90b63c28b4e19f850e424161a6d9eae6b26007e118a266d3c5e0edb9e75b5fefc1bbc57975f7c23caeed699e2b1396a7a0eb945ef2325c883ecca69dad34e6e9c1527aec3c079f5cf22bc1fd91dd1a655984f4f112bbfc265ab9ad6bfe2fcf263592e1ff5b1444e18e2492ec1c680d8fdebdac898451c827491346612d9f1bdb4a702e3c45aca591e37d3398358e191e721fbf49bd6fe0197a90ad4c1d197b827b269e1460dff448eea15d1013a411e4b9409a055196510346f8d8d0ce2078f7e296e51c55b568c2a9582a10cdf36e5e6ca0985228cef06eae6f1451d2f6d9dfe8a3cc5bfc511180894e6214859ba99c7bf189a9b8be2a32ebde7661cc62754777af57f7a93b0b1edfefe186524c60a54aaecee2c173ce2d427e97a2f4e2beee3504bde128fefb85cc40c2840c4efaafa1bd96ac0e6b509119f6bfcad325c327a73f22a4d6e894f09989dfbd7d933fe2d0acfc7f2a142cca946c25e457dfdd8647555a5e0a9abe2133ee54f41d411b2c170313dbf3115a1a6d909178e6918707876a5fcf3ebc8a423ce770da6c61b2f41d26512e678def6fe0ccfd93489abefaa02d1fd1f09d6fb4f450694ed0e08aa5a8eb2a99cda0d08b9cf7f3055a2736be134c60eaec42ceb502f06cfed31147dd61f60c94e0a8bcd8ae8dd6af7599967afd9519f830b5d3f5f4497a10cd588d588678bfc39479e8ad97edbeec91580e27b8c8ef128a324cd93e11600a0d17cf53be0d4b95a2f88bd1cff3dae0dfc94fd050e6dfc7c4f8e6bc69b926c1d817966038a915df8bde170f7cc4975c2e3ee8038b36d818e7389ab6cdda1c70b828d4246a922e7b5b26446ae4214c7714fadc73df4638d1d8322ee8a175018ea7a7ae870d466f86bad1fe900a1f1efe799b606c579513cb80c285443104f2c25077d0a5bce944cfd598f1ebb10dc280d6c48e6ebaaff303a8314371169510c08be37aa711b16f4948c4482f9b0d8a97959b3f0b4f723e7d8ccd16b232f17e6d563fb8f775c1cd4900e6abb164da1b1831f645426f55dee0e92baa2ff8c35861a6631d7881b1c2e3c5798fbde35a89fad38310923a8fdffff61c65293752bb91d4e47a12f7c3fc60983258caa2d9d5b21f383ebef0a25dfc034e5e115ba67fabecf3c8588c5f085149888b933ed43bdaa172502ad045f04f64a808845f70fb806ccd2abf57281ae083426468530058be42cd77100dcbd9c3e54c2586103e543ab7f7054ade7d581c888361b5ad65f58c362cb6e15e96eb93039547c506b9f61d30547d48b77f7deb364a00fc35825ebd24e7060d8268f3dc1f2d0d417f33ef4ec002dc467f1c9838ee9eb7c5d899e814c891dae5d06fe2db4b24bf0030a5eb016491f8fc45e90327895877fe33d3d1040451152b155612ee5dd23cbaec47b20d9d7b5f46a2d9685f8474996f4b5b99cd18c21d0b21b82ba6ebe4afbfcfe213a197f607323966674b26502c3601557474e354d21150a73443cbd49b5e8c6fb46c30de8ad8662698c89f4289914b06be27b2f194f486f9afd744808816af31fc6455aa0f2b0ba7d747aaf03b741e2322021f3eedf7ba84b07d3a6a2414dab9e1091aa85c50ff645aefae5a0c2dd65144ceb43afec1212551356e2bc1de52b4dade4df698ca52ccb9c8e0e4618078d4ec23748d5ec4c11518a77dce4a1e173705733193f79fbd04e3238003d1d1f6a909d1e1fa790ac41cc3ecaf375dd9aba0374e0ef77482db267eda4e3b02933899c494cdd14e06c76c9ad8812cbdfc2353395c07f1390331d0856392bcbef571a2ab9c1c3c5043165a69f67468fe6868d421c9485ae5fb5b0702f645e2cc0d9fc36f05e0fd9acb6e970d6afd96c46e21245a2c1f5b8ec741273492d0b38ecf282cd8aa4235e9a66190647d4782a4a5c1b422a4b24951882aece3cc2c85f4858186bee0ad26462da2f4aaf4fefc0f9ab4d1ba01e49b3dc3e324075233e6e888048a3b2cfbccfd0f362fdc8ed5eb708c20f2564dd327fe396d0745a966bbd0737f8e2c8c276fad00c063411ef41a5b7458d9aef3e57bd84a048b479d46b213f24235191bb93f705931f3889eb7bae7e25a34921fc1364554bf334d0a27ed059e320dbe1ef55a1598654d10c916cdb1e8ce058530a3a31c12d8b2e2a15ba90d16e0c6223bcead78a20fa9e833887f79c3d70b87f4e537ffda4be941023798995b28ef84e0fb476ed09080c9ce880abd9c81959b9d7bd5bee2797460d879aeeb138e19a25b6a77e7eefe1650a37747065333df5b88744ab016908b916d89d4ba79b1605c69a41a96957365889a675d4b1a1f42aa4df1a62683eb10b1d5cb1316d8f8c924f6eb975e7f86d69e99e93e96d7cc414f8b7626021315fbe519483a5b67782cb15c8878739ed9b223dcf24f14858e4cc2bde077f4468f73a913916dc98a37efa9208c764b3e29e1337a1fa18e83777a606c14888395dc1d9c253dbb34c728787f57e3100c41f1753b4b4b2be77609970215383acfd63c588b540cc6d3ab98b522355b6565924a4318cb4d598dbff36168ee19edc0fd164b28fb61e2c9f01e5178da1cb9f66174856963d64675f3a2aaa2745b79b6af196f7431d63e8712262298f954ca7d512f89865102da860096286f9eaef09abc697c03989de89565d4420ab8cc63d7b89e908664cc83a2bc056af9c7a14cd910e835b9c32459850b0838e749411e433ad6a5f572828d124c205c91d0e03c4d9fb9ec12faa7487fb79c45fefc7fd783737f8e1ebf87fb1a6513e9da5c19509ce3bc132ea9e1cff6b2ac5aadc0f027f888863d20e59e47a0ea5979540cc710a2c66c1a5f5d94a4375f627419aff69f1a4fa53d90e91866d73b08f9da58d47e1d84fff12a43dfec562d7a75c08a56da829955b067837a8611b3cd9d3e75bc1a51964b436a02b02a1a37f74ee1505c90a866050cc682d8f79942e60a43ddf4d25f60ffc49c46b6437daf831eec41eeff26d2d4d68e0c30705e4bd5e14c7b91e7c24821f33432d5f94183a59ed3daf9784075e01a2b8e52b38f51c169e7dcf5ddd53e78359a4e6d37290e14cd8b6558fc41df4fb811adc66185c49281994bc885709a25daf2393623d2956a0f54e9469cac19a6324c444880c2589342e4f4d0286939453388e016a85479ca70b298bb6cdd490970066920d2ed0b61c041caa69aad5b1548f6191fe3e7d32f24041a0d23bfaec2bc256ddf5ec1368d9b355398e897b10eabf3756fcd462c59c592a49a642412fca51d843b835f8e6bfa05b7c4e20a821c4dcaaa6c296a71e42515c1d0219b2bc9c1312a83a3fea65b4baf87b8b3df1bbb82e8240c7c4d78d0dc66a6f889780943251d227a30d4de4cda7fb36ef563186c8efa3167e6180e993646baaf0c43104a71626d02a70be0b66c6aced4daa3c09fa5a7afa4d5852a78e016bdde77cae307a71ebd26745d180f87d15efa8ab03174d78e2ad7b25123e36fb76d708e78ecb86f9ff52cd0c0d66274d95587af37a95a80f1ed3a1c12dd1458eb69ebfbcd2b6928c884d800f2298a7869a6412759c9be85a65e912f09438a78773495d89ca370efa47e5e40ee0ad4d0452a263b1d15b1ab80651a97e7d12989d93fa97bff4269a61776010488e87c82af03622aefcca522194158dc72457149b1ba6097c406e39a6c2c0a3f4ed004896de07351ad17ce68b7b80e5445b4f3c35e420db40cc3b6d6e3a069e6a4581c3aa6110cff15ce63c10636f75a4fd1711f1d66ab5407c0a2f26348fd142903eb8c4dbc08264de6f3a4d3b6e408a472e82243b5b3006d0d8eaae5081ab0baa583307fdba6f530316b7fc3dd3d551c1fa3d86d87147fa0bdad1453e03f2147ec44dc14c7dae05dbb61210df97fa94188ef2b679246654f6d5f1cabe37c1f7677d2a353a64e674bb86b84d492c2d3d050af1ae3752eae2d1076028b0b2258be62ce542cfc053f52f90cb707f83322f1f0b0289b29e2da9a8a61e8ada2e95705514196d1a8adf20fe96682891ecad1a41046b2df8fb8f503ec3357a079cdce4312799d9c1df622bf6fb2f129296e856d3eba472be2bb0e6a1b2ff87ad29809e5d02c302fe43a39722eb834e09eb86aa08b55d2df50bc05af3284af15891971f4015fa7090f4ae9bc6e8cabf4411d03868cb8a2d41db71c05d39a3ceb735587eb47be98688c62e21480a21cafbb2e3b2de9d706f52c8186ecd871570a0eb04794cea7d169a61d6427dd2f0753efb390c8dfd058b9943d210187121ef59315f49d858b397c2409b1e37a5276fb73619762cce5da02692dd0fa30621faf35e806f733960ea284f61b144cc4d3bfec2228fe434e4c526032c0be4b54537c1ee17d5d7e89855b7cbf76913be837059118509ad4197b2d402b24615e63c64867a7cb3cdec177c07d5de0ef4d1684d3f31c349703cc59ef3af60caff771969dbecbe53fff1595d3a277641d8d5388cfff3de5950ab38d03752f0719431ed6af166a4fb8452f24d24f9b34b0051730b37b722d3e8817d50b28727dbe132b6e188682c1d44df462a47f26d84e901a9a629173d736f0ed519abfc2ed537334fa6d423944851312356b4d9e31b2611a4d81a24f3cf71d11053f2f771919f6c489b238a62dcc78a736a1f76adb19c0a57d7fe16dc4a65914d57dbf3bde952b54002b56adc6d3ae450f0976d87c4d6632bfb84ab3a896d5fc661e553f28b22e20bc346e695c220bb05c75071bcb72ec72b67dede9c10cc588a4d5e6c9098c3790b3d5f62a268909eff7da32f87a25601132fe6ec6d0f150de4824e230bdffb9be753ab39da6643ed36c37da32a2c2ca3764e0d9533bd7d1784ab4b1f2907d73000d73220824bc0f9e78d6989361c35b28663e8f32389b033ac50c8d5298b1d782c19edf716cea679ec46378248344d9f4a960a47596a77f976104c2c211088fe9969d515bec9b3196ddbfe5860637c160af4f72f51fb765991e51a17dbc939b588fdb8b4943e3242bfcbf149ba4f174047f82f1f0fa1ac0ae9f2cbc026660f89316b2f5c36fe7e717e30b415d6fcabe9b9b1d2d964a40d07c85a136b45e23ef857d1f7815d42f722532dd634278d782c0d9a85522657dfec9dff131fb8f901a377a37994ca953a242c09a670491779d4bf5bb07160ab1a8fb8ae10311c275a22481afbea900ad904b15af2c2507b3ce42531421422d6987a0f5bd6a07590672b992e64013c3101bf838abc8d972351c6439ea974eaf1f6748f3339d1257016f27f1e89322abd428a9af197a0b2f4c4c9865b32d75e3234a0a72ba9197abb6df83e1dc9da3ddca4a102373f6936ec324a4a83d97a571c1af93bf32b8377a545aa65b4fd2d8a9df98c0631243d2071aa213e71492c813c4365ff90bd5e64883e9ff4ea1a4334c2d5bd2811de17b9277559f4b885d8a0680db69b9c4486319588db9cb849ab9bd1f98ece94dfdcf18ec93d7190e3c239527a62e2fc81fc3f3aaba9978fd0c9cf89ad04a11368ab1e5e9bef6198e989cf1d10362977f06c8450cbc6b59cc3208fde1b9a4d9aafc60d42eef0f554868318ba73d8739e23bf191b9fd9b2eec67568f0d7b9b4ed9525984ec1c720d689179e194d161d465d6cfd4a8b78fca8b7aa61c0f08ae1fbd3ca3eef7d610229eca8fcabb833f6bea0f299318e2c53b4f566c2320f6222b5279c1ce7c441065e652343a637a376be02672e7e87955d93d722378d42e429778d6350aa93e353f691c21b64d8b9ce10ad250ad804dac3dd6ebdaa2d891e49ee9962d2fb4cf1147592361eff041a2f7edf4e9650771c67bc7c8aba68e75cffe5239fbe215cfcdea69fcceb7afdeb2c949c1ac2a98d7e130ab69939e6d48ff8887fd4adfe5f29f14c8863501ecdcbd5a31ee0f51de1d500183c6f377a8d53e9ad7ae25fb97f0e056241a59eaec389d417e42b92593829158d0d21943d5450b2612f355d93d094976724e89c2090f1b8f9f590c92eb1dd98b45d490ed81bec5115696e4ae7f4296a6f5f1cbbd7c1e53235f6bb66cb6b82f62b45dfd83de948e57fa541a4445d61946e8db26032ad7901afec235af9fe22f107fbf9c4ffd6a9159bbe6f834a481c97219d37c9df4056be172541ca613a5c4de3a6ef5d98e3e233a6b6c6bb222b56bd825e04e0de896a3c3ba183540e7cf7fea4c14296ce94adad9f6625dcb6b8eb78c5f86c3ecc7f5c975f891171b7ad1e8d08b843aa21493771525ac4ec9d6faa631c0d2128a5f0391b08fb88ff33da4261fe76406256c3cf9f9ddc01096d05a253ace5773c0bbf05adfa3af14315697fe53bd3a6cc74f2f75e359724c6cba813322b828b78468c0430712a25cc59956c9cce4b8924b55b70beafd7237fafd1fb10c94a700deb5ef1ddedacba3587a6dbcb64bc640075937c6efae23da070e51e09674a318f00bebfda316008714152666cad014bc74009c09cf5607cb149770d6cb90120a9405df433ed2957cd98749d4528a0047b34bfb921ab2c68a906a61c5f0f218102cb62c0c11a2622867b67a2bf97bbdffaab7b4b2d49e209b9b37b6456a0fcccd25ccaa1e3157bcce9c8bb42559bf892ade5eb57b88122a63be2d1529af092203b37b7f371dae8d694701d463d4d4eec98bc7680349bcd78631c3b03713a80c0ad17246197b90f26c359d6773b420111d9b249dac425c11886342123d272992c166506f93655758ac5bbbe28e10597dec3d6a74ff00e002c9621766899f63e659a00faf32261b59cfe950a514ae96f2dfeb0bf49a414d766c9207ec19ed31527532658cad412888ef0c80bcf7ae47a548c40e88d57f8ad22a738a4e9e8384ff6e647530e265aff69494285d3219c37e90c4439d66038a8637e6556b1595e7c10cdb10e28e7baad42b5c5adc78d3a58637436c7af6d82ef1e90d44c2d0a00ad8572d17e236bf5bdcf265033d7d9896f9fc138bf4bb66d8696cd9f2b6498e3ba7fc9da81ab0cc23425f36df90b2c7d90c85efd74402e31323d241bc6f3f90305afd04632652b2c0b63bb875622c444cbfe3747cd905e6e23d5c4975a1605f83e1a7a638a3c8613c9b45311ca8e3a9ea8e51c58103b616f861a1745bf21101fe513b40e66a2baee8c1b6a999483975ae9149a00903d66af4160819b3699d6f31d3e87e2a77e61ae81e9e0ab3be1826e511804d2f945b5b818461f833779b0a3d3ed61283a8dfb76c2ce26214dcbf00a6fb98d6acc4e76c5c149d3de6efa3444620ba811f5ff1266716bf7f4b015e8fa271386069863807369c3c8f82061ca94694038cc05c79a072784a62aca279535d24795ba508f10555031bd0218f98e8fc7475ec12a103a702d8c7768b293543ece5344352de33579528f2505a9636def0a3bfa8f2df913ceb8b355358fc605ee29b7ff1c3fc6848043ab2bb0cba2b884435337423bc5ba9e47050312f6f5038ee2315be4b7a8e2812702c6041e715746114bb13e0244dda97a883ce9a0c7430bb47f6748c04438618239615d7d2c292b80dd732844cf7a10f3a6e35c37375ff6ba00fd34762012013e9ac81ab92d57bb10484d828a0ffd94fec4e2796ab713fa9a57eea17c1bf734c64a94911ebe3afa582b528e146968691c4477eca7a9d2737512a160644896026d7331fab84c34bcadb878a3dd75d5c8b05f6432c154d9ac5fe66f1a622dbbf03de839312eadf8f7e91a6b6a63952b4ad6e06736b7a97ee27c0ab123726e185d4eeb7727f45d46542b6254774de4f27be953451bb0dc5e1d93b65832e43bcba96f303e0b9bf10ed899dba4e630489d58151338e6a5ced4b23c0f53f8833818527f08f88487f434c45b6a9194aff04036729bff3f27d85dbc93224f0e23194567a7a19619fcc38a1a5dee01e80e5e48b615456a925a5afc0d14537fcff7308bec84fcee3f3f0bf5a5a6ddfc564449f82675897eba5c170e1c2de2f98f781ca88822438ca78a810141d459e10e74c78c84c706ca13ee6c77db778e247ea69b288649e99d8bb32dae7ddbcc35d6a14084c8878b0b23fb2093d72a612eb0cbc1998d62614893ad54fb6a7e0c685921479b8fc8a3dcf86d844f4bf13a8453dba5f32cb07c871b3105d865cd22e666da3a68dfc7595e368eabe1787822ec671ade52e29e718a286330f3ddbeff7a95de9418535a091aabec84f241093078eed6d68285423bf82cda45fcda31fd73f7551a9d5221a64b8ceb66f3802cd31c85840d6e4a0dbc1258389cf108398d36e61edf05ee1f523a86275da8a0cec2833070cb5fdb677847d997817785c48639e8702a70daa9ddc0b2987465e43174705fab895560ac435c4fa6d7702bd511fef46f0a34787572ee51233b4308a71fa7c7ba363ff3132f0a6d1d65b89906d38294271747de5fbf1006a38d66ff80b0221b1cf8ec829f1825ae8357070c8862f476a7ffc2bf4ed6b3239ae63f3c7fc8ab9b33df39d8494f5b8e8d265fea40c7b6ca87611d2f49e12e6ac9cbfa1fa728570df51c746e06a33ce1c5878f2fa27e229b3ae1cc4e6e455d9daece1eaf42ed19d8db6b573d4ff5305384013d0a3a45996be96c37dd2e2315579a637ee6bb0c9e187395f84be45e355ada6b5040f78c6ed05fe930a873ed9033483894db8ad1b3786e71ecb9dfb1fbd85c0b38f1512aa66796979e01f6d257f07fd456070aacf6890b22cd7bcab0064469fc65ef05239f78850df24ad3d417baf63c9c52e7e57c583cb159aba8d209e86b33eb08cd76b46a5aeea962097a20808bf7c9a861cf5709c632ab7cd60e34d5f95ad4cd39fbb8423e5720c0967a0169e97b4a82aec5140e6107bf1fb352a9dedb204d464316359f473d00b1ea4381172cec4918d2f54ba30d03d79d0e0f3cb8dfc612e31630a0789ce7a8a2be75712ecd1b4416077aababdea8b9950a0e8631fbab22a903b6e157fdf84c88ae9c2c42fac6afb4211131ee8f6d769e71d4e183f3e8f5e977b7dc39f1f86c0964484e1bc6bf93650461039fc1ff58522281a0fe47375ffee6fd5e73118463c557a1c3a0419ddd01599d743cb43662d22e72c792f31b909444f695f2bb7c4babc82ae5013d114fd787decfc90768cabbe86837fa79bc8823e3ba7361f2e0c3ca5e72bd750e6e7668121b13514c76c8994c8d6b6b822b81470945266bd9512836bb71c1a32ad76bf30de5e1171685b0b3e32059f9fd9e750d505376534bd6d364e749f885485a0f134270b5832e49c21a7b8d4508f688ef88722d85dc24e5523d3b9dbfd2ec7291575e94674c9e573e4ea9f743ab7a8b52d481fa7840068f3ffa40fb18fd2f0478ee7caeef08c52fd005db83a4211a078ad9edf0374597a7be39e76bc2f2643a0bbac966c5c5a8c8b3c4edb06ced96d6a7b0587c99273542553a99da79510b910a4c9582ace5188046bd157b023f0bdbb64b746ce8b6b5893d0c776d4d528e7e355a71b0c0a3605a75a2c82b28dd7d03829f00bd4ce46a84454583b11b98ea876cc244ff57816e94f42f4518e28b6c03464a19b797e87c1499d3ae55613a4a6a652adcf641a20ab9fd9ba2dba60b018cc31c017dfb71be596b8962954b6b5918ee9225d08f80462dae00063149a218b0786ef3c12c3b51f53d38ed7d784444a7f034522d61e8617d351a521a751c46f54d1dc9699822f2f99d164b8e93dd81382a8ddc7b78cd0f44bc5d3619796e0d2559c2c02584666a003d99974d1c3750e361c0dac0604294ba28b230818e5efe1424b39a00789120545bb5f0af4673f046774aed6246f35c4a9f12b8e18422a3f2a65844af1cab11c9da019ada16b78044a3c8c527e9d4d7ac26db8b8259ce081ede92d693da913af894889e693da75ecd3fad57cca3ae0da56ab6c405b9c6e836f22d1844ca8e8f176ab913685865facaac23eb6516f81703a911555508b2e865c06a0906d03abc94161a3950a0a253c5931a6739499590a2c25b2eb7196f7cdd14dd12ec8b0dab3f4619242d0ed140f1fc6239bd4495f1447c744a518093f5316b765f5dd390f5940c67b1a9a8a326c8e309ccbe029a7b3014da53fb0de044f0d9dfdc474f2ac19c91423b1671c9386935dcbe7a8353c4b764a7222371edb8fa786145c8ec4b8f99583430f5b32e8712701408bc09f65d2bd64447655ffa33ab0e1f3a1b680458d7ca03b93f98f5cdc04435fbaee49f61266fceb1cf22c4728b40347f73c35f3bd541844fb45421d23f6c494a214a4271c4bb97e62a28ca162b5ec247d938f6bcc32dedc41af1178026a096103a5187a49f86a52b27b6c2a70708d632bc960292fbd459e14f7960ab18f0b278129c4fc7cd36de5a6d1c0880990c90342e6c045c94a18cd925579e049efebcf69a621bee5a60532f338ffb47628290d77080e5f25380d2e585b24afb30b8bbae577164f766357a7aabff154fb959ef327036a4fc0f83889db424842516c79aff3604eb5769ffa44319efc20bc2f544b34f7e4a5520380fac233b5fe0251749cab23022cc6f135e2a9b955f7fdd72f1c89feb39c9f49db55bdf172cda4805f99026984f2b7773bde288b159dfed862021a569e5a2346a4233b38c74ea6b483dce70b35957c1ec7b6d2984098e1d3bf15cf1a6c2165d645c5a9cdee0bd38ef9a188f0f64685bdbe518625b395ad84954cff48e9132f817999101ab0a37ed0401464d952bcea097bb5126313e2e42fed7ba2b3501ba9e136b72e33ef0665b2958c1b201c6cc61833454f10fad74a78228fe9ecb741531dc0c7783ffcc0bbbe812fed3ceb422edfce1ec4dfd1cc446c31a4fe3c32f2ce7e56457349e588fa7825a2b689ef702d948cddcabcff4aefe454b7ca32456100449b45037f2adab04f97369e2c0b300f7184545f317d39b373a41e29b31e614b25ad5c9dd44317f821a5f41005147990889d5920b96573da88b2951db52315e0f503dd8f5f0f1dab89ec76b373f756fae98baf0fdc68c8796ed02c326efa84982be6f066255cb707ac29bcb9e520951890430210f3b54ca2492e1bcd8af61d6e951ea4b0a6f8247a6dcf634dd577fddb3980f633196b045db02ea98b650c2c56dfec6bb5ff9306c2ff0e39983c59cd786d06ef33c022d2e1f674b7083bfaeab20578be801ca263df4cd49e43c9c190b8ba6c2d1321bf026cb9f2be6410cb6bfc0d7fd1536c5255f3cb66d9c7a317bde8e4d6870641dc9c315b3489247683d3c623173b5ca1fa6c4c131fba6b1945eeedc3e3f10004ee42748ce2446762b3dc8c67e981d8817f04f70bc9a0abd007f66254f25dea54569abc6c8d06d040f77744fd2c116eeb179db134c8101d5a751ab4d5ca5d7627f2cf1c804ff1734167016d8ac922023665924ff4cc61a8529f355bd575fa30f8782af582555e020fc5877ab5ff5151f53d81301e67f1fde2a0125c1646200e390757acff760cc27ad32d3ed1850325f6cbd49237b9346e5583356b12855fa545c12a08bba9160d771a663ed30155f16c48c34333134f1a51e7be93c015ef2f9fa503db9b4ca6940336b6cb7184334b571416794c31aba52141e3fdddc87f79a3b94b70d4f702d2e8fd81b11f65fb481aedd7a8c46fa18dd949b0020bfd5c3b07416b13843c4b43881e8652d70a010c3f9144f92c55214a684e38dbb76a2cfae2494597abe61ec52ac6b93fa669b4ab746637d776f78779fe3439a3bea1a913a51c65645970c30ccefc3e2b633f4b3bd64482aa1843be076084c33d9b7850c8582a907972c2252be1c04d67aee2c163298c42b3c438c91151136f7df4f34e295fa4a60805bf6a030caca0583b2ce874feae907326f345fe011d98aaef0df43043c4386c1c3d73429cdc16ad6e115b04f25f51a5e5ee2d13bf448e3f46fb45d1977c4dc7e9d95dfad44e36927696eda84aec65f55715f6cf7623e37f3d06bd297b9b6d4c1aab9d93658c0826bc777e7c1ac66a5659ca317eafad5fe9325d6c8c28879c9335b7557f8e4ac0f19b1ea3c795c84b69487b07e72aa3adc7113a79bbf6aba0e40b4aa38259e827cb686ad5ec5bfb23d5bbb3761b7364e15f72ad11d9f9e689138ca8fef555d76e5ac81553699937de4395eb6ef1cfbc058f1abe445b0a7c5fe6b8590cc456540dd7f0d8fea43ca04c23595d37ef794475877eef46f7f584bac8a8a31190e728b513d440236874baf49bb10168d1001de39f9e156a2b42e5caefa30493c624cefe18640f6d88404ac3cfddbc12d7cd1c166868ea6dd210bc6496183959bcd883d69228fafb20b11fd7ac49a6741c4d93fd8243517f8a2173094fe4201b520bf040bc61c9d3986db53cf76cb41f1a204641b0e08ffef3609e711afcb39bd48aaff67cab87bb01f0c6933d4db1b1e9db6d40ac6f6f38292745d7a80cf1503f0a587dc79082db3e0c860235c7612d2f3d5286c4957e937e3e15726841598a66950ca3df1bbee10d0a175a6a4db55b189953088a80985d07944f7254b8ad54e79afc30571666039c8f56e65e09cbd3c50de73b45330e3422e8dcb15014e463e88184b06849bc322e86b76c219196e8e7ee7adf6ee311a137ceb32ffde7d70e05ebb97bb512b7df1147261b06de8e8fa74d60a46755c56c62d93235be546381a4e503217b9d8ea2c5268f2af29f3fdc77cbcaa840b53c488aeb26eaa413256e67b5ca07ed16469055a33af0f569fd187b7df60a1a4496b9bcd5eb1cb6bbbc372a548e4ba1a55ef06547849b1f2a758bc67038d7344903a0a8c3e6ac6ad747650fc294ee28106109c3c0611e4295ad70702e2b39e463638d494bbcd8bb35e2a6d077c8acb9b099878a9ced0eea1afb50cde8ef3ba7febd965851b95d53394b96cbdfdb9fe0961b468d41af1cf79731791750c23f05889f289c603ffb8214888d0324a91868920b2ccbe5a70a88d610d8946b4c692cb51f6baea0af3a8ad2473fb167fa4277ca1fe0358126be706c7aa82611a2663c00d0c63e4a0096e411a683159bde51f380013064decdcd60987853c40f9f6518eacd89150df6e60adedf1bd5b6acf3cfcb262cbe6d8ab1089b532d4c53ba1be9e6afba5394e335edaa1d791150fd3661bf5487c3577893748da9f72c9675e4afc12eb65b02a2159dc3234da1cf0e00044baa7ef888207d84bfcab902504b6c95d01bde54f8398263b8fa0065bab737818c92ac2bd389973bdd982bb5d958a30b9f63ab85b7f2d888a4c814ebe3311751ab8dd17dd9e021e0d34a610f0f79f55576da0dbed4f6e2c2baf04d1d675fa32bf4fef97776947a07e7b7bd611e3b71ce4b4428e79110a81c94f759ea083585b4f314ca66e1c4c2d8a9492bda8758bb6cdf2d3cca555becf5831f2c00d3794876610bf7db3a9b41b49d04bbae3f893941b647bdcf96a74402d535af8b42995acbeea13ea42454cca7cddb279e4fbbb0f8d7ba23cfec900dd3b8228e9b189e2c49c5025421c33971c1a3e069f5b74e632fad2b5b28c00888dea86015e2ed915ac3d392a9df8728469524c132993e7174c4cb62650be04c604bd3bc7f9ac7eddc369c9acb25dcc102efd80076132eef0b01e9bfe06fa0e4d3db8a119f92b5092988529619e7d123bd7203c61ab629e6fbf60842e33d65caa2199c583a4ce54b7b7caefe2f93c3a06c4f94af156cdac48d856c9a6ef8e52b8459c4c1375d5465fe28e82cc1e546be3d0a50459c425964e064c6b6d27fc69aee676c9d8412f6d4f3589bc389bf4ddf0d4f7b1afaff9d131d63de148d9714de0a7c2cfaed95fcaafb2fbcb4143bec60facfd1daf4dab52592c4eff601ffa4d67ec4303e3b1ed8d0a1bfe98d49b20142c24eb5f53f5701a8566039e065c2e0e68a661abb36e7f9ba6288f0d7a9df2b1e0b065925d88807859a13d935c3b8d6ba7d350d50c0f868be99fb39e2fc97c20e2ad1fad4cf19379aa30cad0ab1fe41bf5f446a11a1c1459b228417619c8753a76ce94539be334aa28516fc677757084af4f34ebe6213ef5fa24482a92acf74efe5c4511b05eb32bd55ce9e225c0f7a258b7ffd0be27b713dcad4765e0ca207bea4e618a98a33d721e843dff621dfa21b94451e6764f40c633fd807acd062763c37364684688398ccbb15422418313f3e9132ae0d7d1b1cc085481c6f69bc06d81837ad6a8bea4770afdabbefce4e2535c2e9c7910698fcb88cd73f55902655b591f43f7eb9a7b88dcac9e97867bc2e6125a6ced1e4184300fc37e39d704f46510240fa4b885c0f320d25c2711d44f06a86d9c8b701b6f773969041fb3e96e6d2c41e235c58683cce556f8a5a68c16c83027fe30b6aee5a61c467e1c9f2f44cac67c50aa9cd935758957043ffbfb2629cc29c540116eed34bbc0aef3b8d8ce8af76c80b89ba160ab3817ddd35e3c0f99fdeb7a7437e1a39d4a6c567deb24f63b087f1181bba4955510187a2567d6e7d738a703c591ef39048e59f6e7b07234a52b874aa712cae8aed8f05a2d687317d6b92c07e0659314105fcc012ed02b9c53d6490df85e24501281b2e9de3b4609b15a58ddb997a8c297e031d73c23e1e111531ab8d4c34d3ce737ca385cda6495a372858d65c33f54963f017a77c95ffe17539d22df3545c2f3a7fe2ed71d5f08dc5dffd55ccfa5a4e07d9914411d3b8c9540df57f0f16f4b3e3c6debcfc903892eff40716ab7dbe344c9b56cd5fd89b9af4b530ad9e326e617a259e0a657f4b06b71e39ce05cde68ba59caaf6b4ddaabde1a28f65b13f934ef02fcfc913b4fc66a424ec9f5854bee69b156d7e1eb28a532a9a85706d4096c0dad9ee4a5105f5354f09e9592b9b8394f54a6cd0396533f94bb3547a642b43aaec2ecf6d275c571a2164a6aa50faae8e8a0b29e1ef4a5f0935c5e6ddff33026acb0fab87e381cacd6f574b9fdee705f7a6131c921d221d86cdcde3741dff28f529f1ba766e132d041fb675f7c37a26c63946a97562d4e03db53c7981fda9f328cbf68da8f28ec0dc73eea05cfa0ca6fd16053923069e5157981b7ecb7f2435647efd4fb2b22a582983bddd4b0d20895fe8a7ad22f7ab47b57095e4510c03038f3e0dedf0ce9530b5fed194ad07fff8cb9d9a5346bad570383fd9f0da7ef6d070dd6d2d1890213266e06835ca044a773dd6ae38d90c8ddab009a7cda2502d6d10aa40964db8bd5d8c19c3a458b0378ef0ed1bf0df9d82daeac423602d2716f137b15a006f623f1920a652da4616c90aa247d90ec35d4e925f94d411dc3bb7538da84817c61c2d36aaed112a1c6baf96dce1296060d21730a21bc15f857a6a7d482b0e9548189e9b2d05bf942b2db74a2e57f14d42615e2742de30b6eac256ec39b6ae8351fa429eb3e484aa84c25b686766ec467f05cd5a7a80154ea93e48bab4b4ba62fea57cb8ecc4afa126597873e722df1ff7d2ff61f755eadd7f4eeff3be09816c8a722e13ab1629406f8408bdc712cd1578736643df73e1a55380b5eca4d928ddf6fb20d57b80684059d81020730368950958e7989054af7be2ab4ca42dc4f7ea5817537e71ca68aa3343084ddcaa33580253660cf49705a0032dae330bfe8b181e2992109ade15c9a236e1e27be297516673b46600d1cbc981c027d40457a76a150b33b4f7f331f2ff6728b8a528068744b66bc4817fbea02cdf27bd9d9be7d1ca8506f6b0e5bc672efc0d7f18810bf1a221eec870dc05ae850ed51c56fdc3dd68b8bce3313f478b6d428f48d2b6a6da9712af51e34616b11100916b10a3654be1730e42c85179c4f642954242a1c596f642cc89b4eae9d0506880435daa284ec2c5dcedbce34fe99a3ef119361bdb2eabd1b07017872248a41575c780d4b159dcdee8265726ac4baa9c520c0007293f395ab645d6f6635db000869b5a5890b6da972585ae1da7b6a4a8ae2956ba6efa7a90e42aa1b7b579c333680e62c978d27ee3a0c51d0e807fb6485a14f5014355097dd79c24766ff52e8409aba36d235cc86313a342d2548679d30c0fded349d7ef9e2b3560d7353bb8611e2bb8acb7ce83e20613c45b406491ab77cf4e6364d00edae70d72fb87f4c4275d0cb1ee35bc699c1ebd7f9aff9411cf22c65f62408453dffbf23506534817620b14a3b839015b78b89f17232f85ab8cd4d6203cadd59660ccf7983c550c6ae809751f05cb7d56662aeb8afb03d08b48d6ee102b404e4d3cfbfb74585c886a48785939ffff70e0d5313734c0f5f6bbc444657ab3d57d68ef951874725eb7236d0cb1d8231d7dd7bed8ecd8b2306259d2de69d7272d192f2a935c53f8a33320fde34e8295b8d2844db2325acc0ede97308944e006f01d77799f065fb646ea185f822cfe062aea6ccf797592780473cc0ee0a3aaa92c7adb89ca823947542bdba33da1d4b94cdf8f3fed3e5436291997dbed3cadcc75750948987054827a62bfa06c40821875c9a01b7475530716334f7aadaafe6d056eeabde31e2e514ceb080af0bf254224b21f71f7198e56c32f31630887041dcce28ef2510ebc33172ea79a1e42b2041360546cb1459ca0c23a7877422278d1dca9f73e11834f10157ef968f7b82fe60cf85b90844d21b4cd0e6bdf4a4f570d459423c66c9761055a01f6e350e6e0c5ab268abaaf2c0e1550ea1e2dbb0509b3923b83a639ee47db188704503e884616c875a6022da6e8ac1ba98448bd852c037da7e8a1b3549062b8b0712052b215a1ec76cfe7b4dd6a8da45ebf328bdb1186d8e7fc950ba092b97bb1fe32b77b99d2b5471c5389d2e58766db02eabb6bb742d2362a75ef8ca9aad912f17aefe3ce82c34683cbc1ee5edb3c6de26010f9f1140b71d3d2850ed91fa2f3c04d17eb02989413a414194cd7b45468bd60fa78c00cea9f00e6c457445c127acf76caafae9a7c3d9ffdd789036cc39f625137f6a7b278ecf2d7fa298a7c6af2e1f1db4fed8562ff588534085e207751b9483e72b72a57c65bb4a2999a24b781ac2112817950fe48194ac6a705f85447896c56b70604bdc0d58f8fb2db5f134d78addb5364c7212f2510a5c1b2f14013da2a2f60bb7c84f03b8f2422c51f4e7c0edd3a675fa7a7895d72633c1020011622483e410b2915ca487d3899f34f047f69fd0b3e23f74b5161ddcc6d4f4d4e38385b669bbe50c945f97cd26ea309ec7b8551e889d6ea619e9f6de10a0335b2bfb52a0a7baca872984a1fe3ed2eb319969cb51591eb1669e57890ffeb9534aa1ab3319de1b00011ffda47b0ae5538043293fa493c61ce37aac9fe1921d21f6619ab342c67319315fa9f3d3009d12138b45bbc5f89841743046cc6fac758faace6bd582e35cb25af3002ef0bde598d61533aef211c735647c76825172994dc51c7de4668b3c46317ec376093f110f7b6b43cdd0a4f5ae8979649fff038d91bc6b688c34c109e029566b77ef123d638f23fe6ab43c1e7b90d47f6a5300f7214602ffeeda750dba927d26fdcf9f3d1d75ac460f6b6f4be7a02b257937f7349afc5fa17df9d6c0eab2a0d140d083c1cc84e3f66a66d5abf507dcf4fc4b23e41fed2a81bb4a7bd05fb8d88d4e82ea4d309b2adbc1151fb2cbf6457f7ece6fd60071090c7d667be474d827a222c19642723742ef4aee56721802e970d063f72206a3315a898166dceb3b6081cbbdf2d29658ee6b9e87269344f583f9490f2887ae728ca09b145b06c15ce05ca0f0c35183139909eaa7f25cdd880729646dbe37cd04c2dd76bccd10c46228ee4ab4a84e1c90ed179ef8b8d0f20585c1cd4bcdd70f86a92abd44c680737c28fbc0a95bcb6388e07cb54b3038f08a5def22e34472bc674a5bf70fd078426f105430ac9de596365f525f79c425b762360792bcfcd7ee06aa42cabe995b682e0ba03cfb4792b61753744eb2e763cebe3c2abec01a2c6b173da30415d4c3a3d5c8c3012b5cb5b26cb3d623f6eb2bc462e29ceb5c23ac918f521346651e7a51cb94ae030d8b4e1736c953ee0dcaedaca0a96e7965ea40fa1efc13d2aadeee4b0590f4aaf313f22423f1daf76437051763e5084b4c84c7b1c51d9cf1ab2c71e37f38e64c9b75639c48f1db7af05965baa58dfe05e3becd9485e744202f5a2029f9693ab367d6f91ed13b84acb86fc568c393972f3b809e5b264c0ba98f3cc22f2efadc460c52e0ab46e9daa2e9dbecb60b0b86cf1e1c7a5fc626775d10af284a4c232334435c71422947006585cd5d6c1b37548bbb76aa532e8d00d298b8ae6746e415a4c71586023c8407d6d6a50dc15725567a00da03a65c6c0b403facab207ba39451ce98c57d8d3edcbbcdea55e74a0f9b2a086e6cfd3947b9c2009dda7593812de9c7f153693c6ea00b282f09bb4904b4acf8c58fe0e094817310003a3a14b1ad57d5b82ff36ba56ecb5117699778c5e3bf19cce9c5caeeed8f5aa3c2c83214530115856561fd371fe88ef12ea7e65a66826b990e1e94e8fb7672e636cc269401771d3f6f5e25b918e894c6f6223cdafa9003fafa99a30362c1390099c808b0da0060688702a57127fcd8fe3b25f8c070e8f7a9100e62c3eda16fb94bb1b4fcf7c2571e8e8e11edb0f3894ca417a9233777a6f9af50f4f3df98ae475ad43cb7ecc8212ba141f7444832589db83e73e0905da5d032a051078778c47d6ec6d36b5eafef56fe1e5695b13e50c1b5f2bae0461c5531eca467c24a1c8187ca2d7f413749f6001dc31bbc7917e701abc7589e641a53a0e067c54323a10c882359aebc01df4ee5fbb0ba629522f4975299292b8ed350a153ceb37843bdaafc333c11ba1449b112120ca3f0bb679db85ffbfb9f6d801e972a51495a49db1fc98ce2531a3837117bc4acba67545e326dd70acec98482f353eb6db57b73d813429d76ac98233b6f412db938505156d2b21528708793bd0d00912711173cbd82357c959165c0e48d385f0606f31d2a9e2c6fbeb705457dff91109b0d1db1b645ff6417eed381e06637aa64081e51da9ad406d9cf3e790485c980053e88b450fa78117759f9b8fa1bc3301c8914934a7c30532482113df70c7b11896b4567ad3bb572f7dcc5c567b133062b39d14638d2612ec5d59459ba72995145e570cc2fed6c67f12f44184fb11f9bebd164f40cf8593a82fdf5fa365256cf57bc66f273b190df8b08e0e14b30f02f439d241b75ad8a3b0dba9a7182b12ad4515ca8f8f466745aeb1b5a26eab074da2a38495dacfa0a9c00ad6b6442f57b153e25bddbaf3b137fb109f02c2077c0da97f65268f60ac4e96242a56024e366cfd515ec8e509d03c6661752dc9cebe93911d2d573ecc1df33f1769fada01148ce3864a9e5ad81cfac1d1a55d01094ef9ad1b60c4fcf64b2e7e3a7b2fcdbe346eedb590ae31cdbfecf328c22e701dd5fcfe49b791b1b3733ec7fec56aa401c095f8973632964a6c9c906a530ec7d8f8ec44af61865b879141520ff5889a3a67bc928cd16bdc323fd3cca5d6624e23d54aea8d2e476c517ee47db5ce8383f6917605ed1745ff99eec114cba96054a2cc1cdb4dd13a8d6e7c9ccd3e50a8207d1a3102605e5fbc04318d1f2a2c905a412b68e2fb4011f874241b7e55e026cc1d7ac7aa5a2971d2dc0bda3af8a0582499233c620603fed6148d8e0d85fd91c21f901fbefdfd7eafa7c7c96341c851a2d568267a12fc406b875fb6fedd72082b7d2a379747cea8e993485630c8947f00c39cd4f404222d1dae03687475b7e165c466251184eabd9ba83dbf87e64e41cbe0c13e1b131331569987a67faaaa9e048c277b580bc8d2a13cc4ae294c008383fb61c807ef9ae0338abbb85b3b33e8c43018e533288927fb16ff78a4a61ad4819fc4d1df8abf44a51f71c3803b163a6cd80a96c376247ac1e69da4681b8e6975a46903b2b8e07aac8c4abafe1116c2bba6118d6d3e675d24bed2adcf64f2a6652db0ae3e0cc52a1773ba6b6d86b6d93aa54b26a7f18cbadecb84a9f6f34053fa5a628505476a11e123cbd442f65470d34c1aa5d660af3833ee4d41b7e80c59928d8da9a4c101c2d97b95ce85b99709d91f677dfabf65f02b555371337d265654c48e44c00061cb8ba71edec637a767304cccd1f14932f0010a332982b13c7e945862b8e82475704a8a70dcf2715afd86fa616963e30b64918c8226131d546a598ce76e25bf52453e849eda963a0fb4984d5e7ccc9aca37d3c4253b99de16aeafb12b443c27bfa1935565b1d91386bf279eb34c192afcf5ede564c30aad3b19eb4c516bcebd0e15e921b5c7db3d97b785866a8fb6718043e84432747d85070d6efd009eb8aa242b2989d3db28a3bb1bb9211da85790a449531ba9f272e0d6e09d8df2ca5767e2b610d77585e8fb17a20add03b4f7532e04436c0744a20ff1e474ecc52d32af2ed4eab7e78d947f39b8167f884e571576bacda2727f20f2bb76638bad2e647a48fd7529c051f551fd46c6edfaada5747a69d141969a581de670dae38a75d0a3d4d1e63d4a7a552ed512ecb18a9f428f4c4d2b81a38be8b737f1a2df89f3ebbbccde6cb25b0a3854bc1f848fbe4080bcd666edf93fff65cb00fef36855654d0b16af52f47973f262ce573e35036502a7338dc5fd6533cba606249cb369f73e7687af874aa2be32e4e1600818823612f216c512eaa9320de2f1eed7d8dada6410aee2061480b8f55ea814d9d525c2d1a030f2f28b401146ff7636ffc745e132842915df3b92dc58bc6ab5cd4fd240089d0addb118f9d8d9d4be89b6dc31df71e54e76b4923327f2815cc4b5c80a9f99bb49acf103a08b88b0c2792a68272617b704fb6f86810d2c9c8567b293313c2975204551b84a2c4a4e6c8529d176e80ce97275a92cccc3625350e6bcb540ddccbee78e2a7ffca5469b036f357f73bcbef6fdafef3ceb78988e1ffb2a6f3268bf1ad7e5fe62acfbcc185c54cb2d59bf7a22e04aa357eb0030adbc56717135d27b31e18d9bd819ae9b721a757c3d20e84b51470fe830af7aa3cdc86b3eae7987bd997321a14a4ed0fc09714a987ead32ef500b2e8a9f2395170c469d2c96871151033b528693b1d1adde6862dd86b1cd6605149bfa8a9d0ee60a2c1c7f6812b79022f6bbd8ea09b18168f01fda0ec7786758f77e0488a679ae94aea6c7979a3a17c48a96a6ba5dcf3103e59e5de11b3ccc200b88ddf9fc756f916437196972bfddcb7ffd4c2596c8e68dfe0dd33585fca00fe2c148e539df74c1e03d3e70af5105aecefcfab77920241a9cdf00b121020bb5ea506c463cc9a7df2cbfae53981acd25bc62b861d5d15fa1e076f8776587adf2b4fadc9a98ebeb8f4d62751b5db8f3fd4e13a14819e4d0de88eeed0b949d3a62e1886da62c79c553134e64d17665f55677cf3d1509a85b559086719f41b71aaa817926e71c915ddc662122d994639a335fe666f8415037f71eacdeb3ec5acabf7a00505b567a907b9366b87f55a44e1ac9cbbd0cbbec6abc6c4f4799cd7de8009d06f282cacc26d8110d16a56d9d5e1c24e3d8f28573922e7e1bd5efa3499e5f9d2918dd3408d6801ed8d94a7e7beda017835f412acf2a968b87c27e70ebb810f276f0fd7f56fa989477352e1d560eaa20168a0bd2793de2dc43f0dfb6c6e8e08875c65ef688c0237596e4dc291a0d4259f72dd817829d7202a75eb26ad8a9172360e37a819227eb103fe28581d90cbb8800417a051823fddba482d0a143d87a25189217edc53ab5dbe279f897b6d4d34779558e7aebd93d05b71add90de4a5483e80d82b4c4be083095551a070b0365aa38c1d8f77a4ab2699f3c2c21a332f7b8215dd776f6565ccb9941c76b9d1d9777836e4c5ae9b30cb63a0d5a7423ff2efa3e1a01ac9ba855f3d89104c982b8ce471aa46d648803c6cadb6442b669be0394a85faac9fad4133a72906e42149f18ab8c610899d00ff29b11b99cadc32031c49927446822103450c1dd41efcbdf79622cd2d3e0fb9b2d2ae5cabb4af126c76f4a47db6cd81124c667da2039c71fe777e753b5b6e351e3be937d8979c710189d61219819965f657e450d3bd522c83ad933428d2faeb189718ef4cf56d33a08358125aa471c1f142cca44e5a5b8fa17b4b5b7fb8dc92bfc04c47871d946fda168b877ba79424888b944292769e6a50942b475c4bdb52764b2718cadc0d668439d5c987f3094cb0d98b35a166c131345b191a5e7b8eb475807e08a5461756f147a1144716b8c5a66936deb7681cf100d857a77ce6fd7a41d9d4f7783ff21a0000c3bb2a3d563355063dfb33be2fa3cb32b6d8c8b4683f5eab7f5b17d8bd605ac3fc1c09b11fd7e709f801bab68c12e59f1f725eccc143c0a2ae1d605a759b65e26e31c0d6cbd05480dc49f0df73c94e64d0776c51bbae2d358f1cbc6451f5aeb027054200fa506d24f00cf40db193a77aae57b299dbba9b088a7f5c44493ada94864fc419461eb44b3eec808876dc1edcf927343be13ca03351dee42cdfcce1446fcdd609232d29a7896f98eb8068d5eb5eda1c6ead4d358ce2696fea0484999aecaf4f7bc272f762f78b1bc88abfc5eb2155b97684d1d34a04a5b624a4ecb3b859025f082cb6f4ea6ef99f81c4124cfddbefa33a3b343e7c8d0571ffc64aebae7d2ff55f6622678f2e6403ee86d45e9a58ebcd19a363e9129c1731cc372e860e64f90a5f2ed84cc75f9009580b6a25976d6d6317f3d2219717f46093efe5912d4603f504cf9e5ff22c6e0121e6773737c8a66bd0d8a282c58a6ccfb505523a682fd2ee3de07ec6f481a1307af351816df7e460f0ca8e1260d99670a21da2d71ff68de3e4d2ecb97f0feccde438ce43058bd1212562eda2732222f25dd31eda341b190e2a7adbbe32dbd6c57e96292728eaf41856ac609eed9d44ef6bdafdd1865fb550e72d4d552d6db1b393451d9566e41794b21bf35b4ad83513b0a8ce70daedad06b13f04b7b7ccfca6ce7767d5bd23f38eb0673f0b8a13248125c7823982f8ccfcf736399958aafcf4ab8e98bbe596072b170b5b9f805e6d03b44f81b16a8b93618b9f2ca11c80623e54ba382e402d4932ad1e87e91316a66ff82ab4dd04f863565ba0d2ab1df462b076758b21cf7d0cda1c582e5a11f3ce7dd2a12b20da55c8654141041a40b40baa182a94794c762410479bc5a19893cbf50fd0b8de418ef7046a89e2b13b1d76d32dd64ac8351cf3633e9c4fa83f2254568fca181caeb2c154cc2fcfedfcba32ba85459dc0ac3a8e1be79e08529e384e8865e2cf2a1857b42038009e9b7bcb83928dd03f2e0cc989e099e2e997973fbeda4584e8f2901fdfad8348f4f1584cdd0ad2836c5d3b9962a5643940abccd2df9a964f492ef8e64262da288de4fb9a90eb569e67c7249c047acbb500c007a3f369a2bd51c62ff3e784491df6c8dee9d59b3a1a4d5a178b937825106fb028891006d0a764b10c5a6e98f82dca1584e92d039781b5e99062b60d293bdb6382ea8276cf51c02e3892bb8bbde3ad633a41e828a16c314e6ffc0ee285d157e7514c233ad8612bc873deaad6843b52ed22c079928700fdd92f9eed694a6841c4985a91240e0e21596938166d24678527afe8fc05e0387fabde33a8e2eb1cde36c22922ba13d815585099dbbd02f81221e585fa2126dc3ba2b2da7e2098d6887a621acf94caf67b7393e12886ede56685755eb7a014b7fad873a9fc39ffb36aa00071049264cf8b0d0ff588807027a51e9687ddc6b27d25c7a518441779cfdf93ee35945d5feec91358d987857373229bf7e42df6bc4c427f0c733e868d62ae4195ad9af574ddf84a4c884a7ff82666cf204d89fd7c4fbea165e461c95becc53f00e67e1f0f599341e3e864c13a3da208b63f300c739d264199b6f28167387dbbbf6b0b88a45ce7f4d297ac5473dfbcfe8537dcdbdf806f19977fb126d0119cf3b2866ce0030f69f1d3c4acdb22c1d6899c7d8b31647758c9383c8656f8914ded429878a9d0198b8d8d8a4b489f2438d106da6bfb91a3804e546607843b859e2dff20e3331720cb4d088c161c2ceaf99353968b4c1324216385e33cd62851052603f0d369c34db886674df55dd788f74fa5f049ac45f2fbd7145a769188b0d92a640a7b6862f9d13211239bc3a6bf7a604785cdc737a4b658e7c1f676f30198824f3a84dd1ce1c8e7a0267d148eece2e3734c75318c7c665a3bb42c0c8f0241bfc5feedc93f9f0128bb12cc1e3e7523692bc1749aaf5a59583a0f19d19ef8e358a33cbee255694d33e426901b8270f9d915f36f6ee6a29ab5def4f992056f240fd02da8faa4ce94e181a8ef8e1cabcff2f1081124ecd86f32002394048dfa38471d2b8a39ffd97caef1fecc0d7a2a9895d0bc0b9e320f6f3cab5fedeb03a659a519ba3897a8270b2b07cdc62681fad1695e5c15d6e0d7b9a9b0ca873207293a6276793891d4f40867d21cf80c5ee315b7bd0e73a53d0c210593e0ba3c2f71098fa70708ace711f52b809ff7b4842aa48b652e4eff35255b55771addf82d039da1de599995eaf92f032a7be7f1c99116b1a23c5817aa37f9595d746bf0c090beb6f4c0355e6acd720a5a26c086376e856b9baf6dba285a44a871c648a4508d51636072847d8db1f9ea91701a195602cff45fb74398f237ea36a7a99f75d3a822b308063342c2f5866797c17af74bc6727fec64655426b76c2f2128d50c292f4b9538d213cc19d9f2955f7a64ad025fd278c026215cb2e27310d6f9df478e33927c0920157d87838f08f601f76c5980d24c838ae6cbed94d4a6b11915e40121063cf8aaaadf5188cc00b41cf475005e2be8510f916e3e518305cce1e09f76e167f2611c486fe36440fa7cb3e07a82939672065a28e4b9ad01a68ab73bc1f1c7bcbba75e12e02da36cbac276911694094c65e7cefb55fb744c0e25ae54adc12311025e346aede581ff6de43596215f94fd7884d95c86fe4f3486e44ef64e77b7116809ce22db77060c0ed4dea006ebc7823fae8c1f04159ae2b77bd567c48f078b549e8dbf2e11e3164d26c9921ba7fb1567ff0750daf1af5aaa99807ad6947580080f254d0e6dfdd495888dba53fc96af1adec8b1dc5a8bbb982036b23eedea72a6b27e92a9e62a9deb5afaa49e34d341a46a1b249c9f3a91dc56b12ebb67f3c49c3c3eabcebbb224d0ba4ed0f060349a38d3a631cafc9dc63709f0f16419d1bb38bbc7325a3bd12790cc4de403fc28b1cf49bf1969efaa2c8ed88ad159fa4ce0b15cb4f6c3a445d3c74d452c151e18d1b36fa0b72de01b013f8c9589c0b0788005b6a3dbf93a4ad2d7b814b9283ee7b4015d71c8845aa4a313566e6d8d59d06583ec7a9d8f5cd24825141cb87609cccdff2c58a28dcbd5e38ee53af17a02c8b8174a8ac2cf2e5c8ec3a185679deee09d88ed47cd81edf93a03e783e424c3ee7fdef2e5908137017580d1bdc7b67c6f2a5e330b302d4faad2eb5cd4b4e4a1df12d2cc1647a0adc1d40e0bcdcbc8c7585cac963ed3f300a2a20bb70d996b2b63c5db2e1b91f974312422a1929e952a18745fd9e8f9dde1b6d0464b704aee471207e4948c5622e17b3689adb4ff6a96b9895e7c75af6bd3ccfb9d0cc05951c152af4667b468722ec8e6f4d48e5f846c54ca9429ba47326452257cb8f353a6c703d0d4bdd44e848d820d3630b1d97648187a5592c7866e74e0cb4e34855fa7bbee48659c03fd71a00166632f97357a67e5bdc5c628875601b9c17cc4e9bb1d6bd591eeea5d14c1cd76cce75ff4b92ffec79b6a08676817c82e86a96a39c128d215e683f2194856f4e8fee0e2192af4b74eaf98d86ce3c7391d451d7d1067ab0253fe65180caee8adf5cb01f86ded93bb51f8232afa38c47a09f34485e31b6e5ce4b1a5cc85c144f3b0e23d786309837a3ed1a2d06cbcca781c9cee3e3f064afcd6a24246e2c7fda80ee5982da0ac3fda0bd58930092fe03c0c34ea874defc9ea49ea2ec40910b72513f4207c27b85a3090b6311726087379cc78063db643a30a8e659abd4581ee4551327f9ebcd007b427839cfeb285c07186391cba3562bc84679dac160d7851873bcc764d897bef88429d15b084a8e9f251658518dd8743fd0345314f77089a85054cc315ed37106646a5af446e25d0c9d9d5ae02b7fe530e9d5d967c9392734836a7300e72d365ba9fdc60a52f96cbde17bea3a0b58e57157e418772359f01c9627e09dbc2b4d4926e3d5ec0e1e6c95d70c28109856bffb3ddee860ec95d9a8d5ba557196a9a958399826b90f7209e65e589066ef31fc9fa86aa9d99d4c30f415c4e049245d8245cdc4e8e81bef2eaa9e2a87b78915608a108213d3b07965556fac047712dcf2d7ab78d201290908acbf9a1b2f061656d95f3aa2c5bd39688821e3b09135d8fc947865161b1ab446383c9dc18d8bcc8ec0e5f6cb187c4136e4306f66d7255e765ec1199f4ccf8f0b6f08fb21f067d2c7edb241f1fcf761e14bad2419fd00bfdef319ba1b7b1b8f2d9ed848cb86115e197fca20b4ffe839336b4e61f0f57744ea0207576a5b064d27dca184119a586e41363657d20fc41e1a2d4b182d3fd5c747ca90434eb5cb92307d9e61dca22e5014d7fd757c79f582d16ac592e8b25d46b963ce6e3a4133dab9e7e76b592bee32b0876b2640e0778ac8b208811054f5f74a84dbc9a1fa19d7c50789d8853147bf51421c7b30cda31b90cbf2848e62ac193024cfb62fedcdcef3da2b9b35e9f5753a9e494d5bdd05776fce9248c104d644a16340a51d6bff159426f169f27292959a85103d2a2c21f4e3c3f0ec1e0671b8a169018e1edf9efcc8ed89dbf6598aa87b37cd9af7f6f3266a3267b50ec1584d478d449385878892bea59a0265bb3369ad8b0c6b81d134129fe873704be09c03ddca631e1e63c19e227bb15656284e0c0647129cc64b230a26c10c37e90ac3f6a434b2ba69a3735f73ef392cef36589c7b6a1cde34e81720ff45dae51c0f614063b073d74428a6af8dffde70cef02521ccf945c4b60add829c41955388c27ed97f3bac0803190fde95ebcb8999a9660d4fcc34bca54a2d01a855371a4ad6e3f46cf69d9a811b2a3810a4250e056cefe8095decf32692858af1a45da2071dc48f178efa20d324bd3259ed45f5732bdfe002ab9cb15a472298164c0dba5ff6791675a2648d8d11ea520685772b038c6390962402ef33e3b55236089b471070a739bc3c3f7eee5c8af34e4dd79266aee2eb15a07cf4df09e0dc12ec513422b7bbb0f8487286b981593064f442046e19426638ea2d163ea15f57dacf0b37dc888acd6ef5439f9d9c9def070c4f31851a87800a8a34fba65e390de8cb6f0cee20246225cf4c43bb99d325dd393f444aa53e08b35fb04017703aeeb871a5037c40d9ab6dfc81b55cd7b9fd01cd14dd60bb4b0c3d5775949b2fc996c1b6e3aebf67ab789d1b13547363c5f90a5a0424774c00ac9bc133450ed600c94f1366a1a30568ae0b517331d466cc095b5d7f793a9dc8e2fbc1d07b406d8fdc3a5536995dab84cd0a9a9b4e65db75e9f91ea4733ac860099071d08e0111f3f8d0b17d92d2158bd738af2bd08e0e0ebff2e13b4c62670d32000e527311928fd4a316bc6dc7023585b93ea217745058b886f4ab1d36c5c6397cb5bd2ea468fa4c77b4517b78191464928c2f40d8100d1de45be9e217340087533243a5e84797bf092c8c4d9415866946c5acb8c6b127ca4157f681fd8a6bfbacfbd75849bf299dcf79e5c11cdf837592b541a6ebcd60b4f9abe3d50abec2601c2850f7b8ca119943e41d0a99b2fb02238517001bfb6b4659128ab40897b8a23ac615fc590354d5957752084ff3f2866459a7a5cc6df59948bcad32c86a3a2cb2ee4efb004891fb513174ecbbb36bab643fd403fe6efb45b93102f755376896b3853abb4f21b463cd95b54b4d03fc1fe09392c38e2944a29f7abc245f7ea42b500c5015e1226e8263e1d98d6919f91dc3423c9bef7facec485a94dd80bd9902a4a4c4d60210dc302f522620ddf2b9d9fe50f4f2e406d8bcbe58fc56e8d66e0502fece9a00a067cb9be61a823b9049785766951e7a79db1bef9d10914777e28aeee8a8121e7a3f57c5e6364c2c6a30d1510a10e93d8fe4d4aeb90b469a3f88cbbdc4aa3f57dad5035ab7bb4e95227d7f55d398afc3ad8d6cffc2030f9e9fa4d030631dd631b5d4eb7e94baca36f6493f4ee43db3be3ad1eb17ee12e69a12b57b2368038a0f4b666273f042786cd01a43d06614c0175692c0edaf5b5fe3df35eb0928842a72e128145d07b07497b5bda0be320f93946e6afa0e43d6072f01cbac7b909656ab3fd3d00e8e2fa581038193814683693e4bf149cc33bd4de1e42887e1a3e74ad1d6d7e67b4a5c4bf3f9de00eb47cc0e6fcde83af5d10b8f8e645b741346e672bf4fd2af02ef0d8cf76f5800a60da454a49469c2aed2bd59a6fb83a19b407c7893343dc103b7a832d663db9cbb8130d3751b43570809854fe1bc829265147c1fb617298a30b33af113be24799651a17a9c403db11bb4de1edf9347fe51ef25584a2afd5f61bf6bc1a341581058655a171a0cb72081994224bdbefa91376ab2d8cf7c1c5ba99044e9a9e56b000ced552e77300193692550a385a05262b189b12daf76cd7421ec0cec3f3538e6f2079b64271592fbba314fb163e99656fc29dd0ec9675f3d6cbde741de8028bbd3658058be0e31dd86ed35498d3d6a95d62ab8bf881ff3fae8468bb29c5a68f0f49fc153765dc49838fe577c95049954c75b4f0f32109430318267928d69419af1778a026ba511593821b5d92a7bcd27615e9e14f4ad8aeed51b5f510cdd28c8dc672975322408299b86e6a67ba06dce6ec5419d15b02857994736cec77c610f73c3c885569f4a7295b3ca80eb9daf6fc9c1aa087a953ffb60580994503970369dff22923ee5e740744debb3243d92a39792552ce1b5884c1a902a9a9450f308aa8f2606f9e2f5cb877ef7e1c68864fe7617567e2994656b5ef5bd6a3927b5078071de0982e0392ace58d86946948130d920b149e53841c65d2cf401d3f526aa5b669bcf31b396fffe2518510b9add0ba2ba3c00d198f2c32eda0e057807090f506eba9dece6ff8aa9a8987d7fcf22c55e5324dffc46df30827e1bdeb446436ed624c9a5b84542ff3ddb07313fcb23d7cfb74cd2872d2007f36339089eaf5394352470a17dbc3e423b90fed0a87003eb65485fb110d54c40008974d0a8bb0bf8b9a7a4d763e9ba0942fd9db70d8c0f7302201c592d83d3ee984bc1a6f9c979ab1c7588598b0796a1d12deb1fa1ed8504966a2b6ff8f0a7475193dd540e9b3d0e673d2929f54d09a7571a4a338ae16684f1ec6ef585f0969240d3bea6d58ae084999a80cc66414304269984a9ecb34ac4ac115e51ca152fe918a5b6bc68749faacdf5e948249327d0f3fe06f43b9c62e08a4772dfcc9b1b8040e43bf22873f71a45d3cea7110a4cc4e390c3e34717c84c29630d602a894a923d1c25b41fecf0203f5b443625aa63eaf4971ef67937c68f64aeabf25acf5ea5926d65c8466ac47caa077b8fd56d4f88776ea3f0d265c99d6349fb9434e939fbb1b6a5a457170eb258e08492cfc740de7d8bc42cabb7f9ef5f837f2962b0e39a04fb64ac9d25d86426190b129556a5a57aa9d485aab1e612b7fcb96605efe1e108c39f031ef31d8185f5a2f22c53e82df3c958e29cce65fa952e9d23ad32a53e2956d36a6d68c2cdcc86a123edd8b14eb9299d678aaa524b4cac57a219dc4de9a5bae344fd7a2e83383d66059e35cfe7ca80111730b5fbc074d04ad8ca71fddc71f417d3071122de0af24f16d4426c7599a2216820c362c75e024cd12c9c4017d12237615e94be15efcb76ebc75997caf546913a20ece9b9c7c34a01d0d76caed70178e6414f2a408ecdc03fbf5c2ac8adf83577d8ca56712a9eb13c0bb0ee78d78f4aea8a98e71663094d38162bcfa09a7ee0c430aea14aa458cc7ce82bfefa46d562c28fd6514c6feb87a095cfad35b6bec60f19872e9adf05f11293b73cbdccab75a68a837fbb75a00db043b07eb696c5f184e3f78d93b2f23c179f4f3bd39909efc22627d4dfc4c06d97f52d5cfe7546952d066fc1e54f8d8b02e6fddea6382e5592ca12c584c557b947f02e103b767e758397cb3cd2892350f8bbe6528582b5022409491221f86f16472b4e43da7b0cc06d44e89c2b02e82d665a8ebd400556cb4c4f84919faab1582c3cc0abc144bd078d5b7fac8a86df26c1b6a87721e135874328ca3b11902c04efbe3bb06caf8d224ceb4f0fca853be1ce61d427e06b1e59894e84c0225db1f455049a040d45905e01dd46259bf26316bea649c8fc3ca3cb175369fb735f36f78481a209c3f79c2db2724f130d5d6ddb598e343ae9eed27e121901e40f8096f80d1401f78481e995bc486420d03d1d7674d368ff88d597f85789140543558dd10b07f89a55208b0c1fd1d69e981abb845030c0e9508fd195671e05b0a1f6fd1cc09f564c7bb54573db130524db6500262504793e991918086cf6001435c6aa263cf78d8fd0120e4db6c31a964f062a552edb7fbe12369f2b3dab91e1a50f8a373bba0cbee18a2e873a53c21ff7805b0934cea0415ec64b261c5994ce09788a4cd1f0446e32429da29253b8e8bd17744f03dc505f68de19ae32bb53adbac3667d88442b73f092cea8c9d8f0c4ec51f5ed729c221a80c0bf51708205c8ef183e4987608b35f0b2a87a8133e245a958fa1e7c31ea2084a33a6edcbf224892252fd57621ce5770ef9c740799653218422b800e107046d354412b269c78b6e85266415a41e460cf26bd406a6ac7f6f58bac7703e95de217ac9ad8fc3ff468e7f2053ceeb6deaf677c4df39281f80d4d55856e2e4978632750cfe3e144b8f0a2451508a35e4076720ae42335468bbe06b6cca1a8fbc0245902ef26c0e2a721fc73d29f1c19823767362e667783951ca01e275bda16215112ca4b1426a96176723c11564ddadb5ca69d7d3ecbc730ac95a939bb1a6b7edbf4873ef3f701319ab67a8695a2eda37c4e4bb75ffe3c0cb4a5b0acfe7de2ef676bd388f92d7c5015bb8f01f0a5f35ed30fea37d8e2877f4a9a028cd1b325b257c1331ad00a0053a8db79ed9e16f64fa0ddc58494f6e97ea86ca1caa0f9d4fde5c9977a3fc1a0ee2e5b82ecdfe7934986ebbdc0ea50cdb0522dccac60cc32f19ed238b016aff055609a77491c1907347d9de9681ec187a7a1850e66f630b2ba6ae78f6470f013e76cbe376aa470785667bcbb860e594f4a1d6923a004017040e06b87a35020a91649ac205148e01ef11d7a550491765d75fd3129bda87746a22af15e0bb110b3f63633798aa5c59da73d623dbc73f2688c6b6d132affbea6916166aecb49207d0bf33c8286b3266a7999ae35d27d163c714443034ca1dd67e61758a2883f5708d638f68664d961cb8725f23f507f5233704ed56d9cf60eabd2ab500abf6c90de2f542dea06f123bba02534e2d1285aad4ef3d27bf0ab2dedf3683a522a461d6546fa6e028765b2077ccdcb022d0467cc9028f0940903be8b2805c12ed8c481381629b6db9018769ba17646bbe0385644bba7351d49573145dfb21939697af47f83b437ee62b2240e6d1c8a1c3e46033913e63a64ab272638e87b2df06776ce9cf85bc9640335b93ac7b39558538eb190d5f349b1070148487ec6340ee2917c4e307d788870b261b141ab115b5eebcef758d2b8bbf60130d82b738f501d5c3afdf5663d6b80460098b88669d978b84985cd55413bda3bb772750978d8ca7e353b28fe30c913520ce3437b2f1222ab7eeec9aaebb2d38183eb30030ab485a9590133c0de065e2291c582ec4b91bebded83ec1a4afaa86e6acd31471a5cfbf03b1dc9fc057fcf1e8b3baac4a5486418857be8544037388df05442b1886ca14bca9a8029b5ecc4f5167b848453c74d63c9f94901ad5c05e8d15a7cb7b2ecc0328563a9faa20b0947f0f87dd3b6c8e11b8d050e7e1617e976f9e8e28414326772ddcf8ba44bb0ba1aad142fcc682e473bed874e46a45d7d6d8b3f53f270e6eabd07cf8e50b42d16fcb9467ff7e196b594f35ecf87f49566439eaa6dd32abfb25f9f0e1000461734e3a76964f711c1b71c0c1e1a9465545bd8224c2f307fe7ed4ede50717c9525c35bff2d159583fbba450675fa16b6820e43e8c3548c583e6b978c717ba0e0052b86a042d28bc79c1eb70a998d518bfb25881e1631aec716329ae5d6046b8d77833fd0cc00031a0c6d4dcad870a928b093f4d9ebefec20e7e3b5778d7d336b1ecb1b62cd9833e920252f0d34deb46f6aeebcc9a1272af21971336c15fc2c6d17430885e131f36791b89ad3eaf33c0dc5bc3e6d5a7067ff1ab10d7f338104e1f608ef5dd75ae2e3c095a18bd66381c4e9dbc7db6cad579557fdd119cd2044fbaa25301edc9cdcf2ce4751e129c3696cfbadc82f5d06654cc7b914ffe9b03b61269c21dcf3a3d477e1d497e479b302320ac9f657f62e3df888de24f962c33277407309a7fa4a44d81b035392be226ec0a85ab4c87024297e33f3614f26670f2505acddd6cc0d8bf86d84a8ebe1bd22d4e383d65decd59d238d749f4eea08104b99579fc7db79832d43b6e82df53144b5f0607cedb9092be0ff271730bd768b30ba12f3738f57aa11718ce14ac852884430ba215b1f98bb197b32811a79084c9422b39889d3157cb9371999234604d2ed4ab64ce38928e59501de8e6d57cdf2326496dc83d71507e5212beee356d89a85ac2d780ec64524b94dc099f8c88fa745b6e7cc75de3f5ad7b923eb3f40830a49c0a272495277bfbb6173aed6ad36df3fc4216c3d4a11556339007b65ca50913535277d48586cf42848afb26d0585ea61df04b8fd417fcf02a79028e2788df12890d6bddcc313b64ad16701e1b673f21cdf7a883f40562a906c97a456afffeca436afdc783aeead64ffc88f1d2b275ff79800e85463b9bfa837ee8508253624a285e2ff1a71c5ee789e2207d28c5519bac09056dddfe3c8465427e013eceb0ab3d904f122bb55753f603a8bbdf53023e45c294057ce9acc39d60c6e691ee4a7a63274af162c1f087d10d80168c3889c8b245154bd85b3a377117b81c2c873b0fbad56331299d9a307c9967109f05d52c9e10df6366649faf5af984d9cd447cdf674fb507b0234eb6fd91a954fe0475acfde1637f69f3f8d3bcf7d99a82b3106760a16eca9ea9c726e31459d4fa855c346020aab40a3c0ca6a5019de9225d9aa8e84da6c744e6066fe301e410677ee2b5372c6e3940731bff8ce67f2903acfdf484caa813bc83a873511c68935f27211db99287c5c407dca7dc03849f7689e7bbe16431c183d3652e8dd9127c543b02d4537a3f14f83fa8aace788fe35dba5906f90e41761b6d656a5e8b4c7c703a78bcff386e6f19cafdf38958033b6f852bc7ef68760adaf61482b2e24eec539c1e8232cfefb1c19910a2b7e287cc010a581a2dc28684ed8aef6e5ebdaa307efdc1ec43e6f8ceeea4b5686e33e8aa95d7443fced352424e4dc7cd1d1568f1f4f49da0006bf5865d119c3fa272fb4834119f31c026691791b2b0a471183c5593496dcc89fc21ac4809a5c11955e73098b776cd9a78e53a78f2eb9c774668b071b8af7ec903849241ae8f45d99b31c6fafe7878389fb199d315645aee6ba15d2614e82c3d1c6885a72af1a5b3f80dd49608e8b9905ce06039eeb260a3a3cce8cbd46206a8c24973aa30dceb8292b052c6e9bfeb05093b23234dd15a0e3afd2921b37c204f99a56cc65f4469fb868c87799aadcdc07c7bdb97bd6ce30127c4be8ed4525b4800ef44082882166ea6470a10fb9f23f55a3574b5e6cf4e000004956c59c8cbd1c4912d0e5f125c2aaa24ff43444d65376474f12ecd5b8989cc257f6d1976469bd7450646f6477cd767f71bc35e5cbd1e757c9f74be9879cd5901a56f7fde9abcb07825dbe962a438aec4b07d477bb414f2745bfa98666443dd24712299a92c74d44093ecc9579ae97fd14cc35bed1e4878f214baba64f8efa765d37fb8ea67ea8e15e2696c5d50e6aa57a1a2a4ae5af65637ea016dfac4f667730df24b5e83a2e7d3f72e66e3a46c25683494f6a03d433fd371e4aa4cfaa8168aa9be0bf33ea22421fe8eb318c0a368af4b5172f23ef2d061835e85613f92e21da295069873c0dfb3f15c60fc89908fd1cc23f8feac8943799cd10883ddbf999f6bf82bef27ce053c0e402cde3da7e1b896552faf65432da886e132449beed208680b276ec60bd0b1cb817118dd89e3a69aa9d36d42fc9d70cd60da9dbacd0b19614f3d68397e34b158941ffa0d02319775a9e8c9d083c915c873b0b974c169870a5c1a547f648244c5a1e41e617325a782e8407d4a2cd7007b4695302de8a1e5c4910f4cd3102b59f9c813ff2d98cf158216ac461be9ffe2404ebbbf2811146207c6c2ca4d1e1436b3c73892ba4ab1300b9f350475ba1a7e92840c88332844bbb2da3cfd5f96e51d90180668e9595cae6de8503cf1b9440ea42eb1bc22150b14e9351475e3e20482e136689743ebb41fb83418fd4f81099b127e541bd4a2aa7f58d92d37c55b43f01ff88ea555c29d3439ac7b764391cf06af54153e59cda5da480534ff56f1e76ff679606177266095158b8ef26fa3aba15dbe9761793bda1c410ec419f3d7b90c9fe74734b36aa913d945b65c52640f73b5ee25b7cbd3475e51b828bea79ec268c8a7278dcd53e4c0bbf585fe163d1e4808e94354cb0c32d81e44499112f53a638420987d7a36dbbb2a7d9914689b18e75e80166df89e7f19f901b29127080a6124825f71e0a92ff99bd4e67fc7bf020b54b2c8f396f44e67ad50a933c2cf70782457eeb8aa535729ccde66a1b16682b798a4ce5f76bc48991b09907e8a02672fd28c81d884d9566e8bdb4962c8531c0d6217e27c1c9bdebb6702f222a2325ef26ce8e735e4673ec8978af7905f36ee68ed0a0daead79efb617463c8e4a4cc6c64a314c16ec49e97a7c214ff628ed4916aeb83978724dc99414e147da99927c61965388149818c6c75178b1ae2bdd93c07b05a2e388e9f7bdff1ff5c9ed8cda8cabe833727df719c992bc726dad6eb97999ace666f82246e5a13cf711197b8af707b887abbe1a5d0184984c68707e1adb8465fb429b2b9f95230afc118c800dd86b27d85d9fdcb56425372c6bc12dbeadc48e142bcfcafe2c2a7cbecba54b74d47383bd6869b13fc9d19e7629536041967fabef320f44006164e7324e2f50d00ac7583f028582c1623116195ea4797c90bf885f85e9a5f188286c552d3320bcc370e57372a97aeb10e3699703b4bb08011d63509bed8b8290f69c8abe478b33b8aaa2f7146ce5a1debdd4851743689875d6d324908244457e018f239eed6be2d2f961c7b0353f12fde999516883da2f679c420934db90c69c8de9361234e1737c3aed2fa165112ae172a8e98faeea334c127410927d5d4e4fb7f3a5475922ce5bb51b5ad041c0e78c79159437456c7cdccb1f88186c409a7a18fa69fd2726bf46093f583446edf758934d6d27d9003b058e3e2231ca0b8c0fab743da0082c7a0a1f2aea1b22b67b7a6e79449ef9f07967de6c67812278e87fe41583f51b77ea028fd5db341ffbf6a8c1d4df6f01377c6681299b90fcbbab33d911468aafe64a8db38803ca0676beb3388d2428eba5b9d3717c327f3bcd2f278823bbfa34e315a69ea6a48c1ebaccef461bd8a4d089a1982829c0297ecfb737abca7130b1a669fee816e26e56e52b021d4694268354ce8f31f22b82c8941c47684bc2da779479b0add28d8418fb6372d1bf80a50884497a3cf8514dabb9b015b86d9da22ae988036532bc9c40e5ee29fcee5ae228c859378a2511b0186281dc70dbcb4385bfc11688aa6f72e445287115a3d69d5dfff0e3ee66e01f2ff536172e84d99b60f08cdbd6b3bebcf321372d1209a494e0ab1800cb50dca038c5f66c1aba6742da7074e283f03a618369dd9d43ff07bf9d8b16b6e0e3a52c5373dd379c2a7c222a35e2ba7240a95fb694408ca2e2a23619752007ce72de4613a6ff67e3692127e5f273a623daab13465cf489dea7f7994be83d314b47219ce8bc5e205f79458077c74ee490bc4b20c3d9b3bab587c51054db9bc9def5711e07cee0f924fb7a557eb5ecc2a62915352d82adb1da0cc3b4932730516899da8d1cdafc9d84c7399bc686e090c075bb563446f6ec0d96aa14d5c3bd7f69df688f8bb22e7469662e254f8d2745b98fc35e63fdfebf121777c29f2660fb9be6f11ca97c44584e289828862f7dff25160dc4aab08bd0a7028c69f52542ee61830232644eacb2b90a7c4694f9b5310c12d99dd50e6274779e86b8b510029c8bbbfadef9764b1457d9d2c7066ac150ef4371b9934b3ecb2e7de00fe1f36d2a69cd3e1d0de5bcf0007ba1c9597eba6c231c2dd8845c41910170f92613191b4937ff730f3e640136fef11e5725ef88ad3e093dc5b5734716df142f1fd0ac5cc6de4379875e16a19f765bddcbf4927ca1304a2a485321711a3071dcb7e6d1496b1aa31a1ef599dd2029bc944db77cb449963f52e3902acfbb6a2607f2ac0169a2be40d3990fed1c6e3398971c7270c55a26d8a713b40fe7a1f474e5909b10de755e82d576cc31ffbae7ecfca03967a14800b4930a07908640b8b4288621c569dc0ed8f53bda591d5802706a49285c1864bfe78588c6e1cb1f00fd9a449edfbc7fec75c074602c82bceb1a54ba0a86b3906aae77d8a42a0ca0bb620fde95c5f13ddc854e806fbe1dc62160f4028521033dd5dfa75dffafe22eebf7018440d5832145b3dc67f6db56b2577a0d26313a5843d4657517508956911c41cf23ee36219d71561dda3c9c90eef17f3984597625f76995736bd04b5d58deb3b0f1eb6e43be19e60d4a8222b57341018d75cd25f16e678dcda615319686bfa718c2c0a7cb4ffa640a3e8f22bd730dc6eb0c88925b42fa6e229d979b027876be9b947aaba950ab618e7ea633665a3acd1a9aa092d5ac21601feb9ea5ba6cb69d2e016c7ed46deadd065e6baec87784e513f1938632a05f165173f138ce3d5ac66f18403571d8678119668be225c100597ec0400f9cf4a98d7ff8d0c4acbe95f98bf98cbe3e9dc03943bab003f9752dc08a7f445c95dc68d1383c6e848d6fb79fe490fdee3a973f494d2516656eab0a9d0adecc1dffb8cf356f33a35ce5a4bf0560d94d7e2abb4c6a3b1a786e53d7118455beaa1aa5cd2a9c9fd509f48b108f4dadd47a9528a24537a1661ebd3af0d4285a18e4c5808afd9d806448395888cea7bb3280bfc9580151efdf8bf8de69bcb00c6b0ab345617ab0fc1fe01dcf6c772e1ab0af91c244d8010c35ed5c0801ca93c021068f4d4ee1a0977099bfc9613d6088c931f8471418a8274aeeb591058270b7037aefd56a2eb8ea6700dd5c500060fe6b985924f8a44d3b9169971cf1398947aafae2ed7a5e60063bd4ec4bbcf40666d863c32be5bcc3ce070af765062df0287f4567afee0abfe75db9569c476b4ce6a263de419887fe743e62feda64057f5faf999e5b1a7c167a8a04d5a5aa5930ee19d5338e826666c409e26210fce8722228c576ea4cc7c05fe91f69b2e94e1f912f84e1c3d850fec0a116a1d437813a74f03bba7825e293148d8b5e1cf81a0a70415c77e4ca187779d6cdbdcb32263384b091a827d297b0ade4f5113168208674af55316b145f4e03f303003fb1d0038009096e2cf2d54d756ee839fc834d1a4478224d669fa40391c82805e90e7346263f1cfb07ffabb593a2acbadfb1954e8351a5d8f197f5b7d03b3b9b7898298f347527008011525adc1d91e4f58bf3c169580ea5357a0998ff22d2cf830421cd55fbc9e9e80129cf3ac80087065758af026eae2207e96aba343911dcb18e00faad46bd517c5a796fa4e241626b932497ac96f9b93791aee9ed69f9a2f87ad70ab1a5574f8340bd6709951ee1e70149841023045ea1268512c9a45333eace6dfc6b2ba00d8c680ddbdbb47281c8e70217995f4c085964777e78fd4b0e07422b38ddd73b086f82a48d7c4d4227b863ad26becbd34784bc3c7a280c11ce15bdc0df610034ae8bc7638c6a5d45adcf4b7261b8f230c01ca9ebac661b304b056bae60e4f07e405a2b228194e095e23dc248edc33799919eb37aee9f775fcef6b6485f5b9c1ac9d4920a3d374e4bffde1940f047f5e22eb8e4dae176f6f48d1802d5db307d18a19552e903bd2effd7f2df96821646d1dfcf192c5ba85cedc0776d9e1c0826ad8a74afa01cdbdfd3dd19b319cf103fd5133cd6ecdd0582f9400980e7192bf9d7425eacafdffe1e1e001373987dd7e2a990f212e280b0e2432ad314e492f32d0cc57d93b54078e20922dd85bfb46889278afb56e5bfc2d4ef4ab4be48154bf787565b6831803b0e778c50590b78fe8da362881fca5eab63ab744517dbcc29f214cdee2fe688212c45bbfefeca589eda2a26af596cdf9f21ed2b04a37b9363dfb6ee9010ed855fac62d5d5ef6e438ff605f06f054945c0e6580dffd8f748a9c7aa176a06631cb3a5b2c71cc3aa93ee1ceb7cd291c27f267eff39823235bd401f3e3ae087f85b000bf1a603f68f4454978049488e5df03f3ce9a36f812f7300cb7601d9daf84eab64823073700401961e679defc2de107e2f6747712fbd3a59a1963e3e65791d364edf2578cb57649fbca7cea4bd45f333211fc8abf838ba839e084f6f0b75638cc95c4637543c59f8af0460667042d99277a6fad3fbba505a88f84438e1d8f445f7ff6242997e9806afbfcac9232d5e6444b8539757377e0bf25d51bbd775bf31f3c55c9b3f0a0fd94bdec08a778a74d7f41e7389dd862b080ce2a33f1966957c35f17291f865bb94959642542531e552e3f00602034c68fb3c2a1aa81e3a1fa6b080e99e99676108bab764ac5b47382cc29f3749be3fb986a1a5e27a752ced9643ce63707fa0624c58fcc8d3538179605a862919208a51ca135c664fdd3a8c1191c5b76fac49db632e7838fa5bb9ce3810215128e85b71327052a5720eecea140b4a300b8caec1b07efc29aa1259071d50e17d9099aeea6c8150578789bdd3515fa2ab68398f9b74c3f5301fd586b612f44fea810dc2f7c1b1cfa55efc0022ffb8fa9d7051a8724e2773557f51df640e372a42a77b8b4d61e8194011e94cc331240d70e2d3d4ca9cf3977d4a2dd698e5887a6c21ec2b0fb73deba2fa3c7633bde47f9ea6c3ec2576a129300df300dab002e9ac64f998c7da13961cb3563b1b7cdb791e99c8b76bd3b696ca0c39d78736c6290a15b9db483bd562155776dbb7800123b9c6d0b9009e73655b81d35b05b0881a31ea6e0635cffe4dd18b596737f8e2b1360691af5cb3e0db692ed70cf9d0acf7d6720222f1b75a700aed12aa01d0b0100e772599a45c9c8d768471a771e52d0401f81cd047f945f35d58f01336d875f1920118dfc61762bc4488fa4236f089a6f3b70a694a79fac9d75cfc5ba573846dc1677a456cf2bf8990a3e754d82d59f69cf9b66a82613e2e83225617fc611fef9bfb9d9fd76ae21c6b9f5eea730d0663d86c7584cf7837104a81acce746c3883d3151d5f02a3100747e15212fff2f8ac275ad034319633755c3c2359d1431cee39be80821c54f528567aa13c886b9923010e74455c5c24addf86b8a0a9e8765a222aa6e59fa9eec0ce202dcc95205cbf83ec699dcec8a88a056be8a18313e6146171e6d70a200ad6bded425801e512a4f134bbc83110eae991f09669552121ae8ceed369172cd1d884d8e7ad85d797b125159cdf4a4e6dca03d7831511b2ee97eaedb99767aa4717e5babc73ea52ad0849cb6cd4a9f7b7f35bf62efa2e4bb2e28901d44f911d0c7d23d4d88d4d28240c94117304a285d906041d3b2f39932b830210874bf3020c72f6306c61f807da5620eb6c04cf6f2c79bb2b20cc89d61ac7ecc6d5f41e084c941e4c92de6ead40187294cc43bc784d79d6801d8c6f58a47888dd1eeab88176d857d5032bb18b9f6dd25dce509f2d25adf76c1496746e0dddf38478da045e8326f959630dde484fdb51dd70d9342edaefa08fb6a591614c1848b966c49173470879972ad17bf1e56030bd837cb0300568a51cc42ff5dc970d94c8dca2e2e5869686fdec8f4e1a7d6b0a7b368fb5c454edd8b7ed2fbfc496b49498bc354d292c86841e2032dfaad178bd1a855fc685489822f02e83ff07815e3a8279402fd64f2dd95101bf1c127bd995d60088c229147f7f0daaf40aa3d1b8d80a8d2665d3189c8bd1766eba41ab25bb0b41e6cbd98f147b2d5c4e87803435fb89b4a5565c050253e04ab516bc3186367c1f154ad06df840c9965dfca299766876d79fbf99efa719642f9a3e227cb4841e5204c00c9db3ffdd65535fe979b9944c935e3bf03736861b253af71702fce3c757b6a2996bb5cb40caafd8de26cd53da188ed95436e4e297b7e50f16fad961a340a9b37bbca46e104824b480a01dde1e77ba23680ee690e8a80d14f1053eff46bfa48ca22047ebe9b219b9746e0f31605ce1bcf0500552eeee5945bcb2412082009d83c437c33d749c242a0d1003e250be8f43bde1789570693778e9e3cb6237e876c2c022ac36d8f8eb24a80810bd190a179cd631a3a7b5c85e9c4713bf83ecfa705d2d66179e99cda12d25e0ebed713c378841e0bb92383f024e96b961c7f53041c95e4eea777555113c74d5383078bfb1b5e2b180ead6cdfb084c63bd223c7eb89332d9a046c8793d166eab698af40e102af219acbd94043dc1531e3b994d15a69de287854365cf37192cba4f50677202df673abd064f5850ed35114a90cf8bbbe565b6887569c3467cd52eea08eb125fa9a6919c6d349a25116bc65bf771dfb15526e2ca892c6a87b62fefd5189988e9b97550be146d57d4e2d25993bea4c6a63c814d7cf0701c65bfb80a564d2363fd5adfa98647bd5e497681e5bcca4e3026db4dc2d38f2d0779359ed4de5c50ba71adc1647abba4dc8a9a8151ac419113b1599803221de3fdf55f26360e23ba9b4478a7154e7cd0563c47fb1230227c2cdaec841a80080aa1819720c67ffc7ae41c225a0f2a5ad2047eaf903f47c829a9acde5c56ebe007fbf60ee3e2857b36070d2f9d540de94e16a9c9b2ab4af49a77e569e5754272ea5e6236b8ac5ed372a13860ad8e26cbf08b02337360f1f757ed9b96df76de9e76968d862f9d93826dd823f8e88e2e4c7ae37250dacbecc73a579eaabd55b1468c573155f5424180811dcd7d3ba841887cfbc8f14769771d0ea688d071f9b85a420196d3d579a03328c1de6a20df62f803bd89473f5f1dfb31516e911176d68668f1144faf2296dbeb1b319e6c9d843e117b21a899842cd2b9ddba9f27cf894b6c1ee6b035bb7affbebdcd30bb3ddb62a58f5b13c280bbdcde8d3f2effa0aa463c1da08dbec5e8a2d7e1857ea848b52af09428ddb6490bab93e18f3105dacdbf1ebbb9c496ea30d361edd5eb4732731632f9b29f339209035149d4172dab4c23f4500328483a199ef3bd2debc7e6c295fdf99e230ed843272851ce256df342b626f569df3dfe9388a196721ce681b3e1d4d41e9b459afb6022d65507893add8d03d826694a17518028a7a2b13169bd325c29405da7823114ad2434b705734332104aef18a2da604b158ad8ca920c4496ba338f612254630c39a64354349cfc20ecf2c07ac5de0b72b42d77a0fc7a99572425450e701260b8cccb49e687e24df9ba4914f318d7b5b50538a55607068c7f35306315e1826f4388debaaf506bf37af0c24c10470a0cb077789b54ee51e687785da795a831de98ab33d9c383ce1071e05a4b22b88ecbc1d7221a73540c35b2323a36b14e12fdaff0a1b17cb06e7314ff7515dfda2bbba9c60a418526278dd82ba15e9df9cf130e1345bfd9a1fd6c5ecdd0f963fb9457b2b9a5035f23db14b481c5d2c56fbd08f6f199054f1258f53b28d053d81490e0d337043c8d4fdb12d77144c2a1315db1cac93c56fb67189c960810e9b25ee76d15e416771c9fee8ae35d224ccc636d7e0b13f1941fe1fbb27584e38edb93489573ebc7f0d447980269b65127f30567822d87e94822506ea3c88f9d94b7de2b36e041521fcd16494667685ea28762b495fedb7d5b0831aa57f0ecef0ff53305be84fb882a64739a5b146dc88301a3aa22241077d7c5d5f7d3bbdd7cf82892d08e603cfb094475b31c6d128c3db11b7b600e4f960563c7a3f08279ca894559283cc4a54f1ece73cc077394ccfa2f0b2083cddaeda3d2c9ef3be9e513f1cad23b9ec6f8612f9bf0defc8da007f595b18358214785df872869df76997e9ea1f4c84c93a3a76ce8666e99bc5bc243fce1824269d77252a99dbbdb59ad1531081c790717e0ea9cdaf1880d5a096ec5fc469b197a93d79c1b8db920b1a7ef5faaef8a09af003ccec4c3966bdbc2adada826e8990d1e3ce6571593fffc346c11c519183ae6ce7de4b95d7ec69ea8646ee8cf8e4437b849436f30b450eeba14fe5c727ede9c1cd72b47ebfe3204cd0469b5a6230bfa5689a2aea8b3d34f5d6daa3e257579f5a871ccc66a961f0ae9816cf12de3e6acc3058593ab9fd0ae54a8f47c0ae0a0f24cc69adbf7d6d2682fbd1a768d0e65e02b2eeefaa41d8ce7bd7cd6fa0c1731999373bb71511a737cf8f82afdff28d9a298d5ca835ffff05b3d00e95e5550fdff406b9a0346ad2626dc077cabd2056c27c00918c3bbfa9f4df5d244fb287317bbb09bc16f9b3d57511f6528e695224d1a88293f0c8def3738db71acdce9b68699e12bb29fea5489396ecdd196e3250d307f7d45b492f53c4e7cb1abd51e0d937e7b8e2dd5896eef8ff29aa5919c72b7b8fb141ff9e5ab11436d421bdbf7308a22c0f56459b5b2922ea2664b56b4af6ade5a7a11210faf586e92c957ae964bdb63bd0074df23b62478003a62e259432779219f580f6b10d110417921a8f866a909c833e96d476a7bf2305af282640c2d440c068683fd0550313a297afeddbb678676b38ca44b607e60d6ead98c23ffffd63b59cc8f08519f53182963e5d0e576274eab4214842841d9b8f3ac3306ad348f8bd74108a63b4e1f421d43f04701a8a9b3cd9d51031efc3d87e38b1342625ed059358366ccc2eceeddf4d0f9c0058328166f4202ec42ec8a5f5173b7aaf8296d5c5ab1c715675befb6fa885579ca97f13abf124815dc8819a4aea6b6f3759f30c481b6fe921f10634eb18a2117a32b471c50128330918b50b3a1247636b6411845d137a6f6ccd8e1d51b321633aa06968f8f72a237f304ac4928fd879ee72aa6901dcb7ab60018796f6bdbcf582a5da4e25d7c2c8154b3168b55f515789dec9475d2035c880e4af5294f7310fb7fa8a3f92f963b43cf2094cfb8e40e03d065d86845e8cf60f9cf6ef9629d217590769ccf9e55938def3277f6049df2d844479ac954e21492679966d98bd412f1ea6ab6f087537b8b28df5023bd56152f806405513f306ed5a756f9121b66d01581402b2da817a2ec847df6bedd1161633b7a1a7b7555f0dc718e8c073bbe3553eb8c181d937014f437e8c2b47fcbf2a667ccfe255c9add89fd7069c61b48a34ef9e13e8b25d403d9b96997d39844249c95ee01604ad15833927a50b299d4a5755d0be9690d51884c36f55a16f796c401d2edd406a1a3c3c60a6b7e73ec1750cb7cc997c259afe41562e77f202b47c80a45d6b7cb8afc78660b06a2129162608685d7814e7c015e9071c0d200d1d52bb790bf4059a13e81f205cd08ecfaa843aadf6810dfcea494c6f5453318c612b1eaa16c5475a7fd415639342d02c9d9f00e3f0af90955e969eb36460b24c6ab5dbb8887ce801a29cccb3bed8e3d647b41b1142f02658ce364823632c563b45856041e5d6cea74faec082aa2ffcf58f5c8e03cf329276ca1baea1e55b471cd63a1f351a450e268f9c0b81910cbe94bd0fdacecd0e3ccb50cc878aead88bc232f9af76e0c8fdd83d1dc5c308b70a858fbe09582807a9f530624dbdc39857b836604365fd482b4e046bf657814b3fab169a96be1bd9ca0ffdeac212a9851daf1690e5c7f382e29507cc769768349d193b5bb77bc61fb5cbd54408f0103a8c49742ae5dc4a8ac175d27ca068184fd79df5b938c46c73838f0bd702f3d0198d20c881da6bb6eb08660529b17d25b8ef93775fe963b93576ab288f3735dca5a565a4adb785f043c71f80bc7ae5b1a363e884876af03c2438e6ac98b5af74d6d1e92ce600cea6d6cae673bb9939d95c92b1fdec88037a82fa821b2a018caaba5ebe83d48fd4c6b85a2df3e36367dfce5c159f7610f64c923af5d08e2e7d75038fb5d56b6e1081713d45628b945eef4e7a736bea2a406c8e7191724dc85ecb04eb1fea89aab1965d2fddc974af1ad6e9f5ed88affffd1bc20728ef90d211df137eea5c1af2384fa171a473731edd6eb838f4a7bb093fe5186193c17566b1249f4cc616d50aafc73ead1a7a58c7f3a319834cca7c5b6106210625aed2c2689990312b66e3bed9aee4c9955cb9aafe8632475859c72629a6c67cabd2c811827e2906d2aed930930a7daac4cbdd7b348d937bf1e49b1d3fa96f84c0088d99c02b03b018920ab6c98d5df6f4a19a581330455f12599275a2bb8dca374d44297fdea7c55a0e3aa3a2b23593b572b06cc236c84fafa823a6e097629118215b2a35758ed5284ee10c081aaf738df48501c21bcb825d45fe8770bdbd72d6c460138fd9779cd324b717911cdd7729de1d759413cccbcbd757f07471801962409c59271be835dc17ebf5d4eec2c88deb5ee7f90a1ae201a05d7e5b7ffb0c689660c5d25a8f8e4cc8c8ef49a3d1007e1db1a3e613a1632be3f3ea8c4c1621e77a8ca99a53189d1160b83b7eceb38888809331fe34515799e93e0ff4cc163e8d9cb95f4a7c4a56c9d1f9748089363c64312a4a06372c0a1c8fa2cf54fb9e1802351107614e6ed9905e798e08023b9f10f9868f7ffbfda4e9f70867edb219da947d4d1e39b4d876aba77efa798eef384ae58776896fafd07aab11ce90133a5942d7dbd84d3dbfd7d29bb9a854f7f6d4a9b9192494c737305cfd93522b81a8030baf9759c9dcc6696d8bca70cc168b4aeff7117fea12adeb418437a3c1061c752ed5b019ea003cfd343a1ff8a83a672ba3296815ad76aeecb69f00e9c4f686b617ab0b4a5e1201e0ec5ce10e54cff5080ea673c5fb685fecb501e6cd8ebe9de686bd52b199390a49bb0874865adee23f6e94f3971b6706bc69b84ae679ce93292583cd96acd09d65151f31ec8b4b7c8766515726d2d528c3d2dd56ad902fea55b5c4cb8f922540a0e77129153b81d14a613c288591d3c401447ce375efc999c05e07a3ec1d3cc9e9001a2b1e41267744260295221094d16c8165e5dd06aae9e5e3ce7ec16ba7d0dd1917efd9c5cd60a80f0472842fb52b025a0a491ffc8c1a1bb52a34ca22fd0df8d9c450ed5cefa49b03233a3197e56adb05bbf3ec080c0f79d597e0ae5e9d80e21af0f39be364a5c6a1708ffdc14972ad61d2839e7ddc1bef6993688d87f062bfc6c09fe867ba2760af8560081a2a317d7e8c3d8f5c329757f0edfd0d6b81b68474bac58b7da426fefd147307fd67f325271af6316351a920eed93ea20f1a64dd3501df36308acaf44046dcce597e7de893553689a44795e12813f2c47125fca47968ed8548df17e360c2c4d299623e72242f889331e03d2fb27de03c79109d08b3d14421b0f85fc8d90b69ed131506f2d7cb8f8d1afac98b05e87da0bcf2c002a5df70224c62fe92640b9e976d9eb07e5cda94e9d2062d816e838721d1079b2b5bac683b96dad9657bd5205e3ebaaf0f41fd601cdf3eaa119e98ac9270c465d7fb49201433135f229593694359176e8b26d32b7a8b08f9f60418078822f908df9709ec5209c7e47e0c4cf7a1e7499e21325bf665a6390a845443758dc10b749e9fcadf05fccd1dbbbe46b2711522b5ab7a3818c14f2a2ac9922a09bb4a2f0e13dc0344be59290a26cd8a5de87458724996994ef95563b5463b83308a2e5aa562f79cf548a3f314c98146e5e3b31f62febd213366fe95937966b1cbcdccb1db734e105343fab8e4f95eb4b3ab8d68e6a3407bdc5b44a62048f30630938c2f1bb57232d0b2e9869adf97e80d284dfe8916aa8389b4ee8cfa3806c82b81100b0bf4f07768202c776663aca05ed64d61fe508d37e000c4c2686cd28232760bab04f8b889f32feaf5c7c4c1a0d7a29e5b4db48a59d0bc02cbaac334b6af7331954029e6cb66d6dba168b42f365f3acfd4dbe24fac3798948648c4c7530b9fd0a8e00e7276e786b8764480e8618bbed5e1b3da42f564f6fd7a71013b2c9892b098ae725b8389d87737fc2d25d5bed422084f88daffa17348351ed2ffadf33ebd933a73ae4e0f66639d6cff3a8f624c72ff5adf5d361b194d8ef9ec33374516b6a73ef420ac4796b68909a337830af837795f069796bfea24ea6f73333e09a15e3f93c8a723769fad742455be30a314a303cbb542416de07fcdd9e24e96902bbe48b0cfb2eb6f9ff7ec49f155f19fd24a8da224375518c8fb66636c1e9482b5710632b5a6e1ca5f907d3fa7dd7524d4c687f3a184f90d78d42c5f4ead04db40ad0f6fc1177ef292e97fd01c59a211fb9484b5a82c10d1bfbd2c387d5db7a27e6714761fc07adc418cb69904e96590d1e63231690bc7195b0f7b7095fb98d6709c365dba62faa4e6dccc86a0c1b16fe703a6b3cfe1798247374eb65d71f607bae2d6937b04d285cf3652a24c11e48b5e379d33c230c3633c8a10c06f16aa71dd26dad47944f22536ae95e12077cd46c0d2d8865825383d4fce0a13c46c6190883014dfc9fcc0c50fd46a993843a52a109bd6a698969fd84fd179b31e2e1b2c11e1f3c3b133bfd6ea88c25e241959a1fff65f585cb696d9c846115bb3c41e3955f21e998e0261d973c257f0ce084e5b7433ea883208f4d3f297bb41842ff7361913f757b42fc08f9d8ea4d297d33af56a1dfd1efc22498c9770e1190db0bbca0a00870ecd40dae03f13aefa37cdfecc9ec1d128b4e20f52587e160284ad337638e8cd8c270c08c17fda3330f9e534528c15b0352ca01c101c3ba8bc3291515463529ef07c9551b1c2a8a89da8625504048ff408c5da526910683ed6bedf4baf910564b4b5bbad49379c246c9464a6656635ba26703e44a4cf81cb9365fc5b7384bc510de623d09df37164657669b8e32923a85049f259fd2f80df6d1a236d429ae934c3e9fe0894779023fecbb0dd4ef52af91d8ffdcab9d19ea50f757eaa946268941cc72a6fd5e0c438a229d9f957dd28f041f6380694e41642eb105cd2c01767faffcab47a49ca7f32518e91032032061e919b6f562ef530e11b1bba3f7fd774e743cae9d145bdb8f9bea67ed310481a383177ec3e4fd9d303d83827dd52d0297fd56b665adc0ffdbce0b34460a39f9d49b9ddb19edf8769115229c48d56f52000d282fb2c6f683f6dd80994dbb94a70ae1e62599ef4f2131208d51d3dabaf382fb8d398b71219229148601f1a0d62632d3f0aebb566f7db9f73a1fa95ea9728b4c4ec7c22d007abda7a209ed7b5f2f89323c4186cda29a873b28e60bf389db10054fae618f329bc48ed74e19c526121c6de7ab293f49afaa794f5ad2d8c94db93537998ab2626f821188009d6fdb597bf21af0307ca41c31dfde0035df5a7965045f07d2ea772f6fe1f568c37ae4154e4f8fadda6ac602630e97301dec2720ab4efc9e89300fcd2c2b8c649a00d0204f3f61e4492efa6ab713988bcfe1c73bc8f8f5ecea5f57c75ca39f6936b6b8ed1c25b28b2901458f9dfc2592d0eeefa4dcd7d3b9763b24c55bdd876d98182120c39d155fa6f3834a43f70864a874c6d1f2fc048d5f64e4e6b130d14bfe4ad92fa8e650a45e997ecc6f0da10d72d825fbb67f72334603d829793b8c4fd53c5631c0a5b241f3ede8b95fbe74a235fa5276eb7fb99bcdb5c5308c4a6cc86d5413cdf2e84644dd91fec9aa752827894020e9e8fdde64bf054ca8cb6097b2e7e98135109cdf074ac111a914a140850565ec03dc1445124709422548a35ee6232cb97359853300e8a0e8bfcbb49bf46a9053917b0950841417f2364c8f7c0159fd1013c77eb809a31eecb5e0e8fcf313c599e5f2d5e42380abcb7b34222bc6ca0699cb3dc848be7386267c416ee922a44199a89b8332fffc4d210f2ed9d58370b2db86ec6f9f15e8651764aca1d69c386ef37145f7d4fa6049a4f9b54997778ec692e3d7d302c20c409df3e2a82a85775f0867a0e1ff37f64ecf32fafe3d9170153ee0ca9b4e8c88d22a82652a9dceb8f44d2c91381f93c1ee1ab51ecd5eca4abf63b050fc0d44939e350fcb7d0239ea3295dc3ab205b373410fbd6a2c220aa03942ce600189f2f84d87f4689e6842b5a34450320c64baa8eba4fb2e893307160f28795732009bd50e8b6a42de062fa7c7423e905d191f97503dc4b254b44fe8cd809d1736bd3cf3209120c36e4c26a5f7570a2bd3ffcd92f20721f88b2f24ed0b226cb14fd983e8a5dd2335a7ea14859a7824b53a41cc6def8ba2f4260a364fffa065caf9ff6aeb93c7e0f8602b0ec3ee324b9c8bc50ce02b95ff39517f64f8283a8936798224667738f2f3fe3b1e8d22f28267702d97c2c7ed5b10e8c647a6c9626ba8bb7c9564c479e9fb78539bad0d5ab7311730bea4aa22ecdd04a40d97fb5fe1ec78115cc8fa2e75513b0f2ada5a3251abf6e45822e437d61b88f72625d7c52eb54fa58e839542b5397a5688103f42c58739e3bf56f1856d8cb68a450c690185669e4aa4223d835f514c870ec9d927a1c4d3bd54400345dbb41ca3c43da4ea59150ac906517a8f7ec789bcf7243673bb7bd93dd8be12b13a5e5b9b549de88c5a055665355843b45fc356a6accd5ea6e2705ae045f8d107b16a0f928fc87764c9c89946f83a444159585a188959cc44dcb70e92eb087909a3d915e1de6cc6d23105e94a4f33544b0e11bf3ed17ab576103c7176d9d6a45f1463d024a7fe42e1b07ca91a1f4e4a506c3bce2a57bae796ccce82bd6d616d36e5d34a98df9f8aa4f4ba3fbfb5dfd79a44e68d2038d51aa52020f13e6305099320e5735d8573811683e3275364cbf79c01742e85f4ff58c2190e153c1e6f458d6da86457147ddbf72a2d0921ac721b136544cceac511bbb8b771a78347dcd2eaf6da6199b8dd8fbb84f05e34e68fdaac83e22edcd9575b1295786e424bfe47ea5b2983779df3ceaaa7e1668337e2aa76cb6fabeef6128f2ddd217c572403789c70dca2a594d66b9f17d1df5eaab3bddc5a852487c7f49ca1719476cc2be8b8f3e5ffca246cd3b1e5bec5232fe12a3607d75e7bed79ba1a413d158eec887ff74f634fa8f8882dbaa18207164de44a9247dbec7d429684bbed4dff1fb1805b5e78eb3f0686f36ddf9a6c2536db4b20b41f9f1a77ec05ecfdd252dbf3a96778f284454ffa1c1969000f0a33538393b6423017a21b9a2fe306000b83b770c79b3d0e36eff6cedac387b2111fbf6ce9f8c8f7eb5d0650edcc930a008119b3e6302333c2697f525b4a5585259f1eda14b14b16538eb57758bce6c0c5d70a027867e6901d162d777414946262871dfb96806aeeeb32633ba3dfc00c7805487b0af3936ab9d0b53a8d4e305ada53b4b37c209147a150bbe0fe2c38c161d5d184d2457eac00c69cf0db93c86807e1b449b05e3b2eb12bae530a45f4b69975039086ee94e56fd74a336e193df44718ebeef404119e84c046031e7febb053e424b1b2e977e6cd22f7bced35db27d9f8961047a429e8b2ae07fa6323490f3371f6537fa34ec9d6584f39108d6ada4a56fa7086ba9f002bfc499c683ff885e4cde168c5a31a878f19ad686e4215bc78f9c8709f0a30fee2c8449b540796f374cfec270ab051674686b01d894d6516b0044aa219aabda55fd250b3e88865eb7cc1d276f40b1f4d80855317591ca092f2939fe6db95305b1fd3bf0fa4f84f1d2ede218d2e94f4c28f9332b87e8e969b42079bf583ee7801163ef17513e89df28a7b1ec3f25c827be4a35eef8eef7f22d34a6a627303d73085061a4c902b24f6ff05fa2ce23bec1b662748e85bfad16ac4116b6410c38601c3d016eee53fa98d6185d2f1f53cbadde7ce88f143a85e62fc1fa87b48df56d78ebd7c18dfe425d900dba7cc4af7d524d183f7a5773ad36c88e80c751622f38ab19e0a24b6b0fc7f2770e246b449d05cd18dad90463ffaabc0f9ab023680e44740343e5505e7eea5a27f9fd10c534a8b89276686ac9e51ca4930efab446f4214e5c082ccdb96ce569f113a0f6bb10ddeaed10c05d144e9c9f3c072e3980923879182587d38d82885eaa9b5412061a0cfed64d5b1314e14448c36aab1df96c38e64c742bab1c36626f0207183b86594b38073a64169f897861424ecc56fff502002f4252f25a2cca5f1fe471a1da94f7e316d1d37db7605f23248fa788eca689e387cf3620559357d152b52f1a43213efd64cab88f151d6f25e9d9a16ea261437771a5ccfccd1010ffea476d06a61ab0f74236815de330a316cb6ed2b52dc9c6ac1fd933c72990e74874fd3ffe44da734eeb7975d01af0d9d773f3fbccf02a16476ffff1dcf3bd4b0985a8e1feeed89d7044b38e57671b2088f33ef51db9fc41768edfa853f44a8d26cd1fc56da41aca64c03f63c8a2d684ca8b4aff50138269e7b419d3239e5210f26afea2662545c4b836469b0cca2fb85c45402675a33d4a817843cf9e1b8258b595098d9ec35efb4df1fad056301d68fa2c4b0fd25acb2dbb99e27ea8d51bf41ddfd63e7138a08e1133a92a702b3c08fc20993470ed6aeb275bad731d592724dc7906c814659c1f47101e27b31739dae9ea80c70776e9355c659ad57e393291b9bdf806ce42aa5c9a7c586cb94b349d7da88eaab0f5dd117b57f08e67cee95f1057e148af9e7fd7e33a247e33b786965b7886bbef073146e995a51eabb71ba532d13ed47d30b5ed65f87545395aa7b8e49d318378658507d7a6223008800c068df74fff97a441b5885514069d0951243feab5d7f0982a83fc66bc555cad6ec7047fe922cf25a8064ab8a5c6ed55c3f368fe2294fe6a067b8ab2cab00f51c3b8ecee1c8f6479b65cb8d870b3a8231ee8bda057d62dc648b09a1bf38f749b0bb400642acd94f89b2ca076bcb8956683956be69a8961686e3261ee1ddc4f2ddd8bef1559e928cbf2c2ccbc71ab0d68bd90d61aafe59b60189264db2b77f2a5d01f029d8ec7102f909ba1b8b2bc5ee4281803d66c5fff48995db7f0353beef0ed8a5cd06282b58a582989280cdc3948ade1785d4c324e3fcf43f4b99c1c192344b2a4054053a42b6ce0c1df419662cadf82ff1d7437b406ffd5d5df7ec07f4cbf9775fad6fb9a4a5311903da5d5de4320f7820777e7526462baa15d9a8716f799d7f070b52a685baca6d8ee50f53debc48b1ef1d631b07a321c9f300d5984ceab3cc75a8d911acb2eb7840de4ac96d477aefc053a22cb7ddb5799aecf97145799db7f59b895ca285e13318c9500c94149cf422e3bbd400962c4f975940bc30293e8ddbcf5668148272775b1303ddfed0f8a3e8c0be6ee553ea60bc8b6ba9732b9244878d6d0f5567a2a2cef46e1b19b0b240e6b12b21f8d227140553f0ebaa55ed0bd3d45a9289f50721ace8a3095bcb7c6064e93725ae5ce79435da198473ca26d0ae5e2c4c84cfe712420e3b346d795d9a4f8f5c3d12f732f793397363bf5e389dab411c025cf7fee1d8d5dcf9fd7881d9e0e349f68a7b747cedfdfb2ea65f2b4dd3bca867bee551bb560e475f66231580262b5a839148dbde4ee2812c4e473fb6e4067d7f7b5d01eb59f8db9b7a9dbf8706d1d91321ede3aae55ba6d9ce38080bc521bc470a51b7c8af18b9c144ddf521a4b8fc6d35f41b83c02571808956c35e6be5dee1560352f57ae5eeb2e28eb69837dbee438d0b27ae88605502204807324b6e0a78ed96773472377144e632490b41a0d849a21f91cf927925e10a7b22c4bb45de894ff4beed6f487ad2a6b4334c1f7ab83a1f70a7bd6410dd136a3b2043e6f1d7ab20b8b5fe883977c92a03759f1e7a987902dd10c132fe29c6be08fae1941deb6e40a26d02033d345214359dc9e34504699186c2763f8eb9f2ac0bd01e0cc601a008421dac25ce81021bcfab2d8cdd50dc4f53e56d227869e42c3b86076c3379d9ddfabf38c36e3bc3b871a130e82552f5b1f41f47acad29abd4a381eb40a53ce2c9151521f49f5c3770f3053de9cad42c997cd499f13f094034c75466989a0daa975171f1a106dade71938cc5750601d00835747baae629eb2b2594ee89053aab46c311186f2e4aa7238d1bfa8a2e1af6e6284d96152539b0c6a15a3a2f23819f40ba4a9aa97debd28fe009f1ae32e6c4fff35a05ee5f16006537bb7b9ff139d6bd5abb90eac5c586a6cbfb0277e1a0a9b13e7063b3fa40c65a4998f18ef04faba6d486488be57feeaec63ebc9fde39a1c6a0fe951df2efd5563eba3970ac724a629a80d0ea1f41c7a9c8268aca973e853c116f9a64ee28984bd014ddcd143422a83d579d607400292f334ca99f634d329f0feea60e9560f3b57b025262a2d864db405469614c46fdb42289e0d52a14b49d4ed447d2813bbcee1e15f2d8ccb2dd1b95ed207f3dff4eeb14df7a01808e2c4642ddce05b52e58391a7fdc5d05b836ddbcc5937379d072e0bb8c2640b4558c55c6bfbd37e4fbb660c982530756c09dc9581090f1187e51fcdb95452f38301eab97d77dbabdd570a88df2240bed00bbb9e7e42ad16580150409fa9da75ec03c37adad65814058648fd1a0a6c2ab28adca1688ba310f0e789a62899512fcd7c67713a5e613086e94146063c40eb91dfbd1658c1daad1dc0f6abc302f40fa8c88086590c42d2b8683ebcc5852a6afa87b3a8fee8bac7b171d5c48c1496ce4ab746094f53aecd427fe37a69819ba3f6a63413a4434a06ea79b5beee98fcdd5eada3d58b67b10f6d14621adce4315996de84648416555b04a7c971f51eda0f159658d4921c577f85da8a983d1078caacc61b46f36cd1f4d12899148cfa6e508d0e491e823b53c82cc14d9fe446eb99bbd9887dfdb6b76969a1f8c253f56d287599743ea8bc5d92cfc72b4a9e16a97e300072d62703e52e8a8146d00ca2baf7f668dbad0537b0be3859af7f400002ac1362666f2162bb4ece18373c6fcc0d03f61ef7cf66e530f4ec696570b254a9f981129e111572978ea970de8a206192173275ac22db61c3894b75d92c4d2b0714261f58a51083500f5d53b72ff96c7cdf71ce6211f0fc3f86802113406be601120dc6c8e58c367b69049ca2c5dac9bed17fb1d8fca0132099f9297c0ba6d7c87205cbeec22e412a8257c0d12983766329c41a41f19681b62ff56a6bec871a0dbca8b63d4a74986f96b3f6235b116d83aca4efc3d0bdc71c234248584343b2c6f9b8956ce018a54ab70e68d7521dc247c903dc62fb2b591a1c9a3df06c84ccbea6e09778609dc072a08ce247cc6830ccf83440c157d016ea1af59591efbfd509d9c4c31900e59819911f12c0a5f01cb942457535d6702eaad666e88c73bb66be85b92d140d57c492d13ba29bf4dc1351b37aebad4cd83e0605fb506cf505dff60ba38a6bec5a8b1c754b606b1a8dba6603c7356c43a1fe3c91135a60a06bfa6904999b045edc33f58dd443e8f7ceb2c20d6db45eb1ec2eaeea7430c4d70785fb98ec6d988a24d54d102bc57689e671a3c1fb0fe698b3e870e5cd90c2f1748f3963333e4998411ddf02e61247398e8e9cef1a63b210d245a61a48da070aa0de602cf018de7c51c7baea233571ccaa98c813d4677217bd22fc2ae7f842f18ae135529aab4d342312403dfb0449c253dc3c4812119c3291dfda94de4e0e66799fa30ae271de30181455fe69114aa2e0ef1ca319a3e36a4074988e5ebf766a08104e20bb69eb817c99b59c00b049725a2ca28fcf376fade4e73670a0e66d8a72e0aed353a8e76d882483657e520ddc3951b8149b6f39316ab0efa63b507db217dd371d1bb57a706a50e38bbd4a90d30cfc81b65b933b3d7271917a34a9f8d9a086a17f2b33ebeb229a1591ee7e18231e63f4ee28216b456df16fe20acdece1e6ef4f47fe80bb615408b8b1c0b2269d521013dca5c196e187bc2b9d8ae8f1df28b9d74a439a003e68a50cb2ef2ff1a008ade31919908a57126a411a12930cb83fdff665a7329fb8cf4d320949e1200bebd619beaa25304eceb35739d8e39194fe88dbf12f7d58f15297fe5289a08e20b7fc0d49999f77e8b2f13059fc378d00c22111e0bd14cd5ffc271f7b2d35fc790ba531877bdecf3c2a04d452aa9e5b6874303963b8947b8bb6ea0db440671b51a32ea1a475f296d0dc75e4923fd8c601550a81b6185ac345848fe6cea513eb4882b44c4a3c11eff084633b05fb00d8df688bd64813c2f0b4a28f3cb205b88a619bb31d1ff1bd93eb429f39076437feaecbda155eb65c1656b3c65a03db81c6a15b753824d0b67d4b44b7faa7b1fd236c97045d74849948df6f012c8a22c251453c76d91b8e272dbcdbee4f28d7e8aff99f6b34128c7dc4f43934efb05fa83dbb34f3a6de19a7b0b603117955b21d5524116216d2ee65c38cdc3e06772a01dda4af2fa0bd87b2ab824219115e0839073fd815408ce55a6fe5ca1fc06d4c3fa0602cbceb3c4423119085d28135690f414691e988153eeeba53a9613b10d405323b6958da1cd665b81cf709eab116ef30d877fc337b92f058777f04ed36f9e5f197a5dcb4ea9125bf579b3a1470028a1d851f810dccc3bebcabf5437726e3cd0f9d5800dbf3e040c4759c1b5ea683b61fc1f11a4bbce8ce8d19afd75231c7885cb97104f925d927d45ac0bac77d41afbd5bf92df4bd48301c79344ac5ed98141edf774c2c8d6d3fa10222a2ebcec74e2a1f7690782a09049f5be005028d6c00674b68141668a20ee6a087e5fafceecfe3404fbe3001c457452f6e2a553703cb8808122debad1995858eb728444967fb03257febed6c74db7f52ab292402eea50c2f38cb8aaf5563020bf3724002420ab7c697f53b0d3615fdf6a4bf2deb2467e9aa87c7a43011cab9f0576882a6485bfd133f58358b325e2e4e142b12ba7b1644bc7331db0d6f63096d03ff5cc207a5ed94c3e418b7b6da76d27422c28a00bf06d9952198509e6f54ab14ea7841a44cdc31905fec3ff2b6998943ac4807240ce27d6afea28b5900b6fe3f8412c95c887cb78efd5b5fe64c24019a4cbd59ef9713152b73819e39cb841e230d666398d1c1a23fb4c2fb6217f65ef565c06b29f05f9f5b9286536ba06f2cb1a89c575e65b6657c1a21925e708b9fe5ec9766458770ab1614ac2b8602e754b2bb4684c8c1ecd92eb147b9952666537377d3a8769b0c10e47b49a503bd13c470b8e94c506c2425613bea1736a036f8105e5348a0e0429f0de8c0a52949eef661b6494dd8fb355b32b21449d5d80c4024b3df815c19e7b9bef8b08793456ee475c3f1a8631eab955f1016a5e5ca32bd9ed0c7cbacc6c7f6ef799823e8afa7e531d94c1fa47edbaf605318ca70fe2c3830c46a231417c7341d0458811e4514e6eddbf4f7d00d0e902ea98f91f7b3c12be70067a411a2ffe508c2869b4b0e7a762092f67513b4370f1de96cef6b1043c49b725f56f898755983026c3f97c3905455f25fbbd1596f45469e511843d52189fd2a94b7dc6f422258891f9ab6bdd6e64ce2c9052e41b50fb85b3289f30be10fa69f8fe1b0cf739788d92bf91b4e571d3e724c7ee488eb5f9c18f0d1c3695032c3aae04276c705822caa044f1de56b9f7bb840503c4a557e7f97aaf5a8f59a7c378049b140dd5cb6e708bba915490bdef9f31b1ce4add258fde3d765e9cdee549c785a9e26b708c761fa44c8ac8f1a297654bf56535f6e7fdd19f365c27bd6a0f1c130f9307dca917bc64dd821f4feac2ebe262d155391d72e279d1e939a3ec572635d3fd753720985c966d15f7d195e29818c5451277ea0f88a8b1210ed3f1704c9413d96d09e310623aa7967e1faca0a270d1b47584fd737e3501a17d3f792b642291af88f806b94a6e59536dd4f68577c940707e3cfa25abae0407486e2509a3409fac780c0de64f119ca150cd71d80555431325f8ad9f591380d72ddebeb4822f4dd3d614aea0a80d30c383fb69a2b6d66f5cb72b576960b21fe892045217f8f3bfd6e4c74df14880a11cd7b21caa66603a4535e51b40752dfa69d0c3efee8f6b64fd88edd8bb55d7d728785adcbf2e569e4e0b68684696c55814df67c6a7b88fd0b8544a8bd337888893432f8e24b2790a84ecd3d50a7e8387477e500d294a9adff54ee3f4068470918fb871c897e225f5a58f4ea00c9dc4f29dc503058ba339b6ade63cb43b90f750e973cde6df5d7fe56d9ebb582eda966b9e7b058cab9706ffaa8558b0a606865c34083e702243b81d4b3c439dbc4dd7d86ea0197c626c7f56a1af64054f04e59403d9040a4802ec60b69d2e43f5f539dbd8642fd17305e3447586e4157e3f488155f7430fc268b03ab90ef155722d87ee0d3c91fb69b9164229dd5a73ab46e5bc6c124d394943699ef19caf11c1adf31ef53ea02d9baa1a6f496c56a8139dbceff63b8659430b2bb384501b32f094f54fe320cbc6540a675b4a4e2ff8818a25fa4abdc4121a73c1db186a7dc6c2b09b925337cf2044ed8a9f8320103ba2b49cbb241535fb8a015d43e712910924a79d5e25c41f5c0c1d7277b02b527457ece3882c608100580c324a6be48247198804d90d83cab99e746d22861d8bb2efe2381995bb66624c3c47261f6f5987f50ccdd03e4c44ea1485fe08d0693bd347556003c296d79a2f186e80cc363a4249a00d16c120cd2279c18ddda1d2cf2ad5e891a19f410b2ce058825296382ebd5f4fc3e87d1b3cf2357fc785c789e88e6e0c51ed2a1944c8866811437cbff795a6c6e4a984005f3e555c6e437207a9bd9c9730f4ad1c994dd93f6ea7d3306c405e564d9f83e1df86c4e16f5ef367c5b80f0c44a14b8c17edfa460e1268a430fbb703bd163ca74ce788ba29378424c60a89b9c6eee4442f01d9dd795df2781ce883d8fe07849d7a2952abb2c248162358397878ad34b74a62f02c5cb7c50648c7565f9b92fbee1a404c9ce326e046ef2002e4f52c0ab4d285d58a05e380cb1dac8723e8472580c1563eaeaa6e66864087ae7f8025bcaddd6e3c71acfd8c48f3228e1ee93fa418e2752857aa8c736cb7dca6e977641bd418d97554015c9e88ad85311786e6b98f8d6a2238c95b65bd3a6cfa2430cee3d8d3568ee7bd25a38b20101d83ddc38e0fe8a2e2361bab6ef04cb22ff025a63c5a6a0bda639f3ed9095e0299a5a1d1b9887271ed58e2ee53fdafbf0b3b8176cc3d95d3489e3f313c23ec8f6f6ef5f62f7e3583f21ebd7554daa7cf0206d638daf3244b3c801ff7c1714f7ec23f69de35fab5e1ae2bfd1c0dae0776ab3d8291ac54f31717c8698f9dcdc56f0a365eae31054ba2f2c7e4819e021cd2c59cfcdb63224338e82ba906065e76740c874d7d236fdc040670d2b2f60bd377fd9cea9d2b624c6877f679f436a872a79faa7e66b97553633beb374a416826243d7598a145ba05b4add8654c7add03d62ed623dc22ae54669e8fd0955acf4ad0ac4d517153a1f6dcb339b924a97c414d2e58d80eb735add9e77f90ff2d908258a108242a71e1e0c426bed1c778a4ee3e79bdc0cfeccf449bec62cab74b45fa940660885b9661025b17301ab1b6ee19662b16c47426516bf77c05fb8759e910487b0f6e5319e0e71cf6c4fa7d6a2b7d4142722fd2b956b9ff356425257c3c94971d5bf8e5902e2a40636b4523852de04724ca7a76249e1c819db48f0aee6a960e0d105b5324e3128d30afb37e812fd1fdc56be7e6c379ceffcfb1250a72a8cd76c255e392484cd8b9c5fb550aa5736a00e8ccde724b6428cf527fa62b2fd310c5d7662a4711009c10787176c607bbe191823cc6f1da9808fbb230f3c2fd23b418ada5a15a2deb8762e7a568caa887cbf6307b46163fc6fd03bf1e4e44808b001b30e15eb3c8044759063d5754df94faaa2214dc2ed0f5059a68e641418cf1ece3aaa24df506f0b1ed3bb7c408c631fd91cab710c3f635a8840804ee40cf69ff6e47e3be45c8a62e3cedf394aac858f2f300b185efbe1af3b86c79671e289eb51c75cf92e154faa5d6c08c2aeae6de8148c62caf481de728c62ef00768812721ce68f998a18311fdcfa5c2db50de8fd76979d231a0223a334f630cd47a94106e55f06a0ff2a6c23f4a0b1e22eba160c556b88f655275917b5eb09b163e1a854852c45bff1941485a83312ebb4d5ceb785387cc2ac26eb6df3d42d5f876c099adb9f3428454c5505a4b1dbe5c9c3ee1dcc4bd1f06c858e63ebe12a1ac5bde361bd84be8b213b812d6f29ae66d0d89cfe357a56b00bea1eb01be2656ff62f913c57872f4955147bd5ab49189d6ddbc85683b4a08aa50793f23478a23a4a7c14e8914b5d8ee4245899e994fa52c0a4a332bdd509b4e95611eeb68cb0667faaf9233259c575f633c6e140176f42ec3baf94aca0d813f571efc3e2f917c5511e242096836639812e774c40fd109307d5d136f14928d73d0c32ffa66d0ff75012a1a39522055ba78c1ee373dd89299294e67e6cac240042dc947eb6db215f24f9a8001bab49572f13c196e9664a0d3733fc8929ad674f8d747ecef22917a1581da3c585a10b7c01a0fc3fcfeb3975c690db48d2392c74ffff051e46153a9ace790242f0df31ebdf3bc351c2e1e40dd8bdd4461059a7c3dd6e29030232f5574347af188dfc0f64576f449ed4919ce0205a079938daa9776afafc34163b327da55c2f42ed4f73565e161ce8d5f1a32e552a6b8514cfc4885e54493e310a4ae263794b487c69611a984f5cbbd66991bae42b9f2b91b8b3cd1de242f5132e114bc07000f4ee9f7ca2bec5ebc8a1fd23290d5a883d794623aee7ea4ebec8a3474ff4d23f8e712edde7c3a9d7da9ee335a5a3ae40fe538674efe0a6fcc31beefffb17a2378aac930eceb23b9212f7209628cb564e3366b43284b6bc3a8ee2928b60216fb73c67be9c85069feb0f752fee20e7799715a4d88ab7f4d55c18156e86572be38c825cff3477107fefd58be101e674a05e071e65bb21ec6adff17b1a8060aacd0b3a3b34be6ce5b4ceac5f4aaef456d7e5b8193368e7bb7df1cba660c3593938d165ed81175c6b2ba9af7da652a1713721da9b5b407667f9f6a6e03277adeff97ae235fadf532b89e038897332b2119500b58904c0176f9671f1b6ece82412c6e74029b626b60f3ccd5b5a09b619b5f5d87ea66f9dd8ccf57fc73b2a808c262f3f4eca2c54b366eed5107a7b60b9055d391d5255467883f531506cd7e3bdbb28d18ee103cde5b3e3d83434125acf203fa755cc7c7d7de1441a016ce92d75ef58c0e740a6e5a02206f283eefaa513625c36af78de6a331ea7fdc66bdcc88c54629c84e744a45d813adf56bfb1f00d0a9bc86e120d70652dfe68c8c765e59212db02931260844b53565ed2fd238d72577e575e892029205f714c2121c735a45f9211173770c0a46a5c7b72d4cf7166a4510ab460c10c54b90a27831894437f9fb95e194fb7cb27e4640218016ae621595143a01e858160d980994cd3b0c5e21d5692850e7c0850c24079f407c3acc9cc1f7f9963df73a7c5c3ca8ee680cd5884fb0c890cdde936033aa44ddd3fd8f4a0fef18b88c4a2cea54958f417f2b825bdc52d746ac1df69811974b96d31622f30fa288f01e56b5b54cd495d263a7ef0bcf3cc9d7d648be1a3923ea16e1df53ad694849a40151f11bc7461d87225c5e762a4aec46f009bc93c2f7afa34e43344a8951d6122be95b4e7ae403bddb56826e18c471f264892933c38831f6a8a7f7cbf407f68be2d51b3b912fa68fefa5ca8783451da9d6f11e0bc6561cbddfa4518aae00650df388e1156c36645d9658448e76be2a6598ebc50f6bff9ce4388ef83b5112ec474787e823d3a449a36c59ce50308637086f7b455fbaa96477ea3888dcf9ffd91fa1454b8942f860194a07ebcd7b99cdb38e3126ffce56ee09aaa43c6dc388266ab7a9e95375fb22cea2cd53a924a1942768f73f5603ef4f095766932ea2f2a3bedd11668f489d23fe3526c249adacd173290f4ac5b130bfe5a70ffc848bf99b374d96efec17374a3a43ace318dbab894d7a28726fbc6db6d6d6bf1911e3010756e2328306fbeb4aa07a6764f216f2badf0a26a02811fc73e6e787dd9a105ba9e22179c084554b3e7d1bad27b25eabc07c5be5bf03306b5d2205f86c030a3d175ac4eee75a8faaa0c2638b21fdef50ae0ac4d400772f3355d97596187da76b4b9dea81e8da5e6bb37f3fab88f7c0ede3dbccb814cdc50df778645a381307a8025b9ab587b6c21c5cdfd224c90a39d5242e5e95badf73633bf7ed8e93af6a13a6e86f001acadbb9215287e8826406fa19bcc3202b04e8f3ac8ac8a5408ee6f39d94fbbf112596820e299f722a11b92899ddc7478879279fd03a50e4802a6e5cbcd00b7dd41a86d8585a54890baf34bb9db36c448e373693133bf3c61518cabf144abebf20197b36882031dda904fb6982fe0afa8c21f739893f52bd84397a4bd3640807dcb4b151b70a0524b6a05cee5a62a201255203c84f4fac7dd6cfdb748622b9d91b3132c4651cc71a6e0462b4c2a1b83d6f56eff139a2b7fcc05b4c3a1d54bbced366b9c914fac4bb89a2208d5767c36c8e75617961b627cc6222aa292a43267cbea2898bd7748f8544a6359608d48a3c3b09fba52f5aa68ad877b20d96448bf3adb9e50f78ae9bd6911803ad590e5f37104ba83951c9695560362ca86e1ccb28bd5a5594efff7918093c5bc84d7af66a12541c962a31361082d6927afaa6d38cc9a609af72ce80dad089c04626b02870f015def812a035d7c8af53cee3d452f5b4c03c6ce2391c6152db7ca3d8f3b076f5c3a7c88285e00dfbf2aa3648678a17127a320defa127d2e722ce3463252c57c9482e3bbba7c7e423f153eaf356c5a6230f344b0a6a6b191ae05ed60683d48343433c12da93c72af4e01faa588f69e398b41d44ad4808cc8ae91c9a906d902b9020f3b73a86ba71959dc04f9b4c5d8d5ba3e6db8533748be0177e52ead25c57ed05d1a69272cc8217389728250cc6927920187c429080a5288b9ead1a22f26a5aa1d1e6bb0e1bf97ed0267c3e282e126f1ac9498e14568920a55c7a2c35bb6ca6f4bca8cadbddf49f32fa3442db2383278a4899d3db9a33e20c7ac5d9dca7dc5505f6e2f72fab7c915626cc46696b4010913448f1f468f8950c3d6da9de3b7614ee43cd8dcf7b9a8b38c0b36e3e1deee6f8fe0958cc97f6db6ed157f6077cecee7ce6bb721d6791f54546f1ff8f7855f347cc19c4b590d395221cea767b168cb670bd9bda46d771070de445d53e7a26a53e325766d867e398f3714204110db18607bedfacfccdbe0a31be1abf7517e1ec8191ca495db1349ce003366b711f9712f53f6964d565f700789a0473317e53cdc58c2a9fb44e3be34145b0c12c06f96181ca1db73f7493aed2f46f58e5263e602c15a5ab42bea48fb1415acf02119397148a94444e9973d0ae2bba74d249c5746a10d65bf52af60c9e05c0be983962e724977f1d72ba462c26ba218f8de51b4f60cf2212616a89796d11a7fc651ea0f7507ab5021f2cc3b9d2eabeb6642af45d56f5eff3a0fc14773a8af3b048cb8417964edd03be23b25e0fb03af597e484041be137ca9cdfd5bb9e0cf5ffabdec5d396577e30d9bb4bb2bc0848e3dafebbe65837ab7114e1dcd24b0a69966686c22350c77f5f899565a0686c82e5e2a9d16858791935273fbc3d1262d3cf947a320040dc9a70c2dffcdfb55d694d1d90ae742e85b0d9b5d552fbf966a88f553eddf866fa575872d4d5b87df2540b011aaff67b63a3571cc6d1c9e07f0168ba8ec6dfa6dd5d0e177d8d2f91e9487ba37adb7665f939deefa9c00f273f90a47e70b4cf52a1a574dcb4bb141b4ca6700a1778ca3dcc85b267988e2fca47893c2f59a42f243ba545614a6abf741aed4f7227fefc3f44b0fcd2ce6cc3c79c8249faf23146182d47abd2d9b5cb24b702dcc75452aacc129851a0f44b6995d7787ad6c317ec9eb4d514945b68ec966ed33345e919da1f9f789d0f26d5cb33c67300977963a05e80867d955039e3c750dd75c359ddc7da55db21d88daa5fdb39c7ac5005526a1edf6757917846fc75598959383eb71a69622b8e4761aacd46c65920e6417fd2081e67c9726d113d92e8ff4befc439fd9e4a7d231dc0614ae4278835d6d0c560bad86cc4b76c7228311495b0307e5af425a28cad907b54dd8359eaec8294b3fa1c97798e33969e839db0976488198980f3d6a3fea05af0f93a1922b8b92676c5d1aea5132b3d1e94d24a096990acf02d626704ee3d71c9a0684c028af297db8a1e114679cd4cec9f0e2377401acf3db0bcebd8bd36b9a0fcce314a233afd1f1459fe0ffbe922f69eb7fd015cbcc2fc731da0c43c90a55f6937da51cdeedb5b65cc2e62ac5cc6f1807e1ff9bf3d07dd17ca02d1715cf7167930b24170f985f53a2f59cdc04ab2c399cca39729179e9b26a4309ddbf1d075e7094d3a8bb8c26340ff319d0a20708049f974333232c133d03732bb9eedfa0c4284b8a898aa1b3edf00bbc15439aa154dcf89b1e6e6395960ec69b299c578aab8a456d6bfee2cec540267e8964efbf4f2f32fbd753ab8c8662d73307ba8bd242dee5384f6887e51e21f9e25f88faa0fcc47b220a0a84ac97490b1f3396ad304b590be96a786101413df0c7e5ecc7b5d1ed4441f15b7e0184a11fdaa4fd3a49b2d1608069eb90e9757385a92cc3f000e7a1b0e15023657a42f331662d4fe30cf95491759a6395adfe2a1e6a3cc215326257e394ef9dc30659d61205f63882c961e4bcc3faa1219e4ba3bce3f7819172dae2e89e0db71ea34777d0dee9e0af7bd47e10f144fb845bd2912425240ea1071f7cfa9a12ba492dc22f70ca3cdee45c76d6248a8fe181f666ca08cca6f32960418597f0bf3e33f3f98e321d6f40a4a7da1ac2d0cbbc69c67f4edbd93fee9836389c2368baf13bb9ac8c83a6fa679693a7c8c7a7ee16da8e4d5b4a9939f29ecd4fd86a7cec2dbd66be35e1574c3a11d92e346c5ef9ae96320225cd094fff81da195882a6541e64b3d6206f3eff646fe072ce199108d9b03709aec98ac5c5a875eb33461b4f625c3703cc78e851fa46d6cc6f04c9128a0858edec5b11d6bb785d3d260d7876190f5406a96b67fb95fc1d4085f8b8d934a1820dd0dcf87aa8403056cb6b7a8db192027a7edd8c1b519c333093bd2e3ef14ea7bcedc4f9dc6abdbeba71d93be3be68c498c73a159a511d51f7212296c8ff316c5ab6da7f80173a1502904324b923337ec1e27a73e97756a891f0033af210f07dab962f5a6c9f8c22bbf1eed8d75a88cf015f527698f78383cba869876fe4f4bd0a4f492b7a1dd942c5ade485dc2d2560946e649705d0dac88d94c41181bd2e90c723834c49350e07484fd4b55b2ee7d93c4487e15efdf4563b699fac262cf1d56891dc1aadb90646fe42e86f1f1a5676b9423e8dd612eb8a92acdc3bd7f58c1756685dd74b5a404dc7c8b4c6bf3a46023247b8f60e6885038174331a1c1ebfb506e4043b839bc6e1e7c9113b2d12845f781b1c428b1e71fc51fae1da2182784f9ca536968156a1a79924701202dc9fee18cdc48106df519d021ca4f09ad0e3e51ec3d2a9bf9d728f7645f90250789c80c3d7514ea242b15149af95ec55d075c1bf81d74860ba39ccc075956a6468d5271f6ccb41bd78db6ffd6417bf5d0bf5413b043a7b6ea9308f97233518ad8d4bae020a4e81a7667fa9405014fa2eac53fccf9eb70bce6aa8fea7c027a5a73d19044986f0beffe50a88d2c1add251606ba1b102160f1c8c511abd62a727d8c60ec1f32ace86e6a72534bd70dc18c7b4cc8ca9ecea1ad6f1aec8927b1a8dab5f8fde4fc2956513b7b0c37786e07afccf02657d3a414db6e70add01b51532110e2d1b1976ba4a0e36cc248994337301a29d62dbcafde07ba3ded2b95d279682a3489b57733d9802cc46e53ee16aa1d75d4cb50814c52d01e8cff5a502c302fadf617dada00ac7baa9291180ca8455665e3a6569119bf10d10256ed39a90e766512610588dfd4ad759cebc8115715f48c6fe18a869c06aefa16fe44db97001de3b2055ac306938da28941ffa27d8da4b7dfaf850322577c60966eda2bc42620e11224f79805ea3547b6a9cedd11310fe1b1854fdf539d0daacdd4c33caebf9d03ab9bc4854d5190430318eaecefd4f85dbbf803bf6877d67870495d77ef3ab0d0ce295c77b986bc184167d6ba86024e20a65d216a6d184a214fa76477c39821db843b2c6013a8917e8c055ddb7091d2424a8c640aa4b4c80bf0bf5ef05dbccb816bcabb635d69c4ce49de0cdb8209482d29892e7facc28902f8b9dbbc34e41742389c1a842b110a94ef349ec75633eea409828b91f17fa4000f286d33a7701cb906e5fc3743c9c66d5d854552a54098c756b4c71f1d289a6bf2b90d153a13731932335aa24fc399c4ce1188b76c4a9edcbfc2f6501c7273a8d921fa948d9ba02091f4ecec0d6cd7e09ec86313603fbebb1bc2970c273417db3a0a2507bc869d42e53bd777dcdbecb6cf06180d265012ae1f5140468667f5da34b707169e58bfbfd27a7bcf5d94654ee30c47446244f2c2a8ba0cda14e7767a237f0b234f56854d07249265f54155547dd52c78708b28b82ef5dd23c92f33fdc2b68133a69a18631c49e529274c32d48ba5e037d2cd2a23f5d5edcea801e894ef79b3139ffb5499e50ce4715d7569e46ce9eb2b1efcfb446e876085956096fba86223e7bc21eceb65afc42a3836c6d40d777bcbb44e6f378cae93f0dff73114060cf376be0486493f4784da986fd2e329da69e754e99e4d77ae8cca35896fdc91027a3889dbb6d6021dc0d75087303ddaa9dc2d201ed45ef5d9ea637c517d5abe24c6230ca095e7ff4ce6838cbb241d5f68958aeb73ebc2f97b4c237ab24547884fdf25d38e3a122e0321c498de98bdd3a01c796f6abcebea441f16dd9cea972d2e6ce1bee5f41c0c739a59b32716190143c91d6b0ce3cf2564a689f3282e9c2b5e501af1604d8b39cd5d8f000deef73526fe6290788f3dabdce844d422748b5887f1e503f24b44625197a0ccc181af7e20756241e8ac097fd6623321c9aa82f99b6499b526df3ab157ef626044e3d77c3edea20961e69f7a4b385947984491e35d464fd2232b528bb24e4a5101f35a8c7aa1d089ce11fd99d57d115832b5386446f203229760aef6480c9cd49284ea2c2dda61f800d1cf4f4ee30e6dac10ccf9ba7d212a78153d672832662b63afb58a8e724b8e44197960d184aaea5c94f08dde1329b7b237a723e3305fed75eaf0f0e41b09d0e4d8a0ff3364a3f407650206a9ecf6c08eaa29501a399094639ac77ea2fd7d264d4074f1124f555b38ded1b4565b008a5431ca7bf45eced60d708a0e7072d7869017af2007df23ac8cd539a4b135176ff124bfc9fe0fcee77b9e4183db90e6e1f444a7382891aca6e16cf67107ce3041653eceac15df76596814f86de11290290198752b523c35d4b9bf8c33ee4fb7073db51eac99ba5a5037c398d751e9c7fa4ff8950c3fc9411365fad81cb649694938d860518130a2a59209999d8c97d82654415c0771836690750837e911c5a4dfa2199476fa5af02cc97a64cfda2c7f94ad13593a43667e61cb2ac56da9d3e4f89ec40d306cd1262a7912b42f7762f1cb6b5676caedba3979db51320ac568d257e55c8f40901752e18e32d2e5afbe02fd7d1f275b0e30ea3b6622eefa6b73597692c156da7eee2aa0cf87abee34ae76daa6533770f69a28558915c1b74c1dbb31f03078807e27b2805dcc636fde4ad1787232e17b5b11e9535d875bdeb8bf1d67fd9439897b09aa65de97b8d1779040d1dc7c60e6f68df2e48308e746ba884caf071198e453e93d8aa81526bad8406410928b9d1b99d31f0adc8e322456eba05e1ba2ce0d04ea156650f23cfd1f1fbb78d7b87ba5feb27c41f6f884baba0e178c1cce6b565a116c914077a206d63a03bc1261ba278d08c54dd1311eaf8e61c8a42e6ad322740d19a70a4206e708a8e65c8f60f32bfd4422bed03933a73e013c295c26192654eccd5e343fabc5aee0b47366e3039510e42fbd617a16ea377a64089e78839d5b1147d03fd28b58256b1ba412f63205b04934032096ed2462e2b8060a60f90f28e5968e6e649516f80516e8051ef79fbd4fc27a01ac4a1c44142b1919c73bddc7f701e3f2888cd84c8914175bac530333bb34746f924bb4a1bd25b2c5db80761e1ecad3caeb8cc653e82126ecd3f92612f3ad16cbc8445141f86019b3ea4c794e4d3052b49cdfcf6c9a7f0a3f4b26a67308f6159ec1cd2eab14770ba2060dfe1d0ce727439639f8eef15d22c9554b8ecb06b6e03733655e4e20c2143676ebd4c0242a36cf69a4c020b12ace547e3e950ebb4db875d02cf910011ba29313dbe4d882c699ef4bb5455b5078b5885086b5c5ee95377e2e4f69eca473e1a6005e906c18998c137519b8ae497e982a7f49fc385cb2b30da390e3f3beaa65abdbd5c9c9ff56c8858cf68f6f081a4ae7855ec89764c0249e27f417a95749770efe1ea21107c72fa9a1ed37eb3430793d496729aa1142718082ee087191e002a686ac04d16236c5679b978fdddfaa185ae9e2951bb0138709d06d507435649ef357ee909740294a484529a98c8a3ecaaadc1b5ce244f3366aae2667de02e45c857ebfa6997515a9ce296d87508f4f97f5078e21e57681d75d7141d2fd5c38b2fed14487dab415191559d89b0a9f79bc06c8277c06ccab665eb2a0617136bf26c811a2662bbc720833c544bde5abf1ad39cb2b1632f454f9121d713e2e5136c94d5a93fe32b4beae0d3867ced98845428bdb1ce26b144a61bc365a4a838938721b29ae8353162a900adce0238ae06faa4720e9fc353613a4ec9e4c3fd7985d960918ec938cf28d8bbb0f940bcccf9dc4d1deee8a48c3abb86fbe6b58518fda4d3d2fdbffb922d6f6e18fc3c51c7d20a7a455631cb9013f49edd629fd15b4e6b0c04621c46f2fbc52f6be1f8c394aebe6b9d0f81a69d7782140cba89680c749b7371ca3df5718fc09539ab17426c83e85d4a3dba899ea1d13aae52fc853404e110d915507dc634815664016642b6ab5256d5c6c397f87f821597e1e6fe4d77ea061945f8fb75ee328dca5154b95438496f33cd39b5cfaf38d46e75075cd73f0aa5463780ba7bc1bb964174597d7aefbeb2b8ccd40d23bfbc050edb2553ef8aed93f858c85d12ec5d1fcf9f8d1fc401005aa286873f5bd52b219883996e79be3bf12ff4cdd2ad653fd35a8cdf9a0267adbe9c30d72db8ad862771d1c5c005399da3c92eb53902498826e82a847165512373f3f6c513b6b98327429240b10ef8cbedecca76565a2678ba5f913ce01a83c5eb2427a70fc189973d361ac0fc932dd292ed1448b1eb4229e379554e6e329c0fe7d7319b987fa12c3bfd54e2714caefa0dea23c31a83e30e5f8a40c3fd4bebcd60804cee489df6f10d2dcab040f9f7af8f9da3f3d8818c68e47a87304a9a08ca2f741c560e4d0934ed8159b0f54dbd112bec4a41c6d9ff2a950a5302d1755552144fb9b1bf4afa59c0b6f28266665ba156c90af8cf6a363221065865bd2c3ad7e45b2ba3e1181f8d3e8faa771140d16336bf3c24a1e132ebd57dff2edaeb65f43f32ced05e699cbacf86c1011d31032fa90a9e5eb40e09db31005374ffd57e2a69ae61110e7d1073c0aa7d770a9d7839f90cc424954cb3d2cca82f62c00a6115c02afe85e7a79b8fa3001c0d299ab101c54a90994fac3b9848dcbd978cb3d38ad19108945134d4a7351d68210778fa7dbe7a71b917ce47d3d7132c1fb3da51937c7a39fda45e617ad85fc5da699e85c46ce05de5646b3b418b38d6f6f8926bd1d9b96cf18eee5e80413805e1ef089f142fbd8c024568681ffaba0e6788971fb6972e711cc132d079d5b0fa7c802cfc1edb71189efcaa2fd182ee87f05758e5c0a5d392dbfe63e119725dfa61c6f31119f5b43ad9855311981592f5d25ca357e4ffa9c56bc5f2d2bba3b6c89bace843f01f19fea82e8418a2cbaa1c20672c15fe362526601181d72122b63ca48f97e5c379782d290f00cf8705bb8b1be98b4f051ea470411dd98bc2b4cb122817d9a712ab254a819f27ac76b4bf0391b6a13d6016b908c29b6df0eb3ae836d54aff8837d1068bbddf51f02532606ade921d19e2e0bf21f7528251eb2146580bf6387a3c95c93a953f982e17d5c967f32869015e6b6df03f2ca8fbbbad32eb1d4440148f362358900d62f9b393b4cfea9e10dfaf182b5664f5e45c6d2d7041d6614c6b9a23392478590087e87e4d03ad66add2eea0e8278ca28c084d03c06ff4e6d86001f4391901af2f13b256f5a9356d7594c5ee8239cee7e80897a23a1e07dedb49a5b96819eb1353ce2c18471c8becdc69a1f96b18b2b347f259c1f4ff437b8db1c2f0eb0ee2ad27ddf1709b1c82d95ba420600bb09d347aee91ca518fc996e9e3a714b593c3286e8bcaab7e509dc0c3ef4e5e0867d2fab29dc69d6bf102d57d084c425f592b504935bf64fc223aa076d82fc3105b77f31511652b77575da89fb997fc0d61145863390803c38ba9b91601f9594cdaee2c752ff10d280bbf0a3f790cb6c1657a9bd2b4b6b09bf7827d0d0a87421e2cb9a31074f1b85dab98ab41d71be5fc94c852575e578dd9d0c443b5e81c51df6079726db943d475b8848744ca7b2546f9c37da4533620b0290066ed6f3c01bbdb54e91c7cab05e0e73bb6dea6fc86f90bcfdae5321de2b55ce6db1fa52a62af81a10355f08bc0babb200b2e7abad34da05500b63b3d3ccf0f85e4cd6e8c59941dea10a807dff9f22f6b6523cdd27cc00e6192c422a66b385019ecbbb5059113cd9a48d58cd1e76a1815ac939c0e9ca558904d402e335b45602df7406ab688e15f19e84b1c08209e73365e39ec1ebe8592e51af25cd2f4a248f6f01a45dd353a8085087b50920ad40d77dcc12fbfd864920d3eb86bdb100a1a90b31bd1b3fcc5ab27013acb1fb01f68d0af0a5318b29b4008483ad3d2bc10ffc0358c5b1f68e2caed3e6173e157a69ab4de240dc4d8647ce2f09ed7c667bc6a40a99ee7cd9689cbda0cadb01c8c99349c995cf0f9c922542b647c83cff80e56fa26644da570889b011e2ffbe1b09837da449317faf6124ef1fb204639aad9c312af0a6861c4e0cf0996e1c38edfdf8c225344971f746bbbf8dd249895c90a84f6540b810b7307a97c427c12d30b6a10caf961d6bf761a830691d2ecbe67be686fa0d80f9817d37bdb43a2af313dea6b8747d314915b3f568357287ff74bc4ac493fe412841a4c53c1dc7a6b8735b72b6b7614c5ebc9b9e24882daa91ce41eae2d52964abbcf4501e7b308b1d9f6b38f9388f859251b7e669e8b3b0207149212bec327e644c0bd11ed7bb3b3e576ef0da724e6249d0e1eecce10ad76d4eb1d5e947ad04fe1dcd94962162e175392a0dd366436a76c1fb33d34864bf53874264759308d2b04df4f8fd70a5b3d1948adc6e3d0ca951581ce9cb20708aede490442fcd2809b2ce190e9f54893368bd678b8b0f36769beb49a0cc28a9249328629ee24a403b32e5ee50773b1fa06b2268a217f1b5572b42a259bca8871e7c45cf4ecb01a3b45687f5033daaa36189a18b77dbedfe92513352ce3e32d3650ff5c50929340b4eae5769da1d2ee8869e03d0206de35023300689e581cfb20faf80913d3252fde1dffc1b2bbd398b1248fbdc43524737f48ba27caa60c89d251cf7281b03fa0c51661c51a55af2a07e59c4db66338ec06d6d225db16f832fec05c6888a107a9842bf402a8148af81169ad53b976db288c9e68f0e76026694c461ac06225ee2cd30143b76c4a64d87893efd4204bf79f85f00d552e0f48ec1288853d37d1c98968e17673284a0462383f47d50d55b11a974fbc280c1f44120abf43fa0807a587d99a110d2a20ce95ab9fc899dcbb30047c1b97112bdd2441258ed8871f9e42408f61f33d0e02ed8d3391de86919ba867f57a3c4276bb293086779aad669d2be4eb3578f90b8d656bd3a286d95b9241f6790e6e161023e55bab0daf370c2ed56859941b33636167c3ea62b3dba2b6730d7e90b8880b2a1f092452fd9b4ede821b8928e8800607dafec11272f8405a0d589109a9a9fbfcb0686c12a04a0a6bc00cbe3796d9fcb328e7338524cd508ea9f019a5e8a05f1a6ed9f312ad8019de12f775c3ea54864faf67f790eb9a92c68783eba5206cf4fde06823d2c8e7890859acce290b691d3fcb25c337b9bd08f9f89dc63dc6873c6740ee8b58893c5de260d9d8d7e334298cbbb02744d114b73dcc556464cdb0ee9bb0fcc0490355a6ec4dc3ffbb28354f0fba63132603f6214066154b8ed56c573918046dbfa9df3718b1e09723c56d53884781bc207f599e90973a3aed0fc97213b70a98d74c0491ec1b5b6aa683229b9f9d043c02ba855e941dfd157272a594114c53ed4965703f1dd3cb3da670b811214f4827561cf8177f3d736faa98752871c49be113f892faf3d34fd322c74013a0fc62cac5e33f070fc0e9f4d8b3431a802f493a9a599b8557acb119aff02e346468a57991038a07c6592270b8f46fb5835b1a1e01d7e76999d9b1358c4407bd8482b0064542120ea9eaa891e7963ab9bb7ec171f427aa1e5b9acc1486ce522d1cc1f5931ae58fa66dd1e3eff54ecc0441702308daf9ce52b108baf82fc9b72d7dde00f4a06526f8fadbfd5cd07193968974e9adc269c426f1a8af57d2ddbef2bfcdafa9bc002b5a64ba6ac3c48a77aaa18e5c93a0efa45a5c6a5d62081b50a82f3ec90b9678243049352cac72965ebb488a0805a5f31008b57f074b349a775ca46b416f45adf9a159bb895cd7f701b700b70fe6ad9e928478d35dcf371c4e7817195ae4dc9e1faeaf41d29e904e80fbf810c9bed659ff154ea474d6755d1286a873c2cb28f9b0fff955c83130f9c1d70b26dcb6b6b44a1e85f67050bc717c6c910875b69a51aa4672e262e48803d37cbd6686daeb55ad93ab60fdd420362fe166491b6c11b08f79903beaa7ab7b67eaa5da2980fb11ec2689e11bf8d72ba0413e72068c67cfd3f313c78eb6078ff8b0752a2ac1686651b55d4e69bb721b2c50afea4c249bba7cf86c0016f24eaeace33f9e1f7e20a717d25f7bcdc3ab2d0a11e398366fee3c9b29af02730e7c460bb1c938a8fb08e04d084c5231056238e65295cae9e3196d13c4402405f61bcc551b5c4f6f6520dd55de2999163d5ca5f4d3ee880f96181cc61c17448887ddec68d27dfc23deeb54676bd9055ab0c022c9237fe28d44930bad40cdd968e63cdeb615ff5f0ab6530c593d1d271f7dbfcec957ac6c4a30e45cb12976e4bf46e95f6e9bf82bb49ae7e3ee25d0d4b63bbf4eab3a7716b06d561fd3c6cea8ca1de17a4477a783217754a1af7c60a34fd15d9a9d00c8e1062f3b64f8dd1a509c7ae8941d945c6b049d5a24b09e92382afdd3a79d3d4007d6891f03eb20aa4244312cd82210449217ffd71aa2e30b9d5fe1a9448f25644afb30776a19a38767d0e4cdc112a78e14e18a55066263f2fb71466c803ac73689a29e857776a0ee305bfdfd7826c98be1155d6af144fb81ab6899dfacb47ecbc1809a51a25dbfdda9bf3e1ddab7b100e27c62f9b0b6b1bd8f1273fbb4a9122f304d8d145bc646a9c625f9bb566d12f0287f0d0fbbc4a274951a81e12e9034bf07d54a5b7262914fb35868b1350ea7dae248586e591a4c461a151a21a29f65d94fd3fa5c3e6178eef56c4b2e64fff65a6952c7921dd4a4648237033295c1e6fc2e8bd7dcf186d01b2c7ea4483e9fc5d4715740e882e0bb1090270d16f7a10b3b4e842cb5ee34c0ba971b93ccc594cf91121318b80d70b8d32460a0c54f41f8128dd8c9bf982dba197129ff3c55727ab5e0d2d3abf28fecfb2e8b38b07e747cd5c02598154e54add892263575fd0adbf17a14ddef3dee1cf928f417e73c6e357826af4309ae579e7e84f4e687682dd4051344283f74eed3adc00b8b512a4f064dd73c2b3cf35a8d6356fe2797f1d93b244543cf90f2466537c5ad816a4a87aba5437127dcf26790f576fed2301d110de33cfc6fff1b3ae068273d6a0ad0aae46730ce5776fc41f03113d7abcd9444eed147bc09a819c1a03aef8d9b66eebd4b2b5fbb0d0f0ac9d55874405d40c6da714c0ea9100005f26ca4e98a99abf69e8a622e366fa14d79b177bb3d1269535963d1b45e49aa4d01aba629903ba05c6c7694e3ffb04183e2cf8044cf20b4ac54ef3dab786d18e68293ec3d83380559aafbf4c81f1d99a5f4fdfc893004ac5ae19cc5821750d94c7bc56500139633c029fb054f878d4b12156c0c575bc1a15114787417729d1ec92fd585fb0c6092ded3cc8adce32c98bceb477ab3c1e5e01cc6247bf16c55661cf81b48edb4b3a753180832c934bce1f06a17e15c3807a2e06c3a98e2c4b39a61dfb9c7d75f246356f89b5f41916459b254df3215e773548eaad73f171fd5df9353ccad223c92f8f0961e9f1f51f02824d898d3dd61de486407daf42f4b19de03c76ad9123347d01d4c869d803a2ff76519b7843b307629de6c633baa7d916adca50044bed067e42740ee65da255df95dfeb4e0fabb0d66d94df06aef669d6461e214397d93fafa79be50cdaa03a40a21c9f9bff7df598e500686fdec8c06bb023c54a89e50c8e9b08d151995be8d74972ce1a9de0f96d4c265a31dd7820df6bd6cf14821e6cb40d7adf9dba5e91b9f9dfa6354f66a471f5d6b02cae931af777b0281482198a9196e2e57439cb75bcb12bba598295c1cd464dc73d52db85fd3684f5228693e130b8a40fb8df7dfdffc7679190a870c0ca2202d700b6258ae11e492c9bf37b71e1d14e240a7452a44a91e6b79fdca3099c36d1bbec91d082da036785a20f5c47994eab6a3ef7414d268a04fa0580c8a355767173a01a5807679188c571d2cdc4e5d15d248e126c18284e96fe0c7ac9c6b1a02f797a6913fdfd1822dd7a8859ad2c23df08423fa3a36f27a22871dba85b4509084f4e4b4216ba1ce8094e9adb3831c8bef6ee5e761559db5b4bc71d532db98a7a30272ab521c943c73f62b72b8549ed12b3e4205030a8dda73c47ed1f3b7c8cdf26f0912bb61dad9c3858bf0eb5a3409944ad9041c62bb59c1ad65adafd052a577f0ca583f65fc11a8c99505a11256eed034d5fff63db2eaab3ccc3d8fdb8cdfa80f991aaae4b23f9741e811728392f248c4486b742ba85db549bccff8166ca29972d219ec5180b063483796617e69515757214290c56d0b1996aca7f2482d384e3c955c591a2802ae1f5ad419a0d3e9320886f1b3e626d8670ed7d876b051278de30fb7f20a9879ad5e1131b4415cf2575f52587c3fd7a15cdfd39f98b8d560761b1e2c510f02a52fecd2bbee6344572b7d81ee3876fb077e7273bc66864022ad8a951686f89c4a1c6c461e22fe91d2bde627d4955302ff21e3063ae426bb5572aa81642730d391e80e66eb439bce0455ce9049e114faa40286c7c20e4f2b3bd18c03f45799ab4cc02ecfaeb535c6639e6d28dc51224cf7c11999bd259b3898ae74d5a76f803c3b8fd75fb2ed4da75d004cedcf346064f1c950ae261963391871994c001efac498cf7250eeb17aac8b83e3f35b85c04905b9dd990e2aa0f0b18aa53988e6e60b59a9644fd6f0fc00aa5cd953fc545ff6183547d6da414c4fcde6f52e5d228b9c5b4b1d1e55a2b32e0d4ebe26d06c8f98c86d4f61f513db6b00ce0477f09ebcfd6a04d50190f203670c209647e03da51c7a4e91429809426aed35cd44a5a40c2d90214744aeecbcddc7fd784bae03c24457b61e081b5e284b0d42e56d1be0d935bc38b0dcb9b6fb0edcf8bda543a393cdc1285ec62b3f3524e9103213005d2dc6c8f6cdc2ead133f89dc7b48049598ed663c2ce49c3fba7fb1b44b09ff0875b08111a2044aaf3b75867f82c515b43db14dd3881e67af9cf118ab39cbb78599250088b179a4a4ed4b29dc0d0e2c730d5f7b8b4b8db428780d61d68c8d87237c1ac15b2d27e06848851816c31691378304afc5fc64f253e4929a7e6820acdd6d7784874d10866f05c7e5fe6f3487ed1fae9fc661c313c9fb5a494e65c9d454654a6ca345fb157e5ee4201faa2ffb645f7d6b56c19fe270540725e575c1946ea4eb8f21941512bf2d98764a5d338db4746cf8ef528413d23141323fc9114c824dc065d4554a7dcf56b2912f36c33f798c9832e369c6579091b0ca460a78767c14175251b48778bdc574ae805188bb89b2d0b4b36ead46f4d2c0a279c6ce96e7b7158268212140b91a2c7901611f301b1e1be1e46a27fc9515b6f3309ae382656889675112d9bc006c68c5c655dab0acd2cac1c13cfebd4d09cce15675e887f55c3b2de46bea3402c7630c3acb6e38d07c69bb37741eb76d6e5fb7ed0cc4233355bfecae2c6440deebbae8e4675d4a92e39259992216db65391e4a7c00be4a61d3407831c0a0f5172b73211add3de644c7441870f3af28e0fc3b5eb10a26282bda7d40d59a49b25f594248d6fe00b595b797cb356db042c3efd2941ebea5ef661030ef890cc5bd38b8183889a293a2c10c80c3afc2e1d01ba16a205f940df4b2283bfca411fbcd955b945470962801b53e42676af8c40f1e93d06d5274358857c1b6a1f8b488ee774bb74ef2c97c4e899b340686cecbed232d821e09cfabfeed023034e4a404d929511a3a5b08100f8db04ba03f954a0938b9e26e98601f275e4f7c10fa5690a1058a7bf66f5198067fe28cbfb8a45a762a8d1585bc8919b0f27942af2d49f92cb007c81ff2fa5b0d96a88b9c192ab3ab5c4808af1cd9d9473d30ef6b66404b5d29d5bd3f2fee7255289d8cd4798ce9247ee217fbbf75b7eac3dd34938a77049ee0ffce1073b5738f3c588055765fb036ac1417432ea15b400368e38846eadf03acdd007a49586737e90f8a5ee5e622d15371d2fd7d6d34ab261d31ae4dc698157c68674d528057b8e92cd8c850e5450f227ee874cd165e68c35e88027cbf6b4dc0e9bdd91a4bc939144ed9e6ec58e6bb78513d84f194dcebd9b418a1b0b90372f7680f8cc3bf9c802c668600646b9c05ecd8c485be2914c5972f4ba5f0f9c470190e344bd681cced47f13ce3e36753288124e961f30f5144f8516ded74d141ea80df46326841755aa57b02af2b061e412a6425f25e31649fe0e12e4e21562ad2cb1a063d05b95ddbbf66967c8c7e1c2f9783dfd5590d770a378bd633cb2ba9f99dd263572604f37e07fdde0b40b513eadf99aee4ae60bfe0ce1004e7d317a79e965c7272774e7b19ff315a1ea692ff09889336d571d15a622ce5b0f51969d17aabbdf1f953a0e4c0cd05a65fee2c7b9dfce952dcf535dae1dd497979a776a83aae7f96bc848f8bb3066d0f5487172010c60a9062e17ea70bf0aeaa59b86265b319f52506318806ed209281b9a434eecb2d432aea2047f902743b9999f36626c1c2941802354c570968a3b8fa66069dea5c43a34cff8697af9bc3cf48516e94ca909606fea6a53d6c745b7b56b18206749edfbd50ab00c17ed7a29081e55921bddb1693c59ab3370a297cdedfe618ec268e788774c7de2a9f918f7ef62f5f03acaaa036616159ad2dfda64e6783be99a41fac03af8a7a92124b5775ffa38273e91938b7ebdbe4fe535c0ebb76a0f9fe03653f14841df2871982f0aed91b6c5cebc9eb2aeaea322e11b3aaf682f4905a52c0ff7fd7d1386cd340d8d04a9daa23ff89d552ce333a031d8de2c81ef83287dfb320af6a3a11a05c88b3cc93aaf40b1a3c638ff2604a936cf6282616c255715640c8056ce9decf0e61b5a23430cae66b8bd36621f75c344bb734ed64b0e712572d700eec378579d782bc6c0849f37dbe4df634aeb8fa9388d13155776f05748ed0dd8421343941c076d8cf64c9ab48e44016dbbbf528418e07e4662cb39e6daa3630961dfeffd56b2e5f42d8dc62ab148a47158981ad82a22d35c14d13d2af3c5f3c63bd79440d837c9de6bf2b60ed000ec9d209f83211ca2e515a2ed34b9e518b903291554ae17d74c23e9e59be2b9e4d5842a60de087cf7bb045ad7aa0e6129ecc4813e20970676ebc374fb8ab2999e3f7e854adcdc9a2c7d959e0712c5918cce71447deedb3be52bad970778de1a088f899f2730bf9d1c5dbd4dc7db9216ca18fdf94e3bcda51c0940bba44374778f68660ac3a111e6c4a05eb110ea1204b0e4ae0d35f2b4c8aab2966defcc96f93c1181f204b490d586d83c4189ec4a8023a436c31d370bd5c6fd85f6959f053efe40365f862fcaa2c80bb43438701734571e5e5d24f4736bd2c07cd33304f801b1bc988b3e49a7c8378f7e7ceb5ea3f65a40336d3904c58d7a1d96dc9f59c23d0e1b20a207f3f79b2d726594635c19b6cca44dd54cb00d7841d9e637510863a31cd938fe467e49142234f259ca610c7f90d62ac1e04da7f97a1ff8091eb81247e21c520b742f3264bae3955a7952663e802c9e41a486fabe334d59b36056bc183637524d6a4092a5f0729a1cf17acbbd448eeaa99aa499d10e2be57145a7ab338c5359d82e107afe2426ef8dc8400bd6b7bbb9aee326a6c1d447ec9bd78185ed89e1055cd7a1d1c588219b09e1dd5fa5490c3421b9c494a2051d9313ad18f5e3aca955d5aa1d13d98e85aeda350f5853f8727261de019556362ae106c6b5420c676b41bb3bad7091681f76598a14657d8b43617f98894b119cb28ef00e13ae023c9870ed34f93811a3184148de4722bc252fceaf22a262a8e122bc190db0caa62e7aa3d9b270605c65e16360bf5855b868855414c2fb3f4a3a5016b420b1443f955ce3b1260462143afb588b77b29cac9a29f91a1bdb3106aabfe5d1939e92c70073fee1c974c3d8c1944d642821ef59a52e1ce35ef5a0bbc40c94b66bb2b8a0d7b4405fb751ca36aa49041088f71a5529d8b7f00bb79193df025b80f103ec0c3d40d0ceeff11d8e3a936838a1ef430d7ea46053788422080a992a396c8baf440dd536dea497ff250b63419c9d9105265a6b43c5475b694cc2fdedf6896cbcb4d996a43b10d83a012e0cd77debbb6640927e91ae5ded62c549470b8b678d2847b07716fe41b29e8d273c00582cdba3c503d196279c1b16fc97c748bd98ece80f862c79088e9bd890f3fbedd23760bad35e3bf9a432271d8aeb7abd08198544ba57585ab57ff8949dd3c505dec09d6d49ce23694b71ac5db61c20e8ae9026ff0e02f551f715a634ed271f06b7d035a1bb74f2b97f646788fabaa721c901bc7ed63c50564244fad2fbca8673fb0aff6f14c4ab7d65ba7f8c9a24b0fd9ade8c9110f8f13d3be66904e16c9a7b5f739fe5791826626d315b4e9a24509a7c6e6ce8fd25f809cc27ceeef1560b04657cfa1f7fad492d73d0a496ac3dd62c76ad2ec4eb91eb8b30ea2d7b1fdbd94cc75b34de917a9337ff1534ba014b6ab3456eb0f08392ac6b1b3dd39e700358b5143a659654103b16288b75c9985c2870315286e4ae8b33ba521db0d3459c974223e4831cb298e2d801954bc1c005e839e744739db6f78d41c3ece885a0ecd5fe142f499ce7d6b7afc524fb8e8f11087973a591c1c4886936362a1ccb56aab06f752673627437047f6d186ffb5253f35077cc2bf0a1b6fa6e285dc0be71c6715e68975401d4df4995fb7452baa16cc12fa635647488fd6d78473da8e4bf8f40514e9c27123788ea3c9c0f4a5a6cab9066b152fa89cfdcf88f2a147d9fa48fec0953cbbd2dc56e5d0b9b751ac53e8c03df7524949d2ab4fcece2918128ba4281c80e0765ab271eb63d6618c82e93afee7458b43e0788ccbc65cc7cc6b19757c8b17db614e888290191e45cec487f5af4200a90636363df09bbc5290aa82e87fe4458f458ba4bdae6c5debba597501a87f6f31184fae8c8f551d160ee98029695da2d0573b8e5fa96e44decffe62baf6d92322f285ddd0c8c7ebbe7807c531b60a90acffa6a880b69e9b516152259f4c383ca43877bb26b012e15b5afd6b0a4ddcc47830cc30ab3b6d1790cd6e1f695e296f91c9af2d83505b61eb2438cfd913caccb4770ba0413c42f2fdccc9f671225d2fff13cea2a437fee5f0a999136e15007f05c9fe75f10b9c98deab43cbdf37df3e19c3c59f9033e1ddd899f8db3fe3c96b68a391d0f2da1912b6d3198c576fb40d75f1c62c033a160ed27f1f01ba27130f4611bcd5610c8863d00a4c345a2b700df671b81e0d76e8323515201ffcebae0669971a78a8ee31ebadb1db4499def0583d5feef19cb26ee5621b96630bd710252dfb41eee432337021a74910020a0c66cc828f270647b7ad623e3124826b15a8a8ff4eb54e69ad1a65fceb3798ebb9d03b672ae1d409b31045ff66f2656b46fd17de1da40b0c654281c47fad39f4c68d11a57ccc08fe351d1e4a44905a4de7db91bcfd3ca400829ea0adf123903322d83cd8672f220e8ccadd4ee3a0b277d789eca620cca4db0fe60738f8718c6552132aef75ffd38f3a036e83f9cc8cb44f3a00b922bd444ef2e5294670efc89a70944932fae042eaf5c72e099206e24ccd2e53e5f5a18e3affcd31e201ba2d0513b25d329725dccb615c1a4ebe723b835a33e408d5d9391da83d0ef110d86113801a9020b6e308643e35fea17e048090aaea8b4c57c71f7fa78cb55fde133c9007f0e9c8972a82ecc69b06f48bd2ea3ca1992322b0ab2ad6a083947cc84cfb91c7221002a7142b78c030e658d71bab39f5862a91104358852da8850bfc4204c351acaa8605c088717e176aab0f0046cd23cd1baf3196f4edb0527bdf8987a51d26acf55369e32a5328922b95792db0df7ca75891a0063a88c9df87e834050153a0b0cfa2b7c1e0bb58a1202a21749c770413d989a5cdd2cbe586de1d710f84f373cc53979146076dd7628244fa0e7315ed51bb34ee7022e074eafd0a0e00336404ea9f59854492649dc9964ca4ffc1637d5e8eb72230d776894e5997ded551d0fbdc79bc9bafca0cdf85c6592e74e5390c4f2a3a3732d17707dd177184f7891ddc06a6ef8431842746f73a591892f703c4160aa8e459e1ad4634008ad28cd80d34485e2145b726691188c3610f96fde4415200dcf4e317552bf5263bc80b53b9b2c73d7ef0528d215fa0a412fe6120028cc859ad09dfc7ed70b09acfe60b0b0eae6865817c3da6bd008c52f20862d602e1ad8c30fe01026e69fa7d7ba7b2567f5965a3ffb345f972dd2d3bfe2e8cfec95beed6e70997777adee6412ca7a38f7cfe446fe4d679dc0ee6cb826528b4143dda23f169f23ef8b433a1341f21f09fc0404b4c83d0540cf61eb38ef5104b755acfc747c3b607fbf77ccf1d8ad66d621853bfffdb3c33d0120e15dc3659526cc2b0018706327d4b7d59248f0e53182c0bf4b2a97ef190782c6cec15a7174f5a8985d61de04dc01c37c9cbade14b3751a90fd6ae6e3085068acda30755f3c5429334ccf13d2758cf4500fb4854373c2d01ae621a8d049c2a44be4f45fc680683a0d4018540223197ab23153250fe782472821d02f89f454e8dc7368a09d627251d8457f7c505bb2aa1690b690c6d30a1e0a5f113b9aa1d5e39d59502cee0013b2ac1cb489eb1cd80396badf7a09da2ff2451c8d978dc5485132113234cc129a570bc58885065fbc9fc8a06f59bcd9c48a0aa37b38cc472bfa1c19199855d60d7892790a60869fb07303534682d34825e70a6bb2a45cfac956b466a2dd6938954e271f55fb88b257a43ed06304be433ee464ccb6ea730cadd7935143af936ae8757f74dda725232777189ef9c6d19584378eaee7003e37c0440d7b8d46b7696995e6d7ab6ff5e56358077d0dc0c76313419506225bc7f4a813bd24622d40357dda4389c14a7e0a2e4e39e8a7211fcfd688bf2e47628612012dc01adbd96cae2d694c656c4d52c93e7de43d0488ddd07e5961a5e750a05b97ecca4d3d537f6ef62c41548bcd17224d9eaaa17b35193201c029dd94e4cf1b660953443d4fc6c0e2eae316489f4c77a944dd4e250eb631922a26f06ce96a2386316538434ec7f61d05063e91b67fbfabe98f434c79c4447a6b10872dcbae21f6ee2295eaa57228ac13a8d7c0117c91f12778d73f07e8005e4a253862c159a7e524afb09fc11b03905b29b74403a884c11d567ee37cb6416f445bc759326a691c649d9351ce9483f39f2c8ec070446820ae6517119e37c1a4974afc5c76ab5241340b7f6ac0194c13f47680b17b1bb94df54eb74af6bfe24d84abce86779a89f227f11d44680a8cc3d75e167715831fe53fbf9ba8015de7b4af430a99cd5c60965191c3e5d6c866fdc5a1e90bcd0d621198c9aefcafbdb5da3b58d6cced26a73c0ecd58d9d868168c60e80e8dd0211a518e6ea598c6c7c88ed29079885b5e23a7181111595d58ee2504fa0f21fe86db8a5b84020ae023777fd1f2b7d95bc25bacb72503c42fa658f605693634afea88de3983f48a265525f801f202b73a4483b9b243cbcda71cd5ebfb43904b32e1967b1d74bdd9937c48453e8537e666d6472ac1b6fe8755797e485bbecbccc1a6a6286ac03dff6df5926d6f66a0f9e32bedc394083a0241dd4eb9a01edb35afde1db269414de92d40b35271f101c3eb28507527a90da64584eaab3e1a67728cfc5721b5e3fe0fd7d3a96d1d3f405d8a7b4848fffb5080ecff1853968df4fd10eed3c968d06c89fd21bc489f87984d0ef472d45eac0a32b800c900b9e0f81b7367760d74b235090b3b09bc5ea357297c90a553f1ea34e16fd2bda54da06c7c32bdd6b8ccaddc19e678aaf5e4534f81a3a47a11ffc4fd5e5b7917a22de609e912e37a48cf0e583333ca7eedaef17f9c333b195c316c50b66157fc52ed1378d4e04c14f1fba448223a30ddeef571cd8c653a4b154d10205798c81e8e095c429c9a9e52ed3e288a241059cfb6fea0cf5fb6c7dffae7119f790afe17e3fb7cdc315b3d20d1553785e2eb046c8e637bd94f1f377514edbc21d8f8cb3af72281b676ddd18928835af6ce1c9774aaf359954551c863926ad7b25118c27adb2efb17ac5373c9844bdf16958285c47a3b959bbdecad257efe360037edbcd7a27c63a5f0ba165653b59e6486ef0bdd7dc5079ee7dbbc4ae025124ebb91e3976f747a8ea94a2a7f80bcbf5ab3c2f54769dce1f214ac27b55630a1ebf34d43518cac48f52e09065fdf5136330280e85722728a97fcda6283f2a771af1ae25a199f7060d2ce7ac4fe56e346b6b9f73fa9fc4c093be4a77daa6fdee66e561655170891206f79821cbe19e4eb8f90b9fb793eb962b8330f7b0de218f58f400a70dbf8dce2abec8eed03a62eb77605eee1cc151e28ef6e113d81b974215d725af88879962c92912f0aae450fb20f5e57336079259343e692cd398c074edeed15d8ad832518f2f079fb404bda2ee322987ffec04a95781da4234284c11650b1b2c0195d01491ab8a58ba7f62926a623bd46b212eb90d50ca400b0a3742d11790c569da39ca6ed1e782b9cf310c8aa3cc6fb9018d02e1999df2fc022d3218c58ba0efe22750d72ba85e893a3355738dabba8d44650990d060d18098282cf072ed3c391b1393f299a2f9a522da5aef862a097dd74310d2ab0dd35bde61d4d96421a1370244533cfc1e1483ce9ca66a352a6b69c98218c865ff1a10c5a38ec28a5a2b3fa9182e327144f1c76326f7656f28c6744306bef7fcadf1b7bb8c6acde20451723e011d5ddeafe048c2dcec6bae6772849d59ec57d8bff7ea21527ae0b22e41666067a743fc7779bc1b21e380ff376156930d680a7777e104ca6351a95f3dec5e0711dbb264d1e932c958d09610bc720fc2732a3d92646d550eb44ee345d125a6cb7fc524f79425212c5e5921d32de1a3a3044d68eabf99978d736a9e1eb8ff269301285c83e9d818ad5bfcc96d623962c3f6866d9997b7962390c8a7afd04290a8c39ea834e1b5fa65f48bd4b9bd0d05c83e20ce752c75ef428ef00feb9d29be3be3d152e4b87f76cb6de04d86bae934535fbc334e39555ce9084bd5ac7fbcddca3573a0d75a89ca734e5fa1dc80a10c650d2382309106bf66a25a6d378c011e205601cb69db25e21839041db6e6dfb90185706e3622001bd65e434c4f1ea23dcabd93ba4f2cc2d3e830bb33d3f22b5f0565840064e653fa64c651162be43fe72e8d1598114986c847d2d0c1f2004332e070a9a22d47f871a002bfcb65220fb0b7f89d911fccd93da1c5bb34004e2937dea8c35c0eea1fc4d794c2921bf4fe48c6e91b8c974cfcd650ed014aa2f331072e92f98446b3bfc4533172d1591a26b83e0e7f7cd663ca5df681865a8e3b01d094e7992d386370e802b57c099c1cccbf85d25da150efa1d1113a3b6160029827babb48a3bd3a7f2f26222af1dfbff70eed76b18392d734b474fc6b19413f6aea7710c84ca8f553d4e84ba5f0fb2546b8faad3d0ba91a81f1b0bdc163f1efaf2de2c73b0d81b8b9b7203ce0cde505310183f25fcfcc38267199b7aa1d08c445302c0da99b546fedbef0cb384750ab2d497de0bb9d8031226e6d899d213ffc90fa76152b9d59d1ad741869dac87fcefdd90d0b022d954acfc3b40691e9bf84dad00a844ff865f89800591df1941095504311c4e26adc9073d0414f3c7a45b25985ce1be9ab06186880fdd84ff72a2391d95f1b69db30f2c39bb5ad0b4a5d6bcd7cf9cd859227254805d40471b6ba335441ac16b700281068eece19b7f7618a9ff14d8f1db0cfeaaadcdb695ae6638a892564657de8d7c52893f9621596b146da05ef79b7a4de34129625e07f2b57bee5b6a278d4ac7f9b56578184a964ebee19f7ce36b8f3035a072ff63af2b999d01d04424cec289a66b8ede54126bc02943007001b859237981502f838bb61a4b4ae4e4e926ea956d419e49ddbc5174df438027073a12823de8656c26a02865bb1b3489e7e25c7b91703263ec2ca17c76130a42ea3a29066335951ffbbd490580bba71f43daced36fda5f26d64778661964d6a3238f29e2117375b6ed91d3d318948eda98da89b9552e56bf5a6bc96bb070f8d508eb535c7c06947c0c9e62d15d3998ee6f29faa2e452a89714a35d6d222b54f226431bbfdfe35753827d261322ae7cb7f4a187204a18333e28c41b73a5229769f9218b7c700c3345c987e6cd8cad119eaa5aa52fa291b547ec4ea0def03e0067e5631251e6ea237986b37a2e56465f09b159c5f682d9807f30a49dbe35303f39e265b942ce133c87b55cc5da111c7bb7e8e673b09d720f0046357e74edd646b0e7e4aef81b1bcbb51e9f7bd53b5cc337fb839df18a61354b9c916e1ec0d05c219615dbf6d69b244a20faa5831aba10c6ac2a852c4f3a76eb23b55bcc036160e06b7fa31f4bd53c70e694a49e5f7219727c30e0a807236cede75108c6978cd63241b217ab7885305ea8034b2fdea3245979ca7a231e6f0720a27c235d341cab7d6b595ea398c5509c5289350c330e09be2e83ab489030916520394a31c0c656d55fc6d984887b27fdf3e85015a850d75e14099e2f0986e0fc0001dfa127f06a102dd746e35e4a4e1dcf31793066ff0cffb38cfa275c7602ca9e213fbb0f358312b7949e0436be58d7cee9586553e4163a60ad6ec646f2183fdd736854a60bbd62f821f8413a5ccf1df3ebcc04c752934c86e0d1fb3b767fac86a7feed134e085c6db6937669263e7853de7d931f3f17523a3dfc09f1c50e20b0500e94b282c2a7c0df8bd298fe52e41d957758c3ad1e9a512bac7b2c2ac52ecae7123d8207045371985f2564dc79c16ae301181e4709ef124c2496b178edfd1dfa33d2e9c24138ae7ba2ae5ab92bf7359cd212a9f46f649d78e28b4b144c2933a52fabeca7ad299d1d088310af847b336d878993a2ede4d0000ec9ac074d981753f6f1002ab6e5688ef05bafd1f12a0d733957154d2b78d3c09808dd278e96acb7a28760d604ebc81046349beb1ddab5dfd4629932fa8b11a4c6d981d63c2bdcefa95db7a4bd96805636dfe5150b325a08b69d645f0ee3d232385113dd376e98dd33f2dc17e18c7f6d388d8d3cc40bda727a1356d99b34b6d6aee14f4f27146a03b743e656a363526300111e53a1089783e2dc0b5d45a532bf8ee01250987ea9207b01c20e855198461395eb6b465e325493e6e297669695fac02c1e54f825f6710c5c1bbd96a179e8b53435d99d3cf402e858d14ecbf6732ba7833b16ccae087a9894b7de099989118008a7cf22d538218fe19a2f8cc1f427fb2b6b4ada3bb0b22adbad068de43fe71bf14fcd6d4ae336e4b8c7923b97ffa8bdf8cd3eafedeae3ac9ef74478e56f4eaec3af28d49078727043b579e083a4a79da67a3090a0482cf90ecabecafa30723b2c3d6c9e010c06ec4902456a84c6e7683a84b62d1627fd7a4403c7818d1edfa62e6ffccd349829474cc3d5f140672fcf6b7c2e9cec662f9ff0781ee05564f99ef980b33a403b650eccab2cc6a51b9be4e1c89436b67b8985f95b464035238d1fb0fe30392d0cbba1399b370e4f12a3fcc5ce838daf727078f391c4a665faf2d2e3e50739a26e411c2b840c6e7f3dbb498ac804d4a968bd70154a1828eba924aa5f18c21f1e4ba1cfc0577089a56c26f7e9c33480e637ff3baa71e68be16515a695588a01b8f76278730c327a3d57189cc602b908bb082855775580503e5556de8215202da9a71dc5d03106039b5c7cffad9fe21c7216e677813c84c2c6e12d0fe30edab94f261f29d378a5b1045d904fafa1e4963c324b7eaf0fa640075f2302f68e492277558457d726074a73e9190df06c96ea847eb996b892d301d77fe8b2f1bc28ce9fa750092c4e386d8664792b0b4c99dafa135a34c92dc1af658701f17bdf0052c28051d6a47cedde90d1616190f7fdec6881b4537c61ad52c987bd6cf8a48fe0b3644aeb56cb49cffd77c14f40b6baf2a6b932334d053430c048788baf773bed10986babd0e6377de1137abce1235714787b4046c8013dfd99026c1ace374977a621d1582866e38316b161df24fd267cc3426d49e70177c2cb5f6114123b743d4a76ddf677c81e3cbfd5ab025e9315ab612fc5d10cc9942d8d2273d020946f46a6cf97328723e2b03f3eb84cc92fddaa4630b3363a2c2a8bafb7a59b88f9e9ed522db9d48e65ffd3fbb984d8650b3fda7a8f388e2be2aae848e36dca798cf4e20dc048a520fd8c35e5ad60a20b88f5eef4e96a403039d4855c3bdaf35a17fcbb26f41953f0d197ba2191e4c349faef02225ce1434dbda5ff52eb8b3ee85014cee7986ff71727ed935d1b5d6beb33d35d426dd905b10c76e066cd5420522999cc2339e86a95f830e19efa51377d420fa2df3b8bbcb202b65983ebdb10605086cca9f2d8c6f6eef485a73548f2bdfaf78709671a25d4837ef9d74bcd5e602197ded5cec5446cc512909f242b415580a9a2013b21be4d1a35eebfdc85aef52f7bbbfe26683e465e7600b9abe993eb9908041adcc112f8b02e4e2c706bda3e857705db7594a31e0434447dbc26e53b4fb0f89dccd7a80d4b9c7fc383eff80946d1fe792ac33b12c8c2510e3daa1ab13057a0273dcac42ae299ac48a199b59caeff7a0b85334ef19eced2bbb238501c4b1ae6bdf6b281d12a2f7ef40a80d92d33af2c3f7b402c6aee7a14046e59cc7638d3cfcb373f781112d7cc9304920b5904ba2d84ba6ab0a8c4671abcc1861200ed06313d54e88c2e862a3d750b6075b023a845a2393dcfcc5a69c77f05fe09a72caaacbf4b40832a34b28b733fc7f25da9b9722e6bb1a3e49098ee296f896cc3821c6b36bb77c488c8d3c2a576cbb97af836f790e965fa0965eb3a2f7eaa8ee3b70ee0c381e967d2e8aba962a2e3730af5dadfd35f13c4ab8e2320f63ba6ae84469f934c1669511a21dfc7f109e9a9df10ab68bcfe44e586f396c03faf2405afe380c9ffd00e157dd33b28a7dff5f7e53a6ca1d73834a3da7b4d669d816b82a587452c21e68d4d1feb041e3beb0111635585047cfed18d75c45428f467b56b9f809ad70f011dfafde6d5d10e1c6738260a59abf26d4a2cd9f5540a8b21eec9cb94463d386e366bc7ea71e1e3add19a158c905bf3c434b1bfa848a48c4dfb2170b81e132161053e5a1a1f8753f7cdcc79d17e2c906c1f189e4354e18daeb8c24a95703df85a640467345df48fa8d28047845d84e9ab1c939fdfe886ba879a59dee3e172fb20748b1898d724273ecbfcd5e08e76eb37eb6bc04233b1521603176c609fcfd425775a6dd4f1c96dd60e52b0db996a6de05e9bab17b142a6d0d0142da0c6a387461af53bd3e025e9cb6515bbb68399bc5dd5d7216d2580315edc69d61b3117ef00659ff50cd2be901e16d70cac6343b01b7741a2048edf39f7047b3e10a7ed682f167e2d6bf6aad03b2342566e8fa9ad846f1e9ceeb7eca38a7373fcc2e393a21d3ec96afcc4ba24c24f23acedc49ef84ddab97add66ae4c96822b7511ceef76fbc54882a2df8762302b47dd13a9985db5b2ed5ce2b4c1eb440d405b46f7926c32ddedb51a298a65ce727b774b936abbc14b48654e88c30073fae243be78d71f73ff3754ccac5c9769bad267e4c6c308769821126eb0796bef7642913e1c2397c864d427459c3f72ed331e111224ee4192c5fdc427630f7117a32d0f626d324cb550631860aebaede779ef02784839ebed034e29e81ecf55756934ff155439d1c08501c0b59e40083d861504ca8a9e29be2853702980431e710176a756e6c09ebda2e3c1fb92cc99cf20043691300b8d1b1538a97fc18981b2ec7f26abc6b25928ae648bac0dad9468638446aabb9afa236b56005cf7f802886c4e106d26ca2775f3fe1c56161528924a2b95bf27dc24bce972718d300a9e47c9c84529581cfd42997d7c0c9242ac01f2fed18d03df4303141037800790660ab775da5fe32ea4b9797dfd0e15a746199cb1c13a272150e7d548841dd7b1ed6c7df4ca73b8f4840ae660c4ff73bce1956b1c39013029eae597b28ec92a01f89c0d003c742111ded1850ee3bdc3b70391f42216b863b41ee1ae4708225940182be71eeca9389284c2f3e6fb875c83720ab121a3de028c421bd4a7f26ade1efb156e76cdc65d9eb6ebeff6f15f6bcec415f2bc2a477652691ed58322e52e5b988eae4b367117e4913f15db9df28b7eb485b7026a628fb95a9649e39201c32abcb5987a6aae2d996535c2895ccb67fd4122496f7bc424707da6213c5bc0047139b5d8679b7ccf302f86253ebf1e97a8489a99ae661c62874d7a679bf4644ac19a5c8d4022864d96fb5d1e0283685466172838c293c941e5c0df5892d22f469d4275376123eeec4eaf0395d173057eae7c1ec1f899cd396f992536351784c81f0eb21c40d80493039b2befdb317a626799e80693b525d89fc2afa94ef23618b7f9a4b5f49a538927c7499077a44db1c7690eedb15d9852204373dfff0b93e5a89631249aec760da3e2611090feb54436d4e72c147917e4a55da86f549f36c32351942e7877a63ed74f2089fba08902debac3051334dd96a7d59ef9f99512962c3eaa893467751d4456acfb84bc1f4e2b6dd8a025a8ba3f228de0c11f0f874056fe051f23550171df7c241563ac4ff4d24b80ce66e02057c466fdff439ad043d889515ee8c1d4e7f2a5f69d2e61fc9a9b21f6078fb17a53863a8a2b627aa0eaa631ecf06280eec2c55716e374ffeac5bad6696788c1f38be35e4467acb2d0e56b1543c2f4113b9c8b7146e32e4b5be838f181adfca1bf18a9f16e04164cf8bad3ba5c22d5328a7d427383e7781ee12d20afab24dd67d36630078a998fe1a4af02a4251b6a3a785bfd6acdf242315537219ce9444607bcd7e2e4887bf12b14e1b329b2171e3f94b843cf57f41885753d604b920040601a1a362e49c7afe3005089dbbdee6f26674c6a19b55854e15c6c3045eb68eca6bce9e89c51235c437231838b4e834108959745c72465709dc895cfe81fd72fee5ed689a863453afd1ca2f384437a7b80fc185baf20092af51934ed75445d155df172c33d0671a92cb32e009db335d8479040a8ff176e94dc2d52064a8da4f1c2bc7408a54ad012c4fa638626fca28134ef08a2f1365eda594420c99bd4b7c7435a9b1799b10198be00ff0cedd82dc10521e322be1cd952c96397314cbda045944617fa06534f142c19b099000b18a62e066515fa546300bed1a3727744e9c2d66097e185c6bef597bfa81ebdbf35116e8b1beebcc465f82d424b0f1a0d1da9182acd9ee7fd3e7b475afd9d1d44130eb69e5e1233b477ffe0eb74298079b921b34c573cd6ac5b2e1f9dbe077838aa011660723b36210825236c4aaf40fa22d68ba6073a6303866c342656d7578d3a0ffc557bf9de042886ce5931fcbd15a8d8e6af9601d2f2be8da6ba9bfd25eb231cb28009841933532dabb39528b3ec6ea29767bf65742a3a9fd37c5ac6263116db6bd25908a4ea4a42bf012bae262ca1997ab6514904f3d3ad068bdfe8de32d160afa9db4de7c177913ecd161e4097714cc34e2b226bcabb577d0e9748e42e24e09291c6fb30ae48eeeb2852fc2285ebf041fc50463b9a6fe9e844a1c8790daaac92a872f204917a25fb4e41eb603a9295f4ddc2a6ecd4256ec7c7dd73d769eaca66d631c2b1951db28a2aa8923115afd58b30bb5d9ecc0d393b24d4f42113389cdf8fcee41a85a1d410e3b746e0c764ce6378973874a949a0e96a043049ad1fc8c896a27696d569b8e1b7736f055f0ce5766f0f3271c7aae48fb9537b7a64051945defe38e1af95ac5fd713bfe0d9a16227e97c1baa18580d8418377140a880c877539eb6d0f8d4bc6013737e66a6aa3d1a7c803ba4ab9eab9656927d9d097b4c83cac4c40ede9c32c5523c9dd0b70d6150e690144fd7bcac24b729e82201bc778c64542a721d5385c6f4f27f742d72e309b5c51e01184c2bea3ffe4fd2d64706c7c832264ae49e69cbb0c41cd544148c7ece8d7b5be0cf4982150112ef22bf45d65dd91c29a074215bd904d82e18a0db367b1c970d9c9b692d2b41d3bc92db9d95fd2975c21538a889f0a1f4a3ad2e0df329d023f87c1766dd61c04bbba2860b47ce15b54ebdbe559d4ccfcbaec94734b79a61f943e1dd2bd514051a71f302b98582701e4061e4bc84621cb7a687255812c9007420817f9f68f2e27dc0bc3764e8ac07eac9b62c081bd0244a83282d9697c427116a24e09eff1fbc01b4f50b9ddfe32960c784b4ae995c68cf2d373bc4b48b13461457ff3889345ceea64b90917c1252c0e3e7280d69de9a2a2b2044d706ad7a8e01d4b8712cdc1bae3982f02ecc835c243afa1cd5f3a6d9933dfd012c8fbfbf251491c6ef6a70b125d627e595737c6d0b0550bbe9e8ae6a66a971a2789fa11531b02db7a2c720b28bc967e7b1684d6c5a6ceb467e4839f1e805fc4456b6ea4b5600834f3481d3589b815c442b3be1f818f0ba0008c4fe0682202f78fa877fda94ac515e12fec5cc75fa156a1c93f59a087c8b5d6134db59234f8884653e323dc6ae0e7d2fcf219a628b02355c546c8df56b0b5388298c73a598faba7af7cfe1503d44cbe6a9035b42c1dfc775ac6f0c05e2f0239917414996e7c69fe8749245d3611b7be17c9cd1f016d2e515498d2cee87fcfc284d96c34e0092ca2e1026710cf0144b47eab8c6d61a24ecfaab8b4574cfcf354b556f89acc2d62868580282ebdf507e7708543e5111c4dbc6baa9452b4a020ad3536fce50a6eb21595db978891c7735be670dd7ab4e10167ec5529262b3fdf796fa84af26feb4c0b4e3a92f6b172ed8b8891ef6530e81b56a6c04f34d5c7e95078edbbf94bcb033ec995aa7d4d2c330371f843885196dc45ec08320f0e77c74a3842366af5b82a50679b9f2cdf17f2bfdbddea0cdbf5085b80231eeacda0c58f41e4ac2d1a1f3af5a6f7212d5cab1848940b19fde45396ae054eaae86d9863daa1a69fda88652544649847722ad1b73af7b61a398ca46e725601b7c8368bb804766524cc81558833cdf6429201f366886cf75289185230902bbb69f82521efed3783eff444760353f44698e2825b93236b019ee4a8574001ddd30138da242ea307d8c5ac6a56da0598ce2357246f898ae462920912323ada6b402b2da38eafe903d43549c941706041f370c9e260aab72f86d78aa24ce742f772531929bf78ae96a77baf65aa3f35871c8d7ba67fd0c887ccaa1540b0094ef33695b06666a68e4a2d4cafb0e01ca711f1bb5e2434c253d4e68481f88d48e4a36d41aa43a0b1c64ebc024a4559f9c0da9b793a6c4c97a12bb2d00b8cef906ab52fd7a0382558acda8c03e2029e743e122cdf89921f0a6ccfe0a222443ff1f99571770cf6d1425287648ec150ced1aa6f1574bccff049e2576f2b888b83b64a27163832720b9e50776934cdbbb20d86737cc506155be169092f619a08153a8830fc7c3473ce6fc06f16b1108c85081a5764e6856a885dc470994a7a0aeedd840547cb9c3e87af2579f92697d91341240c2885d00115fc97fee248a290f30d1c19ae2d7cff5abfcdbf756ad52fe8afd9148cf454153e4c916446dc6dca0daef3d7f1a075a6a34ac0dd5d95e80c9f182781f4173956c7b1d3618834f2996ab8368ced35da9e277c22e2d39b325d04761499c3b77967ee132bee91238cd7e5e19010d3fa9a9b846d794f3d1c9a891441c6a74da2c9b8f0e38ef1e5e650656b6411aaf32ed758c570ceba9239816c3a0dab30ed3817b56831d6e14f666cacf4c24d5199881b0d2f4ea33e557d045d3422ee92e093e4216f94606781e37a6e41b7bb0a524466043f94c4d611ee1521bfc3b11e1f99e9a1283b72130cb8e83498bb0eae77b4cc77409918ca2a1f2ee10254f297348c588bb6594e33f51186dab0d51082e019e1a585cb0a0307d28daab11cd5913a6e7f5a76a626422c89e96f3e749209b4a66000c482199e27328b0c82cd041a838056ca700e21e8291fd55036b0e101220997b9b1509b61800e445420b2aff9565e142c15b758d3741347e1db39e027250a56dc64cadb5f2272a177b7b03ce4951907b7aa971674d4e78f7a94507bbe8b3a26992676771af7110c695b78832a4573a2e5ed68b0d7e52f100d33641e46f8ff4562ffcae8bf8d1a73d6d084363b1bd1bdf3d55fe81eeae665dd26fbad5bb85bd2fe081b75b93cf79f0f0b129aa1e70b4960dac9d2e3a9076950df4fc02c2e8aa647c9c3300d8378d722cfd740fe361d4130412013a47b62891d3b97c50d933e2f21d726bb4989e5afc63b2fec436ac2e2cf9e9ecd3e798670ad71d211d841769ef21f7763aadd2ba8f57f1d2d3e31c00fe6d3b204c1dffdcce35dad877b847d4b0742e990a7ef05fb932dfb3a919b1fd8a1935b61fa234afbfc1ae9efbbc62cd0ef4a397616441464a2e8a151ae2454f74cec7f6ba61504178bfe7493cba7bd215d13371eab6306d40fe240bb1062e6ef81d376c1a73cdd1d232b04709dcb70922c474e5dc094ff6b9f70d70fc1e60271a9d907df4247359ce62405eb91fe43b3eb46b00caed7f2bbdc3d185aa3f1d8240e6cfcc49f5e27113d031156854ac994db5e6ac1adaeade00ee846acac99ad7334240494300b3abac445b343e77c91a554a41802703c9686d9038a1f9fcdbe072489ad42a3878ae2556879681ee63dea47931e9fb306b25d82bd3e0297a5f70562c0440e59037f54e9609d729cd0a1fbf2c68eb2b8bae0ce49363e561ee9b4db479c61619b98ee735b49d80c1ec0ca370b7523d3062e1edc7ec46362590eca433fcf234af3c94d7e4ba1d5ac8ffee0c2da6d9b370f802eaedc3cdac49ecd9a8a557f242e4add3294896eb71eb8e88374cc0dbde0eeacf42b8d7a8bc1cacc27ad133a0638e33e074ac95d11296a85b7f4b2d59e15ad6d32a28c214ed95ea03342fb97632b3ac07b007a7f870d0daeb05f922b8f5283f36e68747b5c7dc7fb916de7b5539fdf1555b15f88e5a425558e4181821e1868bd1d6239b8a4199e174ea9fd987a9705d9bf5c3d7677c830fc747dbe51f2181d2a233f899806d5eef8c176bfafefc4fe9866948af9bff461008e9563937f9f024cf1e7671074e09ea5a2863936eacf7f58c50652bcc84d9a8a1d9c49a84ae93119701c5e63b31e39eddee055480d4249d2e9d6a32aec6ab838f6a1ee00ba62f5774c3ca26ec32bab72a1c2a95edce1b5ee5420d7072bc3e9fd4e33e84e76d376df4c1f43da260a95a4f8fa9311fbf6b790f08fef94608f4de5c79aca690647d9c7f608471abfc0618805ae917bc64c9816327c0c0cc6ea565d5d0b4271acd0d7164729867b1ed0d30e255871e2835144f4d3d099eef921469e0a3137b4d838cbf9e6515d5b99012f84938103b9bf94fd1c2a35a1f56a0b8698a6ddd234af27ca71bed0ffd0dde7a1cadc10aa3451307bc428b23869c76ac8cfc0e8c9806ff2bc1fbd43fe40d3f7d07dcc63c5cfe02b1e4f1860849aea1d44ab806618618117ab760d0e5425bff2f5cf845399e5cf8cda620de752bdf80a0b0470ccf7e5b93a6013ace2e22df8345333b381b5496ec0c87bd3684c4e2800da1b07b6000fc5c10f406c94f6214f6257d0e6d59250ab6e45eec1daad0a22ae2264d84e5bdbf3c55f59966c48cdeae19d5a8bd493a97e3d340464fa64836a2c6ca1326e0d1284779250847110f392e9b7f071926980e28b16a81357b4e285005957c36e1f46917080a085d75e563b22c9d1b49b5447cad4dbc1544402498c3e44f95ef2a8eb53c0bbda6c53c83de18864fa04111689c62b4f4e27182fe7fb60b451acab0a762b9a69b53df9a046486981fdf161bf94feae31d406c7c91c58baa86e7613369b2f5aa5c9f59b95e08f573dfb8720a4511bdc8874b0783608e7e37f9d1513814ff351100a82c0cde521cc2079917426067a998a59746e3fb4c8622c4393c3fea5805d2f84c9e0d70c1e5b23ce84b7484e1bf67a30afb8cce97c73f02060110d4f00c86dd1c6af0b3375cf59182136ce6437564bc27f10322afd0982db1dc70fdfe42261e7e905111a5b994f2cc64c1d23360353cca6c7f157341baa1d44cccbd67769568f33957a4181a5807e094cf82333ee772d1ca43a045a524655344d0c06c367464593df0f01137e479064500770c6c08ea090946a85a970ff53e38a971374fffbfde9ebe2a72a94b8faed0d3d05e7ff38b6f4ced9a60d0f339c28651a448202fa9a4c4935851cb64c4d3706033ef650166c1baa8db47468b26495d73391a4ec81fc2c60abea673192fdb0b4e1f755b0d4a794e4998e6f389685a28d5a16f163c72a5cf4b794d3a2c237468559a1efab5eb4c1b22779a94e1319c7a27a5d49d545112d85c2442d2b8c8608525f41e2237dbf398a1be4858bb2a6dd7102b24abf42422920e76b62966a79ceccbca7f6e42e54969e1c43fcb0de373f368dc0e2d6bc1572191f0a333475142bd85bd869993da3a55eddd2d3a9e9c71c27598629979b6f027a9d053e03c0bde86cf20f439d23900e09e5b5d03728e47cb8f9cb1213cb6e9fc44872d72fe644f12022c88811f6fb51d2299d5b2fd92d45c8edb939e87997c9f7a635dfec3413f0b989c2388c76bde7c2d06f821c96c2548ace1c624f4bce615c4c46d62f35f61759d6019ae86dacd80224f084df3181c6c4ca0b0230e82de18772b8eab8ed56a20b96c145a31bdca0e519a9ef9e0ffe67fe23b396f5f9c95c42ddf568b7f16c6ce4db331941773ffebed24be3706e2ffed2905870136a30793bddaddbb12cb98f13d2d2e454e80adb45cd14691ea8f347553a6a9b849f3e7ab118e24e52a4b54f6af267b03b661b16f9033df49b2eae7ac771455d6f97870a72b0095f643fb5fa6ca8240c8222ae91b757cb8373572e92dc451b533d255ecde1cfb1d52269487afbbca65c7fc57872c816d076a6fd6e9f3627622b5860092d123377eea45f47421df18c94cb865bea678f6a2fbbeb876fde9e2863c4e18623631b59171e4801da5b45592ba3485b280a246127a012c0829b617af76961f424cee9ce8e73bcbd531010d38eb88306103ed0c97de96698b50db22bb98c6abd71e92f31004f7b2045ff883634b6f896fa99cbdbfaa0d650727d94cfb5d0dd5082683bdaaf75c73363316ff80eea7e43934b2406a3b44218f1d07eb973f1c11f1ba215ede41157cc91870820fa46f9a867dbd2eefdbd9ac7e99012796e639f025d5e916c464188f21e519bd11be2577ae3f650b2004163671bbae008d3baf60aa88e5754254c256101c3ac2e1faa1ee850cc9fafcf08e465158cdbc22863661fec84375ae918ea9061c367cd4fd1e0236a85b1b7c8a6b6af809104e93b734cc22928416ad6fc9015815de4bcde3fa76fc5f393f5c89e60520a3740a3f19861759dedd3c6ead972cd8b7e0a68254ff59662db2991758b26ae52b734c91e18262c8697ceed2b800805bd129452480a3c250198b49f924c10039f0d6a22972aa618e6fa9cb5824ad3bc9768f85ca549a5daf28111efe9c3e00784cdbc6619dd66720192ee515b69cb5cea42ebd0c4b0c5ffae099500e22ba6a1c948d064b1c0418c33a1bc005bb06acb43fcc44cd552af6f3dcb4287ff3c183183e526bfed32331175f928b347bbbe904a9541c3c0e97ea00c131cc86880d7f08be28a5da4975c85d8aba9e9cea54ef9635d13e4d32c0eb49ca88693a3117b5dc13985d09357662945073889955d436a6326391314429598673b984b9f8944cf548b7a57eca75bcec6e0e607416fef69fa1a8f0c255361d78c4ebc7d611db311fae8fe8cb1d53c10fb0d0f2231fb987b63879e4699984cf3d119646e0a868928f63fa438253f86137479b8fcb6913fd01d7bfd5b5f86a3818577b819ba0a8dd8f8abbcd3059df3801a492f42122ae1317fa512ec8e616246fdea552c6eb722b73f0893b28a12d81e7d84362d56106bf9c69e465b75c67679fb6673f367e8486c3f6f6b093ff88f562c887eaee2f1321ac2012bbc23931c7fa3552bb38c9db759c7526d154e73db223348290956f0df5765eb404c18f3f9cabceee81dccfd2e61c9c127b36095fe64a49100a4cabc845be5a70350b434dec66f60e0b7218d982081ab5f10c8c174d5dac06a490df0a81869e175cdff20334a66127c01e244ad8f3a90bed95c03ef9c1046eb0e557597b047a82593d3baae0302593da5824082b0631b5b0f1ea95dae616a696c0770d134b7e5aa48318c07adef0e66de4fa52f937362d6b683f27b7469cb5f84a63e0662dd35d8a1c417b795bad5e98290eeb4d5df0c5de776045646ce325c075d552a6c66f2563fd2dd205574978a7f75c73ea573c3e5d26e88b1dc45272a910643773230b1f2d6ab683c14add2ef0879b8c2c4230aa553c482ea06a1503ea431af9c7393f5097ea5dd460b944912b2f42ee08bc271687ccea29f06f6002fa97ad07ea5954c3a108912bf8478ab5797126fbd7fcb3bcad74756a8f2a2f893547fb17ae7c867b516e3bc05ecf5afe78c1282afe467c2bd93c53421da4700caca5db844886a1a91ce5dd3f7e35fabb32bb0bd1ee267ce3c0bb535203bb7fe5d3afc576c65d7d84d804eea12202e06734744b1790be6fa2017214f2fe34ec09489ad2a6f59c016202935c011f39157aa5fa741aa395fb0cafb84c3caa6c7033a338bbca4ad40b3d6aff3d53e2f6754c70eaa031a4ec3afe5c53483ad762d0cb458b5f4a4d371bbbef7845b11f6cd12ea37bbb31eb4cc9c6f038d093a2d893347516ff5bca27ac705ad1b8fba983905a697d2e8fccdca68ce49d525cdcc3eac40eb26f5e16afd805770c0a5b29f3b8e7a95cff1c69a9da2bd164a39d4c79af9b2464ab75c95c38468b2d80da8be3a753fc1b66e3922a4ef07da4b79b34849749508f7aa5775e34453b32036a417aaef0d36d3cabe392aeb75dc8c1860c4bccb0f0e6b02afc811969fbebff6deca21c181b05d291b91d3908c8c596ad361405b5839d255efca13046e971a6732f507b7db08135cd8ae2fe1ae5dc35700c38b34c33995294de86b99f62c57b42ffe3ddd8e6e6c7a8ad4b5c7ffbdf384e9ea4a784784f08a43b1648d2c1056a3d904720b7c4b7362eff5eef091616e6ac9ec6e54753fa5d129b332c017c514c9041a0ede866c3ec9ba677bdb95ff35caa444122eaa76cbe2002b1586adaf1fbd03bed72092d496c496a5b68edafef48e08637f4ebb08de3cf834c25cc60cb96afc440648a6f3e70be93833af56e1b8c1e308461726f9d804b140c49f81879825e26eb15a6fc5fc75fd85cf03c0cdc4c9c03810d461d7d71494737078018fac516ce437595bd7ef77a76021e63cdde3f5a616fdd5feeb4438682a9f853374f018097c4210cb576f1bd179d93e0dd89c31424ab316759f75d2a3f5208e4fc96301a732847a30f48df9db2a35a389eb81ebeff5971f4703f56147f164da6eb27e70f008470aa99717ff5c47b9b2de860e51e79171a0dfdadde7f4b0b27c6f66503724cbb22891f690c91eb8f786701bcc0d35782ad7802a2cb119c653655fed8a7749959050c63e9b1e80d7aa9ca7008928376f604e245ffbea29d2bb8117a71f8ab099b8188115b92975b9bb4b8d75e477d7bb1aa8d60bfc9f0faa132ea578ed3125022ff3d18b9c832ae956d2fd8dc2a0c5ce0c42f6a8126108768f65a691d79943ea5055157616ee2434fc216a0fedf5bb79f75c3d552c33ab904a9fd9d4df700a322622eadbb6d9d8d1fd57cf7af7c843b88fc95a8f2ac4e43705d9764feb32ca587d3625e6d8092dd397c6de7aab8ea7778a7289f6ffc65a232db8df939152882ce43585fd016ea82b35f008a084d620ea894d8fd05f5e4e1979c18ba9e1f15a2c8e5163c7b83db56bc8030e883282701276539f7ff28831b8e6fb2235e6b4543d9bc8cf9083374a8f7503ca801daa0e7df6965dcce97c593667bd182a9f43dc2191bf87bbcfaa86b834e4824dfa13ad937c4eec5548bf07b3367327ae423569fec9e6834ff89d4111356b8a987039043287f1388884cd495e698ad8e143de61d407b2c91371e98ec3c6b635bbbba02fa816766e8f8125928d740fc60c01ba8cd57fe58b4f56ab340ebb02a5caea87ef5c2a02c30fb5a0c77034f4f010ef651702f44ca4e1f1df3a85377b4d181abf8830646b5a5bbea9b66af72fcb16c276ee24e4342317f48a6d67a65c18755746fe43998109f68ec023c19fea5a59002a8a004f4bdcc6d2971cf863140d9f33a05fc59d2b05a8f852d50cd38aeadc2c43d4f04cb13300cafb8a1ce7137f1e19af841a8e15a193f5d29939c9a45cf995ef8e47bfc019cc2e854477c0f08f2cb5f393a2940a9dce5b038a1c406262f7bcd494386e92097ac28e4620d11c9f791049dede10c0c3b9169a603228bbe726988146c58930723e38cc970dd9be188bdfadffcea082e7713c1edc4efe6b06ce49ba432be3b1cccd70f703f5a7ef6008c158af4cdad562a7d1d3b2ded79dd26760ca6fbf5f69450c07a24a302a99c72fd2036aca026682394b6be27186c32a5a52320e6e1a2f0bfff7a002dbcbebc91e18b3c6bb0af8f38092932cb88b97f19d125811f22f8d9eceff058eb8fbb396a7f084d567f0a7e950cc006065597567c672a9f2e9a62578d865f9e3f078a596676f072a35e901527f5ee24dd14e20c1d86fb6fd1a972031eed9e9111013b7820b3839eb7ee41de1f182265c17f78c99d4359066614f45db69555ad350e933624fcdb9ae5fac49034d37be86b66186b3c5c121060ba5463e51a31584ddb21f5b3ce8c6502c99617239c59eaa820ad580de1e06b4bb413e15e039f20cfa0220b0c34f019755d7bab6f0292cbfbadeb8420e38a2f1908c343bc73760aa0e8c3afaa9d6a0cb5a4d13a13504ee7f9856c7e6ba3fcdf13636d9e68ac3a7eaf8379b180187cdeb0b0b2168d4e12527230e4331f03bfa13bbe57950699ad4896a72fcf99abdebf03331dd7790a3fa0b94d12bb3127938d2cd3698d58748fa650f16abea71fb4fe036c43688107e6e42b4f12fbfe42c5d80e9d45e5779fc5cfaabec974d300b3daf1f78390cbaa92c6dd17a28fc8fc1831c001e16f90683f0898da1b270352259f58df9e9cb6c501ecf013f17c45f83f800560eb586bb29e6b66c354430b71187cb3393a94a9f426a0babc2faab9b9ec2efdbf61edd4d677e54bc5befea35777f2635dd922f434abe7db4cb5ffbb27d251de58c8f389c95d825ba50c1da96d3362fc3c275da02232ad71177774a76673785c352cc7cf77ef4b8911ee9128896cbcf94b908440f137869344f1ab9eadc675c2de4217fec3913c285055821a172cabbb939332eba8a42e7695373f1584b03abbfccf6f5e69d6e03cbb4ec6305e2f2cb0dab751761fbd1d3f1a86e47992e2a0c3f2600747ca2acb6e3d80c064ee901cf129f920ec2b1ac3993760906a76b3ac15cb6ab4ce6fafce88559baf156091cb9da3fc81c90e3efb3df6550bff536948ed983c2a3553d22b6a47e3e1343681b13efcc259cfdbf1acc1d4d4012cf4eb436ed773249e73ea2fba79f23abb60a7e04aecd0efe1ec8da12daeabf563aa186b9762202363127078e3906d29a310c44ebd8e1288a1f503c288fad74e415537502795f835b80990e0f55de16a73a75a97000decef07ec8f410585a1876d41420b48c78570bad42726f6f2979c06c61cf489f2214a241d43f263fc3a38bae8adbc3b9d034e47374810865aaff49c8270d69436c1c366f89d31c94c95ff28149e368b21e35d156d97b4bfe8e6db87dc6f4315f2a928b9de975fe75b6bf100d7849808ff9b9d7550e0fdeca519d12ba7e3aca7b6ed4ff61c85691883d7a83c4052419b9baecfd7e21bf9aa673e510c55d024720edc4e03f6e81d606667c1dd1d4f94d2bb9c4b90694090be957d253a5c4f50a69d93204bb346ddb9ed6c61a89b8d4e68e6541834c23db8a3c2ae5bda80a3a818bb65ef771d190dd464f36bf1e7acac203b22c1032b2a738fa28ab01e78eee4fa6a5a6289316457e70389bb3c33df2d11aff5b6a91b4cd3b3b9671db426f03b6becf190037495636aceafae1eed4772e4424fca7fda9907d135caaee54053685718b4e5fe9ccee83e127f98e8ed92b57bd21a1563010a4abee408d2f9f4c38e6ea032ea60dba9a90c41ee31365286953fed4f6d784fc4dce469a2cdbdedae8d4f5daaf9ef1bca2a69accd49fd0f741699f014511be8b51032ad0c53ef0a75de02924dfefea73781cb599795da7d46b9d2bf4828c6f992cff46a1f14bbed8fe4d44c1b9b2228384bdb10e6487819e5af902036c056c08606f6e1a4438fe59f3f67eed13d15c3bf8b7cf9b85e64403dc9a75ced05d791ff3a33471885af02762d841f2e8598fc0da19ae9f8e9527e6d6f86a6a529579d046257622c53a6535b054e80e69ccd9aeda61047fc5308dbaf1ef405b622b9a2c030a07d1da98236ef4a83f764d45bc9933d7abf208aa677ff5fe34e20c1b506479fd9fdc728a2871fd1d85f0f8cde9563b3d015e073c65b97e477e5cd8ce9f1076eee2e0b54c4958006378bc0e2ccd6173aa55f59d6f552a678c7b06c08ff94bcc11362287e0598e6ee3b3079ba00036d4b1045f9548eb70f6333029f57febb61665b1b1417decff8bc4d8d2cccc91e6dbe9073940778d5f92911239f552fecd945f3bef81949e7664be003a375c505ed348e2a2f60f0cfa57aa5168c54c475c2e1803fd71f5177b503c40ac5f4e560f69c07ed9cbdf17b14f212fafa4c8d2d98c212c0425af24df2962e442c4b79b8b20d946d5845bb551b981937933361d208fe10016e2f402bd60a4f8d046824d4619550f188205d2020abf540adff08992fc4febbd8db1ae5266dc40368d862fdc0af009fdcc0c65c0a710433d122e76a3f0525bca209099990c3335b572a1999a55110be8d7957822ba7170679f8f10f07bfda61f68eead76bc8f021be4afa956e5b8185e2886f5559e96c6e636c0f6cbc08b04119ba451b883d312e439df2086c55fa06670fe9acaef499e3154c564f9c3f3b998a1c0edb43f3493468f38ecc0d0f65e247e5838002f5716d32a6ebd5cb2fb1ebae56831b7ee23ea5a01e3f97d1db7902a3e0eccecac85b66adab5c19b8432774a6ec6b23e135977e44148b73230a46fc857247416b3dea20d1f1775e0c392a55c512d6cbb0ca77f927c2f8fa694738234676605dfa6d3fafba07685280112f90e0b527992101a2b1a5ff74d92cb0872296b384d64edab261ac5adcebbe8cd71b555ee0e25692698e8cd2431695091efbcc94feacd4ee754b8072fad1ac39cd102b88834e88f9585259b3673f895614bb2514b4f07eef076c05392286f54b85100c47dcf9e71665a1c3542d7ba1e6acc85c696d3d0b64d9a1ad14126d9d6eb74b035152c56c07e3e8d0809dc29bbfa477c58774d8f501bb6b4087934d21a2e075c58121e42f2ab67e6e40a6a849f81ad57abe3cc76e8bc5ab3b1667e69135259e5e18eed5c9cfb83b75494a14e6cf41100e72c94a44f0bd802dc1ecf28223bc55dc3f3f3c325c71b735ffb13b047a185a37715e035ae35fdf9ee2194adbb560e48bedaba7989719525a114d803986e42b3ce9f45bc5d34ca5753cdb110b271448b474a1d92f55545b19f313bc5b20c02a5914b6e2775a331eb122deba1d64b317300f57a6c8117ca8ac97a5d17c1d1f43709992483f1437ed9dbf3d43d2acf7f29b5caadd692f6e31e95c8d30244962f0399357100038d8816a2c8b435bc94b4d71158897829650e8e78be739316585d39fe458ba82b55cb48cc69a0b88ed03d7ce5afc5220ba92c9fda17db9916fb2b5d66679fc46175b3ccb83b8104bf9909616c03035e4654c1d899aabb9529fae66a1429e7899b75b1a45f01be3a3bae0f6ee06d9fe86b541795b238e5a6862f3d40398da07b7f231fac46a144851a7999d1c324df50071ee3e2f96feb91355a682b382f21ebfd23aa31303c3039de83e7af8013b13cee9477789f8cbda38380426b8ffb160dfe66986c59903ef3d10ed8090f64858c1bb3712e9509c88202e372398b0bfe69f8d97bda9d6723cc1da64eaf378ca3cb8603326865a903285cb79ea23f0e7613c44110600ac74026d1e69fa5189582495d0f832adcbbf3436d9fea1fd42e179204e57744f0c516cac5a48081d9033d6c604afe698b9d254b57396f814c0444d3ea3220802039f3ccdd47b104f60c9b93f0a059829c4fd9e4987e4f695cd19275a683affbb89be6c1f7cb2bdf633deb09d62bd4b7da34ef7c0c1ff1cb66976b9a62a53cebfff3ab2b5b8682134a6389e0c426e6ba2ee5dd4c6a77a3004cddc339fcdc6af180bc93dc82ed6117eb0671d8590cff3670656062af400dcc08136b29b756f4950d7f40bc81ff2f9e51b2338105f918f51f259f647c064e6fbb4b70bffc538b665ee982bbeaaa9d18f1a27028ba2b70862b6b0054f753debbf44adc6544dd993403b994d720b1e59713a398319add4b4e6b46bf3a4ada44b4301ddc349dac2a7c0a7fe846c53b15a1f6bb0f14a7b2ecd4b153d7e7a4b1cc9fd1a2c0e1b8c3a43a4b1977d730c35ad8ac85cbb7b7d2a61c36d520bf683e9970489ab89e4c828d80efcef35e35440e22b8d28109ede480c04f39654f989bc8a2695c4b9d9ec708c027be3ad38cd4dd055cf4a0bb14609ce4e05c03ddb3a2d113a8e7464f82d658b005a7203d7fed606d04ce681437db2822001da411a6c1d2d50503ee9bf2c579dc011992ebb4fc695e16be9f36cd46191fd6d2184af17290cc0da7f8269a49fa26efe8106f08c7c51be5c34046ecbe9cb31d735f34738ac13fd4ef74e0460229c0ba69a7444cb8ecd4f129464789cd218081d5639d6e951706ac416c775b38ce8909d3bfa54b20256d7941447f7b8376cc9016386553d371fd670c92681a991799183048724784932add9ea26b78778729a00bb838d9870f9ca0c23ab9183a9b7446115f2bbf3d0ec0b224bd8a992f51389ed50e8e20dc3c03f87bd924f8f5d7f378c86989f2588df9c600b2ef54473c9d03a143ebcab97c350c01bb5199ee81cfca4e8b0c797dcfa5599b4d5eb903387e33708ac931ea12678eadcae40876d64257074b0b99632e98e64a373f35c41a358b72dbb611d83d10d63c6ad8bb57fdf146d2c3d7acb28b9ed03cab525d8cdee7e9300342b65de054771eda0efb38c61470d1c46384365cf7236f5962a15ee32bb5c2e0d4eb1c11875efa4c3c3ea1ebd9c290c1ec40b3798f3fb77e7b2d3871e62ce3b38b04a05c1eb15870a0c1f4ca48f9b06775fe13725e6ab1b523525bd71b37d690e939490adecc90fbc35e69196c360cb85e29557b9329899e37437226974cb4eba4433edd39ce28284fc90fed63f23980eba4540e20434a475bbee63347432e11c73ec4637aa323a77f9c1c4b92c93d18b00115b63020de6975c3d2bfc3587b51346e7baf0d1be307754d64375e5db6e9bc75a5c09ef29247c1d526efe4f4afb51f624dbcf789378b1eb3544084a706e414dc22b2a161622117276c66ed856880ee8ef3e5ad00e5c066f94cb85aed3ad3e0135cc3a72df75e842698e65149bb26b0ddea91355d6fa2272898a7e41aee9cb57f65cea7bebccb737843db22ba1cc2d40182a8dd5d6c7582ca3e2a64455aed9c18fad3e1cd503cc84f1e5f46f64c90d7471ee8e6dae9f4f2305288cc06d21bd0debe422146c452a1a385321978bc5971c41b33071fd2a995feceb18b5009120985b20e21a398eb034bf8fb73d91def27fb91598f29204e1c1b1ec2fb4fac7d3f16f4281bad2191165a72dcfb9ee8dbb240779666a8b10e722060b623294963383a406946022eae61f2ead0924bedc27ab1fc7123b37abd8834e5a84dd4aa11c132d2c933b1298b331f16c3be838218be9703eb79033271e485e84cbb1fca730bed5165cb25cb90c2b0492c40384ab41c533d95c460562040142f069e6b3b1c691065054dba20df957b5f93bddb304292d37066ba6579f6eef87110a92df59a19a8cc12305569e19bc6320afedd43ef007b0f4d5fcbeecc19a705812a2c9e0c96c571e55a30997c766b9858694c14e45a4d569904bc114b28726f4a9cbe6611d026c6376ce52f1f2043c0dfe84cf3501c8c656444f2de0d3417a6101fd7c0aade75ba2dc303d2ca4bdfff4a94f6663db0d7f62cbc3dbeca5a662f13874ae9c8763fbb1af8b21570a43bb2b23246f146a8f2350973f73a86ceb31c68e83de5f9fb1f6ef7eb42328c2937189ca9666f91f9c933cbebca53a7aa362b85ac68b5fe95f6b0284328f202b69bdc0f9f8816b2d219d819995a4e8c08052b8ed90c76e0c89dee866a357c650171984a3db5605b06ff65e39547cb95cdf4e3281a7dccb0c7d60ea3b2b140d6e92c222200a52dbbc4a6d25541a61adf18d7c887e76ec076f988d5071af80e43ae40dc5d0c610da90cf716af1c38a80214923144ca8fedcb6df486d0f23d2bc3bf3cb7f761e130c34cf7c8164ac7ba819df2bcaf20ae9b6820bc56f56f96cfb068afb13179324eb0aae489dba280e8bc42f997b330df382e967afd6831147e4e99ee02b02323458fe491b538fe40c0c78de499a4b9ee8465ac1d4211e0bc168ca060776b25c02c77b6dad575fca164b44a58aaca3c77827cf460b15e27944cc56674a936e0480e6247e6479afac328b560bbed5e9a18e26709f5cde8bc8d6cd6aa553caa3cecba42187b4bdd8ddbf416e419db3bbad1c6437bc62344501136c3fd4d3a0099c70aafd1560ab6ebb581c15d4fa4f49b7511f46ebabbbacd6f6d92dafcffd46e69c9d4a11c7122b1e29455d022818f15ff021afbcc51f6b9c0fae18a78be796aae35f14a6ba874145d7a1b2dc5c9140c0e6e5f86ba66e04abc90430c2e60dc8d8776b446080e549c919fffbe50497def363c25a02a583cdf780a0003627d9aefeeba6a053a34be1116abe6c3160789f9a25308152fa7003eb08140b0df04e8cdce0cedbc423b843db97ef48fc6aa7a849299f5b49481c363465e2d06c97998f9582cfb0e639dd3b5e138aefc15873cb511e71409113bb724fed6023709df3ced8aba7fbe2b7000b11fa45665ef602b2587ba89db4742d05dd63c7a0e1e598efddcb373eeb42bfc5511a6f57755ff12de2d549f42c7656f4a0992901b7a464648484afebc0809cb6f51007fe6fc164d15aa19844c24c7ed00664d416cf090e5389d4289b57f92be1c40affa71e2c48773d5ace5eb38b3c74a4bc67e53aab26e23a6600593631737b199790ab756f70b5aaaa74c00d52fcaa2e4656159854f26c4c4a24d12acef5b7dbfb18227c52f987512df465ed57a3dd6033a081ab819ba0b4c78d3d903bc0157b92c4091114118119a0cbc9536c7eb6a117c4d8e81fde22843ab08927eb126703ae2aa3e520cf78213493a212cafbfddc61000e94471d34975fece13c89ab29ce419d3de4e044a1f089532374aad4fdc4a9df6ace0d68267b7f4ba47d32fb55385f1d5e1d4d2c8799e64099aab974e26448de1cd1add9f2a46a41fed361d21f13c21d9720053a517433791a6c1ec2dec606258944493e17ed9dd4e7f6fa39e150d142aa8309e1c10f827e5d571559233db4fc6c0b4cfdbbe951e3558c0d241494226def9d7173dd632d2ac66401293898385643d70711a00205d59f66bc3628831081ec724c728f584de0000d9f0846d0b0862c8152fd6c4255e5ca7589667192566904b5ad4d60d46388f97e01298af0b36aaa26aa965eecd85bbd11ac954b64d0c35f658d7fdfda432cc5077274034ba56013999eec54b7fd9348bbacd148c56b3be68a01c42277ca046b89981d6755ecb1f38b1c0a7415c843888d9e31bcdfdd1a591ded19b8122133dadd7c819e54b8a98325d662fdd1de3dc15111f315fd06d5bd3ab79a9acdcace50f0036c28478ff753a616fec70d6e7de23a5465acd8364babe3aaa498b92e85d71687eb0a98c3837470568896a01adcdfd3af18fe555643746ea16c9f5476c49bf87bd84d48dd721df33fc8d1b13f8269ba3a961b9917e2ac279665b500c3f40170290622351815d8fbe96202a370830835fed66d33b573275dab9993a2b4b4517e946d70f516d7062062455f042287aa5e2b2d457ddc3232cc61c7639eec0aae64a71a6d0461b66a98ff5af9e3179064174dd54a8964756e52c8de877e92ff40ad670b321f3bd90480e64ca7dc771cc3be5d8a2279f5e91e1e43141c35c75ab21aacecd8b44f0c22fcccf836adbb0d5b199f30b03da9c6bfe3f4f457f23f1be39d6111c359a2e6baa53a2cbb8451972ce11ac894a698e7aa5dbbff9673762170681d67ccc8dddcfa351b3f85fb2613d444e9143fa03c1d652ad799c3eacb6abcbd3c3c3a55e36dc5e0d84b945a8f63fe89bac5e507a9d2aaabd8cb9aab3dce15e109c43d966959930fc9ce6437b3506c27b325be18a4d1db6b0afb1906e1ebe5ca5297a8b3e47f6590c653996952bcc7a0bfd21290efb3d18666d82f72489f73f4bf160a724ccc1c436c17b13160f9846646f955b1260692975a51181ee359e01363ebb5ffc80edfe60fee53bdfa3a63e0ce4b8531d4c9b0e2cba4a684044dae1d24241dfaf8890704c6e9e3009b7b7da0facc6bc54769daa3e49c7e40f9ecce1c439d755d77d3986cb6ddf35f4125b8ac8d567bcd970f5b5c50726f9177f596f6e99b409b84356e275cb4469ceb95e8b1ef71a9df22217b1425ca4d3ae33c50ba4ff16cf619b6aded4b18c2d183e6e7d8cd0bd975504da207101dcacc7fc608939a1d33f95b2c197deaefdac35a47d97f5a0ce4ce9521b9178203a103e0f12d98963cccf26ae5f35bbe1c1f86e2ccc670037acc97d2d7850236619e359e65182cec9a9c13dbdfaac9b3ccac44ad7412a93da379773a9d5800141fae3ce4abf4e15ed5ca4976eac303429ea0bdaf3692ed0957b98292de4985f5b0c840c743ad85586e71421f1a737876f6e81576f41dafb64d854a449c34a10871b7c31cc856927d40d592aa42d0e42aa8c86678f68793d39154d493e620d5be29f3c5ab2392cc1dff643099bd3779840819a0f835654988772cd006f88443a58ca42dc4212776e2536668015539142b8e890be66a05613971c9bc3ae9695a16b75709f50c036bf6277a19e466b2c460aa47c2abfbdcba78d6a7671a57a6ef6a321136a012b95549845922141bc506de8296be45ae59ddcacbe1ce1b3d7f71fb7fe33fb76ea80e1de15ce77eeae26839628bed468141c2e050374c30577913b53ee2332dce6050f2dca6ae8c3e3e5aca212eb48f77354e372e97c6511b6edb3834ef1355e3da0ef3080b7f1857d7d1b7e9e5135e8e6666560d20f99e893fe4b190e3f59205ed67954791bdb70ab051096e1fb7c60b3d5c36b883f314b8a8b85500a6f3e709712fb410859ae8ec855318263b7ca2e3b2982ffcb4fccda37c827f3c8ca4cf2fef547850849bb1d93de5aaf94a7ab6507663c5c0a411bec8396a573b933dd5e980abeed213067bd5b21f4cab2138dc97fb87ab1922165119e019c15670ac5d8f10b551d57c0139d04802624af19f222742369be318114aef77d9b1a5febe3f7da7bed80997329c2e9badb88d853caafd2c3a622503b4813e925b8f2ff11850f6175000e3d12ad79ee45b4cd520f4375c1f5bffe93e0e2752e70dda3a4fe8c34d91414cc3d00db782fca889ed79e8a5f8d1b0eb532b1109fad5eeef90de3d18adae9de4fe3c5603d70c5896935162be9ec002ba0a83cce8786b7154bee6088d8bac28585458593ba39719cc55312b2e48d64d7b7b2e4ccd03378af1134eb9bfbdbd575006391e23755c1e2babeb188ac796fa824ebbdeb5eefecfb4b6613f65c8455a726c3169106bdf2cb4f88685a07a97881699be1563336c6e892f398592fb0279ef17d9d523739a8fa2471012cea0e26a76268c61af1c0592328a7fd1b14f36b89a116d292887ddc7500007172125592b1216177af3b474247e6da0aa8e67183cab09e4e63ed30b10680a0ef3ee4b91fbbcfef14371fdee720cbcf9640015bce68a7a4414812c6b499486aa4e656fa64085ec33223f66bc185da6ea8e147bc2bbaf2a25d993a16039e7953bfd38c935abfc637d916eb8f318a66bca2b33eff511cdefa619babb62ce0234f018a43be7dee5c7b89ea353b8fb215699d9623e671dfd1fbc7c8401ea4cd5697a4ea2739222cf4ba9c0febc739c981fb6cd1b4d7bd05daa4b5542a7388053d67fb356ac2233d58bd5a7ccb84a2634c205ec3e462e3c70143c3c34bfdf1be59a1becf547b9e116c2375cfcd23d0f3a0af39fb8ba93ea259f3404856edcd3612bb1d48a2a9e8c0f4dc2bd8f3814392222759389a498477302053b1f0ab12fc189f18300e9626d0cf754294980743bdaee95bd1f9d9181a4c4e86abc476748407dbffa285e6d8ebf5eb38d95e78f101e3d6987ce21162ae8560e4cde051b2a072c867b68909104fc25bc6e423ada6b2b31f9fc0044630ca7c99707a14cc5da2484a7f3eb9ed215fc48abec1dbcc14d26e27a48bab394db081bae21c2711b979f1ff9026835908688fb494ea59a49e8ac51816f04cc4d3ae2e399f298aef0d98877fddc1b97e45fc4aa48769ad244fc557ab78b725967b47ccbd3d7ee65eb7b07bf497303608674324441c3c372d38a327692313918f46808d0331fce52075a84e41f42c7577b34b1a2df9908dc629e7775ab9f1e0fc2ec38d731cbd3b3e4b33f6672455981dea36dfa0d786c30ed9edfe9cfa1a1f7fd3a136c1b26e7b5c96c84db9a46dd4f602694ce98225c4de45e27328978896e410e2a5cbfd97c372afa1a6f3b2d70bd39c57d0dd6508d39436175a23b92071c69808ddde270f3df7e010a42ee51dc84e97ff4b1d577bc0c85985d330e50e00ef0711440dafc6a34b9b1c06faf28e76c03b973d628d90fda856b7f87cb5e420a62b62b6abf1a6abfdaaa6dcdeb76940338bed900d9cedb013a0e6dbdeef3326ce97cf7b88129609080238e6d6feebbfe032757a0920b6ff15e00612e5545ccd5f17b3d2ae375e7a488771bb5d30aa50d49b270de21c94cbdf83e2ca66b9fdb7959971a0059b74b8accf4e1e19412db50ae53d62f230e19253df1bd51ae4a3d23e2c228db65163cef0cde3a14e35775b3cdb49a446b7a306585228ed14be69c647321a940f796122cee4821260e7109b9e7a2c8072e7443959ab9765eab9da6407e6bfb73739ca6de0debf63c7a68a79461d2ab2b214e3800fab900710f40a18868401e0721815694270db5eb5bcc0d2bab5a7a2303f03c37e4c32da432a129a0b785c7ba93c5ef9dd3089c6d2fad7c295edbd0df5b4e2c86686c0cb3b3404e482689605a755e70619872068dbc45915e5fd2e069b3aefaf0effc3ac029271a9f8e5752c5a840faa34054a09dee7bc1200af73eaf01a41aacdab985512076afc2137be885221d94c5101389260ac01d126aeec3ff2af2d1f5b18a5547092ce88ec1ba3849152af21b171cbbf98a7676c4389f9e8e6945d5c75c2681b4de621183908c006cd101d215c7ab4970c3e0d7829a7d5e54a07db834a33cf72ad0e209b11c97d0c4df99266e2323b650167c3d29effadf78800a29ad0ca9473e85b30db783cad89f54bffceea22bccd107b0736b782d63655270fafacbf12c41df4fe956b20ecb9292052450c272f83a76ce8e3d33fb55b95637250a31b20d6be3bb340e5047908db9ea2ff184f31ba8bf446c69751fcc3c96f669529966985706de9d900482498422e9ed049781a9dd742ca3614b9a4a52eb7262d3bf7010b6265e76082c67855659fe74555a5c5707bb2aee5acf8f46d29cc069b4eedd8c9009d414e8f02c2488d6808ae3eab24bdda9a3442a40d35ebac61192a88be4325d47909bf252976dfac380f4dea1bc4d9d3d0ebb7a81146644f30421a40461f020843c61df575049e0d780ff556fceb5a39829b6f8173f11e9be6a95c1cd6ea66ab7e5e7a51cfe1fe02ad1d407049fcafd766ac8e2bbd801de318611fca81cb4d15fc49026c17faa7d1cfb2d079f4434d987b528e314ac204ec7a6463c4245696f38b7fee45d50e5ef8afc16ed853e6c2c7b8087aa1ca851b4c6324b1d9ac85dde0fac80717c3917bd98aca90c34216d572b26ce91d3a3085af7990748f9fc253391fc5c8a1b3e3396b0e1a193463f68476ee729d8ee90e576ed5e423e152bb86e4f1bf83b867f811086270f25f9ba0c098746e9efb8c3159a08bea9419428fa09cb4e4c0b7181ace4662c84970d983ac8ef141b11bfdbc50f67ae35befbc5aa29f41e799a67e6c7b8b6d7bf4e3a78b2d9df1a7143b99364cee2c4dd903c2310ad0e199aac06d0f70707a8c6d10700dda7900082b528b55db3c18f8cbc0944ff7b6b9ca557cc63fed0d367bb90232e138e548ea3bd1b2e40282e18e01457bbb3059c19044599a288fb1174324c3b79675e841444350e4926f68391153d81bf5e2e00eea3e84e5d21db1fff59c6a57aacee728f8f1c993800b786b7d1cbde5a6512e3f91b97beceec567ffc0e44a5f40ad52760fa9171bf1be6bc1341714fa5d216e13c82f1b6ccbfe192bbf37c0097575167c04ea2cca977f9bffe8af75571f0dbcaf433d6bb675ce5b563011c2fa1fc77ed4df7d164fa6d9ee541d44f7b40095c874dc974a4f130ca4ab8564f5c6a4bb1b5e4b292211f220fbe484e0eb2ae49543804a081fa41b0265dc53cace1ae67a8a777efac306fbdf7167740996164eaf9797c4ccd05b8298e17cc9b2df5ca27d5d8ceb3a2ae1b60a38287af2153dcb9252d45a3ef3a0e071924951cd694998b24daa6eefeaafe0a5bdac47063cbfa27c3b87f95ab1309f7215bcee92be879faabd49a94e7bfdf45b2519c656416d4c942b6fc5b9e057494de506ceacf7100d9b7da9b022b8fb19d61b83ba8edfb3efdb6056f4a63ce788b0bd7da3adda0f87bec7acab17a832ae51e3113c8e35109e96272f0fdbace64df0f50748a6cc31f8495d88947747c36d05d36cb1dbd2622e7b262b7f4136612f995a2ab4f4886eba44add91fc91b9a6cb42525b39c45f67aef371573e3dd0de0e4e320bf322adee6a68341943c83d39eca096ff61abadf9398dac20c8f3dde0fc04da1bb296a48eda72ba61355ea50d4a33a3bd07029ef07786c9098e5f1f6dae3f50f389c81c00f8b628019b14c5646520a6df7fe955cff887589125b00faae6870a047cda808a24a05c3097f5c7b6e41d91d0bbb133f9942991d364ff9345ea2b98803c517588207ab12fe831a40643fec545cb8a0a7c95e4f88a7b17da948c4d2e05042c58728f8fb6e2da5028c4345b1691367bc4834c1094e66ad470d028e2d4fdad5cdf6fbe94867f9b050c1abac82649b1353a8b8ae2bfb9f261f28d84ba079293c220d098a130d6f22cd2eff1ef86ff406bf763c51e3060bc54ddedf79e7125d991364944943a780556143429eebe1ff1384618dccea62caaedbd96e9275f3ba006335bd4e67f20e18b3bcc94bbaee01e395caed1a1e6b44d412f30a807ff997a9de446cfcdb291ab8b288c5dafac94b0c00fe3c277d36c79d8a0b40a61a991c9e6d969e9058372ca4ffacf3fee47a8ebbd6bca14d2bcec05e922631e9125424ed7a2a44e7eb99518580b0be7556e137ecc0f0a8b20e34319c3da63ea5c61fc5ffb9d1f83708915af965ce96e1d71133887b4be6a03d94bdba37f13f9e9424f332f4c2e6c039c17039e334ed6caf6f99ebb002061e5b94d5fa1e731a4747a4106eefe71b6d63c45186cdf0c246defd3ed318a6fe54b29b936d76c20441cde89c4be4a8e98251b98db58762cd29e4192ec223f8df11d39ee517edb0868081bffad46fae39ba417b477dc2dbe5fe11ef96b4a7ea1ef2fbf3345ff2fe8c3cdbfe4ac595df696ec0d0d0d7a4ef83727dfb79a29442d9a4a1120aa7c645bbc4c7e2292d2e763c2e1ecafd5e71cd5986b5d63dc75651657b9a343fea15e9638b081d36d2d679ff204a2cf78c2604fd9abe6316f42b7584014c160fc4077045a281591d8271848032c72fe75993d84bd97e438046c1a673f3f7440fb0f994fe93aae66d06c2808eb5dcaf20d4fc1876f5ab98258273e680601973fde2d6211f75d17ee5500c0473d7f5d8924d0d9a82514b0e0c4d309af53eb57eda811b77886d64a953d2dc23306e9801240e3223485410565e6d3ffe6af5458993325f11f9fc93d5e8d3fdd4b91c99f30f22e9d763b96816fafa944301c65eb6821847705ecc7be5e1b469afd84f691351719a9b47d6f7915f6534c5c7a91cfd531d5619becb7620cd797bc39d3030e5a73cec632f00555aefe3ae54087b02ec36c49b7ba0e68dfa6610e3779fbdc73cce919e611160a800756f8ca82451b50198adfc0b149001c3bc2a5c4b2390330560b0f95e9d5fefe0325ae58ff8a57586184ac23ba108fd92ff8982e5e26621a4742a6174642c1b1f7aaedf84fb3a92d7f6e8a304e409174db95c03a031bc96d97895261c203b7f6c8c6b3b6aa4f36fe68d0dd9d92617d268158b07495b1d7eb5b50daf26b6997f0c0758e161e72ea62e3e1eba8dea4d11695addb08887b40b7b98666a6bc257252ca4c65360067fda83ff66627dedb127623038809ec9d7f1730523ce5f0ce5a3d49d5c92524b6586664bc6acf3d020ed0e237fd9417c633437b9c9eef64bf8ccf18c86abeb0275daa1c22670a337719ca8a388f88fe4f48452d787f9b90b4c7f98847723eef325133b6ebee6f052dfde455f75963f3d10a2b47c55e08703d723fa760bbc87d2edabfd28e59fbc1f25d6c2d4464a663ede88a9a03eaf41a879d12564e24e507a235e1fa603efd8bd4c17975352be1a26ee20750900987315090520a5c8830abcc07db4d8d192aa75cfce5ceff26d2927665234cbda2fe54c6277db09bf934b84448044cfb11d17df5e226303769eb645626ae3c289c00115f7ba8bef4f3415d0e47067dbe6c284641bbc2a8f35e904e7ec20816a348918466c534f32af9e9956f6cc97b064a7faf1ee5aa48243351f3c5ddfa02b9d4e20e939e78215930c3e4a306fe8fe6e3cb668101bc3b5bfceecc99032532b086555c44f045f5297273e1422a505763911b7ddbeaa17b4c2a0b71d4c09705f2b6ea0bc24d4de4cf7b0161866d32a10258f11fbf2232c99526041df7c40eb8f4451687af2d7745151256adbe765401ecb87b5969c27406e991bbd6726a29f5942b7ff0c0989d872861ef6fed8b58c9954a21ff718ce843995b39b811a0fdcdaad3e5a9263c02fbed68ce593b965d63c061d1c05dcf67094fa44653967e6d598b4500fd2d41dbfc66e408bd5a304caca169a72a7bed41c5dbaac76c874a4c77f29057b05d7706bf8e910e40da9277d53dcda9fbef4343479bd335718d62e9f524bcc06a3107381d33f09dc376d9ada7bde050be691acfdb71b2e37cfc260afe6ca2847924522b7bec4dcf00310b19df0e6358e393ddb440586230b3974c2b30b5f5471b04ba8eeb1987b36e5762044bb5e40b0c4a1a42591ce4dd98229f89f9d77f74de714f5d6163b692635ac0432ba64ddddce8174eb4e97dec38538274e5d63bb78cd96dce576def5cf3ed6eb5a24b1924e51179468cb26d4cd7dfff42a5aee1a8b854b29c327ee0c919ebc96a6fa80d2f497b0dc644ba4c623d848227e7009e8ad64e8cb585afc9c5a9aa68aaeee693c37e51f0ac5f0ddd27e1b01953f60edfdc984d9346e3937a7ede751428627fb7c88e6347ab8c14535d70b2546397652a0a3615c21f93bb1077fe8af270a3cda7c3432782e3b33ae6a2df8576c61e3d82b3d806aa398e4e36b26a92309395015ddff3a63a043a28031bdb3fe60863ae39b985d1cd989443717925d6d61cbea4cb091a2ef2fb55b48eef7f4e7db3c76050402dc405a9b573a268f74636efb121824ee507f3c03cdf5782076553ecc8c1746f29a4c95e72eb7b28f19ffa50edb6db165f9ef5f126d7b53e891bd4a14ba69a83fc1b851c8ea6380d1a0b6d1ddf7a02ec1f950c51e8bfdcbe41a389d1e7e6b06864de3a4424efd2a214974418080c58c3419df5ecf6da3042f9fb1ebf693bc2d9db95fa097b3dc3f77536fbcdea36196e871f5a61b0cb73801e8750a68df53d546ddce95d220f016bad5b29ec6ec2abe34513d35034af198385b777ad96ae60b6688b2675bbee479f1e1505c2c268cb48d8397af029647be852958796d560c7c827b03fcebe12552d4fbbd6d4e564d9246f437294520e19bbb004f39ada73b9c7c4d3109f137e045091bab7e98f7494ceb646f035805595cd35b85ae65e52a7536c1479bae3a03cfe9392429ec45dd0150bc53cde5fd789470a84f6de728b6843f29431502e0a51935b02ef8e6df5c41e2cc461e8aa35ae597a81e1b49f8b0568b3a757627eb2035a33b11bd7c523ae6e30dd096992e525714a5126c5471b248304253904c72586711ffac9d7be2c156ff8eef8d83486096d6de307880ccf8ca2b72d2e2c94bc93fae5326c5095c6b8a5547342d7a8d678177a7351990e166b56f8237338b610f4be5ac7f40e8ed5a64e7452142d9262d891707f6b4c6340f6e41af68ee40bcb9114468f35758a787020e447d7f9817bb788d5874604f17036ace4032fbcc696eab57925a164da4882fd96acf751002ae314e58e2942455f661c2284e9c6688815e34662417682d1e95dadd9e4e08ad3afb7ea9a5989c5d6b56c0252e6ebaf86d4033545b837a9026950bff368858660a9f6bdbce6e71b37cd6e8b0234940ca05a3b4e1641d75af4dd2f79ed366dbb77fd2a0e7e1545c4ab6246e6494032ea90185ba73d9c1643f51a1b5298a5847fcaf16ee13e9fbb34663ba9ea356fee17bb31f7927590b5c896a78555c08af6f3c32ee9757331751f24f824a2e452e69938af69804d936e6b5079b9baa3bfbd14b468fbbf4aaaa4a93fd7b0d68c039bcd2e8e2e2527469cf12d17a2e38b0e91faa10fb77ccde3ff63a3acf0b0c3380464213c35570c3c3601699367300ee397ab412e555be7880da221ec4aa7ac3f315cd9a1865b4274162d396d4d227b12c43023edb6afc1f2b7a3872f4e088c1a300e66c8e3d7a5721454dccdaf27bc928910d4ebfdab7ff34e5736d26a0a24c6777bd4e34beb59439f13d021225029a82af019220297e1f037ce0f67b436ef3ebe03d67fae31c4015bfcf6e4cde8c1e4f8bc8992621d0d31aec366c558c27372361e604dff9c53c0bf728fcd20001d3ae4b4ddf1900808e9408465f5815298839b57b59e323637e7e9bc90507aac58566fb48810a6afe758097c973972fd174fd58618653376164ebfc7aa3968ed617b676bbba6e5082c1f879bc3b8d05f7bc32d2f3c3ad2a86c843854f48643e400eb4da17d4b9f8de150ae789e7d1afcfdbb4c8e94eea306f4fa8d648b99148b7905fbffe2ed291e9c2ab5ae70935fceee149be62d25ca3950345393bc80a988f89840233db33d89491c19f487eaa3668e5d5ef665bb9d6ae981010fc5c10511f6c92c527a3f89c1f93cb4f47905ee0225d59fca4c20a69c6524279a0eea59c200868302f7ceaac49aa5d5ce83b033e95dfed9e2e3503c305afbc25481cb3c5df6cbdae435abf93af0a4a6814cbe0b98c078c44196308058ce9c4eebf62f208b8e4f23157c21e57023edb346ba381fdc1df53e3d7dcfb9eaf8dd3120a7d463a17fb80773195898fa9ab0748caf289ce28b5924dd6523833262d93407e90925e9ab9d4d2c4f0dde6bb4157756dc59b9ba61b21b9b44e147298d0cc7e1d2aeecedb292e604182eb031b5d0eaa45acb85e38c8014c1fc063202b69d4a41f3e27fe7293e75e1ca19ae13b40eab1c3892dc0ac6f53a23df25f4ffa25b4e2ef7f97cd22304e6a1fe7b0e5c472383a2282c2db98507f597592b52b75e39ac5d05e8bd07c92756390d8780c52a5fbac03134df4ba7e4c69c2462022bfe452999915efed097642ffb6999d90513789609987326f5c27198a951615a1cc83b85fbe2f042be9e206e345a326bd1477bca8f39893aec78aa34854f4c2100cca5fef48b88fe4217804bc2c4222f226e82268340fbc4f38d7b0ec53a2d626c47eb2b821c22108d007ca2800da95fccf867ee3b8eb10907027d7040a6c5bd3c53c9fc3cf721b4c37a4230bdbf45680bc624c584bf18ff5ae7ca870bf5c7fa24a761d6c96d440f99edb4b5e13e4a09f0ee30ac0214591d006832ecafef175a6d5afb2f1012d21f4ff58eb72212e4b30b05d5a573e2c653455b67f6e28b1ed9c8080f07e5609e0907ec963eaa3634f537970ff48cf2a062577af886bc206260065522905619f8a03ad411b80ed7d0b246de27393208f252cd1df85e3f62c1025458f93c1abc2c8c384a0027ad95c9ee5caa0d2cee84a45aad4af3476d2eb5be6f81d4acb96134a3d5b74ca4c756a649834c949f98c99f0cc90031726b41ed249a048088bb63d17c3a75ff6c426ebc8d287e73af7d5f9294bbd9e7ca8ca082a7d7cfab9be7e6d5480912c894911511a1768f2c38e1f12a084e0d82c0254075ee0d25d55ed29ec640afd24e296a14b9fe4bb65924ad14c32bb4912d217323ad8e03721740b16f45bbd11a323cc5f3e8ec58b01868aa68414a36fe99cb8e1561f8ebe5572a95ceef494eccfbdc4c0c0418fd5717283bbfcb0579b657e66898f7f2b07a57947951fcb44d0fde67113077b5650c08f4a6fd64615afa750470abfe7dbb5b55d233a0720c054b61397e2c3e74bca1d9359ad970442450d16dc850977f95a14a94a0a05ac37f1d9ddb9dbd4b07471262210e3e86d08010956329731eac4b32daedf9b31bb0adb20d724f97f41ea6b9a918e7a020cabafe4c62a54295001522049c8ce94b9b7de735fe7600fa3cd2c0867c9b503864be9154b31d0f21878fcc0a4ae0f6ac7d25c102f9d26b7f3dd183423445aeefa591d943e192a57f3b0738bab93f178bdbfc147fc3d3e1468db2bb5af60304ab9ecec618c0b4b6ee35b7275d305a1ea34360277e674ac96591cf3a53e486de3032b84fc8e1cc850dd80464ddaf7c3f2e39d03e95404ba788440a41dd3dab80476671334b91bdea9035a6f20103e483c0ea2a40bdcc9f1c6fe43b42559afc05dea0a2a31c2ee78e1b5bcde6f836bcc21ba5e5cfa5421f4c107a0b6aba463d8fbd1990069220e003d57e1d8e1cb3aa22ff07676734c121743133517f57c9ec9c2a2303c6edc1957f22700e603443ef1082b6f846a27be2432f50d54a1c6ddc7ac759bb7785a6f445b2733793c77126db3e45ea40c7d32bc42528230589b4f0a4d01e48e39a0feab78a73441fbcf02b1e6b3630851de2fa2b20c2d0acbe3f7a5c096a07eede8a90eb27f795c0341e68eb9231a8e2da624c477d15846a82fe5b7f2a63f7b4d72813a21bdd5600e536af9f68cc6e1babd6d80f9d8cb739ac2dcdf573a53932b90caae3795d1d830ace391116aec41521e72e19b51b7155dafb2192cd8c70a48d36955cbb923b768b9e17e01a067c03d1b8ee0d30c9078859e600258467538f2a9f9a8b8dfbec9c57e32d702872abc127708141660195eaac35285caa0b3184c577392a18bf101af07bf7f867fe3f7855096e976cd49c929030018d665e2ed3008de8b19a55584cb766de430053cb243e9094319c14b06f598e523954db06afecd897843b7c8f413abef46d36d99b541608273ca9b20e4c108125e73f1e1022ef9668ea5f4b3a50ff4fb2ad6da682524f4fd0aca409264bc73c922ba647604863faf1343545a423acc8efb585cd203e093767ee63c903db8947b9e4ac031918c4ccf2d01f7180778818ae70ba8f10a1514d621aca547da6b622e7fac0ae9b346873ab31e7abd6bc06f15c3f8140689feb5865e3378f2f6acf2796671a080d4dbc1e9eac7ed405e875e56280379ed748b424edd320c1c5d935efa6f960b15c056e256369de9e069054f29a2310f4daa56b18788671d06bed4c76f895930157b1360a7e4dfb5abca2da5cb8e574fadc807dd112e58c1ac189747c252af22e9e6962a61112b9109de52f8a85301dd81d49afc2a6ef7913a64a53add80f028c2755606119a68e305a9dfa0aec749a236583cd761fdd107ef64f0fb332680dbed81da868d45ca7aa1e87bacaefe5d43ab9d4cad5020686c37b944be96f416dfe72c01ab77ef314e5734009102d2121faefd559036e35803da476896c24cff3f261bab62698b96e611420658a2166c118227bf6d03047f384b36881ee5614c4147f903bc539c3239a90dd502f92c0744a0f05bfeb3c7c77faae247f1badb98c168ff51f4443aa7aa7360ccc1de72e67eab6019b8dec3f3f1d2953fe578ec977a207a42f0ee73150259afe169d9a2005f8bd9259afd29775ef30fbac6e496695e6d21b43f0636eb4f5f8903db3e3f270c5752dd6b6304f9f0fc4fe6c79d46cd109a0b6438c76e2adfab92895e9a2695f31ead394a4eddac0e85bcbc749844c7269fccdde702e645a00bf8c075fe59ae883a631926ea26f9970899701634d03a1c158d58e5533e86d814a51eb2d8d227d7b64c6434c8df403797b41825303f2b85465f718ce369fac1b332245ad6ce3d76e526d02dd25f32fb396967e7cab84f4221fdf2221b1571898b4871659b226739faaf469b73fe2255ae6e0643335b42175e5c16434176f35b45fc0104d7451bc601e07f0bd4eaa427ebbc050159ad3166cba743b408b571c489312a97911a56d28f1f5ad7ac7e481be14507746eef0d0019084eeba6e6cdb018acbd6b2090a04dcb799d996fa0f1f86ed23f5c24f147023707f8f7b892497bee92372a3c22453e611b29c038d0457a54aba4e4ef2afea18c9af0200f1ec9614c4911d6e96ddc7c7bad7403c7dc5409a84fbe6315d091eb1a2e72d3bd07c305c7a18a3c8d7f07cf59dca41bcff729417668d33de22c9a034f6a6355a1c6a86848d99c958dc4f855fed7c680ae1f5a3165427b58a2142bde0bd11ca82ac2c2130de25da1bb08f26900474adba0dd6d6410519b7af85257534851e56053f41fe289beb01d8c5d852086bec60180fdd2d5b7435d1a7b1711a018ca953def5e1fd4305c068ec242aecae78507ac77a273ef10a92f46139f7b617a17de7a751e434521ab944e6481ee5470fbd478dde0c2566be8e13c01f9b720916248a22121ec0af4322f593a0a47df1767637f9d0fe97a26ed6c91e6a824e5a05184375b5bafd44676322bfe56ef6194c7c788ca0ef1f724c5030669401af760d94943ddaf669356f046e81a12414bb36340b18b845ef7308eb3e32d8f24212e2a0948d555a2c228e98b807c1d619ddc2f0dba748ffcb7ef9a2da02ead1aaf19db6d377cdf87462481fc1d5c641fbce968474b564b735ef67c1a4519aff649026dc44cd9d43c97af944e118276fb36ebf1c21443aa96530b5761feebf6607387f4b1741fb4c9255983afa41aebec5ff082be95ae1797b31c4158cd3ac5123062eee96b83042436dbfb3c4555c30e6f8582f149adf0ba7f409441d4a7574eee1ae144cfa524df2a9751830eb2b825ec1e5d2136ba9dd45d14dba053a72313309d72142bb279f8286080b1b070021b7302379477b6b420fc05697199e1a73616ecc6ba16a4c67224cfa434c228756b8358c218bde7ce5f9e979e868efcc0190fcb6a443354663ff3697f2162d4d32a3e55bbd0246d007f60824a5fe2b380ad93ebbdc89ed5a9c594548f958147b19633b4d59b3f05b76a16d47bcefa4a68e102f32db942ec8161cf56d4ddceef285eb8fd6f26c8328960d194d496c13b6233a3646f0888032ad99b6daddf58e4e3ee6a3857bebc5dc1cad2ef7da4da2f7e7a1d9a7f9fbe3e90a1b5dbe41eff70f1e4b0f31af7c457099b5d3127e223db1fc824ffaaf537ee698222c1a99c9888e634999f91c780097920ebabf0847e9ab3a2e1467ef10b4eaba859023d263b0d2ae8ee2753991edc13639b8743f2fd86f70041da89733c5427bc1c4d63f6f484a9a9c80464f4e47f5010c81dda68d8a0f0fbfa16d3e0a6d903baf979061d5fc04383214d04d40a3f2a788576cd74186e3da0204dcf337b946ae7226286ec1620731e4a41b03a5b2956ae8a2c03d5e6c193cf8f2f4aee5ec6179ccaa78c5bf08ec974a95ef274b904c8b020b512ff77266b79b55645e485c55c1d6b5cfdebb7d648e6b719e28ce62069e9525fe2a169405fc69be7662c3521bf384746a32698e71bfc54ac2e20dc3065945a45dacb493f5bf275f9321036551fa69a54f82bb05a5626e47b0609372484704886a41a04995eabf35255499c8a293007c68b8c0e930fcd2e5be58b1093e79eb67dc14e6bd1e15651d38c82118b2b60143057561122ff5c703a2d008c57afa612f6fa5d720c8cbe2f41fc8586de593a16e49e52588c3207323223ef580826314f426acdea59ea2a43358db6d5d427603f7217325935944fa09fb69cfc9130c6dd34d5cf50cfe3b8eb51aa8c6c110145faee200dea84a8cb5d44cad2c29ade392ad6a39c22bee36e0b37070aaf027f5f9508b3bb5b4a16d59727c4320b6580fc4ad7a947f008297f253bf30b69d56820127603afdcef2eefe6739233032db071dbc7abb7b2a9b3a43073d1bb92545cb80de10c36f0590d30bfaa4dc871c2787752e49be29a1c1e76ea25c881c78f595db29609a0348798f623acc734bc291abb03c28f4b091cc985fc934086192acefbdf57a87335fb19e059bdb660ce7de47a6125891a76be08f82e3ebc9febcf49602c3d01ffb7b53d835a131ab97e84ae9274e0be9ec1003e82631e731bef0c400a9c5798f55321e221ca554b2d922ecc2fd618c13a99d88692696d3af19d319e27b593e716d46586f5f048368e5199c8c491011110cff3f971f207ebb7f848c357248bca993ddefa68a7c92d8d23dbafa33b8c4fad1cbf5b4f3066fd2d5273bea2caa88c8edfb7576d8c647f0ed210e81c4ecfb0f18f96068a8af36786cca4f1b702f7672b28830e8e428264a958ce7e261b69d35981d20ea715def014f72ddc3b25d09b756530ec3181c8e018550eb40dbfa0697a99d2761ad11c3d74ad290b6ee2e926f628c3999994d14075ec5f2020c4f99d3cc26690b3f3bf2a0dd18077183717d85b833b46e5043f26e3b7773a04a706fe55b6ef1f74773d6c1f86af044d2c826f7227cde3a868f64e56f7220a79f931a4e499c18804bc9f5e5236a2b5117dcefbc09c52375733d7d4ffbd2426da4f7adb820583892da90ed42846ae043802ca752fafb5b02b588b42eed91113ecb3a14a5faa1c0a4a2118b7256ed48fa794468bc877317b83ea57a412bbb4c7bc2d5326e5e3ad89e33fa8708991ca7f88c202ea54bee5c0a53a8f256b42dbc8ffb7f3a4af1012ac674dfbc943cf022c043b1b77517ab14e1264da33c1a14685055fe60e841cd67b1df51e843837de338a55a8de5c7ef7af2b93eb86c41c7303aa145d7dda73042a865b3064e213853d704cfeedef8706a40d027ba3792f663971c663acb184da5e096f7dadbcfba8f75611dafe168844f0d41074027ab78ef9c680a604867e43cc8a16bb351a74a84116874dfef3df13d1bfa180f8dd06559e0fd0483dcf96dd8c48b670269733b6588c74e05c0944777b1538134c50e593bd62e6658e46edd61c34f455b7223c1788b55fb92218151e7e58ac7eec679db1437047939e1f2b0f14f6f2826b6217972a062a0f2f3a73f7ac847d22518ac30088581ae2e9669c38ff58ed75af762549e1552546e854f8cd7b3ba17278dfcbc0500d8c29caf8dadadb8027d87b23c0df73f84d618bd91cd12e5e52edd5ce8128c310d2d2dedde578cdd9f17efa3a152b6ee89540f81fdcbb706c9dded2357c1c1ccafc0452ace919ace27b804cf0752e66b9f3e4dc2ef5d0c039aea656348901f38f7a168c789cb5b026a33e85cad128e46f68a883080d961a451824cbf45cffd9d1543b39b338a7dd83b6de5e40ed77892131cd39359727e98d46fc9f163dc368368d3ce9b66a07c23fa01ee9f395bae860d5ce28ad89d717d99b7cdf91e350790ea37763fbb9c107f007a190afffd65c3e73f7efcdd3dd5ff07491740ffcc343ce592e0ae06ad564443ecc8e0039c06ea22dfa13acb770cd029157ec3f5267a25d53046b43d810915f197541a2d3ccd89a5439604ef2758447b37e2305a052a700a1476bb42789a2d7b17d849b093ec3a9639975c3dcd11001980b8604da94291656d0fe685dca8feee6a32bcb5fff3032bdc32ef3be47ec61eba9ddc8ebbe5ba68439633ad532714f3e8683517ac2b31fa15c3317773ea26d583abf0ce3a7f53d238ff92d748d2c3e93217d61429c3ff95671b6ee9af2d38c037d47bd92a8df1420e6c747a1b85a18b53f63aafdb0bc6932dd035e0a72111fa3ccac89b6bfa278a1f55d1de18c5b8af24ceb967019a2ee1631c63224382082b79e94c086e2f60e6adfe8d98ea31cc7bb6354cc68560dea91979ecf24ddcf13755688783a351317062c545f5866a0d2659896850c0d75f70e926bb78e46abc54dc97547b1b789737ba16b116091a3a85a38144d7093c77abe7673a38c214ed8355c1ec315109b39647496be83baf88666edf8a789ae49ea12abb1c9b469b9292fdac928c909f018ea0d7e5636e5981b695a68f682078a9c8d42ae476310cf00c219c1276173bac6e1a38675856587fbcacaa1935589d1bef128404f20d494d609fd01eeb0e31745261295809c4c737826d28f3131043efea1f5294ae5ceba5f443f5518eb6e31aca8fbc036e3cc9eec9602af0855cb71036fdf84822b4968258413b170621236f95969db662d89556f9138cf9788c4d381fb923632d9d4339b14dd2b1986f35dc6e183c7a77200588ab3d6d32531229b9969a108765382cf26c4f373264ae0d9ebba55d81b014bc7070b505df91eb4d7dbcf8943a533caa27beb68e3ae77e9ebae680c4e5428d191aac6c8589b3d972e8094b89415cb04354ec3ff7f3afbf94a505d13d15c27e4a5873fc392c2dc4772e31c1ac1f8bea87dfaa3eb6313b160a1a2ca26b3fd17bc8dfa29026a9efc0b74d4e0e86cef2e12f7f968170a5998b36ab64547bb253d8d6c0bf7d01e1c0f8f2565d2eefe8939f842b270ee2a0a70eec739beef712e6d6c54fbea76ba2351271e5fafb3662405d6f900e97cffa627717e0ddaedcf5424950ba510ba1204e20a0e3319b7293c9f16d07abaa25e83d2ce1acde2cc354606bb4f18722dacfaa4ec5a94c3b6f10a41bc9b1a3465ed696612298fd9a066db2850666086eb89887d4b663af8fe39c6472bc1d2016c28681d5d5775a46e90ffbf38f62e8d1a89219e8cc321edbfbf5fd7da9d8012cd5e011e9f8bdb01b7b51b2801c62a1d014b4b818c38531d6e258ecc064446ee97958dba8885cbdc7b61c14d1259bdf7a41a4bc5536ec6a922b76b9113f39e85a43a93ffdd8627becc32417ef60365d898388f92eca341824c1249a71976594d07ca3686f735688a610b7826689354d88ad14e3ef491b188220a51ac6ccc920dd8facef9c8c3258bfb2f80ee6c5130ff96996e9453dcf0b654d11c2456fc2d4672c0520fd9f44f1b8bdc2d0c926b9841379743252ab16399a73cb7e94bc9d2670c7cfd06ad64eee7cd696069fbfe0c0c91c04ce61f05e8b7de99d7096edc7bc9a0172e198a770fb2f22daddb4fc8f87bf65e03be5dbeab550b48ef933a60831e79b6cc18a58fa34aee18f9ea4e9f67f112d212bcf90fc287678d33264c122ff66425c54903a086b9f1c3cbbb25db998bfa507c7bef88e645a1f5fd813e3fe63bfe3ec2b13ade0cc63b6df8926fa9ee493aef797792211b1ef6ebb3625850265cc1ba77ad5f6fc1c0e3cfbeccc5b32aeae9fb85ec5d9a84a05d46cc5c062b6a4e6e7fc55bf7e8112d121f332796a28761d81cfc8f02302f0e03182fbdaeb13b90812b3977bb87ed04a91ca65e5dbb3ccd5fef3187b54a8ccb1ff2e929aaa66043dbabb866700cd83408f545dfb3498a80329416255e56d9a1aa433e56f4873dcd619638b07dcc5ea1ae21895360de06cd6b77341851b48b7e6b1e8dafb4e1c0e6ad573606627b319516c93c12a48c1310e633c9de6ad4ae29d865232fc87f56f744b0ad56d784eff706704409d2886a22ca05baf78e97c63c0f74202d445a6416723a5fdda43e148b7ea2075081d37ed10923242f183cd7b1b89d894f115167ec275855e977090e00c9aecf7cc93cbb95d27e9341a9b83bdafd44494980ece0cdda2e7dc905de66cace820d46c05f0aada47568da99c60ae97498f664a487285698c4eb4327a0584a2769cb312f6ea21154dbb1ea2df413cbe6eb224163674126a158b7b27fe638a41370c478cef5844852aaeedd962ee1f0c092667ef0ae7b2e509bb834a5f253a1892d7938e582c7f004052390d338094d40943154b597cc5eec4cb95cd08af6a3b74b5ffbaadbeacec70750fca588e0f7692060682e62635208248c9ea577d9ba96ee0889e4e679be455115ad3696867ac7063bff50e9381fac5a0c414ba28ee48e25b6c854873a070b9c889d79274113819d4d1220c2630c58f94cb493f979065bbf2c10b7d69b0234e42ac34e72ea0e639cb81ae80ffd2ee7d701502e49e78d6e4c402b2b31974a45f4276be591af92fccbd882ce85d114183ac8f012bc5e00e52cd644938fcb4972ae2fd2c50ec036033a490552986040022e68f1eaf4d848fc99808b9928adcf39a47e35dab90ae8934a68a04c536704f968f455ac85ed851dfd4d1fa678257d2ab27ba18c079e6bd8179204274ec410729ca1a24105040462542110f34497dd826f5682095f5bb2d99b4dd7d9c4c7a2d29d4bbb68d2206ad555748f7125d373e1c46d5e2a80afe0e99736dff32ae55d06aede962b907ff9ccb782e8b58de62cd6cd920696848b663c9002e27e9f849ee71844d17cd17ea90a003e2bd34cde8b231a8ed09d318c3b15575c9d9e4e7b3030df54f7efefc65d6cf30f773d29f9546d17eea68147ea4c0b1c1827428e08d4f3ecdca795ec940d015bb83e181cecca93f8d24c00fbfe67562211bcb06a8b31401d6e9d140c995cacc47d6305a9ba2ab103a840fd7e5f11980eb1ed1b44846c558f1a2744e4fb6c8eef9f128b6a987e1ea5e5625ec56e623baa637628aaff336027a851b1f708db28bfd37f10dba50c026f8184b37112fabd4248fa557a6c2c3ca304edd69c4293d7c92ba17275b5265a6a3b7816738fd968a6a4b8dfe269557d90ac2d8d94de5021b7bde166750c9b705226c3f9eaeb3d60b16f7ee19fbe62aeeeec06d94ae96626e4621384a730f0f7b911d7ba8cb060fd1258ffc5c6ef9f2b438618a3f6ed9082648759ebb832f6d3f4d0f75682d559f65334e444f8e898bb4cd5dbedfc4f296c25742bc3fa7970b69fe78e2103823a14178012fd1bbf6663f47593c9442dd5a68bd4ffba876db263d9247453b3437f8960ff8f3abb128f46f1faa800fb336e315a70c06758b985da486a8bb4ccf109834d7dae4dff547da1af27e0e05428b4c00516683d0983431d25c72d2bef4380292c780a7d80c417b7dc1b7f1dcdf73c4ca05ded1c08af166ccdc5c09ab58d301748bd642831814d98ccd2d11b6a142e941ea961f8a9d6f4d4163ff01e53b72f72073159f3b75e04c4dae3cd6982f0bfa1a380dedcab55ead1e58c90b0336962b4b69242b5f48a252d1e54766fff3b5b05e9f0b9a18c02ee8fdd4858dd1ef946e8688268485881131801d2545aaee5e5294a76cdefa0042d6001d0b33397e6245c437ec47bc401c6cb7664a775d4f2b9ba03bba42d9a3b5819219e511a8608200e3f0e2d69bf33485a45c754662e38f4bbb208719467debd2d062f8e3d64cb6610cbf528ed0601bb13dea91bfe46092dfc720e953a7468e377f4689678e286e9b65cc090402d1572142f043746effeb2ea9011db429fcbf7d82b34cde1625bff26a7a835b42a10aa3152b21fbb7b6c8e23723cc1d0bfa479dcaa3119835b5d5bbe005d7aaecb7881c97abbd75ebe6433ffe982b8160956679086a305b0812c2874128291ea644f41f84dc81ee3779289d497c2efbf10b8891542788d12ea3fa28496bedb148121552e2caa3281ccb2b281ccc5911e77d6a1280494b1a8b511fbf3e071a9e986aa6c1d8a41ca128102bd217f702be75f40265e3411f6741114f674af178619861ad87484304f006c76475987e559f43eb7bd700e51b7c0347ff931b82961041ba87f96c7902af2e432b87672a2d747857424cf68b299cafb89d6fdb5e078035e267e28a05b79eb1adabd9943d96cc825e5fb935e6fc7dd2d1c4724085026f901b9b16a94d345bb7077b407f9745281148f4a693d4ebcc505924926f0d6052395e03ab0661f6d45e916fb996c4166c9611231966a6ee30f00e6d2eb534173bd2bea0ba4abe3fe3e9d8e9da4201a83f263fb098434bf33daf9b996094cfe676ea11a73e0f1cd4d4d422af71368dd352df66fc8ba7d404fb8cf82f8a48e6581837724d0d01a6ea748574d2da03bdf4ad6b2dc79849de0bf02c4a084b92cdd83cc2cb0865017d61e3772386d0a0e76aba1dd442a4e82a07cc88a3c5bc2a6f0e799e0f7c0e32e06551c22eaa4a1e663dee1094b001ef202d4fe3887f2b7f873ce5fb0e52811afd3e951244432f57b9c06c23bd5261ba1e80bbfe44acd65d686bf858e82a265de02e081ebc4bb61062fc838a55c43a8c7572358b7170b2de9c0f2a54a3709bf5c541e0f4c932c495859af782ea7fcdc088366527a6e7cf0c0cd21ed0e61df31ac462cbcf395009cf284af24317f8f011be61c7499ebeabe81c7ba60742d6eb091d640c176aa82c0daf289684280cb59795b0e39565193c864ce0ddb128310d4d13e64748d8fd0d65f429569ea671afceaff8ca327047839c87a328cae9b0f430e8e79a7a2a4f4186e35e597b318454ee78913630768f3bd59a86d44d3ce71e3973967d096a8252e7ecc699b35f46efb0826923bde07587da02832a852301d3fdb60bfc17952f99553ed9e5d71ce1d1cc6e0b85587b2aaa7531aa73ef14fba5553a680238f2750c2d452cb2b3007c8eb7ecfd2ee23575d4fe11952180630524a87f14119c851b70d5b8ddfad09efec87aa523372d2f5e115bbd3cca6d51ccf98a07385baa76da547e52d47116c3fb28fefc8d5b11221949b675a8b98e68a46eda9bd52931d319c0f0c41a414da7ea9b1dc7156b61c39ae880b40f435d8aa9a9a300c0d5b2b481f058e0c7ccceaf0eeb9fad34e02104644962192a275fb6ae00da418f03e221193d1c4246ba0203e25a305406026ade094e44feeb99f2ceb2f357d7ac574c03226f8009422093ffcbaefc6e544da610add285da9f56bbcf9a819bfff938a76f8adea93a76ace32472e5f4facc5945f9c3fb1022784695fd5afa47be7878f50cde1f4823b50d562f33807d13e2b6866ffda7ebb8844fc51548ed3d00764688850ae7dee3f6b6f672ca43e62138067091b9d7a96161c90e19a9f30fcdfb5eaaa8e41847be093bfba7c56af4942b987ec0dd1f8e77d127bb114c0b6479c1570b03c816d5dcf75e3c215c600065c86f3b8749eafedef8bd699e2449852311bfa98316828b2870df379080b5f6ab4b36e9a8c2d5d25f5740b8db33e99cb54344adc30199f2738a4d6e086168570790b2b0add3c5db312c01b3564545f55bd8a6c1abac47feb981e6402748daab133a7024105f5c70c967f1eeba751779c86ead46a210117bc1cc6b33418a400eb6319e7582739ad2f8c674e857bf1de80329dc3c545b2f5069d8d123643991ba95da61a79840a92be43080fc5c2e4c3ece2aa4e823cc2a7fff893ecea05a00f705cf9b576938855a1c4d36db86165b180ab963e6670bfc6456732734f46287739d0594cee51a01557da4bc19b3e3ff2d8b21ff7130c1e7ed6d839ab099bce75c49d79d4cfd209e43823e1bd1b81a5aaa39914d9b1ae33033628a74db433f22fad79fb72811d9e6b760eb7e5c7eaba2694d8d3a008e573dc77a06aee5de9bccd354cd3a97b1152ec1ef8e239d70d0d281f68ea42f5c7e798730dfd5a540b3352ee43589db8c39a51012e4b92ad068c3b581e0426914b683347f032eb568a3a81d05457890d6cf3de2b2a01113f0ade8c4cd17c04b89d14afe67f7993e4b76f8b4169ea84f4f4d67fbf411ac86de96ad20a684bdd480aff2de94cd5568b0a4b64cb368d5877d18458ff7e742695cf2ac1da9129e16d1c0a6002f5cf8819d7177f7b8703ac978fc8f5104891079096b75c5b0751d12e228136e51a58a0211768f551c1b8b4008f9d0e9d0786b36eeb004157384c6fc13708d9b1a860aeaa456abc311e2c04f5c55dcf8ffc823a2eb3854fabd28ff59f3b25292a83d91beb3ac39975962cd31a06146d67ca36daba623046d6c801f00df093aadc03f416fc1836ed53d7b8aa828549fa267d025e3c582a30959d2c12c5ad4043013d2e805159b60e48f8f16a8c0d72c0d935b2cadcce8cc463f15f14416d01bdd0b0d6b152266f2dd3aee38743243ba0226dd1c13a2fd46688227f31c23d631f9b798b500b1db705bfd1a75f9d3038e09f648699ecdaf0744111efb40e7ba85064ff7ca14225bd97c9b92ede01a594c56072076b2a5ae7f606289c32f825f20afb2445ee599096ffd1c3b40cdaaa7f69ab755cde14fed8bd87f84287a223bf78e3fa7217596130a4d630f552c850a9b14e3d88142fc48e28e80b5a87747225b783a3deed170ca3f7dbb47e26556a39411ebd91542c63e22bb8d607c776544788909c66bdeb41362a16ee8188b2745db64d54f5c67a2fa0a8e97090e63cc03b280b9e2cd401bc3f1c10859ff676ca432b774f9643e2fb5b430f74b8039d9ecbbacd1a6d72ef3aca92248c0ee85a08abefce2d528cd48131b264783ebd49dfec60aa49602ece0f053e61a01eddbbc6f43bb6e76b22e73fdc6d1c2f98cba384f1816a451d8749e7e8242c054db9d7bcfc883bb9298a53a0cc76a2f5a7eee5cd1a2cb20fe77fce71bd29bb84ebfe0cc2a2e05c5aac73801389e361506fbabdce1024b51cececea733b45d5de9ba09e3dc68a4bc465d071e23bddd6da375ce2be1b92af2d03fd7405eaf0d03df31f4ff260f67ea3dcb87c94047292ef9239c4529b795545abbdeac9c799d9e801e57dade398d4dd252e82ad9d47884b64951114c06f02a7c9fe5b36cf73f78a008a03ba8fe5386982df8cc6d55f3484046d2160cfcf83ab3c39118b952fd7548de1a025e5057bc8c97f58af1a1a3625ce000fb069d1e5185362fd5ea3d8181c214f6b25ce8aa9123b4bc532b2576ea0099273d91bad08ab5535b15b6a052462de53763b483c16ad27ef4d911c9532ce2e6cae06b00506b54c8f304f0cdffd83f56cecfc1adb81d6dd60c5755228d304d5c4a4ca35f5ef26bded5fb1ed7a5d88d5afccb55dfd5f732d40e7d913a7a2a03353a66a6997a074566309cf84e6d684714ecec587be1dc5b986ebab27a1eace5a4ad5ae54e437bc64e910e57d6d29558eb9b1ab04bea47174c17809c8ee12877ae3efddbfce6022228f1deeaf45d9fc0e4ff46e4a692fc2ed6013a69289d8932b3f2a592019d58ed3a78b81100401345b0bd9a7c596e4783fe052f109969e668e4785dc0903338bb4f3062abaa4f6a26aa2c79b39dead5f264719c44a839d033f2f4ec3d0aef7868827c8d9d7cb1d51d828d94c2c6e73e5fb3a37e392f0a6bdcb1ffcecdeb79f14ff2cdf8f285300ec360afc5bca25ba4e826a905d69cd7008099a443e61999097fceada17fa9215e23c80154f560090d14db52b672b07168042deb082154133442d83dd727f9d218fbc523655eaf1ed69e7993484c72deaa5a760265ccf432956d0e873ebafeb27385e84902c1f6f8bca372f2425b6627a0db6ac5740b60e476f3f8bbe429c212d844fe9cae7b65227e6390f844189727b7d9ff9e3442fd7f3e7d060d9dc3582c43bcf2802d15fd2097248d0a118c7dd02f162c14e3bbe7788d80a7006703b5d44fa27f214560615b60da7205d9fdf3b16c794ce04711384a224278a8158b483546eeb30d84891b2101c59bff0b6406573cf05a046a8892ef80afc97f164c2c26cdb2b9cad458c1804d05445685cd5838957aa44fae4548044b1baf94f132a31f623b1a618a55ecec06b15512205af0f407c1d5ca3578dbb5e796036dbd049a3254a7fe4738e40777a17602938efa4f0becde9aef139408a10df25de2b0135679a3442aef10b04ec2e9e67c82650cc63aeded14230f39f2efe0fe89fad6aa894c8fb89261a80d3d1ca1e1397f0fce16183de5bece4cfb57009bef34fc9b68a46cd5d4bf4fd61bd0dc4add7a36c158e578667363c7a685541dc8a79c9b9f72598bf5ec8ef55426736da664bf322825b68195171d49cb445f8154459182f085272162096c1c10d979cdffe5ea4b57244e6a4c20d1b8d7aad88462ae5b322ac68cfb0310e26d8b2b971ac7f07c1e4b89ac8ed711f4f968c686039a44a3677d010caf642697df6c89c10f5dbd78a8d43c7e2131f3d0b192917f0607847e3f9265c188a75d4b83c1095465c6a9682e7b77e97eb94d658571c3937be60afe0a9e13db31987fa558704514cb3d709ea933eb97eb33244c605b3f30cffa51b868758d76ca78724f702ea2b88d3f782cb6127bee790fa7ca5f308cdf84934d656456f7e319e96bac1c957c30d456858351c7e6870eefbaeb30590cdbc151d300e0692b3a794fb478399fde358d3843f1bfe8f20feef04b561a12f96fa79cb77efaefddfc9c0b3e46bb7c230f04c00ba7edf348f0ca70f69989b584d71c9ad9f4b7de081b58740551a4e4814dc4f05fc122c2f40f4bfe08f3f16facb0d6ef422457e8527626469b4762160547a51870ef764566bd9ff04081096f727f42d3fc4c2a04abd9348129ecbc4305730c8bd3d4a119836a2dc1e12c105dd36569f69f58f9a1de6decd0ff32f31b18d2aa5163ebb4eabb54c474049abc2f0352d45c21d3d570633525f5359d5cb4621010948cd495bee18c7f12529e3820115a6b9319ba7a91be68b97bd56b17e4cbe745375c177f6c01236aa4442226cae1c86376239d0856b343dfeea66de8f0701265aaa78bfb185fca1976f105cc498813da6f75bd9fa62dbb42065f2a09b8a3e176c6e413ee9bc55d26d6e94be90ba028ed1958805f45cf54747abeb6da4de8f80b6104d6ff22bf3aea1052897a6ea8816ced24cee3a7fb6e2b6739c59137d22a05dde4a7528b30fd2263ffa3b7b9066d688aa61d30eed692144b508d47bd96f8a6bc4ae82a173654270ecc6b0a94b351e41a6f61c22dc39bad9f7f6b46ab2be54bf7c21de3f540d73f09a32db2a9e47416858a6f5351f8c76c5249290e7b070dcd8d518a912a6b337a822111ff13dfdc2b56219415c8e95644fa9492de7dff4a5947f88075d9e118355b57b0e6275b6a0b5f2ffae7ee55c1bcced4c2803733d1cdc6f2c682f3a429ff9c8c6e961c1e8560d9adee03f492b6aa716b6fa0829a0090fac78b86127f85765412a5cba1bcdfd68c9d588bb1832c551c3d00c04669610f219e53edb5c6d7b555129922422ea1f8a73d95707e15a67f57856abc9ce8c5a40134ebdf0512a225cb6d10e6c0580d281feb03fddde0f45698944151fd124be46759d914f600a3a63459a14b3d37ea882c6e1e1c24cfe6a4782b11b559e773cf65f7bc2449bd2c9ad13e32ab6d0be08de4f69b66c6ba5152728726ab3d62d651e2a3f8b7e933c3f1a0b105629be02fdeb1383fc692fd31fa878d6b9b9e708f8a4fe18c687ef28718b664218f279e77eb7cafb5fe57f823357c164cf6e4d61b962cb1aefa6cd96944976f6f3c0a61f928cdcfc1e0a30449fdc5f2fdb881641a79364d6b3cf3db779a5fa30bcfa8e0bdb4d65d955c60fbc0b9620156f6c233396cc36f9e776f7b9983549dbf40e281ed9d22dd525ab76477cc637fbe855cc1a6883ac5d940187c580acff7513bf72211f609e7f6b1a4489b9929848a0bf79571aeb11b9c76ead7df10513d78f2b5d649f861689446c12d9634116ce5ff1cee680f36824ba30cc5d587f10f993beda67d93c5b9591e0be2a9cc299efbb0bf828bca5197da7d06066a71f574ce1d5d456ca6df00c414942127c6e103118e8a9d0da7e76e6bbc6f8a3fb42f948ea35eee0b218b5e6b71bd2aee9e333e68715ef84d5d99eb896680dc8c0d68b37654cb34944c3bbb311a7f3700d2680fde34dd28a29f986b3f71e307a39f93bc8896eabe039c5a5a6d33628c9a2e2b3de7ecae5cc0dca3f39f66df62994350c20122ee06bf1a100bbdac8417405082b8aded267dd93787e406d3bfb6ac2b42397b8770c644833e9f7a9fdad4a6d56fd1f11c1cdffee85d18ebad470af3e9d266b9702782ef3fd2b88122ae89e377e71623e5cd038abeefe8138398a408516dda444014d3f9b8b8b71b749fcdfd7196a01477961b3711c9508ad0ffe947ce308382e4b03d7ebb7831ee26eaebf922ae1ad7aa56bddee9be3047406fb45e6ec50473e5ed7e7844bf93be018293c60583b287beb2c48d6ab0972fdffd30a5a3d92e2168949d05f43c78a0723fd8d3526205e2b9764193a764a6de28fa1698330d3c248ab4f608bda20965029dae3f694998f8bf45672e727a62404b1f37e86bd67a540b2bab068afbeeea9070a4e1a83dbe703ee77f66748d0d4506b7ddb50e21aee23cbd9c91a5949e76852974227ec141ab106aa07cf47e463a9854d33dedaf8de6bf9be45a58806f5bc073f2c4d7167182bc57b9dc5c38b6652302c14428176acccc8a83ff9ff8bea255128b58a973891bd728d3f74b15c3bf0a3a7f91dbac658cb565ffcbe318a519ab899230b7bc8a6ebdc6adc4ea48c6f0fc4780a10cff8e79cf4cfdd9c44b2905e9345e6b5de1f5d0bd2771b68495deade9e38e792ccf4862f0795cc1b5bf209e99ed719f40b55da9bdb0d56dfaa667004b18d996634053ada7f955cb2f50e22af5048250740918c8fe858eb9bb580e341bead087dfe958c08629f0cc7da7d153958e27ef86b4d47a884a0f2388b4f1c43eaa46f21a2a279d38e1a79c9bc8096c33250e7d1ffa6aeab326790040c4ee63e183922e988f0719122b8c95a932e1cd450271ecf3bd664bbc465c91e9fc93a27dd3e60b2e6fd9385827c086ed941cb40a2ae14a0a973dc451444ffa2677612eb2449c723a552ef245934976823a94c166fea03a69548da4cbc365b8884e0765a9f8117f4f67aa69429d592daa94b3a24a063b261ad67eabab7af31bfe2346108737bba056ace27eecf55d26f3a261a00dfc91c96caea04939494b05c60e1d26411a44aaaf8fd84a373180a878211d76845bc2a78773bc9073b72cfbfd6c5eac80387b4bd4aa7db412257bf8d4b67f2b0b593cd6c8af93534e3764cf1e80031e0da5927500842bc02b734b9dadfd6d8beac66dd80f7732c30e53873cddef05667a1a1c79cf4b984138c9c29759847468ff1d96bc5a6031c5642b7bcdc236219a73960ff0e17546b3b1481c1100f282fe331f225ac9bb1137a14ac92ac8942b8884c0cda41bd21a38e25985ddf6a702581940440d6c85f34fb8e608af24d9fb79b248727555a0910b24a3fbf6b3e990382d565ff38eeec543f679252dbee21a401cd45f6536a8fa0b8473faf8863695f6b4697892648fdc5d244cd1390a0a2c0896f835f5c6009d53c9253852d6a3f7820d8e185b481ea02f146bd6016a5fcbdb8f77972dc39b8bd79ac7b9a006e94c0e8967617d938aeed5e4474a7c331bd5979eb9801b394a48a8c37d291de1525c08f7cc1c1e25724e3a413dda0411288a6ea5c9fc5d169256929fe1d426237de07f0deccf5f64317628ad830ac6b3c03fa04c957a381d8e2a2ae3d1333dadfafc1c796eb6483e06e08f9ac385581381e82325c0714223f276e0c5494eb91a9bb1d6a199d359ae49ccbb8648052c5de0e90e7fe2c38950151ef7a9f5605d1335e5bbe755f5be2f9d1ff6a0b64521b813723024653e5e85d7b11b3c18f5a7683d0168bade1cec6a06153a77a595e150e320183ba143280213b9737a33b67de385d838895ee1885ca048499f14957074e6f970855e6a3f213a09dd11e33a69457420bd02f0152cd02ad912db68a081f52871f0dfc5423d38b87a08f45be07f6f4ad067b5e8de8cb9d5f6df8fb62359c671ce473b86db9e7189d52b140877d09fa1852291a733ffd25c8dcbdafa85c8cc925a8c1b8828c033f58a73ae5faea20229eb80ad28d1992ebab2ebd770cd44eaef4476a772e99d5d8020a6c94322cada6523d6b618e8f4bcb03c8040593f212ba723d6d9b109fe603737b52b1ccb0b334517f68c9bb527f718d61eec024e01bc0f9029e1b24e8795e334af82a58e86627b0794aacc874f1165cf1b1a29450979d93d46f982c21d59c76c9c528ad7e0291ffc0e74d84337274c6a8f8cfa5ed2c8cfa79c305e7dce565876d02d2b430ff4a31f3cc5c2a9f71e570e0dc9c4c833c099f81e885854ffe80f4e4734dda7af1c9ca07da0d1e087d5922b3eb40f602eaa0459ec274e96f180faa5add2d69bb53dd64126abcb0f1c3238b33cc523063b7f2c61552c811d7a970c63c4ac4253683e08ae04ef5c8f5e4dba844c47b305847ccd87b94609866ca53f039fae06d4bcd2e205d8aea785ab494a557d217bae121060664c5e0e3c31151de108a1cb8ad9dcd3b29116aaa74fb116e09d0c106c23250e3e29a2346db944930a09340870d88569693f774b0a389d0826a48808ad80aeb6fcc337fb3e66d051cd0a91cc0bceee1997c6534e7e354ea015d20c5be9c0cc335457867aa8b3bb55fbfe32d8806ff9e6bc4796fe79d30a5f36489a5f67da7f623f88f4ef4bf818f7f2563d4aa9bda0d0d3b1a43ffc3f20b8bafed831b69e81df0a0cd999a8a512909ef1782bc96fcc9772dba0d2759c72f6d6a9651c0c7f7ba9d2289fb8d67fde147753c19fc00157dd820e8c56a7943ff030cf43f5d57d96bb50622e4b60735ea76cbced1311021ef2792376237b01eb78d70435037d36ef7c547ab158680e2da080410cdb684886acff0e06b4773bde7c20aacf25454c7876a885fb59f3dfdd96f9eaebc84ea4e0a4fff0754761f2fc84d1325eb533b7a335be544d28f73c6ff2544c1c218e30816dcde6bc2111ca402db2bac2cd9461fa0bdcee51e323bf3cc388c9508348be2a8c834b160ddc6003d13c6aecacd80a8e2aa494c481dbb0da628244a853ebebc6a358af672b817e8af1e4419eb5ce76d167a9e8bdc1762fa934cfc07fd00acfb5a06bc17832e189c900d26a0d39b553dafae29a95c9364682b0ab34f5977142782efa5530ff625b60245b2f518d9192ea5891269abba56d5ead28dac414f333006725c942bd4b77d064aebec0eccba2ee34d3181767ca152bba38c6b70b9d8afe7ca749e3c71185a229119cf402f84cb08c575e7ad1469ac2937f72ac1be6fd4f9c166a7ec63a194e8e797640e4793abe5add594b577454a69d889699d4a5e84a9b4f0af1f36c8c3d42990c6ede33ac670c051adf39f68674bb5a2500395e5e8daba2612a89270a0450240a5e8ae9cea4ed7ff9865c79f67ffb8e09077a9fb4d9e210e835113faff3e750f68d4e2f64c07b688ce417e232402405df8f63525c83c36d8a1f5be5caf3b314914c3438da39007ddc382fe23718f19532caa420762e5fd534d92ab2c92eb0b40882c0e3b25f8a8e179a5bbd8a328aac86d57436254d2b1e05478bae85b47aaad274ca801f79813bc3133123ca7cda37f75114c74776cd1ac96292feeb894ca474d8fbad280fbdba052e1d30d77d62413ef51f9e1fd9db2afc3431fcbed05d13020298570874bd308474364f2999f258db982a0e87d80a75049ce1cdd89d6d1466bc5186bd6e5f08b0ca43a36d08e8f6c86c292be6c28efb6dd73880ee187bff58981c39fc57ddbccdfdc07d5d681e98848a623e4c8dccec7603370a818af0b24dba6ef01e4e27212b9fae8e3a48015793e3432b338891fe61877df2b3b2605aba27a43b71501c7287c5653f1628c03b76b5920f717b572f6c98dc84a8ea0d62753ea6a26381b6c0ebf760817fef49d26bd654ce1c96ce898447c0393890cdebc82c6f01fe20cc39216689744d7a098f1d35677773c98bc326925848089e97529ae6c97034b16b678012237be8add17faabd389d9a8dbf5a4c7c169560097e9cb073c03d9a4cf95d0cf81cd64db8ccfc7252fbec3911065b793c2a4cbb1480d9b6483d6bb6d2e86fa8e0b65a41d2f252b5e6df24055becf07e03b4f4154f4c25f45a8c5f04674d1683c6768e47f943d19b17d9c019a23d6744ba0cc4b0d9c8d892519617f73f79e60df00df77c21b1d32e561ad618442ebb09b120ad5d9dcd63759b2c239e7c4861fd3268d9e182abff1bd958e1d5ef59ed089d3e261c8776b3beae290c8a863bc90b6c18f82b773b8ccbf8fc6bd3e2309f3ce3e2c5c5067ae0f86016a9aa99602cb23db55fa971dfafbf22e29548a0aaecc511646e7d5fa15e7fc6f66179db6726e53f826e6cb659580b2e5967cbdac6f3293e5b6cd232073e7f92d0d0da5f71746dc5e84b3a44b949ab11632f01db3acc927d0340ce8693ed51819953e748a7681badcb2e88b3ab569a66846b39cfe20e8835a3fe0cae64c00b2f60b1129e8d0a47d03957a6fe4cfcaa951503fe24facd9413c1c1412886effcac6a9f4957c3bee4a52414310761d65cedd1cdf97970b32f27e5b8e8c9fda039f75419b961862b72bcfdaae105778a5845b5a84e12b866595785b970f1a4f40f2fac8a61925b174f7a23994d3b13a133d4f2410a45eb690f91c144ea1873758e98315a9df22fbb9de0ab436b8cd11301b05ca9440eaa5d8d5b8d9d78bbc0b5bde10eb191ee858367eb1032046fb6ee538ce77afd4169968a24426affb152362d6ba4c6001ed2b488af0c8b7f0af6119b72b987c6133d605da254ad71bec6d5a97823958e621bb26872a3849997108e12e10f5643e620d0d47e953807c3b8ad55d2b5ce758550edf302e34ca2d4cc19917676c0309cfb89622c5461bbc63bcf5f912a517b66d0f527ced83225fb7849d9f51db6b06398bff72aaf30852f444c42ffda2c8a342001bd75f528d7e7aaac64de9d3feaf9b65e113c218038fb0ca61032f74fa528215d06ad913181b44199baa5961da814c0958ac6c2cee752d6bd4c4b363e832ffcf5eda7fa4d157f43b3c3b653f66d0c56ed78b2e62b462bf9c6a49f423f6e9d1a9dc85448b1999fd5783480a69f02a688044672af53a798a1a2fb392636e7ad723e0e40af52720bdc6d202de467ea91f194b4646ad4609932de4f2c13e0f1799c79c25cbf21705531fe57bc6e0ec28f5b9cfc3024af08bd51bfc8a513bf4f4231d83f7da6d21c27fb5f5e012e883fab3df9621ef5073f49024898124c35b59c9993ca66c1db0d6b9802a47dd66d2c76f2e1d6e2e56f11fdb0c2f7cfd16b899ef5ce43f590f86f63d5d51d12fe9e3a8094bdd9d4ebf605c068c176b8cbc31893706e8111c81e6bc9ff3839de3554d3f50678d50db8a979961aceb2d40d3bcf59547310f6af7eff5c3b61de149fc2b2c34fb41c75635481a7f15c1cf7d6314931b1ddbc5cf859d3cdefd9583c394cef6cf638e5ae207722d01a565938689398e5da442f8b6b12884e034ec6c0d10141903a8902257b762c0b2d3bfc3cc43fc271059ee41ad8ef13450e71fa21df57da125f661ed003386ec2008eca6ef6363e89a714bfee30b0ab43b1457635303e45356eadb35cf00500ce32f1427d124032a799489cb32ab63d5146d4ddcb3c12c3c35be0e7b2bf362024781aa7119a4ac3e31014d7dc93b385f401144963d9cac819c05427c01a07d77776c1e85d0d3bfe121f0021b1f5e666f4c80f0f79564ff867c766f9046630706fca5b3311ebdf6b1c6e1be65908d7eb4015146e0c3f4fdd730a0d88d47ad7c272a5c08b7b70432d04963502b12beb7ed903d44b5c0d311caf07604f6111ff028618b11ce07f5c3876ade02a190786359ceea3f4782f102c4b0b988424373e82e4631cf0b84716a3c0bfc630d821cb2fb36a148f897f6c821e75825deb6b026ebe6a182adb0ff27148fc44817155e19d6fd8a08a0fc200b9d60b422995c1829955a865171bff3fb098ebdaa2a4077684598c86da58e4c35fcb6cf8f578006e74da651ab9d48650398fd1aca7cfbad2c6db1b2c2f57078c6e10ef8b08cb97e24344b3aea4b00faafec0ed7cf4cd449fa646aad406615b1e1c63238000955b8baf7f85c2d75dedff16d00b93514c5808b368d2eaa378c7b690a1d9ca662743ee1303e2ffae1cc829a3354aac34081b1002e7d6810e1ea5b652a7bc8efe802a0d5401178befa06e18dd3bbd9043e9090c194f078d95af4e8de3a66ff8942f8741dabd930bfc35d5e5520c0151e024ec7278a92e9d1b0b99fa38b40fe2b42b2f2936ca559786f2fdebe2931c4b16059abddf5b51f64d87c3a76eaec2f7a3b421a32c34a27e8059d719798d8d8aef8a56221ae0b968afd5948d5bbcf3cbb3cb9424cf79962001fc885ace565c41650a39f385a00021617078ab4c0e47930c6de2d19f25e1e0a11eb4fb729b8f67fb3e96db99b6d505d269be29b0b1e296d9c51d795df0f70ec043a4e8e99922bc51b37ac73bb9cc2cf65a42e3ea5844dcae8993940fdf75ce2d4ae403a0e96fe6418e621e6903301d5a64fb6b3008ac665216ed243c3f3c1dd1f15ebd2e444b46f87d2d3caf440dc38220f8c7923fdebab05427990fdbd1d4327ba046aa96cc4d4ee1199154a3871370a107d3d1c57a0ef8456800b7c2fa5a72f75eecbab2d498016ba659ea451bea63c5621c21adf119b989e60426aec150941a99dcd67bb3a9e152e51e0a0304d70c2697dc5ba2872a63c1d52dd09b4755989bc1c546b8be00e3ef5533baefe8b2d27edbb252aeeeed15d87ba9c1c21c7ce2655463c9516b0afd91ab507e5668f71d695262afab491848fbde9940db4cafcde54175598b19b7caeb241525c2dd9047f2360edf474a5b2f3c6ae2208873855c14945f058b474620c1547a43a75c6b933073c8887e8412b7fc78ec69170da4b333a1e06d0ef1609b3945b3b9787bdb12c40baadb3d6602d230b3546b12f39cce56031810c03860e4bc866de21719c2c6da70d17581c433e4ca6976d98e5c5ac5ab752bccee755c99339d8a9d571f44d7c9066f439c1c05bee68a9b13cd1bf392eea9e1e51b04df8304adf1248aaec962c09930afa8e3cc44cdb7bcdfd993caf77a374aba443e82f77b040236b704159fafd7a2cce4525d187c61cf707d1af7b2ff7eb00543139eb31a3e3537e551fb19837d277897597f421252f7e0a3c354a43396b67a971a78eeba856a782a2733b65d943d619f5a44e82f827f9a8e1314f6d7ba76d502edbc14662e89b079efcfc99e847180da953e4a7a01f780aac50617981ab9b245c72402cb1765fca7c677b14f8259bbffab4a6b790743ca9e9dc4095183cf8f98051c4d116d28c5d8458aabf0f09fbadd2117158f8a0ef6f35267d196291a12b8cb91d7569ffb1545b086beca9eab1d98439986d437531ac0136b21619584d94770895615e93eb049f5bcb22cdfe967fbd30f509b475f7cd8579387131b10d85e32227f215096080be39678d4723bdb89d1a2157abbd94fcf7bced7f1a29b92ca9f576982b1cc36514e9919ff540816b1696d5a85b11a65aa27ebe35fe752d0b23a7781c52c50d105202c524665fcd92c8c19185abdfbc3a7428ba7761de03f240c6b186cf43f2a326b5b23efa5b8eb94a1be871469bd259cc5de87141db1fc721568b94b986656f0bb773e91a044da86a1e871e62e7d9ab1e99d8ea161653b042b4469a514d97152878f7c6fbee4837bc7606bca2adef0ee7513716baaa4e02db626a6947cb1a8ee74a79e54a2781c703822edb563f0a539903f33491058c537f5550ba83396015eb579e7d234e393e57611214355c769b26c1d85dfadf0d6defb150723b70c0c8b6c635c7eb5e44917b758a21548d248720274d12da52bb385824171a2ad3a57d2e0a42e313b28d70c20856354de91d4b4befbc745b9be72e6798f77af20f114be66ca85aaf3f8529dad0afb070823e3133fc40e536c630baef95df1f569147144794728a75a12d6a18dae3debe86b69c89cce742d4c6f1a9bbdbaa01ac0f34ca3b84110730ae9dfcd02a6258ed850f71801bf455899c593097e05d4b0d35a4be5fc113286ff1783c4ae59785f908ce7d1faf642db3bce65b900e6fb8d98f6edcb92620d9f4d1e8140540b8c91cd5aa9ca6637fdf46f50bf798756148d47cae795494ca088a7ba351be94a85e5dc805780d58e7463a447ace347b3e3fd67511f7b9c88bc5e9998e4ed9df27f21ed2c725b090d29837ae76b6dbe78d9c2e11cc31aea0e0bcc723fadc380c7d4b285ff90376c80e26a217bc31d58ed232cbc25a94600ebfa355b308a4869a6a2c36fa6bd64c4029ee526e31d018efbc23533dbb18311233bf8322073f59b3397af6fe111ae26b44c2f6d3093c03814f7ef032b0d2e95d4491e923758fdd764f4d52cf7bad296cb8e5f8265dbf63e4ccf7187f0548feb712e8f98434f4cedc176447243ccfa71defdf1db850c3bfe357c3ca54d4fb2d0cf496d1a16acb1792b47b0841841daa01d4abee4350b42163ce9fe2af0eb6ad578880646e5bbd58b370474b7be0181cc1920315bddc59aa25b3ae906086013fcd73f5c144b211e987c525b0e4463be9f49d1c7dc97560839838d929366148a9525e5e79b7aab3f208ca4c56b99c8c1b4f04e6246ebe1d7ac4c98f4751b0a774647c6af54ee77620429d57c468096a64d0327354b4e215ddc525a3e968b7203940e3e910068a1fcc2b9542449c9674c3c1f63abe56019278bab1370eb382dc5c7b80f52d7833074a6cc4e3709e1cd38bf41df885fa755f0a164b6b78ab1f60224542e71b411beefd61f800740b22d4e05c13ee5077ee707a8a85223d00b3a0522e4188c90cde67f882c9e8b869b2131fa487a6f4ed9b721f699b9fc18ef71f85fb174959999cf1dcb03f20c7786475a20ac7f5c34febb03a0c15c67ddc524d312b8ac68846c7e8719198776780897b62e092c8590a5e46381ab0dcbb140c33be4b73877b608fe612d55ce64419c759d2813cf4d434d63cabef95981a5c42ca16703f06d41d75c0221e1e070765e9b81bed6a1869b10d268e49d732377bb3db243c2b1c6a69474845fe15a3961e486910694a7ba10031db23d22bf2966ca15488b61ca3f0e186778591afb8ab5a904e34ad2ee767d3612de6fdb96b98328995d24b3d63491c522e46f7ee337cdc0ff65bd99b7204fd355e2f7d5da63cc8bb99dd95a9b4c16135abfd85878d6e382d4d84318723dae1e0002d0531863dc3420b92665e9f61275ed91bd73d07d0411c76975f5a314871d036845dffb9857e770f050909e7292a180fce58238cf20a5a46efcf5e8c26b51c8868ee53aa44341060f1e77f088c39192089d00b5335bfed85b217cd8276336e71eef92696e3cc4af207acbb68ceae5e360e0151210b05311529de9cb97e2fa3c5f7cea23e45f62054eb92a056d5b201c8237fb64feb6b2a8c5abc5489afadd1e10c7521f5fae9bad0b4188f1c0b0084281829a4eb66ad8ca3acddb7fef1a627f3549c9a9592f293c26867fb051e21abd8b389010dbd8333f316ca6e1678de96887741ffd4eea2d3f7d9d372923dcd6ae430ebaa1f3239231db2ff845300b400437f57b3e7629c476f1b49699caaf010f08038d581b8fa4afdb8fc7e857c8094b7e299482c1e562a7a21efe3980fc65a5b52628b05674f264622af96a71a18f0d0a252579d73143d10bd7b88217a884e26e70cf501f9f8356e61e02c4a1484f09ce394afd7fe67a048dfd48424e55dd4033223cd1a1a9ec8fa924085047cf84aadd8531bfacc60c49ddc29137496def63ab0c457a260fc4fd66e11b761511b5b864a69b36227d262ca9e67ac938bea9cbdc40a077fe69a4ae66b1dc35a50acd924e69cd1ad39ff9020e8b851ab73fe4a80d28fa762ac5dbb8b065529d896f975f8579898e6fec4c19deaf397489eec188a04a8507574e7ae3f6ce96fa6d19a586936af809032184fab6ea8f522be70da30eceed54130e705d3842ecb402070f3a1190aa00e6bb65d389b565beb4e993e6b00150343c256c67de1fba567a8d715bccc7cf4cd0cdebd2d9b392ed386cfafa3e75d64df17db3e42d3344a84a42043fa6e57e22824cdbf7121564e20a07fcaa6f8971a156de81924c7684fb483a85211a84e1774e9804e216ddcdc3e41dc4ee29fe28d7d7be606c0454885125d8d45533cdd288870505c0cbe065bb1973bbd794b138593db0398015d77fa6f84a2ddf64a2a4f4b4fa1cb2ff886244f27df45eac961255f91d40a74a1036f11294e7809040779ca844e7ba6ad85fa0f7a173436221a0efc81072fe8a6680108f471931631864698c685e0da06ae7557b136ce8cffae3dee3e35d5250df514600a9cf41437b4947625b29d9e6bcf66410303743f414adb9f372c8130e97e4f89a2560c84b98a3ed2d74f8f09b0071862be4a34ed14b42c9dee2dcea33607bd30acfeb8eb55ccf090bdeae213589ccbc8d1aba05442d6c36e5191c7ae13b7bae70b10774b6678cc5b72a2ae9ecc5d544a2a8cb06c7d9826df946a70ecbb7ed6a8e93f2d34a6f20478672bdf87da44406ae9493bb25e40e96715f5e5f7bc68a6918dda64c94597e1745c08b32b9c38b9d003e57d7988ca49577b4399ad0037dbd4dad8edb24b80889504f96d03c4d1593e4e88692666689d087e9189ceffa5fe74d9bb7ef3a518c16a77e5a1f23b4c2fa582586c92f4893f516c8778b5b9505f9b3bc08630f77179a34a4d51ef14b4f6c95f7db705c3d8edee1804a0a450c1b61e84a9b798b5ee586e8916a8b943d4c9cb126ab9562fb1f6f1e11b3d27679613d485289b6816a9b4925cf67420f41c45073d05e532542c1df4f58acb26244a0f3fee8de4c399cde099912ccd9e4f2bcc84842bf4532a5e688be87f468db1f138926d802fd5f2fd9dc8dcbee3bcd2903855d9342e50474c0f18aa0e75353d421f27a93216921374de73f829c8f3e1b54b9ff355c53baa45ce59b1bffbc9864fcadcfe4073847b2b46a459373268de8ab7947e7e0dab95fd69617caa07e84b54278d82b59c7f7177271bafd80cbe7def722c12152a7252b7ca63e9c9da58eee33c4bef69cbd115497318cc85b5bb91cbbffcb9cefd64cad1f986ed060094bd6fdd89c87bb9f74525b8fd3c7008a309997848544b0719475b6f17d584e5ce44f0723c78d4ade866b881456b11e192332658034126e64aa8ac7312b40cb244497d55e83952d0fed19c255a84a7b07a6542142a1ec38744cb962ee791c39a3852c062b01e070729e1656fe0519663f18bd0b9bb9c27f535f07c753874324d7de1e4f7368df0265458533989fda8b2158b926cbf5ef53c7e9d1f5936ddacd642185d1b7e55ac8058587f5027557cd48c2cdf12ad925daf3163d6b93d0a94bf62e2b7f68f9651a4704376629c61e169ab6c2a3177d9740a7c3361c359175d4cd37b98132501b2fb3c770a60fc4299f5907c381101f6b160f09d4b3039d8761360a676fde1779c3ead7e2244113e0820df77abf9b58a26b0a1f094ed29f95dae3537fc670c96cf0c7b30f38caf22a565d03fdfa27888dee7d15e0be423a088ef14fd9226afbd1a9d3dbf6e2bf7fa7e3c5afaaf382504fa500203ab904b64b4f58bce35f309805465addda5cce93495cfc3b8361d07058206c180fe88f24c09420b58466791ec1030215abac38d525264cb5d7a50d80d6fd40fd7052d8d2f71dc0b84ae64e05753983ba5a40c38cc4377477d5d2b5f6d2ce11c7eb66a6ed3e522d6b0ebc142f32e20299e139e9691b4282d4762acf11c464e440ee4806ca49b3213f36855acf33bfb1eccb2b339d1810b92a57a87c865b945cce70770873d1493c04def545c3bbfa6332495a44583315a147cca52485899279b19f9cbb353cfff52b488e92159dc6067e9df869f2155e77fcc7b60e6c889d2e3fa6260cbf7cf42a2106bd4c7d3592b6f1d126daf1c264cd716fa909b55e8ff01d41600442163861b1cb2c6cd40d37ff9e67f820159b7a208e85d17f88665296ac2cd3972a17ed3773ce21281c0f425418891e46d5201f57eed403aebbfb0abae13eecfef6ffb9ef36edd02d939d6dd1da95f3c86af421391182e212d0f4fb980fdcb283fd4f97b008986c77de0b7ea68019c1c116ee53cec6d3fe43d8b20cf5a05fa8c3949f7eba87d59bdbb2e14d3cc0f96fb692400f66521175f2fb66b31fc938504966a1bfd9926617a94ca938ebb74ea2ae6625d4d66dd30c983b980361615dcdf7e15326389731f2dfb3d69bb7f5b7110d9d1a5ff5247a7ec1718c94ca211bb3698f3e36e59facb774759a777dfe0f067c9b39b10ebce5bdde11be95046dc146c837abe2b0ec794ac807a772340765d179ad79f2422c412c3371f3e756aff4ca4112f36f8ed5454d38d2e07564ae96449c78b2c22dbd65e7c2368f36523be52f62fdb787ed039b5dafcfd7e189ead8b01137be9596090aa2384bfa5ba894a762cbe8fa6134438ca923f296181ff737e01a683b6cc8c950f892222b1b351e3aceded926b3c29e1ec4d6d9063bf6617d3a9296dd66af17a63daa28b58f29db41c4cdf2e7bfb752a303c3eb07e57b7c2f165b53a102aaf3d4316bbaa85ced941a5e495abd0ed97a26d5af351b3e989ff716d45c8ad427e200d1407d1770139f6b016f44a788b0c2d4ce7c8e06a7506d57bd61f504c9f5f9bd43e390a92d0b55b10c90135b45b91ea654163b1ef9c8233b216ffec58b87fc85eeb53c50dcc4af54e02ad28d564903c39e39538014d427feccb5f227a0c805f6b21a31e128a1e5a55f417ef2a4b143e43884ed096b50cb76d38139ad94855bea8a93e18f3e715e0b1fc08342037a2c6c42153bf964de3845f9a93b634b61a0c046dd356ef90a3af03c5a38260dca28c050a9d410f9cfb09b70ad69bc411581fbc09f01c50f94dc4db76021aa33ac9ae0366818688e4fb7f0f41cdd4de5949aa6d6ff77b96089517beb6b3bd42a2985bacb6c0b9ff09f1726495ef41bbad8c6f733275053c23acbf4bde7851de07072350b93348ccbe4256df10e58202b1d1c6e5e99fbc98efb2f4c032679bd1a270ac5f78e968a0c13e9472acf68d0c447dbbb7a4d60ea125a9a1c13dc5f710aa8de97badfd295c563ce4b0cfdefcf616e180a7a3b1a2a6292fef383f33dd3b894210157ad5aed83a7e68732163180860e702bc0272a5098906ceefa812a85090ff515cca4d080d810a5339eb22e039a563d713332a58ecdcba16ec1ce376f830b8a73d301d200524221e3b45430a4e25e497b2d2f5bc525a0d76065a7201ddb9d24ae4a6ce003faad1c523460928dcf03ad9a2ac4e46835b9ee40ae803388bdaaccf5d6cbb2bf3eff71b7946f605b7f89f38bcae86bc8fa77d1e7ba19a6fc2006f5b3399d5a5e77300bc68f65fc0bd4057fe91e2e46647b1a5c967cb2e5ccadceaa06f5a130fb81757903c987ee1e73dd3aff716dae7de8360e73c746bed1bc65c8ae996707b89cd9b0a10c6519190c1f9013992d89d473f1c022237c3d8f116a155d76bcd941aaf563f3ef6a6c21e20daf14c29d132c86f5328cb2f245cff660f250d50ec75a61aa34335631812f99ac31f01a7611212f9d10a0b1bf0dbdd8ea595f295aea4b55b501ac1075b95c40f5fb374615ff3b1f9e6d91dc69991b4dbb85c936d31c2a19a0ee3e6bc15112c0f510ae74c45d69126806434e8692664a57ce6c6966653d0f96f89047d0ff4f54102d194674c6b5fef6305eb72992296538c623959be0a056ef74fd476784e88a49860f53019a525586c35d4cb771fdb57bb52e1d39616596e85f2636df9f2d31a74299517e15b2d4546262a828e8a76966a62d3e8a4329052698be9525ec4d468648a9b785b0df6ea99e6eb70103ac01bbaada29692ef90b713fc04d6d95fc9242268fcda068b196ea466be02cac5c1b1e2382383272387c8b465f848d7c818768bc12795849fa95ce48224b18cc22ea2296afde3f4e115a6831fbc9531f1660380297c24eaffc3f3b315593f9ab3045a375d8aeec9c110d5ed60a63ba47c7df388b58a484c397e22a779bc3fc0c4f47c855fa3fcc43e89c425b22737c83e541e11c988a331000b4849960acca01883568679a7a22947d5a17e3909d922a7f08aa17b372f5766a234a183a2b675dab3e60af5b3110dc37703674c562fcec3a75236f86a4312e689537629e4bcc61fc5a962871435e5b2bdadd21ea40040641b050183890573dbcbb6498cd4a798a28bf445bf9f718ac6833e74af9c9b0bead6d2aebc7de95c74d0ef0bbdc073ee95240b488560bc66dba907ced0b27f193169b2f9757d815ad4aba9cab2c0810c9f01c1a9bae9a6adbbd49bbb6e737c4b839b4d591b15bd7afc14c7e36f65f0bcf30fe505179bf1fa42e3309157006902b6cbb6441cc221fadc0cf40dc749ba0ac5d085aa416ca04201f7699f8af8ef19ec3df4fd167bdd26ece0ba542e85a5a6b3ed093adbca6ce2f04d29c141debdda55d89fc371d1e692ea7345f86d7c06fd1f70282da1bc31e1117a99f659948b3861aa55ac872aa3e5e70e05e5521bc0c45c7fae462d3de9a56d51fbfa3112d0bf4d0395018446f6e111e23723306db5e8e2193e37ca44f18ce8354db5bbf987f3c1621b9b3cb2c5564c15e332ea30389e30bcb9bf3f7e5c7265b7c0082658e37c868d037a871840556d2d0acd056adbd1eac7c128c3a5fed62b0f58e13427d2e73d43ace73714080653a286f35f1d6d5520b3a8f4fb4704a1c6772f194cfa5ac3f84782da4e020a2aab8be17695487f6ffd3c8e1cb1d19457b155cb7d700304ba80b8643ff6c4973cbf8b87158367b1dab049c50b0a54064aba55f441c46436e3a48e2409c74ac119e9b4cc7c126edd737d3db1bbeb2c9bcd91fedc55e151652dd0ed5f9a415e5de59dbd60e22d3b1293be94c29e1b2c0a9ced4cb83720dc7bdb8c9be380b8346150a89e36d9b398726a5e5c499be1bba53b87f311f04f5e0426c405f5e8a19a680916feddc4fc3f00fc70f1c0ceb4b4e61ddf2996d2dadfa66613b3c16b4ea2e93cac234e9cf9e22eefb747e7d1e7bc6e2ff3399901a1736a80edf99e560e6663c267cb77be87ea235613d32e6120195649bf5944b66e0e7254e9fa6dbb71fd1315d7aa7c3447d0f1b1103a4e2dc6cfa4a64ecd82c70a0ac65945ea07822681b140d7d0e863cc89337930fa8d53007abe013596c1e465f7fce016866078eb1a9153b745b514c8891617f111d72f4b8ba6755cb2c0109d088fd9d0b21c3cce946b69ad3f440ed1739ac391252c51d21ed0116d12540beeece7e270a6b8ab40f65f654dc150dbc6d1ae87f9445e83552628fa9ae896b26fd7f530c2a9af2af668b0d37d2d47f53bc3f7edcbd60026481c522ca5d9b8640c9ab2b87d93d3d30d52b079e7cfc8661d54dd1abee54ea2c12749ad11f02de55a0df82af4e695bd94289ab2d36258dc6fef136204fb3df7826cc7d3a89731c611142f2904709706f0970018f328d5897bccc63670801331436c761ae3c1eea89c1262045a7c9b0e2b33a15baace8b19e3efe29470ce496680bdf9677ebc8d368a67fabce7db42996f727b870b022d908eea4f10c11532cd9ecaedae6039413fa4ad0418ff89bd42f9056e5992e0063dc1e1e413bc4e63ab3f7436efb67468dd03f4ae833de7cb9afeedf9f6d3b31bc5a62faaf7ff1d16cb86a1a51037a692811ba43e290637ac0faa6320d5b6820b3214256f796156954610cf7790f4f5b1ca1255ca234b6d6e3aab03b4b0452084397b3afa1d4bc3956283d8d1dfa69c99d7df6b1b0147c21da39186e02e4029a57e2c0908da62ba1e767149cd0ab5a0b9e556742f77f4b3a7e01ac66c2a0342d8e4c8528e1a89cea7b2b2ede1a073775518befd4d769ace5fabf7aa3ab1163f8ea2a87f0bdc375591d8e2c75ca03792574925685e79c51fdff529dbc9a10be5f48059f239a85e5837ab47324cfa4c03b183702b89aeaceb70b9ca4da07dc630179fbfa9b6fa08a52a57c98c511e5d7c2f0b9ad01e500daaedf70fa8dd7246c07cc94fb767f952d703ec704cbd8f78d22d08c46f9afb9bf9b74d6065960ce7f665a67705f013c61627d1146e07e853c092adc4dd84ae2243a2813718c8985eff33ea96d73b541b9fa1fbe7326e084be1f168feadab0b0bd6cc1281e641693e511b69e5a2cb70066847a1d4432d2ac96eb5af4cf62e309b511171e60b8b9f9fe13daf3270af00cd7c37a044abaab949c4ed1f6ef9eb385f093206f7f67a0859f939b0bfc8d22233da4f9cd9f66f993b407bac4e1519c502bfac44763d25458ce6c3128024e6f37dde9dbf0472c9cd0bfeb65685cc1d718750b70337c33d0257442f9ff1e82151bf3aef6bfc88f4348c649d9e536cdfaab5fc505036ef7b291e7b5ca81366641b0532c8e2e0d3996ae0dd8f347cc5ec606e4fe4e481f5fb442038014ba7ffd166c955217c5fa592b3795540e511e68ff87e7ef3897081d0e8fb8faf7f54de9d566907cbf1ebe1ad34cd4bcf7bd00c536caf86b08f3df7c40660d51cb9d469ab6c3cb22e61b554a7b685d8cc4c5cdbfb9178c20992a6ee409d2704390477e10e6426db4dcbfd19f51a95f8b87eeb85097ecd4e5d74df4b3ef7d036a0b6f1ebb2fb2f2c8d5486dda222022161d2a0e3ed722ec46e20a80bb9f8841b06fa22cf4f4b3462c0e06ad2bc5b8a187d07fd31f0de541a37d29b87b54389c17c136af79db1b0db40912227b6d9dd25ab0f8576aca1c539457633fd7af39cf245eb93d5f7774505c0cafee9c1d6c5b8780e7b66ada115461c0c04ed2f3f47b1167d0cdfaf155d65eab5025ebc3149f62dcffafa1a3a6bfc33bc9df77116818c891076095c02dd9f302b5d31e7a2c1f0213f0bd21c41073f06a0473d66348e27a70eafcafa114a4714f254bf1abc9f8bdd05b00819ea526c7cc2351defe92b1b7d1c29dd4cb360b02f4924e62f63127f6f5eb363af261e168875f4cfa3cd6f52465a2c641cb57ba987632739bcdcbb15246da154b963ea5fac4ff2180269bff9a0d5c004c2e1f7e4696af481a38ea457fabbb5f84ff20806197cdb420e642cd9732d6c0d0b3b6bede40c7bc74d6a3a0c16d604cc91d9f3a1456b3d8bbfc5b88f5103dd939f639f78b6f56d5b6a7d3f20b59cc3ec65639091ce4d85eed096928dfc04feb9496b3f85b4affb4f44259d139519ed9227a38fbfc47bbcdaa43b94d2b7b1a2801c601987626979d442645b1145d26728b372f76f81f2dd99d92e3554734a9a0f4c1389919127dc754e7b9fcc0dd3ca533de400a2a04fb97b4cf065faeda43917ade5e6a0490b3361a1b5e387154bbb79b51cc90ab8e768628e04f0393269e58ad6b305e364858b25ea0d3f6fa744677c4b8ae42cb3ee3915784c164425010e2661d5efc673222f6f51bf63106f6429dad09b1a99eaf2af1336651240260fc6c2fe44f786478f73f2aec20515416845c936f957da6092a1c352f2834b3b16cb70e6b0352a13564928a1961b88a02d9ef11dc0274984e418519ab60bcf2032abb7ee1ea98e00f7d3d58681bb768c9e6c0203ed09bc776198f27e9a36146611de51752a7505243c0e3a42f222a13fd0875190aa87cf48bd4809e2080a9d2cdf2a98fae3691a4b13db6b4fac63a5e4e281e14e682eb73bab8a478e4710b6ea00e076dbe53e18df7ea88f8cf97920988bd0421cdb0c2402878501420194da4bcae0233d549f6765d5d6bbe54487b7143c50de07e62a01a4bd397e49e8d8fd7e643a6ec91a6c47dbb8e07741c470f34461e133c1119c2d69229fd68bcff16cd42d2b5c62b9965c04f55efd54f132edae83b534a9fbead6fe3b8b58d65977206d031b9e344b385f927860e0b8894349e6ee0ca5528624ffa4ab04d7f0fc6ca296aa63861ee5f8f08d2eb5360b876fef5737dec975536a604aac5c9c6107abad6c089f884b77ebf673296601659adf39b8a49816447533f981646e1913a0ac4ae1e86e5249d495f8dae23bc17bd3b21513654a3744ebc81521a522b5da3895241508702940642c70f7439ff6405fb6cff4f449f3f5ef736a5ad19b9c2bb82d09efb1348c99d0d37097870fa6bc9769a845f1db79fd44d68ea7f52b7c778ff5465ccd178fcd70fefd3977bbef74acbe5beb683c0f6a20ebafe4243a7dbde9a4fd9c1d3d5c63947e8f1a137bd95f820895d1a9d9e3072e4ff5f31566e462755ca111f1dabb40e6ddb45259e82d69a1a16bccb62430ca6895fcb4e6515043662789f4f168cef67abda4c1d3f9ce10187410ea607a22fc1fb1e3510ed58864fc8f5f24b19c3208b1362f15fee1702ef277fef4191ab337c8ba532e4be92c64fa063a79e0b5774b7690e5dab98a8e1e27579a71c32d2af4c021fdd0688099520f25b2be9c9b3daebad78a2506980f05de6cbb0bd952bb8d9a9851c5e4e4ed37be64c0ba0c789a132ed5dd8a7f86591236bc0729aa30a4ee824a021c624269303b772eebeaf53bd9e701d00452fa6ccb52eae3d16bb7415563a84f539ebc2cc1d9576babe189e2e33575a10a33047d37b82de7794d60bb203482b91c0e8fff6b5cd5aa1acb0302d7b70d3d8f9527ae81c188b630ec8b8e77804928c9034f9adb46b53aa17ca56c04974f8d409b086d999ed7752aea5718306fc70309e425eda146af94c9adbcb374872b71583ac584bed3a02d5fec771fa858c98fbcba7a769c103ed1633c74f2605dc3d738a75350350dd1316042b4d93ad78a938183e41dffa43a8e9da8bbdaaa26c97a297e74ddcff0fe67fbe5250123d44714d29795f4ffeeda3569cb2542a303c88153149ec06f38b8f0b8dad269ae0066df450fd2e83ff8aef63e5393e98dfc278f76fd6e938e8f794571fafd539322920d970aa10dec0b1493703382d6f30ffc063c1b867c7c9ba55e6c6d1567befcbba085f3f336a500f96914a3b361b613a157d710450cddbb765fa6ebaf6ed6c3e3cba03ae36d1cc2138252319c3616a93d47cd3b95e773e9278a87ad874455f1e0a8dbfd4487a2e52f364bf7beb61cd98c8be470a8da3b30a5b9b30cd43afb7f18d369e92182ef333b508e277bf5b8f280e0d02caed10c0f5f6ea05c7783253c2924b849b71a69d1aa1036f20dff8a9b64b88678cb958dc1e2fa11c57284a9448b6ccf75e9b97d5bde302532c9d79f3ca830bebe371b84875a0632a50da2e864aa258f81a2aac5c76e51dadf0e5d9e450fd5768a2a826638e1361004989f193b6c7392cdf53a2b9a66b08929c55c3fc3b3115d35acf406dc336f6c5996bc4d550b2fc1ccc953e4579c8037fbeeeb87603397c03adec5013ccb33685f286a87618f66bb3e63b4a5162114737080e175e70d1a2c639be5c3b6185714f905b73b351b121f35ed9b054482df94fda74b0c60d8cd6731e8d5f97bec3c066856f1884f8cd914dc5f7528b7f5c20163c29d4bbf9a0aad13ef821b6829e87e3f4365877e0c41c2799a4cffd9d79c6e9f1bff15ec14ebf3df2dffa76cfd3be0c5b8804aed42162ac59eaa77badf2330f3f3b2e1e920fcc2d261543fcb9ab7898607928a8fecfba768519a5ca7449ba35eab642c94cc921d59382c0dd55d0e8abf53f89d6958692673ebc6819e17d5102a4cd290000e6bc4c445a0ffe978d6622d37a42705bfc850ca27ba8beaae28f98b5069618afbb813c84d841f2b526653ffa596600d1aa05c0f4507e00e9254b090a4c5999342d9f73a68e88dd4a9cebcb7d06b114e7710af91a53672acf66f39b88b295ca88203ab72adb23992611a4388c6f45b029821ab18edf85d4c40002f3fa8ba283ec0348e11029da880b0ebf0c10d278608a226086f04cad6f53bbecfca7b3eba0cd99a5707570cff18c19eadb04f1aaf1b9229e0ce0cea8f6ae92226250e5b42daa789dcb0576f498ccf33b362d773bc140d51955e125a14eeabb4224d81ea7839f1b6f0bc2534fea451be8c61031151f93733065a2135773e86d1e8dd730a8732c646ee98dd048742ddaabecbd82c9954efa47e6a28396466c29955ab54cc6800d3da3a92e93a1eaaeca79454e4847991f44d2a33733d8f7316c5786bad3836a74e861bcde209023442185eddaa7663eac5de3c46c9222f0b87b83189a72da15371c636900a8580c8d83cf188aedf5951567b34eef7326010638c6d77d30de09bea90d27265ac8427350e4bb2080316676b19bd9499ab9cb02cb910a7a2295212d5dda0dedc44f5c0e1ad70a9bf962899f42128ab980bcea5f98faf3964529cc39f85480608c14accf5130a4ef91a645b222237ba2ecf7e52dbd069d6aa641ad1114aa0948ce2c0579886c32118d98de6e556d9c1013845d4b4a2beca9aa3cc9536b195f52cac28d60130001e3c9476f6fcd8da03b5d8818871360e6ddb14f5893533125fd603131db49ad94b80eeebd45bc15c15ec7b9d9aa35e4fabcf6c80333afef0170592b8c94474c7337c2bfe9283c1f2c75818d42341a63cf3fa5b8c9460e584c6ef2f3792e87fed36100d05395d1a52f53cf85719760bb46ea8ee18e22d5a9d0ab9a38ed6114f0606c8db4ab1d99d82cbd5e1745396c04eb92b095536bcfeca82ef0e75f5a70b810d888292ed8484626643fb5dfabba25bbffdae771986ff0668cefc04557b119f42b8c74bd5dd2d6e2f5cd9818fde4de08078b0aa44594340b5a7222851d52d205168ac8fac3fe73fd19266b3d067a8a11404f8dfd624d3592e9e088c9b0c3796a2186c43adc02fd1a0f6eba11abb4593b2cc43e3bb6b1cc4f6fced53150120b7e6f6f6280d770ef7ae1c14e700fed5d7b43847bacdd300c55e7206f9f5ba55826fad3ac4895f1370d09230b8ab291110b73b0cc8fc49c66e1b70e6469107974a1fd778e4eb81eb909bf589b4a43080960e487e7a492770205abb8e488bf375bc7fd2d86d6172187e9d55b4896f6239b5aed4e8808a2e250f9d6474a50d1595beea4330f9f46199196841aae28ad0b55472d31e5efdadd2f44312bac196f5e60c9040d09557dcc704c75fceefd7b6bbf633ac9f4a834e9ca088a76e5a7659f48894f1b475e8f2ceb3ff18871c5831711d8fae4c2f92fcf6103ba8226915edb2c8f5bd9bfc138469fd190dcb4b28ea9c1cc8c66722d3f33e58138b75a93e803c15d65216189415290f168be8dc9fc671b962c3702b518203409a5473a0b3b69563f2f5d8d27fbb9fcf9180a3a89d999ebb5eb129a8ec8b491cd75ed8530f7e47f726b84c2966fd9ad0250ed52597b4f1dc1b029efc6971f48c8039262c54650d11153847027a078164442d55792accc019bd17c8bcb86d9c6e6033e60c3c874c8a3683893076db4aa746181b9b4b059976e2fe143c8e5ae102aa0b7d5d2ffe52a496435322d3ff29c654c2f7a9dc135c78a21471c95631e3b2e0ee912b893b1664dcda935f80ac7963ca83976fe54240d32242afe786893af10286b81ca7f7b31fcba777526fba12be143c5df53209a8848f06ed0d0497ebe9adb6b835014d1bdd881216e3fb5b2bc563fc46162aba150fecb73fbf1897abbf7b0ff4a26a52201ad5e9613c31551805adcfe5b1749e2a91109b13ab2b5602598d5cf1e0f06151e47be2fb63ef5acdfa409124ac1fb43298fd9afb275afbc3f5dba5a745011c6acadc7add4bc465803a8da1d1fd91d85bd74a73700a20922a4df7931642e239744a0f1b70499cc4075f5df6a5d7ee7a580a6fa4b32b9c05c5d90a2bfdf55dfbe0198b2ab7f6c667c4000a0fe05a1a5fa7624f3972ce2f89a398b659fe0f87a64635bf6b8d202352ea25f643356a6e7e4c757b11f91853743260f31dda3c572142472500afe18830b827ef54f977d95d6159a25af3bf48671489641749fe0541e0b55b95e9707f29d6c7e12a9792e0bd0f8a0c3bfaaec7fa18103569a79dc9e0be311089f7defcbbbbbba36d35ad73d8593c2b2c08f19a5169baccd1029ca69c0bdd323f7c8e38d15fc27d7b5907b308506b6e6745a1e36ee123d0137514f22894052ee44916bed23f4c42ab43da4892ed7ec9b3598e1e04ab15dda7fa3c7ac41132dcc3273fe0c6753e172c6f47d5fb9c6e0adb739528747d8c033f951e42dc8d064bf0f3228b0280dc984b1af2c7a896962612a01e2e930e01970fe371dbbe91dec4635f79d6b4a979e25ba97fa1cf978cfefc2d033e332e1f0e7abf22189326fc7a12ae4b4cc87b9ea189bce7db930bade1afdaf86cf0717c6b80bda140d6d445bc330375b18cdd3cc6f8b0c70bdbe298b3477aa7654b88d5425067ccd4e11bd4a2cf514e1c45f43fd63e8e2304ce4f51f7099fb108be7abde4d2d0c4e3936d32d594ce799f888a463925e237e909b2980de9a91007060761eb165507d38da495def357ce9b6618e589be6acb829f1973c3435003a404de02df36be800819da475c654b3456e87bbab181ba2b1d91eb4835b0f59a88251d664d49e4f765ecba7e0bff9f49d9fdfb1ed83decf791cb16e26775b1d4bf6bdbb36caaa43e5e87032ec07f88fafe106e3377d8322d0755f0833ac5347e2ab75aa345229bdffbc96c1402184f51407a81ce3c35221e8f1072ef619bf61799b9ea41d366f8dd7442a7d42a436b1add74c8f48428b4264c581ec5ee86956a58839c7a3a767d5b26b0bd2790345649c81ac6955f64e5e9084ba65f1816ce9d97cac1b0af578498be64930cd537fe1f916e84edd899b711d5f56fc3cca7bb5f80386be1364af4bec2c0e81126347e1f9f5459633dca1b20444ff2efce3ac8be43c41e5a25db01da16156d5c265faa716ef7dba09a8dcadff3d29cc46075dc6fb31d2f4cbfbe1e7a4988470d08963f07d8a7cf1b9da83a3e279623192174663dfad0c9236ba29eeed588dca36f924fa827bc3f73905ebabb55d92f3f424e1aabdfa0f41e9db5ed16172cb3b8e348f45c6b6d17a3f4a406f739f888979be2b4e5dc142d78ee6cbf7d5fbc24ce4a9acf7fa157c316e03cb32603b3b2b1d8f8a871767e96e45aa6b8c4d5cdb38804517c6615dd0aeea9b2a2fc38b63051b802bba372aaf94e37e2236231a586bd8eb27919c56d156444b8c9ddfafbe574b4fe4fdd8fa6ee53d938668235ae4e690eb9ef3c53bbd99fd0b375b46a1f2fea0464037ffe952b7412c060df1a6022c1c5e7d8728a15748326a4c91e3aad2c5e1073b2fb4cf723982b33d96be3a97282562e008734f023e5eb2c76b1007e0913b1c223fcc4bb9de35e9c54a8994ded3870d2636861c05fd4afe7e6e3d3f2ffc368e02b8e80e6455d976a9b965610fe916b757cbb69052da8519f364a74134195c0f7f2af25d35981e980a3fb50d1e0176c1743d6bb02cccd2ddf3c70d8183a07aeb647aafffa4ddd389be60deadbb00205dc0c9864118e418b2d618c957ff5c55937b784afb9ca689ebd098d21e7d6f3f4f578b8df71354c522f00095b4a4330757fc86b8fb88060ff1a70c5070248dcc2de1f0f75b8f2eb969f949acaae6d2b8ae42ca43b159c329207fb16ae553e5e76bc6b4c677f42ae421d17e41b9000af17120672533bf924c97f54810092fa0d1c7c2f3e4763145f7a27e091a19d2688643212f0a076e1457dcbb00dea8ac24765ba16b6ebf5b97e38ec6ce90801b139fed95f9ad17b3b81b4691040b42ec00b6a320094bc4ae7bfc57f27c6c56f99b51ac31ff851a1f0fd12460f11c249ede2a0155cb25aba2a2889063b941e0683913d015b1d8f94f7c79394ddbda791df0cc81d2db48fc4b5596423e5376ec2ca7c48c868231186ea0eeca28c395c4ca094de7322626cd424fb16056aacbc711b0db1ca1d66d7af9903d58418977e4ba8e0f0b2efdb351475369ceae5c838d2c8db1aa71bc2f43ee3d034e6ccdd80df4d78612378931f118f2af98f28efddc0f0d75e46052bfbf27021294952f14756c4fa41f8b1fe3e50fd8563dcf2f0c559b769d3ebdecb6a8cfdc53546dd2f3fd433f21c4db648ba022aaa66d3992864e642251ca3b2574d3d5651f6bbc3a393c5655c05973229aefd2b2dc09d849f44cb02f030bf3e325bdb5b0d5ae20eac8d9473348829dccbd1eb31b1be974130e9d3496b89decddfaed644d8c374bfbdd03a9fbcd51c415ab32790b6f4c602964c12a1b907b318df08e097c2aa84cfb92fb2a4f37228e4b4333ecbedb68b854a3265e905a157417240fa40ed85b53b0362cd7a076bc49a6143cf64a7808960a9a0a55c3d7ef12b0f9ee57618af18eed860dcfe8a82a9a1b9419cc5e856ff19e4705040cc9ff4eea5c69931603415ce3f77ef6e5a82f8796f6301f839d88ec18c600c8e5e7ac5b043cd6e74d43ff5e8e439f9c72e2349afcf765352fba81793c12a9d821786eb5f01e7882fa4fa188356c7b321c501745d65334e015ee858c2f54e736931a358ea649455dafc5d4d5683e5f69cafef30662ea9a1b743ddf0df95d8e7076dadb149765e64e3f084669de2b0279eb6ad7fe420d12a840350c2c96d58bf3ecd894cdd57b62e6230782d602ccb705fd4baa0ed32e9b01278d6a68963a0b215e1cc549ca9b6283e09c7f4532f030d696779323f88d27d64a9c9949b22bca7becac0eda2ddcd00beb60afaf76f5c69d9ff9fd4685443f9dae64ed9d5c6a18184af98649f2cabe8151294465b9080236a824a272f15b2f343af540ffc9f574d333e68eb511200887f4702246d420b1a5b51773e862897cc705fb777adddcc824fbe0358bddc95b40d55f5a4716fb9196f1e3c1f8c988369d0d9cb34060aeb833ebecd2e02c35f835f35470a8321f7d41c16e2f5b9b5ca0e5be70670140ad3f8cef99dcdc3fda05be480bb61f8295d9427cc6276974a0bfe100788cdabd241a73c4f6772297e9f69d515d498713af64801a4a3a79ea10f414c02b26377b49212205d825af623199789a7298c264b0998d2452af72d12d26acf52f64cf00ef47f7ece8c82a12ca53e7f2363fa4448f1c73728372b324fd26267e5c34c80fb43b942f16b7efef97d9cc7ca580991e46aecdbe12368b9657e1ed34fc3ce4a57bfce06814edadc18829d49eaa232616a29c0dbf66ca8098c784b81444f69c48aa64d776d83ab254a3957746495854968cb0a0910e261b3f3f4321d0ace41553ab2b1ce2148e9eff1afa25ade4b9380d69b55ad8723a54593bed60bcccdfca85f68166f36f3dc2e646ca138e27162de69f93e56452942e0030cec1c6507bedbf10a1638983315212a3d21e8d90e2ffd008f28e0d7b9f97cd5f75809059e349b2659379e0a8158e36c11ca66884166d2d991268c8e5f84ffb8fb243b2d9e36d486ee04e7968f30d96c715111d49fb15a10e125979194c38d8dde1d82c2c3b4887f2cc4f36b331b3a2bdedca0bbfa0dc43f423ee202d7707f25a6e542206fbb2f714dd81b1c375eccffe22fb6e7b12fad3ee9a94db9ce0561d06ffcd25c3c73b5c4f5db6ee96ddce1d0b2635700a6e32ffaf0c5a26202a58a12d1bd0b8b4face561a21bf9797dee9db1eb3828cce5e71f4f007b09d35814e13fae2cafe3ae0ba06439ef0d14085a8b9dfabf95f1c1fa3e808bff9bb6827bf5a40ce99a132953cf259e396e3cdca6568f08c51dac61b43103e39ebcb8cacf032a15eb36835180bdc389ad2309e9d3f42fd33edafc2235ec1bb0cddb2e3634ea3191240ec3e897e8c63a48c7dca906967659d8e06205eb15622bd30d4de3731f47dd658182e3f3b2ef1987863670155fdd6382b75650cbd6aec124df08e6b39d7f5c08191405434f032c806146e48476a732c37b03fdc35c086706983b2aaf2a5f789448a456e0ffe568cd44b5ff09a9be6cb5df10a00b1e2835da5ab62d841aadd2fbeb89d061aa576ec9764322c99f81d81f03befed9352bec809ea2bbd62f50577c7247413e7ead6b78eeb4b3ec020e4c12e5d7e53f2d4642b19fbe023a0d4f8c022dd48f3853900ab895e6f7b79fdcd76c909e69c5309da21de19e51cf54493a750f5e85a56bdf5c61ead74883356fa28854ef50ddea6a8ae8fddaf78ea88ddbba9459ca46c23196797fd513d8f2de0778d5054c892fd489a8c0bc1c571302e6d5c8413b09724a84ba463160ca9892b3661db8b9cb3556fe112841fa52c2eae63334a26bac9c7dfedd99fc13c96cc77198abf0a8e8cdd88886abe9649bece9648a4868e4f154089dfeb5c58afdec6b8f9c722aa69cccd82e09dff17060c41560e87bb349458de58eff3bcc87407c48f68c3a1dfced3541f7866dc10f1983ad439a28d35cf86bd83d912ddba31e93375f95892ba13ba7f21f043504750852167309f180c7bcf13517324352c5324424200b2d80fcbec8995a053f87a96528e9613b50857457f5899a1fa1e8305b02440fed05098405e1de6b1f18f3aa06b767c093b50d44dce5e39274d9a8f4622584f028ab262108c95819873e8085d87c641837acdde9ba8522bfd348c8d4fe473be2fff65b22c4826686704306ce69f351e9ea21617e4e48c0740b630e92285b14a36bcf6430b9b284aae99ed2d5df58cdb5f70aa499a433ebcb7de0e2c3411e19f6f02c599ace8825372cda52412b96d7a70c1fd71b266cea1ef587e47c279e4ffada04960f79d7ffdc5c9dd5d5d7196b79e704a5c66ef7634218ee153887e74a5b0d0279bf2eca0db9e833a2a0b363205629e1fa83322556ad3e91fdef23143345f0be57b31c50a84224734ace2837e57e03e84304e811e1f17f5f85910376d1424cc5cb587799f604a97cedd13d4cb8609073f0fad14e5a83146e4d268d6662e59145437633654ab0ee1d7f0b5bd9e79c1cb857c1ebaf329980cad5d1887c6eb26e3586ebceb7382292c3d71aad73b13dec93a9de43d9477b129140b4010d9c9e39b646b81736faa02a7c0dc5a11e1c3be26588c3611a8249c1d511f63e666d93d170ecf10522bf9477cf636f74e611de23c2d81cb0e1b574eb35d1fbd6b32273def3ea1cbd7792842389f9d2da057ed519830ca118b4b3c69f2c02c353cafa7c1f12b54ab13284c9ef54f4a2dc82e8f43e1919276d8f21e5e0eab49dabc65c2376959da1f594f6154a2155e59f1fad0a6e8a31ca4b24c5a370140f0c02d13943d70c92c146afd498fa98d1be937379bc17980337723770ca7b7f2315ca2e97f16ce56890ba37a3052488f12773090f1ab71343c78999cdd49239f7a8d9aa6e73a6af88d04cdeac6399b65068d27ec129c6674a6eb237bae4a0dedfa7ca65d7ba1284708ae4dbc66296d3da06578cc53e86f0b36fc0a75402b444d485a91a5ccd970bbaf3612aef020e63842109af16ab2edfd6aad36bf172b6ff7fc621edbd52dce3c90677b7e1c5446db0bbc9acc48d1ff0e3a4f2b0b012418d2bdfa5f99b379c11e472af050b275f01e415dc8a04c726783a8eac1649febbd1365ca77c599ca97262bb3b1c0eb20a633dd23db0e41946fa3bb660a6b62e40ceecdf9b2f62b8135a2db25bd8dcae84a1fc24892402e1d1a125b6c7582b08f3a6cb15326b24af369ffbb15f21618d93d71028a0e538a2267e598fd5f3d9272600a1740ba8e1bb372f091a30d9d6dec402216c1e452d842895ea68989467951a0af0e683fd29a6298a82d0f4c98d08e609255c92c61d87216276ba9f5baf920d769d22c0bd0017dd618c5994fc39ec0f363e003b354a53fbb05adefd6bbfbdb0907b5f082847f61463d6238e4e7958cdcb13d202ed326347388c9e440f5ee6a6719c06bd9caf4baef4c73e0606bfc80e7396155ade7bbc704ded6b211bffb955acdf77e5d89d6ad4cd3dc82cff5cd21f138643974091371052883a3f5231598a8aa67308d213c993cb588938dbb8b9b0b5b61600f99b589c12fb087e830403bc7c9eeb30d5a4d38c1f5958be998c1d5f594e3538ca725cbcf9f5e58196906eb7bbcb7be7e84e1a2347a3d1e9cd720c4b7f12d7567fa8e2bc794e1097c0b9af7bda1d54f90a29a8e9a4e4bca6f3fd0593bba005a0f29bf4f31d2f024e6d1ee35af1da971b2b9c60f42c401015159d34374f40465afebeadd86a57fc8af872c5bc4608be4ede44d49db2779d2df2d7ceafdf79dfde35687a3b36376f17044be673121520e4d1351ff6107e55ccfc90d33a4d439c860d37515b747d39e0ba45e86494c843efc87e32c061b875ffdec291d32d7b0270808bb88d33c6f4f146f85abf4e68fd250f790e5f8bfdcb78288eca440c908db73d57d6f47834ea1ff0dc10e5d7034b1e05b250a926e6fd96c73363a35c65d1d7ec000a96e027c3f3177cf1ea9b056bc7f76d55e14554dc82f4d5a53827284cb68cc688eec0acbed7218a5a41e6b91228afa6d97e23cb2da12ff01affe85d7fb1d8909686f19dbb9fee0bf32428f8a58cb7a074aad5a533a70f951aecc7d419af629dac214b48bea1b833357bab20bc939b9d288689a0ec67428d998a578f18c8d867cdd2c03aeee41dad771308361a604b72a5e0def260104ee472f5c8350c602375375a222224587c6556751215fe26174fd964251b7bc3c809cab137119c56366f7edcbf84152a8e5f2a8dcb67f813393887398d0e503d9e06e98a5555780824c5166c3c80fbfca1bc1087f6975cd9e5ea0b5b86d2db4dc268c7b8c302f63e6ba182bb06759cded5a98f70708124335b7c81ba5edbf939676dc54f5715de5e9c41c0a5cf1675612863ab14974f4c196db84fb1f5380a02a859b1c019c1572f32c8f8ce4efa10e55f735e90332079724addf5bdc406fea10d4c25530857b722cb8b70c5ba1c9f2c58aa739df81b3024966082180a113868831dd648c0e8501c29385f88aae1430ab9c2b9cd68a601b4c161dd24a396eed97b07fc612c5290f39be902f88303c0475d8fa330187a74187bdbb11401a3d64ab73db07afec9050f3e24b3c5146226a2ce7b3c4ef017bbc32434c9543b3be28e5439267be1dd01d6fd6b88b062b7f7a812cad48617656e65131f48c515577ea72bff0863c8503f27d193bcb777aac8f420e071a9a038dc6323148eed682ec6a870f674c022d9c2e8ba4fbb12e0c13e7978c5635fa417f771db227fea7f1d35d8e07d2c44017713def7d86230afb4dea45671d854badda46c86a2ae81389684add0992ff5839081fc6938d5edab93dd4fde35195d6459f019126e35eac54bf318bb6df892cc538f1677fa0e7f1a490f4ca4c3f1fac679e08860fafd08ca75fc5dc47c695dc415b644d92049ee78a8d3aacba3f18a7d21efc9ec55d308da59137ac17a29623daea7393de0e63eb4ab612f76ac87f9b1480356b12abc306fba942db50ac023d1c45a80e2bebf9f24f6f265698b23cb51c2eb0b43925d7e96727047e33cb1d6fcb2e0dfe16154bf245e69fcaa4331f24f2bf0bc75840f9ce696201237b1ded0508fcbe71e79cb1544e798fb4165cc120d9f274cda6720fc425abfdf4e75cb544cae26c97221db75405fbf24cf8c4a9f531bb1d5a85dcf2ba547bb94bb5d6cb3b9a0851b7b5ea5a70ddde5e8b9e4e4c029f2c44b2f5b963d508343e0e77ddb50d351962551d01cb91a729347f619499ab4933b81281bcafb468628227d4a44b357d4b3f9d255560e53f5d708ddc73fdb2753e12b7fb7b74b365d370166d3dfc24f2261daf7ccab5c960c13bdd0117fa56d2e6cfe130cef5a0e77199ac82afbe6375c4c89d51a125f76e898bd3ea07088adc500a599f493f54189462f9bdeb0f8867b1544b3902390bd27c533dc72175ca26beb8b9d55ea12934d12d5b787dbb08bf72844fed45096c601b85fec7506f889df60a8a20953dd56bfb6af539055053e90da6d4b2987049d59a0c4cb0523e6f3323e4182bc9c9a936a5deb7e5be79daf4734a4e463006bb22bea1f673ccaae6a98ab4fa50bad9b981d473baa834c9dabd88bf373e33014255a176bbd4f1de6517aa6241959b02065f05f2408c025ec398a4a961f57a0071580a3d5cb4878ff9092afd575f62630afc94de744b14a9a6dea48e2bcdfca5e6aafe6b47d5d0041d244b510051bc20903fc58cf5f2ecc586527d12f1d85b78ae225b805c043353df32097fa779a0dc3469af2a867276dfae9f5b04fcf681a1286db4883f44c1caee5b3d3fa0af47fe4c1bf4e1b5ea1ddd6af10f506fdb90fc2ee34e3b99e2c1a2cc1f25a3da209fd41d04063b1e383cc49f341e3eb4d2daec2a3000540f68431404d87f8cc1eedc14712839606b38dbce7268ce97188151ad270ab7998b5800ba6ca6e116345d2947159c20bdded2cf2d1374d34e946627d2b53458744d1bffeb2beba52b43d09c0ebe4be6d4846710ba8a78cae3588b84970de2aa2d566814482c063b6c4f15c61b37642663ad9aed0d6c2ee106a6292605e8960c08fecfaf9e809b5c35948d11fd972a4ef58a4edf95305020c3617967e91a0127bc425c23a31370fc523d495955bd660741d33e954927d52eb861dc2253cbda6fbbea1e5cdf74ab91e036d0f2fc07aec590831e9532c61658705acf99d683b0d62fc9ded5ea83e717d29bf589a8cd89f80cbd64cc54debccc2a7bd6ed33196fa736020f563f9cdefb6024dc9218e99aa17366f4502092222fc337d8e55de9b53b901e1e90588bace9d8d38263e09e09d1b3953c883178e5ec178fd188d9b9778ce1c752607ea89c4689afedd8527b20a90aaa1da4732c420038a337533742548f177d38a75d8a477645084a7ba983af8519b122ee51b8235c5c8821a0b402d2d4da90409fe920c13cb85f5c021b9384a77281ad5e2524171f5ad24a01c0ad08b78b73cceb4e6bab67722023af3a12b61aac5ef922400030f5d7a81e30b05ce007ded7b2b7c52a3b4368ae245ff8c9b3f8a5f5a0fef202f972bdca924842b3bb168f04a9b26635e73581314386e1ae41974b8424d273946ba064a0d9c4f120ba0754eca4274b83341f80241dbc13c0b5962f4f9e50c4a31c7777ff10b0cc408c27ed2694dec0cf60c3a819bad4f1fd6226ccb85b49bd89ec5bf5f731960212b47cc80684fb31e0d352cdbf63004902c952407123c9aeaa0cd052635230e25da9448ceb854b611f86cda100307a1f963cd6ce4449391e5f3601a2e192f04930a2da99d5005d3b1347f6ec9610cc1d1575fa26a30bbceb5eb0e92b524e6a28a4a47f6ed95681e245e134a52d3d3bd90e564630ec70e6ded3acd20a1b7cff9e2b56385538a46a09869b3c17b5ce167f20b4c286c77149ea777fc3503029d48749f0ea5bda5bae95beb5d771f2ecf1a024572bdf155cc767cd10d20c8d5c603baa82bdf12d78d3a2d6493346c48a8c24b230bc27b8852352eedde4ff8cda7676eadc4845672e8783627df87f215082f354858775b3968198fd2e3a58dd63f0e8e6a91a3a06447484e960c30ca1770cf312030e47927245909c30d8c598fb42997648ee1fa9580647fa86ae7079f906ea0ad2c0aafff04028efee56f9d6f39b87e12389d3dcb7cbac4acf34bc744db351b22663fbb3d930800068a8d6e535fd39161ce5751ad9d0dd783a7eaa369f419cd80d0b766a46059f4fddcb5788a74ca7fec067f45357ac3be96a37415cebdead9b2f99c201f7ac04834484941244b10e01108f1b1d2e0a0e7a7b00ec6ba97dd24335df83c4aaf769cca3ef3e8623d4419f81537138409c47294f17471290b95ff1454caa28ca8c7016f444f44132b6409f773ef8cde597184c1357393d0341893b17c35d2b9f8c7e8884b0f63e54dd006fbd4641ccce5676cd899914b2d489efbfab42a8865b7540656d9d8f50804724eaea0503a0603e1925c86f468295bc24b1e82a395a479a88d80a7b2b2fdfab50173883ce6a89eb7c4e41700f9f7929dbcb41d0abb14c659310ab93a83a2cfe627fd68e2a1acd4f63c95d8bc5a866bd3b8823f5e991747d63d2e38f6005ad78291807786d19e3faa892d34ae574c4e90defcc694f990d9cdd4aa76b4b4883fc3c3764eb9634e40dbcaeecf67f536ff09bc84b6db467e4d4f19461b51e58ec8024b910fa7395c205adf619c32f1adf53699d18995a1fa9b8690deae8fa962d4f12ddba8e60c2305c2e78f8f59edcb548fc82a9e886a39d0304efe84b48aa3d3b07458a319c7faf7147cab7750f658156aaba8eb6ca6d9777976a8d34f56dd89e508aa9df4a2c0bd508db735d2834d5dad8b4db479230821dc09e755ad34561151b91b7e3e67f8d97392a3a55c700aeb9f24dbd3c949042a5e4f0f0afe91bdcaeee795846c0a7dfd669871a77d27f7e524230eba5d3b7cecee86729167113256ac101445204d0057212ab010d97dadd99eee570ee704de029b474c53e6e7718d189549e59cd24cbb459c53f88decf825e9eb5eb81e1fb4f257a7d24b487d5e4a6acfdf3cf836e650ace4bb906d0f6d240239ab7571aad031279c8358401a50c896105754b67c5a916ea8f5f8a55127022f6ff9c8145c8bdbc7ecf275ac2892c15ebf63f20092bf0cee4564378a46614b183f765f1b5fca2b04dc9458755c0fe99fe2d4e50526ba5006d2e0acef7a524eed7a5ea8657190e93bc215086ba9387720bb2193d7b040f3d34b5968a9e4b3ef74c9c2f9db19818e0d0ede70e3317d3a47de8189631a8e9708ca599a741410216c242a2091be898e4a7b537961543a45a4f7d9e6e85a3376ae100a06de1d1e851253f8d7a1c42a1f00e8eefb3533c59be864859e96e75854b1a08501f56bc7e78fe7eae0a188e1c4aef90cbd7b854e7194ee80ef79037496daff38a6307caea7298d0c986a1e4c5fed121a22a5f016f7c35114f625a71f34b8a2240f487cf6bb4d8a2b56c9b1698789fd8882c8ca87ddc77166dae1efe824c77da42d582c8de39a98d89975453f72182a46f8eece29e5fe9df7deac0ee655b6770058b582aaa1b8771593f43f8de253049dd7a2c48dd0edb3f9f9bbc80071c81b889bb4533d51e8cb0dc28415331352a24582b14088fc58e8f3f6b878001470546f679d6a4389ae60649b520c3b319da36758653a01e48ae31b987df0404139f393e48d733e3970718df23d94b47d7e3f771de2f5b4e91c8529b9e3e3f2803265e3dd9a6bf637437c8e7eaaf0009f38c782b304801da0658ab6bf817e2559e83dc3fc322cafa24298da3a46c7d27bfaf89255cec91117c75a5fb940996ed1c491b22994b101a20040e6a15f4fa434586b45b356d964bdef547992f151a854bcc9a35b0dc8f260c0931b06c064b2d9c58693408254b61d93470b252c0b377c0fd1b33bd2f1c3778b37acf001114bb8b6c2891f3eb95481077d7eb526be6bda4ac2f4fce5ef3a9b2ba13df34970b8cb3a29fdd3d8c99e46642f0878f2103b6d662f5d4d05926f251c99eac6ae710eb0f5466ab9bd36247551ee1b1660b4b9cfeeeddde144470b1ddaf45fae679294ca8584a7bd8aa39623e11c8b7098bdd288839ef7ae367062dde49b1de11987e6dfa94c5aab4bf3238bff54b5dedf98985788067787eb2df8f43cd69ad1756337584c16c5466f01f2fdb3a5e022b80292d884a6fce0aa3bfe4035cd3c785c4b71d0802e2f0e3bb081265f8f422d8f8f1b3ea071437a1211e8b7c5d000751e18156ff622e7e6ed1b653731525b09f3151d7357e2071f4ab1949f88f13524a8cc5b7604d704cd0b6e5ae4463b7c04c6b6f76325fb29b84081512c7a806761be3b775b08a1c50f9a292a7cf9a988c2b2b03bbbc475ab170acf8cc0e7e6153bd731cdd39ccd5b25461fe1653e1e97712562cea4f44dfb069660112d05035df7cccf714144c89162a983ce427e7439346f0361660018f423d7beb203c9df53ac14b8d6fbf0f604ad6084dab93ee9f2399c3964c8d826327b18d42f02b6c438910f274c7a1a45a1763e5f1d6a382fa319e0b48f5cef9a414e15a025342e7c86d3188829d0f2b25480ef465fdbe630849b6e2b0ce27c04ad90b5c8d3eb73936832d0a6dea43d741a758a6bf84895b8064085b1cc7c5da57c7825e97451360a1cced41d535cc78b0d618c99e2906852e5cdaa5e3491b44707ebc55d4c277898f02ab7c49d69bbe9039c2e9cde8518a5ad484c3a20a7b3ff7e90ce862329fd77ade8125e6405a098f203bd3fca8c40b03bf8cc9d7858ae2c64ae14680fc875fbe65e2e677e514245517333fae11ae9d9d47501d275f987499585a666d484e668f758092e2f8c9d16ab8f88917991094920cbe6fe63beae203fb7dce24b0c250c6c1bb3e2132a644e1538b5865e257906b66b770117cfb2d3208fecaa2089daf34b57ac286379641238e651f93cc794e199291e6f2361d96d160205047180daab6514be52ae0fb3d1f22818c025ac62ca0972f2e6867c576d1c34194a2372035350db7a795cbdb1fb905d936f044f9dfb0f8b0c9077a90f9caa9d140520d1e16b3e4ff7a0cadc3704080c18a601067765a98881c0c3c7c43dd45a218762d8e7680729999b11400c2a3206bfd36ed41b087d312a85a697cf7979da3487dd8f9bb14bd7505632e643076066cd6fe246544ecd8da5072a711a69a93a7eab2a3010217a122cbddf52898d73da9b4235535b8e83a329db4d26fcc4a0ee79a53aea7857fed2a21d6ffde73a051cb6521cbcf8ef942aed07fedb8872734faa40b1ec67f083645a6cc7989eb1e81367d203a75bb994ccb13c5d80a623e75498c50fc310170f0d9c2a9efbca94924db12549de4bcb40cda7c986d8819afea0469fc560a671012e7de44c31b826ab5c9cf7813ec013ca9d332a5353b091afc40cec54c7e987a0a026f58547e09bd854a3f1fc288a0c9a55c9955159b3cf49ec3dde8064335282fb2f4118b04ba124dcd897119e45df2d596ececf3b8e6084a8c07fee9d42d1fd3158daa8b3473827af87915582f90ef24611e6ab708fe3db820c2ecb08b39ea23067aaa9347132dcd60aed6694da23e31b169806c24a6bd8eb2ecfd5b1b770a7ec7d49b7515d2b7ea2208d783170a3fb55fcdd31da8e36098e24f0485b952105eae6dd8185a4c1598de2fb5c429fc248c604a7234d98123a23f1aa4cffa499210fd49d342535ede5dc3bf8a5da21d40172bdcb0b72e50ff6628ef565aaa95ac8f900d8e97a26d0a8ac3bab1e8e11d4821d90adb138a2bd99b644a2e4b8ee35f51a69f26222c6702ec1246b861aa8c6c55a0fce5eeeba1c935fd2cbfbfee3910e72383aeb829e06f7920a19667e3cf7bb60136300591c85df87fa4247eb60774de538edd20ee2ae30fdc7a64db42c14e02c0205dd72fdf2ed245619aaf0a2b7052d76727d76bd6eecb1823fe497a779f38f56c14cd7809e8df301b5eefa6a134bf98050c72fdefb255fe17ec2e4d95390e3e52a49899eeaa9f6c04740a34e4f48664f691837fe158d72302d590ba1cf57d82af81b8f2e79ab808ab949dd9b557e9b867d411185cfad4cf8e8c52310b1dd8bc1c6e29894567e2395f41d5e740acb15b94e60341935ed197d8d64f47d808707eece32fe469159e4676925a4786b1cd4de2fa9fb9f97ff104a8bc92f130807b42a90b6d999be4d6765f67251af241793d84335c27a46e92c338d2f92678146ade1080ac775283fa870d0221b9af6eb97480ebb1b97e4a0907fabe14273c7e51fafd2f591bea54dfdd98f7fe1b91b074fccb059b29ce7233ddfa6117d4b9d611a5a00584e708dd10730c92f5453d403eedafe0db0d435239fa99ac65c615a03bc03c4354422a65d852136df4c139fa4f78fd68e75c60f23478bc5825a1ebe6964ab45bc26abbf77f2e88384fae28e39bc2238d5a66882f445c385cfedd1d7a58f7aec1bc3be51454badd94f024926c59522994550a3b7abfde22b8bc212b70d691e8e20281c671dd5d62eb6673fe351b56a24966f98db2dcc014697a67941dbc0c2e1a42cad86077fb49b8404d784292988611312954c1aa7e369435456602ddd482bb361b0c42772dfac5d170e5445d82266360836fc68267ddaabae8e27c86ca74b42d4715699ab89ff6699b97127d5227b3ae920d80ee3b963712cb7fd28de12fa2e74636c945d345cadc22fc1e28ba57b5a5f72bc94c85123452444d7d27365e15763dcc6661649b58fbbb5c4c8e0b2ed6347f1a1757df289f0d5c6e413ef5af2d4ea95417ee372cf078623551130ca292f6d830019dd85acdc4cb2efe076df55be1ca63dd61d0de337e6cf8483f1205309af4b048d0bc9ef179472ef7c99f8de6c995e23a74b78de243c35e0da3aed0f211aba309cc13d50e735c36373512282549d6968c3009f4a8770126cb2fe64382e3a1fe0c8e91a6e38b189fd57e6fd50f4f1ea57468321d0fb5ce98968f084e2eb88332308c7420c0963a2ae411d00dd0efb3f4b9dafd9b3092aead1ed1de6108525eb86123192baf486966225b53cbb214b97751b2488dcdd412ed01cba74333c7b97e49e6c209d82183b92b06bb63839965db3ec9d927f41bd750f5c82af00fd9adefd4910718b8f0f969d12c55621f85be691d7000874378f1b34246a5f2a395cebe520460ef35bd728b14209a5d68a1d69a55d5e84664c39af14c10b62b33ad880492a8cbbb2d5f29ac3c2e493d30c4152c86b8225b7b78a567f693a71de355503b9a54d2bc8f6eb5bcc23b9810743796aac0a32126ca71d3ed31fb9ed670f0a38ccacc04fde8b648c321e028439691e09afd895bc938ef068d2bb38518477b35346958062c4e05bb0f8429ed5707b57a974b06dfd32c73cc5946facab3923989725eda7caa0b55ffa6fe25772e5c56ee987d2d2b2c02afa916c1c5a134e3973ff990e205025c8e5e2c78a0a42156ce780b6c023f527acaf228f00e2d05cc399162b2343b42c4c3b51fec41b0e6f7c0214dc154141ddfcecf574b4d5c98c5589b2b949e7df6096a2eec3160c7afcb1ec40c7cd86957e22b12adc3dfdf3a3079d0b3cc1ee6d12195298edcaf895520a04a703184266e526faf660d06f580c77326a337959811121dd55a5b6502e6775c1cfe8bce5f54f12298487ea3b49b2ea0164299610745b341067543ab1d4a0cc6364fd07f7fc9d09e66db7ac278c68b3ecb8bf9ca4036383dd5292a20e0058a02615a0ed0a192bebfa3b03470c6e4d0b7f979432dbd7f7f7f5aa85b57afa7f6b4e1f9081c967aaad4894a250751af3d6a29910389f0fa38d18ed8702c1fe4b0b25c94ec52abe3ac86a0f98f1185f0f56ef021c709f7c0a94bdbfb1b91ac285709b1a431ffa178a092742194206b677d50c63814b1dbb549110a8203fed81672c02bfa2b71d66a8b1ce21b60f3fe20519832ad502be851c3c6acde1337fcb946e01ba1778790db00076e823641c5a289d5994176685c789801ee105550b2f5088b4b6a0f7306e698b53407aad4ad8e23d9ea1f473e31d350840471f8d7bbadfdff23c6940a43a123c1cb13b0a1d621ea0302e0d2de557792d41faaa7c09fbc9afa9a36f700cd8d63b9e1c73e228a419711ceada7d1538a3b96f1145c5aa102b6f87fb22a4688cbb4e8568182287bca7841de728fa5ffa41748d8c3eec7b78e8ac7b3ef3c2dc20917bcb6d75b44e6d59c9d2671284bbb1d04a9c49b75e29346bd8f9cec4ffad3e74383a52d9d1e9111899220875a521fb3ccd4e31326437a3b196b7a2df0fc3d02fe6d922f085d43e0cfa3b0379a326eff1dc0cc8b71b11c2da40d8ac2ced326f2ad772752f972b3dc3204e91a3f1f11c1169c79e02f19f53677667000a1279f6a9a496e8022f532ced67af97ebc3dafdda62b1392dad4b33f7e5264f83cbeb5cf6d018dd356e66328431fc4535ad4b64762ca47e8636371740ac14c46a26eb8d0159ce157d31d44017730eb7049dc24f6a62e1f012d68ab337fdeeef88587ca1f8e87816ba4a961fb6a2fc6c1b6012064f87ee5a9e17c025b7e0ad100caf2c5f94f4b794493f25692ab959d2cacca53241d607b98e1a00e698a9a67ad243bd33a901118cc4f1c25b315df2f0e445e2527d7ab89610ef32d40d7f57b69f09f1b4c653ae671383c57342fca601f69432f856e15f9b5e8f52b4018247d462c5c1692ce0ffa2b331d967b19376e3a3ccc20f0e6359a6b09a2975a6f0414e2813982fd9861cd2f3ccfc454929a2775350784e7757f88be24cdc9e380df7c495041844aef648a91acc97f522a7d89a82ba70786ecdd57d1a0c8fff0ef4c7c4cbc1a3a619d486dd619a5f49c35d327bbf29a848f22d5fc2f4d671ee136f4af499216e96e603b5d6f5b7d235ddefc777cae95df8a938c7744c2772e7ef10085e7eb9394ea7558c0558729870fb9f5f8537485a636be4e0aee4e9ad866a92cb3a718ce0bbc970d7eb43fb66a2bca69c2c7472775d4060dce653ad08fdc359112796ee175d75da4e7d0757d427d580f09d6c060a88e6a0e8cae79d6c8c5f195e5a4a7ac0471766f0d18d8cff41d2db3d68ec03b827d81c439d8f2f5213f678701777d4f0d115a090bcbf7ef3a0956af7337a03a5d25bbea1249b1222dfa2b6a924514b84c0c077463a71b019ebb6f0cda456cb65330085ef37879b68c55fd5219e0fc6c2bb03639f34a311f4e49ae6e191d9eb9591448bf6a78b6b8559a36670eb355298ca3984f337fd83e66a5c4c487548e830d7474693f6b02e075212575e61fe895d13eaf0da2a7b74818254f863f34cbfe3e235022da773ef5f7661d3b3a6ec60fc008151c243c09a0f66a9f2b5df458057116d24fcc791c36b10be9509afd9e4ed80e7b92b8e9d53af2a0287476f2f94dfa8985f66bb73748136ca9dbb9299569c051e2bd979af0019bc57097b7a909a37e8a579725ec61502995717c1837042213fdabea62b29ef5d1694a0157be03a3e48104a5008fc913b95ad940b639ede2934495b3930fc213edfa0b785f93ee188f099444a77ae696d20354583e539a9d063fb2cf66e4c2206aeb9b4079a264b2b02a1667d7765a8da945f9c615c66a1dc00f0c8c0f29c12487754cc8a5c136c8abd58476aadddd25a365a2c9340af69b1e7e3404574a66701f6059d8c5400d7912281d3bac2d352aa8429816ffb1249e017bb40bf6e521e7b21e8feb1865c0f736e3f55ebb6bd295ec3af7878cd6946b8fb79aa718bab328ff27680041308d492ff1f5b579a708d6b764fef9f7749e3c42861365f2fb39e1a17ab8015c81c1eecdac80718d804ee108670957bf33ce0f24d19a4bd9727c17cf28126fc545ee6215c53f8dba5c2e07968c5571e1360482f681a438e40e7078660fa9927f98226b32a049acd9f35caf6804f862a1b0845ef17ae3837369d315f1f5f131d7cd9c6f35a200bbc17e44715d6d09fb943a41cf8bb039dc42e2d6998d5d5e63c39d5aac5bb93430ec9de7cbbf9edf13ffd3cf2b36b8a2585d5bb189218fca3f3cd37cebaa04254f2d7da5bbba7e8732ead8f2cdfb2d93cd50f4ea1bfde81917a2b0af13f43db23af25eb08519514b3d97276a9b97fe554689e378ea49adab47eb323b467a7d022337d7729123846c4f4e4e9ff2ac7f99abd1dfb950dcd3eea94047322fec0325137fde86965c8879c66cde1b84d2455672be2abe8909f6156227b3747de8d41af5fdb96c7826de52efee3a17d0f8e4e67b5936c44062e2d527cb68feb738e5983b35846528dee2138c4a5e0209bcf1a500d0e37ccc7fc0c8b0743b7e0b1446a1f6208d810f4c665984b76cedb1f1986a2c5456702ae96d64e800429d10d317caf59e7702e26f86c3952a808be03816b6052c155c02d7111360bfc8116511ad38108e83487beb004d73975131d2d304898f872a82e1b64de45934031e5a3b869b05b961dc1816aca7d31b30dec997400b13f0da47daaddca9d8a089a0ee573547da01964c15dc9adc57ff1082d30a4107892fab2cb835d79bf6c153ae497d93ef9bd5059f3fc9a5205ffacc9c184355d8ab7a8e387dbb91f288b194f7027aea84a2366a3560e2804af88f6f61bab14dd65d44325e6f365dc8b4d689deefa00b7c6cc76681aeebe4ce9295e2a915eff54bcc6dcfd580253fb419bd04bb7161ca13e1152d81310501218f5c8fb85f41ea20d402d4cd0007c75b5b1c6517a7ad79b9a45da7a40af766df681ebfdd32cee3fad0addebcb313d497d625c5c8c80a6bc51ca742b73e02bfeb629ba1e342496c32b3d3ede58d570043bfa11d3c5832b5db3ee7a043f8f96fd67e22b9b9154aabc5ae6cbd795a189dbb6dc4f6648db368ef81fe1abea406a427fefb4ce646c0b903c72668259fe1f81c3f4cf38082ebcbb0d7974dfb806a21133c304bbbc8728a46bd3405dd3122be0e3ca23408e75c8a5c6858863a373848cb456f4439a3a0aa6f7a87db26de090f5d994ac905c4055a2d329af9a361b0fd4565f7668da4b37e3690280630f1d804d56dba774bc18c2f5d51795578cca245744ddd5884e547d4686a1b133f3887e23765967a53bda19eeb6020aab70f1372e92b5467e0bc9ba51ff61131d56cd3123751aff9ae736b11e8260dda7f3a81d45652d9e4c708d66ab54c0d8a4d18029d002146e7b716d70d4b66b548bdc76e72c5775669bb878d677c5ef521997071d275280a095db13440ef68768c41c0d333a1d7e720a2110bff901ae0e6f85aa29d9e5580a339159f06cb92cbc079d48ba41a9d6923fccfab8391e586ac2a98188709b0de9dc8dc6ec0342972e526b65f962c89e86dcf355be3a3b9d87684922e95b21ff8efb8addd21d59c96a1ebe4d5cf9201def08747c394ee3593fd9432c4d60651357cc8227af7fa7dc93cfc6c1890ad76198699ff412b9ed3eaa22da3907c0e9d309f62e6188c8ca83d26ae62153521eb6781f09d2d674ae4bf317077d92ceac43c9927dec13d047bdf03c4541479a095c89e8a5a5ac9c5ce2b77e5318d91d06509b61df2ed80e7dca820e92c1c43c61aff4577ea5b00d3c3371b825adec3bcdebf3697e32c8eda13940a8ec086031fc6b413165827e210a213adb8389baad05b80040a6771ced0fa6bf27e312410752452a4975671b83632811434a91529a9e5c3b108e9ed6d0ca28dcbe3da219067077e3abe8f83c276a1b071e861b911c7f9c31ffec8b74e51f83e23d579a4228f634fef30618e42217fcf6c9f554add38e29fef7ea0d3309c6dd5fb9faf6ab932cf695f2b41e175233a2654530f8ed0e6d19f5620abb8354a89f4895582f5821557b0caeec75b9ea26f4fbbea4538fa9d2ed6206c09fa4054cb7738cc352eee03ad5938dea97858e2efa7e05a6d7f49e0589b612b959c378410035af6fd76ab4f1cf989f4015e91718af243113c94672df3c4d04fb017c38d2daa527081e3fa01d51332802a4fef492c8e7d367d3a0ec70d335f7dac095986a71369f45b5a3cbf8b19ff33f6a143dc90c5abe232482721e516b7480c3967e90cb8d45dd728dd35b8a43cf50ea79ea8ed75a02ea948a15c4cbcc1958398c79ebaf47dfd98d787c17bcace68f64b7068c1d834fa810d7cef2df67f4df726c12d636a29f414c9b6f2d4de274e2233485a1d4b427c70e72ad7b4d696b3f8c4fb090988c6dec7490df133788f065cd9635d4b0d9d2b9d25d730b29acfcfe516ac6b3befa9a0925ec97ccb923769f650bb5529abcaceb593cc7ff9e5f55834f04a0c38956d0c40b84fe890312a12cd37dac7ed8baacecd2be1594f8d7d1c7b9778b891a9dbdbfb2b5ab1c304fbf9670f2cb6ba2293413aa0c740cfea55f3db82aabd7b0422990bdcfc5fc6d086284057e7870ae28a5ed9fc6f12dafe8673e6d0173f577cf03b24edfcf73ef99ef26e206d8042282ecbbbe94129ed046ab3e3f8652f08a36ed886ca656ac5cd81f1dace8de0d9933fdc9f7ea383c9ed460a8c7d1e358fa604b9c433ba0d4acebc2c28b76de20b5aba01b5a390b35672e5d1d60ce48ce7a4e96063637b70b08423982e8fae11d50f9e34549fcd857cde4339d1d9fa7bb7458b97d933118e6ce6b4db3147c2195b84a44f16888258bdcaa1825f806601ee929b37314f746dc749a2567300e9ba4111d3236c86705749aecb366953a77d6b868e1b539039e6e626e0604dfb5d8712005e65a28e6aca4f0bead2d610ff2192413a48c32ea1ba918bb968b684fb7929df6a417ed7f4aaa7eaac36289238b69def34a05778971d61616c6137ca1cea16e1a59bef799c59743c165215bbf92a116a73a782b4f29b62681cfccd83fe06287ed9783b330707f5437984391a45c3a5eb73da375bbdc36c7e7e722e3a76d58475446c7254a1a8b114570b68461caaacb768ef268783a07410f46632cfb7074139395350a1257fba76b418f99b76f456c13d6fed561f948d6902cc2867578ca684750c6156cb81d446e5665d2bdd7334c9c3202d3997d77e1b4bd038483d8980dbd5008d2061011a7e31a5a2778eca6141e3820d7db54fe41544b3b174afaa610d6859be6acbf4b1d90b2e8c7ea0d13a8b133d3f6d71db8bee18e2544a2a52380edee147e1afe81103702a02d9959ad6bcb5b5014778a013835ae4062638b5b79688d280915ae2b58ba58ffc0d0e1974478f12e3e95265c8f3e00142f5d701ed65eefc7ec77e6e50e50687be8193a488c258778abdec955104e7dba4574bfdc1a0870e957d840a1da82a788166f71c296a3146012dca910086994d19afc3c32a00a38356944f6542cfc648f8c5edcc7af3bbb758f3cdeb488085cbc73a19237e2f0b1b38f56ede3bd3093e2742fd5aeb338f82266d5e2f33d4a3d72e1521ae759c29e7d426428342bc398f0b7421023e6b7392a652a1746a161998b490853d3b937cee02dd8faae501f5c467f5296842e4f866ef4f88e96773848d2fe7d2829d432d236b41af0daad7495783f12c38da879e6ae7446255caf788fbe8c36dd3148f2c7d8565c7383c1acae34c3e60c6340c5f9d1f48caf6cddc64df318b70e517eb72078016101e90c7a3147495f9b4b932ed5795a02accff20675470ee8558b9c5a8b0bcdb451058276c5818f0c9d795497e62b04b442eeb83b08a6f4db27571bf3d611f44b8eca01c007b7aaaf336b51ed23be677eb1083b72195a8427751b9ece31c4d02cbafb8d872e115593d28a0e704e7805ad3a8b104ae4e314848903eeb7fa91c65cef0d6ee0a1d9138c5bc12c3d3023b213151bc75bdd7871eee17e322d347870ffb9e2bae2c45a115062fd2b7954a4887fac151bb7edf3f202be0321ed65c67639d0f067503c9e7e77fcb9a7ef4d65edaae9d6233f8f769829833569c3dac1987e1592400ab35f8faf62cc4a8fb99201958dfd87aae12b39f73bd0cf85389b42793bc8ecf63449f3becd4d70b5bc2307c96e46e7aa7dad05244ea8bc44eb799daf2b771ec4ce9e7362ebf420a1eddd253ddec96aa8e4eb4595796e52c7f913dece241791243c8373e523c595f602b2dbf712b3493530600cde46a512fec26297b3ed3419ac8f9d4d8b997fa1fd401dbf8fe35a36e4eefaeb5137e146a43236e084b9be5c75c22e8939d64ff562b8fe3493ffdffc8a85b82688a6c1af360dc5ca9dc860c40389abbdef28067e418ce2b172b88c9f224ca52da35940b4e54fb03bbb520f8971383c2499e44da6debeab6194e30bb2c5f941ed32ee817173bb7a12ffc29380558d45182863fc77b357c85b0c4de7060aa147acae246d308bf5e5fd3a3e1c69d1f2b4f2f6c2c82fb01c1f5058d7ab4d536e860c05d9c3e28e8c7baf616bda94281c231b623ecbd9377459b46c380becd444d56d76ea9539f5123870407c0fc3ac409be4787f72dfb8b56baa063ef45434f109926d17bbcbf8a5f7e76648bfcc306e2a63762ecb011214b1ff727b4f63a3b154774175046acf5dcab96f4e62920866fef155bb4439e6d2a77641652dbc151468018cc416e9e77239223effeb43872697ad09c1fa369790bcbe108bdc7551656442f70f2c0896675dc369f66c6c147b171c3e85949753b47e536b583788c9492ae9c12181ba6cf5af039042618ef5d7243bcbdfc28f1d82ee2748e991ea64d0c3f9ca8259ef06aff081cff3f4a65f507defd4e7179e928de6dd070ef3bdffbc341dd9e37dcae8ac52e42d38da6f9bb47b402437ae9954c10a02eb4e4dd521f75963daa22cb7ad8461d1c5e944751574e48e03e0e3e4576f68c92bbbaea05dc5fe53ebf0cdca1012b5b88bec6cb4911fb39dc7d9406dd45969ffa279d168004a90149b162bdfd07a5f0811e682968410c3aa8a0affe6bd49cd8935e0ab9f3c1ab54772ed6c4e53993e4d0481d58ec205a8d00471680deb4fcebfc158176a9bc9465c4358ce06a141de1c8f3c0f25f1d867d737dfe2f286ea210ae5cc0c35eb77ff344433abfc1feaffc2ef5cd321e18f17cc1d5b5f2cfe1a43e7c6c5ccdc1e5cc8ddd9b27a334818c39d226721a3725e8c91301608cba1aaede0a995bafb7a14a8b031759854a7e8321febf40d8d1b55f4034d004ba55e49a11da779c89e6687093ecd1acca2343d222d4ff0fc9c0b5f8a097b3d377cf4e7111713f1f667450b66793a81439faa7410801c14207a41319ed4de31d5418a464f06562032bd92e40969de4eb1bc69222c34ab29c52101a2a21d69902c964643f77452eaf54663b38f9cc45afcf9efdb6a02bcf3cf5b2d1e871e8c5bd7888b9ddfd3f93f0aff103d6c6222c073f19cce29f9233e909e05dee5d99d26eb882c7861b2772842c1d1349338441bdaaa1850b49646270d8cd9dd61e5dcd5a297ce7b8a52894d60b953e456d1bdc0db2a78619cdf89b779137c5eee1268ed2afff9544e8b1b2f43921e2cdc5b00ed8b2e9596dce67c6237558ba50132cefb3c8f921f05f17e6c02d7d049808d8925e940cf01cb4d70480c90414774a9b12eaa2129ca88074457dcab383360ceccb5</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">您好, 这里需要密码，密码是123456</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 网站 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网站 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>obsidian使用</title>
      <link href="/posts/4661.html"/>
      <url>/posts/4661.html</url>
      
        <content type="html"><![CDATA[<p>在 Obsidian 最新版中，正反向链接、标签和属性是核心功能，用于构建知识网络、分类管理及添加</p><h3 id="一、正反向链接"><a href="#一、正反向链接" class="headerlink" title="一、正反向链接"></a><strong>一、正反向链接</strong></h3><h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a><strong>功能</strong></h4><ul><li><strong>正向链接（出链）</strong>：当前笔记中主动引用其他笔记或段落。</li><li><strong>反向链接（入链）</strong>：其他笔记引用当前笔记时自动生成的反向关联。</li><li><strong>作用</strong>：形成双向知识网络，通过链接关系追溯相关内容。</li></ul><h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a><strong>使用方法</strong></h4><ol><li><p><strong>基础语法</strong>：  </p> <figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[[目标笔记名]]                  # 链接到整篇笔记</span><br><span class="line">[[目标笔记名#标题]]             # 链接到特定标题</span><br><span class="line">[[目标笔记名#^段落ID]]          # 链接到具体段落（块）</span><br><span class="line">[[目标笔记名|别名]]             # 使用别名显示链接</span><br></pre></td></tr></table></figure></li><li><p><strong>操作提示</strong>：  </p><ul><li>输入 <code>[[</code> 后，Obsidian 会自动提示可链接的笔记。</li><li>支持嵌入内容（如图片、视频）：<code>![[图片名.png]]</code>。</li><li>段落块 ID 可通过光标悬停段落时点击「复制块链接」获取。</li></ul></li><li><p><strong>查看反向链接</strong>：<br> 在右侧面板或笔记底部查看「反向链接」，显示所有引用当前笔记的位置。</p></li></ol><hr><h3 id="二、标签"><a href="#二、标签" class="headerlink" title="二、标签"></a><strong>二、标签</strong></h3><h4 id="功能-1"><a href="#功能-1" class="headerlink" title="功能"></a><strong>功能</strong></h4><ul><li><strong>分类管理</strong>：通过 <code>#标签</code> 对笔记进行主题或属性标记。</li><li><strong>嵌套标签</strong>：支持层级结构（如 <code>#科研/论文</code>），实现精细分类。</li><li><strong>作用</strong>：快速检索、批量管理相关笔记。</li></ul><h4 id="使用方法-1"><a href="#使用方法-1" class="headerlink" title="使用方法"></a><strong>使用方法</strong></h4><ol><li><p><strong>基础语法</strong>：  </p> <figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">#标签名         # 普通标签</span></span><br><span class="line"><span class="section">#父标签/子标签  # 嵌套标签</span></span><br></pre></td></tr></table></figure></li><li><p><strong>优化实践</strong>：  </p><ul><li><p>将标签置于 YAML front matter 中，避免正文干扰：  </p>  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">tags:</span> [<span class="string">Obsidian</span>, <span class="string">教程</span>]</span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure></li><li><p>使用 <strong>Tag Wrangler 插件</strong>：  </p><ul><li>右键标签批量重命名、创建标签页、拖拽插入标签。</li><li>管理嵌套标签结构，生成标签树。</li></ul></li></ul></li></ol><hr><h3 id="三、属性（YAML-Front-Matter）"><a href="#三、属性（YAML-Front-Matter）" class="headerlink" title="三、属性（YAML Front Matter）"></a><strong>三、属性（YAML Front Matter）</strong></h3><h4 id="功能-2"><a href="#功能-2" class="headerlink" title="功能"></a><strong>功能</strong></h4><ul><li><strong>元数据管理</strong>：为笔记添加结构化信息（如作者、创建时间、进度等）。</li><li><strong>类型支持</strong>：文本、列表、数字、日期等（需手动定义类型）。</li><li><strong>作用</strong>：配合插件（如 Dataview）实现高级查询和自动化管理。</li></ul><h4 id="使用方法-2"><a href="#使用方法-2" class="headerlink" title="使用方法"></a><strong>使用方法</strong></h4><ol><li><p><strong>基础语法</strong>：<br> 在笔记开头添加 YAML 块：  </p> <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">aliases:</span> [<span class="string">别名1</span>, <span class="string">别名2</span>]  <span class="comment"># 别名</span></span><br><span class="line"><span class="attr">tags:</span> <span class="string">标签名</span>             <span class="comment"># 标签</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2023-09-01</span>        <span class="comment"># 日期类型属性</span></span><br><span class="line"><span class="attr">progress:</span> <span class="string">进行中</span>         <span class="comment"># 文本类型属性</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure></li><li><p><strong>类型定义</strong>：  </p><ul><li>属性值默认文本类型，可通过插件或手动标注类型（如 <code>date:: 2023-09-01</code>）。</li></ul></li><li><p><strong>模板自动化</strong>：  </p><ul><li>结合模板插件，自动插入常用属性（如 <code>&#123;&#123;date&#125;&#125;</code> 生成当前日期）。</li></ul></li></ol><hr><h3 id="版本注意事项"><a href="#版本注意事项" class="headerlink" title="版本注意事项"></a><strong>版本注意事项</strong></h3><ul><li><strong>桌面端</strong>：1.4.5+ 支持完整属性功能。</li><li><strong>移动端</strong>：暂不支持属性（截至 2023.09），建议通过桌面端编辑。</li></ul><hr><h3 id="总结：使用场景"><a href="#总结：使用场景" class="headerlink" title="总结：使用场景"></a><strong>总结：使用场景</strong></h3><ol><li><strong>正反向链接</strong>：构建知识关联，推荐用于概念解释、参考文献。</li><li><strong>标签</strong>：快速分类，适合主题标记（如 <code>#待办</code>、<code>#灵感</code>）。</li><li><strong>属性</strong>：结构化元数据，适用于项目管理（如 <code>status: 进行中</code>）。</li></ol><p>通过组合这些功能，Obsidian 可实现高效的知识管理与深度关联。</p>]]></content>
      
      
      <categories>
          
          <category> Obsidian </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Obsidian </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ STL —— 基于算法竞赛</title>
      <link href="/posts/123456.html"/>
      <url>/posts/123456.html</url>
      
        <content type="html"><![CDATA[<h1 id="原作者在这里！本文是基于行码棋的文章进行的翻改！"><a href="#原作者在这里！本文是基于行码棋的文章进行的翻改！" class="headerlink" title="原作者在这里！本文是基于行码棋的文章进行的翻改！"></a><a href="https://wyqz.top/p/870124582.html">原作者在这里！本文是基于行码棋的文章进行的翻改！</a></h1><blockquote><p>  [!NOTE]</p><p>  <a href="https://io.zouht.com/154.html">相关好文推荐，这篇 STL 我也觉得非常不错！分享给你！</a></p><p>  简单分享一下：起初入门 C++，我特别幸运地找到了这篇超级适合 <code>STL</code> 入门和竞赛的文章！一开始只是随便翻了翻，没想到 <strong>内容不仅全面详细，而且非常实用</strong>，只记得那天下午用了两个小时，从头到尾仔细的看了一遍，结果越看越上头，不靠视频也能高效、快速的学习（对当时完全没阅读习惯的我来说，简直是个奇迹）。后来的几天时间也是断断续续的在看，一周时间就可以 <strong>快速上手 <code>STL</code></strong> 了。相信屏幕前的你比我更快！</p><p>  这篇文章最大的优点就是 <strong>实用</strong>，不是那种光讲理论、没法落地的内容。在后来的刷题和深入学习的过程中，每次遇到不会的地方，我也时不时的会翻出来查，就像一本随身的 <strong><code>STL</code> 字典</strong>。某些地方反复看了很多遍，每次都会有新的收获。随着不断 <strong>实践 + 回顾</strong>，相关知识越来越清晰，使用起来也越来越顺手，简直就像高中查笔记一样，真的让我受益匪浅！希望也能帮到你~</p></blockquote><blockquote><p>  [!TIP]</p><p>  <strong>实践才是检验真理的唯一标准！</strong></p></blockquote><h1 id="1-vector"><a href="#1-vector" class="headerlink" title="1. vector"></a>1. vector</h1><h2 id="1-1-介绍"><a href="#1-1-介绍" class="headerlink" title="1.1 介绍"></a>1.1 介绍</h2><h3 id="1-1-1-简介"><a href="#1-1-1-简介" class="headerlink" title="1.1.1 简介"></a>1.1.1 简介</h3><p><code>vector</code> 为可变长数组（动态数组），定义的 <code>vector</code> 数组可以随时添加数值和删除元素。</p><blockquote><p>注意：<strong>在局部区域中（比如局部函数里面）开 vector 数组，是在堆空间里面开的。</strong></p><p>在局部区域开数组是在栈空间开的，而栈空间比较小，如果开了非常长的数组就会发生爆栈。</p><p>故局部区域 <strong>不可以</strong> 开大长度数组，但是可以开大长度 <code>vector</code>。</p></blockquote><p>包含头文件：</p><h3 id="1-1-2-初始化"><a href="#1-1-2-初始化" class="headerlink" title="1.1.2 初始化"></a>1.1.2 初始化</h3><ul><li><p><strong>一维初始化：</strong></p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; a; <span class="comment">//定义了一个名为 a 的一维数组, 数组存储 int 类型数据</span></span><br><span class="line">vector&lt;<span class="type">double</span>&gt; b; <span class="comment">//定义了一个名为 b 的一维数组，数组存储 double 类型数据</span></span><br><span class="line">vector&lt;node&gt; c; <span class="comment">//定义了一个名为 c 的一维数组，数组存储结构体类型数据，node 是结构体类型</span></span><br></pre></td></tr></table></figure><p>  指定 <strong>长度</strong> 和 <strong>初始值</strong> 的初始化</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(n)</span></span>; <span class="comment">// 定义一个长度为 n 的数组，初始值默认为 0，下标范围 [0, n - 1]</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(n, <span class="number">1</span>)</span></span>; <span class="comment">// v [0] 到 v [n - 1] 所有的元素初始值均为 1</span></span><br><span class="line"><span class="comment">//注意：指定数组长度之后（指定长度后的数组就相当于正常的数组了）</span></span><br></pre></td></tr></table></figure><p>  初始化中有多个元素</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; a&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;<span class="comment">//数组 a 中有五个元素，数组长度就为 5</span></span><br></pre></td></tr></table></figure><p>  拷贝初始化</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">b</span><span class="params">(a)</span></span>;               <span class="comment">// 两个数组中的类型必须相同, a 和 b 都是长度为 n+1，初始值都为 0 的数组</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; c = a;              <span class="comment">// 也是拷贝初始化, c 和 a 是完全一样的数组</span></span><br></pre></td></tr></table></figure></li><li><p><strong>二维初始化：</strong><br>  定义第一维固定长度为 <code>5</code>，第二维可变化的二维数组</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v[<span class="number">5</span>];           <span class="comment">//定义可变长二维数组</span></span><br><span class="line"><span class="comment">//注意：行不可变（只有 5 行）, 而列可变, 可以在指定行添加元素</span></span><br><span class="line"><span class="comment">//第一维固定长度为 5，第二维长度可以改变</span></span><br></pre></td></tr></table></figure><blockquote><p><code>vector&lt;int&gt; v[5]</code> 可以这样理解：长度为 5 的 v 数组，数组中存储的是 <code>vector&lt;int&gt;</code> 数据类型，而该类型就是数组形式，故 <code>v</code> 为二维数组。其中每个数组元素均为空，因为没有指定长度，所以第二维可变长。可以进行下述操作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">v[<span class="number">1</span>].<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">v[<span class="number">2</span>].<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br></pre></td></tr></table></figure></blockquote><p>  行列均可变</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化二维均可变长数组</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; v;<span class="comment">//定义一个行和列均可变的二维数组</span></span><br></pre></td></tr></table></figure><blockquote><p>应用：可以在 <code>v</code> 数组里面装多个数组</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; t1&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; t2&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">v.<span class="built_in">push_back</span>(t1);</span><br><span class="line">v.<span class="built_in">push_back</span>(t2);</span><br><span class="line">v.<span class="built_in">push_back</span>(&#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;) <span class="comment">// &#123;3, 4, 5, 6&#125;可以作为 vector 的初始化, 相当于一个无名 vector</span></span><br></pre></td></tr></table></figure></blockquote><p>  行列长度均固定 <code>n + 1</code> 行 <code>m + 1</code> 列初始值为 0</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">a</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m + <span class="number">1</span>, <span class="number">0</span>));</span><br></pre></td></tr></table></figure><p>  c++17 及以上支持的形式（定义模板类的对象时，可以不指定模板参数，但必须要在构造函数中能推导出模板参数）</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector a&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;; <span class="comment">// 声明一个 int 类型动态数组，初识元素自己指定</span></span><br><span class="line"><span class="function">vector <span class="title">b</span><span class="params">(n + <span class="number">1</span>, vector(m + <span class="number">1</span>, <span class="number">0</span>))</span></span>;</span><br></pre></td></tr></table></figure></li></ul><h2 id="1-2-方法函数"><a href="#1-2-方法函数" class="headerlink" title="1.2 方法函数"></a>1.2 方法函数</h2><h3 id="1-2-1-函数总结"><a href="#1-2-1-函数总结" class="headerlink" title="1.2.1 函数总结"></a>1.2.1 函数总结</h3><p>注：c 指定为数组名称</p><table><thead><tr><th>代码</th><th>算法复杂度</th><th>返回值类型</th><th>含义</th></tr></thead><tbody><tr><td><code>c.front()</code></td><td>O(1)</td><td>引用</td><td>返回容器中的第一个数据</td></tr><tr><td><code>c.back()</code></td><td>O(1)</td><td>引用</td><td>返回容器中的最后一个数据</td></tr><tr><td><code>c.at(idx)</code></td><td></td><td>引用</td><td>返回 <code>c[idx]</code> ，会进行边界检查，如果越界会报错，比直接使用 <code>[]</code> 更好一些，常在项目中使用</td></tr><tr><td><code>c.size()</code></td><td>O(1)</td><td></td><td>返回实际数据个数（unsigned 类型）</td></tr><tr><td><code>c.begin()</code></td><td>O(1)</td><td>迭代器</td><td>返回首元素的迭代器（通俗来说就是地址）</td></tr><tr><td><code>c.end()</code></td><td>O(1)</td><td>迭代器</td><td>返回最后一个元素后一个位置的迭代器（地址）</td></tr><tr><td><code>c.empty()</code></td><td>O(1)</td><td>bool</td><td>判断是否为空，为空返回真，反之返回假</td></tr><tr><td><code>c.reserve(sz)</code></td><td></td><td></td><td>为数组提前分配 <code>sz</code> 的内存大小，即改变了 <code>capacity</code> 的大小，主要是为了防止在 <code>push_back</code> 过程中多次的内存拷贝</td></tr><tr><td><code>c.assign(beg, end)</code></td><td></td><td></td><td>将另外一个容器 <code>[x.begin(), x.end())</code> 里的内容拷贝到 <code>c</code> 中</td></tr><tr><td><code>c.assign(n, val)</code></td><td></td><td></td><td>将 <code>n</code> 个 <code>val</code> 值拷贝到 <code>c</code> 数组中，这会清除掉容器中以前的内容，<code>c</code> 数组的 <code>size</code> 将变为 <code>n</code>，<code>capacity</code> 不会改变</td></tr><tr><td><code>c.pop_back()</code></td><td>O(1)</td><td></td><td>删除最后一个数据</td></tr><tr><td><code>c.push_back(element)</code></td><td>O(1)</td><td></td><td>在尾部加一个数据</td></tr><tr><td><code>c.emplace_back(ele)</code></td><td>O(1)</td><td></td><td>在数组中加入一个数据，和 <code>push_back</code> 功能基本一样，在某些情况下比它效率更高，支持传入多个构造参数</td></tr><tr><td><code>c.clear()</code></td><td>O(N)</td><td></td><td>清除容器中的所有元素</td></tr><tr><td><code>c.resize(n, v)</code></td><td></td><td></td><td>改变数组大小为 <code>n</code>, <code>n</code> 个空间数值赋为 <code>v</code>，如果没有默认赋值为 <code>0</code></td></tr><tr><td><code>c.insert(pos, x)</code></td><td>O(N)</td><td></td><td>向任意迭代器 <code>pos</code> 插入一个元素 <code>x</code></td></tr><tr><td>例：<code>c.insert(c.begin() + 2, -1)</code></td><td></td><td></td><td>将 <code>-1</code> 插入 <code>c[2]</code> 的位置</td></tr><tr><td><code>c.erase(first, last)</code></td><td>O(N)</td><td></td><td>删除 <code>[first, last)</code> 的所有元素</td></tr></tbody></table><h3 id="1-2-2-注意情况"><a href="#1-2-2-注意情况" class="headerlink" title="1.2.2 注意情况"></a>1.2.2 注意情况</h3><ul><li><p><code>end()</code> 返回的是最后一个元素的后一个位置的地址，不是最后一个元素的地址，<strong>所有 STL 容器均是如此</strong></p></li><li><p>使用 <code>vi.resize(n, v)</code> 函数时，若 <code>vi</code> 之前指定过大小为 <code>pre</code></p><ul><li><code>pre &gt; n</code> ：即数组大小变小了，数组会保存前 <code>n</code> 个元素，前 <code>n</code> 个元素值为原来的值，不是都为 <code>v</code></li><li><code>pre &lt; n</code> ：即数组大小变大了，数组会在后面插入 <code>n - pre</code> 个值为 <code>v</code> 的元素</li></ul><p>  也就是说，这个初始值 <code>v</code> 只对新插入的元素生效。</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">out</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x: a) cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>; cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">5</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="built_in">out</span>(a); <span class="comment">// 1 1 1 1 1</span></span><br><span class="line">a.<span class="built_in">resize</span>(<span class="number">10</span>, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">out</span>(a); <span class="comment">// 1 1 1 1 1 2 2 2 2 2</span></span><br><span class="line">a.<span class="built_in">resize</span>(<span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">out</span>(a); <span class="comment">// 1 1 1</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用 <code>sort</code> 排序要: <code>sort(c.begin(), c.end());</code></p></li></ul><blockquote><p><code>sort()</code> 为 STL 函数，请参考本文最后面 STL 函数系列。</p></blockquote><p>对所有元素进行排序，如果要对指定区间进行排序，可以对 <code>sort()</code> 里面的参数进行加减改动。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="built_in">sort</span>(a.<span class="built_in">begin</span>() + <span class="number">1</span>, a.<span class="built_in">end</span>()); <span class="comment">// 对 [1, n] 区间进行从小到大排序</span></span><br></pre></td></tr></table></figure><h2 id="1-3-元素访问"><a href="#1-3-元素访问" class="headerlink" title="1.3 元素访问"></a>1.3 元素访问</h2><p>共三种方法：</p><ol><li><p><strong>下标法：</strong> 和普通数组一样。注意：一维数组的下标是从 <code>0</code> 到 <code>v.size() - 1</code> ，访问之外的数会出现越界错误！</p></li><li><p><strong>迭代器法：</strong> 类似指针一样的访问 ，首先需要声明迭代器变量，和声明指针变量一样，可以根据代码进行理解（附有注释）。</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; vi; <span class="comment">//定义一个 vi 数组</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it = vi.<span class="built_in">begin</span>();  <span class="comment">//声明一个迭代器指向 vi 的初始位置</span></span><br></pre></td></tr></table></figure><ol start="3"><li><strong>使用 auto：</strong> 非常简便，但是会访问数组的所有元素（特别注意 0 位置元素也会访问到）。</li></ol><h3 id="1-3-1-下标访问"><a href="#1-3-1-下标访问" class="headerlink" title="1.3.1 下标访问"></a>1.3.1 下标访问</h3><p>直接和普通数组一样进行访问即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加元素</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">vi.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//下标访问 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; vi[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br></pre></td></tr></table></figure><h3 id="1-3-2-迭代器访问"><a href="#1-3-2-迭代器访问" class="headerlink" title="1.3.2 迭代器访问"></a>1.3.2 迭代器访问</h3><p>类似指针，迭代器就是充当指针的作用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; vi&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="comment">//迭代器访问</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it;   </span><br><span class="line"><span class="comment">// 相当于声明了一个迭代器类型的变量 it</span></span><br><span class="line"><span class="comment">// 通俗来说就是声明了一个指针变量</span></span><br></pre></td></tr></table></figure><ul><li>方式一：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it = vi.<span class="built_in">begin</span>(); </span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *(it + i) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br></pre></td></tr></table></figure><ul><li>方式二：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it;</span><br><span class="line"><span class="keyword">for</span>(it = vi.<span class="built_in">begin</span>(); it != vi.<span class="built_in">end</span>();it ++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//vi.end()指向尾元素地址的下一个地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">auto</span> it = vi.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span> (it != vi.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    it++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-3-智能指针"><a href="#1-3-3-智能指针" class="headerlink" title="1.3.3 智能指针"></a>1.3.3 智能指针</h3><p><strong>只能遍历完数组</strong>，如果要指定的内容进行遍历，需要另选方法。<code>auto</code> 能够自动识别并获取类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 输入</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x: a)</span><br><span class="line">&#123;</span><br><span class="line">    cin &gt;&gt; x; <span class="comment">// 可以进行输入，注意加引用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 输出</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">12</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">241</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> val : v)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 12 241</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>vector</code> 注意：</p><ul><li><p><code>vi[i]</code> 和 <code>*(vi.begin() + i)</code> 等价，与指针类似。</p></li><li><p><code>vector</code> 和 <code>string</code> 的 <code>STL</code> 容器支持 <code>*(it + i)</code> 的元素访问，其它容器可能也可以支持这种方式访问，但用的不多，可自行尝试。</p></li></ul></blockquote><h1 id="2-stack"><a href="#2-stack" class="headerlink" title="2. stack"></a>2. stack</h1><h2 id="2-1-介绍"><a href="#2-1-介绍" class="headerlink" title="2.1 介绍"></a>2.1 介绍</h2><p>栈为数据结构的一种，是 STL 中实现的一个先进后出，后进先出的容器。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 包含头文件：</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化：</span></span><br><span class="line">stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">stack&lt;string&gt; s;</span><br><span class="line">stack&lt;node&gt; s;<span class="comment">//node 是结构体类型</span></span><br></pre></td></tr></table></figure><h2 id="2-2-方法函数"><a href="#2-2-方法函数" class="headerlink" title="2.2 方法函数"></a>2.2 方法函数</h2><table><thead><tr><th>代码</th><th>含义</th></tr></thead><tbody><tr><td><code>s.push(ele)</code></td><td>元素 <code>ele</code> 入栈，增加元素 O(1)</td></tr><tr><td><code>s.pop()</code></td><td>移除栈顶元素 O(1)</td></tr><tr><td><code>s.top()</code></td><td>取得栈顶元素（但不删除）O(1)</td></tr><tr><td><code>s.empty()</code></td><td>检测栈内是否为空，空为真 O(1)</td></tr><tr><td><code>s.size()</code></td><td>返回栈内元素的个数 O(1)</td></tr></tbody></table><h2 id="2-3-栈元素访问"><a href="#2-3-栈元素访问" class="headerlink" title="2.3 栈元素访问"></a>2.3 栈元素访问</h2><h3 id="2-3-1-栈遍历"><a href="#2-3-1-栈遍历" class="headerlink" title="2.3.1 栈遍历"></a>2.3.1 栈遍历</h3><p>栈只能对栈顶元素进行操作，如果想要进行遍历，只能将栈中元素一个个取出来存在数组中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line">st.<span class="built_in">push</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!st.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> tp = st.<span class="built_in">top</span>(); <span class="comment">// 栈顶元素</span></span><br><span class="line">    st.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-2-数组模拟栈进行遍历"><a href="#2-3-2-数组模拟栈进行遍历" class="headerlink" title="2.3.2 数组模拟栈进行遍历"></a>2.3.2 数组模拟栈进行遍历</h3><p>通过一个 <strong>数组</strong> 对栈进行模拟，一个存放下标的变量 <code>top</code> 模拟指向栈顶的指针。</p><blockquote><p>一般来说单调栈和单调队列写法均可使用额外变量 <code>tt</code> 或 <code>hh</code> 来进行模拟</p></blockquote><p><strong>特点：</strong> 比 <code>STL</code> 的 <code>stack</code> 速度更快，遍历元素方便。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> s[<span class="number">100</span>]; <span class="comment">// 栈 从左至右为栈底到栈顶</span></span><br><span class="line"><span class="type">int</span> tt = <span class="number">-1</span>; <span class="comment">// tt 代表栈顶指针, 初始栈内无元素，tt 为-1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">5</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//入栈 </span></span><br><span class="line">s[++tt] = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出栈</span></span><br><span class="line"><span class="type">int</span> top_element = s[tt--]; </span><br><span class="line"></span><br><span class="line"><span class="comment">//入栈操作示意</span></span><br><span class="line"><span class="comment">//  0  1  2  3  4  5  </span></span><br><span class="line"><span class="comment">//                tt</span></span><br><span class="line"><span class="comment">//出栈后示意</span></span><br><span class="line"><span class="comment">//  0  1  2  3  4 </span></span><br><span class="line"><span class="comment">//              tt</span></span><br></pre></td></tr></table></figure><h1 id="3-queue"><a href="#3-queue" class="headerlink" title="3. queue"></a>3. queue</h1><h2 id="3-1-介绍"><a href="#3-1-介绍" class="headerlink" title="3.1 介绍"></a>3.1 介绍</h2><p>队列是一种先进先出的数据结构。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 包含头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br></pre></td></tr></table></figure><h2 id="3-2-方法函数"><a href="#3-2-方法函数" class="headerlink" title="3.2 方法函数"></a>3.2 方法函数</h2><table><thead><tr><th>代码</th><th>含义</th></tr></thead><tbody><tr><td><code>q.front()</code></td><td>返回队首元素 O(1)</td></tr><tr><td><code>q.back()</code></td><td>返回队尾元素 O(1)</td></tr><tr><td><code>q.push(element)</code></td><td>尾部添加一个元素 <code>element</code> 进队 O(1)</td></tr><tr><td><code>q.pop()</code></td><td>删除第一个元素 出队 O(1)</td></tr><tr><td><code>q.size()</code></td><td>返回队列中元素个数，返回值类型 <code>unsigned int</code> O(1)</td></tr><tr><td><code>q.empty()</code></td><td>判断是否为空，队列为空，返回 <code>true</code> O(1)</td></tr></tbody></table><h2 id="3-3-队列模拟"><a href="#3-3-队列模拟" class="headerlink" title="3.3 队列模拟"></a>3.3 队列模拟</h2><p>使用 <code>q[]</code> 数组模拟队列：</p><ul><li><code>hh</code> 表示队首元素的下标，初始值为 <code>0</code>。</li><li><code>tt</code> 表示队尾元素的下标，初始值为 <code>-1</code>，表示刚 <strong>开始队列为空</strong>。</li></ul><blockquote><p>一般来说单调栈和单调队列写法均可使用额外变量 <code>tt</code> 或 <code>hh</code> 来进行模拟。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> hh = <span class="number">0</span>,tt = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//入队 </span></span><br><span class="line">q[++tt] = <span class="number">1</span>;</span><br><span class="line">q[++tt] = <span class="number">2</span>; </span><br><span class="line">    </span><br><span class="line"><span class="comment">//将所有元素出队 </span></span><br><span class="line"><span class="keyword">while</span>(hh &lt;= tt)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="type">int</span> t = q[hh++];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure><h1 id="4-deque"><a href="#4-deque" class="headerlink" title="4. deque"></a>4. deque</h1><h2 id="4-1-介绍"><a href="#4-1-介绍" class="headerlink" title="4.1 介绍"></a>4.1 介绍</h2><p>首尾都可插入和删除的队列为双端队列。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="comment">//初始化定义</span></span><br><span class="line">deque&lt;<span class="type">int</span>&gt; dq;</span><br></pre></td></tr></table></figure><h2 id="4-2-方法函数"><a href="#4-2-方法函数" class="headerlink" title="4.2 方法函数"></a>4.2 方法函数</h2><blockquote><p>注意双端队列的常数比较大。</p></blockquote><table><thead><tr><th>代码</th><th>含义</th></tr></thead><tbody><tr><td><code>push_back(x)/push_front(x)</code></td><td>把 <code>x</code> 插入队尾后 &#x2F; 队首 O(1)</td></tr><tr><td><code>back()/front()</code></td><td>返回队尾 &#x2F; 队首元素 O(1)</td></tr><tr><td><code>pop_back() / pop_front()</code></td><td>删除队尾 &#x2F; 队首元素 O(1)</td></tr><tr><td><code>erase(iterator it)</code></td><td>删除双端队列中的某一个元素</td></tr><tr><td><code>erase(iterator first,iterator last)</code></td><td>删除双端队列中 <code>[first,last)</code> 中的元素</td></tr><tr><td><code>empty()</code></td><td>判断 deque 是否空 O(1)</td></tr><tr><td><code>size()</code></td><td>返回 deque 的元素数量 O(1)</td></tr><tr><td><code>clear()</code></td><td>清空 deque</td></tr></tbody></table><h2 id="4-3-注意点"><a href="#4-3-注意点" class="headerlink" title="4.3 注意点"></a>4.3 注意点</h2><p>deque 可以进行排序！</p><blockquote><p>双端队列排序一般不用，感觉毫无用处，使用其他 STL 依然可以实现相同功能。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从小到大</span></span><br><span class="line"><span class="built_in">sort</span>(q.<span class="built_in">begin</span>(), q.<span class="built_in">end</span>())</span><br><span class="line"><span class="comment">//从大到小排序</span></span><br><span class="line"><span class="built_in">sort</span>(q.<span class="built_in">begin</span>(), q.<span class="built_in">end</span>(), <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());<span class="comment">//deque 里面的类型需要是 int 型</span></span><br><span class="line"><span class="built_in">sort</span>(q.<span class="built_in">begin</span>(), q.<span class="built_in">end</span>(), <span class="built_in">greater</span>());<span class="comment">//高版本 C++才可以用</span></span><br></pre></td></tr></table></figure><h1 id="5-priority-queue"><a href="#5-priority-queue" class="headerlink" title="5. priority_queue"></a>5. priority_queue</h1><h2 id="5-1-介绍"><a href="#5-1-介绍" class="headerlink" title="5.1 介绍"></a>5.1 介绍</h2><p>优先队列是在正常队列的基础上加了优先级，保证每次的队首元素都是优先级最大的。可以实现每次从优先队列中取出的元素都是队列中 <strong>优先级最大</strong> 的一个。它的底层是通过 <strong>堆</strong> 来实现的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span>        <span class="comment">//头文件</span></span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>&gt; q;        <span class="comment">//初始化定义</span></span><br></pre></td></tr></table></figure><h2 id="5-2-函数方法"><a href="#5-2-函数方法" class="headerlink" title="5.2 函数方法"></a>5.2 函数方法</h2><table><thead><tr><th>代码</th><th>含义</th></tr></thead><tbody><tr><td><code>q.top()</code></td><td>访问队首元素 O(1)</td></tr><tr><td><code>q.push()</code></td><td>入队 O(logN)</td></tr><tr><td><code>q.pop()</code></td><td>堆顶（队首）元素出队 O(logN)</td></tr><tr><td><code>q.size()</code></td><td>队列元素个数 O(1)</td></tr><tr><td><code>q.empty()</code></td><td>是否为空 O(1)</td></tr><tr><td><strong>注意 没有 <code>clear()</code>！</strong></td><td>不提供该方法</td></tr><tr><td>优先队列只能通过 <code>top()</code> 访问队首元素（优先级最高的元素）</td><td></td></tr></tbody></table><h2 id="5-3-设置优先级"><a href="#5-3-设置优先级" class="headerlink" title="5.3 设置优先级"></a>5.3 设置优先级</h2><h3 id="5-3-1-基本数据类型的优先级"><a href="#5-3-1-基本数据类型的优先级" class="headerlink" title="5.3.1 基本数据类型的优先级"></a>5.3.1 基本数据类型的优先级</h3><blockquote><ul><li><span style="color:#FF0000;"><strong>普通排序容器（sort&#x2F;set&#x2F;map）：<code>less = 升序</code>，<code>greater = 降序</code>。</strong></span></li><li><span style="color:#FF0000;"><strong>priority_queue：<code>less = 大根堆（降序堆顶）</code>，<code>greater = 小根堆（升序堆顶）</code>。</strong></span></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;<span class="type">int</span>&gt; pq;                                 <span class="comment">// 默认大根堆, 即每次取出的元素是队列中的最大值</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; q;       <span class="comment">// 小根堆, 每次取出的元素是队列中的最小值</span></span><br></pre></td></tr></table></figure><p>参数解释：</p><ul><li><p>第一个参数：就是优先队列中存储的数据类型。</p></li><li><p>第二个参数：<code>vector&lt;int&gt;</code> 是用来承载底层数据结构堆的容器，若优先队列中存放的是 <code>double</code> 型数据，就要填 <code>vector&lt;double&gt;</code> <strong>总之存的是什么类型的数据，就相应的填写对应类型。同时也要改动第三个参数里面的对应类型。</strong></p></li><li><p>第三个参数：<code>less&lt;int&gt;</code> 表示数字大的优先级大，堆顶为最大的数字 <code>greater&lt;int&gt;</code> 表示数字小的优先级大，堆顶为最小的数字 <strong>int 代表的是数据类型，也要填优先队列中存储的数据类型。</strong></p></li></ul><hr><p>下面介绍基础数据类型优先级设置的写法：</p><ol><li>基础写法（非常常用）：</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;<span class="type">int</span>&gt; q1;                                 <span class="comment">// 默认大根堆, 即每次取出的元素是队列中的最大值</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, less&lt;<span class="type">int</span>&gt;&gt; q2;         <span class="comment">// 大根堆, 每次取出的元素是队列中的最大值，同第一行</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; q3;      <span class="comment">// 小根堆, 每次取出的元素是队列中的最小值</span></span><br></pre></td></tr></table></figure><ol start="2"><li><strong>自定义排序：</strong></li></ol><p>下面的代码比较长，基础类型优先级写着太麻烦，用第一种即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">cmp1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"><span class="keyword">return</span> x &gt; y;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cmp2</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> <span class="type">int</span> x, <span class="type">const</span> <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"><span class="keyword">return</span> x &lt; y;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, cmp1&gt; q1; <span class="comment">// 小根堆</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, cmp2&gt; q2; <span class="comment">// 大根堆</span></span><br></pre></td></tr></table></figure><h3 id="5-3-2-高级数据类型（结构体）优先级"><a href="#5-3-2-高级数据类型（结构体）优先级" class="headerlink" title="5.3.2 高级数据类型（结构体）优先级"></a>5.3.2 高级数据类型（结构体）优先级</h3><blockquote><p>即优先队列中存储结构体类型，必须要设置优先级，即结构体的比较运算（因为优先队列的堆中要比较大小，才能将对应最大或者最小元素移到堆顶）。</p></blockquote><p>优先级设置可以定义在 <strong>结构体内</strong> 进行小于号重载，也可以定义在 <strong>结构体外</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//要排序的结构体（存储在优先队列里面的）</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> x, y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>版本一：自定义全局比较规则</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义的比较结构体</span></span><br><span class="line"><span class="comment">//注意：cmp 是个结构体 </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cmp</span><span class="comment">//自定义堆的排序规则 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Point&amp; a,<span class="type">const</span> Point&amp; b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a.x &lt; b.x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化定义， </span></span><br><span class="line">priority_queue&lt;Point, vector&lt;Point&gt;, cmp&gt; q; <span class="comment">// x 大的在堆顶</span></span><br></pre></td></tr></table></figure><ul><li><strong>版本二：直接在结构体里面写</strong></li></ul><blockquote><p>因为是在结构体内部自定义的规则，一旦需要比较结构体，自动调用结构体内部重载运算符规则。</p></blockquote><p>结构体内部有两种方式：</p><p><strong>方式一</strong> ：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> x, y;</span><br><span class="line"><span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span> &lt; (Point a, Point b)<span class="comment">//为两个结构体参数，结构体调用一定要写上 friend</span></span><br><span class="line">    &#123;</span><br><span class="line"><span class="keyword">return</span> a.x &lt; b.x;  <span class="comment">//按 x 从小到大排，x 大的在堆顶</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>方式二</strong> ：（推荐此种）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> Point &amp;a) <span class="type">const</span><span class="comment">//直接传入一个参数，不必要写 friend</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> x &lt; a.x;  <span class="comment">//按 x 升序排列，x 大的在堆顶</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>优先队列的定义</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;Point&gt; q;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 优先队列自定义排序规则和 <code>sort()</code> 函数定义 <code>cmp</code> 函数很相似，但是最后返回的情况是 <strong>相反</strong> 的。即相同的符号，最后定义的排列顺序是完全相反的。<strong>所以只需要记住 <code>sort</code> 的排序规则和优先队列的排序规则是相反的就可以了。</strong></p><blockquote><p>当理解了堆的原理就会发现，堆调整时比较顺序是孩子和父亲节点进行比较，如果是 <code>&gt;</code> ，那么孩子节点要大于父亲节点，堆顶自然是最小值。</p></blockquote><h2 id="5-4-存储特殊类型的优先级"><a href="#5-4-存储特殊类型的优先级" class="headerlink" title="5.4 存储特殊类型的优先级"></a>5.4 存储特殊类型的优先级</h2><h3 id="5-4-1-存储-pair-类型"><a href="#5-4-1-存储-pair-类型" class="headerlink" title="5.4.1 存储 pair 类型"></a>5.4.1 存储 pair 类型</h3><p>大根堆存储 pair 类型的默认排序规则（<strong>降序排序：first ↓，second ↓</strong>）：</p><ol><li><strong>先按 <code>first</code> 降序排列</strong>（大的排在前面）；</li><li><strong>如果 <code>first</code> 相等，再按 <code>second</code> 降序排列</strong>（也是大的排在前面）。</li></ol><blockquote><p>头文件 <code> #include &lt;utility&gt;</code>  &#x2F;&#x2F; 使用 std:: pair</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span>  <span class="comment">// 使用 std:: pair</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span>    <span class="comment">// 使用 std:: priority_queue</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &gt;q;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123; <span class="number">7</span>, <span class="number">8</span> &#125;);</span><br><span class="line">    q.<span class="built_in">push</span>(&#123; <span class="number">7</span>, <span class="number">9</span> &#125;);</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(<span class="number">8</span>, <span class="number">7</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; q.<span class="built_in">top</span>().first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; q.<span class="built_in">top</span>().second &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>结果：<br>8 7<br>7 9<br>7 8</p></blockquote><p>小根堆则恰恰相反，我们只需要记住：</p><ul><li><span style="color:#FF0000;"><strong>大根堆（默认）：pair 默认比较结果反过来用 → first ↓，second ↓。</strong></span></li><li><span style="color:#FF0000;"><strong>小根堆（加 greater）：pair 默认比较结果直接用 → first ↑，second ↑。</strong></span></li></ul><h1 id="6-map"><a href="#6-map" class="headerlink" title="6. map"></a>6. map</h1><h2 id="6-1-介绍"><a href="#6-1-介绍" class="headerlink" title="6.1 介绍"></a>6.1 介绍</h2><h3 id="6-1-1-简介"><a href="#6-1-1-简介" class="headerlink" title="6.1.1 简介"></a>6.1.1 简介</h3><p>映射类似于函数的对应关系，每个 <code>x</code> 对应一个 <code>y</code>，而 <code>map</code> 是每个键对应一个值。这和 python 的字典类型非常相似。容器中的每个存储对为一个键值对，包含两个元素（键和值）。</p><h3 id="6-1-2-初始化"><a href="#6-1-2-初始化" class="headerlink" title="6.1.2 初始化"></a>6.1.2 初始化</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化定义</span></span><br><span class="line">map&lt;string, string&gt; mp;</span><br><span class="line">map&lt;string, <span class="type">int</span>&gt; mp;</span><br><span class="line">map&lt;<span class="type">int</span>, node&gt; mp;<span class="comment">//node 是结构体类型</span></span><br></pre></td></tr></table></figure><blockquote><p>map 特性：map 会按照键的顺序从小到大自动排序，键的类型必须可以比较大小。</p></blockquote><h2 id="6-2-函数方法"><a href="#6-2-函数方法" class="headerlink" title="6.2 函数方法"></a>6.2 函数方法</h2><h3 id="6-2-1-函数方法"><a href="#6-2-1-函数方法" class="headerlink" title="6.2.1 函数方法"></a>6.2.1 函数方法</h3><table><thead><tr><th>代码</th><th>含义</th><th>复杂度</th></tr></thead><tbody><tr><td><code>mp.find(key)</code></td><td>返回键为 key 的映射的迭代器 注意：用 find 函数来定位数据出现位置，它返回一个迭代器。当数据存在时，返回数据所在位置的迭代器，数据不存在时，返回 mp.end()mp.end()</td><td>O(logN)</td></tr><tr><td><code>mp.erase(it)</code></td><td>删除迭代器对应的键和值</td><td>O(logN)</td></tr><tr><td><code>mp.erase(key)</code></td><td>根据映射的键删除键和值</td><td>O(logN)</td></tr><tr><td><code>mp.erase(first,last)</code></td><td>删除左闭右开区间迭代器对应的键和值</td><td>O(last-first)</td></tr><tr><td><code>mp.size()</code></td><td>返回映射的对数</td><td>O(1)</td></tr><tr><td><code>mp.clear()</code></td><td>清空 map 中的所有元素</td><td>O(N)</td></tr><tr><td><code>mp.insert()</code></td><td>插入元素，插入时要构造键值对</td><td>O(N)</td></tr><tr><td><code>mp.empty()</code></td><td>如果 map 为空，返回 true，否则返回 false</td><td>O(1)</td></tr><tr><td><code>mp.begin()</code></td><td>返回指向 map 第一个元素的迭代器（地址）</td><td>O(1)</td></tr><tr><td><code>mp.end()</code></td><td>返回指向 map 尾部的迭代器（最后一个元素的 <strong>下一个</strong> 地址）</td><td>O(1)</td></tr><tr><td><code>mp.rbegin()</code></td><td>返回指向 map 最后一个元素的迭代器（地址）</td><td>O(1)</td></tr><tr><td><code>mp.rend()</code></td><td>返回指向 map 第一个元素前面(上一个）的逆向迭代器（地址）</td><td>O(1)</td></tr><tr><td><code>mp.count(key)</code></td><td>查看元素是否存在，因为 map 中键是唯一的，所以存在返回 1，不存在返回 0</td><td>O(logN)</td></tr><tr><td><code>mp.lower_bound()</code></td><td>返回一个迭代器，指向键值 &gt;&#x3D; <strong>key</strong> 的第一个元素</td><td></td></tr><tr><td><code>mp.upper_bound()</code></td><td>返回一个迭代器，指向键值 &gt; key 的第一个元素</td><td></td></tr></tbody></table><h3 id="6-2-2-注意情况"><a href="#6-2-2-注意情况" class="headerlink" title="6.2.2 注意情况"></a>6.2.2 注意情况</h3><p><strong>下面说明部分函数方法的注意点</strong></p><p>查找元素是否存在时，可以使用 ① <code>mp.find()</code> ② <code>mp.count()</code> ③ <code>mp[key]</code>，但是第三种情况，如果不存在对应的 <code>key</code> 时，会自动创建一个键值对（产生一个额外的键值对空间），所以为了不增加额外的空间负担，最好使用前两种方法。</p><h3 id="6-2-3-迭代器进行正反向遍历"><a href="#6-2-3-迭代器进行正反向遍历" class="headerlink" title="6.2.3 迭代器进行正反向遍历"></a>6.2.3 迭代器进行正反向遍历</h3><ul><li><code>mp.begin()</code> 和 <code>mp.end()</code> 用法：</li></ul><p><strong>用于正向遍历 map</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; mp;</span><br><span class="line">mp[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">mp[<span class="number">2</span>] = <span class="number">3</span>;</span><br><span class="line">mp[<span class="number">3</span>] = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">auto</span> it = mp.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span>(it != mp.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">it ++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例结果：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><ul><li><code>mp.rbegin()</code> 和 <code>mp.rend()</code></li></ul><p><strong>用于逆向遍历 map</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; mp;</span><br><span class="line">mp[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">mp[<span class="number">2</span>] = <span class="number">3</span>;</span><br><span class="line">mp[<span class="number">3</span>] = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">auto</span> it = mp.<span class="built_in">rbegin</span>();</span><br><span class="line"><span class="keyword">while</span>(it != mp.<span class="built_in">rend</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">it ++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例结果：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><h3 id="6-2-4-二分查找"><a href="#6-2-4-二分查找" class="headerlink" title="6.2.4 二分查找"></a>6.2.4 二分查找</h3><p>二分查找 <code>lower_bound()</code> 和 <code>upper_bound()</code>。</p><blockquote><p>map 的二分查找以第一个元素（即键为准），对 <strong>键</strong> 进行二分查找，返回值为 map 迭代器类型。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; m&#123;&#123;<span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">2</span>, <span class="number">2</span>&#125;, &#123;<span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">8</span>, <span class="number">2</span>&#125;, &#123;<span class="number">6</span>, <span class="number">2</span>&#125;&#125;;<span class="comment">//有序</span></span><br><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::iterator it1 = m.<span class="built_in">lower_bound</span>(<span class="number">2</span>);</span><br><span class="line">cout &lt;&lt; it1-&gt;first &lt;&lt; <span class="string">&quot;\n&quot;</span>;<span class="comment">//it1-&gt; first = 2</span></span><br><span class="line"></span><br><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::iterator it2 = m.<span class="built_in">upper_bound</span>(<span class="number">2</span>);</span><br><span class="line">cout &lt;&lt; it2-&gt;first &lt;&lt; <span class="string">&quot;\n&quot;</span>;<span class="comment">//it2-&gt; first = 6</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-3-添加元素"><a href="#6-3-添加元素" class="headerlink" title="6.3 添加元素"></a>6.3 添加元素</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先声明</span></span><br><span class="line">map&lt;string, string&gt; mp;</span><br></pre></td></tr></table></figure><ul><li><strong>方式一：</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mp[<span class="string">&quot;学习&quot;</span>] = <span class="string">&quot;看书&quot;</span>;</span><br><span class="line">mp[<span class="string">&quot;玩耍&quot;</span>] = <span class="string">&quot;打游戏&quot;</span>;</span><br></pre></td></tr></table></figure><ul><li><strong>方式二：插入元素构造键值对</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mp.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="string">&quot;vegetable&quot;</span>, <span class="string">&quot;蔬菜&quot;</span>));</span><br></pre></td></tr></table></figure><ul><li><strong>方式三：</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mp.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;string,string&gt;(<span class="string">&quot;fruit&quot;</span>,<span class="string">&quot;水果&quot;</span>));</span><br></pre></td></tr></table></figure><ul><li><strong>方式四:</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mp.<span class="built_in">insert</span>(&#123;<span class="string">&quot;hahaha&quot;</span>,<span class="string">&quot;wawawa&quot;</span>&#125;);</span><br></pre></td></tr></table></figure><h2 id="6-4-访问元素"><a href="#6-4-访问元素" class="headerlink" title="6.4 访问元素"></a>6.4 访问元素</h2><h3 id="6-4-1-下标访问"><a href="#6-4-1-下标访问" class="headerlink" title="6.4.1 下标访问"></a>6.4.1 下标访问</h3><p>(大部分情况用于访问单个元素)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mp[<span class="string">&quot;菜哇菜&quot;</span>] = <span class="string">&quot;强哇强&quot;</span>;</span><br><span class="line">cout &lt;&lt; mp[<span class="string">&quot;菜哇菜&quot;</span>] &lt;&lt; <span class="string">&quot;\n&quot;</span>;<span class="comment">//只是简写的一个例子，程序并不完整</span></span><br></pre></td></tr></table></figure><h3 id="6-4-2-遍历访问"><a href="#6-4-2-遍历访问" class="headerlink" title="6.4.2 遍历访问"></a>6.4.2 遍历访问</h3><ul><li>方式一：迭代器访问</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string,string&gt;::iterator it;</span><br><span class="line"><span class="keyword">for</span>(it = mp.<span class="built_in">begin</span>(); it != mp.<span class="built_in">end</span>(); it++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//      键                 值 </span></span><br><span class="line"><span class="comment">// it 是结构体指针访问所以要用 -&gt; 访问</span></span><br><span class="line">cout &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//*it 是结构体变量 访问要用 . 访问</span></span><br><span class="line"><span class="comment">//cout &lt;&lt;(*it).first &lt;&lt; &quot; &quot; &lt;&lt;(* it).second;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>方式二：智能指针访问</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i : mp)</span><br><span class="line">cout &lt;&lt; i.first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; i.second &lt;&lt; endl;<span class="comment">//键，值</span></span><br></pre></td></tr></table></figure><ul><li>方式三：对指定单个元素访问</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="type">char</span>,<span class="type">int</span>&gt;::iterator it = mp.<span class="built_in">find</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">cout &lt;&lt; it -&gt; first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt;  it-&gt;second &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br></pre></td></tr></table></figure><ul><li>方式四：c++17 特性才具有</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> [x, y] : mp)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//x, y 对应键和值</span></span><br></pre></td></tr></table></figure><h2 id="6-5-与-unordered-map-的比较"><a href="#6-5-与-unordered-map-的比较" class="headerlink" title="6.5 与 unordered_map 的比较"></a>6.5 与 unordered_map 的比较</h2><p>这里就不单开一个大目录讲 unordered_map 了，直接在 map 里面讲了。</p><h3 id="6-5-1-内部实现原理"><a href="#6-5-1-内部实现原理" class="headerlink" title="6.5.1 内部实现原理"></a>6.5.1 内部实现原理</h3><ul><li><strong>map</strong>：内部用 <strong>红黑树</strong> 实现，具有 <strong>自动排序</strong>（按键从小到大）功能。</li><li><strong>unordered_map</strong>：内部用 <strong>哈希表</strong> 实现，内部元素无序杂乱。</li></ul><h3 id="6-5-2-效率比较"><a href="#6-5-2-效率比较" class="headerlink" title="6.5.2 效率比较"></a>6.5.2 效率比较</h3><ol><li><p><strong>map</strong>：</p><ul><li><p>优点：内部用红黑树实现，内部元素具有有序性，查询删除等操作复杂度为 O(logN)</p></li><li><p>缺点：占用空间，红黑树里每个节点需要保存父子节点和红黑性质等信息，空间占用较大。</p></li></ul></li><li><p><strong>unordered_map</strong>：</p><ul><li><p>优点：内部用哈希表实现，查找速度非常快（适用于大量的查询操作）。</p></li><li><p>缺点：建立哈希表比较耗时。</p></li></ul></li></ol><blockquote><p>两者方法函数基本一样，差别不大。但是需要注意：</p><ul><li><p>随着内部元素越来越多，两种容器的插入删除查询操作的时间都会逐渐变大，效率逐渐变低。</p></li><li><p>使用 <code>[]</code> 查找元素时，如果元素不存在，两种容器 <strong>都是</strong> 创建一个空的元素；如果存在，会正常索引对应的值。所以如果查询过多的不存在的元素值，容器内部会创建大量的空的键值对，后续查询创建删除效率会 <strong>大大降低</strong>。</p></li><li><p>查询容器内部元素的最优方法是：先判断存在与否，再索引对应值（适用于这两种容器）</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以 map 为例</span></span><br><span class="line"> map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line"> <span class="type">int</span> x = <span class="number">999999999</span>;</span><br><span class="line"> <span class="keyword">if</span>(mp.<span class="built_in">count</span>(x)) <span class="comment">// 此处判断是否存在 x 这个键</span></span><br><span class="line"> &#123;</span><br><span class="line"> cout &lt;&lt; mp[x] &lt;&lt; <span class="string">&quot;\n&quot;</span>;   <span class="comment">// 只有存在才会索引对应的值，避免不存在 x 时多余空元素的创建</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ul></blockquote><p>另外：</p><blockquote><p>还有一种映射：<code>multimap</code></p><p>键可以重复，即一个键对应多个值，如要了解，可以自行搜索。</p></blockquote><h2 id="6-5-3-自定义-hash-函数"><a href="#6-5-3-自定义-hash-函数" class="headerlink" title="6.5.3 自定义 hash 函数"></a>6.5.3 自定义 hash 函数</h2><p>由于 unordered_map 中的元素需要具备 hash 特性，如果语言没有自带 hash 特性的话，需要我们自定义 hash 函数，以下举一个 <code>pair&lt;int, int&gt;</code> 的 hash 函数定义的例子，hash 函数看自己怎么定义了（只要能实现 hash 功能就行）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 lambda 表达式来定义哈希函数</span></span><br><span class="line"><span class="keyword">auto</span> hash_pair = [](<span class="type">const</span> std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; p) -&gt; std::<span class="type">size_t</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> hash&lt;<span class="type">long</span> <span class="type">long</span>&gt; hash_ll;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">hash_ll</span>(p.first + (<span class="built_in">static_cast</span>&lt;<span class="type">long</span> <span class="type">long</span>&gt;(p.second) &lt;&lt; <span class="number">32</span>));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 lambda 表达式作为哈希函数定义 unordered_map, 10 为桶的数量</span></span><br><span class="line">std::unordered_map&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, <span class="type">int</span>, <span class="keyword">decltype</span>(hash_pair)&gt; <span class="built_in">my_map</span>(<span class="number">10</span>, hash_pair);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用：</span></span><br><span class="line">my_map[&#123;<span class="number">3</span>, <span class="number">5</span>&#125;] = <span class="number">100</span>;</span><br><span class="line">cout &lt;&lt; my_map[&#123;<span class="number">3</span>, <span class="number">5</span>&#125;] &lt;&lt; endl;  <span class="comment">// 输出 100</span></span><br></pre></td></tr></table></figure><h1 id="7-set"><a href="#7-set" class="headerlink" title="7. set"></a>7. set</h1><h2 id="7-1-介绍"><a href="#7-1-介绍" class="headerlink" title="7.1 介绍"></a>7.1 介绍</h2><p>set 容器中的元素不会重复，当插入集合中已有的元素时，并不会插入进去，而且 set 容器里的元素 <strong>自动从小到大排序</strong>。<strong>即：set 里面的元素 不重复且有序。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="comment">//初始化定义</span></span><br><span class="line">set&lt;<span class="type">int</span>&gt; s;</span><br></pre></td></tr></table></figure><h2 id="7-2-函数方法"><a href="#7-2-函数方法" class="headerlink" title="7.2 函数方法"></a>7.2 函数方法</h2><table><thead><tr><th>代码</th><th>复杂度</th><th>含义</th></tr></thead><tbody><tr><td><code>s.begin()</code></td><td>O(1)</td><td>返回 set 容器的第一个元素的地址（迭代器）</td></tr><tr><td><code>s.end()</code></td><td>O(1)</td><td>返回 set 容器的最后一个元素的下一个地址（迭代器）</td></tr><tr><td><code>s.rbegin()</code></td><td>O(1)</td><td>返回逆序迭代器，指向容器元素最后一个位置</td></tr><tr><td><code>s.rend()</code></td><td>O(1)</td><td>返回逆序迭代器，指向容器第一个元素前面的位置</td></tr><tr><td><code>s.clear()</code></td><td>O(N)</td><td>删除 set 容器中的所有的元素, 无返回值</td></tr><tr><td><code>s.empty()</code></td><td>O(1)</td><td>判断 set 容器是否为空</td></tr><tr><td><code>s.insert(element)</code></td><td>O(logN)</td><td>插入一个元素</td></tr><tr><td><code>s.size()</code></td><td>O(1)</td><td>返回当前 set 容器中的元素个数</td></tr><tr><td><code>erase(iterator)</code></td><td>O(logN)</td><td>删除定位器 iterator 指向的值</td></tr><tr><td><code>erase(first, second）</code></td><td></td><td>删除定位器 first 和 second 之间的值</td></tr><tr><td><code>erase(key_value)</code></td><td>O(logN)</td><td>删除键值 key_value 的值</td></tr><tr><td>查找</td><td></td><td></td></tr><tr><td><code>s.find(element)</code></td><td></td><td>查找 set 中的某一元素，有则返回该元素对应的迭代器，无则返回结束迭代器</td></tr><tr><td><code>s.count(element)</code></td><td></td><td>查找 set 中的元素出现的个数，由于 set 中元素唯一，此函数相当于查询 element 是否出现</td></tr><tr><td><code>s.lower_bound(k)</code></td><td>O(logN)</td><td>返回大于等于 k 的第一个元素的迭代器</td></tr><tr><td><code>s.upper_bound(k)</code></td><td>O(logN)</td><td>返回大于 k 的第一个元素的迭代器</td></tr></tbody></table><h2 id="7-3-元素访问"><a href="#7-3-元素访问" class="headerlink" title="7.3 元素访问"></a>7.3 元素访问</h2><ul><li><strong>迭代器访问</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(set&lt;<span class="type">int</span>&gt;::iterator it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>智能指针</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i : s)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>访问最后一个元素</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一种</span></span><br><span class="line">cout &lt;&lt; *s.<span class="built_in">rbegin</span>() &lt;&lt; endl;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//第二种</span></span><br><span class="line">set&lt;<span class="type">int</span>&gt;::iterator iter = s.<span class="built_in">end</span>();</span><br><span class="line">iter--;</span><br><span class="line">cout &lt;&lt; (*iter) &lt;&lt; endl; <span class="comment">//打印 2;</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第三种</span></span><br><span class="line">cout &lt;&lt; *(--s.<span class="built_in">end</span>()) &lt;&lt; endl;</span><br></pre></td></tr></table></figure><h2 id="7-4-重载-运算符"><a href="#7-4-重载-运算符" class="headerlink" title="7.4 重载 &lt; 运算符"></a>7.4 重载 &lt; 运算符</h2><ul><li><strong>基础数据类型</strong></li></ul><p>方式一：改变 set 排序规则，set 中默认使用 less 比较器，即从小到大排序。（常用）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set&lt;<span class="type">int</span>&gt; s1; <span class="comment">// 默认从小到大排序</span></span><br><span class="line">set&lt;<span class="type">int</span>, greater&lt;<span class="type">int</span>&gt; &gt; s2;  <span class="comment">// 从大到小排序</span></span><br></pre></td></tr></table></figure><p>方式二：重载运算符。（很麻烦，不太常用，没必要）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//重载 &lt; 运算符</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cmp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span> <span class="params">()</span> <span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; u, <span class="type">const</span> <span class="type">int</span>&amp; v)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">       <span class="comment">// return + 返回条件</span></span><br><span class="line">       <span class="keyword">return</span> u &gt; v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">set&lt;<span class="type">int</span>, cmp&gt; s; </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">s.<span class="built_in">insert</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i : s)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 10 9 8 7 6 5 4 3 2 1</span></span><br></pre></td></tr></table></figure><p>方式三：初始化时使用匿名函数定义比较规则</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">set&lt;<span class="type">int</span>, function&lt;<span class="type">bool</span>(<span class="type">int</span>, <span class="type">int</span>)&gt;&gt; <span class="built_in">s</span>([&amp;](<span class="type">int</span> i, <span class="type">int</span> j)&#123;</span><br><span class="line">    <span class="keyword">return</span> i &gt; j; <span class="comment">// 从大到小</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">s.<span class="built_in">insert</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> x : s)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>高级数据类型（结构体）</strong></li></ul><p>直接重载结构体运算符即可，让结构体可以比较。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> x, y;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> Point &amp;p) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line"><span class="comment">// 按照点的横坐标从小到大排序, 如果横坐标相同, 纵坐标从小到大</span></span><br><span class="line"><span class="keyword">if</span>(x == p.x)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> y &lt; p.y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> x &lt; p.x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">set&lt;Point&gt; s;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    s.<span class="built_in">insert</span>(&#123;x, y&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 输入</span></span><br><span class="line"><span class="comment">5 4</span></span><br><span class="line"><span class="comment">5 2</span></span><br><span class="line"><span class="comment">3 7</span></span><br><span class="line"><span class="comment">3 5</span></span><br><span class="line"><span class="comment">4 8</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i : s)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; i.x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; i.y &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 输出</span></span><br><span class="line"><span class="comment">3 5</span></span><br><span class="line"><span class="comment">3 7</span></span><br><span class="line"><span class="comment">4 8</span></span><br><span class="line"><span class="comment">5 2</span></span><br><span class="line"><span class="comment">5 4</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="7-5-multiset"><a href="#7-5-multiset" class="headerlink" title="7.5 multiset"></a>7.5 multiset</h2><p><strong><code>multiset</code> ：元素可以重复，且元素有序（默认升序）。</strong></p><ul><li>注意点一：方法函数基本和 <code>set</code> 一样，参考 set 即可。</li><li>注意点二：进行删除操作时，要明确删除目标。（ 下面 <code>s</code> 为声明的 multiset 变量名）。<ul><li>删除多个元素：由于元素可以重复，注意使用 <code>s.erase(val)</code> 方法时，会删除掉所有与 <code>val</code> 相等的元素。</li><li>删除一个元素：需要删除一个元素时，需要使用 <code>s.erase(s.find(val))</code> 操作，先找到一个与 <code>val</code> 相等的元素迭代器，专门删除这个元素。</li></ul></li><li>注意点三：头文件操作为 <code>#include&lt;set&gt;</code>。</li></ul><ol><li><strong><code>unordered_set</code> ：元素无序且只能出现一次。</strong></li><li><strong><code>unordered_multiset</code> ：元素无序可以出现多次。</strong></li></ol><table><thead><tr><th>操作</th><th>示例</th><th>说明</th></tr></thead><tbody><tr><td>插入元素</td><td><code>ms.insert(5);</code></td><td>O(log n)</td></tr><tr><td>删除单个元素（只删一个）</td><td><code>ms.erase(ms.find(5));</code></td><td>只删一个 5</td></tr><tr><td>删除所有某值元素</td><td><code>ms.erase(5);</code></td><td>删除所有等于 5 的元素</td></tr><tr><td>计数某值出现次数</td><td><code>ms.count(5);</code></td><td>返回值为 <code>size_t</code></td></tr><tr><td>查找元素</td><td><code>ms.find(5);</code></td><td>返回迭代器，找不到返回 <code>ms.end()</code></td></tr><tr><td>最小值</td><td><code>*ms.begin()</code></td><td>第一个元素</td></tr><tr><td>最大值</td><td><code>*ms.rbegin()</code></td><td>最后一个元素（反向迭代器）</td></tr><tr><td>判断是否为空</td><td><code>ms.empty()</code></td><td>是否无元素</td></tr><tr><td>获取元素个数</td><td><code>ms.size()</code></td><td>总元素数（含重复）</td></tr></tbody></table><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span>                  <span class="comment">// 包含 multiset 所在头文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    multiset&lt;<span class="type">int</span>&gt; ms;           <span class="comment">// 声明一个默认升序的 multiset &lt;int&gt;</span></span><br><span class="line">    <span class="comment">// multiset &lt;int, greater&lt;int&gt; &gt; ms;  // 声明一个降序 multiset</span></span><br><span class="line">    ms.<span class="built_in">insert</span>(<span class="number">5</span>);</span><br><span class="line">    ms.<span class="built_in">insert</span>(<span class="number">3</span>);</span><br><span class="line">    ms.<span class="built_in">insert</span>(<span class="number">7</span>);</span><br><span class="line">    ms.<span class="built_in">insert</span>(<span class="number">5</span>);               <span class="comment">// 重复插入也是允许的</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : ms)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;       <span class="comment">// 遍历输出：3 5 5 7</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">一个升序的 multiset 可以实现: <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">3</span> <span class="number">5</span></span><br><span class="line">一个降序的 multiset 可以实现: <span class="number">5</span> <span class="number">3</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><h1 id="8-pair"><a href="#8-pair" class="headerlink" title="8. pair"></a>8. pair</h1><h2 id="8-1-介绍"><a href="#8-1-介绍" class="headerlink" title="8.1 介绍"></a>8.1 介绍</h2><p>pair 只含有两个元素，可以看作是只有两个元素的结构体。</p><p><strong>应用：</strong></p><ul><li>代替二元结构体</li><li>作为 map 键值对进行插入（代码如下）</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span>  <span class="comment">// 定义 std:: pair 所在的头文件</span></span></span><br><span class="line">map&lt;string, <span class="type">int</span>&gt;mp;</span><br><span class="line">mp.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;string, <span class="type">int</span>&gt;(<span class="string">&quot;xingmaqi&quot;</span>, <span class="number">1</span>));</span><br><span class="line"><span class="comment">// mp.insert(make_pair(&quot;xingmaqi&quot;, 1));</span></span><br><span class="line"><span class="comment">// mp.insert(&#123;&quot;xingmaqi&quot;, 1&#125;);</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.初始化定义</span></span><br><span class="line"><span class="function">pair&lt;string, <span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="string">&quot;wangyaqi&quot;</span>, <span class="number">1</span>)</span></span>;  <span class="comment">//带初始值的</span></span><br><span class="line">pair&lt;string, <span class="type">int</span>&gt; p;<span class="comment">//不带初始值的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.赋值</span></span><br><span class="line">p = &#123;<span class="string">&quot;wang&quot;</span>, <span class="number">18</span>&#125;;</span><br><span class="line">p = <span class="built_in">make_pair</span>(<span class="string">&quot;wang&quot;</span>, <span class="number">18</span>);</span><br><span class="line">p = <span class="built_in">pair</span>&lt;string, <span class="type">int</span>&gt;(<span class="string">&quot;wang&quot;</span>, <span class="number">18</span>);</span><br></pre></td></tr></table></figure><h2 id="8-2-访问"><a href="#8-2-访问" class="headerlink" title="8.2 访问"></a>8.2 访问</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义结构体数组</span></span><br><span class="line">pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; p[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//和结构体类似，first 代表第一个元素，second 代表第二个元素</span></span><br><span class="line">cout &lt;&lt; p[i].first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; p[i].second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="9-string"><a href="#9-string" class="headerlink" title="9. string"></a>9. string</h1><h2 id="9-1-介绍"><a href="#9-1-介绍" class="headerlink" title="9.1 介绍"></a>9.1 介绍</h2><p>string 是一个字符串类，和 <code>char</code> 型字符串类似。可以把 string 理解为一个字符串类型，像 int 一样可以定义。需要注意的是 string 类型结尾 <strong>不包含 <code>/0</code>！</strong></p><h2 id="9-2-初始化及定义"><a href="#9-2-初始化及定义" class="headerlink" title="9.2 初始化及定义"></a>9.2 初始化及定义</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.</span></span><br><span class="line">string str1;                 <span class="comment">//生成空字符串</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.</span></span><br><span class="line"><span class="function">string <span class="title">str2</span><span class="params">(<span class="string">&quot;123456789&quot;</span>)</span></span>;           <span class="comment">//生成 &quot;1234456789&quot; 的复制品 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3.</span></span><br><span class="line"><span class="function">string <span class="title">str3</span><span class="params">(<span class="string">&quot;12345&quot;</span>, <span class="number">0</span>, <span class="number">3</span>)</span></span>;         <span class="comment">//结果为 &quot;123&quot; ，从 0 位置开始，长度为 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//4.</span></span><br><span class="line"><span class="function">string <span class="title">str4</span><span class="params">(<span class="string">&quot;123456&quot;</span>, <span class="number">5</span>)</span></span>;           <span class="comment">//结果为 &quot;12345&quot; ，长度为 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//5.</span></span><br><span class="line"><span class="function">string <span class="title">str5</span><span class="params">(<span class="number">5</span>, <span class="string">&#x27;2&#x27;</span>)</span></span>;                <span class="comment">//结果为 &quot;22222&quot; , 构造 5 个字符&#x27;2&#x27;连接而成的字符串</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//6.</span></span><br><span class="line"><span class="function">string <span class="title">str6</span><span class="params">(str2, <span class="number">2</span>)</span></span>;               <span class="comment">//结果为 &quot;3456789&quot;，截取第三个元素（2 对应第三位）到最后</span></span><br></pre></td></tr></table></figure><p><strong>简单使用</strong></p><ul><li>访问单个字符：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">string s = <span class="string">&quot;xing ma qi!!!&quot;</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; s[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>string</code> 数组使用：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">string s[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">s[i] = <span class="string">&quot;loading...  &quot;</span> ;</span><br><span class="line">cout &lt;&lt; s[i] &lt;&lt; i &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">loading...  <span class="number">1</span></span><br><span class="line">loading...  <span class="number">2</span></span><br><span class="line">loading...  <span class="number">3</span></span><br><span class="line">loading...  <span class="number">4</span></span><br><span class="line">loading...  <span class="number">5</span></span><br><span class="line">loading...  <span class="number">6</span></span><br><span class="line">loading...  <span class="number">7</span></span><br><span class="line">loading...  <span class="number">8</span></span><br><span class="line">loading...  <span class="number">9</span></span><br></pre></td></tr></table></figure><h2 id="9-3-string-特性"><a href="#9-3-string-特性" class="headerlink" title="9.3 string 特性"></a>9.3 string 特性</h2><ul><li><p>支持 <strong>比较</strong> 运算符<br>  string 字符串支持常见的比较操作符 <code>（&gt;,&gt;=,&lt;,&lt;=,==,!=）</code>，支持 <code>string</code> 与 <code>C-string</code> 的比较（如 <code>str &lt; &quot;hello&quot;</code>）。在使用 <code>&gt;,&gt;=,&lt;,&lt;=</code> 这些操作符的时候是根据“当前字符特性”将字符按 <code>字典顺序</code> 进行逐一的比较。字典排序靠前的字符小， 比较的顺序是从前向后比较，遇到不相等的字符就按这个位置上的两个字符的比较结果确定两个字符串的大小（前面减后面）。同时，<code>string (&quot;aaaa&quot;) &lt;string(aaaaa)</code>。</p></li><li><p>支持 <code>+</code> <strong>运算</strong> 符，代表拼接字符串，string 字符串可以拼接，通过 “+” 运算符进行拼接。</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string s1 = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">string s2 = <span class="string">&quot;456&quot;</span>;</span><br><span class="line">string s = s1 + s2;</span><br><span class="line">cout &lt;&lt; s;   <span class="comment">//123456</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="9-4-读入详解"><a href="#9-4-读入详解" class="headerlink" title="9.4 读入详解"></a>9.4 读入详解</h2><p><strong>读入字符串，遇空格，回车结束</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string s;</span><br><span class="line">cin &gt;&gt; s;</span><br></pre></td></tr></table></figure><p><strong>读入一行字符串（包括空格），遇回车结束</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string s;</span><br><span class="line"><span class="built_in">getline</span>(cin, s);</span><br></pre></td></tr></table></figure><p>注意: <code>getline(cin, s)</code> 会获取前一个输入的换行符，需要在前面添加读取换行符的语句。如：<code>getchar()</code> 或 <code>cin.get()</code></p><p>错误读取：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;</span><br><span class="line">string s;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="built_in">getline</span>(cin, s); <span class="comment">//此时读取相当于读取了前一个回车字符</span></span><br></pre></td></tr></table></figure><p>正确读取：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;</span><br><span class="line">string s;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="built_in">getchar</span>(); <span class="comment">//cin.get()</span></span><br><span class="line"><span class="built_in">getline</span>(cin, s);<span class="comment">//可正确读入下一行的输入</span></span><br></pre></td></tr></table></figure><blockquote><p><code>cin</code> 与 <code>cin.getline()</code> 混用</p><p>cin 输入完后，回车，cin 遇到回车结束输入，但回车还在输入流中，cin 并不会清除，导致 <code>getline()</code> 读取回车，结束。<br>需要在 cin 后面加 <code>cin.ignore()</code>；主动删除输入流中的换行符。（不常用）</p></blockquote><p><strong>cin 和 cout 解锁（关闭同步流）</strong></p><p>代码（写在 main 函数开头）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="number">0</span>),cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><blockquote><p>为什么要进行 <code>cin</code> 和 <code>cout</code> 的解锁，原因是：</p><p>在一些题目中，读入的 <strong>数据量很大</strong>，往往超过了 1e5（105）的数据量, 而 <code>cin</code> 和 <code>cout</code> 的读入输出的速度 <strong>很慢</strong>（是因为 <code>cin</code> 和 <code>cout</code> 为了兼容 C 语言的读入输出在性能上做了妥协），远不如 <code>scanf</code> 和 <code>printf</code> 的速度，具体原因可以搜索相关的博客进行了解。</p><p><strong>所以</strong> 对 <code>cin</code> 和 <code>cout</code> 进行解锁使 <code>cin</code> 和 <code>cout</code> 的速度几乎接近 <code>scanf</code> 和 <code>printf</code>，避免输入输出超时。</p></blockquote><p><strong>注意：<code>cin cout</code> 解锁使用时，不能与 <code>scanf、getchar、printf、cin、getline()</code> 混用，一定要注意，会出错。</strong></p><blockquote><p><strong>string 与 C 语言字符串（C-string）的区别</strong></p><ul><li>string：是 C++的一个类，专门实现字符串的相关操作。具有丰富的操作方法，数据类型为 <code>string</code>，字符串结尾没有 <code>\0</code> 字符。</li><li>C-string：C 语言中的字符串，用 char 数组实现，类型为 <code>const char *</code>, 字符串结尾以 <code>\0</code> 结尾。</li></ul></blockquote><p><strong>一般来说 string 向 char 数组转换会出现一些问题，所以为了能够实现转换，string 有一个方法 <code>c_str()</code> 实现 string 向 char 数组的转换。这个在项目中还算比较常用。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string s = <span class="string">&quot;xing ma qi&quot;</span>;</span><br><span class="line"><span class="type">char</span> s2[] = s.<span class="built_in">c_str</span>();</span><br></pre></td></tr></table></figure><h2 id="9-5-函数方法"><a href="#9-5-函数方法" class="headerlink" title="9.5 函数方法"></a>9.5 函数方法</h2><ul><li><strong>获取字符串长度</strong></li></ul><table><thead><tr><th>代码</th><th>含义</th></tr></thead><tbody><tr><td><code>s.size()</code> 和 <code>s.length()</code></td><td>返回 string 对象的字符个数，他们执行效果相同。</td></tr><tr><td><code>s.max_size()</code></td><td>返回 string 对象最多包含的字符数，超出会抛出 length_error 异常</td></tr><tr><td><code>s.capacity()</code></td><td>重新分配内存之前，string 对象能包含的最大字符数</td></tr></tbody></table><ul><li><strong>插入</strong></li></ul><table><thead><tr><th>代码</th><th>含义</th></tr></thead><tbody><tr><td><code>s.push_back()</code></td><td>在末尾插入</td></tr><tr><td>例：<code>s.push_back(&#39;a&#39;)</code></td><td>末尾插入一个字符 a</td></tr><tr><td><code>s.insert(pos,element)</code></td><td>在 pos 位置插入 element</td></tr><tr><td>例：<code>s.insert(s.begin(),&#39;1&#39;)</code></td><td>在第一个位置插入 1 字符</td></tr><tr><td><code>s.append(str)</code></td><td>在 s 字符串结尾添加 str 字符串</td></tr><tr><td>例：<code>s.append(&quot;abc&quot;)</code></td><td>在 s 字符串末尾添加字符串“abc”</td></tr></tbody></table><ul><li><strong>删除</strong></li></ul><table><thead><tr><th>代码</th><th>含义</th></tr></thead><tbody><tr><td><code>erase(iterator p)</code></td><td>删除字符串中 p 所指的字符</td></tr><tr><td><code>erase(iterator first, iterator last)</code></td><td>删除字符串中迭代器区间 <code>[first,last)</code> 上所有字符</td></tr><tr><td><code>erase(pos, len)</code></td><td>删除字符串中从索引位置 pos 开始的 len 个字符</td></tr><tr><td><code>clear()</code></td><td>删除字符串中所有字符</td></tr></tbody></table><ul><li><strong>字符替换</strong></li></ul><table><thead><tr><th>代码</th><th>含义</th></tr></thead><tbody><tr><td><code>s.replace(pos,n,str)</code></td><td>把当前字符串从索引 pos 开始的 n 个字符替换为 str</td></tr><tr><td><code>s.replace(pos,n,n1,c)</code></td><td>把当前字符串从索引 pos 开始的 n 个字符替换为 n1 个字符 c</td></tr><tr><td><code>s.replace(it1,it2,str)</code></td><td>把当前字符串 <code>[it1,it2)</code> 区间替换为 str <strong>it1 , it2 为迭代器哦</strong></td></tr></tbody></table><ul><li><strong>大小写转换</strong></li></ul><p>法一：</p><table><thead><tr><th>代码</th><th>含义</th></tr></thead><tbody><tr><td><code>tolower(s[i])</code></td><td>转换为小写</td></tr><tr><td><code>toupper(s[i])</code></td><td>转换为大写</td></tr></tbody></table><p>法二：</p><p>通过 STL 的 <code>transform</code> 算法配合 <code>tolower</code> 和 <code>toupper</code> 实现。<br>有 4 个参数，前 2 个指定要转换的容器的起止范围，第 3 个参数是结果存放容器的起始位置，第 4 个参数是一元运算。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string s;</span><br><span class="line"><span class="built_in">transform</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>(),s.<span class="built_in">begin</span>(),::tolower);<span class="comment">//转换小写</span></span><br><span class="line"><span class="built_in">transform</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>(),s.<span class="built_in">begin</span>(),::toupper);<span class="comment">//转换大写</span></span><br></pre></td></tr></table></figure><ul><li><strong>分割</strong></li></ul><table><thead><tr><th>代码</th><th>含义</th></tr></thead><tbody><tr><td><code>s.substr(pos,n)</code></td><td>截取从 pos 索引开始的 n 个字符</td></tr></tbody></table><ul><li><strong>查找</strong></li></ul><table><thead><tr><th>代码</th><th>含义</th></tr></thead><tbody><tr><td><code>s.find (str, pos)</code></td><td>在当前字符串的 pos 索引位置（默认为 0）开始，查找子串 str，返回找到的位置索引，-1 表示查找不到子串</td></tr><tr><td><code>s.find (c, pos)</code></td><td>在当前字符串的 pos 索引位置（默认为 0）开始，查找字符 c，返回找到的位置索引，-1 表示查找不到字符</td></tr><tr><td><code>s.rfind (str, pos)</code></td><td>在当前字符串的 pos 索引位置开始，反向查找子串 s，返回找到的位置索引，-1 表示查找不到子串</td></tr><tr><td><code>s.rfind (c,pos)</code></td><td>在当前字符串的 pos 索引位置开始，反向查找字符 c，返回找到的位置索引，-1 表示查找不到字符</td></tr><tr><td><code>s.find_first_of (str, pos)</code></td><td>在当前字符串的 pos 索引位置（默认为 0）开始，查找子串 s 的字符，返回找到的位置索引，-1 表示查找不到字符</td></tr><tr><td><code>s.find_first_not_of (str,pos)</code></td><td>在当前字符串的 pos 索引位置（默认为 0）开始，查找第一个不位于子串 s 的字符，返回找到的位置索引，-1 表示查找不到字符</td></tr><tr><td><code>s.find_last_of(str, pos)</code></td><td>在当前字符串的 pos 索引位置开始，查找最后一个位于子串 s 的字符，返回找到的位置索引，-1 表示查找不到字符</td></tr><tr><td><code>s.find_last_not_of ( str, pos)</code></td><td>在当前字符串的 pos 索引位置开始，查找最后一个不位于子串 s 的字符，返回找到的位置索引，-1 表示查找不到子串</td></tr></tbody></table><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">string <span class="title">s</span><span class="params">(<span class="string">&quot;dog bird chicken bird cat&quot;</span>)</span></span>;</span><br><span class="line">    <span class="comment">//字符串查找-----找到后返回首字母在字符串中的下标</span></span><br><span class="line">    <span class="comment">// 1. 查找一个字符串</span></span><br><span class="line">    cout &lt;&lt; s.<span class="built_in">find</span>(<span class="string">&quot;chicken&quot;</span>) &lt;&lt; endl;              <span class="comment">// 结果是：9</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 从下标为 6 开始找字符&#x27;i&#x27;，返回找到的第一个 i 的下标</span></span><br><span class="line">    cout &lt;&lt; s.<span class="built_in">find</span>(<span class="string">&#x27;i&#x27;</span>, <span class="number">6</span>) &lt;&lt; endl;                 <span class="comment">// 结果是：11</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 从字符串的末尾开始查找字符串，返回的还是首字母在字符串中的下标</span></span><br><span class="line">    cout &lt;&lt; s.<span class="built_in">rfind</span>(<span class="string">&quot;chicken&quot;</span>) &lt;&lt; endl;             <span class="comment">// 结果是：9</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 从字符串的末尾开始查找字符</span></span><br><span class="line">    cout &lt;&lt; s.<span class="built_in">rfind</span>(<span class="string">&#x27;i&#x27;</span>) &lt;&lt; endl;                   <span class="comment">// 结果是：18 因为是从末尾开始查找，所以返回第一次找到的字符</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 在该字符串中查找第一个属于字符串 s 的字符</span></span><br><span class="line">    cout &lt;&lt; s.<span class="built_in">find_first_of</span>(<span class="string">&quot;13br98&quot;</span>) &lt;&lt; endl;      <span class="comment">// 结果是：4---b</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 在该字符串中查找第一个不属于字符串 s 的字符------先匹配 dog，然后 bird 匹配不到，所以打印 4</span></span><br><span class="line">    cout &lt;&lt; s.<span class="built_in">find_first_not_of</span>(<span class="string">&quot;hello dog 2006&quot;</span>) &lt;&lt; endl;      <span class="comment">// 结果是：4</span></span><br><span class="line">    cout &lt;&lt; s.<span class="built_in">find_first_not_of</span>(<span class="string">&quot;dog bird 2006&quot;</span>) &lt;&lt; endl;       <span class="comment">// 结果是：9</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7. 在该字符串最后中查找第一个属于字符串 s 的字符</span></span><br><span class="line">    cout &lt;&lt; s.<span class="built_in">find_last_of</span>(<span class="string">&quot;13r98&quot;</span>) &lt;&lt; endl;        <span class="comment">// 结果是：19</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 8. 在该字符串最后中查找第一个不属于字符串 s 的字符------先匹配 t--a---c，然后空格匹配不到，所以打印 21</span></span><br><span class="line">    cout &lt;&lt; s.<span class="built_in">find_last_not_of</span>(<span class="string">&quot;teac&quot;</span>) &lt;&lt; endl;     <span class="comment">// 结果是：21</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong><code>std::string::npos</code> 是一个静态常量，用来表示 “未找到” 的情况。</strong> 它的类型是 <strong><code>size_t</code></strong>，本质上就是一个无符号整数。官方定义大概是这样的：<code>static const size_t npos = -1;</code>，也就是说，它是 <code>size_t</code> 类型能表示的最大值。</p><ul><li><strong><code>string::npos</code> &#x3D; <code>size_t(-1)</code> &#x3D; <code>size_t</code> 最大值。</strong></li><li><strong>它专门用来表示字符串操作中的 “没找到”。</strong></li><li>推荐写法：<code>if (pos == string::npos)</code>。常用于：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="type">size_t</span> pos = s.<span class="built_in">find</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">&gt;<span class="keyword">if</span> (pos == string::npos)</span><br><span class="line">&gt;&#123;</span><br><span class="line">   <span class="comment">// 表示没找到</span></span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><ul><li><strong><code>string::npos</code> ≈ 特殊的下标（无效下标）</strong>。</li><li><strong><code>x.end()</code> ≈ 特殊的迭代器（无效迭代器）</strong>。</li></ul><p>它们的角色类似，都是“查找失败的标志”，但类型不同，不能混用。</p><hr><p>为什么值等于 -1？</p><ul><li><code>size_t</code> 是 <strong>无符号类型</strong>（一般是 64 位机器上 <code>unsigned long long</code>）。</li><li>把 <code>-1</code> 转成无符号数时，会发生“模 2^n” 的转换。<br>举例：</li><li>假设 <code>size_t</code> 是 32 位 → <code>-1</code> 会变成 <code>4294967295</code>。</li><li>假设 <code>size_t</code> 是 64 位 → <code>-1</code> 会变成 <code>18446744073709551615</code>。</li></ul><p>所以说 <code>string::npos</code> 的底层数值确实就是 <code>-1</code> 转成无符号整数后的结果，即“最大可能值”。</p></blockquote><ul><li><strong>排序</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sort</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>());  <span class="comment">//按 ASCII 码排序</span></span><br></pre></td></tr></table></figure><h1 id="10-bitset"><a href="#10-bitset" class="headerlink" title="10. bitset"></a>10. bitset</h1><h2 id="10-1-介绍"><a href="#10-1-介绍" class="headerlink" title="10.1 介绍"></a>10.1 介绍</h2><p>bitset 在 bitset 头文件中，它类似数组，并且每一个元素只能是 ０ 或 １，每个元素只用 １bit 空间。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="10-2-初始化定义"><a href="#10-2-初始化定义" class="headerlink" title="10.2 初始化定义"></a>10.2 初始化定义</h2><p>初始化方法：</p><table><thead><tr><th>代码</th><th>含义</th></tr></thead><tbody><tr><td><code>bitset&lt;n&gt; a</code></td><td>a 有 n 位，每位都为 0</td></tr><tr><td><code>bitset&lt;n&gt; a(b)</code></td><td>a 是 unsigned long 型 u 的一个副本</td></tr><tr><td><code>bitset&lt;n&gt; a(s)</code></td><td>a 是 string 对象 s 中含有的位串的副本</td></tr><tr><td><code>bitset&lt;n&gt; a(s, pos, n)</code></td><td>a 是 s 中从位置 pos 开始的 n 个位的副本</td></tr></tbody></table><blockquote><p>注意：<code>n</code> 必须为常量表达式！</p></blockquote><p>演示代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bitset&lt;4&gt; bitset1;　　        <span class="comment">//无参构造，长度为 ４，默认每一位为 0</span></span><br><span class="line"></span><br><span class="line">    <span class="function">bitset&lt;9&gt; <span class="title">bitset2</span><span class="params">(<span class="number">12</span>)</span></span>;　      <span class="comment">//长度为 9，二进制保存，前面用 0 补充</span></span><br><span class="line"></span><br><span class="line">    string s = <span class="string">&quot;100101&quot;</span>;</span><br><span class="line">    <span class="function">bitset&lt;10&gt; <span class="title">bitset3</span><span class="params">(s)</span></span>;　　    <span class="comment">//长度为 10，前面用 0 补充</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> s2[] = <span class="string">&quot;10101&quot;</span>;</span><br><span class="line">    <span class="function">bitset&lt;13&gt; <span class="title">bitset4</span><span class="params">(s2)</span></span>;　　   <span class="comment">//长度为 13，前面用 0 补充</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; bitset1 &lt;&lt; endl;　　  <span class="comment">//0000</span></span><br><span class="line">    cout &lt;&lt; bitset2 &lt;&lt; endl;　　  <span class="comment">//000001100</span></span><br><span class="line">    cout &lt;&lt; bitset3 &lt;&lt; endl;　　  <span class="comment">//0000100101</span></span><br><span class="line">    cout &lt;&lt; bitset4 &lt;&lt; endl;　    <span class="comment">//0000000010101</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-3-特性"><a href="#10-3-特性" class="headerlink" title="10.3 特性"></a>10.3 特性</h2><p><code>bitset</code> 可以进行 <strong>位操作</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">bitset&lt;4&gt; <span class="title">foo</span><span class="params">(string(<span class="string">&quot;1001&quot;</span>))</span></span>;</span><br><span class="line"><span class="function">bitset&lt;4&gt; <span class="title">bar</span><span class="params">(string(<span class="string">&quot;0011&quot;</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; (foo ^= bar) &lt;&lt; endl;       <span class="comment">// 1010 (foo 对 bar 按位异或后赋值给 foo)</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; (foo &amp;= bar) &lt;&lt; endl;       <span class="comment">// 0001 (按位与后赋值给 foo)</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; (foo |= bar) &lt;&lt; endl;       <span class="comment">// 1011 (按位或后赋值给 foo)</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; (foo &lt;&lt;= <span class="number">2</span>) &lt;&lt; endl;        <span class="comment">// 0100 (左移 2 位，低位补 0，有自身赋值)</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; (foo &gt;&gt;= <span class="number">1</span>) &lt;&lt; endl;        <span class="comment">// 0100 (右移 1 位，高位补 0，有自身赋值)</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; (~bar) &lt;&lt; endl;             <span class="comment">// 1100 (按位取反)</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; (bar &lt;&lt; <span class="number">1</span>) &lt;&lt; endl;         <span class="comment">// 0110 (左移，不赋值)</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; (bar &gt;&gt; <span class="number">1</span>) &lt;&lt; endl;         <span class="comment">// 0001 (右移，不赋值)</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; (foo == bar) &lt;&lt; endl;       <span class="comment">// false (1001 == 0011 为 false)</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; (foo != bar) &lt;&lt; endl;       <span class="comment">// true  (1001!= 0011 为 true)</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; (foo &amp; bar) &lt;&lt; endl;        <span class="comment">// 0001 (按位与，不赋值)</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; (foo | bar) &lt;&lt; endl;        <span class="comment">// 1011 (按位或，不赋值)</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; (foo ^ bar) &lt;&lt; endl;        <span class="comment">// 1010 (按位异或，不赋值)</span></span><br></pre></td></tr></table></figure><p><strong>访问：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可以通过 [] 访问元素(类似数组)，注意最低位下标为 0，类似于数的二进制表示，如下：</span></span><br><span class="line"><span class="function">bitset&lt;4&gt; <span class="title">f</span><span class="params">(<span class="string">&quot;1011&quot;</span>)</span></span>; </span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; f[i];<span class="comment">// 输出 1101</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-4-方法函数"><a href="#10-4-方法函数" class="headerlink" title="10.4 方法函数"></a>10.4 方法函数</h2><table><thead><tr><th>代码</th><th>含义</th></tr></thead><tbody><tr><td><code>b.any()</code></td><td>b 中是否存在置为 1 的二进制位，有 返回 true</td></tr><tr><td><code>b.none()</code></td><td>b 中是否没有 1，没有 返回 true</td></tr><tr><td><code>b.count()</code></td><td>b 中为 1 的个数</td></tr><tr><td><code>b.size()</code></td><td>b 中二进制位的个数</td></tr><tr><td><code>b.test(pos)</code></td><td>测试 b 在 pos 位置是否为 1，是 返回 true</td></tr><tr><td><code>b[pos]</code></td><td>返回 b 在 pos 处的二进制位</td></tr><tr><td><code>b.set()</code></td><td>把 b 中所有位都置为 1</td></tr><tr><td><code>b.set(pos)</code></td><td>把 b 中 pos 位置置为 1</td></tr><tr><td><code>b.reset()</code></td><td>把 b 中所有位都置为 0</td></tr><tr><td><code>b.reset(pos)</code></td><td>把 b 中 pos 位置置为 0</td></tr><tr><td><code>b.flip()</code></td><td>把 b 中所有二进制位取反</td></tr><tr><td><code>b.flip(pos)</code></td><td>把 b 中 pos 位置取反</td></tr><tr><td><code>b.to_ulong()</code></td><td>用 b 中同样的二进制位返回一个 unsigned long 值</td></tr></tbody></table><h2 id="10-5-bitset-优化"><a href="#10-5-bitset-优化" class="headerlink" title="10.5 bitset 优化"></a>10.5 bitset 优化</h2><p>一般会使用 bitset 来优化时间复杂度，大概时间复杂度会除 64 或 32，例如没有优化的时间复杂度为 O(NM) ，使用 bitset 优化后复杂度可能就为 O(NM&#x2F;64)或者 $O\left(\frac{NM}{64}\right)$。</p><p>bitset 还有开动态空间的技巧，bitset 常用在 <code>01 背包</code> 优化等算法中：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态长度 bitset 实现</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;              <span class="comment">// 开空间的上限，一般为数据范围附近的值</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> len = <span class="number">1</span>&gt;</span><br><span class="line"><span class="type">void</span> <span class="built_in">bitset_</span>(<span class="type">int</span> sz)    <span class="comment">// sz 即为想要开的大小</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (len &lt; sz)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">bitset_</span>&lt;<span class="built_in">min</span>(len * <span class="number">2</span>, N)&gt;(sz); <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bitset&lt;len + 1&gt; dp;</span><br><span class="line">    <span class="comment">// 具体算法的实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="11-array"><a href="#11-array" class="headerlink" title="11. array"></a>11. array</h1><h2 id="11-1-介绍"><a href="#11-1-介绍" class="headerlink" title="11.1 介绍"></a>11.1 介绍</h2><p>头文件 <code>#include &lt;array&gt;</code>。<code>array</code> 是 C++11 新增的容器，效率与普通数据相差无几，比 <code>vector</code> 效率要高，自身添加了一些成员函数。和其它容器不同，array 容器的大小是 <strong>固定</strong> 的，无法动态的扩展或收缩，<strong>只允许访问或者替换存储的元素。</strong></p><p><strong>注意：</strong> <code>array</code> 的使用要在 <code>std</code> 命名空间里。</p><h2 id="11-2-声明与初始化"><a href="#11-2-声明与初始化" class="headerlink" title="11.2 声明与初始化"></a>11.2 声明与初始化</h2><p><strong>基础数据类型</strong></p><p>声明一个大小为 100 的 <code>int</code> 型数组，元素的值不确定：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array&lt;<span class="type">int</span>, 100&gt; a;</span><br></pre></td></tr></table></figure><p>声明一个大小为 100 的 <code>int</code> 型数组，初始值均为 <code>0</code>(初始值与默认元素类型等效)：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array&lt;<span class="type">int</span>, 100&gt; a&#123;&#125;;</span><br></pre></td></tr></table></figure><p>声明一个大小为 100 的 <code>int</code> 型数组，初始化部分值，其余全部为 <code>0</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array&lt;<span class="type">int</span>, 100&gt; a&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure><p>或者可以用等号</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array&lt;<span class="type">int</span>, 100&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure><p><strong>高级数据类型</strong></p><p>不同于数组的是对元素类型不做要求，可以套结构体：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array&lt;string, 2&gt; s = &#123;<span class="string">&quot;ha&quot;</span>, <span class="built_in">string</span>(<span class="string">&quot;haha&quot;</span>)&#125;;</span><br><span class="line">array&lt;node, 2&gt; a;</span><br></pre></td></tr></table></figure><h2 id="11-3-存取元素"><a href="#11-3-存取元素" class="headerlink" title="11.3 存取元素"></a>11.3 存取元素</h2><ul><li>修改元素</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array&lt;<span class="type">int</span>, 4&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">a[<span class="number">0</span>] = <span class="number">4</span>;</span><br></pre></td></tr></table></figure><ul><li>访问元素</li></ul><p><strong>下标访问：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">array&lt;<span class="type">int</span>, 4&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) </span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; \n&quot;</span>[i == <span class="number">3</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>利用 <code>auto</code> 访问：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i : a)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>迭代器访问：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> it = a.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">for</span>(; it != a.<span class="built_in">end</span>(); it++) </span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>at()</code> 函数访问：</strong> 下标为 <code>1</code> 的元素加上下标为 <code>2</code> 的元素，答案为 <code>5</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array&lt;<span class="type">int</span>, 4&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="type">int</span> res = a.<span class="built_in">at</span>(<span class="number">1</span>) + a.<span class="built_in">at</span>(<span class="number">2</span>);</span><br><span class="line">cout &lt;&lt; res &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br></pre></td></tr></table></figure><p><strong><code>get</code> 方法访问：</strong> 将 <code>a</code> 数组下标为 <code>1</code> 位置处的值改为 <code>x</code>。注意：获取的下标只能写数字，不能填变量！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(a) = x;</span><br></pre></td></tr></table></figure><h2 id="11-4-成员函数"><a href="#11-4-成员函数" class="headerlink" title="11.4 成员函数"></a>11.4 成员函数</h2><table><thead><tr><th>成员函数</th><th>功能</th></tr></thead><tbody><tr><td><code>begin()</code></td><td>返回容器中第一个元素的访问迭代器（地址）</td></tr><tr><td><code>end()</code></td><td>返回容器最后一个元素之后一个位置的访问迭代器（地址）</td></tr><tr><td><code>rbegin()</code></td><td>返回最后一个元素的访问迭代器（地址）</td></tr><tr><td><code>rend()</code></td><td>返回第一个元素之前一个位置的访问迭代器（地址）</td></tr><tr><td><code>size()</code></td><td>返回容器中元素的数量，其值等于初始化 array 类的第二个模板参数 <code>N</code></td></tr><tr><td><code>max_size()</code></td><td>返回容器可容纳元素的最大数量，其值始终等于初始化 array 类的第二个模板参数 N</td></tr><tr><td><code>empty()</code></td><td>判断容器是否为空</td></tr><tr><td><code>at(n)</code></td><td>返回容器中 n 位置处元素的引用，函数会自动检查 n 是否在有效的范围内，如果不是则抛出 out_of_range 异常</td></tr><tr><td><code>front()</code></td><td>返回容器中第一个元素的直接引用，函数不适用于空的 array 容器</td></tr><tr><td><code>back()</code></td><td>返回容器中最后一个元素的直接引用，函数不适用于空的 array 容器。</td></tr><tr><td><code>data()</code></td><td>返回一个指向容器首个元素的指针。利用该指针，可实现复制容器中所有元素等类似功能</td></tr><tr><td><code>fill(x)</code></td><td>将 <code>x</code> 这个值赋值给容器中的每个元素, 相当于初始化</td></tr><tr><td><code>array1.swap(array2)</code></td><td>交换 array1 和 array2 容器中的所有元素，但前提是它们具有相同的长度和类型</td></tr></tbody></table><h2 id="11-5-部分用法示例"><a href="#11-5-部分用法示例" class="headerlink" title="11.5 部分用法示例"></a>11.5 部分用法示例</h2><p><code>data()</code>：指向底层元素存储的指针。对于非空容器，返回的指针与首元素地址比较相等。</p><p><code>at()</code></p><p>下标为 <code>1</code> 的元素加上下标为 <code>2</code> 的元素，答案为 <code>5</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array&lt;<span class="type">int</span>, 4&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="type">int</span> res = a.<span class="built_in">at</span>(<span class="number">1</span>) + a.<span class="built_in">at</span>(<span class="number">2</span>);</span><br><span class="line">cout &lt;&lt; res &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br></pre></td></tr></table></figure><p><code>fill()</code></p><p>array 的 <code>fill()</code> 函数，将 <code>a</code> 数组全部元素值变为 <code>x</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.<span class="built_in">fill</span>(x);</span><br></pre></td></tr></table></figure><p>另外还有其它的 <code>fill()</code> 函数: 将 <code>a</code> 数组 [begin, end) 全部值变为 <code>x</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fill</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), x);</span><br></pre></td></tr></table></figure><p><strong>get 方法获取元素值</strong></p><p>将 <code>a</code> 数组下标为 <code>1</code> 位置处的值改为 <code>x</code>，注意: 获取的下标只能写数字，不能填变量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(a) = x;</span><br></pre></td></tr></table></figure><p><strong>排序</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sort</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure><h1 id="12-tuple"><a href="#12-tuple" class="headerlink" title="12. tuple"></a>12. tuple</h1><h2 id="12-1-介绍"><a href="#12-1-介绍" class="headerlink" title="12.1 介绍"></a>12.1 介绍</h2><p>tuple 模板是 pair 的泛化，可以封装不同类型任意数量的对象。可以把 tuple 理解为 pair 的扩展，tuple 可以声明二元组，也可以声明三元组。tuple 可以等价为 <strong>结构体</strong> 使用。</p><p><strong>头文件</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="12-2-声明初始化"><a href="#12-2-声明初始化" class="headerlink" title="12.2 声明初始化"></a>12.2 声明初始化</h2><p>声明一个空的 <code>tuple</code> 三元组：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tuple&lt;<span class="type">int</span>, <span class="type">int</span>, string&gt; t1;</span><br></pre></td></tr></table></figure><p>赋值：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t1 = <span class="built_in">make_tuple</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="string">&quot;hahaha&quot;</span>);</span><br></pre></td></tr></table></figure><p>创建的同时初始化：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">tuple&lt;<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">t2</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>可以使用 pair 对象构造 tuple 对象，但 tuple 对象必须是两个元素：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> p = <span class="built_in">make_pair</span>(<span class="string">&quot;wang&quot;</span>, <span class="number">1</span>);</span><br><span class="line">tuple&lt;string, <span class="type">int</span>&gt; t3 &#123;p&#125;; <span class="comment">//将 pair 对象赋给 tuple 对象</span></span><br></pre></td></tr></table></figure><h2 id="12-3-元素操作"><a href="#12-3-元素操作" class="headerlink" title="12.3 元素操作"></a>12.3 元素操作</h2><p>获取 tuple 对象 <code>t</code> 的第一个元素：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> first = <span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(t);</span><br></pre></td></tr></table></figure><p>修改 tuple 对象 <code>t</code> 的第一个元素：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(t) = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h2 id="12-4-函数操作"><a href="#12-4-函数操作" class="headerlink" title="12.4 函数操作"></a>12.4 函数操作</h2><ul><li>获取元素个数</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">tuple&lt;<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">t</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; tuple_size&lt;<span class="keyword">decltype</span>(t)&gt;::value &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><ul><li>获取对应元素的值</li></ul><p>通过 <code>get&lt;n&gt;(obj)</code> 方法获取, <code>n</code> 必须为数字不能是变量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">tuple&lt;<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">t</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; <span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(t) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="comment">// 1</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(t) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="comment">// 2</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(t) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><ul><li>通过 <code>tie</code> 解包 获取元素值</li></ul><p><code>tie</code> 可以让 tuple 变量中的三个值依次赋到 tie 中的三个变量中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> one, three;</span><br><span class="line">string two; </span><br><span class="line"><span class="function">tuple&lt;<span class="type">int</span>, string, <span class="type">int</span>&gt; <span class="title">t</span><span class="params">(<span class="number">1</span>, <span class="string">&quot;hahaha&quot;</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line"><span class="built_in">tie</span>(one, two, three) = t;</span><br><span class="line">cout &lt;&lt; one &lt;&lt; two &lt;&lt; three &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">// 1hahaha3</span></span><br></pre></td></tr></table></figure><hr><h1 id="STL-函数"><a href="#STL-函数" class="headerlink" title="STL 函数"></a>STL 函数</h1><h2 id="sort-——-排序"><a href="#sort-——-排序" class="headerlink" title="sort —— 排序"></a>sort —— 排序</h2><p><strong>时间复杂度：</strong> O(N logN)</p><blockquote><p>作用：对一个序列进行排序</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原型：</span></span><br><span class="line"><span class="built_in">sort</span>(beg, end);</span><br><span class="line"><span class="built_in">sort</span>(beg, end, cmp);</span><br></pre></td></tr></table></figure><p>几种排序的常见操作：</p><ul><li>操作一：对数组正常升序排序</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[N]; <span class="comment">// 普通数组定义</span></span><br><span class="line"><span class="comment">// 对 a 数组的 [1, n] 位置进行从小到大排序</span></span><br><span class="line"><span class="built_in">sort</span>(a + <span class="number">1</span>, a + <span class="number">1</span> + n);</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">b</span><span class="params">(n + <span class="number">1</span>)</span></span>; <span class="comment">// vector 数组定义</span></span><br><span class="line"><span class="built_in">sort</span>(b.<span class="built_in">begin</span>() + <span class="number">1</span>, b.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure><ul><li>操作二：使用第三个参数，进行降序排序</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对 a 数组的 [0, n-1] 位置从大到小排序</span></span><br><span class="line"><span class="built_in">sort</span>(a, a + n, <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line"><span class="comment">//对 a 数组的 [0, n-1] 位置从小到大排序</span></span><br><span class="line"><span class="built_in">sort</span>(a, a + n, <span class="built_in">less</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">b</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="built_in">sort</span>(b.<span class="built_in">begin</span>() + <span class="number">1</span>, b.<span class="built_in">end</span>()); <span class="comment">// 升序</span></span><br><span class="line"><span class="built_in">sort</span>(b.<span class="built_in">begin</span>() + <span class="number">1</span>, b.<span class="built_in">end</span>(), <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;()); <span class="comment">// 降序</span></span><br></pre></td></tr></table></figure><ul><li>操作三：另外一种降序排序方法，针对 <code>vector</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line"><span class="built_in">sort</span>(a.<span class="built_in">rbegin</span>(), a.<span class="built_in">rend</span>()); <span class="comment">// 使用反向迭代器进行降序排序</span></span><br></pre></td></tr></table></figure><ul><li>操作四：自定义排序规则</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 使用函数自定义排序，定义比较函数</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(node a, node b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//按结构体里面的 x 值降序排列</span></span><br><span class="line">    <span class="keyword">return</span> a.x &gt; b.x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(node, node + n, cmp); <span class="comment">// 只能接受以函数为形式的自定义排序规则，无法接受以结构体为形式的自定义排序规则</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 或者使用匿名函数自定义排序规则</span></span><br><span class="line"><span class="built_in">sort</span>(node, node + n, [](node a, node b) &#123;</span><br><span class="line">    <span class="keyword">return</span> a.x &gt; b.x;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="stable-sort"><a href="#stable-sort" class="headerlink" title="stable_sort"></a>stable_sort</h3><p><strong>复杂度：</strong> O(N logN)</p><blockquote><p>功能和 <code>sort()</code> 基本一样，区别在于 <code>stable_sort()</code> 能够保证相等元素的相对位置，排序时不会改变相等元素的相对位置。</p></blockquote><p>使用用法和 <code>sort()</code> 一样，见上。</p><h3 id="is-sorted"><a href="#is-sorted" class="headerlink" title="is_sorted"></a>is_sorted</h3><p><strong>复杂度：</strong> O(N)</p><blockquote><p>判断序列是否有序（升序），返回 <code>bool</code> 值</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果序列有序，输出 YES</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">is_sorted</span>(a, a + n))</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;YES\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="iota"><a href="#iota" class="headerlink" title="iota"></a>iota</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">iota</span>(beg, end, start)</span><br></pre></td></tr></table></figure><blockquote><p>让序列递增赋值</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="built_in">iota</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i : a)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0 1 2 3 4 5 6 7 8 9</span></span><br></pre></td></tr></table></figure><h3 id="partial-sort"><a href="#partial-sort" class="headerlink" title="partial_sort"></a>partial_sort</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">partial_sort</span>(beg, mid, end)</span><br></pre></td></tr></table></figure><p><strong>时间复杂度：</strong> 大概 O(N logM) ，其中 <code>M</code> 为距离</p><blockquote><p>部分排序, 排序 mid-beg 个元素，mid 为要排序区间元素的尾后的一个位置</p><p>从 beg 到 mid <strong>前</strong> 的元素都排好序</p></blockquote><p>对 a 数组前 5 个元素排序按从小到大排序</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">6</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="built_in">partial_sort</span>(a, a + <span class="number">5</span>, a + <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; a[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1 2 3 4 5 9 8 10 7 6</span></span><br><span class="line"><span class="comment">//前五个元素都有序</span></span><br></pre></td></tr></table></figure><p>也可以添加自定义排序规则：</p><p><code>partial_sort(beg,mid,end,cmp)</code></p><p>对 a 的前五个元素都是降序排列</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">6</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="built_in">partial_sort</span>(a, a + <span class="number">5</span>, a + <span class="number">10</span>, <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) </span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; a[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//10 9 8 7 6 1 2 4 5 3</span></span><br><span class="line"><span class="comment">//前五个元素降序有序</span></span><br></pre></td></tr></table></figure><h2 id="max-min-——-找最值"><a href="#max-min-——-找最值" class="headerlink" title="max + min —— 找最值"></a>max + min —— 找最值</h2><p><strong>时间复杂度：</strong> O(1)</p><blockquote><p>找多个元素的最大值和最小值</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//找 a，b 的最大值和最小值</span></span><br><span class="line">mx = <span class="built_in">max</span>(a, b);</span><br><span class="line">mn = <span class="built_in">min</span>(a, b);</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//找到 a, b, c, d 的最大值和最小值</span></span><br><span class="line">mx = <span class="built_in">max</span>(&#123;a, b, c, d&#125;);</span><br><span class="line">mn = <span class="built_in">min</span>(&#123;a, b, c, d&#125;);</span><br></pre></td></tr></table></figure><h3 id="max-element-min-element-——-找最值"><a href="#max-element-min-element-——-找最值" class="headerlink" title="max_element + min_element —— 找最值"></a>max_element + min_element —— 找最值</h3><p><strong>复杂度：</strong> O(N)</p><blockquote><p>找最大最小值，头文件：<code>#include &lt;algorithm&gt;</code>。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数都是返回地址，需要加*解引用取值</span></span><br><span class="line"><span class="type">int</span> mx = *<span class="built_in">max_element</span>(a, a + n);</span><br><span class="line"><span class="type">int</span> mn = *<span class="built_in">min_element</span>(a, a + n);</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">A</span><span class="params">(n)</span></span>;</span><br><span class="line"><span class="type">int</span> maxval = *<span class="built_in">max_element</span>(A.<span class="built_in">begin</span>(), A.<span class="built_in">end</span>());  <span class="comment">// 数组最大值</span></span><br><span class="line"><span class="type">int</span> minval = *<span class="built_in">min_element</span>(A.<span class="built_in">begin</span>(), A.<span class="built_in">end</span>());  <span class="comment">// 数组最小值</span></span><br></pre></td></tr></table></figure><h3 id="nth-element-——-寻找第-n-小的值"><a href="#nth-element-——-寻找第-n-小的值" class="headerlink" title="nth_element —— 寻找第 n 小的值"></a>nth_element —— 寻找第 n 小的值</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">nth_element</span>(beg, nth, end)</span><br></pre></td></tr></table></figure><p><strong>复杂度：</strong> 平均 O(N)</p><blockquote><p>寻找第序列第 n 小的值</p></blockquote><p><code>nth</code> 为一个迭代器，指向序列中的一个元素。第 n 小的值恰好在 <code>nth</code> 位置上。</p><p>执行 <code>nth_element()</code> 之后，序列中的元素会围绕 nth 进行划分：<strong>nth 之前的元素都小于等于它，而之后的元素都大于等于它</strong></p><p><strong>实例：求序列中的第 3 小的元素</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">nth_element</span>(a, a + <span class="number">2</span>, a + n);</span><br><span class="line">cout &lt;&lt; a[<span class="number">2</span>] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="minmax"><a href="#minmax" class="headerlink" title="minmax"></a>minmax</h3><p><strong>复杂度：</strong> O(1)</p><blockquote><p>返回一个 <code>pair</code> 类型，第一个元素是 <code>min(a, b)</code>， 第二个元素是 <code>max(a, b)</code></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; t = <span class="built_in">minmax</span>(<span class="number">4</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">// t.first = 2, t.second = 4</span></span><br></pre></td></tr></table></figure><h3 id="minmax-element"><a href="#minmax-element" class="headerlink" title="minmax_element"></a>minmax_element</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">minmax_element</span>(beg, end)</span><br></pre></td></tr></table></figure><p><strong>复杂度：</strong> O(N)</p><blockquote><p>返回序列中的最小和最大值组成 pair 的对应的地址，返回类型为 <code>pair&lt;vector&lt;int&gt;::iterator, vector&lt;int&gt;::iterator&gt;</code></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n = <span class="number">10</span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line"><span class="built_in">iota</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), <span class="number">1</span>);</span><br><span class="line"><span class="keyword">auto</span> t = <span class="built_in">minmax_element</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>()); <span class="comment">// 返回的是最小值和最大值对应的地址</span></span><br><span class="line"><span class="comment">// *t.first = 1, * t.second = 10 输出对应最小最大值时需要使用指针</span></span><br></pre></td></tr></table></figure><h2 id="to-string-——-将数字转化成字符串"><a href="#to-string-——-将数字转化成字符串" class="headerlink" title="to_string —— 将数字转化成字符串"></a>to_string —— 将数字转化成字符串</h2><blockquote><p>将数字转化为字符串，支持小数（double）</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">12345678</span>;</span><br><span class="line">cout &lt;&lt; <span class="built_in">to_string</span>(a) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br></pre></td></tr></table></figure><h2 id="lower-bound-upper-bound-——-二分查找"><a href="#lower-bound-upper-bound-——-二分查找" class="headerlink" title="lower_bound + upper_bound —— 二分查找"></a>lower_bound + upper_bound —— 二分查找</h2><p><strong>复杂度：</strong> O(logN)</p><blockquote><p>作用：二分查找</p><p><strong>注意：用 * 解引用之后是取出来的是值，减去 <code>begin()</code> 得到的是下标！</strong></p><ul><li><strong>三个参数</strong>：<code>(起始位置, 结束位置, 目标值)</code>。</li><li><strong>范围</strong>：左闭右开 <code>[start, end)</code>。</li><li><strong>返回值</strong>：成功返回有效迭代器&#x2F;指针，失败返回 <code>end</code>。</li><li><strong>前提</strong>：数据必须有序！</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果未找到，返回尾地址的下一个位置的地址</span></span><br><span class="line"><span class="built_in">lower_bound</span>(起始迭代器 / 指针, 结束迭代器 / 指针, 目标值);</span><br><span class="line"><span class="built_in">upper_bound</span>(起始迭代器 / 指针, 结束迭代器 / 指针, 目标值);</span><br><span class="line"><span class="built_in">lower_bound</span>(a, a + n, x);        <span class="comment">//在 a 数组中查找第一个大于等于 x 的元素，返回该元素的地址</span></span><br><span class="line"><span class="built_in">upper_bound</span>(a, a + n, x);        <span class="comment">//在 a 数组中查找第一个大于 x 的元素，返回该元素的地址</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span>             <span class="comment">// 包含 lower_bound 和 upper_bound</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a[] = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">9</span>, <span class="number">9</span>, <span class="number">11</span> &#125;;</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">sizeof</span>(a) / <span class="built_in">sizeof</span>(a[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 示例 1：使用 lower_bound 查找第一个 &gt;= 3 的元素</span></span><br><span class="line">    <span class="type">int</span> x = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">auto</span> it1 = <span class="built_in">lower_bound</span>(a, a + n, x);</span><br><span class="line">    <span class="keyword">if</span> (it1 != a + n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> index = it1 - a;        <span class="comment">// 计算下标</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;第一个大于等于 &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; 的元素是 a[&quot;</span> &lt;&lt; index &lt;&lt; <span class="string">&quot;] = &quot;</span> &lt;&lt; *it1 &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 第一个大于等于 3 的元素是 a [1] = 3</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;没有找到大于等于 &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; 的元素&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 示例 2：使用 upper_bound 查找第一个 &gt; 3 的元素</span></span><br><span class="line">    <span class="keyword">auto</span> it2 = <span class="built_in">upper_bound</span>(a, a + n, x);</span><br><span class="line">    <span class="keyword">if</span> (it2 != a + n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> index = it2 - a;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;第一个大于 &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; 的元素是 a[&quot;</span> &lt;&lt; index &lt;&lt; <span class="string">&quot;] = &quot;</span> &lt;&lt; *it2 &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 第一个大于 3 的元素是 a [3] = 5</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;没有找到大于 &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; 的元素&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 示例 3：查找不存在的元素</span></span><br><span class="line">    x = <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">auto</span> it3 = <span class="built_in">lower_bound</span>(a, a + n, x);</span><br><span class="line">    <span class="keyword">if</span> (it3 != a + n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> index = it3 - a;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;第一个大于等于 &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; 的元素是 a[&quot;</span> &lt;&lt; index &lt;&lt; <span class="string">&quot;] = &quot;</span> &lt;&lt; *it3 &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 第一个大于等于 8 的元素是 a [5] = 9</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;没有找到大于等于 &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; 的元素&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 示例 4：统计某个值出现的次数</span></span><br><span class="line">    x = <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">auto</span> left = <span class="built_in">lower_bound</span>(a, a + n, x);</span><br><span class="line">    <span class="keyword">auto</span> right = <span class="built_in">upper_bound</span>(a, a + n, x);</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; <span class="string">&quot; 出现的次数: &quot;</span> &lt;&lt; right - left &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 9 出现的次数: 3</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 示例 5：在 vector 中使用</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v = &#123; <span class="number">2</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span> &#125;;</span><br><span class="line">    <span class="keyword">auto</span> itv = <span class="built_in">lower_bound</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">if</span> (itv != v.<span class="built_in">end</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> index = itv - v.<span class="built_in">begin</span>();</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;vector 中第一个大于等于 5 的元素是 v[&quot;</span> &lt;&lt; index &lt;&lt; <span class="string">&quot;] = &quot;</span> &lt;&lt; *itv &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// vector 中第一个大于等于 5 的元素是 v [3] = 6</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="atoi-——-将字符串转整型"><a href="#atoi-——-将字符串转整型" class="headerlink" title="atoi —— 将字符串转整型"></a>atoi —— 将字符串转整型</h2><blockquote><p>将字符串转换为 <code>int</code> 类型</p></blockquote><p>注意参数为 <code>char</code> 型数组，如果需要将 string 类型转换为 int 类型，可以使用 <code>stoi</code> 函数（参考下文），或者将 <code>string</code> 类型转换为 <code>const char *</code> 类型。</p><p>关于输出数字的范围：</p><ul><li><code>atoi</code> <strong>不做</strong> 范围检查，如果超出上界，输出上界，超出下界，输出下界。</li><li><code>stoi</code> <strong>会做</strong> 范围检查，默认必须在 <code>int</code> 范围内，如果超出范围，会出现 RE（Runtime Error）错误。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string s = <span class="string">&quot;1234&quot;</span>;</span><br><span class="line"><span class="type">int</span> a = <span class="built_in">atoi</span>(s.<span class="built_in">c_str</span>());</span><br><span class="line">cout &lt;&lt; a &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">// 1234</span></span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> s[] = <span class="string">&quot;1234&quot;</span>;</span><br><span class="line"><span class="type">int</span> a = <span class="built_in">atoi</span>(s);</span><br><span class="line">cout &lt;&lt; a &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br></pre></td></tr></table></figure><h2 id="stoi-stoll-stod-…-——-将字符串转整型（更常用）"><a href="#stoi-stoll-stod-…-——-将字符串转整型（更常用）" class="headerlink" title="stoi &#x2F; stoll &#x2F; stod &#x2F; … —— 将字符串转整型（更常用）"></a>stoi &#x2F; stoll &#x2F; stod &#x2F; … —— 将字符串转整型（更常用）</h2><blockquote><p>将对应 string 类型字符串转换为数字（<code>int</code> 型），记忆：<code>s -&gt; t 分别对应两个数据类型的某个字母</code></p></blockquote><p>注意参数为 <code>string</code> 字符串类型。</p><p><strong>如果要转换为其他类型的数字可使用 <code>stoll（转换为 long long）</code> ， <code>stoull（转换为 unsigned long long）</code>，<code>stod（转换为 double）</code> 等函数。</strong></p><p>关于输出数字的范围：</p><ul><li><p><code>stoi</code> <strong>会做</strong> 范围检查，默认必须在 <code>int</code> 范围内，如果超出范围，会出现 RE（Runtime Error）错误。</p></li><li><p><code>atoi</code> <strong>不做</strong> 范围检查，如果超出上界，输出上界，超出下界，输出下界。</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string s = <span class="string">&quot;1234&quot;</span>;</span><br><span class="line"><span class="type">int</span> a = <span class="built_in">stoi</span>(s);</span><br><span class="line">cout &lt;&lt; a &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">// 1234</span></span><br></pre></td></tr></table></figure><h2 id="reverse-——-翻转"><a href="#reverse-——-翻转" class="headerlink" title="reverse —— 翻转"></a>reverse —— 翻转</h2><p><strong>时间复杂度：</strong> O(N)</p><blockquote><p><strong>对序列进行前后翻转，包含在头文件 <code>#include &lt;algorithm&gt;</code> 中！</strong></p></blockquote><blockquote><p>  [!NOTE]</p><p>  <strong><code>reverse</code> 函数在解决回文串相关问题格外好用</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">string s = <span class="string">&quot;abcde&quot;</span>;</span><br><span class="line"><span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());<span class="comment">//对 s 进行翻转</span></span><br><span class="line">cout &lt;&lt; s &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;<span class="comment">//edcba</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对 a 数组进行翻转</span></span><br><span class="line"><span class="type">int</span> a[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="built_in">reverse</span>(a, a + <span class="number">4</span>);</span><br><span class="line">cout &lt;&lt; a[<span class="number">0</span>] &lt;&lt; a[<span class="number">1</span>] &lt;&lt; a[<span class="number">2</span>] &lt;&lt; a[<span class="number">3</span>];<span class="comment">//4321</span></span><br></pre></td></tr></table></figure><h2 id="getline-istringstream-——-读取一行-对字符串流进行分割"><a href="#getline-istringstream-——-读取一行-对字符串流进行分割" class="headerlink" title="getline + istringstream —— 读取一行&#x2F;对字符串流进行分割"></a>getline + istringstream —— 读取一行&#x2F;对字符串流进行分割</h2><blockquote><p><strong>时间复杂度： O(n)，头文件：<code>&lt;string&gt;</code> (getline)，<code>&lt;sstream&gt;</code>（istringstream）</strong></p></blockquote><blockquote><p>读取一行（包括空格），搭配 <code>istringstream </code> 实现分割处理</p><ul><li><code>getline</code>(输入流, 变量); → 读取整行</li><li><code>istringstream</code>(字符串变量); → 把字符串当作输入流</li><li><code>getline</code>(字符串流, 变量, 分隔符); → 按分隔符拆分数据</li><li><code>while </code>(字符串流 &gt;&gt; 变量) → 按空格拆分数据</li></ul><p><code>istringstream </code> 用于把字符串当作输入流；<code>getline </code> 用于按分隔符拆分数据；<code>while </code> 循环用于按空格拆分数据。</p><p>快速记忆：<code>getline</code>(字符串流, 变量, 分隔符); → <code>getline</code> 用于读取一整行包括空格，默认（指定分割符）直到遇到换行符（换行符会被丢弃，不存入变量）才结束。如果指定了分隔符，则会读取到 分隔符 为止（即分隔符的前一个位置，分隔符也会被丢弃，不存入变量），读取的部分会被存储在指定的变量中，而分隔符本身不会被包含在结果中。然后，剩余的部分（分隔符后的字符）会留在输入流中，为下一次读取做准备。下一次调用 <code>getline</code> 会继续从流中读取，直到遇到下一个分隔符或者行结束为止。这个过程会一直继续，直到所有需要的数据都被提取出来。</p></blockquote><blockquote><p>  [!IMPORTANT]</p><p>  <code>cin</code> 不能读取换行&#x2F;回车，所以如果在 <code>getline</code> 之前使用了 <code>cin</code>（ 混合输入），那么 <code>getline</code> 实际读取到的是换行&#x2F;回车，就无法正确读入数据，很多时候就是因为这个原因导致程序出错！常用解决方法：当使用了这样的混合输入必须要在 <code>cin</code> 和 <code>getline</code> 之间写上 <strong><code>getchar();</code> 或者 <code>cin.ignore();</code> 来清除输入缓冲区中的换行符！</strong> 例子：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="comment">// 清除输入缓冲区中的换行符（任选其一）</span></span><br><span class="line"><span class="comment">// getchar();</span></span><br><span class="line">cin.<span class="built_in">ignore</span>();</span><br><span class="line"></span><br><span class="line">string s;</span><br><span class="line"><span class="built_in">getline</span>(cin, s);</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span>                   <span class="comment">// 包含 getline</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span>                  <span class="comment">// 包含 stringstream</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 示例 1：输入 &quot;YYYY-MM-DD&quot;，输出 &quot;YYYY/MM/DD&quot;</span></span><br><span class="line">    string year, month, day;</span><br><span class="line">    <span class="built_in">getline</span>(cin, year, <span class="string">&#x27;-&#x27;</span>);        <span class="comment">// 读取到第一个 &#x27;-&#x27; 为止</span></span><br><span class="line">    <span class="built_in">getline</span>(cin, month, <span class="string">&#x27;-&#x27;</span>);       <span class="comment">// 继续读取到下一个 &#x27;-&#x27;</span></span><br><span class="line">    <span class="built_in">getline</span>(cin, day);              <span class="comment">// 读取剩余部分（默认到行尾）</span></span><br><span class="line">    cout &lt;&lt; year &lt;&lt; <span class="string">&quot;/&quot;</span> &lt;&lt; month &lt;&lt; <span class="string">&quot;/&quot;</span> &lt;&lt; day &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 示例 2：按空格拆分 &quot;42 3.14 hello&quot;</span></span><br><span class="line">    string data = <span class="string">&quot;42 3.14 hello&quot;</span>;</span><br><span class="line">    <span class="function">istringstream <span class="title">iss</span><span class="params">(data)</span></span>;        <span class="comment">// 将字符串转为流</span></span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="type">double</span> pi;</span><br><span class="line">    string word;</span><br><span class="line">    iss &gt;&gt; num &gt;&gt; pi &gt;&gt; word;       <span class="comment">// 按空格提取</span></span><br><span class="line">    cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; pi &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; word &lt;&lt; endl;    <span class="comment">// 输出: 42 3.14 hello</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 示例 3：按逗号拆分 CSV 数据 &quot;apple, orange, banana&quot;</span></span><br><span class="line">    string csv = <span class="string">&quot;apple,orange,banana&quot;</span>;</span><br><span class="line">    <span class="function">istringstream <span class="title">iss_csv</span><span class="params">(csv)</span></span>;</span><br><span class="line">    string fruit;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">getline</span>(iss_csv, fruit, <span class="string">&#x27;,&#x27;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; fruit &lt;&lt; <span class="string">&quot; &quot;</span>;       <span class="comment">// 输出: apple orange banana</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 示例 4：逐行处理输入（如文件或控制台）</span></span><br><span class="line">    string line;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">getline</span>(cin, line))      <span class="comment">// 每次读取一行</span></span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="function">istringstream <span class="title">ss</span><span class="params">(line)</span></span>;</span><br><span class="line">        string token;</span><br><span class="line">        <span class="keyword">while</span> (ss &gt;&gt; token)</span><br><span class="line">        &#123;     </span><br><span class="line">            cout &lt;&lt; token &lt;&lt; <span class="string">&quot; &quot;</span>;   <span class="comment">// 按空格拆分每行</span></span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="set-union-set-intersection-set-difference-——-交并差集"><a href="#set-union-set-intersection-set-difference-——-交并差集" class="headerlink" title="set_union, set_intersection, set_difference —— 交并差集"></a>set_union, set_intersection, set_difference —— 交并差集</h2><p>复杂度： O(N+M)</p><blockquote><p><strong>求两个集合的并集，交集，差集</strong>。手动实现双指针就可以搞定，嫌麻烦可以使用该函数</p></blockquote><table><thead><tr><th>函数</th><th>作用</th><th>说明</th></tr></thead><tbody><tr><td><code>set_union</code></td><td>并集</td><td>两个集合所有元素（去重）</td></tr><tr><td><code>set_intersection</code></td><td>交集</td><td>两个集合共同的元素</td></tr><tr><td><code>set_difference</code></td><td>差集</td><td>第一个集合有而第二个集合没有的元素</td></tr></tbody></table><p><strong>注意：</strong></p><ul><li><strong>必须有序（sorted），但不强制升序或降序。</strong></li><li><strong>只要两个输入区间是按照相同的排序规则（比如都是升序、或者都是降序）排好的，就可以正常使用。</strong></li></ul><p>两个集合 <strong>必须为有序集合</strong>，所以下面演示代码使用了排序。<code>vector</code> 容器可以替换成 <code>set</code> 容器，因为 <code>set</code> 自动会对元素进行排序。函数的参数有五个，前两个为第一个容器的首尾迭代器，第三四个为第二个容器的首尾迭代器，最后一个为插入位置，即将结果插入到哪个地址之后。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span><span class="comment">// 头文件</span></span></span><br><span class="line"><span class="built_in">set_union</span>(起始迭代器<span class="number">1</span>, 结束迭代器<span class="number">1</span>, 起始迭代器<span class="number">2</span>, 结束迭代器<span class="number">2</span>, 输出迭代器);</span><br><span class="line"><span class="built_in">set_intersection</span>(起始迭代器<span class="number">1</span>, 结束迭代器<span class="number">1</span>, 起始迭代器<span class="number">2</span>, 结束迭代器<span class="number">2</span>, 输出迭代器);</span><br><span class="line"><span class="built_in">set_difference</span>(起始迭代器<span class="number">1</span>, 结束迭代器<span class="number">1</span>, 起始迭代器<span class="number">2</span>, 结束迭代器<span class="number">2</span>, 输出迭代器);</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">8</span>&#125;, b = &#123;<span class="number">5</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="built_in">sort</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>()); <span class="comment">// 1 2 4 5 8</span></span><br><span class="line"><span class="built_in">sort</span>(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>()); <span class="comment">// 2 3 5 8 9</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; c, d, e;</span><br><span class="line"><span class="comment">// a 并 b：1 2 3 4 5 8 9</span></span><br><span class="line"><span class="built_in">set_union</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>(), <span class="built_in">inserter</span>(c, c.<span class="built_in">begin</span>()));</span><br><span class="line"><span class="comment">// a 交 b：2 5 8</span></span><br><span class="line"><span class="built_in">set_intersection</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>(), <span class="built_in">inserter</span>(d, d.<span class="built_in">begin</span>()));</span><br><span class="line"><span class="comment">// a 差 b： 1 4</span></span><br><span class="line"><span class="built_in">set_difference</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>(), <span class="built_in">inserter</span>(e, e.<span class="built_in">begin</span>()));</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span>                    <span class="comment">// 包含 set_union、set_intersection、set_difference</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span> &#125;;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; b = &#123; <span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span> &#125;;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">Intersection</span><span class="params">(<span class="number">10</span>)</span></span>;       <span class="comment">// 交集，预留足够空间</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">Union</span><span class="params">(<span class="number">10</span>)</span></span>;              <span class="comment">// 并集，预留足够空间</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">Difference</span><span class="params">(<span class="number">10</span>)</span></span>;         <span class="comment">// 差集，预留足够空间</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 求交集</span></span><br><span class="line">    <span class="keyword">auto</span> it1 = <span class="built_in">set_intersection</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>(), Intersection.<span class="built_in">begin</span>());</span><br><span class="line">    Intersection.<span class="built_in">resize</span>(it1 - Intersection.<span class="built_in">begin</span>());    <span class="comment">// 调整交集实际大小</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 求并集</span></span><br><span class="line">    <span class="keyword">auto</span> it2 = <span class="built_in">set_union</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>(), Union.<span class="built_in">begin</span>());</span><br><span class="line">    Union.<span class="built_in">resize</span>(it2 - Union.<span class="built_in">begin</span>());                  <span class="comment">// 调整并集实际大小</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 求差集</span></span><br><span class="line">    <span class="keyword">auto</span> it3 = <span class="built_in">set_difference</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>(), Difference.<span class="built_in">begin</span>());</span><br><span class="line">    Difference.<span class="built_in">resize</span>(it3 - Difference.<span class="built_in">begin</span>());        <span class="comment">// 调整差集实际大小</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出交集</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : Intersection)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">// 输出交集元素 3</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出并集</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : Union)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">// 输出并集元素 1 2 3 5 6</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出差集</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : Difference)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">// 输出差集元素 1 5</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="back-inserter"><a href="#back-inserter" class="headerlink" title="back_inserter"></a>back_inserter</h4><p><code>back_inserter(容器名)</code> 是一个 <strong>生成输出迭代器的小工具</strong>，帮你 <strong>自动在容器尾部插入元素</strong>。<strong>平常如果不用 back_inserter，你需要预先分配好大空间，还要 resize，很麻烦。</strong> 而用 <code>back_inserter</code> 就可以：</p><ul><li>不需要提前开空间！</li><li>自动 <code>push_back</code> 加元素！</li></ul><p><strong>1. 传统写法（需要开大空间）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">result</span><span class="params">(<span class="number">100</span>)</span></span>;  <span class="comment">// 必须提前开好足够空间</span></span><br><span class="line"><span class="keyword">auto</span> it = <span class="built_in">set_union</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>(), result.<span class="built_in">begin</span>());</span><br><span class="line">result.<span class="built_in">resize</span>(it - result.<span class="built_in">begin</span>());  <span class="comment">// 最后再调整大小</span></span><br></pre></td></tr></table></figure><p><strong>2. 使用 back_inserter（最推荐）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; result;  <span class="comment">// 不需要开空间，空的就行</span></span><br><span class="line"><span class="built_in">set_union</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>(), <span class="built_in">back_inserter</span>(result));</span><br><span class="line"><span class="comment">// 不需要 resize，直接用 result 即可</span></span><br></pre></td></tr></table></figure><p>看到了吗？<code>back_inserter</code> 自动帮你扩容，<strong>代码更简洁、安全，强烈推荐使用！</strong></p><h2 id="isdigit、isalpha-——-判断是否是数字-字符"><a href="#isdigit、isalpha-——-判断是否是数字-字符" class="headerlink" title="isdigit、isalpha —— 判断是否是数字&#x2F;字符"></a>isdigit、isalpha —— 判断是否是数字&#x2F;字符</h2><blockquote><p>处于标准库函数（头文件 <code>&lt;cctype&gt;</code>）。正常来说下面前 4 个是较为常用的，记不住也没关系，大多数情况也还是手动实现的</p></blockquote><table><thead><tr><th>函数名</th><th>作用</th><th>示例输入</th><th>示例输出</th></tr></thead><tbody><tr><td><strong><code>isdigit(c)</code></strong></td><td><strong>判断是否为数字（0~9）</strong></td><td><code>&#39;5&#39;</code></td><td><code>true</code></td></tr><tr><td><strong><code>isalpha(c)</code></strong></td><td><strong>判断是否为字母（A-Z 或 a-z）</strong></td><td><code>&#39;a&#39;</code> &#x2F; <code>&#39;Z&#39;</code></td><td><code>true</code></td></tr><tr><td><strong><code>islower(c)</code></strong></td><td><strong>判断是否为小写字母</strong></td><td><code>&#39;g&#39;</code></td><td><code>true</code></td></tr><tr><td><strong><code>isupper(c)</code></strong></td><td><strong>判断是否为大写字母</strong></td><td><code>&#39;G&#39;</code></td><td><code>true</code></td></tr><tr><td><code>isalnum(c)</code></td><td>判断是否为字母或数字</td><td><code>&#39;a&#39;</code>, <code>&#39;9&#39;</code></td><td><code>true</code></td></tr><tr><td><code>isspace(c)</code></td><td>判断是否为空白字符（空格、\t、\n）</td><td><code>&#39; &#39;</code></td><td><code>true</code></td></tr><tr><td><code>isxdigit(c)</code></td><td>判断是否为十六进制数字（0 <del>9, A</del> F, a~f）</td><td><code>&#39;F&#39;</code></td><td><code>true</code></td></tr><tr><td><code>isprint(c)</code></td><td>判断是否为可打印字符</td><td><code>&#39;!&#39;</code></td><td><code>true</code></td></tr><tr><td><code>ispunct(c)</code></td><td>判断是否为标点符号</td><td><code>&#39;!&#39;</code>, <code>&#39;,&#39;</code></td><td><code>true</code></td></tr><tr><td><code>isgraph(c)</code></td><td>是否为可见字符（不含空格）</td><td><code>&#39;A&#39;</code>, <code>&#39;%&#39;</code></td><td><code>true</code></td></tr></tbody></table><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">my_isdigit</span><span class="params">(<span class="type">char</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>;            <span class="comment">// 判断是否为数字字符（ASCII: 48~57）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">my_isalpha</span><span class="params">(<span class="type">char</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (c &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;z&#x27;</span>) || (c &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;Z&#x27;</span>);    <span class="comment">// 判断是否为字母（大写或小写，ASCII: a~z: 97~122, A~Z: 65~90）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">my_islower</span><span class="params">(<span class="type">char</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;z&#x27;</span>;            <span class="comment">// 判断是否为小写字母</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">my_isupper</span><span class="params">(<span class="type">char</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;Z&#x27;</span>;            <span class="comment">// 判断是否为大写字母</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="gcd-——-最大公约数，lcm-——-最小公倍数"><a href="#gcd-——-最大公约数，lcm-——-最小公倍数" class="headerlink" title="gcd —— 最大公约数，lcm —— 最小公倍数"></a>gcd —— 最大公约数，lcm —— 最小公倍数</h2><table><thead><tr><th>名称</th><th>所属</th><th>是否标准</th><th>头文件</th><th>支持类型</th><th>特点说明</th></tr></thead><tbody><tr><td><code>std::gcd</code></td><td>C++17 标准库</td><td>✅ 是</td><td><code>&lt;numeric&gt;</code></td><td><code>int</code>、<code>long long</code> 等整数</td><td>类型安全，支持 <code>constexpr</code>，推荐使用于现代 C++</td></tr><tr><td><code>std::lcm</code></td><td>C++17 标准库</td><td>✅ 是</td><td><code>&lt;numeric&gt;</code></td><td><code>int</code>、<code>long long</code> 等整数</td><td>求最小公倍数，现代推荐方式</td></tr><tr><td><code>__gcd</code></td><td>GNU 扩展</td><td>❌ 否</td><td><code>&lt;algorithm&gt;</code></td><td>原始定义只明确支持 <code>int</code> 类型，后续做了处理，可以接受 <code>long</code>、<code>long long</code> 等整型参数，但仍有部分编译器不支持！</td><td>GCC 特有，非标准函数，竞赛中常用</td></tr></tbody></table><blockquote><p><strong>C++17 引入，头文件：<code>#include &lt;numeric&gt; </code></strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">24</span>, b = <span class="number">12</span>;</span><br><span class="line">cout &lt;&lt; <span class="built_in">gcd</span>(a, b) &lt;&lt; endl;<span class="comment">// 输出 12</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">lcm</span>(a, b) &lt;&lt; endl;<span class="comment">// 输出 24</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">如果环境不支持，可以手动实现其两者功能：</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b == <span class="number">0</span> ? a : <span class="built_in">gcd</span>(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lcm</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a * b) / <span class="built_in">gcd</span>(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="gcd-——-最大公约数"><a href="#gcd-——-最大公约数" class="headerlink" title="__gcd —— 最大公约数"></a>__gcd —— 最大公约数</h3><blockquote><p>求 a 和 b 的最大公约数，使用时要包含 <code>&lt;algorithm&gt;</code> 头文件。准确的来说它是一个 <code>GNU</code> 扩展，不属于 <code>STL</code>。</p></blockquote><p><code>__gcd(12,15) = 3</code></p><p><code>__gcd(21,0) = 21</code></p><h2 id="lg"><a href="#lg" class="headerlink" title="__lg"></a>__lg</h2><blockquote><ol><li>求一个数二进制下最高位位于第几位（从 <strong>第 0 位</strong> 开始）（或二进制数下有几位）</li><li><code>__lg(x)</code> 相当于返回 $log_2 x$</li><li>复杂度 O(1)</li></ol></blockquote><p><code>__lg(8) = 3</code></p><p><code>__lg(15) = 3</code></p><h2 id="accumulate-——-序列求和"><a href="#accumulate-——-序列求和" class="headerlink" title="accumulate —— 序列求和"></a>accumulate —— 序列求和</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">accumulate</span>(beg, end, init)</span><br></pre></td></tr></table></figure><p><strong>复杂度：</strong> O(N)</p><blockquote><p>作用：对一个序列的元素求和</p></blockquote><p><code>init</code> 为对序列元素求和的 <strong>初始值</strong></p><p>返回值类型：与 <code>init</code> 相同</p><ul><li><strong>基础累加求和：</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[]=&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">10</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对 [0,2] 区间求和，初始值为 0，结果为 0 + 1 + 3 + 5 = 9</span></span><br><span class="line"><span class="type">int</span> res1 = <span class="built_in">accumulate</span>(a, a + <span class="number">3</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//对 [0,3] 区间求和，初始值为 5，结果为 5 + 1 + 3 + 5 + 9 = 23</span></span><br><span class="line"><span class="type">int</span> res2 = <span class="built_in">accumulate</span>(a, a + <span class="number">4</span>, <span class="number">5</span>);</span><br></pre></td></tr></table></figure><ul><li><strong>自定义二元对象求和：</strong></li></ul><p>使用 <code>lambda</code> 表达式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    ll num;</span><br><span class="line">&#125; st[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">st[i].num = i + <span class="number">10000000000</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回值类型与 init 一致，同时注意参数类型（a）也要一样</span></span><br><span class="line"><span class="comment">//初始值为 1，累加 1+10000000001+10000000002+10000000003 = 30000000007</span></span><br><span class="line">ll res = <span class="built_in">accumulate</span>(st + <span class="number">1</span>, st + <span class="number">4</span>, <span class="number">1ll</span>, [](ll a,node b) &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b.num;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="ceil-——-向上取整"><a href="#ceil-——-向上取整" class="headerlink" title="ceil —— 向上取整"></a><code>ceil</code> —— 向上取整</h2><blockquote><p>头文件：<code>&lt;cmath&gt;</code>&#x2F;<code>&lt;math.h&gt;</code>。</p><p><code>ceil</code> 函数的功能是返回不小于给定参数 <code>x</code> 的最小整数，也就是我们所说的 <strong>向上取整</strong>。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">ceil</span><span class="params">(<span class="type">double</span> x)</span></span>;</span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">ceil</span><span class="params">(<span class="type">float</span> x)</span></span>;                    <span class="comment">// C++ 中新增的重载版本</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">double</span> <span class="title">ceil</span><span class="params">(<span class="type">long</span> <span class="type">double</span> x)</span></span>;        <span class="comment">// C++ 中新增的重载版本</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span>                        <span class="comment">// 包含了 ceil 函数的头文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">ceil</span>(a) &lt;&lt; endl;            <span class="comment">// 输出 1</span></span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> b = <span class="number">2.5</span>;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">ceil</span>(b) &lt;&lt; endl;            <span class="comment">// 输出 3</span></span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> c = <span class="number">-2.4</span>;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">ceil</span>(c) &lt;&lt; endl;            <span class="comment">// 输出 -2</span></span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="type">double</span> d = <span class="number">3.1415926</span>;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">ceil</span>(d) &lt;&lt; endl;            <span class="comment">// 输出 4</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="fill"><a href="#fill" class="headerlink" title="fill"></a>fill</h2><p><strong>复杂度：</strong> O(N)</p><blockquote><p>对一个序列进行初始化赋值</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对 a 数组的所有元素赋 1</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">5</span>];</span><br><span class="line"><span class="built_in">fill</span>(a, a + <span class="number">5</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1 1 1 1 1</span></span><br></pre></td></tr></table></figure><p><strong>注意区分 memset：<code>void *memset(需要填充内存的指针，填充的值，字节数);</code></strong>，<code>memset()</code> 是按 <strong>字节</strong> 进行赋值，对于初始化赋 <code>0</code> 或 <code>-1</code> 有比较好的效果。</p><p>如果赋某个特定的数会 <strong>出错</strong>，赋值特定的数建议使用 <code>fill()</code>。</p><h2 id="next-permutation"><a href="#next-permutation" class="headerlink" title="next_permutation"></a>next_permutation</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">next_permutation</span>(beg, end)</span><br></pre></td></tr></table></figure><p><strong>时间复杂度：</strong> O(N)</p><blockquote><p>求序列的下一个排列，下一个排列是字典序大一号的排列</p></blockquote><p>返回 <code>true</code> 或 <code>false</code></p><ul><li><p><code>next_permutation(beg, end)</code></p><p>  如果是最后一个排列，返回 <code>false</code>, 否则求出下一个序列后，返回 <code>true</code></p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对 a 序列进行重排</span></span><br><span class="line"><span class="built_in">next_permutation</span>(a, a + n);</span><br></pre></td></tr></table></figure><p><strong>应用：求所有的排列</strong></p><p>输出 <code>a</code> 的所有排列</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组 a 不一定是最小字典序序列，一定注意将它排序</span></span><br><span class="line"><span class="built_in">sort</span>(a, a + n);</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i]);</span><br><span class="line"> &#125;</span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="built_in">next_permutation</span>(a, a + n));</span><br></pre></td></tr></table></figure><ul><li><code>prev_permutation(beg, end)</code></li></ul><blockquote><p>求出前一个排列，如果序列为最小的排列，将其重排为最大的排列，返回 false。</p></blockquote><h2 id="random-shuffle"><a href="#random-shuffle" class="headerlink" title="random_shuffle"></a>random_shuffle</h2><p><strong>复杂度：</strong> O(N)</p><blockquote><ol><li>随机打乱序列的顺序</li><li><code>random_shuffle</code> 在 <code>C++14</code> 中被弃用，在 <code>C++17</code> 中被废除，C++11 之后应尽量使用 <code>shuffle</code> 来代替。</li></ol></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">b</span><span class="params">(n)</span></span>;</span><br><span class="line"><span class="built_in">iota</span>(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>(), <span class="number">1</span>);<span class="comment">// 序列 b 递增赋值 1, 2, 3, 4,...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对 a 数组随机重排</span></span><br><span class="line"><span class="built_in">random_shuffle</span>(a, a + n);</span><br><span class="line"></span><br><span class="line"><span class="comment">// C++11 之后尽量使用 shuffle</span></span><br><span class="line"><span class="built_in">shuffle</span>(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure><h2 id="transform"><a href="#transform" class="headerlink" title="transform"></a>transform</h2><p><strong>复杂度：</strong> O(N)</p><blockquote><p>作用：使用给定操作，将结果写到 dest 中</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原型：</span></span><br><span class="line"><span class="built_in">transform</span>(beg, end, dest, unaryOp);</span><br></pre></td></tr></table></figure><p>一般不怎么使用，徒增记忆负担，不如手动实现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将序列开始地址 beg 到结束地址 end 大小写转换，把结果存到起始地址为 dest 的序列中</span></span><br><span class="line"><span class="built_in">transform</span>(beg, end, dest, ::tolower);</span><br><span class="line"><span class="built_in">transform</span>(beg, end, dest, ::toupper);</span><br></pre></td></tr></table></figure><h2 id="unique"><a href="#unique" class="headerlink" title="unique"></a>unique</h2><p><strong>复杂度：</strong> O(N)</p><blockquote><p>消除重复元素，返回消除完重复元素的下一个位置的地址</p><p>如：<code>a[] = &#123;1, 3, 2, 3, 6&#125;</code>;</p><p><code>unique</code> 之后 <code>a</code> 数组为 <code>&#123;1, 2, 3, 6, 3&#125;</code> 前面为无重复元素的数组，后面则是重复元素移到后面，返回 <code>a[4]</code> 位置的地址（不重复元素的尾后地址）</p></blockquote><p>消除重复元素一般需要原序列是 <strong>有序序列</strong></p><p><strong>应用：离散化</strong></p><ul><li>方法一：利用数组离散化</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    cin &gt;&gt; a[i];</span><br><span class="line">    b[i] = a[i];                    <span class="comment">//将 a 数组复制到 b 数组</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 排序后 b：&#123;1, 2, 3, 3, 6&#125;</span></span><br><span class="line"><span class="built_in">sort</span>(b, b + n);                     <span class="comment">//对 b 数组排序</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 消除重复元素 b：&#123;1, 2, 3, 6, 3&#125; 返回的地址为最后一个元素 3 的地址 </span></span><br><span class="line"><span class="type">int</span> len = <span class="built_in">unique</span>(b, b + n) - b;     <span class="comment">//消除 b 的重复元素，并获取长度</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//因为 b 有序，查找到的下标就是对应的 相对大小（离散化后的值）</span></span><br><span class="line">    <span class="type">int</span> pos = <span class="built_in">lower_bound</span>(b, b + len, a[i]) - b;        <span class="comment">//在 b 数组中二分查找第一个大于等于 a [i] 的下标</span></span><br><span class="line">    a[i] = pos;                     <span class="comment">// 离散化赋值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>方法二：利用 <code>vector</code> 进行离散化</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    cin &gt;&gt; a[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; b = a;</span><br><span class="line"><span class="built_in">sort</span>(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>());</span><br><span class="line">b.<span class="built_in">erase</span>(<span class="built_in">unique</span>(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>()), b.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">a[i] = <span class="built_in">lower_bound</span>(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>(), a[i]) - b.<span class="built_in">begin</span>() + <span class="number">1</span>; <span class="comment">// 离散后的数据从 1 开始   </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="builtin-内置位运算函数"><a href="#builtin-内置位运算函数" class="headerlink" title="__builtin_ 内置位运算函数"></a><code>__builtin_</code> 内置位运算函数</h2><blockquote><p>需要注意：内置函数有相应的 <code>unsigned lnt</code> 和 <code>unsigned long long</code> 版本，<code>unsigned long long</code> 只需要在函数名后面加上 <code>ll</code> 就可以了，比如 <code>__builtin_clzll(x)</code> ，默认是 32 位 <code>unsigned int</code></p><p>很多题目和 <code>long long</code> 数据类型有关，如有需要注意添加 <code>ll</code></p></blockquote><ul><li><code>__builtin_ffs</code></li></ul><blockquote><p>二进制中对应最后一位 <code>1</code> 的位数，比如 <code>4</code> 会返回 <code>3</code>（100）</p></blockquote><ul><li><code>__builtin_popcount</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__builtin_popcount(x)</span><br></pre></td></tr></table></figure><blockquote><p><code>x</code> 中 <code>1</code> 的个数</p></blockquote><ul><li><code>__builtin_ctz</code></li></ul><blockquote><p><code>x</code> 末尾 <code>0</code> 的个数（<code>count tail zero</code>）</p></blockquote><ul><li><code>__builtin_clz</code></li></ul><blockquote><p><code>x</code> 前导 <code>0</code> 的个数（<code>count leading zero</code>）</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; __builtin_clz(<span class="number">32</span>); <span class="comment">// 26</span></span><br><span class="line"><span class="comment">//因为共有 6 位, 默认数据范围为 32 位，32 - 6 = 26</span></span><br></pre></td></tr></table></figure><ul><li><code>__builtin_parity</code></li></ul><blockquote><p><code>x</code> 中 1 的个数的奇偶性， 奇数输出 <code>1</code>，偶数输出 <code>0</code></p></blockquote><h2 id="C-20-ranges"><a href="#C-20-ranges" class="headerlink" title="C++20 ranges"></a>C++20 ranges</h2><p>ranges 主要用来简化迭代器操作，可以少写很多迭代器操作相关的代码。<br>ranges 集成了很多 STL 函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ranges::<span class="built_in">sort</span>(a); <span class="comment">// sort(a.begin(), a.end());</span></span><br><span class="line">ranges::<span class="built_in">sort</span>(a, <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());  <span class="comment">// sort(a.begin(), a.end(), greater &lt;int&gt;());</span></span><br><span class="line"><span class="type">int</span> mx = *ranges::<span class="built_in">max_element</span>(a);</span><br><span class="line"><span class="type">int</span> mn = *ranges::<span class="built_in">min_element</span>(a);</span><br></pre></td></tr></table></figure><blockquote><p>可参考链接：</p><ol><li><a href="https://www.luogu.com.cn/blog/AccRobin/grammar-candies">C++语法糖</a> <a href="https://www.luogu.com.cn/blog/AccRobin/grammar-candies">https://www.luogu.com.cn/blog/AccRobin/grammar-candies</a></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网站说明</title>
      <link href="/posts/17934.html"/>
      <url>/posts/17934.html</url>
      
        <content type="html"><![CDATA[<h1 id="欢迎来到我的个人博客-👋"><a href="#欢迎来到我的个人博客-👋" class="headerlink" title="欢迎来到我的个人博客 👋"></a>欢迎来到我的个人博客 👋</h1><p>这里是我记录学习心得、技术分享与生活点滴的小天地，希望能为你带来有价值的内容 🙌</p><h2 id="关于网站访问"><a href="#关于网站访问" class="headerlink" title="关于网站访问"></a>关于网站访问</h2><blockquote><p><strong>⚠️ 由于网站没有进行备案，诸多加速优化及提升阅读体验的功能和服务受相关规定限制无法启用，主要是个人感觉备案繁琐 😡，暂时没有考虑备案的想法，但后续也会持续对网站进行各方面的优化，感谢理解呀～🤪</strong></p></blockquote><p>为提供最佳访问体验，本站提供三个常用访问域名，均通过 edgeone CDN 加速：</p><ul><li><strong><a href="https://cn.minbit.top/">cn.minbit.top</a>&#x2F;<a href="https://www.cn.minbit.top/">(www.)cn.minbit.top</a></strong>：采用 EdgeOne Pages 部署，<strong>中国大陆用户优先使用此域名</strong>，访问体验更佳！</li><li><strong><a href="https://minbit.top/">minbit.top</a></strong>：Vercel 部署版本，通常需要稳定访问 GitHub（挂 V）。</li><li><strong><a href="https://huangcancan-xbc.github.io/">huangcancan-xbc.github.io</a></strong>：GitHub Pages 默认域名，永久有效且稳定（可确保无 404 问题）。</li></ul><blockquote><p>  <strong>注：minbit.top 域名将于 2027&#x2F;04&#x2F;06 到期，目前还在考虑是否续费，到期时这里会更新。若 minbit.top 系列出现访问异常，建议切换至 GitHub 域名访问。</strong></p></blockquote><h2 id="内容与资源说明"><a href="#内容与资源说明" class="headerlink" title="内容与资源说明"></a>内容与资源说明</h2><blockquote><p><strong>🎉🎉🎉 截至 2025.09.25 日，我已将本站图片迁移至 <a href="https://github.com/huangcancan-xbc/Image-hosting">小米里的大麦图床</a>，网站展示部分的图片均采用了新图床方案，但是为了保证长期稳定，博客文章内的图片依旧使用 GitHub + jsDelivr CDN，这对中国大陆的朋友做了优化，但是依旧推荐使用 科学上网 来达到最好的访问效果！</strong></p><p><strong>需要注意的是该图床每天提供 10 万次的请求，若网站遭到攻击或有人故意盗刷流量请求，依旧会导致对图片的请求失败！此时只能依靠浏览器缓存或者隔天访问！</strong></p></blockquote><ul><li><strong>图片资源</strong>：本站的图片 <del>均</del> 存储于我的 GitHub 图床仓库，通过免费的 jsDelivr CDN 加速，但是不保证快速稳定地加载，延迟可能较高。所以 <strong>网站图片加载异常属于正常现象，可刷新重试</strong>，还请谅解！通过稳定访问 GitHub 可改善。</li><li><strong>评论系统</strong>：采用 Powered by Twikoo v1.6.44 提供评论功能，建议在良好网络环境下使用以获得更佳体验。</li><li><strong>博客内容</strong>：聚焦后端研发方向，以 C++ 和 Linux 为核心，同时也会包含前端（HTML、CSS、Vue 等）、MySQL、Redis 等技术领域内容（待更新）。</li><li><strong>算法相关</strong>：暂未开设算法相关博客，但提供较多算法练习，详见 <a href="https://github.com/huangcancan-xbc/Algorithm">GitHub 的 Algorithm 仓库</a> 或者 <a href="https://gitee.com/huang-cancan-xbc/Algorithm">Gitee 的 Algorithm 仓库</a>，这里包含了算法原理、难点解析、AC 源代码等。</li><li><strong>更新频率：</strong> 由于本人处于学习阶段、多平台维护繁琐等原因，博客更新频率不会很大，所以 <strong>更新频率以月为单位</strong>，正巧对应上 CSDN 的周更篇数，也巧于“研究一代，成熟一代，发布一代”，哈哈，未来可能会加速更新频率，敬请期待！</li></ul><p><strong>我的博客内容（或者说我的学习课程）属于一套完整的学习体系，我想力求还原我的所学所想，但受限于文字表达，文字始终比不上言语来的清楚明了，若有讲解不清之处还请谅解 😊</strong></p><h2 id="网站使用建议"><a href="#网站使用建议" class="headerlink" title="网站使用建议"></a>网站使用建议</h2><ol><li><strong>网络环境</strong>：为获得最佳体验，建议在稳定的网络环境下访问（最好使用特殊网络条件哦 🤪）。</li><li><strong>学习方法</strong>：博客内容按知识体系组织，建议按顺序学习，循序渐进。</li><li><strong>实践建议</strong>：技术学习重在实践，”实践才是检验真理的唯一标准”，请务必动手操作。</li><li><strong>反馈交流</strong>：欢迎通过评论系统或者联系我，分享你的学习心得和疑问，共同进步！</li></ol><h2 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h2><p>我是一名热爱技术的学习者和分享者。2023 年 8 月踏入大学校园，从最初的迷茫到现在的技术探索，这一路走来收获颇丰。技术学习不仅是谋生技能，更是思维训练和解决问题的能力培养。</p><p>博客中的内容源于我的学习笔记和实战经验，希望能帮助更多像我一样的学者少走弯路，高效成长。虽然文字表达难以完全还原课堂讲解的生动性与完整性，但我会持续优化内容，让技术分享更有价值。</p><h2 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h2><ul><li><strong>邮箱：<a href="mailto:&#104;&#x63;&#x31;&#x39;&#54;&#48;&#48;&#x37;&#x34;&#48;&#x38;&#49;&#64;&#x71;&#113;&#x2e;&#99;&#x6f;&#109;">hc1960074081@qq.com</a></strong></li><li><strong>微信：暂时不愿透露</strong></li></ul><p>感谢你的阅读，愿我们都能在技术的海洋中不断探索、成长！🚀</p>]]></content>
      
      
      <categories>
          
          <category> 网站 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网站 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
