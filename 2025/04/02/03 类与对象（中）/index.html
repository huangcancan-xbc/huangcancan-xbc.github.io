<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>类与对象（中） | 小米里的大麦的博客</title><meta name="keywords" content="C++"><meta name="author" content="小米里的大麦"><meta name="copyright" content="小米里的大麦"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="类与对象（中）"><meta name="application-name" content="类与对象（中）"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="类与对象（中）"><meta property="og:url" content="http://example.com/2025/04/02/03 类与对象（中）/index.html"><meta property="og:site_name" content="小米里的大麦的博客"><meta property="og:description" content="1. 类的 6 个默认成员函数默认成员函数的含义： 即使一个类什么都不写，编译器也会默认生成 4 以下个成员函数：  默认构造函数（初始化对象时调用）。 拷贝构造函数（用已有对象创建新对象时调用）。 析构函数（对象生命周期结束时调用）。 赋值运算符重载（用 &amp;#x3D; 赋值时调用）。  可以直接使用的操作符"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Blog/20250314131841400.png?_r_=125d5323-675c-4113-ef67-3ce6ae17162e"><meta property="article:author" content="小米里的大麦"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Blog/20250314131841400.png?_r_=125d5323-675c-4113-ef67-3ce6ae17162e"><meta name="description" content="1. 类的 6 个默认成员函数默认成员函数的含义： 即使一个类什么都不写，编译器也会默认生成 4 以下个成员函数：  默认构造函数（初始化对象时调用）。 拷贝构造函数（用已有对象创建新对象时调用）。 析构函数（对象生命周期结束时调用）。 赋值运算符重载（用 &amp;#x3D; 赋值时调用）。  可以直接使用的操作符"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="http://example.com/2025/04/02/03%20%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%AD%EF%BC%89/"><link rel="preconnect" href="//cdn.cbd.int"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="manifest" href="/manifest.json"/><meta name="msapplication-TileColor" content="var(--anzhiyu-main)"/><link rel="mask-icon" href="/img/siteicon/apple-icon-180.png" color="#5bbad5"/><link rel="apple-touch-icon" sizes="180x180" href="/img/siteicon/apple-icon-180.png"/><link rel="apple-touch-icon-precomposed" sizes="180x180" href="/img/siteicon/apple-icon-180.png"/><link rel="icon" type="image/png" sizes="32x32" href="/img/siteicon/32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/img/siteicon/16.png"/><link rel="bookmark" href="/img/siteicon/apple-icon-180.png"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2048-2732.jpg" media="(device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2732-2048.jpg" media="(device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1668-2388.jpg" media="(device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2388-1668.jpg" media="(device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1536-2048.jpg" media="(device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2048-1536.jpg" media="(device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1668-2224.jpg" media="(device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2224-1668.jpg" media="(device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1620-2160.jpg" media="(device-width: 810px) and (device-height: 1080px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2160-1620.jpg" media="(device-width: 810px) and (device-height: 1080px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1290-2796.jpg" media="(device-width: 430px) and (device-height: 932px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2796-1290.jpg" media="(device-width: 430px) and (device-height: 932px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1179-2556.jpg" media="(device-width: 393px) and (device-height: 852px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2556-1179.jpg" media="(device-width: 393px) and (device-height: 852px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1284-2778.jpg" media="(device-width: 428px) and (device-height: 926px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2778-1284.jpg" media="(device-width: 428px) and (device-height: 926px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1170-2532.jpg" media="(device-width: 390px) and (device-height: 844px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2532-1170.jpg" media="(device-width: 390px) and (device-height: 844px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1125-2436.jpg" media="(device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2436-1125.jpg" media="(device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1242-2688.jpg" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2688-1242.jpg" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-828-1792.jpg" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1792-828.jpg" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1242-2208.jpg" media="(device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2208-1242.jpg" media="(device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-750-1334.jpg" media="(device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1334-750.jpg" media="(device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-640-1136.jpg" media="(device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1136-640.jpg" media="(device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: undefined,
  postHeadAiDescription: {"enable":true,"gptName":"小米里的大麦","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: undefined,
  greetingBox: {"enable":true,"default":"晚上好👋","list":[{"greeting":"晚安😴","startTime":0,"endTime":5},{"greeting":"早上好鸭👋, 祝你一天好心情！","startTime":6,"endTime":9},{"greeting":"上午好👋, 状态很好，鼓励一下～","startTime":10,"endTime":10},{"greeting":"11点多啦, 在坚持一下就吃饭啦～","startTime":11,"endTime":11},{"greeting":"午安👋, 宝贝","startTime":12,"endTime":14},{"greeting":"🌈充实的一天辛苦啦！","startTime":14,"endTime":18},{"greeting":"19点喽, 奖励一顿丰盛的大餐吧🍔。","startTime":19,"endTime":19},{"greeting":"晚上好👋, 在属于自己的时间好好放松😌~","startTime":20,"endTime":24}]},
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  music_page_default: "nav_music",
  root: '/',
  preloader: {"source":3},
  friends_vue_info: {"apiurl":null},
  navMusic: true,
  mainTone: undefined,
  authorStatus: {"skills":["🧐 准备中，就快好了，真的！😭"]},
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: 小米里的大麦","link":"链接: ","source":"来源: 小米里的大麦的博客","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'mediumZoom',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: '小米里的大麦的博客',
  title: '类与对象（中）',
  postAI: '',
  pageFillDescription: '1. 类的 6 个默认成员函数, 传道解惑：, Q1：e1——类的实例化：, Q2：ePtr —— Example 类的指针：, 2. 构造函数, 1. 函数名与类名相同, 2. 无返回值, 3. 对象实例化时自动调用构造函数, 4. 构造函数可以重载, 5. 默认构造函数的生成规则, 6. 默认构造函数对内置和自定义类型的处理, 7. 默认构造函数的种类, 2.1. 无参构造函数（默认构造函数）, 2.2 带参构造函数, 传道解惑：, Q1：公有（public）私有（private）部分的关系：, Q2：私有变量是否必须在公有部分出现？, Q3：关于编译器生成的默认成员函数在不实现构造函数的情况下编译器会生成默认的构造函数。但是看起来默认构造函数又没什么用？对象调用了编译器生成的默认构造函数但是对象里依旧是随机值。也就是说在这里编译器生成的默认构造函数并没有什么用？, 3. 析构函数, 3.1 析构函数的 6 个特征：, 1. 析构函数的命名规则：类名前加字符 ~, 2. 无参数、无返回值类型, 3. 一个类只能有一个析构函数且不能重载, 4. 对象生命周期结束时自动调用析构函数, 5. 默认析构函数：处理类中自定义类型成员的析构, 6. 没有资源时可以不写有资源时必须写, 3.2 示例：, 4. 拷贝构造函数, 4.1 拷贝构造函数的 5 个特征：, 1. 拷贝构造函数是构造函数的一个重载形式, 2. 参数必须是类类型的引用, 3. 默认拷贝构造函数, 4. 是否需要显式定义拷贝构造函数？, 5. 拷贝构造函数的典型调用场景, 提高效率的建议, 4.2 默认拷贝构造函数, 4.3 自定义拷贝构造函数, 5. 赋值运算符重载, 5.1 对运算符重载关键点解释：, 1. 运算符重载的本质, 2. 运算符重载规则, 3. 成员函数 vs 全局函数重载, 4. 常见运算符重载的实现, 赋值运算符重载（operator=）, 前置++ 和 后置++ 重载, 加法运算符重载（operator+）, 5. 默认运算符重载 vs 自定义实现, 6. 为什么返回引用？, 总结, 5.2 示例：, 1. 默认实现, 2. 重载赋值运算符, 重载 +, 重载 ==, 6. const 成员, 6.1 总结规则：, 6.2 适用场景：, 6.3 关键知识点：, 传道解惑：, Q1： const 对象可以调用非 const 成员函数吗？, Q2：const 对象可以调用 const 成员函数吗？, Q3：const 成员函数内可以调用其它的非 const 成员函数吗？, Q4 const 成员函数内可以调用其它的 const 成员函数吗？, 7. 取地址及 const 取地址操作符重载, 7.1 取地址操作符 amp 默认行为, 7.2 取地址操作符的重载, 7.3 代码示例与解释, 传道解惑, Q1：两种版本为什么重要？, Q2：取地址操作符重载的应用场景？, Q3：为什么需要区分 const 对象的取地址？类的个默认成员函数默认成员函数的含义即使一个类什么都不写编译器也会默认生成以下个成员函数默认构造函数初始化对象时调用拷贝构造函数用已有对象创建新对象时调用析构函数对象生命周期结束时调用赋值运算符重载用赋值时调用可以直接使用的操作符取地址操作符常量取地址操作符代码示例空类未显式定义任何成员函数调用默认构造函数调用拷贝构造函数调用取地址操作符在程序结束时和调用析构函数传道解惑类的实例化实例化指的是通过类来创建对象的过程当你写出类似的代码时就是类的一个实例对象实例化的本质就是通过类来创建一个具体的对象类是一种模板或者蓝图它描述了对象的属性和行为但它本身不是一个具体的对象类可以看作是定义对象的结构和功能而实例化就是将类的结构和功能变成一个可以使用的具体对象举个例子类的成员创建一个名为的类对象是一个类定义了一个成员变量是通过类进行实例化的对象它是类的一个具体实例类的指针是一个指向类对象的指针表示指向类的指针表示取对象的地址也就是指向的内存位置可以通过指针操作访问对象的成员虽然在这个示例中类没有成员注意如果用户显式定义任何一个成员函数编译器将不再生成对应的默认版本构造函数构造函数是类的一个特殊成员函数用于在创建对象时进行初始化构造函数的名字与类名相同并且没有返回值它可以是无参构造函数即默认构造函数或者带参构造函数即带参数的构造函数主要是用于初始化对象的成员函数可以有参数无参构造函数也称作默认构造函数是一种特殊类型的构造函数没有参数它用于当创建对象时不需要传递任何参数如果类没有其他构造函数编译器通常会自动提供一个默认的版本所以默认构造函数是一种特殊的构造函数是构造函数的一种形式可以是显式定义的也可以是编译器自动生成的通常在创建对象时如果没有传递任何参数就会调用它带参构造函数是另一种构造函数它带有参数在创建对象时通过传递不同的参数来定制对象的初始化构造函数是中用于初始化对象的特殊函数它的名字虽然叫构造但它的主要任务不是开辟内存空间而是初始化对象的成员变量以下是构造函数个特征函数名与类名相同构造函数的名字和类名完全一样这是的规定用于识别构造函数例子初始化代码无返回值构造函数没有返回值也不能定义返回类型包括理由构造函数的目的是初始化对象不需要返回任何东西调用它的结果就是一个已初始化的对象对象实例化时自动调用构造函数构造函数会在对象创建时由编译器自动调用无需显式调用例如构造函数被调用自动调用构造函数构造函数可以重载构造函数支持重载即可以有多个构造函数但参数列表必须不同通过重载用户可以根据需要初始化对象无参构造函数带参数的构造函数调用无参构造函数调用带参构造函数默认构造函数的生成规则如果类中没有显式定义无参构造函数编译器会自动生成一个默认无参构造函数如果用户显式定义了任意构造函数无论是否带参数编译器将不再生成默认无参构造函数除非显式定义一个无参构造函数例子自动生成无参默认构造函数错误因为没有无参构造函数默认构造函数对内置和自定义类型的处理内置类型如默认构造函数不会初始化内置类型成员成员变量可能是随机值例如默认值是随机的解决方法使用提供的默认值默认值为自定义类型如编译器生成的默认构造函数会调用这些类型成员的默认构造函数例子构造函数自定义类型成员实例化自定义类型成员输出构造函数默认构造函数的种类无参的构造函数和全缺省的构造函数所有参数都有默认值的构造函数都称为默认构造函数并且默认构造函数只能有一个注意无参构造函数全缺省构造函数我们没写编译器默认生成的构造函数都可以认为是默认构造函数无参构造函数没有任何参数的构造函数全缺省构造函数所有参数都有默认值的构造函数两者都属于默认构造函数的范畴但它们的定义和使用场景有所不同例子无参构造函数全缺省构造函数构造函数的核心是初始化对象的成员而非创建内存空间默认构造函数的行为取决于对象成员的类型内置类型成员默认不初始化可能是随机值自定义类型成员会自动调用其默认构造函数通过合理设计构造函数可以确保对象在创建时处于有效的初始状态在及更高版本中编译器还会生成移动构造函数和移动赋值运算符用于优化资源管理这些函数允许对象在移动语义下高效地转移资源而不是进行拷贝例如移动构造函数可以将一个临时对象的资源直接转移给新对象避免不必要的拷贝操作这些内容将在后续章节中详细介绍无参构造函数默认构造函数没有参数创建对象时会被默认调用如果用户没有定义任何构造函数编译器会生成一个无参构造函数一旦用户定义了任何构造函数编译器将不再生成无参构造函数被调用私有成员变量调用无参构造函数注意如果通过无参构造函数创建对象时对象后面不用跟括号否则就成了函数声明输出带参构造函数可接受参数并根据用户输入初始化对象如果只定义了带参构造函数编译器不会生成默认无参构造函数正常调用错误没有默认无参构造函数传道解惑公有私有部分的关系在中类的成员变量和函数可以被指定为公有或私有这些访问控制符决定了成员的访问权限接下来我会详细讲解公有部分和私有部分的作用和关系公有部分访问权限任何外部代码比如函数都可以直接访问和修改公有成员简单来说公有部分的成员对外部可见适用场景一般情况下我们会将类中的接口函数或需要外部访问的数据声明为公有以便外部能够与对象交互私有部分访问权限私有成员只能在类内部的成员函数中访问外部的代码无法直接访问或修改这些成员私有部分用于隐藏类的内部实现细节只允许通过公有的接口与外部交互适用场景私有成员通常是类的内部数据这些数据不希望被外部代码随意修改通过这种方式我们可以控制数据的访问权限和保证数据的正确性通过公有函数进行访问或修改关系数据封装这就是面向对象编程的核心之一即将数据和操作数据的代码封装在一起私有成员数据保护了对象的内部状态避免了外部对数据的不恰当修改公有函数则为外部提供了访问和修改数据的接口分离接口与实现通过将接口函数如放在公有部分类的使用者只需关心接口如何使用而不需要知道具体的实现方式私有部分负责实现细节公有部分提供与外界的交互保护私有成员提供类的内部实现而公有成员则提供与外部的交互接口这种设计有助于封装和数据保护确保类的使用者不破坏对象的状态私有变量是否必须在公有部分出现不需要类中的私有变量是可以仅供类内部使用的它们不一定需要通过公有部分暴露出来私有成员通常是不公开给外部的所以是非必须出现在公有部分的实际上类的设计应该遵循数据隐藏原则即只有通过公有函数外部才能间接地访问或修改私有数据这样能保护数据的完整性避免外部代码直接改变私有数据如果你希望外部能够访问和操作这些私有变量通常会提供一些公有方法如和来间接操作它们但这不是强制的关于编译器生成的默认成员函数在不实现构造函数的情况下编译器会生成默认的构造函数但是看起来默认构造函数又没什么用对象调用了编译器生成的默认构造函数但是对象里依旧是随机值也就是说在这里编译器生成的默认构造函数并没有什么用解答把类型分成内置类型基本类型和自定义类型内置类型就是语言提供的数据类型如自定义类型就是我们使用等自己定义的类型编译器生成默认的构造函数会对自定义类型成员调用的它的默认成员函数即编译器生成的默认构造函数在类的成员变量是自定义类型非内置类型时会自动调用这些自定义类型的默认构造函数这是的一个机制用于确保对象的每个成员都得到正确的初始化具体解释内置类型如等编译器生成的默认构造函数不会对内置类型成员进行初始化这些成员会是随机值例如内置类型成员编译器生成的默认构造函数不会初始化随机值自定义类型如或如果类中包含自定义类型的成员变量编译器生成的默认构造函数会自动调用这些成员的默认构造函数以初始化它们例如的默认构造函数被调用自定义类型成员自动调用编译器生成的默认构造函数输出的默认构造函数被调用在这个例子中类没有显式定义构造函数但编译器生成了一个默认构造函数而这个默认构造函数在初始化时自动调用了类的默认构造函数为什么这样设计自定义类型的对象可能需要复杂的初始化工作比如为动态分配内存初始化状态等默认构造函数确保这些工作在创建对象时正确完成内置类型如等通常不需要调用构造函数默认值可以通过中的默认值赋予当类中有自定义类型的成员变量时如果没有显式定义构造函数编译器会生成一个默认构造函数这个默认构造函数会对自定义类型成员变量调用它们自己的默认构造函数确保它们被正确初始化这意味着你无需手动初始化这些成员自定义类型的构造函数会自动运行完成初始化工作析构函数析构函数与构造函数功能相反析构函数不是完成对对象本身的销毁局部对象销毁工作是由编译器完成的而对象在销毁时会自动调用析构函数完成对象中资源的清理工作即用于释放资源析构函数是中的一个特殊成员函数专门用于对象生命周期结束时释放资源以下是对上述特征的通俗易懂的解释析构函数的个特征析构函数的命名规则类名前加字符析构函数的名字和类名类似但前面加了一个波浪号它是的规定用来显式区分析构函数比如析构代码无参数无返回值类型析构函数不接受任何参数也不能返回任何值它的作用是清理资源而不是用来进行复杂的逻辑处理因此不需要参数或返回值例如不允许带参数或返回值一个类只能有一个析构函数且不能重载析构函数唯一且不能有多个版本编译器在编译时知道如何自动调用析构函数因此多版本没有意义对象生命周期结束时自动调用析构函数当一个对象不再需要时如超出作用域程序结束或显式删除时编译器会自动调用析构函数无需手动调用例如创建对象调用构造函数作用域结束析构函数自动调用如果对象是动态分配的用释放时也会调用动态创建对象自动调用析构函数默认析构函数处理类中自定义类型成员的析构如果没有显式定义析构函数编译器会生成一个默认析构函数它会对类中所有非基本类型的成员调用其析构函数比如自定义类型成员编译器生成的默认析构函数会自动调用的析构函数释放其内部的资源没有资源时可以不写有资源时必须写没有资源如果类中没有动态分配的资源直接使用编译器生成的默认析构函数即可在这种情况下系统生成的默认析构函数已经足够比如无动态资源有资源如果类中有动态分配的资源如申请的内存一定要定义析构函数手动释放这些资源否则会造成内存泄漏动态分配内存释放内存避免泄漏析构函数的核心作用是清理资源尤其是在有动态分配资源的情况下如果没有动态资源则可以省略不写的编译器会在合适的时候自动调用析构函数无需我们手动干预记住如果忘记写析构函数释放资源程序可能会导致内存泄漏尤其是当类中包含动态内存时示例构造函数被调用析构函数被调用创建对象时调用构造函数程序结束时被销毁析构函数自动调用输出构造函数被调用析构函数被调用拷贝构造函数拷贝构造函数是中的一个特殊构造函数用于通过已有对象初始化一个新对象创建一个与已有对象内容完全相同的新对象拷贝构造函数的个特征拷贝构造函数是构造函数的一个重载形式拷贝构造函数和普通构造函数一样是初始化对象的但它专门用于用另一个对象初始化当前对象它是构造函数的一种重载形式形式如下拷贝构造函数声明注意拷贝构造函数的名字和类名一样只是参数是当前类对象的引用参数必须是类类型的引用拷贝构造函数的参数只能是类类型的引用不能用值传递否则会导致编译器报错或发生死循环错误值传递会导致递归调用这是因为如果参数使用值传递在传递参数时会调用拷贝构造函数拷贝构造函数又会调用自己导致无限递归最终栈溢出正确形式使用引用避免递归默认拷贝构造函数如果用户没有显式定义拷贝构造函数编译器会自动生成一个默认的拷贝构造函数默认拷贝构造函数会逐字节拷贝对象的成员变量这种拷贝被称为浅拷贝浅拷贝的含义对于内置类型如直接复制值对于自定义类型成员编译器会调用这些成员自己的拷贝构造函数例子默认构造函数拷贝构造函数浅拷贝析构函数用于释放动态分配的内存如果指向动态分配的内存释放它动态分配内存浅拷贝会与共享相同的指针输出和的值手动释放的动态内存现在是悬空指针访问它会导致未定义行为危险问题如果类中有指针等动态资源浅拷贝会导致问题比如和指向同一块内存释放时可能导致重复释放悬空指针是否需要显式定义拷贝构造函数没有动态资源时不涉及指针或资源申请编译器生成的默认拷贝构造函数已经可以正常工作可以不写有动态资源时涉及指针或资源申请必须显式定义拷贝构造函数完成深拷贝避免内存管理问题深拷贝的实现深拷贝指的是重新分配内存并复制内容而不是直接复制指针地址自定义拷贝构造函数深拷贝重新分配内存释放动态资源拷贝构造函数的典型调用场景场景使用已有对象创建新对象普通构造函数拷贝构造函数场景函数参数为类类型对象如果不使用引用会调用拷贝构造函数场景函数返回类类型对象返回时可能调用拷贝构造函数提高效率的建议传参时使用引用避免拷贝对象的开销使用引用不调用拷贝构造函数返回值优化的移动语义对于返回值尽量结合移动构造函数使用减少不必要的拷贝综上拷贝构造函数是用已有对象初始化新对象的工具编译器默认的拷贝构造函数使用浅拷贝只能处理简单类没有动态资源对于涉及动态资源的类必须显式定义拷贝构造函数确保深拷贝避免内存泄漏或重复释放默认拷贝构造函数编译器默认会生成一个浅拷贝版本调用默认拷贝构造函数输出自定义拷贝构造函数当对象包含动态资源时必须显式定义深拷贝逻辑自定义拷贝构造函数赋值运算符重载中的运算符重载允许我们为类或对象定义新的运算符行为使代码更直观和可读对运算符重载关键点解释运算符重载的本质运算符重载是通过定义一个特殊的函数改变运算符对类对象的行为函数名称后接具体运算符例如是用来重载加法运算符的函数函数原型返回值类型操作符参数列表例子运算符重载规则不能创建新的运算符只能重载已有运算符不能重载不存在的符号如是非法的内置类型的运算符不能改变其含义例如整数相加的行为不能被改变某些运算符不能被重载不能被重载至少有一个操作数是类类型不能对完全是内置类型的运算符重载比如试图重载成员函数全局函数重载运算符重载可以是类的成员函数或全局函数成员函数重载第一个操作数是当前对象编译器会将操作数传递给隐藏的指针全局函数重载需要将两个操作数都作为参数传递注意赋值运算符重载必须是成员函数不能是全局函数常见运算符重载的实现赋值运算符重载特点参数类型避免不必要的拷贝传引用效率更高返回值类型返回对象的引用支持连续赋值如检测自赋值检查是否给自己赋值自赋值检查非常重要因为如果不检查自赋值可能会导致资源被错误释放或重复释放例如如果则会释放当前对象的资源导致后续操作无法正确执行返回让赋值语句返回当前对象实现检测是否自赋值释放已有资源深拷贝避免共享指针导致问题返回当前对象的引用前置和后置重载前置返回增加后的值后置返回增加前的旧值调用时会多传一个参数编译器自动处理实现前置返回引用自增返回当前对象后置返回值保存当前对象自增返回旧值加法运算符重载加法运算符重载支持对象间的相加操作实现重载加法运算符两个对象相加默认运算符重载自定义实现默认行为如果不显式实现赋值运算符或拷贝构造函数编译器会生成默认版本逐字节拷贝默认行为对于内置类型如完全适用对于动态资源如指针默认行为可能导致浅拷贝问题资源共享导致重复释放或悬空指针是否需要自定义实现如果类中没有动态资源如只包含内置类型或容器默认生成的运算符重载就够用如果类中有动态资源如指针必须自定义运算符重载确保深拷贝和正确释放资源为什么返回引用在运算符重载中返回引用有助于提高效率并支持连续赋值操作如例如赋值运算符处理赋值逻辑返回当前对象的引用如果返回值而非引用则每次赋值都会产生一个临时对象效率低总结运算符重载让类对象可以像内置类型一样进行操作提升了代码的可读性但以下几点需要注意只有已有的运算符可以被重载且至少有一个操作数是类类型对于有动态资源的类必须重载运算符以避免浅拷贝问题返回引用是为了支持连续赋值和提高效率某些运算符不能被重载比如和通过合理设计运算符重载可以让类使用起来更像内置类型从而写出更加优雅和简洁的代码示例默认实现编译器默认按字节拷贝可能造成资源冲突调用默认赋值运算符输出重载赋值运算符当对象管理动态资源时需要自定义赋值运算符防止自赋值重载日期加天输出重载成员将修饰的成员函数称之为成员函数成员函数修饰了隐含的指针为类型表示该函数不能修改类的成员变量但可以通过修饰的成员变量在成员函数中进行修改年月日让我们逐步理解上面代码定义了两个函数普通成员函数允许修改对象成员函数不能修改对象函数中是普通对象调用时编译器会选择非版本的是对象调用时编译器会选择版本的总结规则非对象可以调用普通成员函数可以调用成员函数对象只能调用成员函数普通成员函数可以调用普通成员函数不能调用成员函数成员函数不能调用普通成员函数可以调用成员函数适用场景当你希望某个成员函数不修改对象的任何成员变量时应将其声明为成员函数这样可以确保该函数在对象上调用时不会破坏对象的不可变性例如函数通常不需要修改对象状态因此可以声明为成员函数关键知识点修饰的成员函数会将隐含的指针转换为类型编译器通过限定符保证不会在成员函数中修改成员变量如果非成员变量必须在成员函数中被修改可以使用关键字修饰这些变量使其在上下文中也可变但要谨慎使用传道解惑对象可以调用非成员函数吗不可以对象意味着这个对象的任何成员都不能被修改非成员函数没有限制修改成员变量的行为因此对象无法调用非成员函数否则会破坏对象的不变性在上面代码中是一个对象只能调用不能调用非成员函数编译器会通过检查属性阻止这种调用对象可以调用成员函数吗可以成员函数会修饰指针为表示该函数内部不会修改类的成员变量因此对象可以调用成员函数因为这不会破坏对象的不可变性在上面代码中调用的就是因为是成员函数成员函数内可以调用其它的非成员函数吗不可以因为成员函数的指针是的即表示它不能修改成员变量而非成员函数默认的指针是允许修改成员变量因此成员函数无法调用非成员函数因为这样可能导致间接修改成员变量从而违反了的约束成员函数内可以调用其它的成员函数吗可以成员函数的指针是的调用其他成员函数不会违反的约束因为成员函数保证不修改成员变量取地址及取地址操作符重载在中取地址操作符不能被真正重载但可以通过定义特殊的成员函数来改变其行为这种实现方式类似于运算符重载但并非真正的重载结合它的行为会更有针对性取地址操作符不能被重载的原因是它是一个基础操作符用于获取对象的地址如果允许重载可能会导致地址获取的语义混乱取地址操作符默认行为默认情况下操作符返回对象的内存地址例如获取了的地址在类中取地址操作符通常也可以被用来获取对象的地址取地址操作符的重载中无法重载取地址操作符但可以通过定义成员函数来改变其行为例如通过返回自定义指针对象而不是直接返回重载时可以区分普通对象的取地址对象的取地址代码示例与解释重载取地址操作符的代码以下是一个简单示例展示如何通过和非版本的重载来实现不同的行为非版本的取地址操作符重载非取地址操作符被调用版本的取地址操作符重载取地址操作符被调用普通对象对象调用非版本的取地址操作符调用版本的取地址操作符输出结果非取地址操作符被调用取地址操作符被调用代码解释普通对象调用非版本的取地址操作符当我们对普通对象使用时调用的是返回类型是一个非指针即这意味着我们可以通过这个指针修改对象调用版本的取地址操作符当我们对对象使用时调用的是返回类型是即一个不可修改的指针这保证了通过返回的地址无法修改传道解惑两种版本为什么重要如果只有普通的非重载对象调用时会报错因为无法确保对象的不可变性如果只有版本重载普通对象也只能得到一个指针限制了可操作性因此同时提供两个版本普通对象取地址时返回普通指针灵活操作对象取地址时返回指针保护不可变性取地址操作符重载的应用场景调试日志可以在取地址时打印出信息便于调试对象管理可以控制对象暴露出去的指针避免外部直接操作原始地址定制行为对于特定的类可以在取地址时返回自定义指针对象而不是直接返回为什么需要区分对象的取地址假如我们不区分和非对象取地址操作就会产生如下问题如果没有重载这会破坏的不可变性通过引入版本的取地址操作符重载编译器可以在对象中强制返回指针保护数据安全取地址操作符重载的作用自定义取地址操作符的行为区分普通对象和对象的地址获取方式注意事项对普通对象返回普通指针对对象返回指针确保不可变性这是一种增强代码灵活性与安全性的手段同时对复杂场景如调试或资源管理非常有用',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-04-03 22:02:26',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 8 || hour >= 20
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://github.com/huangcancan-xbc/Drawing-bed/blob/master/Blog/20250307201719879.png?raw=true"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><div class="back-home-button"><i class="anzhiyufont anzhiyu-icon-grip-vertical"></i><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">社交</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://github.com/huangcancan-xbc" title="GitHub"><img class="back-menu-item-icon" src="/img/favicon.ico" alt="GitHub"/><span class="back-menu-item-text">GitHub</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://gitee.com/huang-cancan-xbc" title="gitee"><img class="back-menu-item-icon" src="/img/favicon.ico" alt="gitee"/><span class="back-menu-item-text">gitee</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">博客</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://blog.csdn.net/Huangcancan666?type=blog" title="CSDN"><img class="back-menu-item-icon" src="/img/favicon.ico" alt="CSDN"/><span class="back-menu-item-text">CSDN</span></a></div></div></div></div><a id="site-name" href="/" accesskey="h"><div class="title">小米里的大麦的博客</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/fcircle/"><i class="anzhiyufont anzhiyu-icon-artstation faa-tada" style="font-size: 0.9em;"></i><span> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><div class="nav-button" id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" title="搜索🔍" accesskey="s"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span> 搜索</span></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Blog/20250403212543768.png" target="_blank"><img class="post-qr-code-img" alt="微信" src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Blog/20250403212543768.png"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Blog/20250403212622868.png" target="_blank"><img class="post-qr-code-img" alt="支付宝" src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Blog/20250403212622868.png"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/C/" style="font-size: 1.05rem;">C++<sup>3</sup></a><a href="/tags/Obsidian/" style="font-size: 1.05rem;">Obsidian<sup>1</sup></a><a href="/tags/%E5%B7%A5%E5%85%B7/" style="font-size: 1.05rem;">工具<sup>1</sup></a><a href="/tags/%E7%AC%94%E8%AE%B0/" style="font-size: 1.05rem;">笔记<sup>1</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/04/"><span class="card-archive-list-date">四月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">3</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/09/"><span class="card-archive-list-date">九月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/C/" itemprop="url">C++</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/C/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>C++</span></a></span></div></div><h1 class="post-title" itemprop="name headline">类与对象（中）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2025-04-01T16:00:00.000Z" title="发表于 2025-04-02 00:00:00">2025-04-02</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2025-04-03T14:02:26.624Z" title="更新于 2025-04-03 22:02:26">2025-04-03</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="post-meta-wordcount"><i class="anzhiyufont anzhiyu-icon-file-word post-meta-icon" title="文章字数"></i><span class="post-meta-label" title="文章字数">字数总计:</span><span class="word-count" title="文章字数">10.2k</span><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-clock post-meta-icon" title="阅读时长"></i><span class="post-meta-label" title="阅读时长">阅读时长:</span><span>36分钟</span></span><span class="post-meta-separator"></span><span class="post-meta-pv-cv" id="" data-flag-title="类与对象（中）"><i class="anzhiyufont anzhiyu-icon-fw-eye post-meta-icon"></i><span class="post-meta-label" title="阅读量">阅读量:</span><span id="busuanzi_value_page_pv"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></span><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为西安"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>西安</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Blog/20250314131841400.png?_r_=125d5323-675c-4113-ef67-3ce6ae17162e"></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="http://example.com/2025/04/02/03%20%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%AD%EF%BC%89/"><header><a class="post-meta-categories" href="/categories/C/" itemprop="url">C++</a><a href="/tags/C/" tabindex="-1" itemprop="url">C++</a><h1 id="CrawlerTitle" itemprop="name headline">类与对象（中）</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">小米里的大麦</span><time itemprop="dateCreated datePublished" datetime="2025-04-01T16:00:00.000Z" title="发表于 2025-04-02 00:00:00">2025-04-02</time><time itemprop="dateCreated datePublished" datetime="2025-04-03T14:02:26.624Z" title="更新于 2025-04-03 22:02:26">2025-04-03</time></header><h2 id="1-类的-6-个默认成员函数"><a href="#1-类的-6-个默认成员函数" class="headerlink" title="1. 类的 6 个默认成员函数"></a>1. 类的 6 个默认成员函数</h2><p><strong>默认成员函数的含义</strong>：<br> 即使一个类什么都不写，编译器也会默认生成 <code>4</code> 以下个成员函数：</p>
<ol>
<li><strong>默认构造函数</strong>（初始化对象时调用）。</li>
<li><strong>拷贝构造函数</strong>（用已有对象创建新对象时调用）。</li>
<li><strong>析构函数</strong>（对象生命周期结束时调用）。</li>
<li><strong>赋值运算符重载</strong>（用 <code>=</code> 赋值时调用）。</li>
</ol>
<p>可以直接使用的操作符：</p>
<ol>
<li><strong>取地址操作符</strong> <code>&amp;</code>。</li>
<li><strong>常量取地址操作符</strong> <code>const &amp;</code>。</li>
</ol>
<p><strong>代码示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 空类，未显式定义任何成员函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Example e1;  			<span class="comment">// 调用默认构造函数</span></span><br><span class="line">    Example e2 = e1;  		<span class="comment">// 调用拷贝构造函数</span></span><br><span class="line">    Example* ePtr = &amp;e1;  	<span class="comment">// 调用取地址操作符</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  				<span class="comment">// 在程序结束时，e1 和 e2 调用析构函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<h2 id="传道解惑："><a href="#传道解惑：" class="headerlink" title="传道解惑："></a>传道解惑：</h2><h3 id="Q1：e1——类的实例化："><a href="#Q1：e1——类的实例化：" class="headerlink" title="Q1：e1——类的实例化："></a>Q1：<code>e1</code>——类的实例化：</h3><ul>
<li><strong>实例化</strong>（Instantiating）指的是通过类来创建对象的过程。当你写出类似 <code>Example e1;</code> 的代码时，<code>e1</code> 就是 <code>Example</code> 类的一个实例（对象）。实例化的本质就是通过类（<code>Example</code>）来创建一个具体的对象（<code>e1</code>）。</li>
<li><strong>类</strong> 是一种模板或者蓝图，它描述了对象的属性和行为，但它本身不是一个具体的对象。类可以看作是定义对象的结构和功能，而实例化就是将类的结构和功能变成一个可以使用的具体对象。</li>
</ul>
<p><strong>举个例子</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">Example</span></span><br><span class="line">&gt;&#123;</span><br><span class="line">&gt;<span class="keyword">public</span>:</span><br><span class="line">   <span class="type">int</span> value;  	<span class="comment">// 类的成员</span></span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">&gt;</span>&#123;</span><br><span class="line">   Example e1;  	<span class="comment">// 创建一个名为 e1 的 Example 类对象</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Example</code> 是一个类，定义了一个成员变量 <code>value</code>。</li>
<li><code>e1</code> 是通过 <code>Example</code> 类进行实例化的对象。它是 <code>Example</code> 类的一个具体实例。</li>
</ul>
<hr>
<h3 id="Q2：ePtr-——-Example-类的指针："><a href="#Q2：ePtr-——-Example-类的指针：" class="headerlink" title="Q2：ePtr —— Example 类的指针："></a>Q2：<code>ePtr</code> —— <code>Example</code> 类的指针：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;Example* ePtr = &amp;e1;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>ePtr</code> 是一个指向 <code>Example</code> 类对象的指针。<code>Example*</code> 表示“指向 <code>Example</code> 类的指针”。</li>
<li><code>&amp;e1</code> 表示取 <code>e1</code> 对象的地址，也就是 <code>ePtr</code> 指向 <code>e1</code> 的内存位置。</li>
<li><code>ePtr</code> 可以通过指针操作访问 <code>e1</code> 对象的成员（虽然在这个示例中 <code>Example</code> 类没有成员）。</li>
</ul>
</blockquote>
<p>&#x3D;&#x3D;<strong>注意</strong>&#x3D;&#x3D;：如果用户显式定义任何一个成员函数，编译器将不再生成对应的默认版本。</p>
<hr>
<h2 id="2-构造函数"><a href="#2-构造函数" class="headerlink" title="2. 构造函数"></a>2. 构造函数</h2><p><strong>构造函数</strong>（Constructor）：是类的一个特殊成员函数，用于在创建对象时进行初始化。构造函数的名字与类名相同，并且没有返回值。它可以是 <strong>无参构造函数</strong>（即默认构造函数）或者 <strong>带参构造函数</strong>（即带参数的构造函数），主要是用于初始化对象的成员函数，可以有参数。</p>
<ul>
<li><strong>无参构造函数</strong>（Default Constructor）：也称作 <strong>默认构造函数</strong>，是一种特殊类型的构造函数，<strong>没有参数</strong>。它用于当创建对象时不需要传递任何参数，如果类没有其他构造函数，编译器通常会自动提供一个默认的版本。（<strong>所以</strong>，默认构造函数是一种特殊的构造函数，是构造函数的一种形式，可以是显式定义的，也可以是编译器自动生成的，通常在创建对象时，如果没有传递任何参数，就会调用它）</li>
<li><strong>带参构造函数</strong>（Parameterized Constructor）：是另一种构造函数，它 <strong>带有参数</strong>，在创建对象时，通过传递不同的参数来定制对象的初始化。</li>
</ul>
<blockquote>
<p>构造函数是 C++ 中用于初始化对象的特殊函数。它的名字虽然叫“构造”，但它的主要任务不是开辟内存空间，而是初始化对象的成员变量。以下是构造函数 <code>7</code> 个特征：</p>
<h4 id="1-函数名与类名相同"><a href="#1-函数名与类名相同" class="headerlink" title="1. 函数名与类名相同"></a>1. 函数名与类名相同</h4><ul>
<li><p>构造函数的名字和类名完全一样，这是 C++ 的规定，用于识别构造函数。</p>
</li>
<li><p>例子：</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&gt;&#123;</span><br><span class="line">&gt;<span class="keyword">public</span>:</span><br><span class="line">   <span class="built_in">MyClass</span>()</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="comment">// 初始化代码</span></span><br><span class="line">   &#125;</span><br><span class="line">&gt;&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-无返回值"><a href="#2-无返回值" class="headerlink" title="2. 无返回值"></a>2. 无返回值</h4><ul>
<li>构造函数没有返回值，也不能定义返回类型（包括 <code>void</code>）。</li>
<li>理由：构造函数的目的是初始化对象，不需要返回任何东西，调用它的结果就是一个已初始化的对象。</li>
</ul>
<h4 id="3-对象实例化时，自动调用构造函数"><a href="#3-对象实例化时，自动调用构造函数" class="headerlink" title="3. 对象实例化时，自动调用构造函数"></a>3. 对象实例化时，自动调用构造函数</h4><ul>
<li>构造函数会在对象创建时由编译器自动调用，无需显式调用。例如：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&gt;&#123;</span><br><span class="line">&gt;<span class="keyword">public</span>:</span><br><span class="line">   <span class="built_in">MyClass</span>()</span><br><span class="line">   &#123;</span><br><span class="line">       cout &lt;&lt; <span class="string">&quot;构造函数被调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;MyClass obj; <span class="comment">// 自动调用构造函数</span></span><br></pre></td></tr></table></figure>

<h4 id="4-构造函数可以重载"><a href="#4-构造函数可以重载" class="headerlink" title="4. 构造函数可以重载"></a>4. 构造函数可以重载</h4><ul>
<li><p>构造函数支持重载（即可以有多个构造函数，但参数列表必须不同）。</p>
</li>
<li><p>通过重载，用户可以根据需要初始化对象：</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&gt;&#123;</span><br><span class="line">&gt;<span class="keyword">public</span>:</span><br><span class="line">   <span class="built_in">MyClass</span>()</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="comment">// 无参构造函数</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">MyClass</span>(<span class="type">int</span> x)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="comment">// 带参数的构造函数</span></span><br><span class="line">   &#125;</span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;MyClass obj1;     <span class="comment">// 调用无参构造函数</span></span><br><span class="line">&gt;<span class="function">MyClass <span class="title">obj2</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">// 调用带参构造函数</span></span><br></pre></td></tr></table></figure>

<h4 id="5-默认构造函数的生成规则"><a href="#5-默认构造函数的生成规则" class="headerlink" title="5. 默认构造函数的生成规则"></a>5. 默认构造函数的生成规则</h4><ul>
<li><p>如果类中没有显式定义无参构造函数，编译器会自动生成一个默认无参构造函数。</p>
</li>
<li><p>如果用户显式定义了任意构造函数（无论是否带参数），编译器将不再生成默认无参构造函数，除非显式定义一个无参构造函数。</p>
</li>
<li><p>例子：</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&gt;&#123;</span><br><span class="line">   <span class="type">int</span> x;</span><br><span class="line">&gt;&#125;;</span><br><span class="line">&gt;MyClass obj; 		<span class="comment">// 自动生成无参默认构造函数</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">MyClass2</span></span><br><span class="line">&gt;&#123;</span><br><span class="line">&gt;<span class="keyword">public</span>:</span><br><span class="line">   <span class="built_in">MyClass2</span>(<span class="type">int</span> y) &#123;&#125;</span><br><span class="line">&gt;&#125;;</span><br><span class="line">&gt;MyClass2 obj2; 		<span class="comment">// 错误，因为没有无参构造函数</span></span><br></pre></td></tr></table></figure>

<h4 id="6-默认构造函数对内置和自定义类型的处理"><a href="#6-默认构造函数对内置和自定义类型的处理" class="headerlink" title="6. 默认构造函数对内置和自定义类型的处理"></a>6. 默认构造函数对内置和自定义类型的处理</h4><ul>
<li><p><strong>内置类型（如 <code>int</code>, <code>char</code>）</strong>：</p>
</li>
<li><p>默认构造函数不会初始化内置类型成员，成员变量可能是随机值。例如：</p>
</li>
</ul>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x; 		<span class="comment">// 默认值是随机的</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>解决方法：使用 C++11 提供的默认值：</li>
</ul>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>; <span class="comment">// 默认值为 0</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>自定义类型（如 <code>class</code>, <code>struct</code>）</strong>：</p>
</li>
<li><p>编译器生成的默认构造函数会调用这些类型成员的默认构造函数。</p>
</li>
<li><p>例子：</p>
</li>
</ul>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Inner</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Inner</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Inner 构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span></span><br><span class="line">&#123;</span><br><span class="line">    Inner obj; 	<span class="comment">// 自定义类型成员</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Outer obj; 	<span class="comment">// 实例化自定义类型成员</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：Inner 构造函数</span><br></pre></td></tr></table></figure>

<h4 id="7-默认构造函数的种类"><a href="#7-默认构造函数的种类" class="headerlink" title="7. 默认构造函数的种类"></a>7. 默认构造函数的种类</h4><p><strong>无参的构造函数</strong> 和 <strong>全缺省的构造函数</strong>（所有参数都有默认值的构造函数）都称为 <strong>默认构造函数</strong>，并且默认构造函数只能有一个。</p>
<p>注意：无参构造函数、全缺省构造函数、我们没写编译器默认生成的构造函数，都可以认为是默认构造函数。</p>
<ul>
<li><p><strong>无参构造函数</strong>：没有任何参数的构造函数。</p>
</li>
<li><p><strong>全缺省构造函数</strong>：所有参数都有默认值的构造函数。 两者都属于默认构造函数的范畴，但它们的定义和使用场景有所不同。</p>
</li>
<li><p>例子：</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&gt;&#123;</span><br><span class="line">&gt;<span class="keyword">public</span>:</span><br><span class="line">   <span class="built_in">MyClass</span>() &#123;&#125; 				<span class="comment">// 无参构造函数</span></span><br><span class="line">   <span class="built_in">MyClass</span>(<span class="type">int</span> x = <span class="number">0</span>) &#123;&#125; 		<span class="comment">// 全缺省构造函数</span></span><br><span class="line">&gt;&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<p>构造函数的核心是初始化对象的成员，而非创建内存空间。默认构造函数的行为取决于对象成员的类型：</p>
<ul>
<li>内置类型成员默认不初始化，可能是随机值。</li>
<li>自定义类型成员会自动调用其默认构造函数。</li>
</ul>
<p>通过合理设计构造函数，可以确保对象在创建时处于有效的初始状态。（在 C++11 及更高版本中，编译器还会生成 <strong>移动构造函数</strong> 和 <strong>移动赋值运算符</strong>，用于优化资源管理。这些函数允许对象在移动语义下高效地转移资源，而不是进行拷贝。例如，移动构造函数可以将一个临时对象的资源直接转移给新对象，避免不必要的拷贝操作。这些内容将在后续章节中详细介绍。）</p>
</blockquote>
<h3 id="2-1-无参构造函数（默认构造函数）"><a href="#2-1-无参构造函数（默认构造函数）" class="headerlink" title="2.1. 无参构造函数（默认构造函数）"></a>2.1. 无参构造函数（默认构造函数）</h3><p>没有参数，创建对象时会被默认调用。</p>
<ul>
<li>如果用户没有定义任何构造函数，编译器会生成一个无参构造函数。</li>
<li>一旦用户定义了任何构造函数，编译器将不再生成。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Date</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        year = <span class="number">2025</span>;</span><br><span class="line">        month = <span class="number">1</span>;</span><br><span class="line">        day = <span class="number">1</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;无参构造函数被调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; year &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; month &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; day &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> year, month, day;<span class="comment">// 私有成员变量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Date d;  		<span class="comment">// 调用无参构造函数，注意：如果通过无参构造函数创建对象时，对象后面不用跟括号，否则就成了函数声明</span></span><br><span class="line">    d.<span class="built_in">Print</span>();  	<span class="comment">// 输出：2025-1-1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-带参构造函数"><a href="#2-2-带参构造函数" class="headerlink" title="2.2 带参构造函数"></a>2.2 带参构造函数</h3><p>可接受参数，并根据用户输入初始化对象。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Date</span>(<span class="type">int</span> y, <span class="type">int</span> m, <span class="type">int</span> d)</span><br><span class="line">        : <span class="built_in">year</span>(y), </span><br><span class="line">    	<span class="built_in">month</span>(m), </span><br><span class="line">    	<span class="built_in">day</span>(d)</span><br><span class="line">        &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 如果只定义了带参构造函数，编译器不会生成默认无参构造函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123; cout &lt;&lt; year &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; month &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; day &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> year, month, day;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Date <span class="title">d</span><span class="params">(<span class="number">2025</span>, <span class="number">1</span>, <span class="number">1</span>)</span></span>; <span class="comment">// 正常调用</span></span><br><span class="line">    <span class="comment">// Date d2; // 错误：没有默认无参构造函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<h2 id="传道解惑：-1"><a href="#传道解惑：-1" class="headerlink" title="传道解惑："></a>传道解惑：</h2><h3 id="Q1：公有（public）私有（private）部分的关系："><a href="#Q1：公有（public）私有（private）部分的关系：" class="headerlink" title="Q1：公有（public）私有（private）部分的关系："></a>Q1：公有（public）私有（private）部分的关系：</h3><p>在 C++ 中，类的成员（变量和函数）可以被指定为 <strong>公有（public）</strong> 或 <strong>私有（private）</strong>，这些访问控制符决定了成员的访问权限。接下来，我会详细讲解 <strong>公有部分</strong> 和 <strong>私有部分</strong> 的作用和关系。</p>
<p><strong>公有部分（public）</strong></p>
<ul>
<li><strong>访问权限：</strong> 任何外部代码（比如 <code>main()</code> 函数）都可以直接访问和修改公有成员。简单来说，<strong>公有部分</strong> 的成员对外部可见。</li>
<li><strong>适用场景：</strong> 一般情况下，我们会将类中的 <strong>接口函数</strong> 或 <strong>需要外部访问的数据</strong> 声明为公有，以便外部能够与对象交互。</li>
</ul>
<p><strong>私有部分（private）</strong></p>
<ul>
<li><strong>访问权限：</strong> 私有成员 <strong>只能在类内部的成员函数中访问</strong>，外部的代码无法直接访问或修改这些成员。<strong>私有部分</strong> 用于隐藏类的内部实现细节，只允许通过公有的接口与外部交互。</li>
<li><strong>适用场景：</strong> 私有成员通常是 <strong>类的内部数据</strong>，这些数据不希望被外部代码随意修改。通过这种方式，我们可以控制数据的访问权限和保证数据的正确性（通过公有函数进行访问或修改）。</li>
</ul>
<p><strong>关系</strong></p>
<ul>
<li><strong>数据封装（Encapsulation）：</strong> 这就是面向对象编程的核心之一，即将数据和操作数据的代码封装在一起。私有成员数据保护了对象的内部状态，避免了外部对数据的不恰当修改。公有函数则为外部提供了访问和修改数据的接口。</li>
<li><strong>分离接口与实现：</strong> 通过将接口函数（如 <code>Print()</code>）放在公有部分，类的使用者只需关心接口如何使用，而不需要知道具体的实现方式。私有部分负责实现细节，公有部分提供与外界的交互。</li>
<li><strong>保护：</strong> 私有成员提供类的内部实现，而公有成员则提供与外部的交互接口。这种设计有助于 <strong>封装</strong> 和 <strong>数据保护</strong>，确保类的使用者不破坏对象的状态。</li>
</ul>
<hr>
<h3 id="Q2：私有变量是否必须在公有部分出现？"><a href="#Q2：私有变量是否必须在公有部分出现？" class="headerlink" title="Q2：私有变量是否必须在公有部分出现？"></a>Q2：私有变量是否必须在公有部分出现？</h3><p><strong>不需要。</strong></p>
<p>类中的私有变量 (<code>private</code>) 是可以仅供类内部使用的，它们不一定需要通过公有部分 (<code>public</code>) 暴露出来。私有成员通常是不公开给外部的，所以是非必须出现在公有部分的。实际上，<strong>类的设计应该遵循数据隐藏原则</strong>：即只有通过公有函数，外部才能间接地访问或修改私有数据。这样能保护数据的完整性，避免外部代码直接改变私有数据。如果你希望外部能够访问和操作这些私有变量，通常会提供一些公有方法（如 <code>getter</code> 和 <code>setter</code>）来间接操作它们，但这不是强制的。</p>
<h3 id="Q3：关于编译器生成的默认成员函数，在不实现构造函数的情况下，编译器会生成默认的构造函数。但是看起来默认构造函数又没什么用？对象调用了编译器生成的默认构造函数，但是对象里依旧是随机值。也就是说，在这里编译器生成的默认构造函数并没有什么用？"><a href="#Q3：关于编译器生成的默认成员函数，在不实现构造函数的情况下，编译器会生成默认的构造函数。但是看起来默认构造函数又没什么用？对象调用了编译器生成的默认构造函数，但是对象里依旧是随机值。也就是说，在这里编译器生成的默认构造函数并没有什么用？" class="headerlink" title="Q3：关于编译器生成的默认成员函数，在不实现构造函数的情况下，编译器会生成默认的构造函数。但是看起来默认构造函数又没什么用？对象调用了编译器生成的默认构造函数，但是对象里依旧是随机值。也就是说，在这里编译器生成的默认构造函数并没有什么用？"></a>Q3：关于编译器生成的默认成员函数，在不实现构造函数的情况下，编译器会生成默认的构造函数。但是看起来默认构造函数又没什么用？对象调用了编译器生成的默认构造函数，但是对象里依旧是随机值。也就是说，在这里编译器生成的默认构造函数并没有什么用？</h3><p>解答：C++把类型分成内置类型(基本类型)和自定义类型。内置类型就是语言提供的数据类型，如：<code>int/char...</code>，自定义类型就是我们使用 <code>class/struct/union</code> 等自己定义的类型，编译器生成默认的构造函数会对自定义类型成员调用的它的默认成员函数。<strong>即编译器生成的默认构造函数在类的成员变量是自定义类型（非内置类型）时，会自动调用这些自定义类型的默认构造函数。这是 C++ 的一个机制，用于确保对象的每个成员都得到正确的初始化。</strong></p>
<p><strong>具体解释</strong></p>
<ol>
<li><strong>内置类型（如 <code>int</code>、<code>float</code> 等）：</strong></li>
</ol>
<ul>
<li><p>编译器生成的默认构造函数不会对内置类型成员进行初始化，这些成员会是随机值。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x; 			<span class="comment">// 内置类型成员</span></span><br><span class="line">&#125;;</span><br><span class="line">                                        </span><br><span class="line">MyClass obj; 		<span class="comment">// 编译器生成的默认构造函数不会初始化 x</span></span><br><span class="line">cout &lt;&lt; obj.x; 		<span class="comment">// 随机值</span></span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="2">
<li><strong>自定义类型（如 <code>class</code> 或 <code>struct</code>）：</strong></li>
</ol>
<ul>
<li><p>如果类中包含自定义类型的成员变量，编译器生成的默认构造函数会自动调用这些成员的默认构造函数，以初始化它们。</p>
</li>
<li><p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Inner</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Inner</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Inner 的默认构造函数被调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Inner innerMember; <span class="comment">// 自定义类型成员</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Outer obj; <span class="comment">// 自动调用编译器生成的默认构造函数</span></span><br><span class="line"></span><br><span class="line">输出：Inner 的默认构造函数被调用</span><br></pre></td></tr></table></figure>
</li>
<li><p>在这个例子中，<code>Outer</code> 类没有显式定义构造函数，但编译器生成了一个默认构造函数。而这个默认构造函数在初始化 <code>innerMember</code> 时，自动调用了 <code>Inner</code> 类的默认构造函数。</p>
</li>
</ul>
<p><strong>为什么这样设计？</strong></p>
<ul>
<li>自定义类型的对象可能需要复杂的初始化工作，比如为动态分配内存、初始化状态等。默认构造函数确保这些工作在创建对象时正确完成。</li>
<li>内置类型如 <code>int</code>、<code>float</code> 等通常不需要调用构造函数，默认值可以通过 C++11 中的默认值赋予。</li>
</ul>
<p>当类中有自定义类型的成员变量时：</p>
<ol>
<li>如果没有显式定义构造函数，编译器会生成一个默认构造函数。</li>
<li>这个默认构造函数会对 <strong>自定义类型成员变量</strong> 调用它们自己的默认构造函数，确保它们被正确初始化。</li>
</ol>
<p>这意味着你无需手动初始化这些成员，自定义类型的构造函数会自动运行完成初始化工作。</p>
</blockquote>
<hr>
<h2 id="3-析构函数"><a href="#3-析构函数" class="headerlink" title="3. 析构函数"></a>3. 析构函数</h2><p>析构函数：与构造函数功能相反，析构函数不是完成对对象本身的销毁，局部对象销毁工作是由编译器完成的。而 <strong>对象在销毁时会自动调用析构函数，完成对象中资源的清理工作</strong>。即用于释放资源。</p>
<p>析构函数是 C++中的一个特殊成员函数，专门用于对象生命周期结束时释放资源。以下是对上述特征的通俗易懂的解释：</p>
<blockquote>
<h3 id="3-1-析构函数的-6-个特征："><a href="#3-1-析构函数的-6-个特征：" class="headerlink" title="3.1 析构函数的 6 个特征："></a>3.1 析构函数的 <code>6</code> 个特征：</h3><h4 id="1-析构函数的命名规则：类名前加字符"><a href="#1-析构函数的命名规则：类名前加字符" class="headerlink" title="1. 析构函数的命名规则：类名前加字符 ~"></a>1. 析构函数的命名规则：类名前加字符 <code>~</code></h4><p>析构函数的名字和类名类似，但前面加了一个波浪号 <code>~</code>，它是 C++的规定，用来显式区分析构函数。比如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&gt;&#123;</span><br><span class="line">&gt;<span class="keyword">public</span>:</span><br><span class="line">   	~<span class="built_in">MyClass</span>()</span><br><span class="line">   	&#123;</span><br><span class="line">       		<span class="comment">// 析构代码</span></span><br><span class="line">   	&#125;</span><br><span class="line">&gt;&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-无参数、无返回值类型"><a href="#2-无参数、无返回值类型" class="headerlink" title="2. 无参数、无返回值类型"></a>2. 无参数、无返回值类型</h4><p>析构函数不接受任何参数，也不能返回任何值。它的作用是清理资源，而不是用来进行复杂的逻辑处理，因此不需要参数或返回值。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;~<span class="built_in">MyClass</span>(); <span class="comment">// 不允许带参数或返回值</span></span><br></pre></td></tr></table></figure>

<h4 id="3-一个类只能有一个析构函数，且不能重载"><a href="#3-一个类只能有一个析构函数，且不能重载" class="headerlink" title="3. 一个类只能有一个析构函数，且不能重载"></a>3. 一个类只能有一个析构函数，且不能重载</h4><p>析构函数唯一且不能有多个版本。C++编译器在编译时，知道如何自动调用析构函数，因此多版本没有意义。</p>
<h4 id="4-对象生命周期结束时，自动调用析构函数"><a href="#4-对象生命周期结束时，自动调用析构函数" class="headerlink" title="4. 对象生命周期结束时，自动调用析构函数"></a>4. 对象生命周期结束时，自动调用析构函数</h4><p>当一个对象不再需要时（如超出作用域、程序结束或显式删除时），C++编译器会自动调用析构函数，无需手动调用。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&#123;</span><br><span class="line">   	MyClass obj; <span class="comment">// 创建对象，调用构造函数</span></span><br><span class="line">&gt;&#125; <span class="comment">// 作用域结束，析构函数自动调用</span></span><br></pre></td></tr></table></figure>

<p>如果对象是动态分配的，用 <code>delete</code> 释放时也会调用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;MyClass* p = <span class="keyword">new</span> <span class="built_in">MyClass</span>(); <span class="comment">// 动态创建对象</span></span><br><span class="line">&gt;<span class="keyword">delete</span> p; <span class="comment">// 自动调用析构函数</span></span><br></pre></td></tr></table></figure>

<h4 id="5-默认析构函数：处理类中自定义类型成员的析构"><a href="#5-默认析构函数：处理类中自定义类型成员的析构" class="headerlink" title="5. 默认析构函数：处理类中自定义类型成员的析构"></a>5. 默认析构函数：处理类中自定义类型成员的析构</h4><p>如果没有显式定义析构函数，编译器会生成一个 <strong>默认析构函数</strong>。它会对类中所有非基本类型的成员调用其析构函数，比如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&gt;&#123;</span><br><span class="line">   	std::string str; <span class="comment">// 自定义类型成员</span></span><br><span class="line">&gt;&#125;;</span><br></pre></td></tr></table></figure>

<p>编译器生成的默认析构函数会自动调用 <code>std::string</code> 的析构函数，释放其内部的资源。</p>
<h4 id="6-没有资源时可以不写，有资源时必须写"><a href="#6-没有资源时可以不写，有资源时必须写" class="headerlink" title="6. 没有资源时可以不写，有资源时必须写"></a>6. 没有资源时可以不写，有资源时必须写</h4><ul>
<li><strong>没有资源</strong>：如果类中没有动态分配的资源，直接使用编译器生成的默认析构函数即可，在这种情况下，系统生成的默认析构函数已经足够。比如：</li>
</ul>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> year, month, day; <span class="comment">// 无动态资源</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>有资源</strong>：如果类中有动态分配的资源（如 <code>new</code> 申请的内存），一定要定义析构函数，手动释放这些资源，否则会造成 <strong>内存泄漏</strong>：</li>
</ul>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span>* arr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Stack</span>(<span class="type">int</span> size)</span><br><span class="line">    &#123;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="type">int</span>[size]; 	<span class="comment">// 动态分配内存</span></span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Stack</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] arr; 			<span class="comment">// 释放内存，避免泄漏</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>析构函数的核心作用是 <strong>清理资源</strong>，尤其是在有动态分配资源的情况下。如果没有动态资源，则可以省略不写。C++的编译器会在合适的时候自动调用析构函数，无需我们手动干预。<strong>记住</strong>：如果忘记写析构函数释放资源，程序可能会导致 <strong>内存泄漏</strong>，尤其是当类中包含动态内存时！</p>
</blockquote>
<blockquote>
<h3 id="3-2-示例："><a href="#3-2-示例：" class="headerlink" title="3.2 示例："></a>3.2 示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">&gt;<span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">Example</span></span><br><span class="line">&gt;&#123;</span><br><span class="line">&gt;<span class="keyword">public</span>:</span><br><span class="line">       <span class="built_in">Example</span>()</span><br><span class="line">       &#123;</span><br><span class="line">           cout &lt;&lt; <span class="string">&quot;构造函数被调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       ~<span class="built_in">Example</span>()</span><br><span class="line">       &#123;</span><br><span class="line">           cout &lt;&lt; <span class="string">&quot;析构函数被调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">       &#125;</span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">&gt;</span>&#123;</span><br><span class="line">       Example e;  <span class="comment">// 创建对象时调用构造函数</span></span><br><span class="line">       <span class="comment">// 程序结束时，e 被销毁，析构函数自动调用</span></span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;构造函数被调用</span><br><span class="line">&gt;析构函数被调用</span><br></pre></td></tr></table></figure></blockquote>
<h2 id="4-拷贝构造函数"><a href="#4-拷贝构造函数" class="headerlink" title="4. 拷贝构造函数"></a>4. 拷贝构造函数</h2><p>拷贝构造函数是 C++ 中的一个特殊构造函数，用于 <strong>通过已有对象初始化一个新对象</strong>（创建一个与已有对象内容完全相同的新对象）。</p>
<blockquote>
<h2 id="4-1-拷贝构造函数的-5-个特征："><a href="#4-1-拷贝构造函数的-5-个特征：" class="headerlink" title="4.1 拷贝构造函数的 5 个特征："></a>4.1 拷贝构造函数的 <code>5</code> 个特征：</h2><h4 id="1-拷贝构造函数是构造函数的一个重载形式"><a href="#1-拷贝构造函数是构造函数的一个重载形式" class="headerlink" title="1. 拷贝构造函数是构造函数的一个重载形式"></a>1. 拷贝构造函数是构造函数的一个重载形式</h4><ul>
<li><p>拷贝构造函数和普通构造函数一样是初始化对象的，但它专门用于用 <strong>另一个对象</strong> 初始化当前对象。</p>
</li>
<li><p>它是构造函数的一种重载形式，形式如下：</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&gt;&#123;</span><br><span class="line">&gt;<span class="keyword">public</span>:</span><br><span class="line">   <span class="built_in">MyClass</span>(<span class="type">const</span> MyClass&amp; obj); <span class="comment">// 拷贝构造函数声明</span></span><br><span class="line">&gt;&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>注意：拷贝构造函数的名字和类名一样，只是参数是当前类对象的引用。</li>
</ul>
<h4 id="2-参数必须是类类型的引用"><a href="#2-参数必须是类类型的引用" class="headerlink" title="2. 参数必须是类类型的引用"></a>2. 参数必须是类类型的引用</h4><ul>
<li>拷贝构造函数的参数只能是 <strong>类类型的引用</strong>，不能用 <strong>值传递</strong>，否则会导致编译器报错或发生死循环：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="built_in">MyClass</span>(<span class="type">const</span> MyClass obj); 	<span class="comment">// 错误，值传递会导致递归调用</span></span><br></pre></td></tr></table></figure>

<ul>
<li>这是因为：</li>
</ul>
<ol>
<li>如果参数使用值传递（<code>MyClass obj</code>），在传递参数时会调用拷贝构造函数。</li>
<li>拷贝构造函数又会调用自己，导致无限递归，最终栈溢出。</li>
</ol>
<ul>
<li>正确形式：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="built_in">MyClass</span>(<span class="type">const</span> MyClass&amp; obj); <span class="comment">// 使用引用，避免递归</span></span><br></pre></td></tr></table></figure>

<h4 id="3-默认拷贝构造函数"><a href="#3-默认拷贝构造函数" class="headerlink" title="3. 默认拷贝构造函数"></a>3. 默认拷贝构造函数</h4><ul>
<li>如果用户没有显式定义拷贝构造函数，<strong>编译器会自动生成一个默认的拷贝构造函数</strong>。</li>
<li>默认拷贝构造函数会逐字节拷贝对象的成员变量，这种拷贝被称为 <strong>浅拷贝</strong>。</li>
</ul>
<p><strong>浅拷贝的含义：</strong></p>
<ul>
<li>对于 <strong>内置类型</strong>（如 <code>int</code>、<code>float</code>），直接复制值。</li>
<li>对于 <strong>自定义类型</strong> 成员，编译器会调用这些成员自己的拷贝构造函数。</li>
<li>例子：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">&gt;<span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&gt;&#123;</span><br><span class="line">&gt;<span class="keyword">public</span>:</span><br><span class="line">   <span class="type">int</span> a;</span><br><span class="line">   <span class="type">int</span>* p;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">MyClass</span>() : <span class="built_in">a</span>(<span class="number">0</span>), <span class="built_in">p</span>(<span class="literal">nullptr</span>) &#123;&#125;				<span class="comment">// 默认构造函数</span></span><br><span class="line">   <span class="built_in">MyClass</span>(<span class="type">const</span> MyClass&amp; other) : <span class="built_in">a</span>(other.a), <span class="built_in">p</span>(other.p) &#123;&#125;	<span class="comment">// 拷贝构造函数（浅拷贝）</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 析构函数，用于释放动态分配的内存</span></span><br><span class="line">   ~<span class="built_in">MyClass</span>()</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">if</span> (p != <span class="literal">nullptr</span>)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">delete</span> p;					<span class="comment">// 如果 p 指向动态分配的内存，释放它</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">&gt;</span>&#123;</span><br><span class="line">   MyClass obj1;</span><br><span class="line">   obj<span class="number">1.</span>a = <span class="number">10</span>;</span><br><span class="line">   obj<span class="number">1.</span>p = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">20</span>); 				<span class="comment">// 动态分配内存</span></span><br><span class="line"></span><br><span class="line">   MyClass obj2 = obj1; 				<span class="comment">// 浅拷贝：obj2 会与 obj1 共享相同的指针 p</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 输出 obj1 和 obj2 的值</span></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;obj1.a = &quot;</span> &lt;&lt; obj<span class="number">1.</span>a &lt;&lt; <span class="string">&quot;, obj1.p = &quot;</span> &lt;&lt; *obj<span class="number">1.</span>p &lt;&lt; endl;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;obj2.a = &quot;</span> &lt;&lt; obj<span class="number">2.</span>a &lt;&lt; <span class="string">&quot;, obj2.p = &quot;</span> &lt;&lt; *obj<span class="number">2.</span>p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 手动释放 obj1 的动态内存</span></span><br><span class="line">   <span class="keyword">delete</span> obj<span class="number">1.</span>p;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 现在 obj2.p 是悬空指针，访问它会导致未定义行为</span></span><br><span class="line">   <span class="comment">// cout &lt;&lt; &quot;obj2.p after obj1.delete: &quot; &lt;&lt; *obj2.p &lt;&lt; endl; // 危险！</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>问题</strong>：如果类中有指针等动态资源，浅拷贝会导致问题。比如 <code>obj1.p</code> 和 <code>obj2.p</code> 指向同一块内存，释放时可能导致重复释放（<strong>悬空指针</strong>）。</p>
<h4 id="4-是否需要显式定义拷贝构造函数？"><a href="#4-是否需要显式定义拷贝构造函数？" class="headerlink" title="4. 是否需要显式定义拷贝构造函数？"></a>4. 是否需要显式定义拷贝构造函数？</h4><ul>
<li><p><strong>没有动态资源时（不涉及指针或资源申请）：</strong> 编译器生成的默认拷贝构造函数已经可以正常工作，可以不写。</p>
</li>
<li><p><strong>有动态资源时（涉及指针或资源申请）：</strong> 必须显式定义拷贝构造函数，完成深拷贝，避免内存管理问题。</p>
</li>
<li><p><strong>深拷贝的实现：</strong> 深拷贝指的是重新分配内存，并复制内容，而不是直接复制指针地址：</p>
</li>
</ul>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span>* p;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自定义拷贝构造函数</span></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">const</span> MyClass&amp; obj)</span><br><span class="line">    &#123;</span><br><span class="line">        a = obj.a;</span><br><span class="line">        p = <span class="keyword">new</span> <span class="built_in">int</span>(*obj.p);	 <span class="comment">// 深拷贝，重新分配内存</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">MyClass</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> p; 				 <span class="comment">// 释放动态资源</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="5-拷贝构造函数的典型调用场景"><a href="#5-拷贝构造函数的典型调用场景" class="headerlink" title="5. 拷贝构造函数的典型调用场景"></a>5. 拷贝构造函数的典型调用场景</h4><ul>
<li><strong>场景 1：使用已有对象创建新对象</strong></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;MyClass obj1;       	<span class="comment">// 普通构造函数</span></span><br><span class="line">&gt;MyClass obj2 = obj1; 	<span class="comment">// 拷贝构造函数</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>场景 2：函数参数为类类型对象</strong></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(MyClass obj)</span></span>; <span class="comment">// 如果不使用引用，会调用拷贝构造函数</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>场景 3：函数返回类类型对象</strong></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="function">MyClass <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">&gt;</span>&#123;</span><br><span class="line">   MyClass obj;</span><br><span class="line">   <span class="keyword">return</span> obj; 		<span class="comment">// 返回时可能调用拷贝构造函数</span></span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="提高效率的建议"><a href="#提高效率的建议" class="headerlink" title="提高效率的建议"></a>提高效率的建议</h4><ol>
<li><strong>传参时使用引用</strong>：避免拷贝对象的开销。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">const</span> MyClass&amp; obj)</span></span>; <span class="comment">// 使用引用，不调用拷贝构造函数</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>返回值优化（C++11 的移动语义）：</strong> 对于返回值尽量结合移动构造函数使用，减少不必要的拷贝。</li>
</ol>
<p><strong>综上：</strong></p>
<ul>
<li>拷贝构造函数是用已有对象初始化新对象的工具。</li>
<li>编译器默认的拷贝构造函数使用浅拷贝，只能处理简单类（没有动态资源）。</li>
<li>对于涉及动态资源的类，必须显式定义拷贝构造函数，确保深拷贝，避免内存泄漏或重复释放。</li>
</ul>
</blockquote>
<h3 id="4-2-默认拷贝构造函数"><a href="#4-2-默认拷贝构造函数" class="headerlink" title="4.2 默认拷贝构造函数"></a>4.2 默认拷贝构造函数</h3><p>编译器默认会生成一个浅拷贝版本：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Date</span>(<span class="type">int</span> y, <span class="type">int</span> m, <span class="type">int</span> d) : <span class="built_in">year</span>(y), <span class="built_in">month</span>(m), <span class="built_in">day</span>(d) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123; cout &lt;&lt; year &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; month &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; day &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> year, month, day;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Date <span class="title">d1</span><span class="params">(<span class="number">2025</span>, <span class="number">1</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">    Date d2 = d1;  		<span class="comment">// 调用默认拷贝构造函数</span></span><br><span class="line">    d<span class="number">2.</span><span class="built_in">Print</span>();  		<span class="comment">// 输出：2025-1-1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-3-自定义拷贝构造函数"><a href="#4-3-自定义拷贝构造函数" class="headerlink" title="4.3 自定义拷贝构造函数"></a>4.3 自定义拷贝构造函数</h3><p>当对象包含动态资源时，必须显式定义深拷贝逻辑。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Example</span>(<span class="type">int</span> size)</span><br><span class="line">    &#123;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="type">int</span>[size];</span><br><span class="line">        <span class="keyword">this</span>-&gt;size = size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自定义拷贝构造函数</span></span><br><span class="line">    <span class="built_in">Example</span>(<span class="type">const</span> Example&amp; other)</span><br><span class="line">    &#123;</span><br><span class="line">        size = other.size;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="type">int</span>[size];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            arr[i] = other.arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Example</span>() &#123; <span class="keyword">delete</span>[] arr; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span>* arr;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="5-赋值运算符重载"><a href="#5-赋值运算符重载" class="headerlink" title="5. 赋值运算符重载"></a>5. 赋值运算符重载</h2><blockquote>
<p>C++ 中的 <strong>运算符重载</strong> 允许我们为类或对象定义新的运算符行为，使代码更直观和可读。</p>
<h2 id="5-1-对运算符重载关键点解释："><a href="#5-1-对运算符重载关键点解释：" class="headerlink" title="5.1 对运算符重载关键点解释："></a>5.1 对运算符重载关键点解释：</h2><h4 id="1-运算符重载的本质"><a href="#1-运算符重载的本质" class="headerlink" title="1. 运算符重载的本质"></a>1. 运算符重载的本质</h4><ul>
<li><p>运算符重载是通过定义一个特殊的函数，改变运算符对类对象的行为。</p>
</li>
<li><p><strong>函数名称：</strong> <code>operator</code> 后接具体运算符。例如：<code>operator+</code> 是用来重载加法运算符的函数。</p>
</li>
<li><p><strong>函数原型：</strong></p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;返回值类型 <span class="keyword">operator</span>操作符(参数列表);</span><br></pre></td></tr></table></figure>

<ul>
<li>例子：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&gt;&#123;</span><br><span class="line">&gt;<span class="keyword">public</span>:</span><br><span class="line">   MyClass <span class="keyword">operator</span>+(<span class="type">const</span> MyClass&amp; obj);</span><br><span class="line">&gt;&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-运算符重载规则"><a href="#2-运算符重载规则" class="headerlink" title="2. 运算符重载规则"></a>2. 运算符重载规则</h4><ul>
<li><strong>不能创建新的运算符：</strong> 只能重载已有运算符，不能重载不存在的符号（如 <code>operator@</code> 是非法的）。</li>
<li><strong>内置类型的运算符不能改变其含义：</strong> 例如整数相加（<code>3 + 5</code>）的行为不能被改变。</li>
<li><strong>某些运算符不能被重载：</strong> <code>.</code>, <code>.*</code>, <code>::</code>, <code>sizeof</code>, <code>?:</code> 不能被重载。</li>
<li><strong>至少有一个操作数是类类型：</strong> 不能对完全是内置类型的运算符重载，比如试图重载 <code>int + int</code>。</li>
</ul>
<h4 id="3-成员函数-vs-全局函数重载"><a href="#3-成员函数-vs-全局函数重载" class="headerlink" title="3. 成员函数 vs 全局函数重载"></a>3. 成员函数 vs 全局函数重载</h4><ul>
<li>运算符重载可以是类的 <strong>成员函数</strong> 或 <strong>全局函数</strong>。</li>
<li><strong>成员函数重载：</strong> 第一个操作数是当前对象，编译器会将操作数传递给隐藏的 <code>this</code> 指针。</li>
<li><strong>全局函数重载：</strong> 需要将两个操作数都作为参数传递。</li>
<li><strong>注意：赋值运算符重载（<code>operator=</code>）必须是成员函数，不能是全局函数。</strong></li>
</ul>
<h4 id="4-常见运算符重载的实现"><a href="#4-常见运算符重载的实现" class="headerlink" title="4. 常见运算符重载的实现"></a>4. 常见运算符重载的实现</h4><hr>
<h4 id="赋值运算符重载（operator-）"><a href="#赋值运算符重载（operator-）" class="headerlink" title="赋值运算符重载（operator=）"></a>赋值运算符重载（<code>operator=</code>）</h4><p><strong>特点：</strong></p>
<ol>
<li><strong>参数类型：</strong> <code>const T&amp;</code>，避免不必要的拷贝，传引用效率更高。</li>
<li><strong>返回值类型：</strong> <code>T&amp;</code>，返回对象的引用支持连续赋值（如 <code>a = b = c</code>）。</li>
<li><strong>检测自赋值：</strong> 检查是否给自己赋值（<code>if (this == &amp;obj)</code>）。</li>
</ol>
<ul>
<li>自赋值检查非常重要，因为如果不检查自赋值，可能会导致资源被错误释放或重复释放。例如，如果 <code>this == &amp;obj</code>，则 <code>delete data;</code> 会释放当前对象的资源，导致后续操作无法正确执行。</li>
</ul>
<ol start="4">
<li><strong>返回 <code>*this</code>：</strong> 让赋值语句返回当前对象。</li>
</ol>
<p><strong>实现：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&gt;&#123;</span><br><span class="line">&gt;<span class="keyword">public</span>:</span><br><span class="line"> <span class="type">int</span>* data;</span><br><span class="line"></span><br><span class="line"> MyClass&amp; <span class="keyword">operator</span>=(<span class="type">const</span> MyClass&amp; obj)</span><br><span class="line"> &#123;</span><br><span class="line">     <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;obj) 					<span class="comment">// 检测是否自赋值</span></span><br><span class="line">     &#123;</span><br><span class="line">         <span class="keyword">delete</span> data;    					<span class="comment">// 释放已有资源</span></span><br><span class="line">         data = <span class="keyword">new</span> <span class="built_in">int</span>(*obj.data); 		<span class="comment">// 深拷贝，避免共享指针导致问题</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> *<span class="keyword">this</span>; 						<span class="comment">// 返回当前对象的引用</span></span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="前置-和-后置-重载"><a href="#前置-和-后置-重载" class="headerlink" title="前置++ 和 后置++ 重载"></a>前置++ 和 后置++ 重载</h4><ul>
<li><strong>前置++（<code>++obj</code>）：</strong> 返回增加后的值。</li>
<li><strong>后置++（<code>obj++</code>）：</strong> 返回增加前的旧值，调用时会多传一个 <code>int</code> 参数（编译器自动处理）。</li>
</ul>
<p><strong>实现：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&gt;&#123;</span><br><span class="line">&gt;<span class="keyword">public</span>:</span><br><span class="line"> <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 前置++，返回引用</span></span><br><span class="line"> MyClass&amp; <span class="keyword">operator</span>++()</span><br><span class="line"> &#123;</span><br><span class="line">     ++value; 					<span class="comment">// 自增</span></span><br><span class="line">     <span class="keyword">return</span> *<span class="keyword">this</span>; 			<span class="comment">// 返回当前对象</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 后置++，返回值</span></span><br><span class="line"> MyClass <span class="keyword">operator</span>++(<span class="type">int</span>)</span><br><span class="line"> &#123;</span><br><span class="line">     MyClass temp = *<span class="keyword">this</span>; 	<span class="comment">// 保存当前对象</span></span><br><span class="line">     ++value;              	<span class="comment">// 自增</span></span><br><span class="line">     <span class="keyword">return</span> temp;          	<span class="comment">// 返回旧值</span></span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="加法运算符重载（operator-）"><a href="#加法运算符重载（operator-）" class="headerlink" title="加法运算符重载（operator+）"></a>加法运算符重载（<code>operator+</code>）</h4><p>加法运算符重载支持对象间的相加操作。</p>
<p><strong>实现：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&gt;&#123;</span><br><span class="line">&gt;<span class="keyword">public</span>:</span><br><span class="line"> <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 重载加法运算符</span></span><br><span class="line"> MyClass <span class="keyword">operator</span>+(<span class="type">const</span> MyClass&amp; obj) <span class="type">const</span></span><br><span class="line"> &#123;</span><br><span class="line">     MyClass result;</span><br><span class="line">     result.value = <span class="keyword">this</span>-&gt;value + obj.value; <span class="comment">// 两个对象相加</span></span><br><span class="line">     <span class="keyword">return</span> result;</span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="5-默认运算符重载-vs-自定义实现"><a href="#5-默认运算符重载-vs-自定义实现" class="headerlink" title="5. 默认运算符重载 vs 自定义实现"></a>5. 默认运算符重载 vs 自定义实现</h4><p><strong>默认行为：</strong></p>
<ul>
<li>如果不显式实现赋值运算符（<code>operator=</code>）或拷贝构造函数（<code>operator=</code>），编译器会生成默认版本，逐字节拷贝。</li>
<li>默认行为对于 <strong>内置类型</strong>（如 <code>int</code>、<code>char</code>）完全适用。</li>
<li>对于 <strong>动态资源</strong>（如指针），默认行为可能导致 <strong>浅拷贝</strong> 问题（资源共享导致重复释放或悬空指针）。</li>
</ul>
<p><strong>是否需要自定义实现：</strong></p>
<ul>
<li>如果类中没有动态资源（如只包含内置类型或 STL 容器），默认生成的运算符重载就够用。</li>
<li>如果类中有动态资源（如指针），必须自定义运算符重载，确保深拷贝和正确释放资源。</li>
</ul>
<h4 id="6-为什么返回引用？"><a href="#6-为什么返回引用？" class="headerlink" title="6. 为什么返回引用？"></a>6. 为什么返回引用？</h4><ul>
<li><p>在运算符重载中，返回引用（<code>T&amp;</code>）有助于提高效率，并支持连续赋值操作（如 <code>a = b = c</code>）。</p>
</li>
<li><p>例如赋值运算符：</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;MyClass&amp; <span class="keyword">operator</span>=(<span class="type">const</span> MyClass&amp; obj)</span><br><span class="line">&gt;&#123;</span><br><span class="line">   <span class="comment">// 处理赋值逻辑</span></span><br><span class="line">   <span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">// 返回当前对象的引用</span></span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果返回值而非引用，则每次赋值都会产生一个临时对象，效率低。</li>
</ul>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>运算符重载让类对象可以像内置类型一样进行操作，提升了代码的可读性。但以下几点需要注意：</p>
<ol>
<li>只有已有的运算符可以被重载，且至少有一个操作数是类类型。</li>
<li>对于有动态资源的类，必须重载运算符以避免浅拷贝问题。</li>
<li>返回引用是为了支持连续赋值和提高效率。</li>
<li>某些运算符不能被重载，比如 <code>.</code>、<code>::</code>、<code>sizeof</code> 和 <code>?:</code>。</li>
</ol>
<p>通过合理设计运算符重载，可以让类使用起来更像内置类型，从而写出更加优雅和简洁的代码。</p>
</blockquote>
<blockquote>
<h2 id="5-2-示例："><a href="#5-2-示例：" class="headerlink" title="5.2 示例："></a>5.2 示例：</h2><h4 id="1-默认实现"><a href="#1-默认实现" class="headerlink" title="1. 默认实现"></a>1. 默认实现</h4><p>编译器默认按字节拷贝，可能造成资源冲突。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">Date</span></span><br><span class="line">&gt;&#123;</span><br><span class="line">&gt;<span class="keyword">public</span>:</span><br><span class="line">   <span class="built_in">Date</span>(<span class="type">int</span> y, <span class="type">int</span> m, <span class="type">int</span> d) : <span class="built_in">year</span>(y), <span class="built_in">month</span>(m), <span class="built_in">day</span>(d) &#123;&#125;</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123; cout &lt;&lt; year &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; month &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; day &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> year, month, day;</span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">&gt;</span>&#123;</span><br><span class="line">   <span class="function">Date <span class="title">d1</span><span class="params">(<span class="number">2025</span>, <span class="number">1</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">   <span class="function">Date <span class="title">d2</span><span class="params">(<span class="number">2024</span>, <span class="number">12</span>, <span class="number">31</span>)</span></span>;</span><br><span class="line">   d2 = d1;  		<span class="comment">// 调用默认赋值运算符</span></span><br><span class="line">   d<span class="number">2.</span><span class="built_in">Print</span>();  	<span class="comment">// 输出：2025-1-1</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-重载赋值运算符"><a href="#2-重载赋值运算符" class="headerlink" title="2. 重载赋值运算符"></a>2. 重载赋值运算符</h4><p>当对象管理动态资源时，需要自定义赋值运算符。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">Example</span></span><br><span class="line">&gt;&#123;</span><br><span class="line">&gt;<span class="keyword">public</span>:</span><br><span class="line">   <span class="built_in">Example</span>(<span class="type">int</span> size)</span><br><span class="line">   &#123;</span><br><span class="line">      arr = <span class="keyword">new</span> <span class="type">int</span>[size];</span><br><span class="line">      <span class="keyword">this</span>-&gt;size = size;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   Example&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Example&amp; other)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other)			<span class="comment">// 防止自赋值</span></span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">delete</span>[] arr;</span><br><span class="line">          size = other.size;</span><br><span class="line">          arr = <span class="keyword">new</span> <span class="type">int</span>[size];</span><br><span class="line">          </span><br><span class="line">          <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">          &#123;</span><br><span class="line">              arr[i] = other.arr[i];</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">Example</span>() &#123; <span class="keyword">delete</span>[] arr; &#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">private</span>:</span><br><span class="line">   <span class="type">int</span>* arr;</span><br><span class="line">   <span class="type">int</span> size;</span><br><span class="line">&gt;&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="重载"><a href="#重载" class="headerlink" title="重载 +"></a>重载 <code>+</code></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">Date</span></span><br><span class="line">&gt;&#123;</span><br><span class="line">&gt;<span class="keyword">public</span>:</span><br><span class="line">   <span class="built_in">Date</span>(<span class="type">int</span> y, <span class="type">int</span> m, <span class="type">int</span> d) : <span class="built_in">year</span>(y), <span class="built_in">month</span>(m), <span class="built_in">day</span>(d) &#123;&#125;</span><br><span class="line">   Date <span class="keyword">operator</span>+(<span class="type">int</span> days) &#123; <span class="keyword">return</span> <span class="built_in">Date</span>(year, month, day + days); &#125;</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123; cout &lt;&lt; year &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; month &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; day &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> year, month, day;</span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">&gt;</span>&#123;</span><br><span class="line">   <span class="function">Date <span class="title">d</span><span class="params">(<span class="number">2025</span>, <span class="number">1</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">   Date d2 = d + <span class="number">5</span>;  	<span class="comment">// 日期加5天</span></span><br><span class="line">   d<span class="number">2.</span><span class="built_in">Print</span>();  		<span class="comment">// 输出：2025-1-6</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="重载-1"><a href="#重载-1" class="headerlink" title="重载 =="></a>重载 <code>==</code></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">Date</span></span><br><span class="line">&gt;&#123;</span><br><span class="line">&gt;<span class="keyword">public</span>:</span><br><span class="line">   <span class="built_in">Date</span>(<span class="type">int</span> y, <span class="type">int</span> m, <span class="type">int</span> d) : <span class="built_in">year</span>(y), <span class="built_in">month</span>(m), <span class="built_in">day</span>(d) &#123;&#125;</span><br><span class="line">   <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Date&amp; other)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">return</span> year == other.year &amp;&amp; month == other.month &amp;&amp; day == other.day;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> year, month, day;</span><br><span class="line">&gt;&#125;;</span><br></pre></td></tr></table></figure></blockquote>
<h2 id="6-const-成员"><a href="#6-const-成员" class="headerlink" title="6. const 成员"></a>6. <code>const</code> 成员</h2><p>将 <code>const</code> 修饰的“<strong>成员函数</strong>”称之为 <code>const</code> 成员函数，<code>const</code> 成员函数修饰了隐含的 <code>this</code> 指针为 <code>const</code> 类型（<code>const ClassName* this</code>），表示该函数不能修改类的成员变量。但可以通过 <code>mutable</code> 修饰的成员变量在 <code>const</code> 成员函数中进行修改。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Date</span>(<span class="type">int</span> year, <span class="type">int</span> month, <span class="type">int</span> day)</span><br><span class="line">    &#123;</span><br><span class="line">        _year = year;</span><br><span class="line">        _month = month;</span><br><span class="line">        _day = day;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Print()&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;year:&quot;</span> &lt;&lt; _year &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;month:&quot;</span> &lt;&lt; _month &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;day:&quot;</span> &lt;&lt; _day &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PrintConst</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Print(const)&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;year:&quot;</span> &lt;&lt; _year &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;month:&quot;</span> &lt;&lt; _month &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;day:&quot;</span> &lt;&lt; _day &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _year;   <span class="comment">// 年</span></span><br><span class="line">    <span class="type">int</span> _month;  <span class="comment">// 月</span></span><br><span class="line">    <span class="type">int</span> _day;    <span class="comment">// 日</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Date <span class="title">d1</span><span class="params">(<span class="number">2025</span>, <span class="number">1</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">    d<span class="number">1.</span><span class="built_in">Print</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">const</span> Date <span class="title">d2</span><span class="params">(<span class="number">2025</span>, <span class="number">1</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">    d<span class="number">2.</span><span class="built_in">Print</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>让我们逐步理解上面代码：</p>
<ol>
<li>定义了两个 <code>Print</code> 函数：<ul>
<li><code>void Print()</code>：普通成员函数，允许修改对象。</li>
<li><code>void Print() const</code>：<code>const</code> 成员函数，不能修改对象。</li>
</ul>
</li>
<li><code>Test</code> 函数中：<ul>
<li><code>Date d1(2022, 1, 13);</code> 是普通对象，调用 <code>d1.Print()</code> 时，编译器会选择非 <code>const</code> 版本的 <code>Print()</code>。</li>
<li><code>const Date d2(2022, 1, 13);</code> 是 <code>const</code> 对象，调用 <code>d2.Print()</code> 时，编译器会选择 <code>const</code> 版本的 <code>Print()</code>。</li>
</ul>
</li>
</ol>
<h3 id="6-1-总结规则："><a href="#6-1-总结规则：" class="headerlink" title="6.1 总结规则："></a>6.1 总结规则：</h3><ol>
<li><strong>非 <code>const</code> 对象</strong>：<ul>
<li>可以调用普通成员函数。</li>
<li>可以调用 <code>const</code> 成员函数。</li>
</ul>
</li>
<li><strong><code>const</code> 对象</strong>：<ul>
<li>只能调用 <code>const</code> 成员函数。</li>
</ul>
</li>
<li><strong>普通成员函数</strong>：<ul>
<li>可以调用普通成员函数。</li>
<li>不能调用 <code>const</code> 成员函数。</li>
</ul>
</li>
<li><strong><code>const</code> 成员函数</strong>：<ul>
<li>不能调用普通成员函数。</li>
<li>可以调用 <code>const</code> 成员函数。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="6-2-适用场景："><a href="#6-2-适用场景：" class="headerlink" title="6.2 适用场景："></a>6.2 适用场景：</h3><ul>
<li>当你希望某个成员函数不修改对象的任何成员变量时，应将其声明为 <code>const</code> 成员函数。</li>
<li>这样可以确保该函数在 <code>const</code> 对象上调用时不会破坏对象的不可变性。</li>
<li>例如，<code>Print()</code> 函数通常不需要修改对象状态，因此可以声明为 <code>const</code> 成员函数。</li>
</ul>
<hr>
<h3 id="6-3-关键知识点："><a href="#6-3-关键知识点：" class="headerlink" title="6.3 关键知识点："></a>6.3 关键知识点：</h3><ul>
<li><strong><code>const</code> 修饰的成员函数</strong>：会将隐含的 <code>this</code> 指针转换为 <code>const</code> 类型（<code>const ClassName* this</code>）。</li>
<li>编译器通过 <code>const</code> 限定符，保证不会在 <code>const</code> 成员函数中修改成员变量。</li>
<li>如果非 <code>const</code> 成员变量必须在 <code>const</code> 成员函数中被修改，可以使用 <code>mutable</code> 关键字修饰这些变量，使其在 <code>const</code> 上下文中也可变（但要谨慎使用）。</li>
</ul>
<hr>
<blockquote>
<h2 id="传道解惑：-2"><a href="#传道解惑：-2" class="headerlink" title="传道解惑："></a>传道解惑：</h2><h3 id="Q1：-const-对象可以调用非-const-成员函数吗？"><a href="#Q1：-const-对象可以调用非-const-成员函数吗？" class="headerlink" title="Q1： const 对象可以调用非 const 成员函数吗？"></a>Q1： <code>const</code> 对象可以调用非 <code>const</code> 成员函数吗？</h3><p><strong>不可以</strong>。</p>
<p><code>const</code> 对象意味着这个对象的任何成员都不能被修改。非 <code>const</code> 成员函数没有限制修改成员变量的行为，因此 <code>const</code> 对象无法调用非 <code>const</code> 成员函数，否则会破坏 <code>const</code> 对象的不变性。</p>
<p>在上面代码中，<code>const Date d2</code> 是一个 <code>const</code> 对象，只能调用 <code>Print(const)</code>，不能调用 <code>Print()</code>（非 <code>const</code> 成员函数）。编译器会通过检查 <code>const</code> 属性阻止这种调用。</p>
<hr>
<h3 id="Q2：const-对象可以调用-const-成员函数吗？"><a href="#Q2：const-对象可以调用-const-成员函数吗？" class="headerlink" title="Q2：const 对象可以调用 const 成员函数吗？"></a>Q2：<code>const</code> 对象可以调用 <code>const</code> 成员函数吗？</h3><p><strong>可以</strong>。</p>
<p><code>const</code> 成员函数会修饰 <code>this</code> 指针为 <code>const Date* this</code>，表示该函数内部不会修改类的成员变量。因此 <code>const</code> 对象可以调用 <code>const</code> 成员函数，因为这不会破坏 <code>const</code> 对象的不可变性。</p>
<p>在上面代码中，<code>d2.Print()</code> 调用的就是 <code>Print(const)</code>，因为 <code>Print(const)</code> 是 <code>const</code> 成员函数。</p>
<hr>
<h3 id="Q3：const-成员函数内可以调用其它的非-const-成员函数吗？"><a href="#Q3：const-成员函数内可以调用其它的非-const-成员函数吗？" class="headerlink" title="Q3：const 成员函数内可以调用其它的非 const 成员函数吗？"></a>Q3：<code>const</code> 成员函数内可以调用其它的非 <code>const</code> 成员函数吗？</h3><p><strong>不可以</strong>。</p>
<p>因为 <code>const</code> 成员函数的 <code>this</code> 指针是 <code>const</code> 的，即 <code>const Date* this</code>，表示它不能修改成员变量。而非 <code>const</code> 成员函数默认的 <code>this</code> 指针是 <code>Date* this</code>，允许修改成员变量。<br>因此，<code>const</code> 成员函数无法调用非 <code>const</code> 成员函数，因为这样可能导致间接修改成员变量，从而违反了 <code>const</code> 的约束。</p>
<hr>
<h3 id="Q4-const-成员函数内可以调用其它的-const-成员函数吗？"><a href="#Q4-const-成员函数内可以调用其它的-const-成员函数吗？" class="headerlink" title="Q4: const 成员函数内可以调用其它的 const 成员函数吗？"></a>Q4: <code>const</code> 成员函数内可以调用其它的 <code>const</code> 成员函数吗？</h3><p><strong>可以</strong>。</p>
<p><code>const</code> 成员函数的 <code>this</code> 指针是 <code>const</code> 的，调用其他 <code>const</code> 成员函数不会违反 <code>const</code> 的约束，因为 <code>const</code> 成员函数保证不修改成员变量。</p>
</blockquote>
<h2 id="7-取地址及-const-取地址操作符重载"><a href="#7-取地址及-const-取地址操作符重载" class="headerlink" title="7. 取地址及 const 取地址操作符重载"></a>7. 取地址及 <code>const</code> 取地址操作符重载</h2><p>在 C++中，取地址操作符 <code>&amp;</code> 不能被真正重载。但可以通过定义特殊的成员函数来改变其行为。这种实现方式类似于运算符重载，但并非真正的重载。结合 <code>const</code>，它的行为会更有针对性。（取地址操作符 <code>&amp;</code> 不能被重载的原因是，它是一个基础操作符，用于获取对象的地址。如果允许重载，可能会导致地址获取的语义混乱。）</p>
<h3 id="7-1-取地址操作符-默认行为"><a href="#7-1-取地址操作符-默认行为" class="headerlink" title="7.1 取地址操作符 &amp; 默认行为"></a>7.1 取地址操作符 <code>&amp;</code> 默认行为</h3><p>默认情况下，<code>&amp;</code> 操作符返回对象的内存地址。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>* px = &amp;x; <span class="comment">// px 获取了 x 的地址</span></span><br></pre></td></tr></table></figure>

<p>在类中，取地址操作符通常也可以被用来获取对象的地址。</p>
<h3 id="7-2-取地址操作符的重载"><a href="#7-2-取地址操作符的重载" class="headerlink" title="7.2 取地址操作符的重载"></a>7.2 取地址操作符的重载</h3><p>C++中无法重载取地址操作符 <code>&amp;</code>，但可以通过定义成员函数来改变其行为。例如通过返回自定义指针对象，而不是直接返回 <code>this</code>。重载时可以区分：</p>
<ol>
<li>普通对象的取地址。</li>
<li><code>const</code> 对象的取地址。</li>
</ol>
<h3 id="7-3-代码示例与解释"><a href="#7-3-代码示例与解释" class="headerlink" title="7.3 代码示例与解释"></a>7.3 代码示例与解释</h3><p>重载取地址操作符的代码，以下是一个简单示例，展示如何通过 <code>const</code> 和非 <code>const</code> 版本的重载来实现不同的行为。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> value) : _value(value) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非 const 版本的取地址操作符重载</span></span><br><span class="line">    MyClass* <span class="keyword">operator</span>&amp;()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;非 const 取地址操作符被调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// const 版本的取地址操作符重载</span></span><br><span class="line">    <span class="type">const</span> MyClass* <span class="keyword">operator</span>&amp;() <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;const 取地址操作符被调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Display</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; _value &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">MyClass <span class="title">obj</span><span class="params">(<span class="number">10</span>)</span></span>;            		<span class="comment">// 普通对象</span></span><br><span class="line">    <span class="function"><span class="type">const</span> MyClass <span class="title">constObj</span><span class="params">(<span class="number">20</span>)</span></span>; 		<span class="comment">// const 对象</span></span><br><span class="line"></span><br><span class="line">    MyClass* addr1 = &amp;obj;          	<span class="comment">// 调用非 const 版本的取地址操作符</span></span><br><span class="line">    <span class="type">const</span> MyClass* addr2 = &amp;constObj; 	<span class="comment">// 调用 const 版本的取地址操作符</span></span><br><span class="line"></span><br><span class="line">    addr1-&gt;<span class="built_in">Display</span>();</span><br><span class="line">    addr2-&gt;<span class="built_in">Display</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Test</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出结果</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">非 const 取地址操作符被调用</span><br><span class="line">const 取地址操作符被调用</span><br><span class="line">Value: 10</span><br><span class="line">Value: 20</span><br></pre></td></tr></table></figure>

<p><strong>代码解释</strong></p>
<ol>
<li><strong>普通对象调用非 <code>const</code> 版本的取地址操作符</strong>：<ul>
<li>当我们对普通对象 <code>obj</code> 使用 <code>&amp;</code> 时，调用的是 <code>MyClass* operator&amp;()</code>。</li>
<li>返回类型是一个非 <code>const</code> 指针，即 <code>MyClass*</code>。</li>
<li>这意味着我们可以通过这个指针修改 <code>obj</code>。</li>
</ul>
</li>
<li><strong><code>const</code> 对象调用 <code>const</code> 版本的取地址操作符</strong>：<ul>
<li>当我们对 <code>const</code> 对象 <code>constObj</code> 使用 <code>&amp;</code> 时，调用的是 <code>const MyClass* operator&amp;() const</code>。</li>
<li>返回类型是 <code>const MyClass*</code>，即一个不可修改的指针。</li>
<li>这保证了通过返回的地址无法修改 <code>constObj</code>。</li>
</ul>
</li>
</ol>
<blockquote>
<h2 id="传道解惑"><a href="#传道解惑" class="headerlink" title="传道解惑"></a>传道解惑</h2><h3 id="Q1：两种版本为什么重要？"><a href="#Q1：两种版本为什么重要？" class="headerlink" title="Q1：两种版本为什么重要？"></a>Q1：两种版本为什么重要？</h3><ul>
<li>如果只有普通的非 <code>const</code> 重载（<code>MyClass* operator&amp;()</code>），<code>const</code> 对象调用时会报错，因为无法确保 <code>const</code> 对象的不可变性。</li>
<li>如果只有 <code>const</code> 版本重载（<code>const MyClass* operator&amp;() const</code>），普通对象也只能得到一个 <code>const</code> 指针，限制了可操作性。</li>
</ul>
<p>因此，同时提供两个版本：</p>
<ul>
<li>普通对象取地址时返回普通指针，灵活操作。</li>
<li><code>const</code> 对象取地址时返回 <code>const</code> 指针，保护不可变性。</li>
</ul>
<hr>
<h3 id="Q2：取地址操作符重载的应用场景？"><a href="#Q2：取地址操作符重载的应用场景？" class="headerlink" title="Q2：取地址操作符重载的应用场景？"></a>Q2：取地址操作符重载的应用场景？</h3><ol>
<li><strong>调试日志</strong>：可以在取地址时打印出信息，便于调试。</li>
<li><strong>对象管理</strong>：可以控制对象暴露出去的指针，避免外部直接操作原始地址。</li>
<li><strong>定制行为</strong>：对于特定的类，可以在取地址时返回自定义指针对象，而不是直接返回 <code>this</code>。</li>
</ol>
<hr>
<h3 id="Q3：为什么需要区分-const-对象的取地址？"><a href="#Q3：为什么需要区分-const-对象的取地址？" class="headerlink" title="Q3：为什么需要区分 const 对象的取地址？"></a>Q3：为什么需要区分 <code>const</code> 对象的取地址？</h3><p>假如我们不区分 <code>const</code> 和非 <code>const</code> 对象取地址操作，就会产生如下问题：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="function"><span class="type">const</span> MyClass <span class="title">constObj</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line">&gt;MyClass* ptr = &amp;constObj; <span class="comment">// 如果没有 const 重载，这会破坏 constObj 的不可变性</span></span><br></pre></td></tr></table></figure>

<p>通过引入 <code>const</code> 版本的取地址操作符重载，编译器可以在 <code>const</code> 对象中强制返回 <code>const</code> 指针，保护数据安全。</p>
<ol>
<li>取地址操作符重载的作用：</li>
</ol>
<ul>
<li>自定义取地址操作符的行为。</li>
<li>区分普通对象和 <code>const</code> 对象的地址获取方式。</li>
</ul>
<ol start="2">
<li>注意事项：</li>
</ol>
<ul>
<li>对普通对象，返回普通指针。</li>
<li>对 <code>const</code> 对象，返回 <code>const</code> 指针，确保不可变性。</li>
</ul>
<p>这是一种增强代码灵活性与安全性的手段，同时对复杂场景（如调试或资源管理）非常有用。</p>
</blockquote>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://github.com/huangcancan-xbc/Drawing-bed/blob/master/Blog/20250307201719879.png?raw=true" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://github.com/huangcancan-xbc/Drawing-bed/blob/master/Blog/20250307201719879.png?raw=true" title="头像" alt="头像"></a><div class="post-copyright__author_name">小米里的大麦</div><div class="post-copyright__author_desc"></div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="http://example.com/2025/04/02/03%20%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%AD%EF%BC%89/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('http://example.com/2025/04/02/03 类与对象（中）/')">类与对象（中）</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="赞赏作者"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><div class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Blog/20250403212543768.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Blog/20250403212543768.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Blog/20250403212622868.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Blog/20250403212622868.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul><a class="reward-main-btn" href="/about/#about-reward" target="_blank"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display: none"></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="http://example.com/2025/04/02/03%20%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%AD%EF%BC%89/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=类与对象（中）&amp;url=http://example.com/2025/04/02/03%20%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%AD%EF%BC%89/&amp;pic=https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Blog/20250314131841400.png?_r_=125d5323-675c-4113-ef67-3ce6ae17162e" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">MIT</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">小米里的大麦的博客</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/C/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>C++<span class="tagsPageCount">3</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Blog/20250314131841400.png?_r_=125d5323-675c-4113-ef67-3ce6ae17162e" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2025/04/01/02%20%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%8A%EF%BC%89/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Blog/20250314140159768.png?_r_=392c8c4a-25c8-f97a-fc88-c13e18c7bcf3" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">类与对象（上）</div></div></a></div><div class="next-post pull-right"><a href="/2025/04/03/04%20%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%8B%EF%BC%89/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Blog/20250314141714221.png?_r_=aeefb4fb-501f-8f8a-4cc2-82cae65ba2a9" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">类与对象（下）</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size: 1.5rem; margin-right: 4px"></i><span>喜欢这篇文章的人也看了</span></div><div class="relatedPosts-list"><div><a href="/2025/04/01/02%20%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%8A%EF%BC%89/" title="类与对象（上）"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Blog/20250314140159768.png?_r_=392c8c4a-25c8-f97a-fc88-c13e18c7bcf3" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-04-01</div><div class="title">类与对象（上）</div></div></a></div><div><a href="/2025/04/03/04%20%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%8B%EF%BC%89/" title="类与对象（下）"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Blog/20250314141714221.png?_r_=aeefb4fb-501f-8f8a-4cc2-82cae65ba2a9" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-04-03</div><div class="title">类与对象（下）</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info__sayhi" id="author-info__sayhi" onclick="anzhiyu.changeSayHelloText()"></div><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://github.com/huangcancan-xbc/Drawing-bed/blob/master/Blog/20250307201719879.png?raw=true" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-status"><img class="g-status" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/08/24/64e6ce9c507bb.png" alt="status"/></div></div><div class="author-info__description">小米里的大麦的博客</div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/"><h1 class="author-info__name">小米里的大麦</h1><div class="author-info__desc"></div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/huangcancan-xbc" target="_blank" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a><a class="social-icon faa-parent animated-hover" href="https://blog.csdn.net/Huangcancan666?type=blog" target="_blank" title="CSDN"><i class="anzhiyufont anzhiyu-icon-bilibili"></i></a><a class="social-icon faa-parent animated-hover" href="https://gitee.com/huang-cancan-xbc" target="_blank" title="gitee"><i class="anzhiyufont anzhiyu-icon-gitee"></i></a></div></div></div></div><div class="card-widget anzhiyu-right-widget" id="card-wechat" onclick="null"><div id="flip-wrapper"><div id="flip-content"><div class="face" style="background: url(https://bu.dusays.com/2023/01/13/63c02edf44033.png) center center / 100% no-repeat"></div><div class="back face" style="background: url(https://bu.dusays.com/2023/05/13/645fa415e8694.png) center center / 100% no-repeat"></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%B1%BB%E7%9A%84-6-%E4%B8%AA%E9%BB%98%E8%AE%A4%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">1.</span> <span class="toc-text">1. 类的 6 个默认成员函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%A0%E9%81%93%E8%A7%A3%E6%83%91%EF%BC%9A"><span class="toc-number">2.</span> <span class="toc-text">传道解惑：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Q1%EF%BC%9Ae1%E2%80%94%E2%80%94%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%EF%BC%9A"><span class="toc-number">2.1.</span> <span class="toc-text">Q1：e1——类的实例化：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q2%EF%BC%9AePtr-%E2%80%94%E2%80%94-Example-%E7%B1%BB%E7%9A%84%E6%8C%87%E9%92%88%EF%BC%9A"><span class="toc-number">2.2.</span> <span class="toc-text">Q2：ePtr —— Example 类的指针：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">3.</span> <span class="toc-text">2. 构造函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%87%BD%E6%95%B0%E5%90%8D%E4%B8%8E%E7%B1%BB%E5%90%8D%E7%9B%B8%E5%90%8C"><span class="toc-number">3.0.1.</span> <span class="toc-text">1. 函数名与类名相同</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%97%A0%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">3.0.2.</span> <span class="toc-text">2. 无返回值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B%E5%8C%96%E6%97%B6%EF%BC%8C%E8%87%AA%E5%8A%A8%E8%B0%83%E7%94%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">3.0.3.</span> <span class="toc-text">3. 对象实例化时，自动调用构造函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%8F%AF%E4%BB%A5%E9%87%8D%E8%BD%BD"><span class="toc-number">3.0.4.</span> <span class="toc-text">4. 构造函数可以重载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E7%94%9F%E6%88%90%E8%A7%84%E5%88%99"><span class="toc-number">3.0.5.</span> <span class="toc-text">5. 默认构造函数的生成规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%AF%B9%E5%86%85%E7%BD%AE%E5%92%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-number">3.0.6.</span> <span class="toc-text">6. 默认构造函数对内置和自定义类型的处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E7%A7%8D%E7%B1%BB"><span class="toc-number">3.0.7.</span> <span class="toc-text">7. 默认构造函数的种类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E6%97%A0%E5%8F%82%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%88%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%89"><span class="toc-number">3.1.</span> <span class="toc-text">2.1. 无参构造函数（默认构造函数）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E5%B8%A6%E5%8F%82%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">3.2.</span> <span class="toc-text">2.2 带参构造函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%A0%E9%81%93%E8%A7%A3%E6%83%91%EF%BC%9A-1"><span class="toc-number">4.</span> <span class="toc-text">传道解惑：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Q1%EF%BC%9A%E5%85%AC%E6%9C%89%EF%BC%88public%EF%BC%89%E7%A7%81%E6%9C%89%EF%BC%88private%EF%BC%89%E9%83%A8%E5%88%86%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%9A"><span class="toc-number">4.1.</span> <span class="toc-text">Q1：公有（public）私有（private）部分的关系：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q2%EF%BC%9A%E7%A7%81%E6%9C%89%E5%8F%98%E9%87%8F%E6%98%AF%E5%90%A6%E5%BF%85%E9%A1%BB%E5%9C%A8%E5%85%AC%E6%9C%89%E9%83%A8%E5%88%86%E5%87%BA%E7%8E%B0%EF%BC%9F"><span class="toc-number">4.2.</span> <span class="toc-text">Q2：私有变量是否必须在公有部分出现？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q3%EF%BC%9A%E5%85%B3%E4%BA%8E%E7%BC%96%E8%AF%91%E5%99%A8%E7%94%9F%E6%88%90%E7%9A%84%E9%BB%98%E8%AE%A4%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%EF%BC%8C%E5%9C%A8%E4%B8%8D%E5%AE%9E%E7%8E%B0%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%EF%BC%8C%E7%BC%96%E8%AF%91%E5%99%A8%E4%BC%9A%E7%94%9F%E6%88%90%E9%BB%98%E8%AE%A4%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E3%80%82%E4%BD%86%E6%98%AF%E7%9C%8B%E8%B5%B7%E6%9D%A5%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%8F%88%E6%B2%A1%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F%E5%AF%B9%E8%B1%A1%E8%B0%83%E7%94%A8%E4%BA%86%E7%BC%96%E8%AF%91%E5%99%A8%E7%94%9F%E6%88%90%E7%9A%84%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%8C%E4%BD%86%E6%98%AF%E5%AF%B9%E8%B1%A1%E9%87%8C%E4%BE%9D%E6%97%A7%E6%98%AF%E9%9A%8F%E6%9C%BA%E5%80%BC%E3%80%82%E4%B9%9F%E5%B0%B1%E6%98%AF%E8%AF%B4%EF%BC%8C%E5%9C%A8%E8%BF%99%E9%87%8C%E7%BC%96%E8%AF%91%E5%99%A8%E7%94%9F%E6%88%90%E7%9A%84%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%B9%B6%E6%B2%A1%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F"><span class="toc-number">4.3.</span> <span class="toc-text">Q3：关于编译器生成的默认成员函数，在不实现构造函数的情况下，编译器会生成默认的构造函数。但是看起来默认构造函数又没什么用？对象调用了编译器生成的默认构造函数，但是对象里依旧是随机值。也就是说，在这里编译器生成的默认构造函数并没有什么用？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-number">5.</span> <span class="toc-text">3. 析构函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E7%9A%84-6-%E4%B8%AA%E7%89%B9%E5%BE%81%EF%BC%9A"><span class="toc-number">5.1.</span> <span class="toc-text">3.1 析构函数的 6 个特征：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E7%9A%84%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99%EF%BC%9A%E7%B1%BB%E5%90%8D%E5%89%8D%E5%8A%A0%E5%AD%97%E7%AC%A6"><span class="toc-number">5.1.1.</span> <span class="toc-text">1. 析构函数的命名规则：类名前加字符 ~</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%97%A0%E5%8F%82%E6%95%B0%E3%80%81%E6%97%A0%E8%BF%94%E5%9B%9E%E5%80%BC%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.1.2.</span> <span class="toc-text">2. 无参数、无返回值类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%B8%80%E4%B8%AA%E7%B1%BB%E5%8F%AA%E8%83%BD%E6%9C%89%E4%B8%80%E4%B8%AA%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%EF%BC%8C%E4%B8%94%E4%B8%8D%E8%83%BD%E9%87%8D%E8%BD%BD"><span class="toc-number">5.1.3.</span> <span class="toc-text">3. 一个类只能有一个析构函数，且不能重载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%AF%B9%E8%B1%A1%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%BB%93%E6%9D%9F%E6%97%B6%EF%BC%8C%E8%87%AA%E5%8A%A8%E8%B0%83%E7%94%A8%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-number">5.1.4.</span> <span class="toc-text">4. 对象生命周期结束时，自动调用析构函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E9%BB%98%E8%AE%A4%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%EF%BC%9A%E5%A4%84%E7%90%86%E7%B1%BB%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E6%88%90%E5%91%98%E7%9A%84%E6%9E%90%E6%9E%84"><span class="toc-number">5.1.5.</span> <span class="toc-text">5. 默认析构函数：处理类中自定义类型成员的析构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E6%B2%A1%E6%9C%89%E8%B5%84%E6%BA%90%E6%97%B6%E5%8F%AF%E4%BB%A5%E4%B8%8D%E5%86%99%EF%BC%8C%E6%9C%89%E8%B5%84%E6%BA%90%E6%97%B6%E5%BF%85%E9%A1%BB%E5%86%99"><span class="toc-number">5.1.6.</span> <span class="toc-text">6. 没有资源时可以不写，有资源时必须写</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E7%A4%BA%E4%BE%8B%EF%BC%9A"><span class="toc-number">5.2.</span> <span class="toc-text">3.2 示例：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">6.</span> <span class="toc-text">4. 拷贝构造函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84-5-%E4%B8%AA%E7%89%B9%E5%BE%81%EF%BC%9A"><span class="toc-number">7.</span> <span class="toc-text">4.1 拷贝构造函数的 5 个特征：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%98%AF%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E4%B8%80%E4%B8%AA%E9%87%8D%E8%BD%BD%E5%BD%A2%E5%BC%8F"><span class="toc-number">7.0.1.</span> <span class="toc-text">1. 拷贝构造函数是构造函数的一个重载形式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%8F%82%E6%95%B0%E5%BF%85%E9%A1%BB%E6%98%AF%E7%B1%BB%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%BC%95%E7%94%A8"><span class="toc-number">7.0.2.</span> <span class="toc-text">2. 参数必须是类类型的引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E9%BB%98%E8%AE%A4%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">7.0.3.</span> <span class="toc-text">3. 默认拷贝构造函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E6%98%AF%E5%90%A6%E9%9C%80%E8%A6%81%E6%98%BE%E5%BC%8F%E5%AE%9A%E4%B9%89%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="toc-number">7.0.4.</span> <span class="toc-text">4. 是否需要显式定义拷贝构造函数？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%85%B8%E5%9E%8B%E8%B0%83%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">7.0.5.</span> <span class="toc-text">5. 拷贝构造函数的典型调用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%90%E9%AB%98%E6%95%88%E7%8E%87%E7%9A%84%E5%BB%BA%E8%AE%AE"><span class="toc-number">7.0.6.</span> <span class="toc-text">提高效率的建议</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E9%BB%98%E8%AE%A4%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">7.1.</span> <span class="toc-text">4.2 默认拷贝构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">7.2.</span> <span class="toc-text">4.3 自定义拷贝构造函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-number">8.</span> <span class="toc-text">5. 赋值运算符重载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-%E5%AF%B9%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E5%85%B3%E9%94%AE%E7%82%B9%E8%A7%A3%E9%87%8A%EF%BC%9A"><span class="toc-number">9.</span> <span class="toc-text">5.1 对运算符重载关键点解释：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="toc-number">9.0.1.</span> <span class="toc-text">1. 运算符重载的本质</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E8%A7%84%E5%88%99"><span class="toc-number">9.0.2.</span> <span class="toc-text">2. 运算符重载规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0-vs-%E5%85%A8%E5%B1%80%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD"><span class="toc-number">9.0.3.</span> <span class="toc-text">3. 成员函数 vs 全局函数重载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%B8%B8%E8%A7%81%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">9.0.4.</span> <span class="toc-text">4. 常见运算符重载的实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%EF%BC%88operator-%EF%BC%89"><span class="toc-number">9.0.5.</span> <span class="toc-text">赋值运算符重载（operator&#x3D;）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8D%E7%BD%AE-%E5%92%8C-%E5%90%8E%E7%BD%AE-%E9%87%8D%E8%BD%BD"><span class="toc-number">9.0.6.</span> <span class="toc-text">前置++ 和 后置++ 重载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A0%E6%B3%95%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%EF%BC%88operator-%EF%BC%89"><span class="toc-number">9.0.7.</span> <span class="toc-text">加法运算符重载（operator+）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E9%BB%98%E8%AE%A4%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD-vs-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AE%9E%E7%8E%B0"><span class="toc-number">9.0.8.</span> <span class="toc-text">5. 默认运算符重载 vs 自定义实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%94%E5%9B%9E%E5%BC%95%E7%94%A8%EF%BC%9F"><span class="toc-number">9.0.9.</span> <span class="toc-text">6. 为什么返回引用？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">9.1.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-%E7%A4%BA%E4%BE%8B%EF%BC%9A"><span class="toc-number">10.</span> <span class="toc-text">5.2 示例：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%BB%98%E8%AE%A4%E5%AE%9E%E7%8E%B0"><span class="toc-number">10.0.1.</span> <span class="toc-text">1. 默认实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%87%8D%E8%BD%BD%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">10.0.2.</span> <span class="toc-text">2. 重载赋值运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD"><span class="toc-number">10.0.3.</span> <span class="toc-text">重载 +</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD-1"><span class="toc-number">10.0.4.</span> <span class="toc-text">重载 &#x3D;&#x3D;</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-const-%E6%88%90%E5%91%98"><span class="toc-number">11.</span> <span class="toc-text">6. const 成员</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-%E6%80%BB%E7%BB%93%E8%A7%84%E5%88%99%EF%BC%9A"><span class="toc-number">11.1.</span> <span class="toc-text">6.1 总结规则：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9A"><span class="toc-number">11.2.</span> <span class="toc-text">6.2 适用场景：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-%E5%85%B3%E9%94%AE%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%9A"><span class="toc-number">11.3.</span> <span class="toc-text">6.3 关键知识点：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%A0%E9%81%93%E8%A7%A3%E6%83%91%EF%BC%9A-2"><span class="toc-number">12.</span> <span class="toc-text">传道解惑：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Q1%EF%BC%9A-const-%E5%AF%B9%E8%B1%A1%E5%8F%AF%E4%BB%A5%E8%B0%83%E7%94%A8%E9%9D%9E-const-%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%90%97%EF%BC%9F"><span class="toc-number">12.1.</span> <span class="toc-text">Q1： const 对象可以调用非 const 成员函数吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q2%EF%BC%9Aconst-%E5%AF%B9%E8%B1%A1%E5%8F%AF%E4%BB%A5%E8%B0%83%E7%94%A8-const-%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%90%97%EF%BC%9F"><span class="toc-number">12.2.</span> <span class="toc-text">Q2：const 对象可以调用 const 成员函数吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q3%EF%BC%9Aconst-%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%86%85%E5%8F%AF%E4%BB%A5%E8%B0%83%E7%94%A8%E5%85%B6%E5%AE%83%E7%9A%84%E9%9D%9E-const-%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%90%97%EF%BC%9F"><span class="toc-number">12.3.</span> <span class="toc-text">Q3：const 成员函数内可以调用其它的非 const 成员函数吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q4-const-%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%86%85%E5%8F%AF%E4%BB%A5%E8%B0%83%E7%94%A8%E5%85%B6%E5%AE%83%E7%9A%84-const-%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%90%97%EF%BC%9F"><span class="toc-number">12.4.</span> <span class="toc-text">Q4: const 成员函数内可以调用其它的 const 成员函数吗？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E5%8F%96%E5%9C%B0%E5%9D%80%E5%8F%8A-const-%E5%8F%96%E5%9C%B0%E5%9D%80%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-number">13.</span> <span class="toc-text">7. 取地址及 const 取地址操作符重载</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-%E5%8F%96%E5%9C%B0%E5%9D%80%E6%93%8D%E4%BD%9C%E7%AC%A6-%E9%BB%98%E8%AE%A4%E8%A1%8C%E4%B8%BA"><span class="toc-number">13.1.</span> <span class="toc-text">7.1 取地址操作符 &amp; 默认行为</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-%E5%8F%96%E5%9C%B0%E5%9D%80%E6%93%8D%E4%BD%9C%E7%AC%A6%E7%9A%84%E9%87%8D%E8%BD%BD"><span class="toc-number">13.2.</span> <span class="toc-text">7.2 取地址操作符的重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%E4%B8%8E%E8%A7%A3%E9%87%8A"><span class="toc-number">13.3.</span> <span class="toc-text">7.3 代码示例与解释</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%A0%E9%81%93%E8%A7%A3%E6%83%91"><span class="toc-number">14.</span> <span class="toc-text">传道解惑</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Q1%EF%BC%9A%E4%B8%A4%E7%A7%8D%E7%89%88%E6%9C%AC%E4%B8%BA%E4%BB%80%E4%B9%88%E9%87%8D%E8%A6%81%EF%BC%9F"><span class="toc-number">14.1.</span> <span class="toc-text">Q1：两种版本为什么重要？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q2%EF%BC%9A%E5%8F%96%E5%9C%B0%E5%9D%80%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="toc-number">14.2.</span> <span class="toc-text">Q2：取地址操作符重载的应用场景？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q3%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%8C%BA%E5%88%86-const-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8F%96%E5%9C%B0%E5%9D%80%EF%BC%9F"><span class="toc-number">14.3.</span> <span class="toc-text">Q3：为什么需要区分 const 对象的取地址？</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/04/03/04%20%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%8B%EF%BC%89/" title="类与对象（下）"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Blog/20250314141714221.png?_r_=aeefb4fb-501f-8f8a-4cc2-82cae65ba2a9" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="类与对象（下）"/></a><div class="content"><a class="title" href="/2025/04/03/04%20%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%8B%EF%BC%89/" title="类与对象（下）">类与对象（下）</a><time datetime="2025-04-02T16:00:00.000Z" title="发表于 2025-04-03 00:00:00">2025-04-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/04/02/03%20%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%AD%EF%BC%89/" title="类与对象（中）"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Blog/20250314131841400.png?_r_=125d5323-675c-4113-ef67-3ce6ae17162e" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="类与对象（中）"/></a><div class="content"><a class="title" href="/2025/04/02/03%20%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%AD%EF%BC%89/" title="类与对象（中）">类与对象（中）</a><time datetime="2025-04-01T16:00:00.000Z" title="发表于 2025-04-02 00:00:00">2025-04-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/04/01/02%20%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%8A%EF%BC%89/" title="类与对象（上）"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Blog/20250314140159768.png?_r_=392c8c4a-25c8-f97a-fc88-c13e18c7bcf3" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="类与对象（上）"/></a><div class="content"><a class="title" href="/2025/04/01/02%20%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%8A%EF%BC%89/" title="类与对象（上）">类与对象（上）</a><time datetime="2025-03-31T16:00:00.000Z" title="发表于 2025-04-01 00:00:00">2025-04-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/09/01/obsidian%E4%BD%BF%E7%94%A8/" title="obsidian使用"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Blog/20250314130519403.jpg?_r_=49a67235-3ef7-4555-b340-db20f7affa7a" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="obsidian使用"/></a><div class="content"><a class="title" href="/2023/09/01/obsidian%E4%BD%BF%E7%94%A8/" title="obsidian使用">obsidian使用</a><time datetime="2023-09-01T05:00:00.000Z" title="发表于 2023-09-01 13:00:00">2023-09-01</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2025 By <a class="footer-bar-link" href="/" title="小米里的大麦" target="_blank">小米里的大麦</a></div></div><div id="footer-type-tips"></div><div class="js-pjax"><script>function subtitleType () {
  fetch('https://v1.hitokoto.cn')
    .then(response => response.json())
    .then(data => {
      if (true) {
        const from = '出自 ' + data.from
        const sub = ["《左传》载曰：“太上有立德，其次有立功，其次有立言，虽久不废，此之谓不朽。”","纸上得来终觉浅，绝知此事要躬行！"]
        sub.unshift(data.hitokoto, from)
        window.typed = new Typed('#footer-type-tips', {
          strings: sub,
          startDelay: 300,
          typeSpeed: 150,
          loop: true,
          backSpeed: 50,
        })
      } else {
        document.getElementById('footer-type-tips').innerHTML = data.hitokoto
      }
    })
}

if (true) {
  if (typeof Typed === 'function') {
    subtitleType()
  } else {
    getScript('https://cdn.cbd.int/typed.js@2.1.0/dist/typed.umd.js').then(subtitleType)
  }
} else {
  subtitleType()
}
</script></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="安知鱼主题">安知鱼主题</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">4</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">4</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">2</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">社交</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://github.com/huangcancan-xbc" title="GitHub"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="GitHub"/><span class="back-menu-item-text">GitHub</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://gitee.com/huang-cancan-xbc" title="gitee"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="gitee"/><span class="back-menu-item-text">gitee</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">博客</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://blog.csdn.net/Huangcancan666?type=blog" title="CSDN"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="CSDN"/><span class="back-menu-item-text">CSDN</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/fcircle/"><i class="anzhiyufont anzhiyu-icon-artstation faa-tada" style="font-size: 0.9em;"></i><span> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/C/" style="font-size: 0.88rem;">C++<sup>3</sup></a><a href="/tags/Obsidian/" style="font-size: 0.88rem;">Obsidian<sup>1</sup></a><a href="/tags/%E5%B7%A5%E5%85%B7/" style="font-size: 0.88rem;">工具<sup>1</sup></a><a href="/tags/%E7%AC%94%E8%AE%B0/" style="font-size: 0.88rem;">笔记<sup>1</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="anzhiyufont anzhiyu-icon-xmark"></i></button></nav><div class="is-center" id="loading-database"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-pulse-icon"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/medium-zoom@1.1.0/dist/medium-zoom.min.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.cbd.int/pangu@4.0.7/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (true){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("01/01/2025 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2025 By 安知鱼 V1.6.14",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 小米里的大麦 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><input type="hidden" name="page-type" id="page-type" value="post"></div><script async data-pjax src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.1/bubble/bubble.js"></script><script>var visitorMail = "";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><script src="/js/anzhiyu/right_click_menu.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><script id="click-show-text" src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/dist/click-show-text.min.js" data-mobile="false" data-text="offer,get rich quick,offer,healthy,offer,happy,successes,liberty" data-fontsize="18px" data-random="true" async="async"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>