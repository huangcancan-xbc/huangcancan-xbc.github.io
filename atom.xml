<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小米里的大麦</title>
  
  
  <link href="https://www.minbit.top/atom.xml" rel="self"/>
  
  <link href="https://www.minbit.top/"/>
  <updated>2025-11-15T02:10:00.000Z</updated>
  <id>https://www.minbit.top/</id>
  
  <author>
    <name>小米里的大麦</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>免费白嫖 ChatGPT Go 套餐</title>
    <link href="https://www.minbit.top/posts/41191.html"/>
    <id>https://www.minbit.top/posts/41191.html</id>
    <published>2025-11-04T16:00:00.000Z</published>
    <updated>2025-11-15T02:10:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="免费白嫖-ChatGPT-Go-套餐-12-个月（一年）"><a href="#免费白嫖-ChatGPT-Go-套餐-12-个月（一年）" class="headerlink" title="免费白嫖 ChatGPT Go 套餐 12 个月（一年）"></a>免费白嫖 ChatGPT Go 套餐 12 个月（一年）</h1><h2 id="1-前提说明"><a href="#1-前提说明" class="headerlink" title="1. 前提说明"></a>1. 前提说明</h2><blockquote><p><strong>官方说明：</strong></p><p><a href="https://help.openai.com/zh-hans-cn/articles/11989085-what-is-chatgpt-go">什么是 ChatGPT Go？</a></p><p><a href="https://help.openai.com/zh-hans-cn/articles/12739021-chatgpt-go-promotion-india">ChatGPT Go 推广活动（印度）</a></p></blockquote><p>ChatGPT Go 是 OpenAI 于 2025 年 11 月 4 日在印度地区推出的全新套餐服务，据说使用额度限制是免费版的 10 倍左右，上下文窗口是免费版的 2 倍左右，官方套餐说明：</p><ul><li>对 GPT-5 的扩展访问权限</li><li>扩展的消息和上传限额</li><li>扩展且较快的图片生成</li><li>更全面的记忆和背景信息</li><li>有限的深度研究</li><li>项目、任务、自定义 GPT</li></ul><h3 id="1-基本条件"><a href="#1-基本条件" class="headerlink" title="1. 基本条件"></a>1. 基本条件</h3><ul><li>PayPal 账户</li><li>印度 IP</li><li>GPT 的新注册用户&#x2F;免费用户&#x2F;状态良好的 ChatGPT Go 的订阅者</li></ul><h3 id="2-疑难解答"><a href="#2-疑难解答" class="headerlink" title="2. 疑难解答"></a>2. 疑难解答</h3><h4 id="Q1-获得套餐后是否需要持续使用印度节点？"><a href="#Q1-获得套餐后是否需要持续使用印度节点？" class="headerlink" title="Q1: 获得套餐后是否需要持续使用印度节点？"></a>Q1: 获得套餐后是否需要持续使用印度节点？</h4><p><strong>A</strong>: 实测验证，成功订阅 ChatGPT Go 套餐后，可使用 <strong>任意地区</strong> 节点访问。网页界面会持续显示 ChatGPT Go 套餐状态，所有功能正常使用，无任何限制影响。</p><h4 id="Q2-免费使用的关键注意事项？"><a href="#Q2-免费使用的关键注意事项？" class="headerlink" title="Q2: 免费使用的关键注意事项？"></a>Q2: 免费使用的关键注意事项？</h4><p><strong>A</strong>: ChatGPT Go 套餐采用每月自动续订模式。若提前取消订阅，套餐权益将立即终止。套餐到期后若未取消，系统将自动按月扣除 4 美元费用。<strong>想要最大化免费使用其额度就选择在套餐到期的最后一个月进行取消订阅</strong>。</p><h2 id="2-注册一个-paypal-账户"><a href="#2-注册一个-paypal-账户" class="headerlink" title="2. 注册一个 paypal 账户"></a>2. 注册一个 paypal 账户</h2><p>虽然不会产生实际扣费，但订阅过程需要验证支付方式，<strong>注册地址</strong>：<a href="https://www.paypal.com/c2/home">中国区 PayPal 官方网站</a>，不会注册的自行百度。</p><h2 id="3-订阅-ChatGPT-Go-套餐"><a href="#3-订阅-ChatGPT-Go-套餐" class="headerlink" title="3. 订阅 ChatGPT Go 套餐"></a>3. 订阅 ChatGPT Go 套餐</h2><h3 id="1-显示套餐"><a href="#1-显示套餐" class="headerlink" title="1. 显示套餐"></a>1. 显示套餐</h3><p>我们使用 <strong>印度地区</strong> 节点访问 ChatGPT 网页版，刷新页面后即可看到 ChatGPT Go 套餐选项</p><p><img src="https://zycs-img-8kd.pages.dev/v2/cFvNihE.png"></p><p><img src="https://zycs-img-8kd.pages.dev/v2/TDv7azn.png"></p><h3 id="2-订购套餐"><a href="#2-订购套餐" class="headerlink" title="2. 订购套餐"></a>2. 订购套餐</h3><p><strong>注意：千万不要着急进行订购！</strong> 印度是不支持 PayPal 支付的，所以在订购页面的右下角可以看到 <strong>选择国家</strong>，这里选择支持 PayPal 支付的国家，欧洲国家一般都支持，我们以法国为例，将国家切换至法国，然后再进行订购，此时可以看到，折扣是 100%即 0 元购，支付方式选择 PayPal，输入刚才注册 PayPal 账号的信息，即可订购成功！</p><blockquote><p><strong>再次声明：一定要在套餐期限内取消订购，否则超期会自动扣款！</strong></p></blockquote><h2 id="4-彩蛋时间"><a href="#4-彩蛋时间" class="headerlink" title="4. 彩蛋时间"></a>4. 彩蛋时间</h2><p>既然已经有了 PayPal，那么想要白嫖 <a href="https://www.perplexity.ai/join/p/paypal-subscription">Perplexity Pro</a> 也是顺手的事，操作也是大同小异，这里就不多赘述了，<a href="https://www.perplexity.ai/">Perplexity</a> 大概就是一个 AI 搜索引擎，不得不说这些 AI 搜索引擎在某些方面的能力确实很强，能够查到一些比较“封闭”的资源，根据个人所需选择了。</p><blockquote><p><strong>白嫖的感觉确实很爽，但我还是要真心说一句：我支持付费，也鼓励付费。老话说得好，免费的才是最贵的，但像这样一个月成百上千块钱的付费确实挺贵，期待未来当您有能力时，愿意为真正有价值的产品和服务买单，以表对优质产品和服务的支持！</strong></p></blockquote><hr><blockquote><p>  [!CAUTION]</p><p>  截至时间 2025.11.15，似乎白嫖 ChatGPT Go 套餐的账户已经陆续回退至免费账户，具体原因不详。下面是官方说明：OpenAI 原本针对 <strong>印度地区的合格用户</strong> 推出了 ChatGPT Go 的促销活动，但由于支付系统的技术错误，这个优惠被错误地应用到了 <strong>印度以外地区的 PayPal 订单</strong> 中，官方的处理措施：</p><ul><li>已经修复了支付系统的漏洞；</li><li>会 <strong>撤销账户上错误应用的促销折扣</strong>；</li><li>ChatGPT Go 订阅会 <strong>恢复到原始状态</strong>（如果之前是免费版，就会回到免费版；如果是付费版，会按原付费规则执行），且 <strong>不会自动续费</strong>。</li></ul></blockquote>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;免费白嫖-ChatGPT-Go-套餐-12-个月（一年）&quot;&gt;&lt;a href=&quot;#免费白嫖-ChatGPT-Go-套餐-12-个月（一年）&quot; class=&quot;headerlink&quot; title=&quot;免费白嫖 ChatGPT Go 套餐 12</summary>
        
      
    
    
    
    <category term="灵光荟萃" scheme="https://www.minbit.top/categories/%E7%81%B5%E5%85%89%E8%8D%9F%E8%90%83/"/>
    
    
    <category term="ChatGPT" scheme="https://www.minbit.top/tags/ChatGPT/"/>
    
    <category term="AI" scheme="https://www.minbit.top/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>057 高级 IO 之 epoll 详解与 CMake 入门</title>
    <link href="https://www.minbit.top/posts/4211.html"/>
    <id>https://www.minbit.top/posts/4211.html</id>
    <published>2025-10-19T04:00:00.000Z</published>
    <updated>2025-10-29T04:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="epoll-和-CMake-的使用"><a href="#epoll-和-CMake-的使用" class="headerlink" title="epoll 和 CMake 的使用"></a>epoll 和 CMake 的使用</h1><h2 id="1-epoll-简介"><a href="#1-epoll-简介" class="headerlink" title="1. epoll 简介"></a>1. epoll 简介</h2><p>epoll 是 Linux 系统提供的一种 IO 多路复用机制，用来替代传统的 select 和 poll。它的核心优势是：</p><ul><li><strong>高效</strong>：性能不会随着监听的文件描述符数量增加而下降。</li><li><strong>内存友好</strong>：只返回就绪的事件，而不是遍历所有文件描述符。</li><li><strong>支持边缘触发</strong>：可以更灵活地控制事件触发方式。</li></ul><h2 id="2-epoll-的三大函数"><a href="#2-epoll-的三大函数" class="headerlink" title="2. epoll 的三大函数"></a>2. epoll 的三大函数</h2><p><code>epoll_create</code>、<code>epoll_ctl</code> 和 <code>epoll_wait</code> 是 epoll 机制的三个核心函数，可以类比为：</p><ul><li><code>epoll_create()</code>：创建一个 epoll 实例（相当于创建一个事件监听器）。</li><li><code>epoll_ctl()</code>：管理要监听的文件描述符（添加、修改、删除监听列表中的 fd）。</li><li><code>epoll_wait()</code>：等待事件发生（阻塞等待，直到有事件发生或超时）。</li></ul><blockquote><p>这三兄弟的关系就像一个管理系统的三个操作：</p><ol><li><code>epoll_create()</code>：创建一个管理办公室。</li><li><code>epoll_ctl()</code>：向办公室登记&#x2F;修改&#x2F;删除要监控的员工（文件描述符）。</li><li><code>epoll_wait()</code>：在办公室等待，当有员工出事（事件发生）时进行通知。</li></ol><p>这种设计使得 epoll 可以高效地管理大量文件描述符，特别适合高并发的服务器程序。</p></blockquote><h2 id="3-epoll-create-epoll-create1-——-创建-epoll-实例"><a href="#3-epoll-create-epoll-create1-——-创建-epoll-实例" class="headerlink" title="3. epoll_create&#x2F;epoll_create1 —— 创建 epoll 实例"></a>3. <code>epoll_create</code>&#x2F;<code>epoll_create1</code> —— 创建 epoll 实例</h2><p><strong>介绍</strong>：创建一个 epoll 实例，返回一个文件描述符，后续的所有 epoll 操作都通过这个 fd 进行。</p><p><strong>函数原型：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_create</span><span class="params">(<span class="type">int</span> size)</span></span>;<span class="comment">// 旧版</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_create1</span><span class="params">(<span class="type">int</span> flags)</span></span>;<span class="comment">// 推荐：带 flags（如 EPOLL_CLOEXEC）</span></span><br></pre></td></tr></table></figure><p><strong>参数</strong>：</p><ul><li><code>size</code>：告诉内核你 <strong>大概</strong> 要监听多少个文件描述符，它只是一个 <strong>提示值</strong>，在较新的内核中这个参数已经不重要了，但必须大于 0，内核会动态调整内部数据结构的大小，实际可以监听的 fd 数量 <strong>只受系统资源限制</strong>（如文件描述符限制、内存等），定义 <code>size = 10</code>，但实际监听 1000 个 fd 也没问题。</li><li><code>flags</code> 常用 <code>0</code> 或 <code>EPOLL_CLOEXEC</code>（在 exec 时自动关闭 epfd），即：<code>epoll_create1(0)</code>、<code>epoll_create1(EPOLL_CLOEXEC)</code>。</li></ul><p><strong>返回值</strong>：</p><ul><li>成功：返回一个 epoll 文件描述符 <code>epfd</code>（&gt;&#x3D; 0），后续用这个 fd 来操作 epoll</li><li>失败：返回 -1，同时设置 errno。</li></ul><p><strong>使用示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> epfd = <span class="built_in">epoll_create</span>(<span class="number">1024</span>);  <span class="comment">// 创建一个 epoll 实例，预计监听1024个fd</span></span><br><span class="line"><span class="keyword">if</span> (epfd == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">perror</span>(<span class="string">&quot;epoll_create failed&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="4-epoll-ctl-——-控制监听列表（注册-修改-删除-关注的-fd）"><a href="#4-epoll-ctl-——-控制监听列表（注册-修改-删除-关注的-fd）" class="headerlink" title="4. epoll_ctl —— 控制监听列表（注册 &#x2F; 修改 &#x2F; 删除 关注的 fd）"></a>4. <code>epoll_ctl</code> —— 控制监听列表（注册 &#x2F; 修改 &#x2F; 删除 关注的 fd）</h2><p><strong>介绍</strong>：向 epoll 实例中添加、修改或删除要监听的文件描述符。</p><p><strong>函数原型：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> op, <span class="type">int</span> fd, <span class="keyword">struct</span> epoll_event *event)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>epoll_event 结构体</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">epoll_event</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> events;    <span class="comment">// 要监听的事件类型</span></span><br><span class="line">    <span class="type">epoll_data_t</span> data;  <span class="comment">// 用户数据，可以存储fd或指针</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> <span class="title class_">epoll_data</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span>        *ptr;   <span class="comment">// 可以指向任意数据</span></span><br><span class="line">    <span class="type">int</span>          fd;    <span class="comment">// 文件描述符</span></span><br><span class="line">    <span class="type">uint32_t</span>     u32;   <span class="comment">// 32位无符号整数</span></span><br><span class="line">    <span class="type">uint64_t</span>     u64;   <span class="comment">// 64位无符号整数</span></span><br><span class="line">&#125; <span class="type">epoll_data_t</span>;</span><br></pre></td></tr></table></figure><p><strong>参数：</strong></p><ul><li><p><code>epfd</code>：<code>epoll_create</code> 返回的 epoll 文件描述符。</p></li><li><p><code>op</code>：操作类型，告诉 epoll 要做什么。</p><ul><li><code>EPOLL_CTL_ADD</code>：<strong>添加</strong> 一个新的文件描述符到监听列表。</li><li><code>EPOLL_CTL_MOD</code>：<strong>修改</strong> 已存在文件描述符的监听事件。</li><li><code>EPOLL_CTL_DEL</code>：从监听列表中 <strong>删除</strong> 一个文件描述符。</li></ul></li><li><p><code>fd</code>：目标被监控的文件描述符&#x2F;要操作的文件描述符（socket、管道、文件等）。</p></li><li><p><code>event</code>：指向 epoll_event 结构体的指针。</p><ul><li><code>events</code> 指定要关注&#x2F;监听的事件，<strong>常用的 events 事件</strong>：<ul><li><code>EPOLLIN</code>：文件描述符 <strong>可读</strong>。</li><li><code>EPOLLOUT</code>：文件描述符 <strong>可写</strong>。</li><li><code>EPOLLERR</code>：文件描述符 <strong>错误</strong>。</li><li><code>EPOLLPRI</code>：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）。</li><li><code>EPOLLRDHUP</code>：对端文件描述符关闭（连接）。</li><li><code>EPOLLET</code>：边缘触发模式。</li><li><code>EPOLLONESHOT</code>：只监听一次事件，当监听完这次事件之后，如果还需要继续监听该文件描述符的话，需要重新将该文件描述符添加到 epoll 模型中。</li></ul></li><li><code>data</code> 用于回传用户自定义数据（通常存 <code>fd</code> 或结构体指针）。<code>event</code> 对 <code>EPOLL_CTL_DEL</code> 可传 <code>NULL</code>（在某些内核版本仍需有效结构，传地址更保险）。</li></ul></li></ul><blockquote><p><strong>注意</strong>：添加前务必确保 fd 是合法且已打开。若使用 <code>EPOLLET</code>（边沿触发），<strong>必须</strong> 把 fd 设为非阻塞（<code>fcntl</code> + <code>O_NONBLOCK</code>），<code>EPOLL_CTL_MOD</code> 用于修改同一 fd 的事件或 user data。</p><p><strong>只有删除操作(EPOLL_CTL_DEL)可以传 nullptr，添加和修改操作必须传有效的 epoll_event 指针：</strong></p><ul><li>EPOLL_CTL_ADD：需要告诉内核监听什么事件 → 必须传 <code>struct epoll_event *</code>。</li><li>EPOLL_CTL_MOD：需要告诉内核修改成什么事件 → 必须传 <code>struct epoll_event *</code>。</li><li>EPOLL_CTL_DEL：只是删除，不需要指定事件 → 可以传 <code>nullptr</code>。</li></ul><p>传 nullptr 的含义：删除操作不需要关心事件类型，只要告诉内核要删除哪个 fd 即可，内核只需要 fd 值就能找到红黑树（下文会提到）中对应的节点并删除，传 nullptr 可以避免传递不必要的参数，提高效率。</p></blockquote><p><strong>返回值</strong>：</p><ul><li>成功：返回 0。</li><li>失败：返回 -1，同时设置 errno。</li></ul><p><strong>使用示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">epoll_event</span> ev;</span><br><span class="line">ev.events = EPOLLIN | EPOLLET;  <span class="comment">// 监听可读事件，使用边缘触发</span></span><br><span class="line">ev.data.fd = client_fd;         <span class="comment">// 将客户端fd保存到data中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加客户端fd到epoll监听列表</span></span><br><span class="line"><span class="type">int</span> ret = <span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_ADD, client_fd, &amp;ev);</span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">perror</span>(<span class="string">&quot;epoll_ctl add failed&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="5-epoll-wait-——-等待事件发生"><a href="#5-epoll-wait-——-等待事件发生" class="headerlink" title="5. epoll_wait —— 等待事件发生"></a>5. <code>epoll_wait</code> —— 等待事件发生</h2><p><strong>介绍</strong>：阻塞等待，直到有文件描述符上的事件发生，然后返回所有就绪的事件。</p><p><strong>函数原型：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event *events, <span class="type">int</span> maxevents, <span class="type">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>参数（结构体同上）</strong>：</p><ul><li><code>epfd</code>：<code>epoll_create</code> 返回的 epoll 文件描述符。</li><li><code>events</code>：指向 epoll_event 数组的指针，用于接收（内核返回）就绪的事件信息。</li><li><code>maxevents</code>：数组大小（能接收的最大就绪事件数）。</li><li><code>timeout</code>：超时&#x2F;最长等待时间（毫秒）。<ul><li><code>-1</code>：永久阻塞，直到有事件发生。</li><li><code>0</code>：非阻塞，立即返回。</li><li><code>&gt; 0</code>：最多等待 timeout 毫秒。</li></ul></li></ul><blockquote><p><strong>要点</strong>：</p><ul><li><code>events[i].data</code> 是你在 <code>epoll_ctl</code> 时设置的数据（常用来快速拿到对应的 fd 或连接结构体）。</li><li><code>epoll_wait</code> 返回后应遍历 <code>events</code> 数组并处理每个就绪项。</li><li><code>maxevents</code> 不应小于你预计一次处理的并发就绪数，通常设置为 64、128 或更大。</li></ul></blockquote><p><strong>返回值</strong>：</p><ul><li><code>&gt; 0</code>：返回就绪事件的数量（events [0..ret-1]）。</li><li><code>0</code>：超时（在指定时间内没有事件发生）。</li><li><code>-1</code>：出错，同时设置 errno。</li></ul><p><strong>使用示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_EVENTS 10</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">epoll_event</span> events[MAX_EVENTS];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待事件发生，最多返回10个就绪事件，超时时间为-1（永久等待）</span></span><br><span class="line"><span class="type">int</span> num_events = <span class="built_in">epoll_wait</span>(epfd, events, MAX_EVENTS, <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">if</span> (num_events == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">perror</span>(<span class="string">&quot;epoll_wait failed&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理所有就绪的事件</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_events; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd = events[i].data.fd;         <span class="comment">// 获取发生事件的文件描述符</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (events[i].events &amp; EPOLLIN)     <span class="comment">// 如果是可读事件</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 处理读操作</span></span><br><span class="line">        <span class="keyword">if</span> (fd == listen_fd)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 监听socket可读，说明有新连接</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 客户端socket可读，接收数据</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-epoll-的底层原理"><a href="#6-epoll-的底层原理" class="headerlink" title="6. epoll 的底层原理"></a>6. epoll 的底层原理</h2><p><code>epoll</code> 之所以比 <code>select</code>、<code>poll</code> 快、高效不是靠单一技术，而是 <strong>数据结构 + 算法 + 机制</strong> 的完美结合：它用了 <strong>“红黑树 + 就绪队列 + 回调机制”</strong> 这三样核心设计，让“监听谁”“谁就绪了”“怎么取结果”都高效完成，避免了反复轮询和复制。</p><h3 id="1-epoll-的三大核心组件"><a href="#1-epoll-的三大核心组件" class="headerlink" title="1. epoll 的三大核心组件"></a>1. epoll 的三大核心组件</h3><table><thead><tr><th>名称</th><th>数据结构</th><th>作用</th></tr></thead><tbody><tr><td><strong>红黑树 rbr</strong></td><td><code>struct rb_root rbr;</code></td><td>存放“我要关注哪些 fd、关心哪些事件”的集合（监控列表）</td></tr><tr><td><strong>就绪队列 rdlist</strong></td><td><code>struct list_head rdlist;</code></td><td>存放“已经就绪的 fd 事件”，等 <code>epoll_wait</code> 来取</td></tr><tr><td><strong>回调机制 ep_poll_callback</strong></td><td>函数指针</td><td>当设备驱动检测到某个 fd 就绪时自动触发，把它加入就绪队列</td></tr></tbody></table><ul><li><strong>红黑树（rbr）</strong>：存储要监听的所有文件描述符，就像“购物清单”，记录了所有要关注的商品（文件描述符），文件描述符天然作为红黑树的 key，查找速度很快 O(log n)，每次调用 <code>epoll_ctl</code> 就是在这张清单上增删改项目。</li><li><strong>就绪队列（rdlist）</strong>：存储已经就绪的文件描述符，就像“已到货通知单”，记录了哪些商品已经到了，可以取货，每次调用 <code>epoll_wait</code> 就是来取这张通知单。</li></ul><p>这三个东西组合在一起，就构成了一个完整的 epoll 模型（对应内核结构 <code>eventpoll</code>）。</p><h3 id="2-一个核心机制：回调-——-epoll-高效的-秘密武器！"><a href="#2-一个核心机制：回调-——-epoll-高效的-秘密武器！" class="headerlink" title="2. 一个核心机制：回调 —— epoll 高效的 秘密武器！"></a>2. 一个核心机制：回调 —— epoll 高效的 <strong>秘密武器</strong>！</h3><ul><li><strong>select&#x2F;poll 的问题：</strong> 程序问操作系统：”我关注的这些 fd，哪些有数据了？”，操作系统：”我一个一个帮你查一遍…”，每次都要遍历所有 fd，效率随 fd 数量增加而下降。</li><li><strong>epoll 的聪明做法</strong>：程序告诉操作系统：”我要关注这些 fd 的事件”，操作系统在内核里建立回调函数（ep_poll_callback），当网卡收到数据时，硬件直接通知内核：”fd 3 有数据了！”，内核自动调用回调函数，把 fd 3 从红黑树移到就绪队列，程序调用 <code>epoll_wait</code> 时，直接取就绪队列就行。</li></ul><p><strong>比喻理解：</strong> 想象你在网上购物：</p><ul><li><strong>select&#x2F;poll</strong>：你每隔几分钟就去快递点问：”我的包裹到了吗？”，快递员要查所有包裹。</li><li><strong>epoll</strong>：快递员有你的电话，包裹一到就给你打电话，你再过去取。</li></ul><h3 id="3-整体流程概览"><a href="#3-整体流程概览" class="headerlink" title="3. 整体流程概览"></a>3. 整体流程概览</h3><p>三个函数 <code>epoll_create</code>、<code>epoll_ctl</code>、<code>epoll_wait</code>，分别对应底层三个阶段：</p><table><thead><tr><th>用户函数</th><th>内核动作</th><th>对应的数据结构</th></tr></thead><tbody><tr><td><code>epoll_create</code></td><td>创建一个 <code>eventpoll</code> 实例</td><td>初始化红黑树 rbr、就绪队列 rdlist</td></tr><tr><td><code>epoll_ctl</code></td><td>把 fd 添加&#x2F;修改&#x2F;删除到红黑树</td><td>操作红黑树节点（每个节点是 epitem）</td></tr><tr><td><code>epoll_wait</code></td><td>等待就绪事件</td><td>从就绪队列里取出已经准备好的事件</td></tr></tbody></table><h3 id="4-内部关键对象：epitem"><a href="#4-内部关键对象：epitem" class="headerlink" title="4. 内部关键对象：epitem"></a>4. 内部关键对象：<code>epitem</code></h3><p>每一个通过 <code>epoll_ctl</code> 加入监听的 fd，内核都会创建一个对应的结构体 <code>epitem</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">epitem</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">rb_node</span> rbn;            <span class="comment">// 红黑树节点 (对应 epoll_ctl 增删改)</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">list_head</span> rdllink;      <span class="comment">// 链表节点 (对应就绪队列)</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_filefd</span> ffd;       <span class="comment">// 文件描述符信息</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">eventpoll</span> *ep;          <span class="comment">// 所属 epoll 实例</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> event;      <span class="comment">// 要监听的事件类型</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p><strong>可以理解为：红黑树节点：表示我关注了 fd 上的这些事件，就绪队列节点：表示 fd 上的事件真的发生了，ffd + event：是谁、关心什么。</strong></p></blockquote><h3 id="5-特殊处理"><a href="#5-特殊处理" class="headerlink" title="5. 特殊处理"></a>5. 特殊处理</h3><ul><li><strong>普通模式</strong>：事件就绪后，继续保留在红黑树中，下次还会通知。</li><li><strong>EPOLLONESHOT 模式</strong>：事件就绪后，会 <strong>自动从红黑树删除</strong>，想再次监听这个 fd，必须重新添加（调用 <code>epoll_ctl(ADD)</code>），常用于多线程模式，防止同一个 fd 被多个线程同时处理。</li><li><strong>EPOLLET（边沿触发）：</strong> 只在状态变化时通知一次，必须配合非阻塞 IO，否则可能漏事件，减少系统调用次数，进一步提升性能。</li></ul><h3 id="6-线程安全保障"><a href="#6-线程安全保障" class="headerlink" title="6. 线程安全保障"></a>6. 线程安全保障</h3><ul><li>就绪队列用互斥锁保护，多线程访问安全</li><li>等待队列处理多个线程同时访问的情况</li></ul><h3 id="7-为什么比-select-poll-高效？"><a href="#7-为什么比-select-poll-高效？" class="headerlink" title="7. 为什么比 select&#x2F;poll 高效？"></a>7. 为什么比 select&#x2F;poll 高效？</h3><ol><li><strong>O(1) 查找</strong>：红黑树保证添加&#x2F;删除操作是 O(log n)，比数组快。</li><li><strong>按需通知</strong>：只有事件真正发生时才通知，不需要轮询。</li><li><strong>批量处理</strong>：一次 <code>epoll_wait</code> 可以返回多个就绪事件。</li><li><strong>内存友好</strong>：只返回就绪的 fd，不是所有 fd。</li></ol><h2 id="7-代码示例（epoll-LT）"><a href="#7-代码示例（epoll-LT）" class="headerlink" title="7. 代码示例（epoll LT）"></a>7. 代码示例（epoll LT）</h2><blockquote><p><strong>完整代码请前往 <a href="https://github.com/huangcancan-xbc/Linux-Ubuntu/tree/main/Coding/Advanced_IO/epoll(LT)">GitHub</a> 查看。</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Socket.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;noCopy.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Epoller.hpp&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义epoll事件类型常量</span></span><br><span class="line"><span class="type">uint32_t</span> EVENT_IN = (EPOLLIN);                              <span class="comment">// 可读事件（EPOLLIN）</span></span><br><span class="line"><span class="type">uint32_t</span> EVENT_OUT = (EPOLLOUT);                            <span class="comment">// 可写事件（EPOLLOUT）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EpollServer</span> : <span class="keyword">public</span> noCopy                           <span class="comment">// 继承防拷贝基类，确保服务器对象不能被拷贝</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> num = <span class="number">64</span>;                              <span class="comment">// epoll_wait最多返回的事件数量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">EpollServer</span>(<span class="type">uint16_t</span> port)                              <span class="comment">// 构造函数，接收端口号</span></span><br><span class="line">        : _port(port),                                      <span class="comment">// 初始化端口号</span></span><br><span class="line">          _listsocket_ptr(<span class="keyword">new</span> <span class="built_in">Sock</span>()),                      <span class="comment">// 创建监听socket智能指针</span></span><br><span class="line">          _epoller_ptr(<span class="keyword">new</span> <span class="built_in">Epoller</span>())                       <span class="comment">// 创建epoller智能指针</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">EpollServer</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        _listsocket_ptr-&gt;<span class="built_in">Close</span>();                            <span class="comment">// 关闭监听socket</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _listsocket_ptr-&gt;<span class="built_in">Socket</span>();                           <span class="comment">// 创建socket</span></span><br><span class="line">        _listsocket_ptr-&gt;<span class="built_in">Bind</span>(_port);                        <span class="comment">// 绑定端口</span></span><br><span class="line">        _listsocket_ptr-&gt;<span class="built_in">Listen</span>();                           <span class="comment">// 开始监听</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">log_</span>(Info, <span class="string">&quot;create listen socket success! fd = %d&quot;</span>, _listsocket_ptr-&gt;<span class="built_in">Fd</span>()); <span class="comment">// 记录监听socket创建成功日志</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理新连接</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Accept</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::string client_ip;                               <span class="comment">// 存储客户端IP</span></span><br><span class="line">        <span class="type">uint16_t</span> client_port;                                <span class="comment">// 存储客户端端口</span></span><br><span class="line">        <span class="type">int</span> sockfd = _listsocket_ptr-&gt;<span class="built_in">Accept</span>(&amp;client_ip, &amp;client_port);             <span class="comment">// 接收新连接</span></span><br><span class="line">        <span class="keyword">if</span> (sockfd &gt; <span class="number">0</span>)                                      <span class="comment">// 如果接收连接成功</span></span><br><span class="line">        &#123;</span><br><span class="line">            _epoller_ptr-&gt;<span class="built_in">EpollerUpdate</span>(EPOLL_CTL_ADD, sockfd, EVENT_IN);           <span class="comment">// 将新连接的fd添加到epoll监听列表，监听可读事件</span></span><br><span class="line">            <span class="built_in">log_</span>(Info, <span class="string">&quot;获得一个新的连接：客户端说：%s:%d&quot;</span>, client_ip.<span class="built_in">c_str</span>(), client_port);    <span class="comment">// 记录新连接日志</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理数据接收</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Recver</span><span class="params">(<span class="type">int</span> fd)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">char</span> buffer[<span class="number">1024</span>];                                  <span class="comment">// 临时缓冲区，用于接收数据</span></span><br><span class="line">        <span class="type">int</span> n = <span class="built_in">read</span>(fd, buffer, <span class="built_in">sizeof</span>(buffer) - <span class="number">1</span>);       <span class="comment">// 从指定fd读取数据</span></span><br><span class="line">        <span class="keyword">if</span> (n &gt; <span class="number">0</span>)                                          <span class="comment">// 成功读取到数据</span></span><br><span class="line">        &#123;</span><br><span class="line">            buffer[n] = <span class="string">&#x27;\0&#x27;</span>;                               <span class="comment">// 添加字符串结束符</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;收到消息：&quot;</span> &lt;&lt; buffer &lt;&lt; std::endl;<span class="comment">// 输出收到的消息</span></span><br><span class="line"></span><br><span class="line">            std::string echo_str = <span class="string">&quot;Sverver echo # &quot;</span> + std::<span class="built_in">string</span>(buffer);     <span class="comment">// 构造回显消息</span></span><br><span class="line">            <span class="built_in">write</span>(fd, echo_str.<span class="built_in">c_str</span>(), echo_str.<span class="built_in">size</span>());   <span class="comment">// 将回显消息写回客户端</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">0</span>)                                    <span class="comment">// 客户端关闭连接（读到文件结束符）</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">log_</span>(Info, <span class="string">&quot;客户端断开连接: fd=%d&quot;</span>, fd);         <span class="comment">// 记录客户端断开连接日志</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;客户端断开连接&quot;</span> &lt;&lt; std::endl;      <span class="comment">// 输出断开连接信息</span></span><br><span class="line">            _epoller_ptr-&gt;<span class="built_in">EpollerUpdate</span>(EPOLL_CTL_DEL, fd, <span class="number">0</span>);      <span class="comment">// 从epoll监听列表中删除该fd</span></span><br><span class="line">            <span class="built_in">close</span>(fd);                                      <span class="comment">// 关闭该连接的文件描述符</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>                                                <span class="comment">// 读取数据出错</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">log_</span>(Error, <span class="string">&quot;read error: fd=%d&quot;</span>, fd);           <span class="comment">// 记录读取错误日志</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;read error&quot;</span> &lt;&lt; std::endl;         <span class="comment">// 输出错误信息</span></span><br><span class="line">            _epoller_ptr-&gt;<span class="built_in">EpollerUpdate</span>(EPOLL_CTL_DEL, fd, <span class="number">0</span>);      <span class="comment">// 从epoll监听列表中删除该fd</span></span><br><span class="line">            <span class="built_in">close</span>(fd);                                      <span class="comment">// 关闭该连接的文件描述符</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Dispatcher</span><span class="params">(<span class="keyword">struct</span> epoll_event revs[], <span class="type">int</span> num)</span>     <span class="comment">// 事件分发器，处理所有就绪的事件</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num; i++)                       <span class="comment">// 遍历所有就绪的事件</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">uint32_t</span> events = revs[i].events;               <span class="comment">// 获取事件类型</span></span><br><span class="line">            <span class="type">int</span> fd = revs[i].data.fd;                       <span class="comment">// 获取发生事件的文件描述符</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (events &amp; EVENT_IN)                          <span class="comment">// 如果是可读事件</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (fd == _listsocket_ptr-&gt;<span class="built_in">Fd</span>())            <span class="comment">// 如果是监听socket可读（有新连接）</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">Accept</span>();                               <span class="comment">// 处理新连接</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">Recver</span>(fd);                             <span class="comment">// 处理数据接收</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (events &amp; EVENT_OUT)                    <span class="comment">// 如果是可写事件</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 可写事件处理逻辑</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>                                            <span class="comment">// 其他事件</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 其他事件处理逻辑</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> <span class="built_in">Start</span>()                                            <span class="comment">// 启动服务器主循环</span></span><br><span class="line">    &#123;</span><br><span class="line">        _epoller_ptr-&gt;<span class="built_in">EpollerUpdate</span>(EPOLL_CTL_ADD, _listsocket_ptr-&gt;<span class="built_in">Fd</span>(), EVENT_IN);    <span class="comment">// 将监听socket添加到epoll监听列表</span></span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">epoll_event</span> revs[num];                       <span class="comment">// 创建epoll_event数组，用于接收就绪事件</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;)                                            <span class="comment">// 服务器无限循环</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> n = _epoller_ptr-&gt;<span class="built_in">EpollerWait</span>(revs, num);   <span class="comment">// 等待事件发生，最多返回num个事件</span></span><br><span class="line">            <span class="keyword">if</span> (n &gt; <span class="number">0</span>)                                      <span class="comment">// 有事件发生</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">log_</span>(Info, <span class="string">&quot;有事件已经就绪，开始处理……其文件描述符是：%d&quot;</span>, revs[<span class="number">0</span>].data.fd);<span class="comment">// 记录第一个就绪事件的fd</span></span><br><span class="line">                <span class="built_in">Dispatcher</span>(revs, n);                        <span class="comment">// 分发处理所有就绪的事件</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">0</span>)                                <span class="comment">// 超时（没有事件发生）</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">log_</span>(Info, <span class="string">&quot;timeout...&quot;</span>);                   <span class="comment">// 记录超时日志</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>                                            <span class="comment">// epoll_wait出错</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">log_</span>(Error, <span class="string">&quot;epoll_wait error!&quot;</span>);           <span class="comment">// 记录错误日志</span></span><br><span class="line">                <span class="comment">// break;                                   // 出错时可以选择退出循环</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::shared_ptr&lt;Sock&gt; _listsocket_ptr;                  <span class="comment">// 监听socket的智能指针</span></span><br><span class="line">    std::shared_ptr&lt;Epoller&gt; _epoller_ptr;                  <span class="comment">// Epoller对象的智能指针</span></span><br><span class="line">    <span class="type">uint16_t</span> _port;                                         <span class="comment">// 服务器端口号</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="8-epoll-的工作方式"><a href="#8-epoll-的工作方式" class="headerlink" title="8. epoll 的工作方式"></a>8. epoll 的工作方式</h2><h3 id="1-核心区别"><a href="#1-核心区别" class="headerlink" title="1. 核心区别"></a>1. 核心区别</h3><table><thead><tr><th>模式</th><th>触发时机</th><th>是否重复通知</th><th>是否必须非阻塞</th><th>实现复杂度</th><th><strong>通知频率</strong></th></tr></thead><tbody><tr><td><strong>LT（Level Triggered，epoll 的默认模式）</strong></td><td>只要内核缓冲区里有数据（高电平状态）</td><td>会 <strong>一直</strong> 通知</td><td>不强制，可阻塞或非阻塞</td><td>简单：可分多次处理事件</td><td>高（只要事件存在就反复通知）</td></tr><tr><td><strong>ET（Edge Triggered）</strong></td><td>只有“状态变化”时触发（从无到有&#x2F;有到多）</td><td>只通知一次</td><td><strong>必须</strong> 非阻塞（否则可能永久阻塞）</td><td>复杂：必须一次性处理完所有数据</td><td>低（仅状态变化时通知一次）</td></tr></tbody></table><p><strong>类比理解：</strong> 可以把内核数据缓冲区理解为“水桶”：</p><ul><li><strong>LT 模式：</strong> 只要桶里有水（数据没读完），内核就会一遍又一遍告诉你“有水！”，所以你可以慢慢舀，不急着一次读完。</li><li><strong>ET 模式：</strong> 只有桶第一次被装满、或者水又多了一点时，才会告诉你一次，之后不会再提醒。所以必须一次把水全舀光，否则漏掉的数据就永远没人告诉你了。</li></ul><p><strong>性能与设计取舍：</strong></p><table><thead><tr><th>对比项</th><th>LT</th><th>ET</th></tr></thead><tbody><tr><td>内核通知次数</td><td>多（每次都通知）</td><td>少（状态变化才通知）</td></tr><tr><td>CPU 开销</td><td>稍高</td><td>更低</td></tr><tr><td>编程难度</td><td>简单</td><td>较高</td></tr><tr><td>安全性</td><td>容错性强（可多次处理）</td><td>容错性低（必须彻底处理）</td></tr><tr><td>实际应用</td><td>select、poll 属于 LT</td><td>Nginx、Redis 使用 ET</td></tr></tbody></table><h3 id="2-ET-模式的编程要点"><a href="#2-ET-模式的编程要点" class="headerlink" title="2. ET 模式的编程要点"></a>2. ET 模式的编程要点</h3><ol><li><p><strong>必须设置非阻塞：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> flags = <span class="built_in">fcntl</span>(fd, F_GETFL, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">fcntl</span>(fd, F_SETFL, flags | O_NONBLOCK);</span><br></pre></td></tr></table></figure></li><li><p><strong>循环读写直到返回错误：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">ssize_t</span> n = <span class="built_in">recv</span>(fd, buf, <span class="built_in">sizeof</span>(buf), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (errno == EAGAIN || errno == EWOULDBLOCK)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// 读完</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;recv error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 对端关闭</span></span><br><span class="line">        <span class="built_in">close</span>(fd);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 正常读取</span></span><br><span class="line">        <span class="built_in">process</span>(buf, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写同理，循环 send，直到 EAGAIN</span></span><br></pre></td></tr></table></figure></li><li><p><strong>注册事件时带上 <code>EPOLLET</code>：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">epoll_event ev;</span><br><span class="line">ev.data.fd = fd;</span><br><span class="line">ev.events = EPOLLIN | EPOLLET;</span><br><span class="line"><span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_ADD, fd, &amp;ev);</span><br></pre></td></tr></table></figure></li></ol><hr><h3 id="3-疑难解答"><a href="#3-疑难解答" class="headerlink" title="3. 疑难解答"></a>3. 疑难解答</h3><h4 id="1-LT-模式下，如果我把-fd-设为非阻塞，并在第一次通知时就循环读完所有数据，那和-ET-有什么区别？"><a href="#1-LT-模式下，如果我把-fd-设为非阻塞，并在第一次通知时就循环读完所有数据，那和-ET-有什么区别？" class="headerlink" title="1. LT 模式下，如果我把 fd 设为非阻塞，并在第一次通知时就循环读完所有数据，那和 ET 有什么区别？"></a>1. LT 模式下，如果我把 fd 设为非阻塞，并在第一次通知时就循环读完所有数据，那和 ET 有什么区别？</h4><p><strong>逻辑行为上几乎一样，性能也接近</strong>。但 LT 模式仍有“条件判断 + 冗余通知”的系统开销，ET 是内核级别的“只在状态变化时触发”，性能更纯粹：</p><ul><li>LT 仍然会“准备通知”，但因为你已经清空了缓冲区，所以下次 <code>epoll_wait</code> 不会再返回该 fd。</li><li>但 LT 仍保留“兜底”能力：万一你漏读了，下次还会提醒你。</li><li>所以：<strong>ET 的优势不是“必须更快”，而是“强制你写出高效代码”</strong>。</li></ul><blockquote><p>  实际上，<strong>高性能服务器（如 Redis、Nginx）选择 ET，是为了避免“意外的重复通知”带来的开销</strong>，尤其是在连接数极高的场景。 </p></blockquote><h4 id="2-为什么-ET-必须用非阻塞-IO？"><a href="#2-为什么-ET-必须用非阻塞-IO？" class="headerlink" title="2. 为什么 ET 必须用非阻塞 IO？"></a>2. 为什么 ET 必须用非阻塞 IO？</h4><p>因为 ET 要求你 <strong>一次性读完所有数据</strong>。如果使用阻塞 IO，当你读到最后一次（缓冲区已空），<code>recv</code> 会 <strong>永远阻塞</strong>，因为没有新数据到来，epoll 也不会再通知你。非阻塞 IO 在无数据时立即返回 <code>-1</code> 并设置 <code>errno = EAGAIN</code>，让你知道“本次数据已读完”。</p><h4 id="3-ET-模式真的更高效吗？"><a href="#3-ET-模式真的更高效吗？" class="headerlink" title="3. ET 模式真的更高效吗？"></a>3. ET 模式真的更高效吗？</h4><p><strong>在特定条件下是的</strong>：</p><ul><li><strong>减少 epoll_wait 的唤醒次数</strong> → 降低系统调用开销。</li><li><strong>促使应用层批量处理数据</strong> → 更好的 cache locality 和吞吐。</li><li><strong>TCP 窗口优化</strong>：当接收方快速消费数据（ET 强制你这么做），TCP 接收窗口更大，发送方可以一次发更多数据，减少小包和 ACK 开销。</li></ul><p><strong>注意：如果 ET 实现不当（如漏读、未设非阻塞），反而会导致连接“假死”，比 LT 更危险。</strong></p><h2 id="9-代码示例（epoll-ET）"><a href="#9-代码示例（epoll-ET）" class="headerlink" title="9. 代码示例（epoll ET）"></a>9. 代码示例（epoll ET）</h2><blockquote><p><strong>完整代码请前往 <a href="https://github.com/huangcancan-xbc/Linux-Ubuntu/tree/main/Coding/Advanced_IO/epoll(ET)">GitHub</a> 查看。</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cerrno&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Log.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;noCopy.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Epoller.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Socket.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Comm.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 前向声明Connection和TcpServer类，避免循环包含</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Connection</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TcpServer</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> EVENT_IN = (EPOLLIN | EPOLLET);            <span class="comment">// 定义读事件掩码（EPOLLIN | EPOLLET）</span></span><br><span class="line"><span class="type">uint32_t</span> EVENT_OUT = (EPOLLOUT | EPOLLET);          <span class="comment">// 定义写事件掩码（EPOLLOUT | EPOLLET）</span></span><br><span class="line"><span class="type">const</span> <span class="type">static</span> <span class="type">int</span> g_buffer_size = <span class="number">1024</span>;              <span class="comment">// 定义缓冲区大小为1024字节</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// using func_t = std::function&lt;void(std::shared_ptr&lt;Connection&gt;)&gt;;</span></span><br><span class="line"><span class="keyword">using</span> <span class="type">func_t</span> = std::function&lt;<span class="built_in">void</span>(std::weak_ptr&lt;Connection&gt;)&gt;;      <span class="comment">// 定义回调函数类型，参数为weak_ptr类型的连接对象</span></span><br><span class="line"><span class="keyword">using</span> except_func = std::function&lt;<span class="built_in">void</span>(std::weak_ptr&lt;Connection&gt;)&gt;; <span class="comment">// 定义异常处理函数类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Connection类：管理单个客户端连接</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Connection</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数，接收socket文件描述符</span></span><br><span class="line">    <span class="comment">// Connection(int sock, std::shared_ptr&lt;TcpServer&gt; tcp_server_ptr)</span></span><br><span class="line">    <span class="comment">//     : _sock(sock),</span></span><br><span class="line">    <span class="comment">//     _tcp_server_ptr(tcp_server_ptr)</span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="built_in">Connection</span>(<span class="type">int</span> sock)</span><br><span class="line">        : _sock(sock)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置连接的回调函数</span></span><br><span class="line">    <span class="comment">// void SetHandler(func_t recv_cb, func_t send_cb, func_t except_cb)</span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">//     _recv_cb = recv_cb;</span></span><br><span class="line">    <span class="comment">//     _send_cb = send_cb;</span></span><br><span class="line">    <span class="comment">//     _except_cb = except_cb;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetHandler</span><span class="params">(<span class="type">func_t</span> recv_cb, <span class="type">func_t</span> send_cb, except_func except_cb)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _recv_cb = recv_cb;</span><br><span class="line">        _send_cb = send_cb;</span><br><span class="line">        _except_cb = except_cb;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取socket文件描述符</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">SockFd</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _sock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向输入缓冲区追加数据</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AppendInBuffer</span><span class="params">(<span class="type">const</span> std::string&amp; data)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _inbuffer += data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向输出缓冲区追加数据</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AppendOutBuffer</span><span class="params">(<span class="type">const</span> std::string&amp; info)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _outbuffer += info;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// const std::string&amp; Inbuffer()</span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">//     return _inbuffer;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// 获取输入缓冲区的引用</span></span><br><span class="line">    <span class="function">std::string&amp; <span class="title">Inbuffer</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _inbuffer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取输出缓冲区的引用</span></span><br><span class="line">    <span class="function">std::string&amp; <span class="title">OutBuffer</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _outbuffer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置指向TCP服务器的弱引用指针</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetWeakPtr</span><span class="params">(std::weak_ptr&lt;TcpServer&gt; tcp_server_ptr)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _tcp_server_ptr = tcp_server_ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Connection</span>()</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _sock;                      <span class="comment">// socket文件描述符</span></span><br><span class="line">    std::string _inbuffer;          <span class="comment">// 输入缓冲区</span></span><br><span class="line">    std::string _outbuffer;         <span class="comment">// 输出缓冲区</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">func_t</span> _recv_cb;                <span class="comment">// 读回调函数</span></span><br><span class="line">    <span class="type">func_t</span> _send_cb;                <span class="comment">// 写回调函数</span></span><br><span class="line">    <span class="comment">// func_t _except_cb;</span></span><br><span class="line">    except_func _except_cb;         <span class="comment">// 异常回调函数</span></span><br><span class="line"></span><br><span class="line">    std::weak_ptr&lt;TcpServer&gt; _tcp_server_ptr;   <span class="comment">// 指向TCP服务器的弱引用</span></span><br><span class="line">    std::string _ip;                <span class="comment">// 客户端IP地址</span></span><br><span class="line">    <span class="type">uint16_t</span> _port;                 <span class="comment">// 客户端端口号</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// TcpServer类：TCP服务器主类，支持epoll事件驱动</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TcpServer</span> : <span class="keyword">public</span> std::enable_shared_from_this&lt;TcpServer&gt;, <span class="keyword">public</span> noCopy</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> num = <span class="number">64</span>;      <span class="comment">// 定义epoll事件数组大小为64</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TcpServer</span>(<span class="type">uint16_t</span> port, <span class="type">func_t</span> OnMessage)          <span class="comment">// 构造函数，接收端口号和消息处理函数</span></span><br><span class="line">        : _port(port),                                  <span class="comment">// 服务器端口号</span></span><br><span class="line">        _OnMessage(OnMessage),                          <span class="comment">// 消息处理函数</span></span><br><span class="line">        _quit(<span class="literal">true</span>),                                    <span class="comment">// 退出标志</span></span><br><span class="line">        _epoller_ptr(<span class="keyword">new</span> <span class="built_in">Epoller</span>()),                    <span class="comment">// epoll对象指针</span></span><br><span class="line">        _listensock_ptr(<span class="keyword">new</span> <span class="built_in">Sock</span>())                     <span class="comment">// 监听socket对象指针</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">()</span>                     <span class="comment">// 初始化服务器</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _listensock_ptr-&gt;<span class="built_in">Socket</span>();  <span class="comment">// 创建socket</span></span><br><span class="line">        <span class="built_in">SetNonBlockOrDie</span>(_listensock_ptr-&gt;<span class="built_in">Fd</span>());        <span class="comment">// 设置为非阻塞模式</span></span><br><span class="line">        _listensock_ptr-&gt;<span class="built_in">Bind</span>(_port);   <span class="comment">// 绑定端口</span></span><br><span class="line">        _listensock_ptr-&gt;<span class="built_in">Listen</span>();  <span class="comment">// 开始监听</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// log_(Info, &quot;创建listen socket成功，fd：&quot;, _listensock_ptr-&gt;Fd());</span></span><br><span class="line">        <span class="built_in">log_</span>(Info, <span class="string">&quot;TCP服务器初始化成功，监听端口: %d, listen socket fd: %d&quot;</span>, _port, _listensock_ptr-&gt;<span class="built_in">Fd</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将监听socket添加到epoll中，设置读事件回调</span></span><br><span class="line">        <span class="built_in">AddConnection</span>(_listensock_ptr-&gt;<span class="built_in">Fd</span>(), EVENT_IN, std::<span class="built_in">bind</span>(&amp;TcpServer::Accepter, <span class="keyword">this</span>, std::placeholders::_1), <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// void AddConnection(int sockfd, uint32_t event, func_t recv_cb, func_t send_cb, func_t except_cb, const std::string &amp;ip = &quot;0.0.0.0&quot;, uint16_t port = 0)</span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">//     // std::shared_ptr&lt;Connection&gt; new_connection=std::make_shared&lt;Connection&gt;(sockfd, std::shared_ptr&lt;TcpServer&gt;(this));</span></span><br><span class="line">    <span class="comment">//     std::shared_ptr&lt;Connection&gt; new_connection = std::make_shared&lt;Connection&gt;(sockfd, std::shared_ptr&lt;TcpServer&gt;(this));</span></span><br><span class="line">    <span class="comment">//     new_connection-&gt;SetHandler(recv_cb, send_cb, except_cb);</span></span><br><span class="line">    <span class="comment">//     new_connection-&gt;_ip=ip;</span></span><br><span class="line">    <span class="comment">//     new_connection-&gt;_port=port;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//     _connections.insert(std::make_pair(sockfd, new_connection));</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//     _epoller_ptr-&gt;EpollerUpdate(EPOLL_CTL_ADD, sockfd, event);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//     log_(Debug, &quot;添加一个新的连接，fd：&quot;, sockfd);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// 添加连接到服务器</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AddConnection</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">uint32_t</span> event, <span class="type">func_t</span> recv_cb, <span class="type">func_t</span> send_cb, except_func except_cb, <span class="type">const</span> std::string&amp; ip = <span class="string">&quot;0.0.0.0&quot;</span>, <span class="type">uint16_t</span> port = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::shared_ptr&lt;Connection&gt; <span class="title">new_connection</span><span class="params">(<span class="keyword">new</span> Connection(sockfd))</span></span>;     <span class="comment">// 创建新的连接对象</span></span><br><span class="line">        new_connection-&gt;<span class="built_in">SetWeakPtr</span>(<span class="built_in">shared_from_this</span>());                         <span class="comment">// 设置连接对象对服务器的弱引用</span></span><br><span class="line">        new_connection-&gt;<span class="built_in">SetHandler</span>(recv_cb, send_cb, except_cb);                <span class="comment">// 设置连接的回调函数</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置客户端IP和端口</span></span><br><span class="line">        new_connection-&gt;_ip = ip;</span><br><span class="line">        new_connection-&gt;_port = port;</span><br><span class="line"></span><br><span class="line">        _connections.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(sockfd, new_connection));            <span class="comment">// 将连接添加到连接映射表中</span></span><br><span class="line"></span><br><span class="line">        _epoller_ptr-&gt;<span class="built_in">EpollerUpdate</span>(EPOLL_CTL_ADD, sockfd, event);              <span class="comment">// 将socket添加到epoll监控列表中</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">log_</span>(Debug, <span class="string">&quot;成功添加新连接，fd: %d, 客户端IP: %s, 客户端端口: %d&quot;</span>, sockfd, ip.<span class="built_in">c_str</span>(), port);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 链接管理器</span></span><br><span class="line">    <span class="comment">// void Accepter(std::shared_ptr&lt;Connection&gt; connection)</span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">//     while (true)</span></span><br><span class="line">    <span class="comment">//     &#123;</span></span><br><span class="line">    <span class="comment">//         struct sockaddr_in peer;</span></span><br><span class="line">    <span class="comment">//         socklen_t len = sizeof(peer);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//         int sockfd = ::accept(connection-&gt;SockFd(), (struct sockaddr*)&amp;peer, &amp;len);</span></span><br><span class="line">    <span class="comment">//         if (sockfd &gt; 0)</span></span><br><span class="line">    <span class="comment">//         &#123;</span></span><br><span class="line">    <span class="comment">//             uint16_t peer_port = ntohs(peer.sin_port);</span></span><br><span class="line">    <span class="comment">//             char ipbuf[128];</span></span><br><span class="line">    <span class="comment">//             inet_ntop(AF_INET, &amp;peer.sin_addr.s_addr, ipbuf, sizeof(ipbuf));</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//             log_(Debug, &quot;收到一个新的客户端连接，得到的消息：[%s:%d], sockfd：%d&quot;, ipbuf, peer_port, sockfd);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//             SetNonBlockOrDie(sockfd);</span></span><br><span class="line">    <span class="comment">//             // listensock只需要设置_recv_cb，其他sock，读，写，异常都设置</span></span><br><span class="line">    <span class="comment">//             // AddConnection(sockfd, EVENT_IN, nullptr, nullptr, nullptr);</span></span><br><span class="line">    <span class="comment">//             AddConnection(sockfd, EVENT_IN, std::bind(&amp;TcpServer::Recver, this, std::placeholders::_1), std::bind(&amp;TcpServer::Sender, this, std::placeholders::_1), std::bind(&amp;TcpServer::Excepter, this, std::placeholders::_1), ipbuf, peer_port);</span></span><br><span class="line">    <span class="comment">//         &#125;</span></span><br><span class="line">    <span class="comment">//         else</span></span><br><span class="line">    <span class="comment">//         &#123;</span></span><br><span class="line">    <span class="comment">//             if (errno == EWOULDBLOCK)</span></span><br><span class="line">    <span class="comment">//             &#123;</span></span><br><span class="line">    <span class="comment">//                 break;</span></span><br><span class="line">    <span class="comment">//             &#125;</span></span><br><span class="line">    <span class="comment">//             else if (errno == EINTR)</span></span><br><span class="line">    <span class="comment">//             &#123;</span></span><br><span class="line">    <span class="comment">//                 continue;</span></span><br><span class="line">    <span class="comment">//             &#125;</span></span><br><span class="line">    <span class="comment">//             else</span></span><br><span class="line">    <span class="comment">//             &#123;</span></span><br><span class="line">    <span class="comment">//                 break;</span></span><br><span class="line">    <span class="comment">//             &#125;</span></span><br><span class="line">    <span class="comment">//         &#125;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接受新连接的处理函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Accepter</span><span class="params">(std::weak_ptr&lt;Connection&gt; connection)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> connection_ptr = connection.<span class="built_in">lock</span>();                <span class="comment">// 将weak_ptr转换为shared_ptr以安全访问连接对象</span></span><br><span class="line">        <span class="keyword">if</span> (!connection_ptr)                                    <span class="comment">// 检查转换是否成功</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// log_(Warning, &quot;无法获取连接对象指针，可能已被销毁&quot;);</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> peer;</span><br><span class="line">            <span class="type">socklen_t</span> len = <span class="built_in">sizeof</span>(peer);</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> sockfd = ::<span class="built_in">accept</span>(connection_ptr-&gt;<span class="built_in">SockFd</span>(), (<span class="keyword">struct</span> sockaddr*)&amp;peer, &amp;len);         <span class="comment">// 接受新的客户端连接</span></span><br><span class="line">            <span class="keyword">if</span> (sockfd &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">uint16_t</span> peer_port = <span class="built_in">ntohs</span>(peer.sin_port);</span><br><span class="line">                <span class="type">char</span> ipbuf[<span class="number">128</span>];</span><br><span class="line">                <span class="built_in">inet_ntop</span>(AF_INET, &amp;peer.sin_addr.s_addr, ipbuf, <span class="built_in">sizeof</span>(ipbuf));</span><br><span class="line"></span><br><span class="line">                <span class="comment">// log_(Debug, &quot;收到一个新的客户端连接，得到的消息：[%s:%d], sockfd：%d&quot;, ipbuf, peer_port, sockfd);</span></span><br><span class="line">                <span class="built_in">log_</span>(Info, <span class="string">&quot;收到新的客户端连接，客户端IP: %s, 客户端端口: %d, 连接fd: %d&quot;</span>, ipbuf, peer_port, sockfd);</span><br><span class="line"></span><br><span class="line">                <span class="built_in">SetNonBlockOrDie</span>(sockfd);       <span class="comment">// 设置新连接为非阻塞模式</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 为新连接添加到服务器管理中，设置各种回调函数</span></span><br><span class="line">                <span class="built_in">AddConnection</span>(sockfd, EVENT_IN,</span><br><span class="line">                    std::<span class="built_in">bind</span>(&amp;TcpServer::Recver, <span class="keyword">this</span>, std::placeholders::_1),</span><br><span class="line">                    std::<span class="built_in">bind</span>(&amp;TcpServer::Sender, <span class="keyword">this</span>, std::placeholders::_1),</span><br><span class="line">                    std::<span class="built_in">bind</span>(&amp;TcpServer::Excepter, <span class="keyword">this</span>, std::placeholders::_1),</span><br><span class="line">                    ipbuf, peer_port);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (errno == EWOULDBLOCK)       <span class="comment">// 处理accept返回错误的情况</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;                      <span class="comment">// 没有更多连接，退出循环</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (errno == EINTR)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;                   <span class="comment">// 被信号中断，继续循环</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">log_</span>(Error, <span class="string">&quot;accept调用失败，错误码: %d, 错误信息: %s&quot;</span>, errno, <span class="built_in">strerror</span>(errno));</span><br><span class="line">                    <span class="keyword">break</span>;                      <span class="comment">// 其他错误，退出循环</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 事件管理器</span></span><br><span class="line">    <span class="comment">// void Recver(std::shared_ptr&lt;Connection&gt; connection)</span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">//     // std::cout &lt;&lt; &quot;haha, got you!!!, sockfd:&quot; &lt;&lt; connection-&gt;SockFd() &lt;&lt; std::endl;</span></span><br><span class="line">    <span class="comment">//     int sockfd = connection-&gt;SockFd();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//     while(true)</span></span><br><span class="line">    <span class="comment">//     &#123;</span></span><br><span class="line">    <span class="comment">//         char buffer[g_buffer_size];</span></span><br><span class="line">    <span class="comment">//         memset(buffer, 0, sizeof(buffer));</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//         ssize_t n = recv(sockfd, buf, sizeof(buffer) - 1, 0);</span></span><br><span class="line">    <span class="comment">//         if (n &gt; 0)</span></span><br><span class="line">    <span class="comment">//         &#123;</span></span><br><span class="line">    <span class="comment">//             connection-&gt;Append(buffer);</span></span><br><span class="line">    <span class="comment">//         &#125;</span></span><br><span class="line">    <span class="comment">//         else if(n == 0)</span></span><br><span class="line">    <span class="comment">//         &#123;</span></span><br><span class="line">    <span class="comment">//             log_(Debug,&quot;客户端断开连接，&quot; ,sockfd,  connection-&gt;_ip.c_str(),connection-&gt;_port);</span></span><br><span class="line">    <span class="comment">//             connection-&gt;excepter(connection);</span></span><br><span class="line">    <span class="comment">//         &#125;</span></span><br><span class="line">    <span class="comment">//         else</span></span><br><span class="line">    <span class="comment">//         &#123;</span></span><br><span class="line">    <span class="comment">//             if (errno ==EWOULDBLOCK)</span></span><br><span class="line">    <span class="comment">//             &#123;</span></span><br><span class="line">    <span class="comment">//                 break;</span></span><br><span class="line">    <span class="comment">//             &#125;</span></span><br><span class="line">    <span class="comment">//             else if (errno == EINTR)</span></span><br><span class="line">    <span class="comment">//             &#123;</span></span><br><span class="line">    <span class="comment">//                 continue;</span></span><br><span class="line">    <span class="comment">//             &#125;</span></span><br><span class="line">    <span class="comment">//             else</span></span><br><span class="line">    <span class="comment">//             &#123;</span></span><br><span class="line">    <span class="comment">//                 log_(Warning,&quot;sockfd: %d,客户端断开连接，errno: %d&quot;,fd,connection-&gt;_ip.c_str(),connection-&gt;_port);</span></span><br><span class="line">    <span class="comment">//                 connection-&gt;excepter(connection);</span></span><br><span class="line">    <span class="comment">//                 break;</span></span><br><span class="line">    <span class="comment">//             &#125;</span></span><br><span class="line">    <span class="comment">//         &#125;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//     OnMessage(connection);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收数据的处理函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Recver</span><span class="params">(std::weak_ptr&lt;Connection&gt; connection)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (connection.<span class="built_in">expired</span>())           <span class="comment">// 检查连接对象是否已经过期</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// log_(Warning, &quot;连接对象已过期，无法处理接收事件&quot;);</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将weak_ptr转换为shared_ptr以安全访问连接对象</span></span><br><span class="line">        <span class="keyword">auto</span> connection_ptr = connection.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="type">int</span> sockfd = connection_ptr-&gt;<span class="built_in">SockFd</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">char</span> buffer[g_buffer_size];</span><br><span class="line">            <span class="built_in">memset</span>(buffer, <span class="number">0</span>, <span class="built_in">sizeof</span>(buffer));</span><br><span class="line"></span><br><span class="line">            <span class="type">ssize_t</span> n = <span class="built_in">recv</span>(sockfd, buffer, <span class="built_in">sizeof</span>(buffer) - <span class="number">1</span>, <span class="number">0</span>);    <span class="comment">// 从socket接收数据</span></span><br><span class="line">            <span class="keyword">if</span> (n &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                connection_ptr-&gt;<span class="built_in">AppendInBuffer</span>(buffer);         <span class="comment">// 接收到数据，添加到输入缓冲区</span></span><br><span class="line">                <span class="built_in">log_</span>(Debug, <span class="string">&quot;从客户端fd: %d 接收到 %ld 字节数据&quot;</span>, sockfd, n);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">0</span>)                                    <span class="comment">// 客户端关闭连接</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// log_(Debug, &quot;sockfd: %d,客户端消息：%s : %d断开连接(退出)&quot;, sockfd, connection_ptr-&gt;_ip.c_str(), connection_ptr-&gt;_port);</span></span><br><span class="line">                <span class="built_in">log_</span>(Info, <span class="string">&quot;客户端fd: %d (IP: %s, 端口: %d) 主动断开连接&quot;</span>, sockfd, connection_ptr-&gt;_ip.<span class="built_in">c_str</span>(), connection_ptr-&gt;_port);</span><br><span class="line">                connection_ptr-&gt;_except_cb(connection_ptr);     <span class="comment">// 调用异常回调函数处理连接断开</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (errno == EWOULDBLOCK)                       <span class="comment">// 处理接收错误</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// log_(Debug, &quot;客户端fd: %d 数据接收完毕&quot;, sockfd);</span></span><br><span class="line">                    <span class="keyword">break</span>;                                      <span class="comment">// 没有更多数据可读，退出循环</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (errno == EINTR)                        <span class="comment">// 被信号中断，继续循环</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>                                            <span class="comment">// 其他错误</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// log_(Warning, &quot;sockfd: %d,客户端信息：%s : %d接收错误&quot;, sockfd, connection_ptr-&gt;_ip.c_str(), connection_ptr-&gt;_port);</span></span><br><span class="line">                    <span class="built_in">log_</span>(Error, <span class="string">&quot;从客户端fd: %d 接收数据失败，错误码: %d, 错误信息: %s&quot;</span>, sockfd, errno, <span class="built_in">strerror</span>(errno));</span><br><span class="line">                    connection_ptr-&gt;_except_cb(connection_ptr);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        _OnMessage(connection_ptr);                             <span class="comment">// 调用上层消息处理函数处理接收到的数据</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送数据的处理函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Sender</span><span class="params">(std::weak_ptr&lt;Connection&gt; connection)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (connection.<span class="built_in">expired</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// log_(Warning, &quot;连接对象已过期，无法处理发送事件&quot;);</span></span><br><span class="line">            <span class="keyword">return</span>;             <span class="comment">// 检查连接对象是否已经过期</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将weak_ptr转换为shared_ptr以安全访问连接对象</span></span><br><span class="line">        <span class="keyword">auto</span> connection_ptr = connection.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="keyword">auto</span>&amp; outbuffer = connection_ptr-&gt;<span class="built_in">OutBuffer</span>();</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 发送数据到客户端</span></span><br><span class="line">            <span class="type">ssize_t</span> n = <span class="built_in">send</span>(connection_ptr-&gt;<span class="built_in">SockFd</span>(), outbuffer.<span class="built_in">c_str</span>(), outbuffer.<span class="built_in">size</span>(), <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (n &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// log_(Debug, &quot;向客户端fd: %d 成功发送 %ld 字节数据&quot;, connection_ptr-&gt;SockFd(), n);</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 成功发送部分数据，从输出缓冲区中删除已发送的数据</span></span><br><span class="line">                outbuffer.<span class="built_in">erase</span>(<span class="number">0</span>, n);</span><br><span class="line">                <span class="keyword">if</span> (outbuffer.<span class="built_in">empty</span>())</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// log_(Debug, &quot;客户端fd: %d 输出缓冲区已清空&quot;, connection_ptr-&gt;SockFd());</span></span><br><span class="line">                    <span class="keyword">break</span>;                  <span class="comment">// 缓冲区清空，退出循环</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// log_(Debug, &quot;向客户端fd: %d 发送0字节数据&quot;, connection_ptr-&gt;SockFd());</span></span><br><span class="line">                <span class="keyword">return</span>;                     <span class="comment">// 发送0字节，退出</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 处理发送错误</span></span><br><span class="line">                <span class="keyword">if</span> (errno == EWOULDBLOCK)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">log_</span>(Debug, <span class="string">&quot;客户端fd: %d socket发送缓冲区已满，等待下次发送&quot;</span>, connection_ptr-&gt;<span class="built_in">SockFd</span>());</span><br><span class="line">                    <span class="keyword">break</span>;                  <span class="comment">// socket缓冲区满，退出循环</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (errno == EINTR)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;               <span class="comment">// 被信号中断，继续循环</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>                        <span class="comment">// 其他错误</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// log_(Warning, &quot;sockfd: %d, 客户端消息： %s : %d 发送错误&quot;, connection_ptr-&gt;SockFd(), connection_ptr-&gt;_ip.c_str(), connection_ptr-&gt;_port);</span></span><br><span class="line">                    <span class="built_in">log_</span>(Error, <span class="string">&quot;向客户端fd: %d 发送数据失败，错误码: %d, 错误信息: %s&quot;</span>, connection_ptr-&gt;<span class="built_in">SockFd</span>(), errno, <span class="built_in">strerror</span>(errno));</span><br><span class="line">                    connection_ptr-&gt;_except_cb(connection_ptr);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!outbuffer.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 开启对写事件的关心</span></span><br><span class="line">            <span class="built_in">EnableEvent</span>(connection_ptr-&gt;<span class="built_in">SockFd</span>(), <span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line">            <span class="comment">// log_(Debug, &quot;为客户端fd: %d 启用写事件监控&quot;, connection_ptr-&gt;SockFd());</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 关闭对写事件的关心</span></span><br><span class="line">            <span class="built_in">EnableEvent</span>(connection_ptr-&gt;<span class="built_in">SockFd</span>(), <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">            <span class="comment">// log_(Debug, &quot;为客户端fd: %d 禁用写事件监控&quot;, connection_ptr-&gt;SockFd());</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异常处理函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Excepter</span><span class="params">(std::weak_ptr&lt;Connection&gt; connection)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (connection.<span class="built_in">expired</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// log_(Warning, &quot;连接对象已过期，无法处理异常事件&quot;);</span></span><br><span class="line">            <span class="keyword">return</span>;             <span class="comment">// 检查连接对象是否已经过期</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> conn = connection.<span class="built_in">lock</span>();          <span class="comment">// 将weak_ptr转换为shared_ptr以安全访问连接对象</span></span><br><span class="line">        <span class="keyword">if</span> (!conn)                              <span class="comment">// 检查转换是否成功</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// log_(Warning, &quot;无法获取连接对象指针，可能已被销毁&quot;);</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> fd = conn-&gt;<span class="built_in">SockFd</span>();</span><br><span class="line">        <span class="comment">// log_(Warning, &quot;异常处理程序套接字文件描述符: %d, 客户端消息：%s : %d 异常退出&quot;, conn-&gt;SockFd(), conn-&gt;_ip.c_str(), conn-&gt;_port);</span></span><br><span class="line">        <span class="built_in">log_</span>(Warning, <span class="string">&quot;处理异常连接，fd: %d, 客户端IP: %s, 客户端端口: %d&quot;</span>, conn-&gt;<span class="built_in">SockFd</span>(), conn-&gt;_ip.<span class="built_in">c_str</span>(), conn-&gt;_port);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 1. 移除对特定fd的关心</span></span><br><span class="line">        <span class="comment">// EnableEvent(connection-&gt;SockFd(), false, false);</span></span><br><span class="line">        _epoller_ptr-&gt;<span class="built_in">EpollerUpdate</span>(EPOLL_CTL_DEL, fd, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 2. 关闭异常的文件描述符</span></span><br><span class="line">        <span class="built_in">log_</span>(Debug, <span class="string">&quot;关闭异常连接的文件描述符: %d&quot;</span>, fd);</span><br><span class="line">        <span class="built_in">close</span>(fd);</span><br><span class="line">        <span class="comment">// 3. 从unordered_map中(连接映射表中)移除</span></span><br><span class="line">        <span class="built_in">log_</span>(Debug, <span class="string">&quot;从连接管理器中移除异常连接: %d&quot;</span>, fd);</span><br><span class="line"></span><br><span class="line">        _connections.<span class="built_in">erase</span>(fd);</span><br><span class="line">        <span class="built_in">log_</span>(Info, <span class="string">&quot;异常连接处理完成，fd: %d&quot;</span>, fd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启用或禁用socket的读写事件监控</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">EnableEvent</span><span class="params">(<span class="type">int</span> sock, <span class="type">bool</span> readable, <span class="type">bool</span> writeable)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">uint32_t</span> events = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据参数设置事件掩码</span></span><br><span class="line">        events |= ((readable ? EPOLLIN : <span class="number">0</span>) | (writeable ? EPOLLOUT : <span class="number">0</span>) | EPOLLET);</span><br><span class="line">        _epoller_ptr-&gt;<span class="built_in">EpollerUpdate</span>(EPOLL_CTL_MOD, sock, events);</span><br><span class="line">        <span class="comment">// log_(Debug, &quot;更新socket: %d 的事件监控，可读: %s, 可写: %s&quot;, sock, readable ? &quot;是&quot; : &quot;否&quot;, writeable ? &quot;是&quot; : &quot;否&quot;);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查指定的socket文件描述符是否在服务器管理中</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">IsConnectionSafe</span><span class="params">(<span class="type">int</span> sockfd)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> iter = _connections.<span class="built_in">find</span>(sockfd);</span><br><span class="line">        <span class="keyword">if</span> (iter == _connections.<span class="built_in">end</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// log_(Debug, &quot;检查连接安全状态，fd: %d 不存在于连接管理器中&quot;, sockfd);</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// log_(Debug, &quot;检查连接安全状态，fd: %d 存在于连接管理器中&quot;, sockfd);</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 事件分发器，处理epoll返回的事件</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Dispatcher</span><span class="params">(<span class="type">int</span> timeout)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = _epoller_ptr-&gt;<span class="built_in">EpollerWait</span>(revs, num, timeout);  <span class="comment">// 等待epoll事件</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// if (n &lt; 0)</span></span><br><span class="line">        <span class="comment">// &#123;</span></span><br><span class="line">        <span class="comment">//     log_(Error, &quot;epoll_wait调用失败，错误码: %d, 错误信息: %s&quot;, errno, strerror(errno));</span></span><br><span class="line">        <span class="comment">//     return;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// else if (n == 0)</span></span><br><span class="line">        <span class="comment">// &#123;</span></span><br><span class="line">        <span class="comment">//     log_(Debug, &quot;epoll_wait超时，未检测到任何事件&quot;);</span></span><br><span class="line">        <span class="comment">//     return;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// log_(Debug, &quot;epoll_wait返回 %d 个事件&quot;, n);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">uint32_t</span> events = revs[i].events;</span><br><span class="line">            <span class="type">int</span> sockfd = revs[i].data.fd;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// if (evets &amp; EPOLLERR)</span></span><br><span class="line">            <span class="comment">// &#123;</span></span><br><span class="line">            <span class="comment">//     events |= (EPOLLIN | EPOLLOUT);</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// if (evets &amp; EPOLLHUP)</span></span><br><span class="line">            <span class="comment">// &#123;</span></span><br><span class="line">            <span class="comment">//     events |= (EPOLLIN | EPOLLOUT);</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 处理读事件</span></span><br><span class="line">            <span class="keyword">if</span> ((events &amp; EPOLLIN) &amp;&amp; <span class="built_in">IsConnectionSafe</span>(sockfd))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (_connections[sockfd]-&gt;_recv_cb)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// log_(Debug, &quot;处理读事件，fd: %d&quot;, sockfd);</span></span><br><span class="line">                    _connections[sockfd]-&gt;_recv_cb(_connections[sockfd]);   <span class="comment">// 调用读回调函数</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 处理写事件</span></span><br><span class="line">            <span class="keyword">if</span> ((events &amp; EPOLLOUT) &amp;&amp; <span class="built_in">IsConnectionSafe</span>(sockfd))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (_connections[sockfd]-&gt;_send_cb)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// log_(Debug, &quot;处理写事件，fd: %d&quot;, sockfd);</span></span><br><span class="line">                    _connections[sockfd]-&gt;_send_cb(_connections[sockfd]);   <span class="comment">// 调用写回调函数</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 服务器主循环</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Loop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _quit = <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">log_</span>(Info, <span class="string">&quot;TCP服务器主循环开始运行，端口: %d&quot;</span>, _port);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// AddConnection(_listensock_ptr-&gt;Fd(), EVENT_IN, std::bind(&amp;TcpServer::Accept, this, std::placeholders::_1),nullptr,nullptr);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!_quit)              <span class="comment">// 持续处理事件直到服务器退出</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">Dispatcher</span>(<span class="number">3000</span>);</span><br><span class="line">            <span class="built_in">PrintConnection</span>();      <span class="comment">// 可选，如果需要打印连接状态可以取消注释</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">log_</span>(Info, <span class="string">&quot;TCP服务器主循环结束&quot;</span>);</span><br><span class="line">        _quit = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印当前连接列表（调试用）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PrintConnection</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">log_</span>(Debug, <span class="string">&quot;当前连接总数: %zu&quot;</span>, _connections.<span class="built_in">size</span>());</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;当前连接列表:&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; connection : _connections)</span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; connection.second-&gt;<span class="built_in">SockFd</span>() &lt;&lt; <span class="string">&quot;, &quot;</span>;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;inbuffer: &quot;</span> &lt;&lt; connection.second-&gt;<span class="built_in">Inbuffer</span>().<span class="built_in">c_str</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">TcpServer</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">log_</span>(Info, <span class="string">&quot;TCP服务器正在关闭，清理资源&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::shared_ptr&lt;Epoller&gt; _epoller_ptr;      <span class="comment">// epoll对象指针</span></span><br><span class="line">    std::shared_ptr&lt;Sock&gt; _listensock_ptr;      <span class="comment">// 监听socket对象指针</span></span><br><span class="line">    std::unordered_map&lt;<span class="type">int</span>, std::shared_ptr&lt;Connection&gt;&gt; _connections;  <span class="comment">// 连接管理映射表</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> revs[num];               <span class="comment">// epoll事件数组</span></span><br><span class="line">    <span class="type">uint16_t</span> _port;                             <span class="comment">// 服务器端口号</span></span><br><span class="line">    <span class="type">bool</span> _quit;                                 <span class="comment">// 退出标志</span></span><br><span class="line"></span><br><span class="line">    <span class="type">func_t</span> _OnMessage;                          <span class="comment">// 消息处理函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="10-快速上手-CMake"><a href="#10-快速上手-CMake" class="headerlink" title="10. 快速上手 CMake"></a>10. 快速上手 CMake</h2><h3 id="1-CMake-是干什么的"><a href="#1-CMake-是干什么的" class="headerlink" title="1. CMake 是干什么的"></a>1. CMake 是干什么的</h3><p>CMake 是一个跨平台的 <strong>自动化构建工具</strong>。它的核心作用是：<strong>根据 CMakeLists.txt 自动生成 Makefile</strong>，然后我们只需执行 <code>make</code> 就能编译整个项目。</p><p>简单说：写一份 CMakeLists.txt → 执行 cmake → 自动生成 Makefile → 执行 make → 生成可执行文件。</p><h3 id="2-安装-CMake"><a href="#2-安装-CMake" class="headerlink" title="2. 安装 CMake"></a>2. 安装 CMake</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt install cmake -y</span><br></pre></td></tr></table></figure><p>检查版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake --version</span><br></pre></td></tr></table></figure><h3 id="3-编写最简-CMakeLists-txt"><a href="#3-编写最简-CMakeLists-txt" class="headerlink" title="3. 编写最简 CMakeLists.txt"></a>3. 编写最简 CMakeLists.txt</h3><p>在项目的根目录中创建一个名为 <code>CMakeLists.txt</code> 的文件写入内容：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)<span class="comment"># 指定最低CMake版本</span></span><br><span class="line"><span class="keyword">project</span>(EpollServer)<span class="comment"># 工程名</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)<span class="comment"># 使用C++11标准</span></span><br><span class="line"><span class="keyword">add_executable</span>(EpollServer Main.cc log.cpp) <span class="comment"># 生成可执行文件 main</span></span><br></pre></td></tr></table></figure><p>这就是最基本的版本。<strong>注意：CMake 严格要求文件名必须是 <code>CMakeLists.txt</code>，大小写都必须完全匹配。</strong> 原因很简单：CMake 的解析器在目录下只会自动搜索这个 <strong>精确名字</strong> 的文件（<code>CMakeLists.txt</code>）。不是变量名，不是模糊匹配，也不会识别 <code>CMakelists.txt</code>、<code>cmakelist.txt</code> 等写法。比如：</p><ul><li>✅ 正确：<code>CMakeLists.txt</code>。</li><li>❌ 错误：<code>CMakelists.txt</code> &#x2F; <code>cmakelists.txt</code>。</li></ul><blockquote><p><code>project(EpollServer)</code>：只是一个 <strong>工程名字</strong>，主要用于 CMake 内部标识，与目录名没强绑定。通常我们会让它与最终生成的可执行文件同名，这样方便。</p></blockquote><h3 id="4-编译和运行"><a href="#4-编译和运行" class="headerlink" title="4. 编译和运行"></a>4. 编译和运行</h3><p>我们建议在项目根目录执行下面的代码，这样生成的临时文件都在 build 里，不会污染源代码目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> build</span><br><span class="line"><span class="built_in">cd</span> build</span><br></pre></td></tr></table></figure><p>运行 cmake 命令生成 Makefile</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake ..</span><br></pre></td></tr></table></figure><p>解释：<code>..</code> 表示让 CMake 去上一级（也就是项目根目录）找 <code>CMakeLists.txt</code>。执行完这步后，<code>build/</code> 目录里会生成：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Makefile</span><br><span class="line">CMakeCache.txt</span><br><span class="line">CMakeFiles/</span><br></pre></td></tr></table></figure><p>执行 make 编译：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure><p>CMake 会自动调用 g++ 编译 <code>Main.cc</code> 并生成可执行文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EpollServer</span><br></pre></td></tr></table></figure><p>可选：运行程序</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./EpollServer</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;epoll-和-CMake-的使用&quot;&gt;&lt;a href=&quot;#epoll-和-CMake-的使用&quot; class=&quot;headerlink&quot; title=&quot;epoll 和 CMake 的使用&quot;&gt;&lt;/a&gt;epoll 和 CMake 的使用&lt;/h1&gt;&lt;h2</summary>
        
      
    
    
    
    <category term="Linux" scheme="https://www.minbit.top/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://www.minbit.top/tags/Linux/"/>
    
    <category term="IO" scheme="https://www.minbit.top/tags/IO/"/>
    
  </entry>
  
  <entry>
    <title>056 高级 IO</title>
    <link href="https://www.minbit.top/posts/7814.html"/>
    <id>https://www.minbit.top/posts/7814.html</id>
    <published>2025-10-14T04:00:00.000Z</published>
    <updated>2025-10-22T04:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="高级-IO"><a href="#高级-IO" class="headerlink" title="高级 IO"></a>高级 IO</h1><blockquote><p><a href="https://blog.csdn.net/chenlong_cxy/article/details/126050039">Linux 高级 IO | CSDN</a></p></blockquote><h2 id="1-正确认识-IO"><a href="#1-正确认识-IO" class="headerlink" title="1. 正确认识 IO"></a>1. 正确认识 IO</h2><h3 id="1-IO-的本质"><a href="#1-IO-的本质" class="headerlink" title="1. IO 的本质"></a>1. IO 的本质</h3><p>I&#x2F;O（Input &#x2F; Output）指的是 <strong>CPU 与外设之间的数据交互过程</strong>。在冯·诺依曼结构中，系统由：<strong>CPU</strong>（运算与控制）、<strong>内存</strong>（暂存数据与指令）、<strong>外设</strong>（磁盘、网卡、显示器、键盘等）组成。</p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Blog/20250623200921613.png"></p><p>I&#x2F;O 就是：数据在「内存 ↔ 外设」之间的传输。所以：</p><ul><li><strong>输入（Input）</strong>：外设 → 内存（例如：键盘输入、磁盘读文件、网卡收包）。</li><li><strong>输出（Output）</strong>：内存 → 外设（例如：屏幕显示、磁盘写文件、网卡发包）。</li></ul><h3 id="2-IO-的关键特征"><a href="#2-IO-的关键特征" class="headerlink" title="2. IO 的关键特征"></a>2. IO 的关键特征</h3><ol><li><strong>慢</strong>：外设的速度远慢于 CPU 和内存。因此，IO 通常是性能瓶颈。</li><li><strong>异步性</strong>：外设工作时 CPU 可去做别的事。操作系统通过 <strong>中断、DMA（直接内存访问）</strong> 来提高效率。</li></ol><h3 id="3-文件-IO-与-网络-IO"><a href="#3-文件-IO-与-网络-IO" class="headerlink" title="3. 文件 IO 与 网络 IO"></a>3. 文件 IO 与 网络 IO</h3><table><thead><tr><th>IO 类型</th><th>外设</th><th>操作系统抽象</th><th>本质</th></tr></thead><tbody><tr><td>文件 IO</td><td>磁盘</td><td>文件描述符（fd）</td><td>把数据从磁盘读入内存或写出</td></tr><tr><td>网络 IO</td><td>网卡</td><td>套接字（socket）</td><td>把数据从网卡缓冲区读入内存或写出</td></tr></tbody></table><p>对操作系统来说，<strong>一切皆文件</strong>，无论是磁盘文件、管道、套接字，本质都是「文件描述符 + 缓冲区」上的读写操作。</p><h3 id="4-系统调用层面"><a href="#4-系统调用层面" class="headerlink" title="4. 系统调用层面"></a>4. 系统调用层面</h3><p>C&#x2F;C++ 层面对 IO 的最底层接口如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span></span>;   <span class="comment">// 从 fd 读数据到内存</span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span></span>;  <span class="comment">// 从内存写数据到 fd</span></span><br></pre></td></tr></table></figure><ul><li>读文件时，数据路径是：磁盘 → 内核缓存 → 用户内存。</li><li>读网络时，数据路径是：网卡 → 内核缓冲区 → 用户内存。</li></ul><blockquote><p><strong>应用层 <code>read</code> &amp;&amp; <code>write</code> 的时候，本质就是把数据从用户层写给 OS，即“拷贝函数”。此时我们只需要知道：<span style="color:#FF0000;">IO &#x3D; 等 + 拷贝</span>。要进行拷贝，必须先判断读写事件这个条件成立！</strong></p><p><strong>什么叫做高效 IO 呢？知道 IO &#x3D; 等 + 拷贝后，就可以得出结论：单位时间内，IO 的过程中，等的比重越小，IO 效率越高！反之，等的比重越大，IO 效率越低。几乎所有提高 IO 效率的策略，本质就是这个！</strong></p></blockquote><hr><h2 id="2-五种-IO-模型"><a href="#2-五种-IO-模型" class="headerlink" title="2. 五种 IO 模型"></a>2. 五种 IO 模型</h2><h3 id="1-小故事入题"><a href="#1-小故事入题" class="headerlink" title="1. 小故事入题"></a>1. 小故事入题</h3><ol><li><p>张三是个钓鱼佬，他的钓鱼方式是一根儿鱼竿儿，钓鱼时就一直一动不动地盯着鱼漂，直到有鱼上钩。在这段时间内他不能干别的事，我们管这种方式叫做 <strong>阻塞式 IO</strong>。</p><ul><li>对应到计算机上：<code>read()</code> 一调用，就会 <strong>阻塞当前线程</strong>，操作系统先等数据准备好（等待阶段），数据准备好后，再拷贝到用户空间（拷贝阶段），两步都做完，<code>read()</code> 才返回。<strong>特点</strong>：简单、直观，但效率最低。CPU 在“等鱼”的时间被浪费掉。</li></ul></li><li><p>李四也是钓鱼佬，他也是一根儿鱼竿儿，但他的钓鱼方式是：抛完杆儿，等一会了去喝个茶回来看一看上没上鱼，看会书回来看一看，睡一觉回来看一看，跟张三说完话回来看一看（张三并不想搭理李四），这种方式叫做 <strong>非阻塞式 IO，即非阻塞轮询，特点：</strong> 线程不会被卡死，但 CPU 不停在空转查询，效率依然不高（多线程或高并发场景中非常浪费 CPU）。</p></li><li><p>王五一样，但是他很聪明，他在鱼竿上绑了一个铃铛，期间可以看书、睡觉、打游戏，摸鱼……当铃铛响了说明上鱼了，才去看鱼竿儿，这属于 <strong>信号驱动式 IO</strong>。</p><ul><li>系统上：程序先注册一个信号回调函数（<code>sigaction</code>），当内核检测到数据可读时，会发信号通知用户进程，用户进程再调用 <code>read()</code> 把数据拷贝到用户空间。<strong>特点</strong>：通过信号机制通知事件，比轮询更高效。但信号机制复杂、调度开销大，所以实际使用较少。</li></ul></li><li><p>赵六是个有钱人，他直接开了一大卡车的鱼竿儿，机械化钓鱼，就假设他布置好了 1000 根鱼竿儿，他不可能盯着每一根，于是雇了个助手，<br>助手负责统一盯着所有鱼竿，一旦某根竿有动静就通知他。此时水里的鱼是一定的，但赵六上鱼的概率远远高于其他人，这就是 <strong>多路复用&#x2F;转接。</strong></p><ul><li><strong>这就是 select&#x2F;poll&#x2F;epoll 的核心思想。</strong> 系统提供一个统一的接口，一次性监听多个文件描述符（鱼竿），当其中任意一个“准备就绪”时再通知进程。<strong>特点</strong>：可同时管理大量连接（高并发）、赵六只需要等“通知”即可，效率大大提升、是高性能网络服务器（如 Nginx、Redis）最常用的模式。</li></ul></li><li><p>田七照样是个有钱人，看到他们在钓鱼，于是也想吃鱼，就准备一起，但是很不巧临时有事要走，他一想：我就想吃鱼，怎么来的不重要，于是就叫随行的司机拿着工具去钓鱼，田七则去办其他的事情，告诉司机等他钓好鱼后直接给他打电话就行。这就是 <strong>异步 IO，值得注意的是这里的司机其实就是 OS</strong>。</p><ul><li>系统中：用户调用 <code>aio_read()</code> 之后立即返回，操作系统后台完成“数据准备 + 拷贝”两个阶段，完成后通过事件或回调通知应用。<strong>特点</strong>：真正的 <strong>非阻塞 + 无等待</strong>，CPU 可以同时干别的工作，适用于 I&#x2F;O 密集型高并发场景。</li></ul></li></ol><p>我们知道 <strong>IO &#x3D; 等 + 拷贝</strong>，所有 IO 模型的区别，都在于这两个阶段是 <strong>谁在做</strong>、<strong>怎么做</strong>。在这个钓鱼的过程中只有田七是异步 IO，其他人都属于同步 IO，因为其他人都直接参与了等的环节，但田七则是间接做了等的操作，实际不参与 IO，田七只是发起 IO，最后拿结果就行，就像我交给你一个黑盒，我不管你干了什么，到时候我从黑盒中拿结果就行。还有一点就是同步 IO 是&#x2F;属于线程同步吗？答案是老婆和老婆饼的关系 —— 没有关系！</p><h3 id="2-深入理解-IO-等-拷贝-的思维模型"><a href="#2-深入理解-IO-等-拷贝-的思维模型" class="headerlink" title="2. 深入理解 IO &#x3D; 等 + 拷贝 的思维模型"></a>2. 深入理解 IO &#x3D; 等 + 拷贝 的思维模型</h3><p>无论哪种 IO，本质都要经历两个阶段：</p><ol><li><strong>等待数据准备好</strong>（等待鱼上钩）。</li><li><strong>数据从内核缓冲区拷贝到用户空间</strong>（把鱼拽上来）。</li></ol><p>区别在于：谁来“等”（线程自己、统一管理者、还是操作系统），什么时候返回（等完再返回，还是先返回之后回调）。</p><table><thead><tr><th>模型类型</th><th>等待阶段</th><th>拷贝阶段</th><th>是否阻塞</th><th>谁来等</th><th>典型调用</th><th>适用场景</th></tr></thead><tbody><tr><td>阻塞 I&#x2F;O</td><td>阻塞</td><td>阻塞</td><td>是</td><td>应用线程</td><td><code>read()</code></td><td>简单场景</td></tr><tr><td>非阻塞 I&#x2F;O</td><td>轮询</td><td>阻塞</td><td>否（轮询）</td><td>应用线程</td><td><code>fcntl(fd, O_NONBLOCK)</code></td><td>少量连接</td></tr><tr><td>信号驱动 I&#x2F;O</td><td>信号触发</td><td>阻塞</td><td>否</td><td>内核发信号</td><td><code>sigaction()</code></td><td>特殊场合</td></tr><tr><td>I&#x2F;O 多路复用</td><td>阻塞等待事件</td><td>阻塞拷贝</td><td>部分阻塞</td><td>统一等待者（select&#x2F;poll&#x2F;epoll）</td><td>高并发服务器</td><td>高性能</td></tr><tr><td>异步 I&#x2F;O</td><td>非阻塞</td><td>非阻塞</td><td>否</td><td>全交给内核</td><td><code>aio_read()</code></td><td>真正异步场景</td></tr></tbody></table><hr><h2 id="3-fcntl-函数原型"><a href="#3-fcntl-函数原型" class="headerlink" title="3. fcntl 函数原型"></a>3. <code>fcntl</code> 函数原型</h2><h3 id="1-功能-作用"><a href="#1-功能-作用" class="headerlink" title="1. 功能 &#x2F; 作用"></a>1. 功能 &#x2F; 作用</h3><p><code>fcntl()</code> —— 它是 Linux 文件描述符控制的“瑞士军刀”，非常常见于网络编程和 I&#x2F;O 模型设置中，比如设置非阻塞套接字。<code>fcntl()</code>（file control）用于 <strong>对已打开的文件描述符进行各种控制操作</strong>。几乎所有“修改文件描述符行为”的操作都要通过它完成，例如：设置 &#x2F; 清除文件描述符的标志（如非阻塞模式）、获取 &#x2F; 修改文件状态、复制文件描述符、锁定文件、调整文件特性等。</p><h3 id="2-函数原型"><a href="#2-函数原型" class="headerlink" title="2. 函数原型"></a>2. 函数原型</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fcntl</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> cmd, ... <span class="comment">/* arg */</span>)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="3-参数详解"><a href="#3-参数详解" class="headerlink" title="3. 参数详解"></a>3. 参数详解</h3><table><thead><tr><th>参数位置</th><th>含义</th></tr></thead><tbody><tr><td><strong>第 1 个参数：fd</strong></td><td>要操作哪个文件描述符（文件、socket 等）</td></tr><tr><td><strong>第 2 个参数：cmd</strong></td><td>要执行的命令&#x2F;控制操作（告诉内核你想干什么）</td></tr><tr><td><strong>第 3 个参数：arg（可选）</strong></td><td>如果需要，就传入新的标志值（常用“旧标志 | 新功能”）</td></tr></tbody></table><h4 id="1-第二个参数（cmd）——-要执行的操作类型"><a href="#1-第二个参数（cmd）——-要执行的操作类型" class="headerlink" title="1. 第二个参数（cmd）—— 要执行的操作类型"></a>1. 第二个参数（cmd）—— 要执行的操作类型</h4><table><thead><tr><th>命令（cmd）</th><th>含义</th><th>第三个参数（arg）</th><th>常用场景</th></tr></thead><tbody><tr><td><strong>F_GETFL</strong></td><td>获取文件状态标志</td><td>无</td><td>读取当前 fd 的打开模式（只读、非阻塞等）</td></tr><tr><td><strong>F_SETFL</strong></td><td>设置文件状态标志</td><td>新标志（通常是“旧标志 | 新标志”）</td><td>修改 fd 行为，如设为非阻塞</td></tr><tr><td><strong>F_GETFD</strong></td><td>获取文件描述符标志</td><td>无</td><td>判断 fd 是否带有 FD_CLOEXEC</td></tr><tr><td><strong>F_SETFD</strong></td><td>设置文件描述符标志</td><td><code>FD_CLOEXEC</code> 等</td><td>设置执行 exec() 时是否自动关闭 fd</td></tr><tr><td><strong>F_DUPFD</strong></td><td>复制一个新的文件描述符</td><td>最小可用 fd 编号</td><td>类似 dup()，但可指定起始编号</td></tr><tr><td><strong>F_SETLK</strong></td><td>设置文件锁（非阻塞）</td><td><code>struct flock *</code></td><td>文件加锁，不会阻塞</td></tr><tr><td><strong>F_SETLKW</strong></td><td>设置文件锁（阻塞）</td><td><code>struct flock *</code></td><td>文件加锁，会阻塞等待</td></tr><tr><td><strong>F_GETLK</strong></td><td>获取文件锁状态</td><td><code>struct flock *</code></td><td>查询当前文件锁</td></tr></tbody></table><p>实际开发中 <strong>最常用的就是 <code>F_GETFL</code> 和 <code>F_SETFL</code></strong>，尤其用于：设置非阻塞 IO（<code>O_NONBLOCK</code>）、设置追加写（<code>O_APPEND</code>）。</p><h4 id="2-第三个参数（arg）——-状态标志"><a href="#2-第三个参数（arg）——-状态标志" class="headerlink" title="2. 第三个参数（arg）—— 状态标志"></a>2. 第三个参数（arg）—— 状态标志</h4><table><thead><tr><th>标志</th><th>含义</th><th>常见场景</th></tr></thead><tbody><tr><td><strong>O_RDONLY</strong></td><td>只读打开</td><td>打开文件用</td></tr><tr><td><strong>O_WRONLY</strong></td><td>只写打开</td><td>打开文件用</td></tr><tr><td><strong>O_RDWR</strong></td><td>可读可写</td><td>打开文件用</td></tr><tr><td><strong>O_APPEND</strong></td><td>写操作追加到文件末尾</td><td>日志文件</td></tr><tr><td><strong>O_NONBLOCK</strong></td><td>非阻塞模式</td><td>网络 I&#x2F;O</td></tr><tr><td><strong>O_SYNC</strong></td><td>同步写入（每次写都落盘）</td><td>文件系统安全要求高的场景</td></tr><tr><td><strong>O_ASYNC</strong></td><td>异步 I&#x2F;O 模式</td><td>很少单独使用</td></tr><tr><td><strong>O_CREAT</strong></td><td>不存在则创建</td><td>文件打开</td></tr><tr><td><strong>O_TRUNC</strong></td><td>打开时清空文件内容</td><td>文件重写</td></tr><tr><td><strong>FD_CLOEXEC</strong></td><td>执行 exec() 时自动关闭 fd</td><td>防止文件描述符泄漏</td></tr></tbody></table><h4 id="3-快速记忆法"><a href="#3-快速记忆法" class="headerlink" title="3. 快速记忆法"></a>3. 快速记忆法</h4><table><thead><tr><th>操作类型</th><th>缩写记忆</th><th>用途</th></tr></thead><tbody><tr><td><code>F_GETFL</code> &#x2F; <code>F_SETFL</code></td><td>FL &#x3D; File status Flags</td><td>控制读写行为</td></tr><tr><td><code>F_GETFD</code> &#x2F; <code>F_SETFD</code></td><td>FD &#x3D; File Descriptor</td><td>控制描述符自身属性</td></tr><tr><td><code>O_NONBLOCK</code></td><td>Non-blocking</td><td>设置非阻塞</td></tr><tr><td><code>FD_CLOEXEC</code></td><td>Close on exec</td><td>执行新程序时关闭 fd</td></tr></tbody></table><h3 id="4-返回值"><a href="#4-返回值" class="headerlink" title="4. 返回值"></a>4. 返回值</h3><ul><li><strong>成功：</strong> 返回值依赖于 <code>cmd</code>，一般为 <strong>非负数</strong>。</li><li><strong>失败：</strong> 返回 <strong>-1</strong>，并设置 <code>errno</code>。</li></ul><h3 id="5-示例：设置非阻塞套接字"><a href="#5-示例：设置非阻塞套接字" class="headerlink" title="5. 示例：设置非阻塞套接字"></a>5. 示例：设置非阻塞套接字</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setNoBlock</span><span class="params">(<span class="type">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> fl = <span class="built_in">fcntl</span>(fd, F_GETFL);                <span class="comment">// 获取原来文件描述符的属性</span></span><br><span class="line">    <span class="keyword">if</span>(fl &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;fcntl&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fcntl</span>(fd, F_GETFL, fl | O_NONBLOCK);        <span class="comment">// 在原标志基础上加上非阻塞</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;设置 &quot;</span> &lt;&lt; fd &lt;&lt; <span class="string">&quot; 为非阻塞模式成功！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">setNoBlock</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// printf(&quot;please enter: &quot;);</span></span><br><span class="line">        <span class="comment">// fflush(stdout);</span></span><br><span class="line"></span><br><span class="line">        <span class="type">ssize_t</span> n = <span class="built_in">read</span>(<span class="number">0</span>, buffer, <span class="built_in">sizeof</span>(buffer) - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(n &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            buffer[n - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;echo: &quot;</span> &lt;&lt; buffer &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;read EOF/read done!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cerr &lt;&lt; <span class="string">&quot;read error, n = &quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&quot;error code: &quot;</span> &lt;&lt; errno &lt;&lt; <span class="string">&quot;error string: &quot;</span> &lt;&lt; <span class="built_in">strerror</span>(errno) &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>设置成为非阻塞，如果底层 fd 数据没有就绪，recv&#x2F;read&#x2F;write&#x2F;send, 返回值会以出错的形式返回，错误形式的两种情况：a. 真的出错，b. 底层没有就绪。怎么区分呢？需要通过 errno 区分！！！</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> sockfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);  <span class="comment">// 创建 TCP 套接字</span></span><br><span class="line">    <span class="keyword">if</span> (sockfd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;socket error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前文件状态标志</span></span><br><span class="line">    <span class="type">int</span> flags = <span class="built_in">fcntl</span>(sockfd, F_GETFL, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (flags &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;fcntl F_GETFL error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置非阻塞模式（加上 O_NONBLOCK）</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fcntl</span>(sockfd, F_SETFL, flags | O_NONBLOCK) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;fcntl F_SETFL error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;套接字已设置为非阻塞模式&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(sockfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-IO-多路转接之-select-函数原型"><a href="#4-IO-多路转接之-select-函数原型" class="headerlink" title="4. IO 多路转接之 select 函数原型"></a>4. IO 多路转接之 select 函数原型</h2><blockquote><p><a href="https://blog.csdn.net/chenlong_cxy/article/details/126189616">IO 多路转接 ——— select、poll、epoll | CSDN</a></p></blockquote><h3 id="1-作用"><a href="#1-作用" class="headerlink" title="1. 作用"></a>1. 作用</h3><p><code>select</code> 是最早的 I&#x2F;O 多路复用函数，用来 <strong>同时监控多个文件描述符（fd）是否可读、可写或有异常事件</strong>。</p><h3 id="2-函数原型-1"><a href="#2-函数原型-1" class="headerlink" title="2. 函数原型"></a>2. 函数原型</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">select</span><span class="params">(<span class="type">int</span> nfds,</span></span></span><br><span class="line"><span class="params"><span class="function">           fd_set *readfds,</span></span></span><br><span class="line"><span class="params"><span class="function">           fd_set *writefds,</span></span></span><br><span class="line"><span class="params"><span class="function">           fd_set *exceptfds,</span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="keyword">struct</span> timeval *timeout)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="3-参数解释"><a href="#3-参数解释" class="headerlink" title="3. 参数解释"></a>3. 参数解释</h3><table><thead><tr><th>参数名</th><th>含义</th></tr></thead><tbody><tr><td><code>nfds</code></td><td><strong>监控的最大文件描述符 + 1</strong>（例如要监控 <code>fd=5</code>，就写 <code>nfds=6</code>）</td></tr><tr><td><code>readfds</code></td><td>想监控“<strong>可读事件</strong>”的文件描述符集合（如 <code>recv()</code>、<code>read()</code> 是否不阻塞）</td></tr><tr><td><code>writefds</code></td><td>想监控“<strong>可写事件</strong>”的文件描述符集合（如 <code>send()</code>、<code>write()</code> 是否不阻塞）</td></tr><tr><td><code>exceptfds</code></td><td>监控“<strong>异常事件</strong>”的文件描述符集合（一般不用，传 <code>NULL</code>）</td></tr><tr><td><code>timeout</code></td><td>超时时间（阻塞多久）。传 <code>NULL</code> 就是 <strong>一直阻塞</strong>。</td></tr></tbody></table><h4 id="1-nfds-参数"><a href="#1-nfds-参数" class="headerlink" title="1. nfds 参数"></a>1. <code>nfds</code> 参数</h4><p><code>nfds</code> &#x3D; <strong>要监控的最高文件描述符编号 + 1</strong>。</p><ul><li>想监控 fd 3, fd 5？最高是 5，<code>nfds</code> 就写 <code>5 + 1 = 6</code>。</li><li>想监控 fd 1, fd 2, fd 100？最高是 100，<code>nfds</code> 就是 <code>100 + 1 = 101</code>。</li><li><strong>不是系统最大支持的文件描述符大小！</strong> 那个值通常很大（如 1024 或 65536），不需要监控那么多。</li></ul><p><strong>记住：<code>nfds</code> 是一个范围</strong>：<code>select</code> 会检查从 0 到 <code>nfds - 1</code> 这个范围内的所有 fd（只要在 <code>fd_set</code> 里设置了它们）。<code>nfds</code> 就是这个范围的 <strong>上限</strong>（不包含）。<strong>简化记忆</strong>：<code>nfds = max_fd + 1</code>。<code>select</code> 会在这个范围 <code>[0, max_fd]</code> 内，看你 <code>fd_set</code> 里标记了哪些 fd，然后监控它们。</p><h4 id="2-fd-set-的本质"><a href="#2-fd-set-的本质" class="headerlink" title="2. fd_set 的本质"></a>2. <code>fd_set</code> 的本质</h4><p><strong><code>fd_set</code> 是内核与用户空间之间传递“文件描述符就绪信息”的一张位图。</strong></p><table><thead><tr><th>阶段</th><th>谁在操作</th><th>含义</th></tr></thead><tbody><tr><td><strong>输入阶段（用户 → 内核）</strong></td><td>用户调用 <code>select()</code> 前</td><td>告诉内核：“我关心这些 fd（读、写、异常）。”</td></tr><tr><td><strong>输出阶段（内核 → 用户）</strong></td><td>内核执行完 I&#x2F;O 检查后</td><td>告诉用户：“这些 fd 已经就绪（比特位 &#x3D; 1）。”</td></tr></tbody></table><p><strong>也就是说：<code>readfds</code> 是输入输出双向参数（既是输入，也会被输出修改），每一位对应一个 <code>fd</code>，<code>1</code> 表示就绪；<code>0</code> 表示未就绪。调用后必须重新设置 <code>fd_set</code>，因为 <code>select</code> 会修改它。<code>fd_set</code> 的内部形式：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> fds_bits[__FD_SETSIZE / (<span class="number">8</span> * <span class="built_in">sizeof</span>(<span class="type">long</span>))];</span><br><span class="line">&#125; fd_set;</span><br></pre></td></tr></table></figure><p>本质就是一个 <strong>位图</strong>，每个 bit 对应一个文件描述符号位（fd 号），比如：<code>fd=3</code> -&gt; <code>fds_bits[0]</code> 的第 3 位。<code>select()</code> 的核心：用户传一张“关注表”（<code>fd_set</code>）给内核，内核帮你看这些 fd 是否有事件，等结果出来后，内核再把“结果表”写回给你。</p><h4 id="3-常用辅助宏"><a href="#3-常用辅助宏" class="headerlink" title="3. 常用辅助宏"></a>3. 常用辅助宏</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">FD_CLR</span>(<span class="type">int</span> fd, fd_set* set);<span class="comment">// 把fd从集合中移除（对应 bit = 0）</span></span><br><span class="line"><span class="built_in">FD_ISSET</span>(<span class="type">int</span> fd, fd_set* set);<span class="comment">// 判断fd是否在集合中就绪（bit==1 返回 true）</span></span><br><span class="line"><span class="built_in">FD_SET</span>(<span class="type">int</span> fd, fd_set* set);<span class="comment">// 把fd加入集合（设置对应 bit = 1）</span></span><br><span class="line"><span class="built_in">FD_ZERO</span>(fd_set* set);<span class="comment">// 清空集合（所有 bit 置 0）</span></span><br></pre></td></tr></table></figure><p>一般是这么操作的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">fd_set readfds;          <span class="comment">// 定义一个fd集合</span></span><br><span class="line"><span class="built_in">FD_ZERO</span>(&amp;readfds);       <span class="comment">// 清空集合</span></span><br><span class="line"><span class="built_in">FD_SET</span>(sockfd, &amp;readfds); <span class="comment">// 把sockfd加入关注集合</span></span><br><span class="line"><span class="built_in">FD_SET</span>(STDIN_FILENO, &amp;readfds); <span class="comment">// 把标准输入加入集合</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用select，监听读事件</span></span><br><span class="line"><span class="type">int</span> ret = <span class="built_in">select</span>(maxfd + <span class="number">1</span>, &amp;readfds, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;timeout);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">FD_ISSET</span>(sockfd, &amp;readfds))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// sockfd 可读</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">FD_ISSET</span>(STDIN_FILENO, &amp;readfds))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 标准输入可读</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用后，<code>readfds</code> 会被内核修改，表示哪些 fd 已经 <strong>就绪</strong>。</p><h4 id="4-struct-timeval-的含义"><a href="#4-struct-timeval-的含义" class="headerlink" title="4. struct timeval 的含义"></a>4. <code>struct timeval</code> 的含义</h4><blockquote><p><code>timeout</code> 就是给 <code>select</code> 设置一个 <strong>最长等待时间</strong> 的 <strong>闹钟</strong>。如果在闹钟响之前有事（fd 就绪），就立即叫醒你（返回）；如果闹钟响了还没事（fd 未就绪），也叫醒你（返回 0）。如果设置为永不响（<code>NULL</code>），就会一直睡（阻塞）；如果设置为立刻响（<code>{0, 0}</code>），就不会睡（非阻塞）。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">timeval</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">time_t</span>      tv_sec;   <span class="comment">// Seconds —— 秒</span></span><br><span class="line">    <span class="type">suseconds_t</span> tv_usec;  <span class="comment">// Microseconds —— 微秒（1秒=1,000,000微秒）</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>{seconds, microseconds}</code>: <code>select</code> 最多等待 <code>seconds</code> 秒 + <code>microseconds</code> 微秒。</p><ul><li>如果在 <strong>这个时间之内</strong>，有你监控的 fd 就绪了，<code>select</code> 会 <strong>立即返回</strong>，告诉你哪些 fd 就绪了，剩余的等待时间会被写回到 <code>timeout</code> 结构体中（通常在实际编程中，会每次都重新设置这个值）。</li><li>如果 <strong>这个时间之内</strong>，没有任何你监控的 fd 就绪，<code>select</code> 会 <strong>超时返回</strong>（返回值为 0）。</li></ul><p><strong>示例：</strong></p><ul><li><code>NULL</code> → 永久阻塞（传统阻塞式 I&#x2F;O）。</li><li><code>{5,0}</code> → 最多阻塞 5 秒（带超时的阻塞）。</li><li><code>{0,0}</code> → 不阻塞，<strong>非阻塞轮询式 I&#x2F;O</strong>。</li></ul><h3 id="4-返回值-1"><a href="#4-返回值-1" class="headerlink" title="4. 返回值"></a>4. 返回值</h3><ul><li><code>&gt; 0</code>：有多少个文件描述符就绪（可读 &#x2F; 可写 &#x2F; 异常）。</li><li><code>= 0</code>：超时，没有任何事件发生，没有错误，但是也没有 fd 就绪。</li><li><code>&lt; 0</code>：出错（一般是信号中断或参数错误）。</li></ul><h3 id="5-使用示例"><a href="#5-使用示例" class="headerlink" title="5. 使用示例"></a>5. 使用示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fd_set readfds;                  <span class="comment">// 创建fd集合</span></span><br><span class="line">    <span class="built_in">FD_ZERO</span>(&amp;readfds);               <span class="comment">// 清空集合</span></span><br><span class="line">    <span class="built_in">FD_SET</span>(STDIN_FILENO, &amp;readfds);  <span class="comment">// 把标准输入加入监控集合</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">timeval</span> tv;</span><br><span class="line">    tv.tv_sec = <span class="number">5</span>;                   <span class="comment">// 最多阻塞5秒</span></span><br><span class="line">    tv.tv_usec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;等待输入中...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">select</span>(STDIN_FILENO + <span class="number">1</span>, &amp;readfds, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;tv);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">FD_ISSET</span>(STDIN_FILENO, &amp;readfds))</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;检测到输入：&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">            <span class="built_in">read</span>(STDIN_FILENO, buf, <span class="built_in">sizeof</span>(buf));</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;你输入了: &quot;</span> &lt;&lt; buf;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;超时，没有输入&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;select 出错&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>一个基于 <code>select</code> 系统调用的单进程、单线程 TCP 服务器：</strong></p><blockquote><p>完整代码请前往 <a href="https://github.com/huangcancan-xbc/Linux-Ubuntu/tree/main/Coding/Advanced_IO/select">GitHub</a> 进行查看！</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Socket.hpp&quot;</span></span></span><br><span class="line"><span class="comment">// #include &quot;Log.hpp&quot;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">uint16_t</span> defaultport = <span class="number">8080</span>;                   <span class="comment">// 默认端口号8080</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> fd_num_max = (<span class="built_in">sizeof</span>(fd_set) * <span class="number">8</span>);         <span class="comment">// 计算fd_set能容纳的最大文件描述符数量，每个bit位代表一个fd</span></span><br><span class="line"><span class="type">int</span> defaultfd = <span class="number">-1</span>;                                         <span class="comment">// 无效文件描述符，用来标识数组中空闲的位置</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SelectServer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SelectServer</span>(<span class="type">uint16_t</span> port = defaultport)</span><br><span class="line">        : _port(port)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; fd_num_max; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            fd_array[i] = defaultfd;                        <span class="comment">// 将数组中所有位置都初始化为-1，表示空闲</span></span><br><span class="line">            <span class="comment">// std::cout &lt;&lt; &quot;fd_array[&quot; &lt;&lt; i &lt;&lt; &quot;]&quot; &lt;&lt; &quot; : &quot; &lt;&lt; fd_array[i] &lt;&lt; std::endl;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">SelectServer</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        _listensock.<span class="built_in">Close</span>();                                <span class="comment">// 关闭监听socket</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化服务器：创建socket、绑定端口、开始监听</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _listensock.<span class="built_in">Socket</span>();                               <span class="comment">// 创建监听socket</span></span><br><span class="line">        _listensock.<span class="built_in">Bind</span>(_port);                            <span class="comment">// 绑定端口</span></span><br><span class="line">        _listensock.<span class="built_in">Listen</span>();                               <span class="comment">// 开始监听</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印当前在线的文件描述符列表</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PrintFd</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;在线_fd_列表： &quot;</span>;                          <span class="comment">// 输出提示信息</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; fd_num_max; i++)               <span class="comment">// 遍历fd_array数组</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (fd_array[i] == defaultfd)                  <span class="comment">// 如果是空闲位置，跳过</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            cout &lt;&lt; fd_array[i] &lt;&lt; <span class="string">&quot; &quot;</span>;                    <span class="comment">// 输出有效的文件描述符</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Accepter</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 连接事件已经就绪</span></span><br><span class="line">        std::string client_ip;                              <span class="comment">// 客户端的IP</span></span><br><span class="line">        <span class="type">uint16_t</span> client_port;                               <span class="comment">// 客户端的端口</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> sock = _listensock.<span class="built_in">Accept</span>(&amp;client_ip, &amp;client_port);    <span class="comment">// 从监听socket获取新的连接，不会阻塞，因为select已经告诉我们有连接事件就绪</span></span><br><span class="line">        <span class="keyword">if</span> (sock &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;  <span class="comment">// 如果accept失败，直接返回</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">log_</span>(Info, <span class="string">&quot;新连接建立成功：客户端IP：%s，客户端端口：%d，socket fd：%d&quot;</span>, client_ip.<span class="built_in">c_str</span>(), client_port, sock);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Info, 新连接建立成功：客户端IP：&quot;</span> &lt;&lt; client_ip &lt;&lt; <span class="string">&quot;，客户端端口：&quot;</span> &lt;&lt; client_port &lt;&lt; <span class="string">&quot;，socket fd：&quot;</span> &lt;&lt; sock &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将新连接的文件描述符存入fd_array数组中</span></span><br><span class="line">        <span class="type">int</span> pos = <span class="number">1</span>;                                       <span class="comment">// 从数组索引1开始找空闲位置（索引0存放监听socket）</span></span><br><span class="line">        <span class="keyword">for</span> (; pos &lt; fd_num_max; pos++)                    <span class="comment">// 查找数组中空闲的位置</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (fd_array[pos] != defaultfd)                <span class="comment">// 如果当前位置不为空（-1），继续找下一个</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>                                           <span class="comment">// 找到空闲位置，跳出循环</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pos == fd_num_max)                             <span class="comment">// 如果遍历完整个数组都没找到空闲位置</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">log_</span>(Warning, <span class="string">&quot;服务器已满，立即关闭%d！&quot;</span>, sock); <span class="comment">// 服务器已满，关闭新连接</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Warning, 服务器已满，立即关闭&quot;</span> &lt;&lt; sock &lt;&lt; <span class="string">&quot;！&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="built_in">close</span>(sock);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>                                               <span class="comment">// 找到了空闲位置</span></span><br><span class="line">        &#123;</span><br><span class="line">            fd_array[pos] = sock;                          <span class="comment">// 将新连接的fd放入数组</span></span><br><span class="line">            <span class="built_in">PrintFd</span>();                                     <span class="comment">// 打印当前在线的fd列表</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 后续可能还有其他处理</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理数据接收的函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Recver</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> pos)</span>                            <span class="comment">// fd是需要读取数据的文件描述符，pos是该fd在数组中的位置</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// demo，接收客户端数据</span></span><br><span class="line">        <span class="type">char</span> buffer[<span class="number">1024</span>];                                  <span class="comment">// 临时缓冲区，用于存储接收的数据</span></span><br><span class="line">        <span class="type">ssize_t</span> n = <span class="built_in">read</span>(fd, buffer, <span class="built_in">sizeof</span>(buffer) - <span class="number">1</span>);   <span class="comment">// 从指定fd读取数据到缓冲区，预留1字节给字符串结束符</span></span><br><span class="line">        <span class="keyword">if</span> (n &gt; <span class="number">0</span>)                                          <span class="comment">// 读取到数据</span></span><br><span class="line">        &#123;</span><br><span class="line">            buffer[n] = <span class="number">0</span>;                                  <span class="comment">// 手动添加字符串结束符</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;收到一条消息：&quot;</span> &lt;&lt; buffer &lt;&lt; endl;      <span class="comment">// 输出接收到的消息</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">0</span>)                                    <span class="comment">// 客户端断开连接（读到文件结束符）</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">log_</span>(Info, <span class="string">&quot;客户端退出了，关闭连接的文件描述符是%d&quot;</span>, fd);  <span class="comment">// 记录客户端断开日志</span></span><br><span class="line">            <span class="built_in">close</span>(fd);                                      <span class="comment">// 关闭该连接的文件描述符</span></span><br><span class="line">            fd_array[pos] = defaultfd;                      <span class="comment">// 将数组中对应位置重置为-1，表示该位置空闲（这里本质是从select中移除该fd）</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>                                                <span class="comment">// 读取错误</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">log_</span>(Warning, <span class="string">&quot;接收文件错误，描述符是: %d&quot;</span>, fd);  <span class="comment">// 记录接收错误日志</span></span><br><span class="line">            <span class="built_in">close</span>(fd);                                      <span class="comment">// 关闭该连接的文件描述符</span></span><br><span class="line">            fd_array[pos] = defaultfd;                      <span class="comment">// 将数组中对应位置重置为-1，表示该位置空闲（这里本质是从select中移除该fd）</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 事件分发函数：根据select返回的结果，处理就绪的文件描述符</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Dispatcher</span><span class="params">(fd_set&amp; rfds)</span>                           <span class="comment">// rfds是select调用后被修改的fd_set，其中包含了就绪的fd</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; fd_num_max; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> fd = fd_array[i];                           <span class="comment">// 获取数组中第i个位置的fd</span></span><br><span class="line">            <span class="keyword">if</span> (fd == defaultfd)                            <span class="comment">// 如果是无效fd（-1），跳过</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 检查这个fd是否在select返回的就绪fd集合中</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">FD_ISSET</span>(fd, &amp;rfds))                         <span class="comment">// FD_ISSET宏用于检查fd是否在rfds集合中</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(fd == _listensock.<span class="built_in">Fd</span>())                  <span class="comment">// 如果就绪的fd是监听socket</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">Accepter</span>();                             <span class="comment">// 说明有新的连接请求，调用Accepter处理</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>                                        <span class="comment">// 如果就绪的fd不是监听socket，而是普通的数据连接socket</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">Recver</span>(fd, i);                          <span class="comment">// 调用Recver处理数据接收</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 服务器主循环：使用select实现IO多路复用</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Start</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> listensock = _listensock.<span class="built_in">Fd</span>();                  <span class="comment">// 获取监听socket的文件描述符</span></span><br><span class="line">        fd_array[<span class="number">0</span>] = listensock;                           <span class="comment">// 将监听socket放在数组第0个位置</span></span><br><span class="line">        <span class="comment">// 程序启动时，只有数组第0个位置有值，是监听socket的fd，但是，程序运行过程中，Accepter 会向数组中其他位置添加新的连接fd！</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;)                                            <span class="comment">// 无限循环，服务器持续运行</span></span><br><span class="line">        &#123;</span><br><span class="line">            fd_set readfds;                                 <span class="comment">// 定义一个fd_set变量，用于存储待检测的读就绪文件描述符集合</span></span><br><span class="line">            <span class="built_in">FD_ZERO</span>(&amp;readfds);                              <span class="comment">// 清空readfds集合，将所有位都设置为0</span></span><br><span class="line">            <span class="comment">// 每次进入循环，都要重新构建readfds集合，因为select会修改它。</span></span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> maxfds = fd_array[<span class="number">0</span>];                       <span class="comment">// 记录当前最大的文件描述符值，用于select调用</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; fd_num_max;i++)          <span class="comment">// 第一次循环，遍历fd_array数组，准备select的参数</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (fd_array[i] == defaultfd)               <span class="comment">// 如果数组中该位置是空闲的（-1），跳过</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="comment">// 这个 continue 非常有用！如果不跳过，fd_array[i] 是 -1，FD_SET(-1, &amp;readfds) 会出错或行为未定义。</span></span><br><span class="line">                    <span class="comment">// 并且，如果当前只有监听socket，数组后面的位置都是-1，这个循环会遍历所有位置，</span></span><br><span class="line">                    <span class="comment">// 但由于 continue，只有有效的fd（比如监听socket）会被处理。</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">FD_SET</span>(fd_array[i], &amp;readfds);              <span class="comment">// 将有效的fd添加到readfds集合中，让select监控这些fd的读就绪状态</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(fd_array[i] &gt; maxfds)</span><br><span class="line">                &#123;</span><br><span class="line">                    maxfds = fd_array[i];                   <span class="comment">// 更新最大fd值</span></span><br><span class="line">                    <span class="built_in">log_</span>(Info,<span class="string">&quot;最大文件描述符更新，最大文件描述符为：%d&quot;</span>, maxfds);</span><br><span class="line">                    std::cout &lt;&lt; <span class="string">&quot;最大文件描述符更新，最大文件描述符为：&quot;</span> &lt;&lt; maxfds &lt;&lt; std::endl;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">struct</span> <span class="title class_">timeval</span> timeout = &#123;<span class="number">5</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 调用select系统调用，监控maxfds+1个文件描述符（0到maxfds），readfds是读就绪集合，nullptr表示不监控写和异常</span></span><br><span class="line">            <span class="type">int</span> n = <span class="built_in">select</span>(maxfds + <span class="number">1</span>, &amp;readfds, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;timeout); <span class="comment">// 最后一个参数为nullptr表示不超时，阻塞等待</span></span><br><span class="line">            <span class="comment">// select 现在监控的是 0 到 maxfds 范围内所有在 readfds 位图中被置位的 fd。</span></span><br><span class="line">            <span class="comment">// 如果只有监听socket，它只监控监听socket。如果有多个连接，它会监控监听socket 和 所有已连接的socket。</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 根据select返回值进行处理</span></span><br><span class="line">            <span class="keyword">switch</span>(n)</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="comment">// select超时处理</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;time out, timeout: &quot;</span> &lt;&lt; timeout.tv_sec &lt;&lt; <span class="string">&quot;.&quot;</span> &lt;&lt; timeout.tv_usec &lt;&lt; endl;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// select调用出错处理</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;select error, errno:&quot;</span> &lt;&lt; errno &lt;&lt; endl;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// select成功处理</span></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;得到了一个新的连接请求！&quot;</span> &lt;&lt; endl;</span><br><span class="line">                <span class="built_in">Dispatcher</span>(readfds); <span class="comment">// 调用Dispatcher处理所有就绪的事件</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Sock _listensock;                <span class="comment">// 监听socket对象</span></span><br><span class="line">    <span class="type">uint16_t</span> _port;                  <span class="comment">// 服务器端口号</span></span><br><span class="line">    <span class="type">int</span> fd_array[fd_num_max];        <span class="comment">// 文件描述符数组，用于维护当前所有有效的连接fd（包括监听fd）</span></span><br><span class="line">    <span class="comment">// int wfd_array[fd_num_max];    // 扩展写事件处理</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>测试连接：<code>telnet 127.0.0.1 8080</code>，尝试输入一些内容……</strong> 初学时，这段代码要理解其实有一定难度，让我们详细梳理一下：</p><ol><li><p><strong>初始状态</strong>：</p><ul><li><code>listensock = 3</code>，监听 socket 的 fd，0、1、2 默认被占用就不解释了。</li><li><code>fd_array[0] = 3</code>。</li><li><code>fd_array[1]</code> 到 <code>fd_array[fd_num_max-1]</code> 都是 <code>-1</code>。</li></ul></li><li><p><strong>第一次 <code>Start</code> 循环</strong>：</p><ul><li><code>fd_set readfds</code> 被清空。</li><li>遍历 <code>fd_array</code>，只有 <code>fd_array[0]</code> (值为 3) 有效，所以 <code>FD_SET(3, &amp;readfds)</code>。<code>maxfds = 3</code>。</li><li><code>select(4, &amp;readfds, ...)</code> 被调用，监控 fd 3。</li><li>假设现在 <strong>客户端 A</strong> 连接服务器。</li><li><code>select</code> 发现 fd 3 (监听 socket) 可读（有新连接），返回值 &gt; 0。</li><li>进入 <code>Dispatcher(readfds)</code>。</li><li><code>Dispatcher</code> 遍历 <code>fd_array</code>。</li><li><code>i=0</code>: <code>fd = fd_array[0] = 3</code>。<code>FD_ISSET(3, &amp;readfds)</code> 为真。<code>fd (3) == _listensock.Fd()</code> 为真。调用 <code>Accepter()</code>。</li></ul></li><li><p><strong><code>Accepter</code> 执行</strong>：</p><ul><li><code>accept</code> 被调用，获取 <strong>客户端 A</strong> 的连接。</li><li>假设此时进程内最小可用 fd 是 4（因为 0,1,2 被占用，3 是监听 socket），所以 <code>accept</code> 返回 <code>sock = 4</code>。</li><li><code>Accepter</code> 开始查找 <code>fd_array</code> 中的空闲位置：<code>pos = 1</code>: <code>fd_array[1] = -1</code> (defaultfd)。找到空闲位置，<code>break</code>。</li><li><code>pos</code> 不等于 <code>fd_num_max</code>，所以执行 <code>else</code> 分支：<ul><li><code>fd_array[1] = 4</code> (将客户端 A 的 fd 存入数组)。</li><li><code>PrintFd()</code>。</li></ul></li></ul></li><li><p><strong>第二次 <code>Start</code> 循环</strong>：</p><ul><li><code>fd_set readfds</code> 被清空。</li><li>遍历 <code>fd_array</code>：<ul><li><code>i=0</code>: <code>fd_array[0] = 3</code> (监听 socket)。有效，<code>FD_SET(3, &amp;readfds)</code>。<code>maxfds</code> 更新为 3。</li><li><code>i=1</code>: <code>fd_array[1] = 4</code> (客户端 A 的 socket)。有效，<code>FD_SET(4, &amp;readfds)</code>。<code>maxfds</code> 更新为 4。</li><li><code>i=2</code> 到 <code>fd_num_max-1</code>: <code>fd_array[i] = -1</code>。跳过。</li></ul></li><li><code>select(5, &amp;readfds, ...)</code> 被调用，<strong>现在监控 fd 3 和 fd 4</strong>！</li><li>假设现在 <strong>客户端 A</strong> 发送了一条消息 “Hello”。</li><li><code>select</code> 发现 <strong>fd 4</strong> (客户端 A 的 socket) 可读（有数据到达），返回值 &gt; 0。</li><li>进入 <code>Dispatcher(readfds)</code>。</li><li><code>Dispatcher</code> 遍历 <code>fd_array</code>：<ul><li><code>i=0</code>: <code>fd = fd_array[0] = 3</code>。检查 <code>FD_ISSET(3, &amp;readfds)</code>。因为这次是 fd 4 就绪，fd 3 没就绪，所以 <code>FD_ISSET(3, &amp;readfds)</code> 为假。<strong>跳过</strong>。</li><li><code>i=1</code>: <code>fd = fd_array[1] = 4</code>。检查 <code>FD_ISSET(4, &amp;readfds)</code>。因为这次是 fd 4 就绪，所以 <code>FD_ISSET(4, &amp;readfds)</code> 为真。<code>fd (4) != _listensock.Fd()</code> 为真。<strong>进入 <code>else</code> 分支</strong>。</li><li>调用 <code>Recver(4, 1)</code>。<strong><code>Recver</code> 被成功调用了！</strong></li></ul></li></ul></li><li><p><strong><code>Recver</code> 执行</strong>：</p><ul><li><code>Recver</code> 从 fd 4 (客户端 A 的 socket) 读取数据 “Hello”，并处理它（例如打印）。</li></ul></li></ol><p><strong>关键点：</strong></p><ul><li><code>accept</code> 返回的 <strong>不是</strong> 监听 socket 的 fd。它返回的是一个 <strong>全新的、代表新客户端连接的 socket 的 fd</strong>。这个新 fd 会被存储到 <code>fd_array</code> 中。</li><li><code>Start</code> 循环中的 <code>for</code> 循环会 <strong>持续更新</strong> <code>select</code> 监控的 fd 集合 (<code>readfds</code>)。每次循环，它都会将 <code>fd_array</code> 中所有非 <code>-1</code> 的 fd（包括监听 socket 和所有已连接的客户端 socket）都添加到监控集合中。</li><li><code>Dispatcher</code> 循环会 <strong>持续检查</strong> <code>fd_array</code> 中所有非 <code>-1</code> 的 fd，看它们是否在 <code>select</code> 返回的就绪集合 (<code>readfds</code>) 中。</li><li>如果就绪的 fd 是 <strong>监听 socket 的 fd</strong>，说明有新连接，走 <code>Accepter</code>。</li><li>如果就绪的 fd 是 <strong><code>fd_array</code> 中某个已存储的客户端 socket 的 fd</strong>（即 <code>fd != _listensock.Fd()</code>），说明这个特定客户端发送了数据，走 <code>Recver</code>。</li></ul><p><strong><code>Accepter</code> 中查找空闲位置的意义：</strong></p><ul><li><strong><code>fd_array</code></strong> 是服务器用来 <strong>追踪和管理</strong> 所有当前连接（包括监听 socket）的 <strong>本地数据结构</strong>。</li><li><code>accept</code> 返回的 fd 必须被 <strong>记录</strong> 下来，否则服务器就无法知道有哪些客户端连接，也无法监控它们。</li><li>查找空闲位置并存入 <code>fd_array</code>，是为了让 <code>Start</code> 和 <code>Dispatcher</code> 能够 <strong>知道</strong> 这个新连接的存在，并将其加入到 <code>select</code> 的监控范围和事件分发范围中。</li><li><code>if (pos == fd_num_max)</code> 检查是为了防止 <code>fd_array</code> 被填满，实现连接数限制。</li></ul><p><strong>注意：</strong> <code>Recver</code> <strong>非常重要且会被使用</strong>。每当任何一个已连接的客户端发送数据时，<code>select</code> 就会检测到该客户端对应的 fd 就绪，<code>Dispatcher</code> 就会找到该 fd 在 <code>fd_array</code> 中的位置，并调用 <code>Recver</code> 来处理该客户端的数据。<code>fd_array</code> 和 <code>Accepter</code> 的查找逻辑是实现多客户端管理的关键。</p><h3 id="6-快速上手-select-的编写步骤（重要）"><a href="#6-快速上手-select-的编写步骤（重要）" class="headerlink" title="6. 快速上手 select 的编写步骤（重要）"></a>6. 快速上手 <code>select</code> 的编写步骤（重要）</h3><p>想象你是一个 <strong>服务员</strong>，要同时服务多个客户（文件描述符）。</p><ol><li><strong>准备工具</strong>：创建一个 <code>fd_set</code>（想象成一个 <strong>点名册</strong>），清空它 (<code>FD_ZERO</code>)。</li><li><strong>记录客户</strong>：把你需要服务的客户（文件描述符）一个个记到点名册上 (<code>FD_SET</code>)。比如客户 A (fd &#x3D; 3)，客户 B (fd &#x3D; 5)。</li><li><strong>确定范围</strong>：看看你记下的客户里，编号最大的是谁？比如是客户 B (fd &#x3D; 5)。<strong><code>nfds</code> 就是这个最大编号 + 1</strong>，也就是 6。告诉老板（操作系统）：”我要服务编号 0 到 5 的客户”。</li><li><strong>开始观察</strong>：调用 <code>select(6, &amp;点名册, NULL, NULL, NULL)</code>。你开始观察点名册上记录的客户，等待他们有需要（比如按铃表示可读）。</li><li><strong>响应需求</strong>：<code>select</code> 告诉你哪些客户按铃了。你再次查看点名册（<code>FD_ISSET</code>），看具体是哪个客户按的。然后去服务这个客户（比如读取数据）。</li><li><strong>循环往复</strong>：回到第 1 步，继续准备、记录、观察、响应。</li></ol><p><strong>编写步骤：</strong></p><ol><li><strong>初始化</strong>：创建监听 socket，绑定，监听。</li><li><strong>准备容器</strong>：用一个数组（如 <code>fd_array</code>）或链表存储所有要监控的 fd。</li><li><strong>主循环 (<code>Start</code>)</strong>：<ul><li>清空 <code>fd_set</code>。</li><li>遍历你的容器（<code>fd_array</code>），将所有有效 fd (<code>fd != -1</code>) 添加到 <code>fd_set</code> (<code>FD_SET</code>)。</li><li>同时记录这些 fd 中的 <strong>最大值</strong> (<code>maxfd</code>)。</li><li>调用 <code>select(maxfd + 1, &amp;fd_set, ...)</code>.</li></ul></li><li><strong>事件分发 (<code>Dispatcher</code>)</strong>：<ul><li>再次遍历你的容器（<code>fd_array</code>）。</li><li>对于每个有效 fd，用 <code>FD_ISSET(fd, &amp;fd_set)</code> 检查它是否在 <code>select</code> 返回的就绪集合中。</li><li>如果是监听 fd 就绪，调用 <code>Accepter</code>。</li><li>如果是普通连接 fd 就绪，调用 <code>Recver</code> 或相应的处理函数。</li></ul></li><li><strong>处理连接 (<code>Accepter</code>)</strong>：<code>accept</code> 得到新 fd，将其添加到你的容器（<code>fd_array</code>）中。</li><li><strong>处理数据 (<code>Recver</code>)</strong>：读取数据，处理。如果连接断开，从你的容器（<code>fd_array</code>）中移除该 fd（设置为 <code>-1</code>）。</li></ol><p><strong>核心思想</strong>：用一个 <strong>容器</strong>（数组&#x2F;链表）管理所有 fd，用 <code>select</code> <strong>监控</strong> 这个容器里的所有 fd，用 <code>select</code> 的返回结果 <strong>分发</strong> 事件给相应的处理函数。</p><h3 id="7-select-优缺点总结"><a href="#7-select-优缺点总结" class="headerlink" title="7. select 优缺点总结"></a>7. select 优缺点总结</h3><p><strong>优点：</strong></p><ol><li>可同时等待多个文件描述符，提高 IO 利用率。</li><li>“等待”与“操作”分离，IO 操作本身不会被阻塞。</li><li>实现简单，兼容性好，几乎所有平台都支持。</li></ol><p><strong>缺点：</strong></p><ol><li><strong>fd 数量有限</strong>（通常上限 1024）。</li><li><strong>每次调用都要重置 fd 集合</strong>，使用繁琐。</li><li><strong>用户态到内核态频繁拷贝</strong>，开销大。</li><li><strong>内核遍历所有 fd</strong> 检查状态，效率低。</li><li><strong>用户态也需维护 fd 集合</strong>，多次遍历，复杂度高。</li></ol><p>select 能多路等待，但机制老、开销大、扩展性差，设计比较久远，具有局限性，对初学者也并不友好，于是就有了 <strong>Poll 的多路转接方案</strong>，<code>poll</code> 是对 <code>select</code> 的改进版，解决了它的一些局限。</p><h2 id="5-poll-的函数原型"><a href="#5-poll-的函数原型" class="headerlink" title="5. poll 的函数原型"></a>5. poll 的函数原型</h2><h3 id="1-作用-1"><a href="#1-作用-1" class="headerlink" title="1. 作用"></a>1. 作用</h3><blockquote><p><code>poll</code> &#x3D; “用数组替代位图的 select”，功能一样但更方便、无 fd 上限。</p></blockquote><p><code>poll</code> 是比 <code>select</code> 新的 I&#x2F;O 多路复用函数，用来 <strong>同时监控多个文件描述符的可读、可写或异常事件</strong>。功能和 <code>select</code> 一样，但使用方式更简单、限制更少。</p><h3 id="2-函数原型-2"><a href="#2-函数原型-2" class="headerlink" title="2. 函数原型"></a>2. 函数原型</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">poll</span><span class="params">(<span class="keyword">struct</span> pollfd *fds, <span class="type">nfds_t</span> nfds, <span class="type">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="3-参数解释-1"><a href="#3-参数解释-1" class="headerlink" title="3. 参数解释"></a>3. 参数解释</h3><table><thead><tr><th>参数名</th><th>含义</th><th>与 <code>select</code> 对比</th></tr></thead><tbody><tr><td><code>fds</code></td><td>一个 <code>pollfd</code> 结构体数组，每个元素描述一个要监控的 fd</td><td>类似于 <code>readfds</code> &#x2F; <code>writefds</code> &#x2F; <code>exceptfds</code> 三个集合的合并版</td></tr><tr><td><code>nfds</code></td><td>数组中有多少个元素，即可以传入多少个文件描述符</td><td>等价于 <code>select</code> 的 <code>nfds</code>（监控的 fd 数量）</td></tr><tr><td><code>timeout</code></td><td>超时&#x2F;最长等待时间（毫秒）</td><td>功能同 <code>select</code> 的 <code>timeout</code>，只是单位不同（毫秒）</td></tr></tbody></table><h4 id="1-struct-pollfd-结构体"><a href="#1-struct-pollfd-结构体" class="headerlink" title="1. struct pollfd 结构体"></a>1. <code>struct pollfd</code> 结构体</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">pollfd</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span>   fd;        <span class="comment">// 要监控的文件描述符</span></span><br><span class="line">    <span class="type">short</span> events;    <span class="comment">// 想监控哪些事件（输入参数）</span></span><br><span class="line">    <span class="type">short</span> revents;   <span class="comment">// 实际发生的事件（输出参数，由内核填充）</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="2-事件标志（events-和-revents-的取值）"><a href="#2-事件标志（events-和-revents-的取值）" class="headerlink" title="2. 事件标志（events 和 revents 的取值）"></a>2. 事件标志（<code>events</code> 和 <code>revents</code> 的取值）</h4><table><thead><tr><th>事件</th><th>描述</th><th>是否可作为输入</th><th>是否可作为输出</th></tr></thead><tbody><tr><td><strong><code>POLLIN</code></strong></td><td><strong>数据（包括普通数据和优先数据）可读</strong></td><td><strong>是</strong></td><td><strong>是</strong></td></tr><tr><td>POLLRDNORM</td><td>普通数据可读</td><td>是</td><td>是</td></tr><tr><td>POLLRDBAND</td><td>优先级带数据可读（Linux 不支持）</td><td>是</td><td>是</td></tr><tr><td>POLLPRI</td><td>高优先级数据可读，比如 TCP 带外数据</td><td>是</td><td>是</td></tr><tr><td><strong><code>POLLOUT</code></strong></td><td><strong>数据（包括普通数据和优先数据）可写</strong></td><td><strong>是</strong></td><td><strong>是</strong></td></tr><tr><td>POLLWRNORM</td><td>普通数据可写</td><td>是</td><td>是</td></tr><tr><td>POLLWRBAND</td><td>优先级带数据可写</td><td>是</td><td>是</td></tr><tr><td>POLLRDHUP</td><td>TCP 连接被对方关闭，或者对方关闭了写操作，它由 GNU 引入</td><td>是</td><td>是</td></tr><tr><td><strong><code>POLLERR</code></strong></td><td><strong>错误</strong></td><td><strong>否</strong></td><td><strong>是</strong></td></tr><tr><td>POLLHUP</td><td>挂起。比如管道的写端被关闭后，读端描述符上将收到 POLLHUP 事件</td><td>否</td><td>是</td></tr><tr><td><strong><code>POLLNVAL</code></strong></td><td><strong>文件描述符没有打开</strong></td><td><strong>否</strong></td><td><strong>是</strong></td></tr></tbody></table><table><thead><tr><th><strong>常用的事件标志</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td><strong><code>POLLIN</code></strong></td><td><strong>可读（读缓冲区有数据）</strong></td></tr><tr><td><strong><code>POLLOUT</code></strong></td><td><strong>可写（写缓冲区可用）</strong></td></tr><tr><td><strong><code>POLLERR</code></strong></td><td><strong>错误（比如连接异常）</strong></td></tr><tr><td><strong><code>POLLHUP</code></strong></td><td><strong>对端关闭连接（挂断）</strong></td></tr><tr><td><strong><code>POLLNVAL</code></strong></td><td><strong>无效的 fd</strong></td></tr></tbody></table><h4 id="3-超时-最长等待时间（timeout）含义"><a href="#3-超时-最长等待时间（timeout）含义" class="headerlink" title="3. 超时&#x2F;最长等待时间（timeout）含义"></a>3. 超时&#x2F;最长等待时间（timeout）含义</h4><table><thead><tr><th align="center">取值</th><th>含义</th></tr></thead><tbody><tr><td align="center"><code>&gt;0</code></td><td>最多等待指定毫秒数（超时返回 0）</td></tr><tr><td align="center"><code>0</code></td><td>立即返回（非阻塞轮询）</td></tr><tr><td align="center"><code>-1</code></td><td>一直阻塞（直到有事件）</td></tr></tbody></table><h3 id="4-返回值-2"><a href="#4-返回值-2" class="headerlink" title="4. 返回值"></a>4. 返回值</h3><ul><li><strong><code>&gt;0</code>：</strong> 有多少个 fd 就绪。</li><li><strong><code>=0</code>：</strong> 超时。</li><li><strong><code>&lt;0</code>：</strong> 出错。</li></ul><h3 id="5-使用示例-1"><a href="#5-使用示例-1" class="headerlink" title="5. 使用示例"></a>5. 使用示例</h3><blockquote><p>完整代码请前往 <a href="https://github.com/huangcancan-xbc/Linux-Ubuntu/tree/main/Coding/Advanced_IO/poll">GitHub</a> 查看。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Socket.hpp&quot;</span></span></span><br><span class="line"><span class="comment">// #include &quot;Log.hpp&quot;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">uint16_t</span> defaultport = <span class="number">8080</span>;           <span class="comment">// 默认端口号8080</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> fd_num_max = <span class="number">64</span>;                   <span class="comment">// poll数组的最大容量，最多同时监听64个文件描述符</span></span><br><span class="line"><span class="type">int</span> defaultfd = <span class="number">-1</span>;                                 <span class="comment">// 无效文件描述符，用来标识数组中空闲的位置</span></span><br><span class="line"><span class="type">int</span> no_event = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PollServer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">PollServer</span>(<span class="type">uint16_t</span> port = defaultport)</span><br><span class="line">        : _port(port)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; fd_num_max; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            _event_fds[i].fd = defaultfd;           <span class="comment">// 初始化每个位置的fd为-1（表示未使用）</span></span><br><span class="line">            _event_fds[i].events = no_event;        <span class="comment">// 初始化每个位置的监听事件为0（不监听任何事件）</span></span><br><span class="line">            _event_fds[i].revents = no_event;       <span class="comment">// 初始化每个位置的返回事件为0（无事件发生）</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// std::cout &lt;&lt; &quot;fd_array[&quot; &lt;&lt; i &lt;&lt; &quot;]&quot; &lt;&lt; &quot; : &quot; &lt;&lt; fd_array[i] &lt;&lt; std::endl;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">PollServer</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        _listensock.<span class="built_in">Close</span>();                        <span class="comment">// 关闭监听socket</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化服务器：创建socket、绑定端口、开始监听</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _listensock.<span class="built_in">Socket</span>();                       <span class="comment">// 创建监听socket</span></span><br><span class="line">        _listensock.<span class="built_in">Bind</span>(_port);                    <span class="comment">// 绑定端口</span></span><br><span class="line">        _listensock.<span class="built_in">Listen</span>();                       <span class="comment">// 开始监听</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印当前在线的文件描述符列表</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PrintFd</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;在线_fd_列表： &quot;</span>;                  <span class="comment">// 输出提示信息</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; fd_num_max; i++)       <span class="comment">// 遍历_event_fds数组</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (_event_fds[i].fd == defaultfd)     <span class="comment">// 如果是空闲位置（fd为-1），跳过</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            cout &lt;&lt; _event_fds[i].fd &lt;&lt; <span class="string">&quot; &quot;</span>;       <span class="comment">// 输出有效的文件描述符</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Accepter</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 有新的客户端连接请求到来</span></span><br><span class="line">        std::string client_ip;                     <span class="comment">// 客户端的IP</span></span><br><span class="line">        <span class="type">uint16_t</span> client_port;                      <span class="comment">// 客户端的端口</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> sock = _listensock.<span class="built_in">Accept</span>(&amp;client_ip, &amp;client_port);    <span class="comment">// 接收新的客户端连接</span></span><br><span class="line">        <span class="keyword">if</span> (sock &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;                                <span class="comment">// 如果accept失败，直接返回</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">log_</span>(Info, <span class="string">&quot;新连接建立成功：客户端IP：%s，客户端端口：%d，socket fd：%d&quot;</span>, client_ip.<span class="built_in">c_str</span>(), client_port, sock);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Info, 新连接建立成功：客户端IP：&quot;</span> &lt;&lt; client_ip &lt;&lt; <span class="string">&quot;，客户端端口：&quot;</span> &lt;&lt; client_port &lt;&lt; <span class="string">&quot;，socket fd：&quot;</span> &lt;&lt; sock &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将新连接的文件描述符添加到poll数组中</span></span><br><span class="line">        <span class="type">int</span> pos = <span class="number">1</span>;                               <span class="comment">// 从数组索引1开始找空闲位置（索引0存放监听socket）</span></span><br><span class="line">        <span class="keyword">for</span> (; pos &lt; fd_num_max; pos++)            <span class="comment">// 查找数组中空闲的位置</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (_event_fds[pos].fd != defaultfd)   <span class="comment">// 如果当前位置已被占用（fd不为-1），继续找下一个</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>                                   <span class="comment">// 找到空闲位置，跳出循环</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pos == fd_num_max)                     <span class="comment">// 如果遍历完整个数组都没找到空闲位置</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">log_</span>(Warning, <span class="string">&quot;服务器已满，立即关闭%d！&quot;</span>, sock);        <span class="comment">// 服务器连接数已达上限，关闭新连接</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Warning, 服务器已满，立即关闭&quot;</span> &lt;&lt; sock &lt;&lt; <span class="string">&quot;！&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="built_in">close</span>(sock);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// 找到了空闲位置</span></span><br><span class="line">        &#123;</span><br><span class="line">            _event_fds[pos].fd = sock;             <span class="comment">// 将新连接的fd放入数组</span></span><br><span class="line">            _event_fds[pos].events = POLLIN;       <span class="comment">// 设置该fd的监听事件为POLLIN（监听数据可读）</span></span><br><span class="line">            _event_fds[pos].revents = no_event;    <span class="comment">// 清空返回事件</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">PrintFd</span>();                             <span class="comment">// 打印当前在线的fd列表</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 后续可能还有其他处理</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理数据接收的函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Recver</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> pos)</span>                   <span class="comment">// fd是需要读取数据的文件描述符，pos是该fd在数组中的位置</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 接收客户端发送的数据</span></span><br><span class="line">        <span class="type">char</span> buffer[<span class="number">1024</span>];                         <span class="comment">// 临时缓冲区，用于存储接收的数据</span></span><br><span class="line">        <span class="type">ssize_t</span> n = <span class="built_in">read</span>(fd, buffer, <span class="built_in">sizeof</span>(buffer) - <span class="number">1</span>);       <span class="comment">// 从指定fd读取数据到缓冲区，预留1字节给字符串结束符</span></span><br><span class="line">        <span class="keyword">if</span> (n &gt; <span class="number">0</span>)                                 <span class="comment">// 读取到数据</span></span><br><span class="line">        &#123;</span><br><span class="line">            buffer[n] = <span class="string">&#x27;\0&#x27;</span>;                      <span class="comment">// 手动添加字符串结束符</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;收到一条消息：&quot;</span> &lt;&lt; buffer &lt;&lt; endl;          <span class="comment">// 输出接收到的消息</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">0</span>)                           <span class="comment">// 客户端断开连接（读到文件结束符）</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">log_</span>(Info, <span class="string">&quot;客户端退出了，关闭连接的文件描述符是%d&quot;</span>, fd);   <span class="comment">// 记录客户端断开日志</span></span><br><span class="line">            <span class="built_in">close</span>(fd);                             <span class="comment">// 关闭该连接的文件描述符</span></span><br><span class="line">            _event_fds[pos].fd = defaultfd;        <span class="comment">// 将数组中对应位置重置为-1，表示该位置空闲（从poll监听列表中移除该fd）</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>                                       <span class="comment">// 读取错误</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">log_</span>(Warning, <span class="string">&quot;接收文件错误，描述符是: %d&quot;</span>, fd);      <span class="comment">// 记录接收错误日志</span></span><br><span class="line">            <span class="built_in">close</span>(fd);                             <span class="comment">// 关闭该连接的文件描述符</span></span><br><span class="line">            _event_fds[pos].fd = defaultfd;        <span class="comment">// 将数组中对应位置重置为-1，表示该位置空闲（从poll监听列表中移除该fd）</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 事件分发函数：处理所有就绪的事件</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Dispatcher</span><span class="params">()</span>                              <span class="comment">// 遍历poll数组，检查哪些fd的事件已经就绪</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; fd_num_max; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> fd = _event_fds[i].fd;             <span class="comment">// 获取数组中第i个位置的fd</span></span><br><span class="line">            <span class="keyword">if</span> (fd == defaultfd)                   <span class="comment">// 如果是无效fd（-1），跳过</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (_event_fds[i].revents &amp; POLLIN)    <span class="comment">// 如果这个fd的POLLIN事件已经就绪（有数据可读）</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (fd == _listensock.<span class="built_in">Fd</span>())        <span class="comment">// 如果就绪的fd是监听socket</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">Accepter</span>();                    <span class="comment">// 说明有新的连接请求，调用Accepter处理</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>                               <span class="comment">// 如果就绪的fd不是监听socket，而是普通的数据连接socket</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">Recver</span>(fd, i);                 <span class="comment">// 调用Recver处理数据接收</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 服务器主循环：使用poll实现IO多路复用</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Start</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _event_fds[<span class="number">0</span>].fd = _listensock.<span class="built_in">Fd</span>();       <span class="comment">// 把监听socket的fd放到数组的第一个位置</span></span><br><span class="line">        _event_fds[<span class="number">0</span>].events = POLLIN;             <span class="comment">// 监听socket只关心POLLIN事件（新连接请求）</span></span><br><span class="line">        <span class="type">int</span> timeout = <span class="number">3000</span>;                        <span class="comment">// 设置poll超时时间为3000毫秒（3秒），如果3秒内没有事件发生，poll会返回0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;)                                   <span class="comment">// 服务器无限循环，持续监听和处理事件</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> n = <span class="built_in">poll</span>(_event_fds, fd_num_max, timeout);   <span class="comment">// 调用poll等待事件发生</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 根据poll返回值进行处理</span></span><br><span class="line">            <span class="keyword">switch</span> (n)</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="comment">// poll超时处理（timeout时间内没有事件发生）</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;time out, timeout: &quot;</span> &lt;&lt; timeout &lt;&lt; endl;   <span class="comment">// poll超时，没有事件发生</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// poll调用出错处理</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;select error, errno:&quot;</span> &lt;&lt; errno &lt;&lt; endl;    <span class="comment">// poll调用出错</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// poll成功处理（有事件发生）</span></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;得到了一个新的连接请求！&quot;</span> &lt;&lt; endl;           <span class="comment">// poll成功，有事件发生（注意：这里注释可能不准确，有事件发生不一定都是连接请求）</span></span><br><span class="line">                <span class="built_in">Dispatcher</span>();                      <span class="comment">// 调用Dispatcher处理所有就绪的事件</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Sock _listensock;                             <span class="comment">// 监听socket对象</span></span><br><span class="line">    <span class="type">uint16_t</span> _port;                               <span class="comment">// 服务器端口号</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">pollfd</span> _event_fds[fd_num_max];         <span class="comment">// poll需要的数组，存储要监听的fd和事件（结构体数组，数组每一个位置都是结构体）</span></span><br><span class="line">    <span class="comment">// struct pollfd *_event_fds;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// int fd_array[fd_num_max];</span></span><br><span class="line">    <span class="comment">// int wfd_array[fd_num_max];                 // 扩展写事件处理</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="6-poll-小结"><a href="#6-poll-小结" class="headerlink" title="6. poll 小结"></a>6. <code>poll</code> 小结</h3><h4 id="1-poll-的优点"><a href="#1-poll-的优点" class="headerlink" title="1. poll 的优点"></a>1. <code>poll</code> 的优点</h4><ol><li><strong>输入输出参数分离：</strong> <code>struct pollfd</code> 里有 <code>events</code>（输入）和 <code>revents</code>（输出），不像 <code>select</code> 那样每次都要重新设置集合。</li><li><strong>监控数量不限：</strong> 不再受 <code>fd_set</code> 的 1024 比特位限制，想监控多少个 fd，就传多少个 <code>pollfd</code> 元素，具体监控多少个由第二个参数 <code>nfds</code> 决定。</li><li><strong>同时等待多个 fd，提高效率：</strong>“等”的时间可以重叠，IO 效率比阻塞式 IO 高得多。</li></ol><h4 id="2-poll-的缺点"><a href="#2-poll-的缺点" class="headerlink" title="2. poll 的缺点"></a>2. <code>poll</code> 的缺点</h4><ol><li><strong>返回后仍需遍历：</strong> 需要遍历整个 <code>fds</code> 数组，找出哪些 fd 已经就绪。</li><li><strong>用户态与内核态拷贝开销大：</strong> 每次调用都要把整个 <code>pollfd</code> 数组复制进内核，fd 多时性能会明显下降。</li><li><strong>内核仍是线性扫描：</strong> 内核依然要挨个检查每个 fd，就绪检测效率低，当 fd 数量非常大时，性能退化明显。</li></ol><h4 id="3-与-select-的核心区别"><a href="#3-与-select-的核心区别" class="headerlink" title="3. 与 select 的核心区别"></a>3. 与 <code>select</code> 的核心区别</h4><table><thead><tr><th>对比项</th><th><code>select</code></th><th><code>poll</code></th></tr></thead><tbody><tr><td>fd 表达方式</td><td>位图 (<code>fd_set</code>)</td><td>结构体数组 (<code>pollfd[]</code>)</td></tr><tr><td>fd 数量限制</td><td>有（通常 1024）</td><td>理论无限（由系统资源决定）</td></tr><tr><td>参数是否要重置</td><td>每次都要重新设置</td><td>不用重置，只更新有变化的项</td></tr><tr><td>内核检测机制</td><td>遍历所有 fd</td><td>同样遍历，但结构更清晰</td></tr></tbody></table><blockquote><p>  <strong><code>poll</code> 是 <code>select</code> 的改良版，解决了 fd 数量上限和参数重置的问题，但底层依然是“遍历式检测”，性能瓶颈依旧。</strong></p></blockquote>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;高级-IO&quot;&gt;&lt;a href=&quot;#高级-IO&quot; class=&quot;headerlink&quot; title=&quot;高级 IO&quot;&gt;&lt;/a&gt;高级 IO&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a</summary>
        
      
    
    
    
    <category term="Linux" scheme="https://www.minbit.top/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://www.minbit.top/tags/Linux/"/>
    
    <category term="IO" scheme="https://www.minbit.top/tags/IO/"/>
    
  </entry>
  
  <entry>
    <title>055 其他重要协议和技术</title>
    <link href="https://www.minbit.top/posts/48372.html"/>
    <id>https://www.minbit.top/posts/48372.html</id>
    <published>2025-10-12T04:00:00.000Z</published>
    <updated>2025-10-12T04:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="其他重要协议和技术"><a href="#其他重要协议和技术" class="headerlink" title="其他重要协议和技术"></a>其他重要协议和技术</h1><blockquote><p><a href="https://blog.csdn.net/chenlong_cxy/article/details/124788487">DNS 协议、ICMP 协议、NAT 技术 | CSDN</a></p></blockquote><h2 id="1-DNS"><a href="#1-DNS" class="headerlink" title="1. DNS"></a>1. DNS</h2><h3 id="1-DNS-背景与作用"><a href="#1-DNS-背景与作用" class="headerlink" title="1. DNS 背景与作用"></a>1. DNS 背景与作用</h3><blockquote><p>  <strong>DNS（Domain Name System，域名系统）</strong> 是互联网中 <strong>负责把域名转换为 IP 地址</strong> 的系统。人记域名（如 <code>www.baidu.com</code>），机器识别 IP（如 <code>110.242.69.21</code>）。DNS 就是充当这两者之间的“翻译官”。</p></blockquote><p><strong>为什么需要 DNS？</strong></p><ul><li>IP 地址难记、会变动，而域名容易记。</li><li>访问网站、发邮件、请求 API 时都依赖域名解析到具体主机。</li></ul><h3 id="2-域名简介"><a href="#2-域名简介" class="headerlink" title="2. 域名简介"></a>2. 域名简介</h3><p>域名是分层结构（<strong>从右往左层级递减</strong>）：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">www.example.com.</span><br><span class="line">│   │       └── 顶级域（TLD）：.com / .org / .cn / .edu</span><br><span class="line">│   └────────── 二级域（注册主体）：example</span><br><span class="line">└────────────── 主机名（子域）：www（可省略）</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li><strong>根域</strong>：隐藏的 “.”，由全球 13 组根 DNS 服务器管理。</li><li><strong>顶级域（TLD）</strong>：如 <code>.com</code>：商业类；<code>.net</code>：网络服务类；<code>.org</code>：开源组织或非盈利组织。</li><li><strong>二级域</strong>：企业或组织自行注册（如 baidu.com）。</li><li><strong>子域（三级及以下）</strong>：如 <code>www.baidu.com</code>、<code>api.baidu.com</code>。</li></ul><h3 id="3-DNS-解析过程（简化说明）"><a href="#3-DNS-解析过程（简化说明）" class="headerlink" title="3. DNS 解析过程（简化说明）"></a>3. DNS 解析过程（简化说明）</h3><blockquote><p>DNS 查询是一个“从根到叶”的 <strong>分层查找过程</strong>，递归服务器负责一层层问下去，直到拿到最终结果。</p></blockquote><p>假设用户访问 <code>www.baidu.com</code>：</p><ol><li><p><strong>浏览器缓存查询：</strong> 先查本地浏览器缓存，看是否已有 IP。</p></li><li><p><strong>操作系统缓存查询：</strong> 若浏览器无，则查 OS 缓存（Linux 可看 <code>/etc/hosts</code>）。</p></li><li><p><strong>本地 DNS 服务器查询：</strong>（通常是自己所在网络的 DNS，如 8.8.8.8）本地 DNS 会缓存常见记录，若命中则直接返回。</p></li><li><p><strong>递归查询</strong>（若本地 DNS 未命中）：</p><ul><li><p>向 <strong>根 DNS</strong> 请求：谁管 <code>.com</code>？</p></li><li><p>根 DNS 返回顶级域服务器地址。</p></li><li><p>向 <strong>.com 顶级域 DNS</strong> 请求：谁管 <code>baidu.com</code>？</p></li><li><p>返回 <code>baidu.com</code> 的权威 DNS 地址。</p></li><li><p>向 <strong>baidu.com 权威 DNS</strong> 请求：<code>www</code> 的 IP 是多少？</p></li><li><p>最终得到 <code>110.242.69.21</code>。</p></li></ul></li></ol><hr><h3 id="4-dig-工具简介与安装"><a href="#4-dig-工具简介与安装" class="headerlink" title="4. dig 工具简介与安装"></a>4. <code>dig</code> 工具简介与安装</h3><blockquote><p><code>dig</code>（Domain Information Groper）是 DNS 调试利器，用于查询域名解析信息。<a href="https://www.imooc.com/article/26971?block_id=tuijian_wz">linux dig 命令使用方法 | 慕课网</a>。</p></blockquote><p>安装命令：</p><h4 id="1-CentOS-7-6"><a href="#1-CentOS-7-6" class="headerlink" title="1. CentOS 7.6"></a>1. CentOS 7.6</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> yum install bind-utils -y</span><br></pre></td></tr></table></figure><h4 id="2-Ubuntu-22-04"><a href="#2-Ubuntu-22-04" class="headerlink" title="2. Ubuntu 22.04"></a>2. Ubuntu 22.04</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt install dnsutils -y</span><br></pre></td></tr></table></figure><hr><h3 id="5-浏览器输入-URL-后发生的事情（核心）"><a href="#5-浏览器输入-URL-后发生的事情（核心）" class="headerlink" title="5. 浏览器输入 URL 后发生的事情（核心）"></a>5. 浏览器输入 URL 后发生的事情（核心）</h3><blockquote><p><strong>整体流程可以概括为五个阶段：输入域名 → DNS 解析 → 建立连接 → 请求响应 → 页面渲染。其中 DNS 是从域名到 IP 的入口，TCP 是可靠通信的保障，HTTP&#x2F;HTTPS 是传输层的协议规范，最后浏览器负责把字节变成视觉结果。</strong></p><p><a href="https://blog.csdn.net/wuhenliushui/article/details/20038819/">当你在浏览器地址栏输入一个 URL 后回车，将会发生的事情？ | CSDN</a></p></blockquote><ol><li><p>DNS 解析：浏览器 → 操作系统 → 本地 DNS→ 根 →TLD→ 权威 DNS → 得到服务器 IP。</p></li><li><p>建立 TCP 连接：通过三次握手（SYN → SYN+ACK → ACK）。若是 HTTPS，会在 TCP 之后进行 <strong>TLS 握手</strong>（证书校验 + 加密协商）。</p></li><li><p>发送 HTTP 请求：浏览器发出请求报文：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>www.baidu.com</span><br></pre></td></tr></table></figure></li><li><p>服务器处理请求：Web 服务器（如 Nginx）解析请求，调用后端逻辑，生成响应。</p></li><li><p>返回 HTTP 响应：返回状态码、响应头、HTML 正文等。</p></li><li><p>浏览器渲染页面</p><ul><li>解析 HTML → 构建 DOM 树。</li><li>解析 CSS → 构建 CSSOM 树。</li><li>执行 JS、合成渲染树、布局、绘制页面。</li></ul></li><li><p>建立持久连接（Keep-Alive）：用于减少后续请求的延迟。</p></li></ol><hr><h2 id="2-ICMP-协议"><a href="#2-ICMP-协议" class="headerlink" title="2. ICMP 协议"></a>2. ICMP 协议</h2><blockquote><p><strong>ICMP 是 IP 协议的辅助协议，主要用于网络诊断与错误报告。常见命令有 ping（检测连通性）和 traceroute（追踪路由路径）。ICMP 不属于传输层，没有端口号，而是直接封装在 IP 报文中。它让网络具备了‘自我反馈’能力，帮助发现问题所在。</strong></p></blockquote><h3 id="1-ICMP-是什么？"><a href="#1-ICMP-是什么？" class="headerlink" title="1. ICMP 是什么？"></a>1. ICMP 是什么？</h3><p><strong>ICMP（Internet Control Message Protocol）是 IP 协议的“信使”，负责在主机和路由器之间传递网络错误与状态信息。它不传输用户数据，只传递“控制消息”，用来检测、诊断和报告网络问题。</strong></p><h3 id="2-ICMP-的位置和关系"><a href="#2-ICMP-的位置和关系" class="headerlink" title="2. ICMP 的位置和关系"></a>2. ICMP 的位置和关系</h3><table><thead><tr><th>层级</th><th>常见协议</th></tr></thead><tbody><tr><td>应用层</td><td>HTTP、DNS</td></tr><tr><td>传输层</td><td>TCP、UDP</td></tr><tr><td>网络层</td><td>IP、ICMP、IGMP</td></tr><tr><td>数据链路层</td><td>MAC 帧、ARP、RARP</td></tr></tbody></table><p>ICMP 属于 <strong>网络层协议</strong>，但它是 <strong>IP 的上层协议</strong>（使用 IP 封装），IP 报文中 <code>Protocol 字段 = 1</code> 时，就表示这是一个 <strong>ICMP 报文</strong>。类比理解：</p><ul><li><strong>IP：送快递的司机。</strong></li><li><strong>ICMP：告诉司机“路堵了 &#x2F; 地址不存在 &#x2F; 包送到了”的消息员。</strong></li></ul><h3 id="3-ICMP-的功能"><a href="#3-ICMP-的功能" class="headerlink" title="3. ICMP 的功能"></a>3. ICMP 的功能</h3><ol><li><p><strong>错误报告：</strong> → 通知发送方网络中出现的问题。常见错误：</p><ul><li><p>目标不可达（Destination Unreachable）</p></li><li><p>超时（Time Exceeded）</p></li><li><p>重定向（Redirect）</p></li></ul></li><li><p><strong>诊断查询：</strong> → 用于检测网络状态，典型命令：<code>ping</code>、<code>traceroute</code>。</p></li></ol><h3 id="4-ICMP-常见类型"><a href="#4-ICMP-常见类型" class="headerlink" title="4. ICMP 常见类型"></a>4. ICMP 常见类型</h3><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20251010134038655.png" alt="PixPin_2025-10-10_13-40-34"></p><p>我们记几个关键的就行：</p><table><thead><tr><th>类型值</th><th>含义</th><th>应用场景</th></tr></thead><tbody><tr><td>0</td><td>Echo Reply</td><td>ping 回复</td></tr><tr><td>3</td><td>Destination Unreachable</td><td>目标不可达</td></tr><tr><td>5</td><td>Redirect</td><td>路由重定向</td></tr><tr><td>8</td><td>Echo Request</td><td>ping 请求</td></tr><tr><td>11</td><td>Time Exceeded</td><td>TTL 超时（用于 traceroute）</td></tr></tbody></table><h3 id="5-ICMP-报文格式（了解）"><a href="#5-ICMP-报文格式（了解）" class="headerlink" title="5. ICMP 报文格式（了解）"></a>5. ICMP 报文格式（了解）</h3><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20251010134259972.png" alt="PixPin_2025-10-10_13-42-56"></p><table><thead><tr><th>字段</th><th>说明</th></tr></thead><tbody><tr><td>Type</td><td>报文类型（例如 8 表示 Echo Request）</td></tr><tr><td>Code</td><td>进一步说明原因</td></tr><tr><td>Checksum</td><td>校验和</td></tr><tr><td>其他字段</td><td>根据类型不同变化</td></tr></tbody></table><hr><h3 id="6-两个典型工具：Ping-与-Traceroute"><a href="#6-两个典型工具：Ping-与-Traceroute" class="headerlink" title="6. 两个典型工具：Ping 与 Traceroute"></a>6. 两个典型工具：Ping 与 Traceroute</h3><h4 id="1-ping-命令工作流程"><a href="#1-ping-命令工作流程" class="headerlink" title="1. ping 命令工作流程"></a>1. ping 命令工作流程</h4><ol><li><code>ping www.baidu.com</code>。</li><li>DNS 解析 → <code>110.242.69.21</code>。</li><li>构造 IP 包：<code>Protocol=1</code>，ICMP 头 <code>Type=8</code>。</li><li>发送 → 目标主机收到后，<strong>自动返回 <code>Type=0</code></strong>。</li><li>统计：往返时间（RTT）、TTL、丢包率。</li></ol><blockquote><p><strong>常见面试陷阱：Q: ping 使用哪个端口？</strong><br><strong>A: 没有端口！ICMP 工作在网络层，绕过 TCP&#x2F;UDP，不涉及端口号。</strong></p></blockquote><h4 id="2-traceroute-命令"><a href="#2-traceroute-命令" class="headerlink" title="2. traceroute 命令"></a>2. traceroute 命令</h4><p><strong>功能：</strong> 追踪数据包经过的路径（每一跳路由器），也是基于 ICMP 协议实现，能够打印出可执行程序主机，一直到目标主机之前经历多少路由器。</p><p><strong>工作原理：</strong> 发送多个 IP 包，从 <code>TTL=1</code> 开始逐步递增，每经过一个路由器，TTL 就减 1，当 TTL 减为 0 时，该路由器丢弃包并返回 <code>ICMP Time Exceeded</code>，traceroute 收集所有返回的 IP → 得出路径。</p><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">traceroute www.baidu.com</span><br></pre></td></tr></table></figure><p>返回：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">root@hcss-ecs-be68:~# traceroute www.baidu.com</span><br><span class="line">traceroute to www.baidu.com (180.101.51.73), 30 hops max, 60 byte packets</span><br><span class="line"> 1  * * *</span><br><span class="line"> 2  * * *</span><br><span class="line"> 3  * * *</span><br><span class="line"> 4  * * *</span><br><span class="line"> 5  11.87.210.128 (11.87.210.128)  1.183 ms 11.87.111.128 (11.87.111.128)  1.284 ms 11.87.210.134 (11.87.210.134)  1.694 ms</span><br><span class="line"> 6  * * *</span><br><span class="line"> 7  * * *</span><br><span class="line"> 8  * * *</span><br><span class="line"> 9  172.16.65.70 (172.16.65.70)  3.104 ms  3.306 ms 180.163.107.161 (180.163.107.161)  4.342 ms</span><br><span class="line">10  180.163.107.177 (180.163.107.177)  3.115 ms  3.309 ms 101.95.246.65 (101.95.246.65)  4.649 ms</span><br><span class="line">11  101.95.224.125 (101.95.224.125)  5.762 ms 101.95.226.245 (101.95.226.245)  5.271 ms 101.95.219.21 (101.95.219.21)  4.961 ms</span><br><span class="line">12  * 101.95.219.65 (101.95.219.65)  4.649 ms 202.97.52.222 (202.97.52.222)  10.990 ms</span><br><span class="line">13  58.213.95.214 (58.213.95.214)  26.524 ms 202.97.101.54 (202.97.101.54)  7.736 ms 180.110.207.18 (180.110.207.18)  10.984 ms</span><br><span class="line">14  * * *</span><br><span class="line">15  58.213.96.50 (58.213.96.50)  10.689 ms * *</span><br><span class="line">16  * * *</span><br><span class="line">17  * * *</span><br><span class="line">18  * * *</span><br><span class="line">19  * * *</span><br><span class="line">20  * * *</span><br><span class="line">21  * * *</span><br><span class="line">22  * * *</span><br><span class="line">23  * * *</span><br><span class="line">24  * * *</span><br><span class="line">25  * * *</span><br><span class="line">26  * * *</span><br><span class="line">27  * * *</span><br><span class="line">28  * * *</span><br><span class="line">29  * * *</span><br><span class="line">30  * * *</span><br></pre></td></tr></table></figure><p>解释：</p><ul><li>1-4 跳：均显示 * * *，表示这些跳数的路由器未返回响应（可能因防火墙屏蔽或网络配置限制）。</li><li>第 5 跳：首次出现响应的节点（11.87.210.128 等），延迟约 1-1.7 毫秒，推测为本地网络内部的网关或交换机。</li><li>第 9-13 跳：连续出现响应的节点（如 172.16.65.70、180.163.107.161 等），延迟逐渐增加到 26 毫秒左右，这些是运营商骨干网的路由节点，逐步向百度服务器靠近。</li><li>14-30 跳：再次出现连续 * * *，说明到达目标前的最后几跳路由未响应，或目标服务器本身不返回 ICMP 响应。</li></ul><p>网络路径在经过 13 跳后未能完全到达目标服务器（百度可能屏蔽了追踪响应），前几跳的屏蔽通常是网络安全策略导致，属于正常现象，从响应节点的延迟来看，本地网络到运营商骨干网的连接正常（延迟较低）。</p><hr><h2 id="3-NAT-技术"><a href="#3-NAT-技术" class="headerlink" title="3. NAT 技术"></a>3. NAT 技术</h2><blockquote><p><a href="https://www.bilibili.com/video/BV1TK3YzmEJx/?share_source=copy_web&vd_source=872e5e3ccf44874c39edaf42e30ab0de">NAT(网络地址转换)是什么？一个视频带你看懂它 | B 站</a></p><p>[[网络知识] NAT 是什么？它有什么作用？一个视频带你了解清楚 NAT！ | B 站](<a href="https://www.bilibili.com/video/BV1rN89zCE1r/?share_source">https://www.bilibili.com/video/BV1rN89zCE1r/?share_source</a> &#x3D; copy_web&amp;vd_source &#x3D; 872e5e3ccf44874c39edaf42e30ab0de)</p><p><a href="https://www.bilibili.com/video/BV11M4y1J7zP/?share_source=copy_web&vd_source=872e5e3ccf44874c39edaf42e30ab0de">【虚拟机网络模式】NAT | NAT 网络 | 桥接 Bridged | 内部网络 Internal | 仅主机(Host-Only) | B 站</a></p></blockquote><blockquote><p><strong>摘自《趣味网络图解 —— 从基础到应用》46 页：</strong></p><ul><li>IPv4 地址有限，但通过 NAT 路由器，可以使得整个内网的多台机器对外只使用一个公网 IP 地址，大大节省了 IP 地址资源。</li><li>内网机器主动连接公网 IP 地址，中间的 NAT 会将内网机器的内网 IP 地址转换为公网 IP 地址，从而实现内网和外网的数据交互。</li><li>普通的 NAT 技术只会修改网络包中的发送端和接收端 IP 地址，当内网设备较多时，将有可能导致冲突。因此一般会使用 NAPT 技术，同时修改发送端和接收端的 <strong>IP 地址和端口</strong>。</li><li>由于 NAT 的存在，公网 IP 地址是无法访问内网服务的，但通过内网穿透技术，就可以让公网 IP 地址访问内网服务。一拨操作下来，就可以在公司的网络里访问家里的计算机。</li></ul></blockquote><h3 id="1-NAT-技术背景"><a href="#1-NAT-技术背景" class="headerlink" title="1. NAT 技术背景"></a>1. NAT 技术背景</h3><h4 id="1-问题来源"><a href="#1-问题来源" class="headerlink" title="1. 问题来源"></a>1. 问题来源</h4><p>IPv4 的地址是 32 位，最多支持约 43 亿个地址，随着网络设备爆炸式增长，公网 IP 远远不够用。</p><h4 id="2-解决思路"><a href="#2-解决思路" class="headerlink" title="2. 解决思路"></a>2. 解决思路</h4><p><strong>NAT（Network Address Translation，网络地址转换）：通过 “让多个内网设备共享一个公网 IP 上网”，解决 IP 不足问题。简单说：NAT 就是让一整个局域网看起来像只有一台主机在上网。</strong></p><h4 id="3-关键前提"><a href="#3-关键前提" class="headerlink" title="3. 关键前提"></a>3. 关键前提</h4><ul><li><strong>私有 IP</strong>：仅内网有效（如 <code>192.168.x.x</code>），可重复使用。</li><li><strong>公网 IP</strong>：全球唯一，由 ISP 分配。</li></ul><blockquote><p>  <strong>本质</strong>：NAT 是 <strong>IPv4 时代的“地址复用”技术</strong>，不是协议升级，而是“ workaround”。 </p></blockquote><h4 id="4-补充价值"><a href="#4-补充价值" class="headerlink" title="4. 补充价值"></a>4. 补充价值</h4><p>除了节省公网 IP，NAT 还能：</p><ul><li><strong>隐藏内网结构</strong>（提升安全性）。</li><li><strong>阻止外部主动访问内网主机</strong>（除非端口映射）。</li></ul><hr><h3 id="2-NAT-IP-转换过程（理解核心）"><a href="#2-NAT-IP-转换过程（理解核心）" class="headerlink" title="2. NAT IP 转换过程（理解核心）"></a>2. NAT IP 转换过程（理解核心）</h3><p>假设局域网有三台主机：A、B、C，它们都通过一台 <strong>NAT 路由器</strong> 上网。</p><h4 id="1-局域网-→-公网（出站）"><a href="#1-局域网-→-公网（出站）" class="headerlink" title="1. 局域网 → 公网（出站）"></a>1. 局域网 → 公网（出站）</h4><table><thead><tr><th>阶段</th><th>源 IP</th><th>目的 IP</th><th>说明</th></tr></thead><tbody><tr><td>主机 A 发包</td><td>192.168.1.10</td><td>8.8.8.8</td><td>源为私有 IP</td></tr><tr><td>路由器 NAT 转换</td><td><strong>203.0.113.5</strong></td><td>8.8.8.8</td><td>源地址改为路由器公网 IP</td></tr><tr><td>公网传输</td><td>203.0.113.5</td><td>8.8.8.8</td><td>已是公网间通信</td></tr></tbody></table><h4 id="2-公网-→-局域网（入站）"><a href="#2-公网-→-局域网（入站）" class="headerlink" title="2. 公网 → 局域网（入站）"></a>2. 公网 → 局域网（入站）</h4><table><thead><tr><th>阶段</th><th>源 IP</th><th>目的 IP</th><th>说明</th></tr></thead><tbody><tr><td>服务器发回</td><td>8.8.8.8</td><td><strong>203.0.113.5</strong></td><td>目标为 NAT 公网 IP</td></tr><tr><td>路由器查表</td><td>8.8.8.8</td><td>192.168.1.10</td><td>查 NAT 表反向转换</td></tr><tr><td>转发给主机 A</td><td>8.8.8.8</td><td>192.168.1.10</td><td>主机 A 收到数据</td></tr></tbody></table><blockquote><p>  NAT 路由器维护一张 “转换表”，记录了私网 IP ↔ 公网 IP 的映射关系。</p></blockquote><h3 id="3-NAPT（端口转换）-——-NAT-的升级版"><a href="#3-NAPT（端口转换）-——-NAT-的升级版" class="headerlink" title="3. NAPT（端口转换） —— NAT 的升级版"></a>3. NAPT（端口转换） —— NAT 的升级版</h3><h4 id="1-为什么需要-NAPT？"><a href="#1-为什么需要-NAPT？" class="headerlink" title="1. 为什么需要 NAPT？"></a>1. 为什么需要 NAPT？</h4><p>如果 A、B 两台主机同时访问同一个公网服务器：它们的源 IP 都被改成了同一个公网 IP（NAT 路由器的 IP），服务器返回时，路由器无法区分响应该转给谁，于是需要引入端口号。</p><h4 id="2-核心思路：IP-端口共同唯一标识一次通信"><a href="#2-核心思路：IP-端口共同唯一标识一次通信" class="headerlink" title="2. 核心思路：IP + 端口共同唯一标识一次通信"></a>2. 核心思路：IP + 端口共同唯一标识一次通信</h4><table><thead><tr><th>局域网主机</th><th>源 IP: 端口</th><th>映射后公网 IP: 端口</th></tr></thead><tbody><tr><td>主机 A</td><td>192.168.1.10:1025</td><td>203.0.113.5:1025</td></tr><tr><td>主机 B</td><td>192.168.1.11:1025</td><td>203.0.113.5:1026</td></tr></tbody></table><p>当服务器返回时：数据包目的地址 &#x3D; <code>203.0.113.5</code>，端口号 &#x3D; 1025 或 1026，路由器查表即可知道数据属于谁。这样既能让多台主机共享一个公网 IP，又能通过端口区分不同连接。</p><h3 id="4-NAT-技术的缺陷"><a href="#4-NAT-技术的缺陷" class="headerlink" title="4. NAT 技术的缺陷"></a>4. NAT 技术的缺陷</h3><ul><li><strong>无法从外网主动访问内网主机：</strong> 因为公网只看到 NAT 的一个 IP，不知道内部真实 IP，如果想访问内部服务器，需做“端口映射”。</li><li><strong>转换表有性能消耗：</strong> 每个连接都要建立 &#x2F; 查找 &#x2F; 维护映射表。</li><li><strong>连接中断问题：</strong> NAT 路由器重启或切换时，表清空 → 所有 TCP 连接断开。</li><li><strong>破坏端到端原则：</strong> 原本 IP 层应是“点到点”通信，NAT 插入其中，导致某些协议（如 P2P、IPsec）无法直接使用。</li></ul><h3 id="5-内网穿透"><a href="#5-内网穿透" class="headerlink" title="5. 内网穿透"></a>5. 内网穿透</h3><blockquote><p><a href="https://www.bilibili.com/video/BV1FV4xz9EPt/?share_source=copy_web&vd_source=872e5e3ccf44874c39edaf42e30ab0de">使用云服务器搭建内网穿透！纵享独属于个人的丝滑体验！| B 站</a></p></blockquote><p>内网穿透就是把位于私有网络、被 NAT 隐藏的内网服务暴露到公网，从而让公网客户端能访问内网主机。常见方法有端口映射、VPN、点对点打洞和中继&#x2F;反向代理等。NAT 把内网地址隐藏在路由器后面，若无公网地址或无端口映射，外部无法主动连入，内网穿透要么打洞（利用 NAT 的出站连接建立返向通路），要么中继&#x2F;代理（内网主动连到公网服务器，由公网服务器转发流量）。常见技术分类：</p><ul><li>端口映射&#x2F;端口转发：在路由器上手动映射端口。最简单但需路由器权限。</li><li>UDP&#x2F;TCP Hole Punching（打洞）：借助公服协调，让双方同时发起出站连接实现直连。适用于对称 NAT 以外的场景，不保证总能成功。</li><li>VPN &#x2F; 专线：把内网主机加入到公网可路由的虚拟网段，复杂但稳定。</li><li>中继&#x2F;反向代理（Relay&#x2F;Reverse Proxy）：内网客户端主动与公网中继服建立长连接，公网客户端连中继服由中继转发到内网。最稳健但需要公网服务器带宽。</li></ul><blockquote><p><strong>HTTP 隧道技术</strong>：在 HTTP 请求正文中携带加密的有效载荷数据，绕过运营商检测，实现外网访问，响应也进行加密处理后返回，还可套着 HTTP 壳子携带其他数据，如游戏数据。</p></blockquote><hr><h3 id="6-NAT-与代理服务器的区别（很容易混淆）"><a href="#6-NAT-与代理服务器的区别（很容易混淆）" class="headerlink" title="6. NAT 与代理服务器的区别（很容易混淆）"></a>6. NAT 与代理服务器的区别（很容易混淆）</h3><table><thead><tr><th>对比维度</th><th>NAT</th><th>代理服务器（Proxy）</th></tr></thead><tbody><tr><td>工作层次</td><td>网络层</td><td>应用层</td></tr><tr><td>处理对象</td><td>IP、端口</td><td>应用数据（HTTP、FTP 等）</td></tr><tr><td>主要目的</td><td>节省 IP、隐藏内网</td><td>缓存、访问控制、负载均衡</td></tr><tr><td>部署位置</td><td>路由器、防火墙设备</td><td>软件部署在服务器上</td></tr><tr><td>示例</td><td>家用无线路由器</td><td>Nginx、Squid、Apache</td></tr><tr><td>连接方向</td><td>双向透明</td><td>客户端或服务器主动配置</td></tr><tr><td>是否缓存内容</td><td>否</td><td>可缓存网页、资源</td></tr></tbody></table><blockquote><p>  <strong>NAT 是 IP 层的代理，Proxy 是 应用层的代理。</strong></p></blockquote><hr><h3 id="7-正向代理-vs-反向代理"><a href="#7-正向代理-vs-反向代理" class="headerlink" title="7. 正向代理 vs 反向代理"></a>7. 正向代理 vs 反向代理</h3><blockquote><p><strong>正向代理原理</strong>：利用国内可访问外网的服务器，将请求交给该服务器，经外网访问目标服务器，再将响应返回，服务器充当正向代理角色。</p></blockquote><h4 id="1-正反向代理"><a href="#1-正反向代理" class="headerlink" title="1. 正反向代理"></a>1. 正反向代理</h4><table><thead><tr><th>类型</th><th>位置</th><th>谁在用</th><th>作用</th></tr></thead><tbody><tr><td>正向代理</td><td>客户端侧</td><td>客户端搭建</td><td>访问受限网站、缓存内容</td></tr><tr><td>反向代理</td><td>服务端侧</td><td>服务端搭建</td><td>负载均衡、安全防护（如 Nginx）</td></tr></tbody></table><ul><li><p><strong>正向代理</strong>：<strong>客户端</strong> 用的（如公司上网代理，帮用户访问服务器）→ 隐藏客户端。</p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20251010164447854.png" alt="PixPin_2025-10-10_16-44-42"></p></li><li><p><strong>反向代理</strong>：<strong>服务端</strong> 用的（如帮服务器服务用户：Nginx 做负载均衡）→ 隐藏服务器。</p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20251010164542739.png" alt="PixPin_2025-10-10_16-45-37"></p></li></ul><h4 id="2-FRP-的介绍"><a href="#2-FRP-的介绍" class="headerlink" title="2. FRP 的介绍"></a>2. FRP 的介绍</h4><p><a href="https://github.com/fatedier/frp">FRP</a>（Fast Reverse Proxy）属于 <strong>反向代理 &#x2F; 中继型内网穿透工具</strong>。主要特点：分为 <code>frps</code>（部署在有公网 IP 的服务器）和 <code>frpc</code>（部署在内网主机），内网的 <code>frpc</code> 主动与 <code>frps</code> 建立并维持长连接，公网客户端连接 <code>frps</code> 的某个公网端口或域名，<code>frps</code> 将流量通过已建立的连接反向代理到对应的 <code>frpc</code>，支持 TCP&#x2F;UDP&#x2F;http&#x2F;https&#x2F;websocket 等协议和多路复用。</p><p>注意：FRP 不是纯打洞工具，它通过“内网发起出站连接到公服，然后公服中转”来实现穿透，适合不能修改路由器或无法打洞的场景。</p><h4 id="3-FRP-的工作流程（简短步骤）"><a href="#3-FRP-的工作流程（简短步骤）" class="headerlink" title="3. FRP 的工作流程（简短步骤）"></a>3. FRP 的工作流程（简短步骤）</h4><ol><li>在公网主机运行 <code>frps</code>，监听公网端口。</li><li>在内网主机运行 <code>frpc</code>，主动与 <code>frps</code> 建立持久连接并注册要暴露的服务。</li><li>公网用户访问 <code>frps</code> 的公网端口。</li><li><code>frps</code> 把流量通过 <code>frpc</code> 的长连接转发到内网服务。</li></ol><hr><h2 id="4-网络协议总结"><a href="#4-网络协议总结" class="headerlink" title="4. 网络协议总结"></a>4. 网络协议总结</h2><h3 id="1-应用层"><a href="#1-应用层" class="headerlink" title="1. 应用层"></a>1. 应用层</h3><ul><li>应用层的作用：负责应用程序间沟通，完成一系列业务处理所需服务。</li><li>能够根据自己的需求，设计对应的应用层协议。</li><li>了解 HTTP 协议。</li><li>理解 DNS 的原理和工作流程。</li></ul><h3 id="2-传输层"><a href="#2-传输层" class="headerlink" title="2. 传输层"></a>2. 传输层</h3><ul><li>传输层的作用：负责为两个网络通信进程之间的通信提供服务，更多的是为数据的传输提供一些策略。</li><li>理解端口号的概念。</li><li>认识 TCP 协议，理解 TCP 协议的可靠性，理解 TCP 协议的状态转化。</li><li>掌握 TCP 的连接管理、确认应答、超时重传、滑动窗口、流量控制、拥塞控制、延迟应答、捎带应答特性。</li><li>理解 TCP 面向字节流，理解粘包问题和解决方案。</li><li>能够基于 UDP 实现可靠传输。</li><li>理解 MTU 对 UDP&#x2F;TCP 的影响。</li></ul><h3 id="3-网络层"><a href="#3-网络层" class="headerlink" title="3. 网络层"></a>3. 网络层</h3><ul><li>网络层的作用：在复杂的网络环境中确定一条合适的路径。</li><li>理解 IP 地址，理解 IP 地址和 MAC 地址的区别。</li><li>理解 IP 协议格式。</li><li>理解如何解决 IP 数目不足的问题，掌握网段划分的两种方案，理解私有 IP 和公网 IP。</li><li>理解网络层的 IP 地址路由过程，理解一个数据包如何跨网段到达最终目的地。</li><li>理解 IP 数据包分片的原因。</li><li>了解 ICMP 协议。</li><li>了解 NAT 设备的工作原理。</li></ul><h3 id="4-数据链路层"><a href="#4-数据链路层" class="headerlink" title="4. 数据链路层"></a>4. 数据链路层</h3><ul><li>数据链路层的作用：负责局域网内两个设备之间的数据传递。</li><li>理解以太网通信原理</li><li>以太网帧格式。</li><li>理解 MAC 地址。</li><li>理解 ARP 协议。</li><li>理解 MTU。</li></ul>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;其他重要协议和技术&quot;&gt;&lt;a href=&quot;#其他重要协议和技术&quot; class=&quot;headerlink&quot; title=&quot;其他重要协议和技术&quot;&gt;&lt;/a&gt;其他重要协议和技术&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a</summary>
        
      
    
    
    
    <category term="Linux" scheme="https://www.minbit.top/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://www.minbit.top/tags/Linux/"/>
    
    <category term="网络" scheme="https://www.minbit.top/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>03 库的操作</title>
    <link href="https://www.minbit.top/posts/19289.html"/>
    <id>https://www.minbit.top/posts/19289.html</id>
    <published>2025-10-10T16:00:00.000Z</published>
    <updated>2025-10-11T02:10:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="库的操作"><a href="#库的操作" class="headerlink" title="库的操作"></a>库的操作</h1><h2 id="1-创建数据库"><a href="#1-创建数据库" class="headerlink" title="1. 创建数据库"></a>1. 创建数据库</h2><h3 id="1-语法格式"><a href="#1-语法格式" class="headerlink" title="1. 语法格式"></a>1. 语法格式</h3><p><code>CREATE DATABASE</code> 用于在 MySQL 中创建新的数据库，可以同时指定字符集（编码格式）和校验规则。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE [IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] 数据库名 [<span class="keyword">DEFAULT</span> <span class="keyword">CHARACTER SET</span> 字符集名] [<span class="keyword">DEFAULT</span> <span class="keyword">COLLATE</span> 校验规则];</span><br><span class="line"><span class="keyword">CREATE</span> DATABASE [IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] 数据库名 [[<span class="keyword">DEFAULT</span>] CHARSET<span class="operator">=</span>字符集名] [[<span class="keyword">DEFAULT</span>] <span class="keyword">COLLATE</span><span class="operator">=</span>校验规则];</span><br></pre></td></tr></table></figure><blockquote><p><strong>其中带 <code>[]</code> 表示可选项，不写就会自动选择默认的配置。sql 语句也可以使用小写，会自动识别！在之后的讲解中，我会尽量使用多种写法来展示同一条 sql 语句的效果。</strong></p></blockquote><p><strong>参数详解：</strong></p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>IF NOT EXISTS</code></td><td>如果没有就创建，如果已有同名的则报错：提示无法创建，因为已存在</td></tr><tr><td><code>DEFAULT CHARACTER SET</code></td><td>指定数据库的默认字符集（如 utf8、utf8mb4 等）</td></tr><tr><td><code>DEFAULT COLLATE</code></td><td>指定校验规则，即字符串比较、排序方式</td></tr><tr><td><code>数据库名</code></td><td>自定义的新数据库名称</td></tr></tbody></table><blockquote><p>  注：字符集决定存储文字的编码方式；校验规则决定字符串的比较方式。例如 <code>utf8_general_ci</code> 表示 utf8 字符集下，比较时不区分大小写（ci &#x3D; case insensitive）。</p></blockquote><h3 id="2-采用默认编码格式和校验规则创建数据库"><a href="#2-采用默认编码格式和校验规则创建数据库" class="headerlink" title="2. 采用默认编码格式和校验规则创建数据库"></a>2. 采用默认编码格式和校验规则创建数据库</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE test;# 创建一个名为 test 的库，对应 <span class="operator">/</span>var<span class="operator">/</span>lib<span class="operator">/</span>mysql<span class="operator">/</span> 下的 test 文件夹 </span><br></pre></td></tr></table></figure><p>使用 MySQL 配置文件中默认的字符集与校验规则，根据我们的配置会自动选择 <code>utf8mb4</code> 和 <code>utf8mb4_general_ci</code>。</p><h3 id="3-指定-UTF-8-编码格式创建数据库"><a href="#3-指定-UTF-8-编码格式创建数据库" class="headerlink" title="3. 指定 UTF-8 编码格式创建数据库"></a>3. 指定 UTF-8 编码格式创建数据库</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE mydb_utf8 <span class="keyword">DEFAULT</span> <span class="keyword">CHARACTER SET</span> utf8;</span><br><span class="line"><span class="keyword">create</span> database mydb_utf8 charset<span class="operator">=</span>utf8;</span><br><span class="line"># 创建一个名为 mydb_utf8 的库，并设置默认字符集为 utf8，对应 <span class="operator">/</span>var<span class="operator">/</span>lib<span class="operator">/</span>mysql<span class="operator">/</span> 下的 mydb_utf8 文件夹</span><br></pre></td></tr></table></figure><p>仅指定字符集为 <code>utf8</code>，校验规则会自动采用该字符集的默认规则（即 <code>utf8_general_ci</code>）。</p><h3 id="4-指定-UTF-8-编码格式与校验规则创建数据库"><a href="#4-指定-UTF-8-编码格式与校验规则创建数据库" class="headerlink" title="4. 指定 UTF-8 编码格式与校验规则创建数据库"></a>4. 指定 UTF-8 编码格式与校验规则创建数据库</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE test1 <span class="keyword">DEFAULT</span> <span class="keyword">CHARACTER SET</span> utf8 <span class="keyword">DEFAULT</span> <span class="keyword">COLLATE</span> utf8_general_ci;</span><br><span class="line"><span class="keyword">create</span> database test1 charset<span class="operator">=</span>utf8 <span class="keyword">collate</span><span class="operator">=</span>utf8_general_ci;</span><br><span class="line"># 创建一个名为 test1 的库，设置默认字符集为 utf8，默认排序规则为 utf8_general_ci，对应 <span class="operator">/</span>var<span class="operator">/</span>lib<span class="operator">/</span>mysql<span class="operator">/</span> 下的 test1 文件夹</span><br></pre></td></tr></table></figure><p>同时指定字符集与校验规则，使字符串比较、排序时不区分大小写。</p><blockquote><p>数据库命名规范建议：数据库名只能包含字母、数字、下划线、不能以数字开头、建议使用小写字母、避免使用 MySQL 关键字（如 database、table 等）、如果必须使用关键字，需要用反引号 <code>`</code> 包裹：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> DATABASE `database`;</span><br></pre></td></tr></table></figure></blockquote><h2 id="2-字符集和校验规则"><a href="#2-字符集和校验规则" class="headerlink" title="2. 字符集和校验规则"></a>2. 字符集和校验规则</h2><h3 id="1-查看系统默认的字符集与校验规则"><a href="#1-查看系统默认的字符集与校验规则" class="headerlink" title="1. 查看系统默认的字符集与校验规则"></a>1. 查看系统默认的字符集与校验规则</h3><p>我们可以使用以下语句查看当前 MySQL 服务的 <strong>系统默认字符集</strong> 和 <strong>默认校验规则</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;character_set_database&#x27;</span>;# 查看当前 USE 的数据库的字符集</span><br><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;collation_database&#x27;</span>;# 查看当前 USE 的数据库的校验规则</span><br><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;character_set_server&#x27;</span>;# 查看服务器默认字符集</span><br><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;collation_server&#x27;</span>;# 查看服务器默认校验规则</span><br></pre></td></tr></table></figure><p>也可以一次性查看所有字符集相关配置：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;character_set_%&#x27;</span>;</span><br><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;collation%&#x27;</span>;</span><br></pre></td></tr></table></figure><blockquote><p>  <strong>说明：</strong></p><ul><li><code>character_set_server</code> 表示 MySQL 服务的全局默认字符集。</li><li><code>collation_server</code> 表示 MySQL 服务的全局默认校验规则。</li><li><code>character_set_database</code> 和 <code>collation_database</code> 表示当前已选中数据库的默认字符集与校验规则。</li><li>如果未执行 <code>USE</code>，它们会回退到 <code>character_set_server</code> 和 <code>collation_server</code> 的值，但语义上仍属于“当前数据库上下文”。</li></ul></blockquote><h3 id="2-查看-MySQL-支持的字符集"><a href="#2-查看-MySQL-支持的字符集" class="headerlink" title="2. 查看 MySQL 支持的字符集"></a>2. 查看 MySQL 支持的字符集</h3><p>MySQL 支持多种字符集，可用以下命令查看：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CHARACTER SET</span>;</span><br><span class="line"><span class="keyword">show</span> charset;</span><br></pre></td></tr></table></figure><p>输出结果示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">+</span><span class="comment">----------+---------------------------------+---------------------+--------+</span></span><br><span class="line"><span class="operator">|</span> Charset  <span class="operator">|</span> Description                     <span class="operator">|</span> <span class="keyword">Default</span> <span class="keyword">collation</span>   <span class="operator">|</span> Maxlen <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+---------------------------------+---------------------+--------+</span></span><br><span class="line"><span class="operator">|</span> armscii8 <span class="operator">|</span> ARMSCII<span class="number">-8</span> Armenian              <span class="operator">|</span> armscii8_general_ci <span class="operator">|</span>      <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> ascii    <span class="operator">|</span> US ASCII                        <span class="operator">|</span> ascii_general_ci    <span class="operator">|</span>      <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> big5     <span class="operator">|</span> Big5 Traditional Chinese        <span class="operator">|</span> big5_chinese_ci     <span class="operator">|</span>      <span class="number">2</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="type">binary</span>   <span class="operator">|</span> <span class="type">Binary</span> pseudo charset           <span class="operator">|</span> <span class="type">binary</span>              <span class="operator">|</span>      <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> cp1250   <span class="operator">|</span> Windows Central European        <span class="operator">|</span> cp1250_general_ci   <span class="operator">|</span>      <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> cp1251   <span class="operator">|</span> Windows Cyrillic                <span class="operator">|</span> cp1251_general_ci   <span class="operator">|</span>      <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> cp1256   <span class="operator">|</span> Windows Arabic                  <span class="operator">|</span> cp1256_general_ci   <span class="operator">|</span>      <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> cp1257   <span class="operator">|</span> Windows Baltic                  <span class="operator">|</span> cp1257_general_ci   <span class="operator">|</span>      <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> cp850    <span class="operator">|</span> DOS West European               <span class="operator">|</span> cp850_general_ci    <span class="operator">|</span>      <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> cp852    <span class="operator">|</span> DOS Central European            <span class="operator">|</span> cp852_general_ci    <span class="operator">|</span>      <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> cp866    <span class="operator">|</span> DOS Russian                     <span class="operator">|</span> cp866_general_ci    <span class="operator">|</span>      <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> cp932    <span class="operator">|</span> SJIS <span class="keyword">for</span> Windows Japanese       <span class="operator">|</span> cp932_japanese_ci   <span class="operator">|</span>      <span class="number">2</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> dec8     <span class="operator">|</span> <span class="type">DEC</span> West European               <span class="operator">|</span> dec8_swedish_ci     <span class="operator">|</span>      <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> eucjpms  <span class="operator">|</span> UJIS <span class="keyword">for</span> Windows Japanese       <span class="operator">|</span> eucjpms_japanese_ci <span class="operator">|</span>      <span class="number">3</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> euckr    <span class="operator">|</span> EUC<span class="operator">-</span>KR Korean                   <span class="operator">|</span> euckr_korean_ci     <span class="operator">|</span>      <span class="number">2</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> gb18030  <span class="operator">|</span> China <span class="type">National</span> Standard GB18030 <span class="operator">|</span> gb18030_chinese_ci  <span class="operator">|</span>      <span class="number">4</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> gb2312   <span class="operator">|</span> GB2312 Simplified Chinese       <span class="operator">|</span> gb2312_chinese_ci   <span class="operator">|</span>      <span class="number">2</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> gbk      <span class="operator">|</span> GBK Simplified Chinese          <span class="operator">|</span> gbk_chinese_ci      <span class="operator">|</span>      <span class="number">2</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> geostd8  <span class="operator">|</span> GEOSTD8 Georgian                <span class="operator">|</span> geostd8_general_ci  <span class="operator">|</span>      <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> greek    <span class="operator">|</span> ISO <span class="number">8859</span><span class="number">-7</span> Greek                <span class="operator">|</span> greek_general_ci    <span class="operator">|</span>      <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> hebrew   <span class="operator">|</span> ISO <span class="number">8859</span><span class="number">-8</span> Hebrew               <span class="operator">|</span> hebrew_general_ci   <span class="operator">|</span>      <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> hp8      <span class="operator">|</span> HP West European                <span class="operator">|</span> hp8_english_ci      <span class="operator">|</span>      <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> keybcs2  <span class="operator">|</span> DOS Kamenicky Czech<span class="operator">-</span>Slovak      <span class="operator">|</span> keybcs2_general_ci  <span class="operator">|</span>      <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> koi8r    <span class="operator">|</span> KOI8<span class="operator">-</span>R Relcom Russian           <span class="operator">|</span> koi8r_general_ci    <span class="operator">|</span>      <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> koi8u    <span class="operator">|</span> KOI8<span class="operator">-</span>U Ukrainian                <span class="operator">|</span> koi8u_general_ci    <span class="operator">|</span>      <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> latin1   <span class="operator">|</span> cp1252 West European            <span class="operator">|</span> latin1_swedish_ci   <span class="operator">|</span>      <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> latin2   <span class="operator">|</span> ISO <span class="number">8859</span><span class="number">-2</span> Central European     <span class="operator">|</span> latin2_general_ci   <span class="operator">|</span>      <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> latin5   <span class="operator">|</span> ISO <span class="number">8859</span><span class="number">-9</span> Turkish              <span class="operator">|</span> latin5_turkish_ci   <span class="operator">|</span>      <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> latin7   <span class="operator">|</span> ISO <span class="number">8859</span><span class="number">-13</span> Baltic              <span class="operator">|</span> latin7_general_ci   <span class="operator">|</span>      <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> macce    <span class="operator">|</span> Mac Central European            <span class="operator">|</span> macce_general_ci    <span class="operator">|</span>      <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> macroman <span class="operator">|</span> Mac West European               <span class="operator">|</span> macroman_general_ci <span class="operator">|</span>      <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> sjis     <span class="operator">|</span> Shift<span class="operator">-</span>JIS Japanese              <span class="operator">|</span> sjis_japanese_ci    <span class="operator">|</span>      <span class="number">2</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> swe7     <span class="operator">|</span> <span class="number">7</span>bit Swedish                    <span class="operator">|</span> swe7_swedish_ci     <span class="operator">|</span>      <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> tis620   <span class="operator">|</span> TIS620 Thai                     <span class="operator">|</span> tis620_thai_ci      <span class="operator">|</span>      <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> ucs2     <span class="operator">|</span> UCS<span class="number">-2</span> Unicode                   <span class="operator">|</span> ucs2_general_ci     <span class="operator">|</span>      <span class="number">2</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> ujis     <span class="operator">|</span> EUC<span class="operator">-</span>JP Japanese                 <span class="operator">|</span> ujis_japanese_ci    <span class="operator">|</span>      <span class="number">3</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> utf16    <span class="operator">|</span> UTF<span class="number">-16</span> Unicode                  <span class="operator">|</span> utf16_general_ci    <span class="operator">|</span>      <span class="number">4</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> utf16le  <span class="operator">|</span> UTF<span class="number">-16</span>LE Unicode                <span class="operator">|</span> utf16le_general_ci  <span class="operator">|</span>      <span class="number">4</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> utf32    <span class="operator">|</span> UTF<span class="number">-32</span> Unicode                  <span class="operator">|</span> utf32_general_ci    <span class="operator">|</span>      <span class="number">4</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> utf8mb3  <span class="operator">|</span> UTF<span class="number">-8</span> Unicode                   <span class="operator">|</span> utf8mb3_general_ci  <span class="operator">|</span>      <span class="number">3</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> utf8mb4  <span class="operator">|</span> UTF<span class="number">-8</span> Unicode                   <span class="operator">|</span> utf8mb4_0900_ai_ci  <span class="operator">|</span>      <span class="number">4</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+---------------------------------+---------------------+--------+</span></span><br><span class="line"><span class="number">41</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li><code>Charset</code>：字符集名称。</li><li><code>Description</code>：描述。</li><li><code>Default collation</code>：默认校验规则。</li><li><code>Maxlen</code>：每个字符所需最大字节数。</li></ul><h3 id="3-查看某个字符集支持的校验规则"><a href="#3-查看某个字符集支持的校验规则" class="headerlink" title="3. 查看某个字符集支持的校验规则"></a>3. 查看某个字符集支持的校验规则</h3><p>使用以下语句查看指定字符集的所有可用校验规则：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">COLLATION</span> <span class="keyword">WHERE</span> Charset<span class="operator">=</span><span class="string">&#x27;utf8&#x27;</span>;</span><br></pre></td></tr></table></figure><p>输出示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+--------------------+---------+----+---------+----------+---------+</span><br><span class="line">| Collation          | Charset | Id | Default | Compiled | Sortlen |</span><br><span class="line">+--------------------+---------+----+---------+----------+---------+</span><br><span class="line">| utf8_general_ci    | utf8    | 33 | Yes     | Yes      | 1       |</span><br><span class="line">| utf8_bin           | utf8    | 83 |         | Yes      | 1       |</span><br><span class="line">| utf8_unicode_ci    | utf8    | 192|         | Yes      | 8       |</span><br><span class="line">+--------------------+---------+----+---------+----------+---------+</span><br></pre></td></tr></table></figure><p><strong>常见校验规则说明：</strong></p><ul><li><code>utf8_general_ci</code>：不区分大小写的通用排序规则（ci &#x3D; case insensitive）。</li><li><code>utf8_bin</code>：区分大小写的二进制比较方式（bin &#x3D; binary）。</li><li><code>utf8_unicode_ci</code>：基于 Unicode 标准的更准确排序方式（不区分大小写，但性能略低）。</li></ul><h3 id="4-校验规则对数据库的影响"><a href="#4-校验规则对数据库的影响" class="headerlink" title="4. 校验规则对数据库的影响"></a>4. 校验规则对数据库的影响</h3><p>校验规则主要影响字符串的 <strong>比较</strong> 与 <strong>排序</strong>。不同的规则可能导致查询结果差异。</p><h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE test_ci <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_general_ci;</span><br><span class="line"><span class="keyword">CREATE</span> DATABASE test_bin <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin;</span><br><span class="line"></span><br><span class="line">USE test_ci;</span><br><span class="line"><span class="keyword">CREATE TABLE</span> t (name <span class="type">VARCHAR</span>(<span class="number">20</span>));</span><br><span class="line"><span class="keyword">INSERT INTO</span> t <span class="keyword">VALUES</span> (<span class="string">&#x27;abc&#x27;</span>), (<span class="string">&#x27;ABC&#x27;</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> name<span class="operator">=</span><span class="string">&#x27;abc&#x27;</span>;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">+</span><span class="comment">------+</span></span><br><span class="line"><span class="operator">|</span> name <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+</span></span><br><span class="line"><span class="operator">|</span> abc  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> ABC  <span class="operator">|</span>   ← 不区分大小写</span><br><span class="line"><span class="operator">+</span><span class="comment">------+</span></span><br></pre></td></tr></table></figure><p>而如果使用 <code>utf8_bin</code>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">USE test_bin;</span><br><span class="line"><span class="keyword">CREATE TABLE</span> t (name <span class="type">VARCHAR</span>(<span class="number">20</span>));</span><br><span class="line"><span class="keyword">INSERT INTO</span> t <span class="keyword">VALUES</span> (<span class="string">&#x27;abc&#x27;</span>), (<span class="string">&#x27;ABC&#x27;</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> name<span class="operator">=</span><span class="string">&#x27;abc&#x27;</span>;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">+</span><span class="comment">------+</span></span><br><span class="line"><span class="operator">|</span> name <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+</span></span><br><span class="line"><span class="operator">|</span> abc  <span class="operator">|</span>   ← 区分大小写</span><br><span class="line"><span class="operator">+</span><span class="comment">------+</span></span><br></pre></td></tr></table></figure><blockquote><p>  <strong>总结：</strong></p><ul><li><code>utf8_general_ci</code>：比较和排序不区分大小写。</li><li><code>utf8_bin</code>：比较和排序区分大小写。</li><li>校验规则不会改变数据存储内容，只影响字符串比较结果与排序方式。</li></ul></blockquote><h2 id="3-操作数据库"><a href="#3-操作数据库" class="headerlink" title="3. 操作数据库"></a>3. 操作数据库</h2><h3 id="1-查看数据库"><a href="#1-查看数据库" class="headerlink" title="1. 查看数据库"></a>1. 查看数据库</h3><h4 id="1-查看当前服务器中所有数据库"><a href="#1-查看当前服务器中所有数据库" class="headerlink" title="1. 查看当前服务器中所有数据库"></a>1. 查看当前服务器中所有数据库</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> DATABASES;# 注意不要丢了最后的 S ！</span><br><span class="line"><span class="keyword">show</span> databases;</span><br></pre></td></tr></table></figure><p><strong>说明：这会显示 MySQL 服务端当前存在的所有数据库。注意：<code>information_schema</code>、<code>mysql</code>、<code>performance_schema</code>、<code>sys</code> 是系统库，不要随意修改或删除。</strong></p><h4 id="2-查看当前正在使用的数据库"><a href="#2-查看当前正在使用的数据库" class="headerlink" title="2. 查看当前正在使用的数据库"></a>2. 查看当前正在使用的数据库</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> DATABASE();</span><br><span class="line"><span class="keyword">select</span> database();</span><br></pre></td></tr></table></figure><h3 id="2-显示数据库创建语句"><a href="#2-显示数据库创建语句" class="headerlink" title="2. 显示数据库创建语句"></a>2. 显示数据库创建语句</h3><p>要查看数据库的创建详情（字符集、校验规则等），可用：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> DATABASE 数据库名;</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> database 数据库名;</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> DATABASE test;# 示例</span><br></pre></td></tr></table></figure><p>输出示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+----------+--------------------------------------------------------------------------------------------------------------------------------+</span><br><span class="line">| Database | Create Database                                                                                                                |</span><br><span class="line">+----------+--------------------------------------------------------------------------------------------------------------------------------+</span><br><span class="line">| test     | CREATE DATABASE `test` /*!40100 DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci */ /*!80016 DEFAULT ENCRYPTION=&#x27;N&#x27; */ |</span><br><span class="line">+----------+--------------------------------------------------------------------------------------------------------------------------------+</span><br></pre></td></tr></table></figure><p>看着有点乱对吧，可以使用 <code>show create database test\G</code>，此时后面的 <code>;</code> 可有可无，<code>G</code> 选项的作用是将结果按行垂直排列，每个字段单独占一行，特别适合处理字段值较长的输出场景：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show create database <span class="built_in">test</span>\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">       Database: <span class="built_in">test</span></span><br><span class="line">Create Database: CREATE DATABASE `<span class="built_in">test</span>` /*!40100 DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci */ /*!80016 DEFAULT ENCRYPTION=<span class="string">&#x27;N&#x27;</span> */</span><br><span class="line">1 row <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br></pre></td></tr></table></figure><p><strong>说明：</strong> 语句会完整显示数据库的创建 SQL，包括字符集与校验规则，可用于迁移或备份时复制创建语句。<code>/*!40100 DEFAULT CHARACTER SET utf8 */</code> 不是注释，它表示当前 MySQL 版本如果大于 4.10，则执行后面的 SQL 语句，相当于 <code>if</code> 语句。</p><h3 id="3-修改数据库"><a href="#3-修改数据库" class="headerlink" title="3. 修改数据库"></a>3. 修改数据库</h3><p>可通过 <code>ALTER DATABASE</code> 修改数据库的默认字符集与校验规则，<strong>语法格式：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> DATABASE 数据库名 [<span class="keyword">DEFAULT</span> <span class="keyword">CHARACTER SET</span> 字符集名] [<span class="keyword">DEFAULT</span> <span class="keyword">COLLATE</span> 校验规则];</span><br><span class="line"><span class="keyword">ALTER</span> DATABASE 数据库名 [<span class="keyword">DEFAULT</span>] CHARSET<span class="operator">=</span>字符集名 [<span class="keyword">DEFAULT</span>] <span class="keyword">COLLATE</span><span class="operator">=</span>校验规则;</span><br><span class="line"><span class="keyword">alter</span> database 数据库名 charset<span class="operator">=</span>字符集名 <span class="keyword">collate</span><span class="operator">=</span>校验规则;</span><br></pre></td></tr></table></figure><h4 id="1-示例-1：修改字符集"><a href="#1-示例-1：修改字符集" class="headerlink" title="1. 示例 1：修改字符集"></a>1. 示例 1：修改字符集</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> DATABASE test <span class="keyword">DEFAULT</span> <span class="keyword">CHARACTER SET</span> utf8mb4;</span><br><span class="line"><span class="keyword">alter</span> database test <span class="keyword">default</span> charset<span class="operator">=</span>utfmb4;</span><br></pre></td></tr></table></figure><h4 id="2-示例-2：修改字符集和校验规则"><a href="#2-示例-2：修改字符集和校验规则" class="headerlink" title="2. 示例 2：修改字符集和校验规则"></a>2. 示例 2：修改字符集和校验规则</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> DATABASE test <span class="keyword">DEFAULT</span> <span class="keyword">CHARACTER SET</span> utf8mb4 <span class="keyword">DEFAULT</span> <span class="keyword">COLLATE</span> utf8mb4_general_ci;</span><br><span class="line"><span class="keyword">ALTER</span> DATABASE test <span class="keyword">CHARACTER SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_general_ci;</span><br><span class="line"></span><br><span class="line"># 分 <span class="number">2</span> 次修改：</span><br><span class="line"><span class="keyword">alter</span> database test <span class="keyword">character set</span> utf8mb4;</span><br><span class="line"><span class="keyword">alter</span> database test <span class="keyword">collate</span> utf8mb4_general_ci;</span><br></pre></td></tr></table></figure><blockquote><p>  <strong>说明：</strong> 只会改变“数据库默认字符集”，不会自动修改已存在表的字符集。如果要真正改变表内数据编码，还需针对表执行 <code>ALTER TABLE</code>。</p></blockquote><h3 id="4-删除数据库"><a href="#4-删除数据库" class="headerlink" title="4. 删除数据库"></a>4. 删除数据库</h3><p><strong>语法格式：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> DATABASE [IF <span class="keyword">EXISTS</span>] 数据库名;</span><br><span class="line"><span class="keyword">drop</span> database 数据库名;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> database test;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li><code>IF EXISTS</code> 表示若数据库不存在则不报错。</li><li>MySQL 不支持同时删除多个库的语法，一次只能删除一个数据库。如果要一次性删除多个库，需要写多条语句，或用脚本批量执行。</li><li>删除数据库会 <strong>直接删除对应目录及全部数据文件（库中的表也会一并删除）</strong>，例如 <code>/var/lib/mysql/test/</code>。</li><li><strong>删除操作不可恢复，务必谨慎执行。</strong></li></ul><p>前面提到，一个数据库的创建其实是在 <code>/var/lib/mysql/</code> 会创建对应的文件夹，那么删除一个库是不是可以直接使用 <code>rm</code> 进行删除呢？</p><table><thead><tr><th>操作方式</th><th>行为</th><th>风险</th></tr></thead><tbody><tr><td><code>DROP DATABASE</code></td><td>MySQL 内部安全删除：清理表空间、日志、数据字典记录、权限信息</td><td>推荐、安全</td></tr><tr><td>手动删除文件夹</td><td>只删掉物理文件，MySQL 内部元数据（如 <code>information_schema</code>、权限缓存）不会更新</td><td>不推荐、高风险</td></tr></tbody></table><blockquote><p>从 MySQL 8.0 开始，<strong>所有数据库元数据都存储在 InnoDB 的数据字典中</strong>，不再依赖文件系统目录是否存在。这意味着：删了 <code>/var/lib/mysql/test</code> 目录，表面上好像效果一样，但 <code>SHOW DATABASES;</code> <strong>可能仍然显示 <code>test</code></strong>，尝试 <code>USE mydb;</code> 会报错：<code>Unknown database &#39;test&#39;</code>，也 <strong>无法再创建同名数据库</strong>，因为元数据还存在！这会导致“幽灵数据库”问题：看不见、删不掉、建不了！ <strong>所以：推荐直接使用 MySQL 的命令，最好不要直接删除对应的文件夹！反过来也最好不要使用 <code>mkdir</code> 进行创建。</strong></p></blockquote><h2 id="4-备份和恢复"><a href="#4-备份和恢复" class="headerlink" title="4. 备份和恢复"></a>4. 备份和恢复</h2><h3 id="1-备份"><a href="#1-备份" class="headerlink" title="1. 备份"></a>1. 备份</h3><h4 id="1-基础备份"><a href="#1-基础备份" class="headerlink" title="1. 基础备份"></a>1. 基础备份</h4><blockquote><p><strong><code>mysqldump</code> 是一个命令行工具（不是 SQL 语句），不能在 MySQL 客户端（即 <code>mysql&gt;</code> 交互界面）中直接执行，需要先 <code>exit</code> 退出。</strong></p></blockquote><p><strong>语法格式：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -P端口号 -u 用户名 -p 密码 -B 数据库名 &gt; 数据库备份存储路径</span><br><span class="line"></span><br><span class="line">mysqldump -P3306 -u root -p123456 -B <span class="built_in">test</span> &gt; D:/test.sql<span class="comment"># 示例：将 mytest 库备份到 D: 盘</span></span><br><span class="line">mysqldump -P3306 -u root -p -B <span class="built_in">test</span> &gt; ~/temp/t.sql<span class="comment"># 或者执行完再输密码，注意：文件/目录不存在不会自动创建！</span></span><br></pre></td></tr></table></figure><p><strong>说明：</strong> 备份文件 <code>test.sql</code> 中包含整个数据库的创建语句、表结构、表数据，可以打开文件查看 SQL 内容。比如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">root<span class="variable">@hcss</span><span class="operator">-</span>ecs<span class="operator">-</span>be68:<span class="operator">~</span><span class="operator">/</span>temp# cat t.sql </span><br><span class="line"><span class="comment">-- MySQL dump 10.13  Distrib 8.0.43, for Linux (x86_64)</span></span><br><span class="line"><span class="comment">--</span></span><br><span class="line"><span class="comment">-- Host: localhost    Database: test</span></span><br><span class="line"><span class="comment">-- ------------------------------------------------------</span></span><br><span class="line"><span class="comment">-- Server version8.0.43-0ubuntu0.22.04.2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */</span>;</span><br><span class="line"><span class="comment">/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */</span>;</span><br><span class="line"><span class="comment">/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */</span>;</span><br><span class="line"><span class="comment">/*!50503 SET NAMES utf8mb4 */</span>;</span><br><span class="line"><span class="comment">/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */</span>;</span><br><span class="line"><span class="comment">/*!40103 SET TIME_ZONE=&#x27;+00:00&#x27; */</span>;</span><br><span class="line"><span class="comment">/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */</span>;</span><br><span class="line"><span class="comment">/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */</span>;</span><br><span class="line"><span class="comment">/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE=&#x27;NO_AUTO_VALUE_ON_ZERO&#x27; */</span>;</span><br><span class="line"><span class="comment">/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--</span></span><br><span class="line"><span class="comment">-- Current Database: `test`</span></span><br><span class="line"><span class="comment">--</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> DATABASE <span class="comment">/*!32312 IF NOT EXISTS*/</span> `test` <span class="comment">/*!40100 DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci */</span> <span class="comment">/*!80016 DEFAULT ENCRYPTION=&#x27;N&#x27; */</span>;</span><br><span class="line"></span><br><span class="line">USE `test`;</span><br><span class="line"></span><br><span class="line"><span class="comment">--</span></span><br><span class="line"><span class="comment">-- Table structure for table `students`</span></span><br><span class="line"><span class="comment">--</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `students`;</span><br><span class="line"><span class="comment">/*!40101 SET @saved_cs_client     = @@character_set_client */</span>;</span><br><span class="line"><span class="comment">/*!50503 SET character_set_client = utf8mb4 */</span>;</span><br><span class="line"><span class="keyword">CREATE TABLE</span> `students` (</span><br><span class="line">  `id` <span class="type">int</span> <span class="keyword">NOT NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">COLLATE</span> utf8mb4_general_ci <span class="keyword">NOT NULL</span>,</span><br><span class="line">  `age` <span class="type">int</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `grade` <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">COLLATE</span> utf8mb4_general_ci <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY KEY</span> (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">4</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8mb4_general_ci;</span><br><span class="line"><span class="comment">/*!40101 SET character_set_client = @saved_cs_client */</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--</span></span><br><span class="line"><span class="comment">-- Dumping data for table `students`</span></span><br><span class="line"><span class="comment">--</span></span><br><span class="line"></span><br><span class="line">LOCK TABLES `students` WRITE;</span><br><span class="line"><span class="comment">/*!40000 ALTER TABLE `students` DISABLE KEYS */</span>;</span><br><span class="line"><span class="keyword">INSERT INTO</span> `students` <span class="keyword">VALUES</span> (<span class="number">1</span>,<span class="string">&#x27;张三&#x27;</span>,<span class="number">18</span>,<span class="string">&#x27;高三&#x27;</span>),(<span class="number">2</span>,<span class="string">&#x27;李四&#x27;</span>,<span class="number">17</span>,<span class="string">&#x27;高二&#x27;</span>),(<span class="number">3</span>,<span class="string">&#x27;王五&#x27;</span>,<span class="number">19</span>,<span class="string">&#x27;大学一年级&#x27;</span>);</span><br><span class="line"><span class="comment">/*!40000 ALTER TABLE `students` ENABLE KEYS */</span>;</span><br><span class="line">UNLOCK TABLES;</span><br><span class="line"><span class="comment">/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*!40101 SET SQL_MODE=@OLD_SQL_MODE */</span>;</span><br><span class="line"><span class="comment">/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */</span>;</span><br><span class="line"><span class="comment">/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */</span>;</span><br><span class="line"><span class="comment">/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */</span>;</span><br><span class="line"><span class="comment">/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */</span>;</span><br><span class="line"><span class="comment">/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */</span>;</span><br><span class="line"><span class="comment">/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Dump completed on 2025-9-11 15:56:29</span></span><br></pre></td></tr></table></figure><h4 id="2-备份单张表"><a href="#2-备份单张表" class="headerlink" title="2. 备份单张表"></a>2. 备份单张表</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump <span class="operator">-</span>u root <span class="operator">-</span>p 数据库名 表名<span class="number">1</span> 表名<span class="number">2</span> <span class="operator">&gt;</span> D:<span class="operator">/</span>mytest.sql# 仅备份指定表，不会备份整个数据库。</span><br></pre></td></tr></table></figure><h4 id="3-同时备份多个数据库"><a href="#3-同时备份多个数据库" class="headerlink" title="3. 同时备份多个数据库"></a>3. 同时备份多个数据库</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -u root -p -B 数据库名1 数据库名2 ... &gt; D:/backup.sql</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 如果没有 <code>-B</code> 参数，备份单库时，需要先手动创建空数据库，然后再用 <code>source</code> 导入，<code>mysqldump</code> 会生成标准 SQL 文件，可跨服务器恢复。</p><hr><h3 id="2-恢复"><a href="#2-恢复" class="headerlink" title="2. 恢复"></a>2. 恢复</h3><p><strong>语法：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> source 数据库备份文件路径;</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> source D:<span class="operator">/</span><span class="keyword">new</span><span class="operator">/</span>test.sql;# 示例</span><br></pre></td></tr></table></figure><p><strong>说明：</strong> 恢复会执行 SQL 文件里的所有语句：创建数据库、建表、导入数据，如果备份文件没有 <code>CREATE DATABASE</code>，需要先手动创建空数据库再导入。<strong>注意事项：</strong></p><ul><li>备份不是整个数据库，而是单表时，需指定表名。</li><li>多库备份可通过 <code>-B 数据库名1 数据库名2</code> 实现。</li><li>恢复单库时，如果备份文件没有 <code>-B</code> 参数创建数据库，需要先创建空库。</li></ul><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> source <span class="operator">~</span><span class="operator">/</span>temp<span class="operator">/</span>t.sql;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">Database changed</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.02</span> sec)</span><br><span class="line"></span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.02</span> sec)</span><br><span class="line"></span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">Query OK, <span class="number">3</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line">Records: <span class="number">3</span>  Duplicates: <span class="number">0</span>  Warnings: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> </span><br></pre></td></tr></table></figure><h2 id="5-查看连接情况"><a href="#5-查看连接情况" class="headerlink" title="5. 查看连接情况"></a>5. 查看连接情况</h2><h3 id="1-语法格式-1"><a href="#1-语法格式-1" class="headerlink" title="1. 语法格式"></a>1. 语法格式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SHOW PROCESSLIST;</span><br><span class="line">show processlist;</span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> processlist;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-----------------+-----------+------+---------+------+------------------------+------------------+</span></span><br><span class="line"><span class="operator">|</span> Id <span class="operator">|</span> <span class="keyword">User</span>            <span class="operator">|</span> Host      <span class="operator">|</span> db   <span class="operator">|</span> Command <span class="operator">|</span> <span class="type">Time</span> <span class="operator">|</span> State                  <span class="operator">|</span> Info             <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-----------------+-----------+------+---------+------+------------------------+------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">5</span> <span class="operator">|</span> event_scheduler <span class="operator">|</span> localhost <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> Daemon  <span class="operator">|</span> <span class="number">8710</span> <span class="operator">|</span> Waiting <span class="keyword">on</span> <span class="keyword">empty</span> queue <span class="operator">|</span> <span class="keyword">NULL</span>             <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">15</span> <span class="operator">|</span> root            <span class="operator">|</span> localhost <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> Query   <span class="operator">|</span>    <span class="number">0</span> <span class="operator">|</span> init                   <span class="operator">|</span> <span class="keyword">show</span> processlist <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-----------------+-----------+------+---------+------+------------------------+------------------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> warning (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li><code>Id</code>：连接编号。</li><li><code>User</code>：用户名。</li><li><code>Host</code>：客户端主机。</li><li><code>db</code>：当前使用的数据库。</li><li><code>Command</code>：操作类型。</li><li><code>Time</code>：操作持续时间。</li><li><code>State</code>：操作状态。</li><li><code>Info</code>：执行的 SQL 语句。</li></ul><blockquote><p>  <strong>用途：</strong></p><ul><li>查看当前有哪些用户连接到 MySQL。</li><li>可判断是否有异常或未授权的连接。</li><li>当发现数据库操作缓慢或异常时，可用此命令排查连接。</li></ul></blockquote><h3 id="2-终止异常连接"><a href="#2-终止异常连接" class="headerlink" title="2. 终止异常连接"></a>2. 终止异常连接</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">KILL <span class="number">123</span>;  # 终止ID为<span class="number">123</span>的连接</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;库的操作&quot;&gt;&lt;a href=&quot;#库的操作&quot; class=&quot;headerlink&quot; title=&quot;库的操作&quot;&gt;&lt;/a&gt;库的操作&lt;/h1&gt;&lt;h2 id=&quot;1-创建数据库&quot;&gt;&lt;a href=&quot;#1-创建数据库&quot; class=&quot;headerlink&quot; title=&quot;1.</summary>
        
      
    
    
    
    <category term="MySQL" scheme="https://www.minbit.top/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="https://www.minbit.top/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>054 数据链路层</title>
    <link href="https://www.minbit.top/posts/55230.html"/>
    <id>https://www.minbit.top/posts/55230.html</id>
    <published>2025-10-09T04:00:00.000Z</published>
    <updated>2025-11-09T04:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h1><blockquote><p><a href="https://blog.csdn.net/chenlong_cxy/article/details/124788397">数据链路层协议 ——— 以太网协议 | CSDN</a></p><p><a href="https://blog.csdn.net/m0_64280701/article/details/134042240">「网络编程」数据链路层协议_ 以太网协议学习 | CSDN</a></p></blockquote><h2 id="1-对比理解-MAC-地址和-IP-地址"><a href="#1-对比理解-MAC-地址和-IP-地址" class="headerlink" title="1. 对比理解 MAC 地址和 IP 地址"></a>1. 对比理解 MAC 地址和 IP 地址</h2><h3 id="1-通俗类比：寄快递的两步走"><a href="#1-通俗类比：寄快递的两步走" class="headerlink" title="1. 通俗类比：寄快递的两步走"></a>1. 通俗类比：寄快递的两步走</h3><p>假设你要从北京家里寄一个文件到上海朋友家，整个过程对应两层的分工：</p><table><thead><tr><th>层级</th><th>类比角色</th><th>负责的环节</th></tr></thead><tbody><tr><td>数据链路层</td><td>你家楼下的快递员</td><td>只负责 “<strong>本地最后一公里</strong>”：从你手里接过文件（数据），封装成 “本地快递袋”（帧），送到小区门口的 “物流站点”（路由器）；不关心文件最终去哪，只认 “你家的门牌号”（MAC 地址）。</td></tr><tr><td>网络层</td><td>全国物流调度中心</td><td>负责 “<strong>跨区域全局路由</strong>”：从物流站点接过快递袋，拆开看 “目的地地址”（IP 地址），规划从北京到上海的路线（比如北京 → 济南 → 南京 → 上海），把快递转到下一个站点，直到送到上海的物流站点；不关心 “最后一公里怎么送”，只管 “跨区域怎么到目标城市”。</td></tr></tbody></table><p>简言之：</p><ul><li>数据链路层：<strong>管 “邻居间” 的本地传输</strong>（比如你家电脑 ↔ 路由器、路由器 ↔ 隔壁路由器）。</li><li>网络层：<strong>管 “跨网络” 的全局路由</strong>（比如北京内网 ↔ 上海内网、家里 WiFi↔ 百度服务器）。</li></ul><h3 id="2-关键对比"><a href="#2-关键对比" class="headerlink" title="2. 关键对比"></a>2. 关键对比</h3><table><thead><tr><th>对比维度</th><th>数据链路层</th><th>网络层</th></tr></thead><tbody><tr><td>1. 作用范围</td><td><strong>本地局域网（LAN）</strong>：仅覆盖 “直接相连的设备”（如同一 WiFi 下的电脑、手机），无法跨网络通信。</td><td><strong>跨网络（广域网 WAN &#x2F; 互联网）</strong>：覆盖多个局域网，实现 “异地设备” 通信（如北京电脑 ↔ 广州服务器）。</td></tr><tr><td>2. 核心任务</td><td>1. 把上层数据封装成 “帧”（Frame）<br>2. 用 <strong>MAC 地址</strong> 找到 “本地邻居”<br>3. 检测本地传输的错误（如帧损坏）。</td><td>1. 把上层数据封装成 “数据包”（Packet）<br>2. 用 <strong>IP 地址</strong> 找到 “目标网络”<br>3. 规划跨网路线（路由选择），转发数据包。</td></tr><tr><td>3. 数据单元</td><td><strong>帧（Frame）</strong>：是数据链路层的 “传输单位”，包含 “源 MAC 地址 + 目的 MAC 地址”。</td><td><strong>数据包（Packet）</strong>：是网络层的 “传输单位”，包含 “源 IP 地址 + 目的 IP 地址”。</td></tr><tr><td>4. 寻址方式</td><td><strong>MAC 地址</strong>（物理地址）：固定在网卡上，全球唯一，仅在本地局域网内有效，跨网无效。</td><td><strong>IP 地址</strong>（逻辑地址）：可动态分配（如家里 WiFi 的 IP），也可固定（如服务器 IP）。跨网唯一，用于定位 “目标网络”。</td></tr><tr><td>5. 关键协议</td><td>以太网（Ethernet）、WiFi（802.11）、PPP（拨号上网）、ARP（将 IP 转 MAC）</td><td>IP（IPv4&#x2F;IPv6）、ICMP（ping 命令用的协议）、路由协议（RIP&#x2F;OSPF）</td></tr><tr><td>6. 差错处理</td><td>仅 “<strong>本地差错检测</strong>”：发现帧损坏就丢弃，不负责修复或重传（重传交给上层如传输层）。</td><td>仅 “<strong>跨网差错报告</strong>”：用 ICMP 报告 “数据包丢了”“路由不可达”，不负责修复或重传。</td></tr></tbody></table><h3 id="3-一个实战案例：电脑-ping-百度的两层协作"><a href="#3-一个实战案例：电脑-ping-百度的两层协作" class="headerlink" title="3. 一个实战案例：电脑 ping 百度的两层协作"></a>3. 一个实战案例：电脑 ping 百度的两层协作</h3><p>当在电脑上输入 <code>ping www.baidu.com</code>，数据链路层和网络层的分工清晰可见：</p><ol><li><strong>网络层先干活</strong>：<ul><li>电脑先把 “ping 请求” 封装成 <strong>IP 数据包</strong>，目的 IP 是百度服务器的 IP（比如 <code>180.101.49.12</code>）。</li><li>电脑问本地路由器：“怎么把这个数据包送到百度？” 路由器用路由协议查 “路线表”，确定下一个转发节点（比如运营商的网关）。</li></ul></li><li><strong>数据链路层再封装</strong>：<ul><li>电脑把 “IP 数据包” 再封装成 <strong>以太网帧</strong>，目的 MAC 地址是 “本地路由器的 MAC 地址”（不是百度的 MAC！因为 MAC 只在本地有效）。</li><li>帧通过 WiFi &#x2F; 网线传到路由器，路由器拆开帧，取出里面的 IP 数据包，再给这个数据包套上 “新的帧”（目的 MAC 是下一个网关的 MAC），继续转发。</li></ul></li><li><strong>到百度服务器后反向操作</strong>：<ul><li>百度的路由器收到数据包，拆帧取包，再用 “百度服务器的 MAC” 封装成帧，送到百度服务器。</li><li>百度服务器返回 “ping 响应”，重复上述过程，最终回到你的电脑。</li></ul></li></ol><hr><h2 id="2-认识以太网"><a href="#2-认识以太网" class="headerlink" title="2. 认识以太网"></a>2. 认识以太网</h2><blockquote><ul><li><strong>IP 层</strong>：决定“送给谁”，类似“写信的收件人地址”；</li><li><strong>以太网层（链路层）</strong>：决定“信封怎么送到下一个邮局（下一跳）”；</li><li><strong>ARP 协议</strong>：负责查“邮递员的住址（MAC）”；</li><li><strong>路由器</strong>：相当于中转邮局，负责转运到不同地区。</li></ul></blockquote><h3 id="1-以太网是什么？"><a href="#1-以太网是什么？" class="headerlink" title="1. 以太网是什么？"></a>1. 以太网是什么？</h3><blockquote><p><strong>以太网的本质：局域网（LAN）的“物理 + 数据链路”实现。它只负责“一跳”通信 —— 即从当前主机到下一跳（通常是网关或目标主机），不关心跨网、路由、可靠性。</strong> </p></blockquote><p>以太网（Ethernet）是目前最常用的 <strong>局域网通信技术</strong>，它解决 <strong>同一局域网内</strong> 多台主机之间的 <strong>点对点或广播通信</strong>。它定义了：</p><ul><li><strong>物理层</strong>：用什么电缆&#x2F;光纤&#x2F;网卡等连接主机。</li><li><strong>数据链路层</strong>：如何封装、发送、识别、接收帧。</li><li><strong>寻址机制</strong>：用 <strong>MAC 地址</strong>（48 位，每个网卡的唯一标识）来区分不同主机。</li></ul><h3 id="2-以太网通信的核心原理"><a href="#2-以太网通信的核心原理" class="headerlink" title="2. 以太网通信的核心原理"></a>2. 以太网通信的核心原理</h3><p>以太网采用的基本通信方式是：<strong>广播 + 识别 + 过滤</strong>。</p><ol><li><p><strong>发送过程：</strong> 主机 A 想发数据给主机 B（同网段），A 封装以太网帧：目的 MAC &#x3D; B 的 MAC，源 MAC &#x3D; A 的 MAC，<strong>将帧广播到整个局域网</strong>（通过交换机或集线器）。</p></li><li><p>接收过程：局域网内 <strong>所有主机都收到该帧</strong>，每台主机检查目的 MAC：</p><ul><li><p><strong>匹配自己</strong> → 去掉以太网头，将 payload（如 IP 包）交给上层。</p></li><li><p><strong>不匹配</strong> → <strong>直接丢弃</strong>（不向上交付）。</p></li></ul></li></ol><p>这就是之前说的：在局域网中，<strong>每个主机都能看到所有帧</strong>，但只会“认领”发给自己的那部分。</p><blockquote><p><strong>交换机的作用：学习 MAC 地址表，只转发帧到目标端口（不是广播），减少冲突和带宽浪费。</strong></p></blockquote><h3 id="3-路由器在以太网通信中的作用"><a href="#3-路由器在以太网通信中的作用" class="headerlink" title="3. 路由器在以太网通信中的作用"></a>3. 路由器在以太网通信中的作用</h3><p>以太网通信范围是一个局域网（即一个广播域），<strong>不同网段之间</strong> 的通信必须经过路由器。当主机 A 发现目标 IP 不在本地网段时，它会：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">查路由表 → 发现下一跳是默认网关（路由器）→ 使用 ARP 找到网关的 MAC 地址 → 将帧发给网关 → 路由器接收后，剥去旧帧头，重新封装成新帧（目标是下一跳或目标主机）</span><br></pre></td></tr></table></figure><p>所以每跨一个路由器，就意味着一次“去掉旧帧头 + 加上新帧头”的过程。那么以太网又是如何与 IP 协作的呢？—— 封装与解封装：</p><ol><li><strong>发送端（主机 A）：</strong> 应用数据 → TCP&#x2F;UDP 封装（加端口号） → IP 封装（加源&#x2F;目的 IP） → <strong>以太网封装（加源&#x2F;目的 MAC）</strong> → 发送。</li><li><strong>转发中（路由器）：</strong> 收到帧 → 去掉以太网头 → 查 IP 目的地址 → 查路由表 → <strong>重新封装新以太网头</strong>（下一跳的 MAC） → 转发。</li></ol><p><strong>注意：IP 地址全程不变（端到端）、MAC 地址每跳都变（只用于本地链路）。</strong></p><h3 id="4-如何找到目标-MAC-——-ARP-协议（后文详解）"><a href="#4-如何找到目标-MAC-——-ARP-协议（后文详解）" class="headerlink" title="4. 如何找到目标 MAC —— ARP 协议（后文详解）"></a>4. 如何找到目标 MAC —— ARP 协议（后文详解）</h3><p>问题来了：主机 A 想发给主机 B，它只知道 B 的 <strong>IP 地址</strong>，却不知道 B 的 <strong>MAC 地址</strong>，怎么办？答案是 —— 使用 <strong>ARP 协议（Address Resolution Protocol）</strong>。</p><ul><li>A 先在局域网中广播一个 ARP 请求帧：“谁是 IP &#x3D; 192.168.1.10？请告诉我你的 MAC！”</li><li>B 收到后发现 IP 匹配，于是单播回应：“我的 MAC 地址是 xx:xx:xx:xx:xx: xx。”</li><li>A 收到后就缓存这个映射关系（写入 ARP 缓存表），之后发送数据帧时就不用再广播了。</li></ul><h2 id="3-以太网帧格式-结构"><a href="#3-以太网帧格式-结构" class="headerlink" title="3. 以太网帧格式&#x2F;结构"></a>3. 以太网帧格式&#x2F;结构</h2><h3 id="1-以太网帧格式"><a href="#1-以太网帧格式" class="headerlink" title="1. 以太网帧格式"></a>1. 以太网帧格式</h3><p>一个标准的以太网帧结构如下：</p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20251008204331593.png" alt="PixPin_2025-10-08_20-43-21"></p><table><thead><tr><th>字段</th><th>长度（字节）</th><th>作用</th></tr></thead><tbody><tr><td>目标 MAC 地址</td><td>6</td><td>标识接收方设备（帧要发给谁）</td></tr><tr><td>源 MAC 地址</td><td>6</td><td>标识发送方设备（谁发的）</td></tr><tr><td>类型字段</td><td>2</td><td>指明上层协议（如 <strong><span style="color:#FF0000;"><code>0x0800</code> &#x3D; IPv4，<code>0x86DD</code> &#x3D; IPv6，<code>0x0806</code> &#x3D; ARP</span></strong>，现已基本被 DHCP 取代，极少在现代网络中使用：<code>0x8035</code> &#x3D; RARP）</td></tr><tr><td>数据载荷</td><td>46~1500</td><td>实际承载的上层数据（通常是 IP 报文）</td></tr><tr><td>FCS（帧校验序列）</td><td>4</td><td>CRC32 校验，检查传输过程中是否出错</td></tr></tbody></table><p><strong>特点：</strong></p><ul><li><strong>帧头固定 14 字节（6 + 6 + 2）。</strong></li><li><strong>帧尾固定 4 字节（CRC）。</strong></li><li><strong>有效载荷部分可变，最小 46 字节，最大 1500 字节。</strong></li><li><strong>类型字段（Type） 是关键：用于区分上层协议。</strong></li></ul><blockquote><ul><li><strong>最小帧 64 字节</strong>（含头尾）→ 数据不足 46 字节时会填充。</li><li><strong>最大帧 1518 字节</strong> → 对应 IP 层 MTU &#x3D; 1500 。</li></ul><p>  注意：<strong>MAC 地址</strong> 是硬件层面的标识，和 IP 地址完全不同，工作范围只限于局域网。对比理解 MAC 地址和 IP 地址：</p><ul><li>IP 地址描述的是路途总体的起点和终点。</li><li>MAC 地址描述的是路途上的每一个区间的起点和终点。</li></ul></blockquote><h3 id="2-MAC-帧的分离原理（如何提取报头和有效载荷）"><a href="#2-MAC-帧的分离原理（如何提取报头和有效载荷）" class="headerlink" title="2. MAC 帧的分离原理（如何提取报头和有效载荷）"></a>2. MAC 帧的分离原理（如何提取报头和有效载荷）</h3><blockquote><p>MAC 帧的报头和帧尾长度是固定的，所以“定长分离”即可取出有效载荷。只要看类型字段，就能知道“有效载荷”该交给哪个上层协议。</p></blockquote><p>因为以太网帧的 <strong>帧头和帧尾长度固定</strong>，所以在接收端处理非常简单：</p><ol><li><strong>底层网卡驱动</strong> 收到原始比特流；</li><li>按帧结构解析出：前 14 字节 → 报头（含源 MAC、目的 MAC、类型字段），后 4 字节 → CRC 校验码，中间部分 → 有效载荷（上层协议的数据）。</li><li><strong>CRC 校验</strong>：验证数据是否出错，失败则丢弃，不交付上层。</li></ol><h3 id="3-流程示例（主机-A-→-主机-B）"><a href="#3-流程示例（主机-A-→-主机-B）" class="headerlink" title="3. 流程示例（主机 A → 主机 B）"></a>3. 流程示例（主机 A → 主机 B）</h3><p>假设主机 A 想把一个 IP 数据报发给同一局域网的主机 B。</p><h4 id="1-主机-A-封装帧"><a href="#1-主机-A-封装帧" class="headerlink" title="1. 主机 A 封装帧"></a>1. 主机 A 封装帧</h4><ul><li><strong>目的 MAC 地址</strong>：主机 B 的 MAC。</li><li><strong>源 MAC 地址</strong>：主机 A 的 MAC。</li><li><strong>类型字段</strong>：<code>0x0800</code>（表示上层协议是 IPv4）。</li><li><strong>有效载荷</strong>：要发送的 IP 数据报。</li><li><strong>CRC 校验码</strong>：通过多项式算法生成，用于校验错误。</li><li>封装完毕后发入局域网（广播介质）。</li></ul><h4 id="2-局域网中每台主机都能收到这个帧"><a href="#2-局域网中每台主机都能收到这个帧" class="headerlink" title="2. 局域网中每台主机都能收到这个帧"></a>2. 局域网中每台主机都能收到这个帧</h4><p>包括主机 A 自己、主机 B、以及其他主机，每台主机都会提取出 <strong>目的 MAC 地址</strong>，比对自己的 MAC 地址：</p><ul><li><strong>如果匹配：</strong> 说明是发给自己的，继续向上交付。</li><li><strong>如果不匹配：</strong> 说明不是给自己的，直接丢弃。</li></ul><h4 id="3-主机-B-处理-MAC-帧"><a href="#3-主机-B-处理-MAC-帧" class="headerlink" title="3. 主机 B 处理 MAC 帧"></a>3. 主机 B 处理 MAC 帧</h4><p>主机 B 收到后执行以下步骤：</p><ol><li><strong>CRC 校验通过</strong>。</li><li><strong>目的 MAC 地址匹配自己</strong>。</li><li>读取 <strong>类型字段（0x0800）</strong>，得知上层协议是 IP。</li><li>将“有效载荷部分”交给上层 <strong>IP 协议模块</strong>。</li><li>上层 IP 模块再进一步解析 IP 头、转发或交付给 TCP&#x2F;UDP。</li></ol><blockquote><p>MAC 帧是局域网的信封，IP 数据报是信件内容，信封上写了寄信人（源 MAC）、收信人（目的 MAC）和信件类型（Type），收到后，只要信封写的是你、信件没损坏，就会把信交给正确的部门（上层协议）。</p></blockquote><h2 id="4-认识-MTU"><a href="#4-认识-MTU" class="headerlink" title="4. 认识 MTU"></a>4. 认识 MTU</h2><h3 id="1-什么是-MTU？"><a href="#1-什么是-MTU？" class="headerlink" title="1. 什么是 MTU？"></a>1. 什么是 MTU？</h3><blockquote><p>  <strong>MTU（最大传输单元）：指数据链路层一次能够承载的最大数据负载长度（单位：字节），不包括以太网帧头与帧尾。</strong></p></blockquote><p>也就是说，<strong>MTU 限制了 IP 层单次发送的数据量上限</strong>，如果上层交给 IP 的数据长度超过 MTU，<strong>IP 层就必须分片</strong>。</p><h3 id="2-MTU-对-IP-协议的影响"><a href="#2-MTU-对-IP-协议的影响" class="headerlink" title="2. MTU 对 IP 协议的影响"></a>2. MTU 对 IP 协议的影响</h3><p>IP 层负责把上层传来的数据封装成 IP 数据报，如果要发送的数据 &gt; MTU，则需要 <strong>分片</strong>，分片机制：</p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20251008161058351.png"></p><p>示例：假设 MTU &#x3D; 1500，IP 头 &#x3D; 20 字节，则有效载荷最大 &#x3D; 1480。如果上层传 4000 字节，则会被拆分成：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[第1片] 1480字节（MF=1）</span><br><span class="line">[第2片] 1480字节（MF=1）</span><br><span class="line">[第3片] 1040字节（MF=0）</span><br></pre></td></tr></table></figure><p><strong>接收方 IP 层</strong> 根据“标识 + 偏移”重组原始数据报。如果任意一个分片丢失，整个 IP 数据报重组失败 → 上层必须重传。</p><hr><h3 id="3-MTU-对-UDP-协议的影响"><a href="#3-MTU-对-UDP-协议的影响" class="headerlink" title="3. MTU 对 UDP 协议的影响"></a>3. MTU 对 UDP 协议的影响</h3><p>UDP 没有重传机制，因此：若 UDP 报文长度 &gt; MTU → IP 分片，任意一个分片丢失 → 整体 UDP 报文丢失，UDP 没有超时重传机制，只能上层应用感知丢包。因此 <strong>UDP 应尽量避免触发 IP 分片</strong>，推荐单包负载 ≤ 1472 字节（&#x3D; 1500 − 20 − 8）。</p><h3 id="4-MTU-对-TCP-协议的影响"><a href="#4-MTU-对-TCP-协议的影响" class="headerlink" title="4. MTU 对 TCP 协议的影响"></a>4. MTU 对 TCP 协议的影响</h3><p><strong>TCP 有重传机制，但分片仍会带来性能损耗。</strong> 因此 TCP 使用 <strong>MSS（最大分段大小）</strong> 控制单次发送量。<strong>MSS 与 MTU 的关系：</strong></p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MSS = MTU - IP头长度 - TCP头长度</span><br><span class="line">例如：MSS = 1500 - 20 - 20 = 1460</span><br></pre></td></tr></table></figure><p>TCP 在三次握手阶段交换 MSS：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SYN 报文：</span><br><span class="line">  Kind=2（MSS选项）</span><br><span class="line">  Length=4</span><br><span class="line">  Value=1460</span><br></pre></td></tr></table></figure><p>双方协商后取较小值作为实际 MSS，这样 TCP 可以 <strong>避免触发 IP 分片</strong>，直接分段发送。</p><h3 id="5-Linux-中查看硬件地址与-MTU"><a href="#5-Linux-中查看硬件地址与-MTU" class="headerlink" title="5. Linux 中查看硬件地址与 MTU"></a>5. Linux 中查看硬件地址与 MTU</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ifconfig</span><br><span class="line">ip addr show<span class="comment"># 更现代</span></span><br></pre></td></tr></table></figure><p>输出示例：</p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250813132749254.png"></p><p>说明：</p><ul><li><code>mtu 1500</code> → 当前接口最大传输单元为 1500 字节。</li><li><code>link/ether</code> → 后面即是物理 MAC 地址。</li></ul><hr><h2 id="5-ARP-协议"><a href="#5-ARP-协议" class="headerlink" title="5. ARP 协议"></a>5. ARP 协议</h2><h3 id="1-ARP-协议的作用"><a href="#1-ARP-协议的作用" class="headerlink" title="1. ARP 协议的作用"></a>1. ARP 协议的作用</h3><h4 id="1-ARP-的使命"><a href="#1-ARP-的使命" class="headerlink" title="1. ARP 的使命"></a>1. ARP 的使命</h4><blockquote><p><strong>在同一个局域网内，通过目标 IP 地址，动态查询并获取其对应的 MAC 地址。</strong> </p></blockquote><p>在同一个局域网（LAN）中进行通信时：数据链路层负责 <strong>以太网帧</strong> 的传输，但以太网通信依赖的是 <strong>MAC 地址</strong>（硬件地址），而不是 IP 地址，实际上，我们在上层通信时通常只知道对方的 <strong>IP 地址</strong>（例如 <code>192.168.1.2</code>）。所以，问题来了：已知对方 IP 地址，如何得到对应的 MAC 地址？这正是 <strong>ARP（地址解析协议）</strong> 的核心作用。</p><h4 id="2-ARP-协议定位与特性"><a href="#2-ARP-协议定位与特性" class="headerlink" title="2. ARP 协议定位与特性"></a>2. ARP 协议定位与特性</h4><ul><li><strong>所在层次：</strong> TCP&#x2F;IP 四层模型的 <strong>数据链路层</strong>。</li><li><strong>与 MAC 帧关系：</strong> 属于 <strong>MAC 帧的上层协议</strong>（即 MAC 封装 ARP）。</li><li><strong>主要功能：</strong> 实现 IP 地址 → MAC 地址 的映射。</li><li><strong>仅限本地子网</strong>：不能跨路由器（ARP 请求不会被路由器转发）。</li><li><strong>无连接、无确认</strong>：广播请求 + 单播应答，不保证可靠（靠重试）。</li><li><strong>缓存机制</strong>：避免频繁广播（<code>arp -a</code> 可查看）。</li></ul><blockquote><p>  <strong>类比：</strong> IP 地址 &#x3D; 收件人姓名，MAC 地址 &#x3D; 收件人门牌号，ARP &#x3D; 在小区公告栏喊：“张三住哪栋哪户？”。</p></blockquote><hr><h3 id="2-ARP-报文格式（重点）"><a href="#2-ARP-报文格式（重点）" class="headerlink" title="2. ARP 报文格式（重点）"></a>2. ARP 报文格式（重点）</h3><p>ARP 报文并不是独立存在的，它是封装在以太网帧中的。下面是 <strong>ARP 数据包格式（共 28 字节）</strong>：</p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20251008224421005.png" alt="PixPin_2025-10-08_22-44-15"></p><table><thead><tr><th>字段名称</th><th>长度（字节）</th><th>含义说明</th></tr></thead><tbody><tr><td><strong>硬件类型（Hardware Type）</strong></td><td>2 字节</td><td>表示链路层类型。以太网为 <code>1</code></td></tr><tr><td><strong>协议类型（Protocol Type）</strong></td><td>2 字节</td><td>表示要解析的协议类型。IPv4 为 <code>0x0800</code></td></tr><tr><td><strong>硬件地址长度（HLEN）</strong></td><td>1 字节</td><td>MAC 地址长度（以太网中为 <code>6</code> 字节）</td></tr><tr><td><strong>协议地址长度（PLEN）</strong></td><td>1 字节</td><td>IP 地址长度（IPv4 中为 <code>4</code> 字节）</td></tr><tr><td><strong>操作码（Op Code）</strong></td><td>2 字节</td><td><code>1</code> &#x3D; 请求，<code>2</code> &#x3D; 应答</td></tr><tr><td><strong>发送端 MAC 地址</strong></td><td>6 字节</td><td>发起 ARP 的主机 MAC 地址</td></tr><tr><td><strong>发送端 IP 地址</strong></td><td>4 字节</td><td>发起 ARP 的主机 IP 地址</td></tr><tr><td><strong>目标 MAC 地址</strong></td><td>6 字节</td><td>目标主机的 MAC 地址（请求时未知，全 1）</td></tr><tr><td><strong>目标 IP 地址</strong></td><td>4 字节</td><td>目标主机的 IP 地址（要解析的 IP）</td></tr></tbody></table><p><strong>注意：帧类型：<code>0x0806</code>（在以太网头部指定），最小长度限制：ARP 报文只有 28 字节，不足以太网帧最小 46 字节，因此需要 补 18 字节填充位。这说明 ARP 是“位于 MAC 帧上层的链路层协议”，而不是网络层。</strong></p><h4 id="1-为什么-ARP-报头里还要-MAC-和-IP？"><a href="#1-为什么-ARP-报头里还要-MAC-和-IP？" class="headerlink" title="1. 为什么 ARP 报头里还要 MAC 和 IP？"></a>1. 为什么 ARP 报头里还要 MAC 和 IP？</h4><ul><li><strong>协议独立性</strong>：ARP 设计为通用协议，可支持非以太网。</li><li><strong>上下层解耦</strong>：MAC 帧只负责传输，ARP 负责逻辑解析，二者不共享字段。</li></ul><hr><h3 id="3-ARP-工作流程（核心机制）"><a href="#3-ARP-工作流程（核心机制）" class="headerlink" title="3. ARP 工作流程（核心机制）"></a>3. ARP 工作流程（核心机制）</h3><blockquote><p><strong>在 ARP 过程中，收到的任何 ARP 报文，都是先看操作码（Op Code）！！！</strong></p><ul><li>Op Code 值为 1 表示 ARP 请求（ARP Request）。</li><li>Op Code 值为 2 表示 ARP 应答（ARP Reply）。</li></ul><p>当主机收到一个 ARP 报文时，首先看这个字段，<strong>它决定了接下来主机要干什么：</strong></p><ul><li>如果是 <code>1（请求）</code>：说明对方在问「谁是这个 IP？」→ 如果该 IP 是我自己，就要 <strong>回一个应答包</strong> 告诉对方我的 MAC 地址。</li><li>如果是 <code>2（应答）</code>：说明对方在告诉我「这个 IP 的 MAC 是我」 → 我就要 <strong>更新或新增我的 ARP 缓存表</strong>。</li></ul><p>所以 Op Code 决定了这个包是请求还是应答，也决定了主机下一步行为。</p></blockquote><h4 id="1-ARP-请求（Request）"><a href="#1-ARP-请求（Request）" class="headerlink" title="1. ARP 请求（Request）"></a>1. ARP 请求（Request）</h4><p>主机 A 想知道主机 B 的 MAC 地址，但只知道其 IP 地址。这时需要构建 ARP 请求：</p><table><thead><tr><th>字段</th><th>内容</th></tr></thead><tbody><tr><td>硬件类型</td><td>1（以太网）</td></tr><tr><td>协议类型</td><td>0x0800（IPv4）</td></tr><tr><td>硬件地址长度</td><td>6</td></tr><tr><td>协议地址长度</td><td>4</td></tr><tr><td>操作码</td><td>1（ARP 请求）</td></tr><tr><td>发送端 MAC&#x2F;IP</td><td>路由器 D 的 MAC&#x2F;IP</td></tr><tr><td>目标 MAC</td><td>全 1（二进制，全 F）表示广播</td></tr><tr><td>目标 IP</td><td>主机 B 的 IP</td></tr></tbody></table><ol><li><strong>发送过程：</strong> ARP 请求封装进以太网帧：以太网 <strong>目的地址</strong>：<code>FF:FF:FF:FF:FF:FF</code>（广播），以太网 <strong>源地址</strong>：A 的 MAC 地址，帧类型：<code>0x0806</code>，然后广播发送到整个局域网。</li><li><strong>各主机的处理：</strong> 每台主机都能收到该广播帧，所有主机的 MAC 层识别帧类型为 <code>0x0806</code> → 上交给 <strong>ARP 层</strong>，各主机比对 <strong>目的 IP</strong> 是否与自己相符：<ul><li>若 <strong>不匹配</strong> → 在 ARP 层丢弃。</li><li>若 <strong>匹配</strong> → 生成 ARP 应答。</li></ul></li></ol><h4 id="2-ARP-应答（Reply）"><a href="#2-ARP-应答（Reply）" class="headerlink" title="2. ARP 应答（Reply）"></a>2. ARP 应答（Reply）</h4><p>主机 B 收到 ARP 请求，发现目的 IP 是自己的 IP，于是要回复，构建 ARP 应答：</p><table><thead><tr><th>字段</th><th>内容</th></tr></thead><tbody><tr><td>硬件类型</td><td>1</td></tr><tr><td>协议类型</td><td>0x0800</td></tr><tr><td>硬件地址长度</td><td>6</td></tr><tr><td>协议地址长度</td><td>4</td></tr><tr><td>操作码</td><td>2（ARP 应答）</td></tr><tr><td>发送端 MAC&#x2F;IP</td><td>主机 B 的 MAC&#x2F;IP</td></tr><tr><td>目标 MAC&#x2F;IP</td><td>路由器 D 的 MAC&#x2F;IP（请求中带有）</td></tr></tbody></table><ol><li><strong>发送过程：</strong> ARP 应答封装成以太网帧：以太网 <strong>目的地址</strong>：D 的 MAC 地址（单播），以太网 <strong>源地址</strong>：B 的 MAC 地址，帧类型：<code>0x0806</code></li><li><strong>接收与更新：</strong> A 收到该帧，交给 ARP 层，ARP 层识别为应答包（op &#x3D; 2），从中提取 B 的 MAC 地址，更新 <strong>ARP 缓存表</strong>（IP ↔ MAC 映射）。</li></ol><hr><h3 id="4-ARP-缓存表（ARP-Cache）"><a href="#4-ARP-缓存表（ARP-Cache）" class="headerlink" title="4. ARP 缓存表（ARP Cache）"></a>4. ARP 缓存表（ARP Cache）</h3><blockquote><p><strong>主机的 MAC 地址和 IP 地址，会被主机临时缓存起来，即在本地维护一张 ARP 表（ARP Cache），它的作用是：避免每次都广播请求，可以通过命令查看：<code>arp -a</code>。</strong></p></blockquote><ul><li><p><strong>ARP 只有在缓存失效的时候才会进行：</strong> ARP 缓存表中的每一条记录都有 <strong>生命周期（一般 60~120 秒）</strong>，在这段时间内主机会直接使用，不会重新发 ARP 请求。过期后再使用该 IP 通信时，才会重新广播询问。</p></li><li><p><strong>可以“扫描网段”来获取所有主机的 MAC 地址：</strong> 在同一个局域网内，我们知道：本机的 IP，例如 192.168.1.10，子网掩码：255.255.255.0 → 网络号：192.168.1.0&#x2F;24，那就可以从 192.168.1.1 到 192.168.1.254 依次 ping。每 ping 一个地址，系统都会自动触发一次 ARP 查询。 查询结果（IP-MAC 映射）就会缓存在本机 ARP 表中。工具命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">arp -n<span class="comment"># 查看本机 ARP 缓存</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者使用 nmap 自动扫描局域网主机</span></span><br><span class="line"><span class="built_in">sudo</span> apt install nmap</span><br><span class="line"><span class="built_in">sudo</span> apt install -y nmap</span><br><span class="line"><span class="built_in">sudo</span> nmap -sn 192.168.1.0/24</span><br></pre></td></tr></table></figure></li><li><p><strong>若收到多次同样的 ARP 应答，以最新为准：</strong> ARP 缓存表是动态维护的，<strong>新的应答会覆盖旧的记录</strong>，这正是 ARP 欺骗能攻击的原因之一！攻击者伪造应答包欺骗网关，篡改缓存表，从而劫持流量。</p></li></ul><h3 id="5-为什么不直接用广播通信？"><a href="#5-为什么不直接用广播通信？" class="headerlink" title="5. 为什么不直接用广播通信？"></a>5. 为什么不直接用广播通信？</h3><p>理论上确实可以直接广播发数据帧（IP 层再判断是否是给自己的），但这会带来：</p><ol><li>大量无关主机都要交给内核处理（浪费 CPU&#x2F;内存资源）。</li><li>破坏单播&#x2F;广播的语义。</li><li>极大降低局域网效率（广播风暴）。</li></ol><p>所以我们必须依赖 ARP，在底层就精确确定目标 MAC。</p><h3 id="6-ARP-欺骗"><a href="#6-ARP-欺骗" class="headerlink" title="6. ARP 欺骗"></a>6. ARP 欺骗</h3><blockquote><p>以下操作 <strong>仅限授权测试（如自己搭建的实验环境）</strong>，在他人网络中实施 ARP 欺骗属于 <strong>违法行为</strong>（违反《网络安全法》）。 </p></blockquote><h4 id="1-推荐工具：arpspoof（来自-dsniff-套件）"><a href="#1-推荐工具：arpspoof（来自-dsniff-套件）" class="headerlink" title="1. 推荐工具：arpspoof（来自 dsniff 套件）"></a>1. 推荐工具：<code>arpspoof</code>（来自 <code>dsniff</code> 套件）</h4><p>Centos 7.6 中安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> yum install -y epel-release<span class="comment"># 启用 EPEL 仓库（多数网络工具在 EPEL）</span></span><br><span class="line"><span class="built_in">sudo</span> yum makecache<span class="comment"># 更新缓存（可选）</span></span><br><span class="line"><span class="built_in">sudo</span> yum install -y nmap dsniff<span class="comment"># 安装 nmap 与 dsniff</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证安装</span></span><br><span class="line">nmap --version</span><br><span class="line"><span class="built_in">which</span> dsniff || rpm -qa | grep dsniff</span><br></pre></td></tr></table></figure><p>Ubuntu 22.04 中安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt update<span class="comment"># 更新包索引（可选但推荐）</span></span><br><span class="line"><span class="built_in">sudo</span> apt install -y nmap<span class="comment"># 安装 nmap（APT 版本）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者用 snap（若你偏好 snap 版本）</span></span><br><span class="line"><span class="comment"># sudo snap install nmap</span></span><br><span class="line"></span><br><span class="line">nmap --version<span class="comment"># 安装后验证</span></span><br></pre></td></tr></table></figure><hr><h4 id="2-arpspoof-命令参数含义（不是固定的，必须根据目标改！）"><a href="#2-arpspoof-命令参数含义（不是固定的，必须根据目标改！）" class="headerlink" title="2. arpspoof 命令参数含义（不是固定的，必须根据目标改！）"></a>2. <code>arpspoof</code> 命令参数含义（不是固定的，必须根据目标改！）</h4><p>命令格式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> arpspoof -i &lt;网卡名&gt; -t &lt;目标主机IP&gt; &lt;欺骗对象IP&gt;</span><br></pre></td></tr></table></figure><p><strong>各参数解释：</strong></p><table><thead><tr><th>参数</th><th>说明</th><th>必须改吗？</th></tr></thead><tbody><tr><td><code>-i eth0</code></td><td>你当前联网的网卡（可能是 <code>wlan0</code>、<code>ens33</code> 等）</td><td>必须改成你自己的网卡</td></tr><tr><td><code>-t 192.168.1.100</code></td><td><strong>你要欺骗的那台主机的 IP</strong>（受害者）</td><td>必须指定目标</td></tr><tr><td><code>192.168.1.1</code></td><td><strong>你冒充的对象的 IP</strong>（通常是网关）</td><td>必须指定冒充谁</td></tr></tbody></table><blockquote><p><strong>为什么需要两个 IP？</strong><br>因为 ARP 欺骗的本质是：<strong>“让 A 相信 B 的 MAC 地址是我（攻击者）的”</strong>，所以你需要告诉 <code>arpspoof</code>：</p><ul><li><strong>谁被骗？</strong> → <code>-t 192.168.1.100</code>（目标主机）。</li><li><strong>冒充谁？</strong> → <code>192.168.1.1</code>（通常是网关）。</li></ul></blockquote><h4 id="3-ARP-欺骗"><a href="#3-ARP-欺骗" class="headerlink" title="3. ARP 欺骗"></a>3. ARP 欺骗</h4><blockquote><p>[[网络科普] 一个视频看懂 ARP 与 ARP 攻击 | B 站](<a href="https://www.bilibili.com/video/BV1MSKfz1ExS/?share_source">https://www.bilibili.com/video/BV1MSKfz1ExS/?share_source</a> &#x3D; copy_web&amp;vd_source &#x3D; 872e5e3ccf44874c39edaf42e30ab0de)</p><p><a href="https://www.bilibili.com/video/BV1B3PxeKEsV/?share_source=copy_web&vd_source=872e5e3ccf44874c39edaf42e30ab0de">【城】网络高手让你断网的方法竟是…如何预防？(ARP 协议与攻击防护) | B 站</a></p></blockquote><blockquote><p><span style="color:#FF0000;"><strong>⚠️ 重要法律与道德声明 ⚠️</strong></span></p><p><span style="color:#FF0000;">本指南仅用于 <strong>网络安全学习、实验环境搭建及授权渗透测试</strong>。</span></p><p><span style="color:#FF0000;">在 <strong>未经授权</strong> 的情况下，对他人网络、设备或服务实施 ARP 欺骗、流量劫持、数据嗅探等行为，属于 <strong>严重违法行为</strong>，违反《中华人民共和国网络安全法》、《刑法》第 285 条（非法侵入计算机信息系统罪）及第 286 条（破坏计算机信息系统罪）。</span></p><p><span style="color:#FF0000;">请务必在以下场景中使用本指南：</span></p><ul><li><span style="color:#FF0000;">自己搭建的虚拟机环境（如 VirtualBox&#x2F;VMware）</span></li><li><span style="color:#FF0000;">经过明确书面授权的渗透测试项目</span></li><li><span style="color:#FF0000;">教学机构提供的实验平台</span></li></ul><p><span style="color:#FF0000;">禁止在公共网络、公司内网、云服务器或任何非授权环境中进行此类操作。</span></p><p><span style="color:#FF0000;">学习安全技术的目的是为了更好地保护网络，而非攻击。请遵守法律法规，做一名负责任的安全从业者。 </span></p></blockquote><p><strong>前提条件：设备需要处于同一个子网下，如：同一 WiFi、热点等。云服务器存在限制，大概率是不行的。效果：目标主机断网。</strong></p><ol><li>查自己的网卡名和网关（只需做一次）：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ip a                    <span class="comment"># 看网卡名（如 eth0、ens33、wlan0）</span></span><br><span class="line">ip route show default   <span class="comment"># 看网关 IP（如 192.31.0.1）</span></span><br></pre></td></tr></table></figure><ol start="2"><li>如果不知道目标 IP，就用 nmap 扫描同网段找活跃主机（可选）：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -sn 192.31.0.0/20   <span class="comment"># 把 192.31.0.0/20 换成你的真实子网，从结果里选一个目标 IP，不想计算可以直接选择 ip a 的结果，或者使用其他工具进行计算</span></span><br></pre></td></tr></table></figure><ol start="3"><li>开启 IP 转发（让流量经过你再转发出去）：</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="number">1</span> | sudo tee /proc/sys/net/ipv4/ip_forward</span><br></pre></td></tr></table></figure><ol start="4"><li>发起 ARP 欺骗：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> arpspoof -i 网卡名 -t 目标IP 网关IP</span><br></pre></td></tr></table></figure><ol start="5"><li>在目标机上进行验证：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arp -a | grep 网关IP</span><br></pre></td></tr></table></figure><ol start="6"><li>停止攻击并恢复网络：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 停止 arpspoof (按 Ctrl+C)</span></span><br><span class="line"><span class="comment"># 2. 关闭 IP 转发</span></span><br><span class="line"><span class="built_in">echo</span> 0 | <span class="built_in">sudo</span> <span class="built_in">tee</span> /proc/sys/net/ipv4/ip_forward</span><br></pre></td></tr></table></figure><blockquote><p>在 kali 中感觉会容易一点：注意虚拟机中要把网络适配器改成 <strong>NAT 模式</strong> 或者 <strong>桥接模式（勾选复制物理网络连接状态）</strong> 直连真实的物理网络。</p><ol><li>先切换到 root，执行：<code>ifconfig</code> 拿到 IP，用 <code>route -n</code> 拿到网关（”default” 或 “0.0.0.0” 行对应的就是默认网关，或者看 Flags 项：<code>UG</code> 标志中的 <code>G</code> 表示这是一个网关）。</li><li>用 <code>fping -g 自己的 IP</code> 或者 <code>nmap -sn 自己的IP</code> 找到当前局域网下所有活跃、活着的 IP（alive）。</li><li>开启 IP 转发（让流量能经 Kali 转发）：<code>echo 1 | sudo tee /proc/sys/net/ipv4/ip_forward</code>。</li><li>开始攻击：<code>arpspoof -i 网卡名 -t 目标IP 要冒充的IP/网关IP</code>，比如：<code>arpspoof -i eth0 -t 192.168.72.130 192.168.72.2</code>。</li><li>停止攻击：<code>echo 0 | sudo tee /proc/sys/net/ipv4/ip_forward</code>。</li></ol></blockquote>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;数据链路层&quot;&gt;&lt;a href=&quot;#数据链路层&quot; class=&quot;headerlink&quot; title=&quot;数据链路层&quot;&gt;&lt;/a&gt;数据链路层&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a</summary>
        
      
    
    
    
    <category term="Linux" scheme="https://www.minbit.top/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://www.minbit.top/tags/Linux/"/>
    
    <category term="网络" scheme="https://www.minbit.top/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>053 网络层 —— IP 协议</title>
    <link href="https://www.minbit.top/posts/60727.html"/>
    <id>https://www.minbit.top/posts/60727.html</id>
    <published>2025-10-08T04:00:00.000Z</published>
    <updated>2025-10-08T04:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="网络层-——-IP-协议"><a href="#网络层-——-IP-协议" class="headerlink" title="网络层 —— IP 协议"></a>网络层 —— IP 协议</h1><blockquote><p><a href="https://blog.csdn.net/chenlong_cxy/article/details/125837340">网络层协议 ——— IP 协议 | CSDN</a></p><p><a href="https://blog.csdn.net/m0_73281594/article/details/147008726">网络层 IP 协议 | CSDN</a></p><p><a href="https://www.bilibili.com/video/BV1HL41117tZ/?share_source=copy_web&vd_source=872e5e3ccf44874c39edaf42e30ab0de">为什么大家的 IP 都是 192.168 开头的？| B 站（荐）</a></p><p><a href="https://www.bilibili.com/video/BV1DD4y127r4/?share_source=copy_web&vd_source=872e5e3ccf44874c39edaf42e30ab0de">【硬核科普】IP 地址是什么东西？IPV6 和 IPV4 有什么区别？公网 IP 和私有 IP 又是什么？| B 站（荐）</a></p></blockquote><h2 id="1-IP-地址的本质：网络号-主机号"><a href="#1-IP-地址的本质：网络号-主机号" class="headerlink" title="1. IP 地址的本质：网络号 + 主机号"></a>1. IP 地址的本质：网络号 + 主机号</h2><p>IP 地址由两部分组成：</p><table><thead><tr><th>部分</th><th>作用</th><th>举例</th></tr></thead><tbody><tr><td><strong>网络号 (Network ID)</strong></td><td>表示属于哪个子网</td><td>192.168.10.<strong>0</strong></td></tr><tr><td><strong>主机号 (Host ID)</strong></td><td>表示子网内的哪台主机</td><td>192.168.10.<strong>15</strong></td></tr></tbody></table><p><strong>规律：</strong></p><ul><li><strong>同一子网内</strong>：网络号相同，主机号不同。</li><li><strong>不同子网</strong>：网络号不同，主机号可以重复。</li></ul><p><strong>举例：</strong></p><ul><li>子网 A：192.168.1.0&#x2F;24</li><li>子网 B：192.168.2.0&#x2F;24</li></ul><p>两个子网的主机号范围都可是 1–254，不冲突，因为网络号不同。</p><h2 id="2-IP-地址划分基础"><a href="#2-IP-地址划分基础" class="headerlink" title="2. IP 地址划分基础"></a>2. IP 地址划分基础</h2><h3 id="1-划分目的"><a href="#1-划分目的" class="headerlink" title="1. 划分目的"></a>1. 划分目的</h3><blockquote><p><strong>根本目的就是为了高效管理、节省地址、提升安全和性能。</strong></p></blockquote><p>最初，互联网只分为 <strong>A、B、C 类地址</strong>（分类地址），但从 1993 年起，RFC 1519 正式引入 CIDR，<strong>CIDR（无类别域间路由） + 子网掩码灵活划分</strong> 彻底取代了 A&#x2F;B&#x2F;C 类的刚性结构，于是就出现了现代 IP 地址分类图：</p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20251007173226991.png" alt="PixPin_2025-10-07_17-32-21"></p><table><thead><tr><th>类别</th><th>起始位</th><th>首字节范围</th><th>网络（号）位数</th><th>主机（号）位数</th><th>用途</th><th>典型示例</th></tr></thead><tbody><tr><td>A 类</td><td>0</td><td>0–127</td><td>8</td><td>24</td><td>特大型网络</td><td>10.0.0.0</td></tr><tr><td>B 类</td><td>10</td><td>128–191</td><td>16</td><td>16</td><td>中型网络</td><td>172.16.0.0</td></tr><tr><td>C 类</td><td>110</td><td>192–223</td><td>24</td><td>8</td><td>小型网络（家庭&#x2F;小公司）</td><td>192.168.0.0</td></tr><tr><td>D 类</td><td>1110</td><td>224–239</td><td>——</td><td>——</td><td>多播&#x2F;组播（Multicast）</td><td>224.0.0.1</td></tr><tr><td>E 类</td><td>11110</td><td>240–255</td><td>——</td><td>——</td><td>保留（实验&#x2F;未来）</td><td>240.0.0.0</td></tr></tbody></table><p><strong>问题</strong>：</p><ul><li>某公司有 1000 台主机，用 C 类不够（254），用 B 类又太多（浪费），IP 资源有限，这样分配太粗。</li><li>而且所有主机在一个广播域，广播风暴、安全隔离都成问题。</li></ul><p><strong>所以，必须打破 A&#x2F;B&#x2F;C 类的限制，按实际需求“切分”IP 地址块</strong> —— 这就是 <strong>子网划分</strong> 的核心目的，于是 <strong>子网划分</strong> 就此出现。</p><h3 id="2-CIDR-是什么？"><a href="#2-CIDR-是什么？" class="headerlink" title="2. CIDR 是什么？"></a>2. CIDR 是什么？</h3><p><strong>CIDR &#x3D; Classless Inter-Domain Routing（无类别域间路由），核心思想：不再看第一个字节的前几位来判断是 A&#x2F;B&#x2F;C，而是用“斜杠 + 数字”表示网络位长度。</strong> 例如：</p><ul><li><code>192.168.1.0/24</code> → 不管它是 C 类，我们说“前 24 位是网络号”</li><li><code>10.0.0.0/8</code> → 不管它是 A 类，我们说“前 8 位是网络号”</li><li><code>172.16.0.0/16</code> → 不管它是 B 类，我们说“前 16 位是网络号”</li></ul><p><strong>现在所有网络设备（路由器、交换机、Linux、Windows）都支持 CIDR！</strong> 而我们只需要记住：</p><ol><li><strong>私有 IP 地址范围（面试常问！）</strong><ul><li>A 类：<code>10.0.0.0/8</code> → 10.0.0.0 ~ 10.255.255.255。</li><li>B 类：<code>172.16.0.0/12</code> → 172.16.0.0 ~ 172.31.255.255。</li><li>C 类：<code>192.168.0.0/16</code> → 192.168.0.0 ~ 192.168.255.255。</li></ul></li><li><strong>公有 IP 地址</strong> → 由 ISP 分配，全球唯一，可用于互联网访问。</li><li><strong>子网划分完全基于 CIDR 和子网掩码，与 A&#x2F;B&#x2F;C 无关！</strong></li></ol><h3 id="3-什么是子网（Subnet）——-网络号相同的一组主机"><a href="#3-什么是子网（Subnet）——-网络号相同的一组主机" class="headerlink" title="3. 什么是子网（Subnet）—— 网络号相同的一组主机"></a>3. 什么是子网（Subnet）—— 网络号相同的一组主机</h3><blockquote><p><strong>同一子网：网络号相同的一组主机；不同子网：网络号不同的主机。后文会提到。</strong></p></blockquote><p><strong>子网</strong>：把原来的一个网络再细分成多个更小的网络（称为“子网”），每个子网都能独立使用。这样做有两个核心目的：</p><ol><li><strong>节约 IP 地址</strong> —— 合理利用地址空间。</li><li><strong>便于网络管理</strong> —— 不同部门、楼层或业务线用不同子网，方便隔离与路由。</li></ol><h3 id="4-子网掩码（Subnet-Mask）"><a href="#4-子网掩码（Subnet-Mask）" class="headerlink" title="4. 子网掩码（Subnet Mask）"></a>4. 子网掩码（Subnet Mask）</h3><p>子网划分的关键就是 <strong>子网掩码</strong>，它用来区分“网络号”和“主机号”。它和 IP 地址配合，告诉设备：“哪些位是网络部分，哪些是主机部分”。常见写法：</p><ul><li><code>255.255.255.0</code>（等价于 <code>/24</code>）。</li><li><code>255.255.0.0</code>（等价于 <code>/16</code>）。</li><li><code>255.255.255.128</code>（等价于 <code>/25</code>）。</li></ul><blockquote><p><strong>记住：&#x2F;后面的数字 &#x3D; 网络位的总位数（从左往右数 1 的个数）</strong></p></blockquote><h4 id="1-举个实际例子"><a href="#1-举个实际例子" class="headerlink" title="1. 举个实际例子"></a>1. 举个实际例子</h4><p>有一个 C 类地址：<code>192.168.1.0/24</code>，默认只能有 1 个网络，254 台主机（192.168.1.1 ~ 192.168.1.254）。但公司有 <strong>3 个部门</strong>，希望彼此隔离（财务、研发、销售），怎么办？</p><p><strong>划分子网！</strong> 把 <code>/24</code> 改成 <code>/26</code>：</p><ul><li>网络位从 24 位 → 26 位（多借 2 位）。</li><li>可用子网数：2² &#x3D; <strong>4 个子网</strong>。</li><li>每个子网主机数：2^(32-26) - 2 &#x3D; 64 - 2 &#x3D; <strong>62 台</strong>（减 2 是去掉网络地址和广播地址）。</li></ul><p>子网划分结果：</p><table><thead><tr><th>子网</th><th>网络地址</th><th>可用 IP 范围</th><th>广播地址</th></tr></thead><tbody><tr><td>1</td><td>192.168.1.0</td><td>192.168.1.1 ~ 192.168.1.62</td><td>192.168.1.63</td></tr><tr><td>2</td><td>192.168.1.64</td><td>192.168.1.65 ~ 192.168.1.126</td><td>192.168.1.127</td></tr><tr><td>3</td><td>192.168.1.128</td><td>…</td><td>192.168.1.191</td></tr><tr><td>4</td><td>192.168.1.192</td><td>…</td><td>192.168.1.255</td></tr></tbody></table><hr><h2 id="3-IP（IPv4）-协议报头解析"><a href="#3-IP（IPv4）-协议报头解析" class="headerlink" title="3. IP（IPv4） 协议报头解析"></a>3. IP（IPv4） 协议报头解析</h2><blockquote><p>IPv4 报头 20 字节起，包含版本、长度、TOS、总长、ID、标志、偏移、TTL、协议、校验和、源&#x2F;目的 IP。其中 TTL 用于防环，协议号决定上层协议，校验和只保护报头，分片靠 ID + 偏移 + 标志控制。现代网络主要用 CIDR 和 TTL&#x2F;Protocol，选项基本废弃。</p><ul><li><strong>IP 报头标准长度 &#x3D; 20 字节</strong>（无选项时）</li><li><strong>IP 报头最大长度 &#x3D; 60 字节</strong>（带选项时）</li><li><strong>本质是内核里的结构体</strong>：<code>struct iphdr</code>（Linux 中定义在 <code>&lt;linux/ip.h&gt;</code>）</li></ul></blockquote><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20251007174941328.png" alt="PixPin_2025-10-07_17-49-36"></p><table><thead><tr><th>字段名</th><th>位数</th><th>作用</th><th>说明</th></tr></thead><tbody><tr><td><strong>版本 (Version)</strong></td><td>4</td><td>指定 IP 协议版本</td><td>IPv4 为 4，IPv6 为 6</td></tr><tr><td><strong>首部长度 (IHL)</strong></td><td>4</td><td>表示报头长度（单位：4 字节）</td><td>常见值为 5 → 5×4 &#x3D; 20 字节；最大 15→60 字节</td></tr><tr><td><strong>服务类型 (TOS &#x2F; DSCP)</strong></td><td>8</td><td>指导路由器如何转发（QoS）</td><td>可指定最小延迟、最大吞吐、最高可靠、最低成本</td></tr><tr><td><strong>总长度 (Total Length)</strong></td><td>16</td><td>报文整体长度（头 + 数据）</td><td>最大 65535 字节</td></tr><tr><td><strong>标识 (Identification)</strong></td><td>16</td><td>数据分片标识</td><td>同一报文的所有分片使用相同 ID</td></tr><tr><td><strong>标志 (Flags)</strong></td><td>3</td><td>控制分片行为</td><td>含 DF（不分片）和 MF（后续有分片）</td></tr><tr><td><strong>片偏移 (Fragment Offset)</strong></td><td>13</td><td>当前分片在原报文中的偏移位置</td><td>单位为 8 字节</td></tr><tr><td><strong>生存时间 (TTL)</strong></td><td>8</td><td>报文能经过的最大路由跳数</td><td>每过一跳减 1，为 0 时丢弃，防止死循环</td></tr><tr><td><strong>协议 (Protocol)</strong></td><td>8</td><td>指明 IP 的有效载荷交付上层的协议类型</td><td>TCP &#x3D; 6，UDP &#x3D; 17，ICMP &#x3D; 1</td></tr><tr><td><strong>首部校验和 (Header Checksum)</strong></td><td>16</td><td>检查报头是否被破坏</td><td>每个路由器都要重新计算一次</td></tr><tr><td><strong>源 IP 地址 (Source Address)</strong></td><td>32</td><td>发送端地址</td><td>IPv4 地址</td></tr><tr><td><strong>目的 IP 地址 (Destination Address)</strong></td><td>32</td><td>接收端地址</td><td>IPv4 地址</td></tr><tr><td><strong>可选项 (Options)</strong></td><td>可变</td><td>一些特殊用途</td><td>如时间戳、安全、路由记录等</td></tr></tbody></table><hr><h2 id="4-路由器到底是什么？"><a href="#4-路由器到底是什么？" class="headerlink" title="4. 路由器到底是什么？"></a>4. 路由器到底是什么？</h2><blockquote><p><strong>路由器 &#x3D; 有多张网卡的特殊主机。</strong></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20251007183027623.png" alt="PixPin_2025-10-07_18-30-22"></p><h3 id="1-路由器本质是一台多网卡的专用主机"><a href="#1-路由器本质是一台多网卡的专用主机" class="headerlink" title="1. 路由器本质是一台多网卡的专用主机"></a>1. 路由器本质是一台多网卡的专用主机</h3><p>每个物理&#x2F;逻辑接口（网卡）连接一个子网，每个接口必须配置一个 <strong>属于该子网的 IP 地址</strong>，它在每个连接的子网中，都相当于一台普通主机。所以：<strong>路由器本身“属于”多个子网</strong>，但它 <strong>不是普通主机</strong>（不跑业务应用，只转发）。</p><h3 id="2-路由器必须至少连接两个子网"><a href="#2-路由器必须至少连接两个子网" class="headerlink" title="2. 路由器必须至少连接两个子网"></a>2. 路由器必须至少连接两个子网</h3><p>一张网卡对应一个子网，两张网卡以上才能“转发”不同子网的数据，所以路由器一定“同时属于多个子网”。否则就叫“单臂路由”或根本不是路由器（比如家用光猫只接一个 LAN，其实是桥接）。</p><table><thead><tr><th>接口</th><th>连接子网</th><th>配置 IP</th></tr></thead><tbody><tr><td>eth0</td><td>192.168.1.0&#x2F;24</td><td>192.168.1.1</td></tr><tr><td>eth1</td><td>192.168.2.0&#x2F;24</td><td>192.168.2.1</td></tr></tbody></table><p>这样它就能把 A 子网和 B 子网互联。</p><h3 id="3-路由器接口-IP-通常是-1，但不是强制规定！"><a href="#3-路由器接口-IP-通常是-1，但不是强制规定！" class="headerlink" title="3. 路由器接口 IP 通常是 .1，但不是强制规定！"></a>3. 路由器接口 IP 通常是 .1，但不是强制规定！</h3><p>一般路由器是子网中第一台设备（方便识别）。所以它的地址常为 <strong>“网络号 + .1”</strong>。例如：192.168.10.0&#x2F;24 → 路由器常用 IP：192.168.10.1，因为：</p><ul><li><p>网络地址（.0）不能用、广播地址（.255）不能用</p></li><li><p>.1 最顺手、易记（这不是硬性规定，而是一种行业约定，便于统一管理）。</p></li><li><p>但可以设成 .254、.100，只要在子网范围内就行！</p></li></ul><p><strong>关键</strong>：所有主机的“默认网关”要指向这个 IP。</p><h3 id="4-路由器的核心功能"><a href="#4-路由器的核心功能" class="headerlink" title="4. 路由器的核心功能"></a>4. 路由器的核心功能</h3><table><thead><tr><th>功能</th><th>说明</th></tr></thead><tbody><tr><td><strong>数据转发</strong></td><td>根据路由表选择下一跳，把 IP 报文送到目标子网</td></tr><tr><td><strong>子网构建</strong></td><td>可以划分并管理局域网（LAN）</td></tr><tr><td><strong>DHCP 分配</strong></td><td>自动给新主机分配 IP（DHCP 服务器功能）</td></tr><tr><td><strong>NAT 转换</strong></td><td>私网 IP ↔ 公网 IP 转换，实现上网访问</td></tr><tr><td><strong>防火墙 &#x2F; ACL</strong></td><td>过滤、限制特定流量</td></tr></tbody></table><blockquote><p><strong>路由器不“构建”子网，它“连接”子网！</strong> 子网是由 <strong>IP 地址 + 子网掩码</strong> 定义的逻辑网络，物理上靠交换机&#x2F;网线连接，逻辑上靠路由器互联。</p></blockquote><blockquote><p>“子网是由 IP 地址和子网掩码定义的逻辑网络，路由器通过多个接口连接不同子网，每个接口配置对应子网的 IP（通常为 .1），负责跨子网 IP 转发和广播隔离。子网划分基于 CIDR，DHCP 仅用于自动分配地址，非路由器核心功能。”</p></blockquote><hr><h2 id="5-特殊的-IP-地址"><a href="#5-特殊的-IP-地址" class="headerlink" title="5. 特殊的 IP 地址"></a>5. 特殊的 IP 地址</h2><p>我们把 IPv4 的 32 位地址分成两部分：<strong>网络号（Net ID）</strong> 和 <strong>主机号（Host ID）</strong>。根据主机号的取值（全 0、全 1、特殊段），出现了几种特殊地址：</p><table><thead><tr><th>类型</th><th>主机号情况</th><th>举例</th><th>含义</th><th>特点</th></tr></thead><tbody><tr><td><strong>网络地址</strong></td><td>主机号全为 0</td><td><code>xxx.xxx.xxx.0</code>（主机位全 0） 如 <code>192.168.1.0/24</code></td><td>表示整个子网</td><td>不能分配给具体主机</td></tr><tr><td><strong>广播地址</strong></td><td>主机号全为 1</td><td><code>xxx.xxx.xxx.255</code>（主机位全 1） 如&#96;&#96;192.168.1.255&#x2F;24&#96;</td><td>用于给子网内所有主机广播&#x2F;发包</td><td>局域网广播，不能分配给主机</td></tr><tr><td><strong>环回地址</strong></td><td><code>127.0.0.0/8</code> 段</td><td>常用 <code>127.0.0.1</code></td><td>回环测试（本机通信）</td><td>仅本机可用，不经过网卡</td></tr><tr><td><strong>私有地址</strong></td><td>特定保留段</td><td><code>10.0.0.0/8</code>&#x2F;<code>172.16.0.0/12</code>&#x2F;<code>192.168.0.0/16</code></td><td>局域网内部使用，即内网专用，不能上公网</td><td>可在局域网自由使用，不可直接访问公网</td></tr><tr><td><strong>公网地址</strong></td><td>非保留段</td><td>例：<code>8.8.8.8</code></td><td>由 ISP 分配，用于互联网通信</td><td>唯一、可路由</td></tr><tr><td><strong>0.0.0.0</strong></td><td>特殊源地址</td><td>具体含义需结合使用场景、上下文进行判断</td><td>不是真实地址，而是占位符。表示“任意地址”&#x2F;“本机未配置 IP”&#x2F;“默认路由” 等</td><td>不能配置给主机，路由表中表示默认网关</td></tr></tbody></table><blockquote><p>  提示：</p><ul><li>主机号全 0：代表“网络本身”。</li><li>主机号全 1：代表“该网络内的广播”。</li><li>“为什么不能 ping 通 192.168.1.0？” → 因为是网络地址，不是主机。</li></ul></blockquote><h2 id="6-IPv4-地址数量限制"><a href="#6-IPv4-地址数量限制" class="headerlink" title="6. IPv4 地址数量限制"></a>6. IPv4 地址数量限制</h2><h3 id="1-为什么“43-亿”-IP-地址不够用？"><a href="#1-为什么“43-亿”-IP-地址不够用？" class="headerlink" title="1. 为什么“43 亿” IP 地址不够用？"></a>1. 为什么“43 亿” IP 地址不够用？</h3><p><strong>IPv4 是 32 位二进制地址，理论总数：2³² &#x3D; 4,294,967,296（约 43 亿）。 实际可用远少于 43 亿：</strong></p><ul><li>有大量地址被保留（例如环回、私网、广播等）。</li><li>每个设备的 <strong>每张网卡</strong> 都要一个 IP（一台服务器常常有多个网卡，就要多个 IP）。</li><li>早期大公司（如 MIT、Ford）拿走了整段 A 类地址（1600 万个 IP），导致 <strong>地址分配不均</strong>，造成巨大浪费。</li><li>网络分段、地址浪费（如传统 A&#x2F;B&#x2F;C 类）。</li><li><strong>不能按主机数分配</strong>：即使一台电脑，也可能配多个 IP（虚拟主机、容器等）。</li></ul><h3 id="2-如何解决-IPv4-地址枯竭？"><a href="#2-如何解决-IPv4-地址枯竭？" class="headerlink" title="2. 如何解决 IPv4 地址枯竭？"></a>2. 如何解决 IPv4 地址枯竭？</h3><h4 id="1-动态分配-IP（DHCP）"><a href="#1-动态分配-IP（DHCP）" class="headerlink" title="1. 动态分配 IP（DHCP）"></a>1. 动态分配 IP（DHCP）</h4><p><strong>原理：IP 地址池共享，设备上线时分配，下线时回收。优点：提高利用率，局限：无法解决“同时在线设备数 &gt; 可用公网 IP”的问题。</strong> 场景：</p><ul><li>家庭&#x2F;公司路由器：100 台设备，但只有 50 人同时在线 → 只需 50 个 IP。</li><li>学校机房：500 台电脑，但分批使用 → IP 复用。</li></ul><h4 id="2-NAT（网络地址转换）——-最广泛应用！"><a href="#2-NAT（网络地址转换）——-最广泛应用！" class="headerlink" title="2. NAT（网络地址转换）—— 最广泛应用！"></a>2. NAT（网络地址转换）—— 最广泛应用！</h4><p><strong>原理：内网用私有 IP（如 192.168.x.x），出公网时由路由器将 私有 IP + 端口 映射为 一个公网 IP + 不同端口。</strong></p><ul><li><strong>效果：</strong> 成千上万台内网设备，<strong>共享 1 个公网 IP</strong> 上网，公网看不到内网结构，还提升了安全性。</li><li><strong>类型：</strong><ul><li><strong>SNAT（源 NAT）</strong>：内网 → 外网（最常见）。</li><li><strong>DNAT（目的 NAT）</strong>：外网 → 内网（如端口映射：公网 80 → 内网 192.168.1.100:80）。</li></ul></li><li><strong>Linux 实现</strong>：<code>iptables</code> &#x2F; <code>nftables</code> 的 <code>MASQUERADE</code> 或 <code>SNAT</code> 规则。</li></ul><blockquote><p>  NAT 是解决 IPv4 地址不足的核心技术，通过端口复用实现多对一映射。</p></blockquote><h4 id="3-IPv6-——-终极解决方案"><a href="#3-IPv6-——-终极解决方案" class="headerlink" title="3. IPv6 —— 终极解决方案"></a>3. IPv6 —— 终极解决方案</h4><p><strong>地址长度</strong>：128 位 → 地址数 &#x3D; 2¹²⁸ ≈ <strong>3.4×10³⁸</strong>（地球每平方米可分配 10²⁸ 个 IP！）。特点：</p><ul><li>无 NAT（理论上每个设备都有公网 IP）。</li><li>自动配置（SLAAC）。</li><li>报头更简洁，支持流标签、安全扩展。</li></ul><blockquote><p>  虽然 IPv6 是未来，但因历史包袱和成本，IPv4 + NAT 仍是当前主流。</p></blockquote><h3 id="3-杂谈"><a href="#3-杂谈" class="headerlink" title="3. 杂谈"></a>3. 杂谈</h3><blockquote><p>中国的 IPv6 技术目前遥遥领先！</p></blockquote><p>中国的互联网设备数量庞大——光是手机、电脑、物联网设备加起来，早已超过这个数十倍。所以必须找一个更大的地址空间方案，就是 IPv6。对中国来说，这意味着 <strong>从根本上解决地址短缺、NAT 层层嵌套等痛点问题。从国家战略层面来说：是为了实现自主可控 + 下一代网络主导权：</strong></p><ul><li>IPv6 是未来网络的核心基础，涉及骨干网、物联网、云计算、AI 等所有领域。</li><li>早早布局 IPv6，可以减少对旧技术的依赖，<strong>在全球网络标准中占据话语权</strong>。</li></ul><h4 id="1-为什么不能“一键切换”-IPv4-→-IPv6？"><a href="#1-为什么不能“一键切换”-IPv4-→-IPv6？" class="headerlink" title="1. 为什么不能“一键切换” IPv4 → IPv6？"></a>1. 为什么不能“一键切换” IPv4 → IPv6？</h4><p>这点很多人误解了。IPv6 并不是 IPv4 的“升级包”，而是一个 <strong>全新的协议体系</strong>。具体困难主要在三点：</p><ol><li><strong>不兼容设计：</strong> IPv4 和 IPv6 报头结构完全不同，IPv6 无法直接理解 IPv4 报文（例如校验和、地址长度都不同）。所以 IPv4 网络设备、路由器、应用软件都得重新支持 IPv6。</li><li><strong>全球网络规模太庞大：</strong> 互联网中有无数旧设备、老系统（银行、工厂、政府网络等）仍在用 IPv4，不可能让全球数十亿设备在同一时刻同时换协议。</li><li><strong>转换与过渡成本太高：</strong> 企业需要重新配置网络、防火墙、DNS、安全策略，用户端还要兼容双栈（IPv4 + IPv6）运行，否则很多旧网站上不了。<strong>所以现在全球都采用“双栈机制”：IPv4 和 IPv6 并行运行，慢慢过渡。</strong></li></ol><hr><h2 id="7-私网-IP-地址和公网-IP-地址"><a href="#7-私网-IP-地址和公网-IP-地址" class="headerlink" title="7. 私网 IP 地址和公网 IP 地址"></a>7. 私网 IP 地址和公网 IP 地址</h2><blockquote><p>私有 IP 用于内网通信，公网 IP 全球唯一；运营商通过光纤、基站和 IP 分配构建网络基础设施；全球互联网像大学层级体系，靠子网掩码和路由表实现高效寻址；NAT 技术将私有 IP 映射为公网 IP，使内网设备能访问互联网，是 IPv4 时代解决地址枯竭的核心机制。</p></blockquote><h3 id="1-私有-IP-与-公网-IP：谁负责“内部”，谁负责“对外”"><a href="#1-私有-IP-与-公网-IP：谁负责“内部”，谁负责“对外”" class="headerlink" title="1. 私有 IP 与 公网 IP：谁负责“内部”，谁负责“对外”"></a>1. 私有 IP 与 公网 IP：谁负责“内部”，谁负责“对外”</h3><table><thead><tr><th align="center">对比</th><th>私有 IP</th><th>公网 IP</th></tr></thead><tbody><tr><td align="center"><strong>定义</strong></td><td>仅在局域网内有效，<strong>不能在互联网上路由（不可直接上公网）</strong></td><td>全球唯一，<strong>可在互联网上直接通信</strong></td></tr><tr><td align="center"><strong>用途</strong></td><td>局域网内部设备通信（手机、电脑、摄像头）</td><td>全球互联网上通信（全球唯一）</td></tr><tr><td align="center"><strong>地址范围</strong></td><td>-<code>10.0.0.0/8</code>（10.x.x.x） -<code>172.16.0.0/12</code>（172.16~31.x.x） -<code>192.168.0.0/16</code>（192.168.x.x）</td><td>除私有地址、保留地址外的所有 IPv4 地址</td></tr><tr><td align="center"><strong>谁分配</strong></td><td>用户&#x2F;管理员自行规划（如家用路由器自动分配）</td><td>由 <strong>IANA → RIR（如 APNIC）→ ISP（运营商）</strong> 逐级分配</td></tr><tr><td align="center"><strong>能否重复</strong></td><td>可以（不同公司都用 192.168.1.0&#x2F;24）</td><td>不可重复</td></tr><tr><td align="center"><strong>举例</strong></td><td>家用 WiFi、公司内网</td><td>云服务器、网站 IP</td></tr></tbody></table><blockquote><p>  私有 IP 就像“宿舍楼房间号”，只有本楼人懂；公网 IP 是“身份证号”，全国唯一。 </p></blockquote><h3 id="2-运营商：互联网的“基建狂魔”"><a href="#2-运营商：互联网的“基建狂魔”" class="headerlink" title="2. 运营商：互联网的“基建狂魔”"></a>2. 运营商：互联网的“基建狂魔”</h3><p>运营商即互联网服务提供商，它们的作用可以分为两层：</p><ol><li><p><strong>基础设施建设：</strong> 铺设光纤、建基站、建骨干网、机房、IDC 等，就像大学建教学楼、宿舍楼、操场，提供“物理层”环境。</p></li><li><p><strong>提供网络接入：</strong></p><ul><li><p><strong>分配公网 IP</strong>：家庭宽带、移动数据、企业专线等。</p></li><li><p><strong>提供接入服务</strong>：光猫（调制解调器）把光纤信号转成电信号，路由器再分发给内网设备，路由器再给每台设备分配 <strong>私有 IP</strong>，并通过 NAT 技术“借用”一个 <strong>公网 IP</strong> 出门上网。</p></li><li><p><strong>维护骨干网</strong>：确保跨省、跨国流量高效转发。</p></li></ul></li></ol><hr><h3 id="3-全球互联网与网段划分-——-大学的“层级管理”"><a href="#3-全球互联网与网段划分-——-大学的“层级管理”" class="headerlink" title="3. 全球互联网与网段划分 —— 大学的“层级管理”"></a>3. 全球互联网与网段划分 —— 大学的“层级管理”</h3><p>互联网的 IP 地址分配体系非常像大学的组织结构：</p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20251008003448484.png" alt="PixPin_2025-10-08_00-34-43"></p><table><thead><tr><th>网络层级</th><th>对应</th><th>类比：大学体系</th></tr></thead><tbody><tr><td><strong>IANA</strong>（国际互联网数字分配&#x2F;管理机构）</td><td>全球 IP 地址总管家</td><td>教育部：统一分配全国高校编号</td></tr><tr><td><strong>RIR</strong>（区域互联网注册机构，如 APNIC、ARIN 等）</td><td>按大洲分配地址块</td><td>教育厅：给各省分配高校名额</td></tr><tr><td><strong>ISP</strong>（运营商，如中国电信、移动）</td><td>向用户&#x2F;企业提供公网 IP</td><td>省教育厅 → 给某大学分配学号段（如 20250001~20259999）</td></tr><tr><td><strong>企业&#x2F;家庭网络</strong></td><td>使用私有 IP 或少量公网 IP</td><td>大学内部：院系 → 年级 → 班级 → 学生</td></tr><tr><td><strong>子网掩码</strong></td><td>划分网络边界</td><td>学号结构：前 4 位 &#x3D; 院系，中间 2 位 &#x3D; 年级，后 4 位 &#x3D; 个人编号</td></tr><tr><td><strong>路由器</strong></td><td>跨子网转发</td><td>班主任、院办、校务处：负责信息在不同层级间传递</td></tr></tbody></table><p><strong>学号类比：</strong> 每个学生（设备）都有唯一“学号”（IP），通常学号前几位能看出学院、年级、专业（就像子网掩码划分出的网段），如果学生证（IP）丢了，被其他学院的人（另一个网络）捡到，也能通过学号前缀快速查出属于哪个学院（网段）——这就是 <strong>路由转发原理</strong>。</p><hr><h3 id="4-私有网络与公网的关系：靠-NAT-桥接"><a href="#4-私有网络与公网的关系：靠-NAT-桥接" class="headerlink" title="4. 私有网络与公网的关系：靠 NAT 桥接"></a>4. 私有网络与公网的关系：靠 NAT 桥接</h3><p><strong>问题：</strong> 私有 IP 不能上公网！因为公网路由器 <strong>不认识</strong> <code>192.168.1.100</code>，会直接丢弃，而且全球有无数个 <code>192.168.1.100</code>，无法区分。</p><p><strong>解决方案：NAT（网络地址转换）</strong>，工作过程：</p><ol><li>你（<code>192.168.1.100:50000</code>）访问 <code>www.baidu.com:80</code>。</li><li>路由器收到包，<strong>把源 IP 改成自己的公网 IP</strong>（如 <code>203.0.113.45</code>），端口映射为 <code>60000</code>。</li><li>发往公网：<code>源=203.0.113.45:60000</code>，目的 &#x3D; <code>110.242.68.4:80</code>。</li><li>百度回包给 <code>203.0.113.45:60000</code>。</li><li>路由器查 NAT 表，<strong>还原为 <code>192.168.1.100:50000</code></strong>，转发给你。</li></ol><p><strong>效果</strong>：成千上万台内网设备，<strong>共享 1 个公网 IP</strong>，外网无法主动访问内网（天然防火墙），节省公网 IP 资源（核心价值！）。</p><blockquote><p>  <strong>云服务器为什么需要公网 IP？</strong> 因为我们要主动访问它（如 SSH、Web 服务），它必须有一个 <strong>全球可达的地址</strong>，所以云厂商会分配公网 IP（或通过 EIP 弹性绑定）。 </p></blockquote><hr><h2 id="8-NAT-技术的核心作用：让有限的公网-IP-服务更多设备"><a href="#8-NAT-技术的核心作用：让有限的公网-IP-服务更多设备" class="headerlink" title="8. NAT 技术的核心作用：让有限的公网 IP 服务更多设备"></a>8. NAT 技术的核心作用：让有限的公网 IP 服务更多设备</h2><h3 id="1-NAT-是什么？"><a href="#1-NAT-是什么？" class="headerlink" title="1. NAT 是什么？"></a>1. NAT 是什么？</h3><p><strong>NAT（Network Address Translation）</strong> —— 网络地址转换。它的本质是：在数据包经过路由器时，<strong>动态修改 IP 地址（以及端口号）</strong>，以便多个内网设备共用一个公网 IP 上网。</p><h3 id="2-为什么需要-NAT？"><a href="#2-为什么需要-NAT？" class="headerlink" title="2. 为什么需要 NAT？"></a>2. 为什么需要 NAT？</h3><p>IPv4 只有约 43 亿个地址（2³² 个），但设备早就远超这个数量。于是：每个家庭、公司内部设备（电脑、手机、打印机…）都使用 <strong>私有 IP</strong>，路由器对外只暴露一个 <strong>公网 IP</strong>，NAT 技术负责在出入网时做“翻译”。</p><h3 id="3-NAT-的工作过程"><a href="#3-NAT-的工作过程" class="headerlink" title="3. NAT 的工作过程"></a>3. NAT 的工作过程</h3><p>假设：</p><ul><li>家庭内网：192.168.0.10（你的电脑）。</li><li>路由器公网 IP：42.101.8.5。</li></ul><p>你访问百度时：<code>源 IP = 192.168.0.10    →   目的 IP = 180.101.49.12（百度）</code>，在出网时，NAT 做了替换：<code>源 IP = 42.101.8.5:40001（公网IP+端口） → 目的 IP = 180.101.49.12</code>，路由器保存一条映射表：<code>42.101.8.5:40001 ↔ 192.168.0.10:12345</code>，当百度返回数据时：<code>目的 IP = 42.101.8.5:40001</code>。路由器查表，发现要转给内网的 192.168.0.10，于是数据成功回到你的电脑。</p><p><strong>好处：</strong> 成千上万设备共享一个公网 IP，屏蔽内网结构，提高安全性，有效缓解 IPv4 地址不足问题。</p><h3 id="4-NAT-的三种常见类型（按转换粒度区分）"><a href="#4-NAT-的三种常见类型（按转换粒度区分）" class="headerlink" title="4. NAT 的三种常见类型（按转换粒度区分）"></a>4. NAT 的三种常见类型（按转换粒度区分）</h3><table><thead><tr><th>类型</th><th>说明</th><th>典型场景</th></tr></thead><tbody><tr><td><strong>静态 NAT</strong></td><td>一对一映射</td><td>内网服务器要对外提供服务</td></tr><tr><td><strong>动态 NAT</strong></td><td>多对多临时映射</td><td>企业网络动态分配公网地址池</td></tr><tr><td><strong>端口复用 NAT（PAT）</strong></td><td>多对一，通过端口区分</td><td>家用路由器、校园网、公司常用</td></tr></tbody></table><p><strong>家用路由器几乎都是 PAT（端口复用型 NAT）</strong>。因为只有一个公网 IP，但要让几十台设备同时上网，必须通过不同端口区分。</p><blockquote><p><strong>大公司网络虽与家用网络共享 IP 路由原理，但采用精细 IP 规划、多层架构和有限 NAT 策略，对外服务通常直接使用公网 IP 以保障性能与可靠性，其高昂费用主要来自公网 IP、专线带宽和高可用基础设施。家庭路由器是 NAT 的小型实现，大公司机房是它的企业级放大版。运营商卖的不是“网速”，而是带宽 + 公网资源 + 可靠性。</strong></p></blockquote><hr><h2 id="9-路由转发原理：IP-报文如何找到“回家的路”"><a href="#9-路由转发原理：IP-报文如何找到“回家的路”" class="headerlink" title="9. 路由转发原理：IP 报文如何找到“回家的路”"></a>9. 路由转发原理：IP 报文如何找到“回家的路”</h2><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20251008161932828.png" alt="PixPin_2025-10-08_16-19-12"></p><h3 id="1-基本逻辑"><a href="#1-基本逻辑" class="headerlink" title="1. 基本逻辑"></a>1. 基本逻辑</h3><p>所有 IP 报文的转发都是根据 <strong>目的 IP 地址</strong> 来决定的，<strong>与源 IP 无关</strong>。无论是主机还是路由器，都维护着一张 <strong>路由表</strong>，都靠 <strong>本地路由表</strong> 决定“下一跳去哪”。路由表每一项通常包括：</p><table><thead><tr><th>项目</th><th>含义</th></tr></thead><tbody><tr><td>目的网络（Destination）</td><td>目标网段</td></tr><tr><td>子网掩码（Netmask）</td><td>区分网络号和主机号</td></tr><tr><td>下一跳（Next Hop）</td><td>报文应该转发给的下一个路由器地址</td></tr><tr><td>出口接口（Interface）</td><td>报文应从哪块网卡发出</td></tr></tbody></table><h3 id="2-查找路由表的过程"><a href="#2-查找路由表的过程" class="headerlink" title="2. 查找路由表的过程"></a>2. 查找路由表的过程</h3><p>当主机要发送数据时，它会：</p><ol><li><strong>先判断目标是否在同一网段</strong>：<ul><li>用自己的 IP 与目标 IP 分别和子网掩码做按位与；</li><li>若结果相同 → 同一网段，直接通过局域网（ARP 找 MAC）通信；</li><li>若不同 → 不同网段，交给默认网关（通常是路由器）。</li></ul></li><li><strong>路由器转发时</strong>：<ul><li>路由器查自己的路由表；</li><li>对每一条记录执行 <code>(目标IP &amp; 子网掩码)</code>；</li><li>找出最长匹配的网段（即 <strong>最长前缀匹配原则</strong>）；</li><li>按照该记录指示的接口或下一跳转发。</li></ul></li></ol><blockquote><p>  比喻理解：主机查路由表就像问路</p><ul><li>有人告诉你“到市中心走这条路”（有明确路）。</li><li>有人说“我不知道，但我知道到高速入口怎么走”（下一跳）。</li><li>若没人知道，就交给默认路由（缺省出口）。</li></ul></blockquote><h3 id="3-大概转发过程"><a href="#3-大概转发过程" class="headerlink" title="3. 大概转发过程"></a>3. 大概转发过程</h3><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[主机A] → [家用路由器] → [运营商路由器] → [目标网络路由器] → [主机B]</span><br></pre></td></tr></table></figure><p>每经过一个路由器：路由器查路由表，目的 IP <strong>不变</strong>，源 MAC、目的 MAC <strong>每跳都会变</strong>（数据链路层负责）。</p><blockquote><p>  <strong>关键点：网络层靠 IP 地址确定“去哪”，数据链路层靠 MAC 地址确定“怎么到下一跳”。</strong></p></blockquote><hr><h2 id="10-IP-分片机制：大报文如何被拆开传输？"><a href="#10-IP-分片机制：大报文如何被拆开传输？" class="headerlink" title="10. IP 分片机制：大报文如何被拆开传输？"></a>10. IP 分片机制：大报文如何被拆开传输？</h2><h3 id="1-为什么要分片？"><a href="#1-为什么要分片？" class="headerlink" title="1. 为什么要分片？"></a>1. 为什么要分片？</h3><p>因为不同链路的最大传输单元（MTU）不同。比如：以太网 MTU &#x3D; <strong>1500 字节</strong>，若 IP 报文超过 1500 字节，就必须拆分，否则底层帧发不出去。</p><h3 id="2-分片的字段结构"><a href="#2-分片的字段结构" class="headerlink" title="2. 分片的字段结构"></a>2. 分片的字段结构</h3><p>IP 报头里有三个关键字段：</p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20251008161058351.png" alt="PixPin_2025-10-08_16-10-46"></p><table><thead><tr><th>字段</th><th>作用</th></tr></thead><tbody><tr><td><strong>16 位标识（Identification）</strong></td><td>标识同一份数据（同一 IP 报文分片的共同编号）</td></tr><tr><td><strong>3 位标志（Flags）</strong></td><td>控制分片行为</td></tr><tr><td><strong>13 位片偏移（Fragment Offset）</strong></td><td>表示该分片在原报文中的偏移位置（单位 8 字节）</td></tr></tbody></table><p><strong>Flags 含义如下：</strong></p><ul><li>bit0：保留。</li><li>bit1：DF（Don’t Fragment）是否允许分片。</li><li>bit2：MF（More Fragment）是否还有后续分片。</li></ul><p>举例：<code>MF = 1</code> 表示后面还有分片，<code>MF = 0</code> 且 <code>Offset = 0</code> 表示仅此一个分片。</p><h3 id="3-分片与组装"><a href="#3-分片与组装" class="headerlink" title="3. 分片与组装"></a>3. 分片与组装</h3><p><strong>分片在发送端或中间路由器完成，组装必须在接收端完成。</strong> 如果一个分片丢了，即使其他分片都到了，整份报文也无法重组，只能重传，增加延迟和负担。因此：网络设计时会 <strong>尽量避免分片</strong>，TCP 会在三次握手阶段协商 MSS，控制单次传输不超过 MTU（常见 1460 字节）。</p><h3 id="4-为什么不建议分片？"><a href="#4-为什么不建议分片？" class="headerlink" title="4. 为什么不建议分片？"></a>4. 为什么不建议分片？</h3><ul><li>增加路由器 CPU 开销；</li><li>增加丢包概率；</li><li>丢一个片就得重传整个报文；</li><li>对实时性要求高的通信极其不利（如视频流）。</li></ul><p><strong>所以实际网络中：分片尽量只在端系统进行，路由器最好只转发，不分片。</strong></p><h2 id="11-数据链路层简述：局域网内的一跳通信"><a href="#11-数据链路层简述：局域网内的一跳通信" class="headerlink" title="11. 数据链路层简述：局域网内的一跳通信"></a>11. 数据链路层简述：局域网内的一跳通信</h2><blockquote><p>IP 报文转发靠查路由表，逐跳找到目标网络；若目标过大，IP 层会按 MTU 进行分片，接收端再组装；而每一跳之间的实际传输靠 MAC 帧完成，MAC 只在局域网内有效。</p></blockquote><p>虽然之后会细讲，但这里要先有个框架，可以先做一个简单了解。</p><h3 id="1-主要作用"><a href="#1-主要作用" class="headerlink" title="1. 主要作用"></a>1. 主要作用</h3><p>负责 <strong>点对点或点对多点的数据传输</strong>，以 <strong>MAC 帧（Frame）</strong> 为基本传输单位，通过 <strong>MAC 地址</strong> 标识网络设备。</p><h3 id="2-通信过程（以以太网为例）"><a href="#2-通信过程（以以太网为例）" class="headerlink" title="2. 通信过程（以以太网为例）"></a>2. 通信过程（以以太网为例）</h3><p>发送方将 IP 报文封装为 MAC 帧，MAC 帧头包含：目的 MAC、源 MAC、类型字段，所有主机都能收到这个帧，只有目的 MAC 匹配的主机才会上交给上层处理。这一层只在局域网中有效，数据一旦跨路由器转发，<strong>MAC 地址必然变化</strong>。</p><h3 id="3-数据帧长度与碰撞"><a href="#3-数据帧长度与碰撞" class="headerlink" title="3. 数据帧长度与碰撞"></a>3. 数据帧长度与碰撞</h3><p>有效载荷：46–1500 字节，过短帧会触发填充，过长则被丢弃，交换机通过分隔碰撞域减少冲突。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;网络层-——-IP-协议&quot;&gt;&lt;a href=&quot;#网络层-——-IP-协议&quot; class=&quot;headerlink&quot; title=&quot;网络层 —— IP 协议&quot;&gt;&lt;/a&gt;网络层 —— IP 协议&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a</summary>
        
      
    
    
    
    <category term="Linux" scheme="https://www.minbit.top/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://www.minbit.top/tags/Linux/"/>
    
    <category term="网络" scheme="https://www.minbit.top/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>052 传输层 —— TCP（下）</title>
    <link href="https://www.minbit.top/posts/23032.html"/>
    <id>https://www.minbit.top/posts/23032.html</id>
    <published>2025-10-05T04:00:00.000Z</published>
    <updated>2025-11-15T04:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="传输层-——-TCP（下）"><a href="#传输层-——-TCP（下）" class="headerlink" title="传输层 —— TCP（下）"></a>传输层 —— TCP（下）</h1><blockquote><p><a href="https://www.cnblogs.com/xiaolincoding/p/12732052.html">30 张图解： TCP 重传、滑动窗口、流量控制、拥塞控制 | 博客园</a></p></blockquote><h2 id="1-TCP-流量控制"><a href="#1-TCP-流量控制" class="headerlink" title="1. TCP 流量控制"></a>1. TCP 流量控制</h2><h3 id="1-什么是流量控制？"><a href="#1-什么是流量控制？" class="headerlink" title="1. 什么是流量控制？"></a>1. 什么是流量控制？</h3><p>先想一个比喻：你在和朋友聊天，对方打字太快，你还没看完一句他又发十条，你就“被淹没”了。TCP 里也一样，发送方（Sender）发数据太快，而接收方（Receiver）处理不过来，就会导致：</p><ul><li>接收缓冲区溢出（数据丢失）</li><li>重传、拥塞、效率下降</li></ul><p>所以 TCP 设计了 <strong>流量控制机制（Flow Control）</strong>，让接收方告诉发送方：“我现在只能接收这么多数据，请你慢一点。”它是一种防止发送方发送数据过快，导致接收方来不及处理而造成数据丢失的机制，其核心目标是 <strong>匹配发送速率与接收能力</strong>。</p><h3 id="2-实现方式：接收窗口"><a href="#2-实现方式：接收窗口" class="headerlink" title="2. 实现方式：接收窗口"></a>2. 实现方式：接收窗口</h3><p>TCP 报文头部包含一个 <strong>16 位的窗口字段（Window Size）</strong>，表示接收方当前还能接收多少字节的数据（即接收缓冲区剩余空间）。发送方根据这个窗口大小决定最多能发送多少未确认的数据。如果接收方缓冲区快满了，它会通告一个较小的窗口；如果缓冲区空了，就通告一个较大的窗口（甚至为 0）。</p><blockquote><p><a href="https://www.ietf.org/rfc/rfc1323.txt">高性能 TCP 扩展</a></p></blockquote><p>注意：窗口大小字段最大为 65535 字节（64 KB），这对早期的低速网络还行，但在高速宽带（比如千兆）环境下，<strong>64KB 窗口太小，会严重限制吞吐量</strong>。于是 RFC 1323 引入了“窗口缩放选项（Window Scale Option，<a href="https://www.ibm.com/docs/zh/aix/7.3.0?topic=tuning-rfc1323-tunable">RFC 1323</a>）”，根据原始 RFC 1323（后来更新到 RFC 7323）在 <strong>三次握手阶段</strong>，双方可以协商一个窗口缩放因子 <code>S</code>，范围是：[0,14]，也就是说，<strong>报文里的 16 位窗口字段只是一个“基值”，实际值还要乘上缩放因子。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">实际窗口大小 = 通告窗口大小 × (<span class="number">2</span>^S)</span><br><span class="line">最大窗口 = <span class="number">65535</span> × <span class="number">2</span>^<span class="number">14</span></span><br><span class="line">          = <span class="number">65535</span> × <span class="number">16384</span></span><br><span class="line">          = <span class="number">1</span>,<span class="number">073</span>,<span class="number">725</span>,<span class="number">440</span> 字节 ≈ <span class="number">1</span> GB</span><br></pre></td></tr></table></figure><p>所以 <strong>理论上最大窗口 ≈ 1GB</strong>，但这样一来，就与 IBM、Linux 内核文档说的不一样了，这其实就是进入“<strong>理论 vs 实际实现差异</strong>”的问题：不同操作系统、内核或 TCP 栈为了性能、内存安全、兼容性，会 <strong>人为限制最大窗口</strong>，不会真的给我们用到 1GB。比如：</p><table><thead><tr><th>系统</th><th>实际可配置的最大窗口</th></tr></thead><tbody><tr><td><strong>Linux (CentOS 7)</strong></td><td>通常 ≤ 16 MB（由 <code>/proc/sys/net/core/rmem_max</code> 限制）</td></tr><tr><td><strong>Windows</strong></td><td>一般上限在几 MB</td></tr><tr><td><strong>IBM AIX</strong></td><td>文档中说最大 1 MB（是默认配置限制，不是协议上限）</td></tr></tbody></table><p>所以：RFC 是协议标准，定义了“理论上能支持到 1GB”，系统实现（比如 AIX、Linux）出于稳定性或内存限制，只允许配置到几 MB。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看TCP窗口缩放功能是否启用，输出1表示启用TCP窗口缩放（RFC 1323定义的扩展）</span></span><br><span class="line"><span class="comment"># 允许TCP接收窗口大小超过65535字节，提升高带宽长距离网络的吞吐量</span></span><br><span class="line"><span class="built_in">cat</span> /proc/sys/net/ipv4/tcp_window_scaling</span><br><span class="line">1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看系统所有socket接收缓冲区的最大大小（全局上限），单位：字节，所有socket的接收缓冲区配置不能超过此值</span></span><br><span class="line"><span class="built_in">cat</span> /proc/sys/net/core/rmem_max</span><br><span class="line">212992<span class="comment"># 当前值为212992字节（208KB）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看系统所有socket发送缓冲区的最大大小（全局上限），单位：字节，所有socket的发送缓冲区配置不能超过此值</span></span><br><span class="line"><span class="built_in">cat</span> /proc/sys/net/core/wmem_max</span><br><span class="line">212992<span class="comment"># 当前值为212992字节（208KB）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看TCP协议接收缓冲区的配置（三个值分别为最小/默认/最大），单位：字节</span></span><br><span class="line"><span class="built_in">cat</span> /proc/sys/net/ipv4/tcp_rmem</span><br><span class="line">4096873806291456</span><br><span class="line"><span class="comment"># 4096：接收缓冲区最小值（即使内存紧张也不会小于此值）</span></span><br><span class="line"><span class="comment"># 87380：接收缓冲区默认值（新建连接时的初始大小）</span></span><br><span class="line"><span class="comment"># 6291456：接收缓冲区理论最大值（实际受rmem_max限制，当前实际最大为212992）</span></span><br><span class="line"><span class="comment"># TCP 接收缓冲区的实际最大值 = min(tcp_rmem[2], rmem_max)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看TCP协议发送缓冲区的配置（三个值分别为最小/默认/最大），单位：字节</span></span><br><span class="line"><span class="built_in">cat</span> /proc/sys/net/ipv4/tcp_wmem</span><br><span class="line">4096163844194304</span><br><span class="line"><span class="comment"># 4096：发送缓冲区最小值</span></span><br><span class="line"><span class="comment"># 16384：发送缓冲区默认值</span></span><br><span class="line"><span class="comment"># 4194304：发送缓冲区理论最大值（实际受wmem_max限制，当前实际最大为212992）</span></span><br></pre></td></tr></table></figure><h2 id="2-滑动窗口"><a href="#2-滑动窗口" class="headerlink" title="2. 滑动窗口"></a>2. 滑动窗口</h2><blockquote><p><a href="https://www.bilibili.com/video/BV1sQXDYREwP/?share_source=copy_web&vd_source=872e5e3ccf44874c39edaf42e30ab0de">神奇的滑动窗口 | TCP 流量控制 | B 站</a></p></blockquote><h3 id="1-什么是滑动窗口？"><a href="#1-什么是滑动窗口？" class="headerlink" title="1. 什么是滑动窗口？"></a>1. 什么是滑动窗口？</h3><blockquote><p>这里的滑动窗口和在算法中的滑动窗口算法可以认为是一致的，如果滑动窗口算法你有所了解，那么此处很容易理解，因为原理一致！</p><p><strong>TCP 滑动窗口 &#x3D; 流量控制的核心机制，用于让发送方根据接收方的处理能力动态调整发送速率，防止“发太快、收不动”。</strong></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20251006153117547.png" alt="PixPin_2025-10-06_15-31-06"></p><p>滑动窗口是 TCP 实现 <strong>流量控制 + 高效传输</strong> 的关键机制。它允许发送方在 <strong>未收到确认的情况下</strong> 连续发送多个数据段，而不是“发送一个、等待一个”。其本质是一个“动态的发送许可”。 </p><ul><li><strong>本质</strong>：就是 TCP 为了提高传输 <strong>效率</strong> 设计的一种机制。</li><li><strong>目的</strong>：不用每发一个包就等确认，而是允许「一批包」在途，从而实现一次可以发送大量 TCP 报文。</li></ul><p>可以理解为：“发送方最多能发多少还没被确认的数据（未 ACK 的数据）。”这个“能发的范围”由 <strong>接收方</strong> 决定， 接收方通过 <code>TCP Header</code> 里的 <strong>Window 字段（窗口大小）</strong> 通知发送方，举个直观例子（假设）：</p><ul><li>接收方当前窗口大小为 <code>4096 bytes</code>。</li><li>每个数据包 <code>1024 bytes</code>。</li></ul><p>发送方就能 <strong>连续发 4 个包</strong>（4096 bytes）后，必须停下来等 ACK。 等接收方确认了第 1 个包，它的窗口“右移”，发送方又能继续发新的一个。</p><h3 id="2-滑动窗口的组成（发送方视角）"><a href="#2-滑动窗口的组成（发送方视角）" class="headerlink" title="2. 滑动窗口的组成（发送方视角）"></a>2. 滑动窗口的组成（发送方视角）</h3><p>发送窗口通常分为四部分（按序列号顺序）：</p><table><thead><tr><th><strong>区域</strong></th><th><strong>说明</strong></th><th><strong>是否占用缓冲区</strong></th></tr></thead><tbody><tr><td><strong>已发送且已确认（收到 ACK）</strong></td><td><strong>可以丢弃，窗口向前滑动</strong></td><td><strong>不再占用（可释放）</strong></td></tr><tr><td><strong>已发送但未确认（未收到 ACK）</strong></td><td><strong>正在等待 ACK</strong></td><td><strong>占用</strong></td></tr><tr><td><strong>未发送但可发送</strong></td><td><strong>在窗口内，可立即发送</strong></td><td><strong>占用（待发）</strong></td></tr><tr><td>未发送且不可发送（存在感不高，可忽略，而且是窗口之外的空间，严格来说 <strong>不属于滑动窗口本身</strong>）</td><td>超出窗口，需等待窗口滑动</td><td>占用（但被“冻结”）</td></tr></tbody></table><p>发送方的 <strong>发送窗口</strong> 是一个区间，主要分为三块：</p><ol><li><strong>已发送且已确认的数据</strong>（窗口左边，已经安全了）</li><li><strong>已发送但未确认的数据</strong>（窗口中间，在途数据）</li><li><strong>允许发送但还没发送的数据</strong>（窗口右边，可以继续发）</li></ol><blockquote><p><strong>重点：<span style="color:#FF0000;">理论上的滑动窗口大小 &#x3D; min(接收方通告窗口，拥塞窗口，发送方缓存大小)</span>，这是操作系统实际可用的发送窗口上限，包含内核资源限制；而协议标准中通常只考虑发送方当前实际使用的滑动窗口大小，<span style="color:#FF0000;">实际窗口大小 &#x3D; min（接收窗口大小，拥塞窗口大小）即 min(cwnd, rwnd)</span>。</strong></p></blockquote><h3 id="3-确认序号（ACK）的含义是什么？"><a href="#3-确认序号（ACK）的含义是什么？" class="headerlink" title="3. 确认序号（ACK）的含义是什么？"></a>3. 确认序号（ACK）的含义是什么？</h3><p>TCP 的确认序号（Acknowledgment Number）表示：“<strong>我期望收到的下一个字节的序号是 x，也就是说，x 之前的所有字节我都成功收到了。</strong>” 例如：ACK &#x3D; 1001 → 表示序号 1~1000 的字节都收到了，这是 <strong>累计确认（Cumulative ACK）</strong> 机制。</p><p><strong>允许少量 ACK 丢失吗？</strong></p><blockquote><p><strong>TCP 是可靠传输协议，ACK 丢了，接收方下次再发 ACK（累积确认）依旧能覆盖。所以只要不是连续大量丢失，就不会有问题。</strong></p></blockquote><p><strong>允许！</strong> 因为 TCP 使用累计确认：</p><ul><li>即使某个 ACK 丢了，只要后续的 ACK 到达（比如 ACK &#x3D; 2001），就说明 1~2000 都收到了。</li><li>所以前面的 ACK 丢失不影响正确性（但可能影响性能，如触发重传）。</li><li><strong>普通数据 ACK 丢失通常无害，但携带窗口更新的 ACK 丢失可能影响性能。</strong></li></ul><h3 id="4-滑动窗口如何“向右移动”？移动时大小会变吗？"><a href="#4-滑动窗口如何“向右移动”？移动时大小会变吗？" class="headerlink" title="4. 滑动窗口如何“向右移动”？移动时大小会变吗？"></a>4. 滑动窗口如何“向右移动”？移动时大小会变吗？</h3><h4 id="1-向右移动："><a href="#1-向右移动：" class="headerlink" title="1. 向右移动："></a>1. 向右移动：</h4><ol><li>当收到 ACK（比如 ACK &#x3D; x），说明 x 之前的数据都确认了，窗口整体向右滑动。</li><li>发送窗口的 <strong>左边界</strong> 就移动到 x，释放已确认的数据空间，这意味着一些数据已经确认，不用再管了。</li><li>如果接收方缓冲区有空闲，还会在 ACK 中携带新的接收窗口大小，可能让 <strong>右边界也右移</strong>（窗口变大）。</li></ol><h4 id="2-窗口大小会变化吗？"><a href="#2-窗口大小会变化吗？" class="headerlink" title="2. 窗口大小会变化吗？"></a>2. 窗口大小会变化吗？</h4><p><strong>会！而且经常变！</strong></p><ul><li><strong>变大</strong>：接收方处理了数据，缓冲区空出 → 接收窗口大小增大 → 窗口右边界右移。</li><li><strong>变小</strong>：接收方缓冲区快满了 → 接收窗口大小减小 → 窗口右边界左移（但左边界不能左移！）。</li><li><strong>变为 0</strong>：接收方缓冲区完全满 → 接收窗口大小 &#x3D; 0 → 窗口大小为 0，发送方暂停发送（进入“零窗口探测”状态）。</li></ul><blockquote><p>  <strong>注意：窗口左边界只能右移或不动，不能左移（因为已确认的数据不能“反悔”）。</strong> </p></blockquote><h3 id="5-滑动窗口会“越界”发送缓冲区吗？"><a href="#5-滑动窗口会“越界”发送缓冲区吗？" class="headerlink" title="5. 滑动窗口会“越界”发送缓冲区吗？"></a>5. 滑动窗口会“越界”发送缓冲区吗？</h3><blockquote><p><strong>TCP 采用了类似环状算法，始终保证滑动窗口不会越界！</strong></p></blockquote><p><strong>不会。</strong></p><ul><li>滑动窗口的右边界（即“可发送的最大序号”）<strong>永远不会超过发送缓冲区的容量</strong>。</li><li>如果应用程序写入的数据太多，而窗口太小（比如接收窗口大小 &#x3D; 0），<code>send()</code> 系统调用会 <strong>阻塞</strong>（或返回 EAGAIN，如果是非阻塞 socket），直到窗口有空间。</li><li>因此，<strong>滑动窗口始终被限制在发送缓冲区内</strong>，不会越界。</li></ul><h3 id="6-流量控制是通过滑动窗口实现的吗？"><a href="#6-流量控制是通过滑动窗口实现的吗？" class="headerlink" title="6. 流量控制是通过滑动窗口实现的吗？"></a>6. 流量控制是通过滑动窗口实现的吗？</h3><p><strong>是的！流量控制的核心就是滑动窗口！</strong></p><p><strong>流量控制的本质</strong>：防止发送方发得太快，把接收方“撑爆”。<strong>实现方式</strong>：接收方通过 TCP 报文头中的 <strong>Window 字段（即接收窗口大小）</strong> 告诉发送方自己还能收多少。发送方据此 <strong>动态调整滑动窗口的大小</strong>。当 接收窗口大小 &#x3D; 0 时，发送方停止发送（除零窗口探测包外）。</p><blockquote><p>  <strong>滑动窗口是流量控制的执行机制，接收窗口大小是流量控制的控制信号。</strong> </p></blockquote><h3 id="7-如果发生丢包，滑动窗口怎么处理？"><a href="#7-如果发生丢包，滑动窗口怎么处理？" class="headerlink" title="7. 如果发生丢包，滑动窗口怎么处理？"></a>7. 如果发生丢包，滑动窗口怎么处理？</h3><p>丢包主要影响 <strong>拥塞控制</strong>，但也会间接影响滑动窗口：</p><ol><li><strong>发送方发现丢包</strong>（通过超时或重复 ACK）：<ul><li>会触发重传（重发未确认的数据）。</li><li>同时 <strong>减小拥塞窗口</strong>（比如减半）→ 导致滑动窗口变小。</li></ul></li><li><strong>滑动窗口本身不会“回退”</strong>：<ul><li>已确认的部分不会撤销。</li><li>未确认的部分继续等待 ACK 或重传。</li><li>窗口左边界不变，右边界可能因 <strong>拥塞窗口</strong> 减小而左移（窗口缩小）。</li></ul></li><li><strong>接收方视角</strong>：<ul><li>如果中间丢包，接收方会重复发送 <strong>最后一个正确 ACK</strong>（比如一直 ACK &#x3D; 1001）。</li><li>发送方收到 3 个重复 ACK 后，会快速重传序号 1001 开始的数据（快速重传机制）。</li></ul></li></ol><blockquote><p>  <strong>重点：滑动窗口只向前滑（左边界不回退），丢包通过重传 + 调整拥塞窗口大小来处理。</strong> </p></blockquote><h2 id="3-拥塞控制"><a href="#3-拥塞控制" class="headerlink" title="3. 拥塞控制"></a>3. 拥塞控制</h2><h3 id="1-什么是拥塞控制？"><a href="#1-什么是拥塞控制？" class="headerlink" title="1. 什么是拥塞控制？"></a>1. 什么是拥塞控制？</h3><p><strong>拥塞控制</strong> 是 TCP 协议中的一种 <strong>机制</strong>，用于 <strong>防止发送方因发送数据过快而导致网络过载（网络中的路由器或链路被过多数据淹没&#x2F;拥塞）</strong>，从而避免大量丢包、延迟剧增甚至网络崩溃。它的目标是：既要尽可能高效利用带宽，又要避免让网络“堵车”。</p><blockquote><p>关键点：  </p><ul><li>流量控制 → 保护 <strong>接收方</strong>（别发太快，我处理不过来），防止「<strong>发送方</strong>」把「<strong>接收方</strong>」撑爆。</li><li>拥塞控制 → 保护 <strong>整个网络</strong>（别发太多，网络会堵），防止「<strong>所有发送方</strong>」把「<strong>网络</strong>」堵死。</li></ul></blockquote><h3 id="2-为什么要有拥塞控制？"><a href="#2-为什么要有拥塞控制？" class="headerlink" title="2. 为什么要有拥塞控制？"></a>2. 为什么要有拥塞控制？</h3><blockquote><p><strong>如果所有主机都“无脑狂发数据”，网络会出现：路由器缓存溢出（包被丢弃）、延迟飙升、重传风暴（越丢越发），最终导致整个网络吞吐量下降，也就是所谓的“网络崩溃”。</strong></p></blockquote><ol><li><strong>网络资源有限</strong>：网络资源本质还是 <strong>共享资源</strong>，路由器缓存、带宽都是有限的。</li><li><strong>无控制的后果</strong>：<ul><li>多个发送方同时高速发包 → 路由器缓存溢出 → <strong>大量丢包</strong>。</li><li>丢包触发重传 → 更多数据进入网络 → <strong>恶性循环（拥塞崩溃）</strong>。</li></ul></li></ol><blockquote><p><strong>因此，TCP 必须“感知”网络状态，并 自适应调整发送速率。</strong></p></blockquote><h3 id="3-如何判断网络是否拥塞？"><a href="#3-如何判断网络是否拥塞？" class="headerlink" title="3. 如何判断网络是否拥塞？"></a>3. 如何判断网络是否拥塞？</h3><p>TCP <strong>无法直接看到网络状态</strong>，只能通过 <strong>间接信号</strong> 推断拥塞：</p><table><thead><tr><th>拥塞信号</th><th>说明</th></tr></thead><tbody><tr><td><strong>超时（Timeout）</strong></td><td>数据包长时间未收到 ACK → 很可能已丢弃（严重拥塞）</td></tr><tr><td><strong>重复 ACK</strong></td><td>接收方收到乱序包，反复确认最后一个正确序号（如连续 3 次 ACK &#x3D; 1001）→ 中间包可能丢失（轻度拥塞）</td></tr></tbody></table><blockquote><p>这两个事件是触发拥塞控制算法动作的关键“警报”。</p></blockquote><h3 id="4-拥塞控制的核心机制与关键概念"><a href="#4-拥塞控制的核心机制与关键概念" class="headerlink" title="4. 拥塞控制的核心机制与关键概念"></a>4. 拥塞控制的核心机制与关键概念</h3><blockquote><p>在热恋中，人总是“小心试探”——</p><ul><li>一开始不敢太快靠近（<strong>慢启动</strong>）。</li><li>发现对方反应良好，就逐步增加接触（<strong>拥塞避免&#x2F;快增长</strong>）。</li><li>如果对方突然冷淡（<strong>丢包&#x2F;超时</strong>），就立刻收敛，变得保守（<strong>快恢复&#x2F;慢启动重启</strong>）。</li></ul><p>TCP 也是这样：它“试探”网络承受能力，逐渐增加速度，一旦发现不对劲（丢包），马上退回去，避免网络“受伤”。</p></blockquote><p>TCP 拥塞控制通过一个 <strong>拥塞窗口</strong> 来限制发送速率。</p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20251006170038145.png" alt="PixPin_2025-10-06_17-00-35"></p><table><thead><tr><th>阶段&#x2F;策略</th><th>触发条件</th><th>cwnd 增长方式</th><th>说明</th></tr></thead><tbody><tr><td>慢启动</td><td>初始阶段或严重拥塞</td><td>每 ACK cwnd × 2</td><td>指数增长</td></tr><tr><td>拥塞避免</td><td>cwnd ≥ ssthresh</td><td>每 RTT cwnd + 1 MSS</td><td>线性增长</td></tr><tr><td>快重传</td><td>3 个重复 ACK</td><td>立即重传丢失包</td><td>不等超时</td></tr><tr><td>快恢复</td><td>轻微拥塞</td><td>cwnd &#x3D; ssthresh，然后线性增长</td><td>恢复阶段</td></tr></tbody></table><h4 id="1-慢启动"><a href="#1-慢启动" class="headerlink" title="1. 慢启动"></a>1. 慢启动</h4><blockquote><p>就像“刚恋爱，试探性地快快加深感情”。</p></blockquote><ul><li><strong>目的</strong>：连接刚建立时，不知道网络承载能力，先“试探性”发送。</li><li><strong>规则</strong>：<ul><li>传统初始拥塞窗口大小 &#x3D; 1 MSS（Maximum Segment Size，通常 1460 字节）。注：现代 TCP 实现（如 RFC 6928）的初始拥塞窗口更大，通常是 10 个 MSS。</li><li>在慢启动阶段，每经过一个 RTT，cwnd 大致翻倍（<strong>指数增长</strong>）。</li><li>一直到达到慢启动阈值（ssthresh）。</li></ul></li><li><strong>例子</strong>：<ul><li>第 1 轮：发 1 个包 → 收 1 个 ACK → cwnd &#x3D; 2</li><li>第 2 轮：发 2 个包 → 收 2 个 ACK → cwnd &#x3D; 4</li><li>第 3 轮：发 4 个包 → 收 4 个 ACK → cwnd &#x3D; 8</li><li>……</li></ul></li></ul><blockquote><p><strong>虽叫“慢启动”，但增长其实很快（指数级）！</strong> 小故事：一个农名欠地主粮食，于是地主给出 2 个选择，一个是慢慢还，一个是第一天还 1 粒米，第二天 2 粒，以此类推……农民毫不犹豫的选择了第 2 个选择，让他没想到的是最开始的日子还能还的上，后来指数级增长的粮食竟压得他叫苦不迭……</p></blockquote><h4 id="2-拥塞避免"><a href="#2-拥塞避免" class="headerlink" title="2. 拥塞避免"></a>2. 拥塞避免</h4><blockquote><p>稳定关系后，不再激进增加，逐渐探索极限。</p></blockquote><ul><li><strong>何时进入</strong>：当拥塞窗口大小大于等于慢启动阈值时（cwnd ≥ ssthresh）。</li><li><strong>规则</strong>：<ul><li>每收到一个 ACK，cwnd +&#x3D; 1&#x2F;cwnd → <strong>每轮 RTT，拥塞窗口只增加 1 MSS（线性增长）</strong></li></ul></li><li><strong>目的</strong>：避免指数增长导致突然拥塞。</li></ul><h4 id="3-快重传"><a href="#3-快重传" class="headerlink" title="3. 快重传"></a>3. 快重传</h4><ul><li><strong>触发条件</strong>：收到 <strong>3 个重复 ACK</strong>，就认为某个包丢了。</li><li><strong>动作</strong>：立即重传丢失的包，<strong>不等超时</strong>。</li><li><strong>优点</strong>：大幅减少重传延迟。</li></ul><h4 id="4-快恢复"><a href="#4-快恢复" class="headerlink" title="4. 快恢复"></a>4. 快恢复</h4><blockquote><p>恋爱里遇到小矛盾，退一步，再慢慢靠近。</p></blockquote><ul><li><strong>触发条件</strong>：快重传之后，当检测到轻微拥塞时，不用回到最初的慢启动。</li><li><strong>动作</strong>：将慢启动阈值设为当前拥塞窗口大小的一半（把 ssthresh 降到 cwnd&#x2F;2，然后线性增长）。</li><li><strong>目的</strong>：避免因单个丢包就“从头开始”，保持较高吞吐。</li></ul><h3 id="5-如何解决网络拥塞问题？"><a href="#5-如何解决网络拥塞问题？" class="headerlink" title="5. 如何解决网络拥塞问题？"></a>5. 如何解决网络拥塞问题？</h3><p>TCP 的解决思路就是「<strong>自我降速 + 逐步恢复</strong>」：</p><ol><li><strong>动态调整 cwnd（拥塞窗口）。</strong></li><li><strong>根据 ACK 反馈推断网络状态。</strong></li><li><strong>丢包时快速响应，防止恶化。</strong></li><li><strong>利用慢启动和线性增长实现自适应调节。</strong></li></ol><p>现代系统还在此基础上发展出了许多变种算法，如：</p><ul><li>Reno（经典）</li><li>NewReno（改进快恢复）</li><li>CUBIC（Linux 默认）</li><li>BBR（基于带宽估计，Google 提出）</li></ul><h2 id="4-流量控制-VS-拥塞窗口"><a href="#4-流量控制-VS-拥塞窗口" class="headerlink" title="4. 流量控制 VS 拥塞窗口"></a>4. 流量控制 VS 拥塞窗口</h2><table><thead><tr><th align="left">对比维度</th><th align="left">流量控制</th><th align="left">拥塞控制</th></tr></thead><tbody><tr><td align="left">控制目标</td><td align="left">防止 <strong>接收方</strong> 缓冲区溢出</td><td align="left">防止 <strong>网络</strong> 整体拥塞</td></tr><tr><td align="left">控制范围</td><td align="left">端到端（发送方与接收方之间）</td><td align="left">全局（整个网络路径）</td></tr><tr><td align="left">触发因素</td><td align="left">接收方缓冲区容量</td><td align="left">网络路由器队列溢出、分组丢失</td></tr><tr><td align="left">关键参数</td><td align="left">接收窗口 (rwnd)</td><td align="left">拥塞窗口 (cwnd)、阈值 (ssthresh)</td></tr><tr><td align="left">实现方式</td><td align="left">接收方反馈窗口大小</td><td align="left">发送方主动调整发送速率</td></tr><tr><td align="left">典型算法</td><td align="left">滑动窗口协议</td><td align="left">慢启动、拥塞避免、快重传、快恢复</td></tr><tr><td align="left">窗口增长</td><td align="left">根据接收方反馈动态调整</td><td align="left">指数增长 → 线性增长 → 快速下降</td></tr><tr><td align="left">检测机制</td><td align="left">零窗口检测</td><td align="left">超时重传、重复 ACK 检测</td></tr></tbody></table><hr><blockquote><p><strong>TCP 是全双工通信（双方都能同时发数据和 ACK）。但发送 ACK（确认号）本身也要占用网络资源，如果对方每发一个小包，我就立刻回一个 ACK，就会增加很多小包通信 → 影响效率。所以：TCP 引入了 延迟应答（Delayed ACK）和 捎带应答（Piggyback ACK）来优化。</strong></p></blockquote><h2 id="5-延迟应答"><a href="#5-延迟应答" class="headerlink" title="5. 延迟应答"></a>5. 延迟应答</h2><h3 id="1-类比场景"><a href="#1-类比场景" class="headerlink" title="1. 类比场景"></a>1. 类比场景</h3><ol><li>A：你吃饭了吗？（B 听到了，但暂时没回——他在想自己是不是也要说点别的）。</li><li>几秒后：B：吃了（这句话既是回答，也是“我听到你说话了”的信号）。</li><li>如果 B 想了半天没要说的，就会单独说一句：B：听到了！</li></ol><h3 id="2-对应-TCP-含义"><a href="#2-对应-TCP-含义" class="headerlink" title="2. 对应 TCP 含义"></a>2. 对应 TCP 含义</h3><ol><li>TCP 收到数据后，不急着立刻回 ACK，而是 <strong>稍微等一下</strong>，看看自己是否要发送数据回去。</li><li>如果这段时间内有要发的数据 → 就在数据包里“顺便带上 ACK”。</li><li>如果一直没有新数据 → 到了延迟时间（比如 40ms）再单独发 ACK。</li></ol><h3 id="3-作用"><a href="#3-作用" class="headerlink" title="3. 作用"></a>3. 作用</h3><ul><li>减少纯 ACK 包数量，降低网络负担；</li><li>提高吞吐率，让数据传输更高效。</li></ul><h2 id="6-捎带应答"><a href="#6-捎带应答" class="headerlink" title="6. 捎带应答"></a>6. 捎带应答</h2><h3 id="1-类比场景-1"><a href="#1-类比场景-1" class="headerlink" title="1. 类比场景"></a>1. 类比场景</h3><ol><li>A：吃饭了吗？</li><li>B：吃了。</li></ol><p>这里 B 没有说「听到你说话了」，但实际上他回答了问题，<strong>自然就说明他听到了</strong>。这就是「捎带」：在自己的内容里顺便带上确认。</p><h3 id="2-对应-TCP-含义-1"><a href="#2-对应-TCP-含义-1" class="headerlink" title="2. 对应 TCP 含义"></a>2. 对应 TCP 含义</h3><p>当 TCP 双方都在发数据时，接收方就 <strong>在自己的数据包中附上 ACK 确认号</strong>，告诉对方“上一个包我收到了”，不需要单独发一个 ACK 包。</p><h3 id="3-作用-1"><a href="#3-作用-1" class="headerlink" title="3. 作用"></a>3. 作用</h3><ul><li>减少包的数量（因为数据和确认合并成一个包）。</li><li>提高通信效率，尤其在双向传输时。</li></ul><h2 id="7-延迟应答-VS-捎带应答"><a href="#7-延迟应答-VS-捎带应答" class="headerlink" title="7. 延迟应答 VS 捎带应答"></a>7. 延迟应答 VS 捎带应答</h2><blockquote><ul><li>延迟应答：<strong>等一等再回，看看能不能顺便带上 ACK。</strong> </li><li>捎带应答：<strong>既然要说话，那就顺便说“我听到了”。</strong></li></ul></blockquote><table><thead><tr><th>项目</th><th>延迟应答</th><th>捎带应答</th></tr></thead><tbody><tr><td>类比</td><td>B 等一等，看要不要顺便回</td><td>B 在自己的回答中顺便确认</td></tr><tr><td>触发条件</td><td>收到数据，但无数据要发</td><td>收到数据且有数据要发</td></tr><tr><td>是否等</td><td>会延迟一小段时间</td><td>不延迟，直接发</td></tr><tr><td>是否双向通信</td><td>不一定</td><td>必须双向都有数据</td></tr><tr><td>目的</td><td>减少无意义的 ACK 包</td><td>合并数据和 ACK，节省一次发包</td></tr><tr><td>典型场景</td><td>单向传输（如文件下载）</td><td>双向交互（如 Telnet、HTTP）</td></tr></tbody></table><hr><h2 id="8-面向字节流"><a href="#8-面向字节流" class="headerlink" title="8. 面向字节流"></a>8. 面向字节流</h2><h3 id="1-面向字节流的本质"><a href="#1-面向字节流的本质" class="headerlink" title="1. 面向字节流的本质"></a>1. 面向字节流的本质</h3><p>TCP 是 <strong>「面向字节流」</strong> 的协议，这句话的意思是：<strong>TCP 只看连续的字节，不关心消息边界。</strong> 也就是说，TCP 眼中没有“包”或“消息”的概念，它只负责：把发送方写入的那一串字节完整、有序地交给接收方，确保不丢、不乱、不错。<strong>所以无论写几次、读几次，对 TCP 来说都没区别——它只是管「流动的字节」。</strong></p><h3 id="2-从发送到接收的完整过程"><a href="#2-从发送到接收的完整过程" class="headerlink" title="2. 从发送到接收的完整过程"></a>2. 从发送到接收的完整过程</h3><blockquote><p><strong>应用层调用 <code>write()</code> → 用户态数据拷贝到内核态的 TCP 发送缓冲区 → TCP 协议栈按当前网络状况和拥塞窗口决定什么时候、按多大尺寸分段发送 → 网络传输 → 对端的 TCP 收到后，先把数据放入内核态的 TCP 接收缓冲区 → 对端应用层调用 <code>read()</code> 从内核缓冲区中按需读取任意长度的字节数据 → 由应用层自己根据协议格式解析出完整消息边界。这就是 TCP 面向字节流的本质：提供可靠、有序的字节传输通道，但把“语义”交给上层。</strong></p></blockquote><p>我们用一个简化图来还原整个流程：</p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20251006221632301.png" alt="PixPin_2025-10-06_22-16-21"></p><p>现在来讲讲每一步背后的逻辑：</p><h4 id="1-应用层调用-write"><a href="#1-应用层调用-write" class="headerlink" title="1. 应用层调用 write()"></a>1. 应用层调用 <code>write()</code></h4><p>应用层产生数据转成字节拷贝进 <strong>内核的发送缓冲区</strong>。这时 <code>write()</code> 就可以返回了，<strong>并不意味着数据发出去了</strong>，只是进入了内核队列。</p><h4 id="2-TCP-自动分片与聚合"><a href="#2-TCP-自动分片与聚合" class="headerlink" title="2. TCP 自动分片与聚合"></a>2. TCP 自动分片与聚合</h4><p>发送缓冲区中的数据由 TCP 协议控制发送：</p><ul><li>如果太大，会拆成多个 TCP 段；</li><li>如果太小，TCP 可能暂时不发（比如启用了 Nagle 算法），等待更多数据合并成一个包再发。</li></ul><p>这一步是 <strong>TCP 的“面向字节流”特性在发送端的体现</strong>：它不管我们一次 write 写多少字节，只管按自己的节奏连续发字节。</p><h4 id="3-网络传输与确认"><a href="#3-网络传输与确认" class="headerlink" title="3. 网络传输与确认"></a>3. 网络传输与确认</h4><p>TCP 在传输过程中做三件事：</p><ol><li>维护序号（保证有序）。</li><li>超时重传（保证可靠）。</li><li>滑动窗口（控制流量）。</li></ol><p>丢了会重发，乱序会重排。</p><h4 id="4-接收方重组数据流"><a href="#4-接收方重组数据流" class="headerlink" title="4. 接收方重组数据流"></a>4. 接收方重组数据流</h4><p>数据到达接收方内核后，TCP 会根据序号：把乱序的包重新排序，确认收到的字节，把连续的字节流写入 <strong>接收缓冲区</strong>。</p><h4 id="5-应用层调用-read"><a href="#5-应用层调用-read" class="headerlink" title="5. 应用层调用 read()"></a>5. 应用层调用 <code>read()</code></h4><p>应用层从接收缓冲区中 <strong>按自己想要的长度</strong> 去读数据。读多少、读几次都行。TCP 不关心我们每次 read 的“分界”，它只负责保证我们收到的字节顺序正确。</p><h4 id="6-举个例子"><a href="#6-举个例子" class="headerlink" title="6. 举个例子"></a>6. 举个例子</h4><p>用 <code>write(fd, &quot;Hello&quot;, 5)</code> 写 5 次，每次 1 字节：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">write</span>(fd, <span class="string">&quot;H&quot;</span>, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">write</span>(fd, <span class="string">&quot;e&quot;</span>, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">write</span>(fd, <span class="string">&quot;l&quot;</span>, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">write</span>(fd, <span class="string">&quot;l&quot;</span>, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">write</span>(fd, <span class="string">&quot;o&quot;</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>和一次写 5 字节：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">write</span>(fd, <span class="string">&quot;Hello&quot;</span>, <span class="number">5</span>);</span><br></pre></td></tr></table></figure><p><strong>这对 TCP 来说完全一样</strong>！它只看到 5 个连续字节：<code>H e l l o</code>。</p><p>同样，接收方可以：</p><ul><li>一次 <code>read(buf, 5)</code> 读完；</li><li>或 5 次 <code>read(buf, 1)</code> 逐字节读；</li><li>甚至一次 <code>read(buf, 100)</code> 把这 5 字节和其他后续数据一起读进来。</li></ul><blockquote><p>  <strong>TCP 不保证“写多少次，就读多少次”；也不保证“每次写的边界 &#x3D; 每次读的边界”。 像水管输水，不管你倒一桶还是倒十桶，水流不断过去。水分段传输，但水的“总量”是靠序号控制的，不需要每次标记“这一桶多大”。</strong></p></blockquote><h2 id="9-粘包问题"><a href="#9-粘包问题" class="headerlink" title="9. 粘包问题"></a>9. 粘包问题</h2><h3 id="1-什么是粘包问题？"><a href="#1-什么是粘包问题？" class="headerlink" title="1. 什么是粘包问题？"></a>1. 什么是粘包问题？</h3><blockquote><p>这就好像小时候家里蒸包子，出现从蒸笼里拿一个包子，结果连带一个或者多个包子一并被拿起一样。</p></blockquote><p>TCP 粘包是因为 TCP 是面向字节流的协议，不保留消息边界，导致多个应用层消息被合并成一个 TCP 段传输。其根本就是 <strong>TCP 是面向字节流的协议</strong>，它只保证字节的顺序和可靠（不丢不重）传输，不关心一条消息从哪里开始、到哪里结束。举个例子：假设客户端连续发了两条消息：”hello”、”world”，底层 TCP 实际发送过程可能是：</p><ol><li>一起发出去 → 收方一次 read() 得到 “helloworld”</li><li>拆成两次发 → 收方第一次 read() 得到 “hell”，第二次得到 “oworld”</li></ol><p>无论哪种情况，对 TCP 来说都没错，它完成了“字节传输”。但对应用层来说，就糊涂了：到底哪 5 个字节是 “hello”，哪 5 个字节是 “world” 呢？这就是 <strong>粘包&#x2F;拆包问题</strong>。</p><blockquote><p>注意：严格来说，“粘包”是 <strong>应用层术语</strong>，TCP 本身没有“包”的概念（它是字节流），所以更准确的说法是 <strong>“消息边界丢失”</strong> 或 <strong>“应用层消息粘连”</strong>。 </p></blockquote><h3 id="2-为什么会发生粘包？"><a href="#2-为什么会发生粘包？" class="headerlink" title="2. 为什么会发生粘包？"></a>2. 为什么会发生粘包？</h3><p>主要有两个原因：</p><ol><li><strong>TCP 是流式协议</strong> —— 没有消息边界。</li><li><strong>发送端的优化机制</strong>：TCP 可能把多次 <code>write()</code> 的小数据包合并成一个更大的包再发送（比如受 <strong>Nagle 算法</strong> 影响）。</li></ol><blockquote><p>  比喻：连发两封信，TCP 相当于觉得信太小，顺手把它们塞进一个信封寄了出去。收信人收到一封信里两张纸，就要自己判断哪一张属于哪一封。</p></blockquote><h3 id="3-UDP-会不会有粘包问题？"><a href="#3-UDP-会不会有粘包问题？" class="headerlink" title="3. UDP 会不会有粘包问题？"></a>3. UDP 会不会有粘包问题？</h3><p><strong>不会。</strong> 因为：UDP 是 <strong>面向报文</strong> 的，每次 <code>sendto()</code> 发出的数据就是一个独立的报文，接收方 <code>recvfrom()</code> 一次只能收到一个完整的报文，如果太大，UDP 直接丢（不会拆分合并）。所以 UDP 可能会 <strong>丢包</strong>，但 <strong>不会粘包</strong>。</p><h3 id="4-解决粘包的四种典型方案（应用层协议）"><a href="#4-解决粘包的四种典型方案（应用层协议）" class="headerlink" title="4. 解决粘包的四种典型方案（应用层协议）"></a>4. 解决粘包的四种典型方案（应用层协议）</h3><table><thead><tr><th>方案类型</th><th>描述</th><th>优点</th><th>缺点</th><th>常见场景</th></tr></thead><tbody><tr><td><strong>1. 定长报文</strong></td><td>每个消息的长度是固定的，比如每条 128 字节。</td><td>实现最简单，无需解析。</td><td>浪费带宽，不适合变长内容。</td><td>心跳包、状态同步。</td></tr><tr><td><strong>2. 特殊字符分隔</strong></td><td>每条消息结尾加一个独特分隔符，比如 <code>\n</code>、<code>\r\n</code>、<code>#</code> 等。</td><td>简单直观，易调试。</td><td>若数据本身可能包含该字符，就要转义或转码。</td><td>文本协议：HTTP（<code>\r\n\r\n</code>）、Redis（<code>\r\n</code>）、FTP。</td></tr><tr><td><strong>3. 定长报头 + 描述字段（自描述长度）</strong></td><td>报头中包含“消息体长度”，先读报头，再按长度读消息体。</td><td>高通用性，可支持任意变长数据。</td><td>需要两阶段解析（读头再读体）。</td><td>二进制协议、RPC 通信、游戏服务器。</td></tr><tr><td><strong>4. 自描述字段 + 特殊字符</strong></td><td>报头带长度字段，报尾再加结束符；双重保险。</td><td>边界更安全、健壮。</td><td>报文略复杂。</td><td>通信要求高可靠性时（如金融系统）。</td></tr></tbody></table><p>举个例子（第 3 种最常用），比如我们定义协议格式：<code>| 报头：4字节消息体长度 | 报体：消息数据 |</code>，假设发两条消息：”0005hello” 和 “0005world”，接收方解析逻辑：</p><ol><li>先读 4 字节（0005） → 得知消息长度为 5。</li><li>再读 5 字节 → “hello”。</li><li>重复上述步骤 → “world”。</li></ol><p>这样即使 TCP 把两条粘一起了，也能正确拆包。</p><h3 id="5-小结（可直接答面试）"><a href="#5-小结（可直接答面试）" class="headerlink" title="5. 小结（可直接答面试）"></a>5. 小结（可直接答面试）</h3><blockquote><p>  粘包是因为 TCP 是字节流，没有边界概念，所以我们要在 <strong>用户层定义应用协议</strong> 划分消息。常见方案包括：</p><ol><li>固定长度；</li><li>特殊分隔符；</li><li>定长报头 + 长度字段（最通用）；</li><li>长度字段 + 分隔符（更健壮）。</li></ol><p>  UDP 不会粘包，因为它是面向报文的。</p></blockquote><h2 id="10-TCP-异常情况"><a href="#10-TCP-异常情况" class="headerlink" title="10. TCP 异常情况"></a>10. TCP 异常情况</h2><h3 id="1-进程终止（正常退出或被-kill）"><a href="#1-进程终止（正常退出或被-kill）" class="headerlink" title="1. 进程终止（正常退出或被 kill）"></a>1. 进程终止（正常退出或被 kill）</h3><p><strong><span style="color:#FF0000;">TCP 连接会正常断开（四次挥手）</span></strong>，原理：当进程调用 <code>exit()</code>、<code>_exit()</code> 或被 <code>kill -9</code> 终止时，<strong>内核会自动关闭该进程打开的所有文件描述符</strong>，包括 socket，关闭 socket 时，内核 TCP 协议栈会：</p><ol><li>发送 <strong>FIN</strong> 报文（表示“我不会再发数据了”）。</li><li>进入 <strong>FIN-WAIT-1</strong> 状态。</li><li>后续完成标准的 <strong>四次挥手</strong> 流程。</li></ol><blockquote><p>即使进程是被 <code>kill -9</code> 强制杀死，<strong>内核仍会清理其资源并发送 FIN</strong>（因为 socket 是内核对象，进程只是持有 fd）。</p></blockquote><p>对方表现：对端收到 FIN 后，<code>read()</code> 返回 0（表示对方关闭连接），应用可正常感知连接关闭，做清理工作。注意：</p><ul><li>如果进程退出前有未发送完的数据，内核会尝试发送（取决于 SO_LINGER 设置）。</li><li>默认情况下，内核会尽力完成挥手，<strong>连接是“优雅关闭”的</strong>。</li></ul><h3 id="2-机器重启（操作系统重启）"><a href="#2-机器重启（操作系统重启）" class="headerlink" title="2. 机器重启（操作系统重启）"></a>2. 机器重启（操作系统重启）</h3><p><strong><span style="color:#FF0000;">所有 TCP 连接会被强制中断，但过程分两步</span></strong>，原理：</p><ol><li><p><strong>关机阶段</strong>：</p><ul><li>系统 shutdown 时，会向所有进程发送 SIGTERM，然后 SIGKILL。</li><li>内核会尝试关闭所有 socket，<strong>理想情况下会发送 FIN</strong>。</li><li>但如果关机太快，可能来不及发 FIN。</li></ul></li><li><p><strong>重启后</strong>：</p><ul><li>所有旧连接的 socket 已被销毁。</li><li>本机 TCP 状态机重置。</li><li><strong>对端仍认为连接存在</strong>（因为没收到 FIN 或 RST）。</li></ul></li></ol><p>关键问题：<strong>对端无法立即感知连接已断！</strong></p><ul><li>对端继续发数据 → 本机收到后，发现无对应连接 → 回 <strong>RST（复位）</strong>。</li><li>对端收到 RST → 知道连接已失效，<code>write()</code> 会触发 <strong>SIGPIPE</strong> 或返回 <strong>ECONNRESET</strong>。</li></ul><blockquote><p><a href="https://zhuanlan.zhihu.com/p/670726420">TCP 保活机制详解（KeepAlive）| 知乎</a></p><p>但如果对端不发数据，它可能 <strong>长时间不知道连接已断</strong>（直到保活探测或应用超时）。</p></blockquote><p>解决方案建议：</p><ul><li>应用层实现 <strong>心跳机制</strong>（定期 ping&#x2F;pong）。</li><li>启用 <strong><a href="https://tldp.org/HOWTO/TCP-Keepalive-HOWTO/overview.html">TCP Keep-Alive</a></strong>。</li></ul><blockquote><p><a href="https://blog.csdn.net/pmt123456/article/details/58233999">TCP 长连接与短连接、心跳机制 | CSDN</a></p><p><a href="https://www.bilibili.com/video/BV1uF411V7WH/?share_source=copy_web&vd_source=872e5e3ccf44874c39edaf42e30ab0de">0407.TCP 长连接心跳机制的实现 | B 站</a></p></blockquote><h3 id="3-机器掉电-网线断开（非正常断连）"><a href="#3-机器掉电-网线断开（非正常断连）" class="headerlink" title="3. 机器掉电 &#x2F; 网线断开（非正常断连）"></a>3. 机器掉电 &#x2F; 网线断开（非正常断连）</h3><p><strong><span style="color:#FF0000;">连接“静默失效”——双方都无法立即感知！</span></strong>，原理：本机突然断电或网线拔掉 → <strong>无法发送任何 TCP 报文（包括 FIN、RST）</strong>，对端：仍认为连接正常，若继续发数据 → 数据包到达对方（但对方已关机）→ <strong>无 ACK 返回</strong>，经过多次重传超时后 → <code>write()</code> 返回 <strong>ETIMEDOUT</strong>，若一直不发数据 → <strong>永远不知道连接已断！</strong></p><blockquote><p>这就是所谓的 <strong>“半开连接”</strong> —— 一方已断，另一方不知情。</p></blockquote><p><strong>默认超时时间有多长？</strong> Linux 默认 TCP 重传约 <strong>15 次</strong>，总超时可达 <strong>9~13 分钟</strong>！在此期间，连接“看似正常”，实则已失效。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看重传次数和间隔（单位：秒）</span></span><br><span class="line"><span class="built_in">cat</span> /proc/sys/net/ipv4/tcp_retries2    <span class="comment"># 通常为 15</span></span><br></pre></td></tr></table></figure><h3 id="4-小结"><a href="#4-小结" class="headerlink" title="4. 小结"></a>4. 小结</h3><table><thead><tr><th>异常场景</th><th>本机能否发 FIN&#x2F;RST？</th><th>对端能否立即感知？</th><th>是否会自动断开</th><th>连接如何关闭</th><th>建议应对措施</th></tr></thead><tbody><tr><td><strong>进程终止</strong></td><td>✅ 能（发 FIN）</td><td>✅ 能（收到 FIN）</td><td>✅ 正常断开</td><td>正常四次挥手</td><td>无需特殊处理</td></tr><tr><td><strong>机器重启</strong></td><td>⚠️ 可能来不及发</td><td>❌ 不能（除非对端发数据）</td><td>❌ 不一定</td><td>对端收到 RST</td><td>启用 Keep-Alive 或心跳</td></tr><tr><td><strong>掉电&#x2F;断网</strong></td><td>❌ 完全不能</td><td>❌ 不能（静默失效）</td><td>❌ 不自动断开</td><td>超时或 Keep-Alive 探测失败</td><td><strong>必须用心跳或调短 Keep-Alive</strong></td></tr></tbody></table><blockquote><ol><li><strong>只有进程终止能保证优雅关闭；</strong></li><li><strong>系统级异常（重启、断电）会导致连接“假死”；</strong></li><li><strong>TCP 本身无法快速检测物理层断连；</strong></li><li><strong>生产环境必须依赖：</strong><ul><li><strong>应用层心跳（推荐）</strong></li><li><strong>或 调优 TCP Keep-Alive</strong></li></ul></li></ol><p><strong>记住：“TCP 可靠，但不万能；异常检测，靠心跳保命。”</strong></p></blockquote><h2 id="11-TCP-小结"><a href="#11-TCP-小结" class="headerlink" title="11. TCP 小结"></a>11. TCP 小结</h2><p>TCP 协议这么复杂就是因为 TCP 既要保证可靠性，同时又尽可能的提高性能。</p><p><strong>可靠性：</strong></p><ul><li><p><strong>检验和：</strong> 检测数据传输中的错误。</p></li><li><p><strong>序列号：</strong> 确保数据按序到达，解决重复和乱序问题。</p></li><li><p><strong>确认应答：</strong> 接收方确认收到数据，形成闭环（核心）。</p></li><li><p><strong>超时重传：</strong> 发送方未及时收到确认则重发数据。</p></li><li><p><strong>连接管理：</strong> 三次握手建立连接，四次挥手释放连接。</p></li><li><p><strong>流量控制：</strong> 通过滑动窗口机制控制发送速率，避免接收方过载（也属于提高性能）。</p></li><li><p><strong>拥塞控制：</strong> 检测网络拥塞并调整发送速率（也属于提高性能）。</p></li></ul><p><strong>提高性能：</strong></p><ul><li><p><strong>滑动窗口：</strong> 允许发送方连续发送多个数据包。</p></li><li><p><strong>快速重传：</strong> 基于重复确认快速检测丢包并重传。</p></li><li><p><strong>延迟应答：</strong> 合并多个确认，减少网络开销。</p></li><li><p><strong>捎带应答：</strong> 在数据报文段中携带确认信息。</p></li></ul><p>其他：TCP 定时器：</p><ul><li>重传定时器：为了控制丢失的报文段或丢弃的报文段，也就是对报文段确认的等待时间。</li><li>坚持定时器：专门为对方零窗口通知而设立的，也就是向对方发送窗口探测的时间间隔。</li><li>保活定时器：为了检查空闲连接的存在状态，也就是向对方发送探查报文的时间间隔。</li><li>TIME_WAIT 定时器：双方在四次挥手后，主动断开连接的一方需要等待的时长。</li></ul><h2 id="12-基于-TCP-的应用层协议"><a href="#12-基于-TCP-的应用层协议" class="headerlink" title="12. 基于 TCP 的应用层协议"></a>12. 基于 TCP 的应用层协议</h2><p>常见的基于 TCP 的应用层协议如下：</p><ul><li>HTTP（超文本传输协议）。 </li><li>HTTPS（安全数据传输协议）。</li><li>SSH（安全外壳协议）。 </li><li>Telnet（远程终端协议）。 </li><li>FTP（文件传输协议）。 </li><li>SMTP（电子邮件传输协议）。</li></ul><p>当然，也包括自己写 TCP 程序时自定义的应用层协议。</p><h2 id="13-UDP-实现可靠传输的思路-——-具体场景具体分析，往-TCP-靠"><a href="#13-UDP-实现可靠传输的思路-——-具体场景具体分析，往-TCP-靠" class="headerlink" title="13. UDP 实现可靠传输的思路 —— 具体场景具体分析，往 TCP 靠"></a>13. UDP 实现可靠传输的思路 —— 具体场景具体分析，往 TCP 靠</h2><p>虽然 UDP 本身是不可靠的，但可以在应用层实现类似 TCP 的可靠性机制：</p><ol><li><strong>引入序列号</strong>：为每个数据包分配唯一序号，确保数据有序。</li><li><strong>确认应答机制</strong>：接收方收到数据后发送确认信息。</li><li><strong>超时重传</strong>：设置合理的超时时间，未收到确认则重传。</li><li><strong>滑动窗口</strong>：控制发送窗口大小，实现流量控制。</li><li><strong>拥塞控制</strong>：根据网络状况动态调整发送速率。</li></ol><h2 id="14-补充：listen-第二个参数（backlog）的准确理解"><a href="#14-补充：listen-第二个参数（backlog）的准确理解" class="headerlink" title="14. 补充：listen 第二个参数（backlog）的准确理解"></a>14. 补充：<code>listen</code> 第二个参数（<code>backlog</code>）的准确理解</h2><h3 id="1-函数原型"><a href="#1-函数原型" class="headerlink" title="1. 函数原型"></a>1. 函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">listen</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> backlog)</span>;</span><br></pre></td></tr></table></figure><p>官方定义：<code>backlog</code> 参数指定了 <strong>内核为该套接字维护的等待接受的连接队列的最大长度</strong>。</p><h3 id="2-实际含义"><a href="#2-实际含义" class="headerlink" title="2. 实际含义"></a>2. 实际含义</h3><p>在现代 Linux 系统中，这个参数控制的是 <strong>全连接队列（accept queue）</strong> 的大小，即：</p><ul><li>已经完成三次握手的连接。</li><li>等待应用层调用 <code>accept()</code> 函数取走的连接。</li></ul><h3 id="3-关键要点（重要）"><a href="#3-关键要点（重要）" class="headerlink" title="3. 关键要点（重要）"></a>3. 关键要点（重要）</h3><h4 id="1-队列机制"><a href="#1-队列机制" class="headerlink" title="1. 队列机制"></a>1. 队列机制</h4><p>TCP 连接建立过程中涉及两个队列：</p><ul><li><strong>半连接队列（SYN queue）</strong>：处理三次握手过程中的连接（SYN_RECV 状态）。</li><li><strong>全连接队列（accept queue）</strong>：已完成握手等待应用处理的连接（ESTABLISHED 状态）。</li></ul><p><code>backlog</code> 参数主要影响的是 <strong>全连接队列</strong> 的大小。</p><h4 id="2-实际队列长度"><a href="#2-实际队列长度" class="headerlink" title="2. 实际队列长度"></a>2. 实际队列长度</h4><p>在 Linux 内核中，实际的全连接队列长度通常是 <code>backlog + 1</code>。这是因为：队列维护时会包含当前正在被 <code>accept()</code> 处理的连接，所以设置 <code>backlog = 5</code> 时，实际可容纳 6 个等待连接。</p><h4 id="3-连接拒绝机制"><a href="#3-连接拒绝机制" class="headerlink" title="3. 连接拒绝机制"></a>3. 连接拒绝机制</h4><p>当全连接队列满时：新的连接请求会被内核拒绝，客户端可能会收到 <code>ECONNREFUSED</code> 错误，或者内核会静默丢弃连接请求（取决于具体配置）。</p><h3 id="4-历史演变"><a href="#4-历史演变" class="headerlink" title="4. 历史演变"></a>4. 历史演变</h3><ul><li><strong>早期实现</strong>：<code>backlog</code> 表示半连接队列和全连接队列的总和。</li><li><strong>现代实现</strong>：<code>backlog</code> 主要控制全连接队列，半连接队列由其他内核参数控制。</li></ul><h3 id="5-实际应用"><a href="#5-实际应用" class="headerlink" title="5. 实际应用"></a>5. 实际应用</h3><ul><li><strong>Web 服务器</strong>：通常设置为 128、256 或 512。</li><li><strong>高并发服务</strong>：可以适当增大，如 1024 或更高。</li><li><strong>考虑系统限制</strong>：受 <code>/proc/sys/net/core/somaxconn</code> 内核参数限制。</li><li><strong>监控队列状态</strong>：通过 <code>ss -tlnp</code> 等命令查看队列使用情况。</li></ul><p>简单来说，<code>backlog</code> 参数决定了服务器能够同时 “挂起” 多少个已经建立但尚未被应用程序处理的 TCP 连接。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;传输层-——-TCP（下）&quot;&gt;&lt;a href=&quot;#传输层-——-TCP（下）&quot; class=&quot;headerlink&quot; title=&quot;传输层 —— TCP（下）&quot;&gt;&lt;/a&gt;传输层 —— TCP（下）&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a</summary>
        
      
    
    
    
    <category term="Linux" scheme="https://www.minbit.top/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://www.minbit.top/tags/Linux/"/>
    
    <category term="网络" scheme="https://www.minbit.top/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>058 从 Centos 切换到 Ubuntu</title>
    <link href="https://www.minbit.top/posts/38169.html"/>
    <id>https://www.minbit.top/posts/38169.html</id>
    <published>2025-10-05T04:00:00.000Z</published>
    <updated>2025-10-12T04:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="从-Centos-切换到-Ubuntu"><a href="#从-Centos-切换到-Ubuntu" class="headerlink" title="从 Centos 切换到 Ubuntu"></a>从 Centos 切换到 Ubuntu</h1><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>Centos 是一个不错的发行版，但是它的各个版本都已经停止维护了。CentOS 7 于 2024 年 6 月 30 日正式停止支持，CentOS 8 更是早在 2021 年 12 月 31 日就停止维护了。而且后续学习中不支持部分软件版本，从长远使用、学习、生态等多方面考虑，将其切换到 Ubuntu 是不错之举。</p><p>其实从一开始就直接接触 Ubuntu 也是不错的选择，但这些都是后话了，各有优劣吧。从 Centos 切换到 Ubuntu 的朋友可以体验到不同系统的优劣，直接使用 Ubuntu 倒是可以省去一些小麻烦，但归根结底，二者基本可以做到无缝互通，命令大差不差，遇到不一样的简单查一下就行了。下面开始教学如何从 Centos 切换到 Ubuntu，基本上比较简单，少部分涉及 Centos 的一点基础。</p><h2 id="2-系统切换"><a href="#2-系统切换" class="headerlink" title="2. 系统切换"></a>2. 系统切换</h2><p>到自己的云服务器厂商后台找到切换镜像，选择 Ubuntu 22.04 版本进行安装，几分钟后就会完成，注意完成后要重新设置密码！</p><p><strong>重要提醒：切换系统前一定要备份好重要数据，系统切换会清空所有数据！</strong></p><h2 id="3-使用-Xshell-进行连接"><a href="#3-使用-Xshell-进行连接" class="headerlink" title="3. 使用 Xshell 进行连接"></a>3. 使用 Xshell 进行连接</h2><p><strong>这里的操作和连接 Centos 一模一样，直接输入公网 IP 和对应的账密就能进行登录。</strong></p><h3 id="1-创建普通账户"><a href="#1-创建普通账户" class="headerlink" title="1. 创建普通账户"></a>1. 创建普通账户</h3><p>同样的，我们还是创建一个普通账户：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adduser 用户名</span><br></pre></td></tr></table></figure><p>紧接着会让我们设置和确认密码，正常输入就行。完了后就会发现和 Centos 的区别：它会让我们设置该账户的信息，比如全名、房间号码、工作电话、家庭电话等。<strong>为了方便可以一路回车表示默认，个人使用会比较方便快捷</strong>，当然，如果你想要进行设置也行。</p><h3 id="2-赋予-sudo-权限"><a href="#2-赋予-sudo-权限" class="headerlink" title="2. 赋予 sudo 权限"></a>2. 赋予 sudo 权限</h3><p><strong>关键步骤</strong>：创建用户后需要赋予 sudo 权限，否则无法执行管理员命令，这里有两个方法：</p><p><strong>方法一：</strong> 和 Centos 一样，使用 <code>root</code> 账户执行命令：<code>vim /etc/sudoers</code>，按下 <code>i</code> 键进入插入模式，找到大约第 100 行左右的位置（附近会有 <code>root ALL=(ALL) ALL</code> 的字眼），在其下方添加以下内容：<code>username    ALL=(ALL)    ALL</code>。</p><ul><li><code>username</code>：替换为你要授权的账户名。</li><li><code>ALL=(ALL)</code>：允许用户以任何用户身份执行命令。</li><li><code>ALL</code>：允许执行所有命令。</li></ul><p>按 <code>Esc</code> 键返回到默认模式，然后输入 <code>:wq!</code> 强制保存并退出。然后就可以验证 <code>sudo</code> 权限了。</p><p><strong>方法二（更推荐）：</strong> 先切换到 root 账号，在 Ubuntu 里，加入 <code>sudo</code> 组就是最安全的方式，把某用户加入 sudo 组执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">usermod -aG <span class="built_in">sudo</span> 用户名</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可选验证：</span></span><br><span class="line"><span class="built_in">groups</span> 用户名</span><br><span class="line"><span class="comment"># 示例输出</span></span><br><span class="line">用户名 : 用户名 <span class="built_in">sudo</span></span><br></pre></td></tr></table></figure><p>这样新用户就可以使用 sudo 命令来执行需要管理员权限的操作了。</p><h2 id="4-软件包管理器详解"><a href="#4-软件包管理器详解" class="headerlink" title="4. 软件包管理器详解"></a>4. 软件包管理器详解</h2><p>在 <strong>Ubuntu 22.04</strong> 中已经没有 <code>yum</code>，它属于 RHEL&#x2F;CentOS 系列。Ubuntu 默认的软件包管理器是 <strong>APT (Advanced Package Tool)</strong>。等价关系大概是：</p><ul><li>CentOS&#x2F;RHEL: <code>yum</code> &#x2F; <code>dnf</code></li><li>Ubuntu&#x2F;Debian: <code>apt</code> &#x2F; <code>apt-get</code></li></ul><h3 id="1-等价命令对比"><a href="#1-等价命令对比" class="headerlink" title="1. 等价命令对比"></a>1. 等价命令对比</h3><table><thead><tr><th>CentOS&#x2F;RHEL (yum&#x2F;dnf)</th><th>Ubuntu&#x2F;Debian (apt)</th><th>说明</th></tr></thead><tbody><tr><td>yum update</td><td>apt update</td><td>更新软件包列表</td></tr><tr><td>yum upgrade</td><td>apt upgrade</td><td>升级已安装的软件</td></tr><tr><td>yum install 包名</td><td>apt install 包名</td><td>安装软件包</td></tr><tr><td>yum remove 包名</td><td>apt remove 包名</td><td>卸载软件包</td></tr><tr><td>yum search 关键词</td><td>apt search 关键词</td><td>搜索软件包</td></tr><tr><td>yum info 包名</td><td>apt show 包名</td><td>显示软件包详细信息</td></tr></tbody></table><h3 id="2-常用-APT-命令"><a href="#2-常用-APT-命令" class="headerlink" title="2. 常用 APT 命令"></a>2. 常用 APT 命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt update<span class="comment"># 更新软件包列表</span></span><br><span class="line"><span class="built_in">sudo</span> apt upgrade -y<span class="comment"># 升级已安装的软件</span></span><br><span class="line"><span class="built_in">sudo</span> apt install 软件包名称 -y<span class="comment"># 安装软件包</span></span><br><span class="line"><span class="built_in">sudo</span> apt remove 软件包名称 -y<span class="comment"># 卸载软件包</span></span><br><span class="line"><span class="built_in">sudo</span> apt purge 软件包名称 -y<span class="comment"># 彻底卸载（包括配置文件）</span></span><br><span class="line">apt search 关键词<span class="comment"># 搜索软件包</span></span><br><span class="line"><span class="built_in">sudo</span> apt clean<span class="comment"># 清理缓存</span></span><br></pre></td></tr></table></figure><h3 id="3-更新升级"><a href="#3-更新升级" class="headerlink" title="3. 更新升级"></a>3. 更新升级</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt update        <span class="comment"># 更新软件包列表</span></span><br><span class="line"><span class="built_in">sudo</span> apt upgrade -y    <span class="comment"># 升级已安装的软件</span></span><br></pre></td></tr></table></figure><p>这个过程可能在 10 多分钟作用，耐心等待……可能会出现下面的情况：</p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20251005182822895.png" alt="PixPin_2025-10-05_18-28-09"></p><p>这是 <strong>Ubuntu 在升级 <code>openssh-server</code> 包时的提示</strong>，意思是：之前修改过 <code>/etc/ssh/sshd_config</code> 配置文件（比如改过端口、sudo 权限等），而现在升级的软件包带来了一份新的默认配置。系统不知道该用哪个，所以给出选择，选项含义：</p><ol><li><strong>install the package maintainer’s version</strong> → 用新版本覆盖掉你现在的配置（会丢失你自己改的设置）。</li><li><strong>keep the local version currently installed</strong> → 保留你现在的配置（推荐，大部分情况下选这个）。</li><li><strong>show the differences…</strong> → 查看差异，方便你决定。</li><li><strong>do a 3-way merge…</strong> → 尝试三方合并。</li><li><strong>start a new shell…</strong> → 打开一个 shell 手动处理。</li></ol><p>按照自己情况来，如果选择覆盖，之前的解放的 sudo 要重新配置。</p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20251005183306585.png" alt="PixPin_2025-10-05_18-32-57"></p><p><strong>直接 ok 就行。</strong> 这是 Ubuntu 系统提示有内核更新待处理的界面。系统当前运行的内核版本是 <code>5.15.0 - 138 - generic</code>，而有更新的内核版本 <code>5.15.0 - 157 - generic</code> 可用。提示说明系统不会自动重启来加载新内核，建议你考虑手动重启系统，这样新的内核就能被加载运行，可能会带来性能优化、 bug 修复等好处。</p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20251005183326565.png" alt="PixPin_2025-10-05_18-33-15"></p><p><strong>直接保持默认选中的状态，然后选择 <code>&lt;Ok&gt;</code> 即可。</strong> 当你看到这个界面时，是系统在询问哪些服务需要重启，因为有一些守护进程使用了过时的库，（前面带 <code>[*]</code>）通常是系统推荐需要重启的关键服务，更新后需要重启相关服务来应用更改。这些服务依赖的库更新后，重启它们能确保服务使用新库正常运行。</p><p><strong>为了让新的内核和系统更新完全生效，建议你重启系统：<code>sudo reboot</code> 或云服务器厂商后台重启。</strong></p><h2 id="5-安装和配置-GCC-编译器"><a href="#5-安装和配置-GCC-编译器" class="headerlink" title="5. 安装和配置 GCC 编译器"></a>5. 安装和配置 GCC 编译器</h2><h3 id="1-安装较新的-GCC-和-G-（推荐版本-9-12）"><a href="#1-安装较新的-GCC-和-G-（推荐版本-9-12）" class="headerlink" title="1. 安装较新的 GCC 和 G++（推荐版本 9-12）"></a>1. 安装较新的 GCC 和 G++（推荐版本 9-12）</h3><p>Ubuntu 22.04 默认自带的 GCC 版本是 <strong>11.x</strong>。如果你需要更高版本（例如 GCC 12 或 13），可以通过官方 <code>ppa:ubuntu-toolchain-r/test</code> 获得，这里我们选择默认的就行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 PPA 源</span></span><br><span class="line"><span class="built_in">sudo</span> add-apt-repository ppa:ubuntu-toolchain-r/test -y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可选</span></span><br><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt install gcc-13 g++-13 -y</span><br></pre></td></tr></table></figure><p>安装完成后可以用以下命令查看版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">gcc --version</span><br><span class="line">g++ --version</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例输出：</span></span><br><span class="line">gcc (Ubuntu 11.4.0-1ubuntu1~22.04.2) 11.4.0</span><br><span class="line">Copyright (C) 2021 Free Software Foundation, Inc.</span><br><span class="line">This is free software; see the <span class="built_in">source</span> <span class="keyword">for</span> copying conditions.  There is NO</span><br><span class="line">warranty; not even <span class="keyword">for</span> MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</span><br><span class="line"></span><br><span class="line">g++ (Ubuntu 11.4.0-1ubuntu1~22.04.2) 11.4.0</span><br><span class="line">Copyright (C) 2021 Free Software Foundation, Inc.</span><br><span class="line">This is free software; see the <span class="built_in">source</span> <span class="keyword">for</span> copying conditions.  There is NO</span><br><span class="line">warranty; not even <span class="keyword">for</span> MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</span><br></pre></td></tr></table></figure><h3 id="2-安装指定版本的-GCC（可选）"><a href="#2-安装指定版本的-GCC（可选）" class="headerlink" title="2. 安装指定版本的 GCC（可选）"></a>2. 安装指定版本的 GCC（可选）</h3><p>如果你需要安装 GCC 12 或 13：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 GCC 12</span></span><br><span class="line"><span class="built_in">sudo</span> apt install gcc-12 g++-12 -y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 GCC 13（需要添加 PPA 源）</span></span><br><span class="line"><span class="built_in">sudo</span> add-apt-repository ppa:ubuntu-toolchain-r/test -y</span><br><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt install gcc-13 g++-13 -y</span><br></pre></td></tr></table></figure><h3 id="3-配置-GCC-版本切换（可选）"><a href="#3-配置-GCC-版本切换（可选）" class="headerlink" title="3. 配置 GCC 版本切换（可选）"></a>3. 配置 GCC 版本切换（可选）</h3><p>如果系统中安装了多个版本的 GCC，可以使用 update-alternatives 来管理：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置 GCC 12 为默认版本</span></span><br><span class="line"><span class="built_in">sudo</span> update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-12 100 \</span><br><span class="line">                         --slave /usr/bin/g++ g++ /usr/bin/g++-12 \</span><br><span class="line">                         --slave /usr/bin/gcov gcov /usr/bin/gcov-12</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置 GCC 11 为备选版本</span></span><br><span class="line"><span class="built_in">sudo</span> update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-11 80 \</span><br><span class="line">                         --slave /usr/bin/g++ g++ /usr/bin/g++-11 \</span><br><span class="line">                         --slave /usr/bin/gcov gcov /usr/bin/gcov-11</span><br></pre></td></tr></table></figure><p><strong>切换 GCC 版本</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> update-alternatives --config gcc</span><br></pre></td></tr></table></figure><p>输入对应的编号即可切换到相应的 GCC 版本。</p><h2 id="6-其他工具的安装"><a href="#6-其他工具的安装" class="headerlink" title="6. 其他工具的安装"></a>6. 其他工具的安装</h2><blockquote><p>在 CentOS 中，使用 <code>yum install</code> 或 <code>dnf install</code> 安装软件时，<strong>最后会显示一行醒目的：<code>Complete!</code></strong>，这行文字就像一个“成功印章”，告诉你：“安装顺利完成，一切 OK！”<strong>Ubuntu 不会显示 <code>Complete!</code>，在 Ubuntu 的世界里，安静，就是最好的赞美！没有报错（Error）就是成功！</strong></p></blockquote><h3 id="1-安装-tree-命令"><a href="#1-安装-tree-命令" class="headerlink" title="1. 安装 tree 命令"></a>1. 安装 <code>tree</code> 命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install tree -y</span><br></pre></td></tr></table></figure><p>安装完成后测试：<code>tree --version</code>。</p><h3 id="2-安装-Git"><a href="#2-安装-Git" class="headerlink" title="2. 安装 Git"></a>2. 安装 Git</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install git -y <span class="comment"># 通常是 2.34.x（Ubuntu 22.04 默认）</span></span><br><span class="line">git --version  <span class="comment"># 版本验证，可能是 2.40+ 或更高</span></span><br></pre></td></tr></table></figure><h3 id="3-安装-lrzsz-工具"><a href="#3-安装-lrzsz-工具" class="headerlink" title="3. 安装 lrzsz 工具"></a>3. 安装 lrzsz 工具</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install lrzsz -y</span><br></pre></td></tr></table></figure><p>安装后即可使用：</p><ul><li><code>rz</code>：从本地上传文件到服务器。</li><li><code>sz 文件名</code>：从服务器下载文件到本地。</li></ul><h3 id="4-安装-htop-命令"><a href="#4-安装-htop-命令" class="headerlink" title="4. 安装 htop 命令"></a>4. 安装 <code>htop</code> 命令</h3><p><code>htop</code> 是交互式的进程监控工具，比 <code>top</code> 更直观，支持上下滚动查看进程树，命令：<code>htop</code>，和 top 差不多，也是按 q 退出。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install htop -y</span><br></pre></td></tr></table></figure><h3 id="5-安装-Core-Dump-调试支持（debuginfo-替代）"><a href="#5-安装-Core-Dump-调试支持（debuginfo-替代）" class="headerlink" title="5. 安装 Core Dump 调试支持（debuginfo 替代）"></a>5. 安装 Core Dump 调试支持（<code>debuginfo</code> 替代）</h3><p>在 Ubuntu 中 <strong>没有 <code>debuginfo-install</code></strong> 命令，对应的是 <strong><code>-dbg</code> 或 <code>-dbgsym</code></strong> 包。Ubuntu 的 <code>libc6-dbg</code> 是 glibc 的调试信息包，<code>libgcc-11-dev</code> 对应 GCC 的调试支持（你可以根据 GCC 版本调整，如 <code>libgcc-12-dev</code>）。用于调试程序 Core Dump 时提供符号信息，让 gdb 能正确显示函数调用栈。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install libc6-dbg libgcc-11-dev -y</span><br><span class="line">dpkg -l | grep libc6-dbg<span class="comment"># 验证：若出现 libc6-dbg，说明安装成功。</span></span><br></pre></td></tr></table></figure><h3 id="6-安装-JsonCpp"><a href="#6-安装-JsonCpp" class="headerlink" title="6. 安装 JsonCpp"></a>6. 安装 <code>JsonCpp</code></h3><p><code>JsonCpp</code> 是 C++ 的 JSON 解析与序列化库，常用于网络通信、配置文件解析。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install libjsoncpp-dev -y</span><br><span class="line">dpkg -l | grep jsoncpp<span class="comment"># 验证：若显示 libjsoncpp-dev，说明安装成功。</span></span><br></pre></td></tr></table></figure><h3 id="7-安装-telnet"><a href="#7-安装-telnet" class="headerlink" title="7. 安装 telnet"></a>7. 安装 <code>telnet</code></h3><p><code>telnet</code> 用于测试网络连通性与端口开放状态（TCP 连接测试），可快速验证远程主机端口是否可访问。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install telnet -y</span><br></pre></td></tr></table></figure><p>基本语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># telnet [主机名或IP地址] [端口号]，比如：</span></span><br><span class="line">telnet baidu.com 80</span><br><span class="line"><span class="comment"># 连通后的示例输出：</span></span><br><span class="line">Trying 220.181.7.203...</span><br><span class="line">Connected to baidu.com.</span><br><span class="line">Escape character is <span class="string">&#x27;^]&#x27;</span>.</span><br></pre></td></tr></table></figure><p><strong>注意：如果省略端口号，默认连接远程主机的 23 端口（Telnet 服务默认端口）。退出 Telnet 连接： Telnet 交互界面中，按 Ctrl + ] 进入命令模式，然后输入 quit 退出。</strong></p><h3 id="8-安装-iostat（sysstat-工具包）"><a href="#8-安装-iostat（sysstat-工具包）" class="headerlink" title="8. 安装 iostat（sysstat 工具包）"></a>8. 安装 <code>iostat</code>（sysstat 工具包）</h3><p><code>iostat</code> 用于监控 <strong>CPU 使用率</strong> 和 <strong>磁盘 I&#x2F;O 性能</strong>，常用于性能分析。用命令 <code>iostat</code> 验证，如果输出 CPU 与磁盘统计信息，即表示安装成功。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install sysstat -y</span><br></pre></td></tr></table></figure><h3 id="9-使用-ifconfig-命令"><a href="#9-使用-ifconfig-命令" class="headerlink" title="9. 使用 ifconfig 命令"></a>9. 使用 <code>ifconfig</code> 命令</h3><p>从 Ubuntu 18.04 开始，<code>ifconfig</code> 已经不再默认安装，取而代之的是更强大的 <strong>ip 命令</strong>。如果更习惯 <code>ifconfig</code>，可以安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install net-tools</span><br></pre></td></tr></table></figure><p>安装完成后即可使用：<code>ifconfig</code>。</p><h2 id="7-使用-VS-Code-连接主机开始开发"><a href="#7-使用-VS-Code-连接主机开始开发" class="headerlink" title="7. 使用 VS Code 连接主机开始开发"></a>7. 使用 VS Code 连接主机开始开发</h2><p>这里的操作和之前的一模一样，但是会存在一个问题：换了系统后，公网 IP 和配置没变，典型的效果是远程资源管理器中还显示旧的记录，新的连接一直失败。</p><p><strong>解决方法：此时需要做一个操作：在 Windows 中来到 <code>C:\Users\xxxxxxxx\.ssh</code> 这个目录下，将最后 <code>known_hosts</code> 和 <code>known_hosts.old</code> 这 2 个文件删除，重新连接即可，等待 1-2 分钟，VS Code Server 就会完成，该目录下会自动生成新的密钥，我们又可以进行愉快的开发啦~</strong></p><blockquote><p>如果你使用的还是 <strong>1.85.1 版本的 VS Code</strong> 那就是照旧，但如果你使用的是 <strong>2025 年 9 月（版本 1.105）</strong>，你就会惊奇的发现也可以正常连接！这对于我们老 CentOS 用户来说真是太妙啦！如今的 Ubuntu 不管是这个用户体验还是生态来说都要优于 CentOS，真体验到了什么叫 <strong>对开发者真友好</strong>……</p></blockquote>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;从-Centos-切换到-Ubuntu&quot;&gt;&lt;a href=&quot;#从-Centos-切换到-Ubuntu&quot; class=&quot;headerlink&quot; title=&quot;从 Centos 切换到 Ubuntu&quot;&gt;&lt;/a&gt;从 Centos 切换到 Ubuntu&lt;/h1&gt;&lt;h2</summary>
        
      
    
    
    
    <category term="Linux" scheme="https://www.minbit.top/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://www.minbit.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>01 在 Ubuntu 中安装 Redis</title>
    <link href="https://www.minbit.top/posts/15952.html"/>
    <id>https://www.minbit.top/posts/15952.html</id>
    <published>2025-10-04T16:00:00.000Z</published>
    <updated>2025-10-05T02:10:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="在-Ubuntu-中安装-Redis"><a href="#在-Ubuntu-中安装-Redis" class="headerlink" title="在 Ubuntu 中安装 Redis"></a>在 Ubuntu 中安装 Redis</h1><blockquote><p><strong>在安装之前需要切换至 root 账户！</strong></p></blockquote><h2 id="1-查找可用版本"><a href="#1-查找可用版本" class="headerlink" title="1. 查找可用版本"></a>1. 查找可用版本</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">apt search redis</span><br><span class="line"></span><br><span class="line"><span class="comment"># 往下翻（可能较长），大概会存在下面的字样：</span></span><br><span class="line">redis/jammy 5:6.0.16-1ubuntu1 all</span><br><span class="line">  Persistent key-value database with network interface (metapackage)</span><br></pre></td></tr></table></figure><h2 id="2-安装"><a href="#2-安装" class="headerlink" title="2. 安装"></a>2. 安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">apt install redis</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 看到：</span></span><br><span class="line">Do you want to <span class="built_in">continue</span>? [Y/n] </span><br><span class="line"><span class="comment"># 选择 y</span></span><br></pre></td></tr></table></figure><h2 id="3-验证版本"><a href="#3-验证版本" class="headerlink" title="3. 验证版本"></a>3. 验证版本</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server --version</span><br></pre></td></tr></table></figure><h2 id="4-修改配置文件"><a href="#4-修改配置文件" class="headerlink" title="4. 修改配置文件"></a>4. 修改配置文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc/redis</span><br><span class="line">ll</span><br><span class="line">vim redis.conf</span><br></pre></td></tr></table></figure><p>做以下修改：</p><ul><li><code>bind 127.0.0.1 ::1</code> 改成 <code>bind 0.0.0.0 ::1</code>。</li><li><code>protected-mode yes</code> 改成 <code>protected-mode no</code>。</li></ul><p>重新启动服务器生效并检查：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">service redis-server restart</span><br><span class="line"></span><br><span class="line">service redis-server status</span><br><span class="line"><span class="comment"># 看到绿色的 active (running) 即代表成功</span></span><br></pre></td></tr></table></figure><h2 id="5-连接和退出"><a href="#5-连接和退出" class="headerlink" title="5. 连接和退出"></a>5. 连接和退出</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis-cli</span><br><span class="line">127.0.0.1:6379&gt; ping</span><br><span class="line"><span class="comment"># 返回 PONG 表示成功</span></span><br></pre></td></tr></table></figure><p><strong>退出：按 <code>Ctrl+D</code> 或输入 <code>exit</code>。</strong></p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;在-Ubuntu-中安装-Redis&quot;&gt;&lt;a href=&quot;#在-Ubuntu-中安装-Redis&quot; class=&quot;headerlink&quot; title=&quot;在 Ubuntu 中安装 Redis&quot;&gt;&lt;/a&gt;在 Ubuntu 中安装</summary>
        
      
    
    
    
    <category term="Redis" scheme="https://www.minbit.top/categories/Redis/"/>
    
    
    <category term="Redis" scheme="https://www.minbit.top/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>00 在 CentOS 7 上安装 Redis</title>
    <link href="https://www.minbit.top/posts/7665.html"/>
    <id>https://www.minbit.top/posts/7665.html</id>
    <published>2025-10-04T16:00:00.000Z</published>
    <updated>2025-10-05T02:10:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CentOS-7-安装-Redis-5-碰壁记录：从-yum-源配置到软件安装的踩坑之旅"><a href="#CentOS-7-安装-Redis-5-碰壁记录：从-yum-源配置到软件安装的踩坑之旅" class="headerlink" title="CentOS 7 安装 Redis 5 碰壁记录：从 yum 源配置到软件安装的踩坑之旅"></a>CentOS 7 安装 Redis 5 碰壁记录：从 yum 源配置到软件安装的踩坑之旅</h1><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>我尝试在 CentOS 7 服务器上尝试安装 Redis 5，原本以为是个简单的 <code>yum install redis</code> 就能搞定的事情，结果却遇到了一系列问题。原本用下面的步骤就能完成，但是很不巧，这个迭代和维护等种种原因很不巧的出现在一起……所以这下面的 6 条命令仅适合有缘人。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 先把原有的 repo 文件备份，避免冲突或损坏</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">mv</span> /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.bak</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 使用阿里云的 CentOS7 源替换官方源</span></span><br><span class="line"><span class="comment">#   - 这里直接下载阿里云维护的 CentOS-7.repo 文件到 /etc/yum.repos.d/ 目录</span></span><br><span class="line"><span class="built_in">sudo</span> curl -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 清理旧的 yum 缓存</span></span><br><span class="line"><span class="built_in">sudo</span> yum clean all</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 重新生成 yum 缓存，确保源可以正常使用</span></span><br><span class="line"><span class="built_in">sudo</span> yum makecache</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 安装 gcc</span></span><br><span class="line"><span class="comment">#   - 如果系统已经有 gcc，则会提示已安装并是最新版本</span></span><br><span class="line"><span class="built_in">sudo</span> yum install -y gcc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 6. 安装常用开发工具（可选，推荐一次性安装好）</span></span><br><span class="line"><span class="comment">#   - 包括 gcc-c++（C++编译器）、make（编译工具）、wget（下载工具）、epel-release（扩展源）</span></span><br><span class="line"><span class="built_in">sudo</span> yum install -y gcc gcc-c++ make wget epel-release</span><br></pre></td></tr></table></figure><p>从最初的 yum 源无法解析，到更换阿里云源，再到 Redis 版本不符预期，整个过程真是惹人心烦。<strong>本文将详细记录我的操作过程、遇到的问题，最终我还是没能成功安装，但是可以安装 Redis 7.2.5 这个版本，希望能为遇到类似问题的朋友提供参考。</strong></p><h2 id="2-问题起源：yum-源无法解析"><a href="#2-问题起源：yum-源无法解析" class="headerlink" title="2. 问题起源：yum 源无法解析"></a>2. 问题起源：yum 源无法解析</h2><h3 id="1-初始尝试"><a href="#1-初始尝试" class="headerlink" title="1. 初始尝试"></a>1. 初始尝试</h3><p>我首先尝试安装基础的开发工具：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> yum install -y gcc gcc-c++ make wget epel-release</span><br></pre></td></tr></table></figure><p>结果立即遇到了问题：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Could not retrieve mirrorlist http://mirrorlist.centos.org?<span class="built_in">arch</span>=x86\_64\&amp;release=7\&amp;repo=sclo-rh error was</span><br><span class="line"></span><br><span class="line">14: curl#6 - <span class="string">&quot;Could not resolve host: mirrorlist.centos.org; Unknown error&quot;</span></span><br></pre></td></tr></table></figure><p>这个错误很明显是由于无法解析官方的 <a href="https://mirrorlist.centos.org/">mirrorlist.centos.org</a> 域名导致的。这可能是由于网络问题，或者是 CentOS 7 官方源在国内访问不稳定造成的。</p><h2 id="3-解决方案一：更换阿里云-yum-源"><a href="#3-解决方案一：更换阿里云-yum-源" class="headerlink" title="3. 解决方案一：更换阿里云 yum 源"></a>3. 解决方案一：更换阿里云 yum 源</h2><p>既然官方源有问题，我决定更换为国内的阿里云源。</p><h3 id="1-备份原有源配置"><a href="#1-备份原有源配置" class="headerlink" title="1. 备份原有源配置"></a>1. 备份原有源配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">mv</span> /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.bak</span><br></pre></td></tr></table></figure><h3 id="2-下载阿里云源配置"><a href="#2-下载阿里云源配置" class="headerlink" title="2. 下载阿里云源配置"></a>2. 下载阿里云源配置</h3><p>我首先尝试从 <a href="https://vault.centos.org/">vault.centos.org</a> 下载：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> curl -o /etc/yum.repos.d/CentOS-Base.repo http://vault.centos.org/7.9.2009/os/x86\_64/CentOS-Base.repo</span><br></pre></td></tr></table></figure><p>但下载下来的文件似乎有问题，执行 <code>yum clean all</code> 时出现：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">File contains no section headers.</span><br><span class="line"></span><br><span class="line">file: file:///etc/yum.repos.d/CentOS-Base.repo, line: 1</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;\&lt;html&gt;\r\n&#x27;</span></span><br></pre></td></tr></table></figure><p>看来直接从 vault 下载的文件不是正确的 repo 配置文件。</p><h3 id="3-正确的阿里云源配置"><a href="#3-正确的阿里云源配置" class="headerlink" title="3. 正确的阿里云源配置"></a>3. 正确的阿里云源配置</h3><p>我重新尝试直接从阿里云下载 repo 文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">rm</span> -f /etc/yum.repos.d/CentOS-Base.repo</span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> curl -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo</span><br></pre></td></tr></table></figure><p>这次下载成功了。接下来清理缓存并重新生成：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> yum clean all</span><br><span class="line"><span class="built_in">sudo</span> yum makecache</span><br></pre></td></tr></table></figure><p>在 <code>yum makecache</code> 过程中，虽然出现了一些连接超时的警告：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http://mirrors.cloud.aliyuncs.com/centos/7/os/x86\_64/repodata/6d0c3a488c282fe537794b5946b01e28c7f44db79097bb06826e1c0c88bad5ef-primary.sqlite.bz2: \[Errno 14] curl#6 - <span class="string">&quot;Could not resolve host: mirrors.cloud.aliyuncs.com; Unknown error&quot;</span></span><br><span class="line"></span><br><span class="line">Trying other mirror.</span><br></pre></td></tr></table></figure><p>但最终还是成功生成了缓存：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Metadata Cache Created</span><br></pre></td></tr></table></figure><h2 id="4-验证基础工具安装"><a href="#4-验证基础工具安装" class="headerlink" title="4. 验证基础工具安装"></a>4. 验证基础工具安装</h2><p>更换源后，我再次检查基础开发工具是否已安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gcc -v</span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> yum install -y gcc-c++</span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> yum install -y make wget epel-release</span><br></pre></td></tr></table></figure><p>结果显示这些工具都已经安装并且是最新版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Package gcc-4.8.5-44.el7.x86\_64 already installed and latest version</span><br><span class="line"></span><br><span class="line">Package gcc-c++-4.8.5-44.el7.x86\_64 already installed and latest version</span><br><span class="line"></span><br><span class="line">Package 1:make-3.82-24.el7.x86\_64 already installed and latest version</span><br><span class="line"></span><br><span class="line">Package wget-1.14-18.el7\_6.1.x86\_64 already installed and latest version</span><br><span class="line"></span><br><span class="line">Package epel-release-7-14.noarch already installed and latest version</span><br></pre></td></tr></table></figure><p>看来基础环境已经准备好了。</p><h2 id="5-安装-Redis-的尝试"><a href="#5-安装-Redis-的尝试" class="headerlink" title="5. 安装 Redis 的尝试"></a>5. 安装 Redis 的尝试</h2><h3 id="1-安装-yum-utils"><a href="#1-安装-yum-utils" class="headerlink" title="1. 安装 yum-utils"></a>1. 安装 yum-utils</h3><p>为了更好地管理 yum 源，我先安装了 yum-utils：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> yum install -y yum-utils</span><br></pre></td></tr></table></figure><p>这个安装过程很顺利，成功安装了 yum-utils 及其依赖包。</p><h3 id="2-尝试通过-remi-源安装-Redis"><a href="#2-尝试通过-remi-源安装-Redis" class="headerlink" title="2. 尝试通过 remi 源安装 Redis"></a>2. 尝试通过 remi 源安装 Redis</h3><p>我知道 remi 源提供了较新版本的 Redis，所以尝试使用 remi 源：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum --enablerepo=remi list redis</span><br></pre></td></tr></table></figure><p>显示可以安装 Redis 7.2.5：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Available Packages</span><br><span class="line"></span><br><span class="line">redis.x86\_64                                                7.2.5-1.el7.remi                                                remi</span><br></pre></td></tr></table></figure><p>我启用了 remi 源并安装 Redis：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> yum-config-manager --<span class="built_in">enable</span> remi</span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> yum install -y redis</span><br></pre></td></tr></table></figure><p>安装成功后，验证版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis-server -v</span><br><span class="line"></span><br><span class="line">Redis server v=7.2.5 sha=00000000:0 malloc=jemalloc-5.3.0 bits=64 build=2dd7a20ee3c6d015</span><br></pre></td></tr></table></figure><p>虽然安装成功了，但这是 Redis 7.2.5，而不是我需要的 Redis 5。</p><h3 id="3-尝试安装-Redis-5"><a href="#3-尝试安装-Redis-5" class="headerlink" title="3. 尝试安装 Redis 5"></a>3. 尝试安装 Redis 5</h3><p>我卸载了 Redis 7.2.5，并尝试安装 Redis 5：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> yum remove -y redis</span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> yum-config-manager --<span class="built_in">disable</span> remi</span><br></pre></td></tr></table></figure><p>我听说 remi 源有专门的 redis50 仓库，所以尝试启用它：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> yum-config-manager --<span class="built_in">enable</span> remi-redis50</span><br></pre></td></tr></table></figure><p>但这个命令执行后没有任何输出，可能 remi-redis50 源在我的系统中不存在。然后我尝试直接安装 Redis：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> yum install -y redis</span><br></pre></td></tr></table></figure><p>这次安装的是来自 epel 源的 Redis 3.2.12：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Package redis.x86\_64 0:3.2.12-2.el7 will be installed</span><br></pre></td></tr></table></figure><p>验证版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis-server -v</span><br><span class="line"></span><br><span class="line">Redis server v=3.2.12 sha=00000000:0 malloc=jemalloc-3.6.0 bits=64 build=7897e7d0e13773f</span><br></pre></td></tr></table></figure><p>这仍然不是我需要的 Redis 5。</p><h2 id="6-问题总结与分析"><a href="#6-问题总结与分析" class="headerlink" title="6. 问题总结与分析"></a>6. 问题总结与分析</h2><h3 id="1-成功的操作"><a href="#1-成功的操作" class="headerlink" title="1. 成功的操作"></a>1. 成功的操作</h3><ol><li><p><strong>更换阿里云 yum 源</strong>：成功解决了官方源无法解析的问题</p></li><li><p><strong>安装基础开发工具</strong>：确认 gcc、gcc-c++、make、wget 等工具已正确安装</p></li><li><p><strong>安装 yum-utils</strong>：成功安装了 yum 源管理工具</p></li><li><p><strong>通过 remi 源安装 Redis 7</strong>：成功安装了 Redis 7.2.5</p></li></ol><h3 id="2-未解决的问题"><a href="#2-未解决的问题" class="headerlink" title="2. 未解决的问题"></a>2. 未解决的问题</h3><ol><li><p><strong>无法通过 yum 源安装 Redis 5</strong>：虽然尝试了多种方法，但最终只能安装到 Redis 3.2.12 或 Redis 7.2.5</p></li><li><p><strong>remi-redis50 源配置问题</strong>：可能需要手动配置 remi-redis50 源才能安装 Redis 5</p></li></ol><h2 id="7-参考资料"><a href="#7-参考资料" class="headerlink" title="7. 参考资料"></a>7. 参考资料</h2><ol><li><p>CentOS 官方文档。</p></li><li><p>阿里云开源镜像站文档。</p></li><li><p>Redis 官方安装指南。</p></li><li><p>各大技术社区的相关讨论和解决方案。</p></li></ol>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;CentOS-7-安装-Redis-5-碰壁记录：从-yum-源配置到软件安装的踩坑之旅&quot;&gt;&lt;a href=&quot;#CentOS-7-安装-Redis-5-碰壁记录：从-yum-源配置到软件安装的踩坑之旅&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    <category term="Redis" scheme="https://www.minbit.top/categories/Redis/"/>
    
    
    <category term="Redis" scheme="https://www.minbit.top/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>临时邮箱汇总</title>
    <link href="https://www.minbit.top/posts/30632.html"/>
    <id>https://www.minbit.top/posts/30632.html</id>
    <published>2025-09-30T16:00:00.000Z</published>
    <updated>2025-10-01T02:10:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="临时邮箱汇总"><a href="#临时邮箱汇总" class="headerlink" title="临时邮箱汇总"></a>临时邮箱汇总</h1><p>在网络世界中，邮箱验证是注册账户的常见方式。然而，在一些小众或安全性未知的网站注册时，邮箱泄露可能会导致无休止的垃圾邮件轰炸。特别是当我们需要临时使用邮箱或批量注册账号时，临时邮箱就成为了理想选择。本文将深入探讨临时邮箱的优势，并汇总 2025 年国内外最佳临时邮箱服务，助你轻松应对各种注册需求。</p><h2 id="什么是临时邮箱？"><a href="#什么是临时邮箱？" class="headerlink" title="什么是临时邮箱？"></a>什么是临时邮箱？</h2><p>临时邮箱，顾名思义，是一种具有时间限制的邮箱。它与我们常用的永久邮箱不同，后者除非用户主动注销，否则会一直存在。临时邮箱则是一次性的，使用完毕即可丢弃。尽管寿命有限，临时邮箱的功能与普通邮箱无异，支持接收邮件、用于注册登录等操作。</p><h2 id="临时邮箱的优势"><a href="#临时邮箱的优势" class="headerlink" title="临时邮箱的优势"></a>临时邮箱的优势</h2><p>相比永久邮箱，临时邮箱在保护隐私、规避垃圾邮件等方面具有显著优势：</p><ul><li><strong>🛡️ 抵御垃圾邮件：</strong> 避免大量无关邮件占用主邮箱空间，确保重要邮件不被遗漏。</li><li><strong>🔒 防范恶意软件：</strong>  大多数临时邮箱都会丢弃附件，降低病毒、木马等恶意软件的风险。</li><li><strong>👤 保护匿名性：</strong> 无需注册，不收集个人信息，有效避免个人信息泄露。</li><li><strong>♾️ 邮箱数量无限制：</strong> 突破永久邮箱的注册限制，可用于注册多个账号，满足跨境营销等需求。</li></ul><h2 id="何时使用临时邮箱？"><a href="#何时使用临时邮箱？" class="headerlink" title="何时使用临时邮箱？"></a>何时使用临时邮箱？</h2><p>在某些场景下，临时邮箱能更好地满足我们的需求：</p><ul><li><strong>不想接收垃圾邮件：</strong>  注册论坛、博客等网站，仅为查看内容或下载资源时使用，避免后续广告轰炸。</li><li><strong>临时注册：</strong> 快速注册一些不常用的账户，无需担心邮箱信息长期暴露。</li><li><strong>批量注册：</strong>  需要注册多个账号进行推广、测试时，临时邮箱可以轻松应对。</li></ul><h2 id="2025-年国内外最佳临时邮箱服务汇总"><a href="#2025-年国内外最佳临时邮箱服务汇总" class="headerlink" title="2025 年国内外最佳临时邮箱服务汇总"></a>2025 年国内外最佳临时邮箱服务汇总</h2><p>以下列出了一系列好评如潮的临时邮箱服务，方便您选择使用：</p><h3 id="免费临时邮箱服务"><a href="#免费临时邮箱服务" class="headerlink" title="免费临时邮箱服务"></a>免费临时邮箱服务</h3><ul><li><strong><a href="https://www.linshiyouxiang.net/">LinShiYouXiang.net</a></strong>：提供 10 分钟邮箱、24 小时邮箱等多种临时邮箱服务，快速接收邮件，保护用户隐私。</li><li><strong><a href="https://temp-mail.org/zh/">Temp-Mail.org</a></strong>：提供匿名临时邮箱地址，有效拦截垃圾邮件，保护真实邮箱。</li><li><strong><a href="https://tempm.com/">Tempm.com</a></strong>：无需注册，提供自定义域名临时邮箱，具备实时自动接收邮件等特性。</li><li><strong><a href="https://internxt.com/zh/temporary-email">Internxt</a></strong>：提供匿名、安全、临时的邮箱地址服务，且附带邮件收件箱功能。</li><li><strong><a href="https://mail.tm/zh/">Mail.tm</a></strong>：安全、快速的临时邮箱服务，无需注册，有效防止垃圾邮件和在线滥用。</li><li><strong><a href="https://tempmail.plus/zh/">TempMail.Plus</a></strong>：支持多语言，可自定义邮箱前缀和域名，拥有隐私设置和 TOR 镜像访问。</li><li><strong><a href="https://www.linshi-email.com/">www.linshi-email.com</a></strong>：提供临时邮箱服务，保护真实邮箱免受垃圾邮件侵害。</li><li><strong><a href="https://temp-mail.io/zh">temp-mail.io</a></strong>：一次性邮件服务，能有效保护真实邮箱，匿名且免费。</li><li><strong><a href="https://moakt.com/zh">moakt.com</a></strong>：提供可替代邮箱、临时邮箱等多种服务，功能全面。</li><li><strong><a href="https://www.linshiguge.com/">www.linshiguge.com</a></strong>：提供免费的临时谷歌邮箱，支持 Gmail、Googlemail 等。</li><li><strong><a href="https://www.guerrillamail.com/zh/">GuerrillaMail</a></strong>：提供持续 60 分钟的临时邮箱，无需注册，高效处理邮件。</li><li><strong><a href="https://youxiang.dev/mailbox">youxiang.dev</a></strong>：包含临时邮箱、Gmail、Outlook 等多种类型，一站式服务。</li><li><strong><a href="https://linshiyou.com/">linshiyou.com</a></strong>：提供 10 分钟邮箱、24 小时邮箱等多种选择，支持自动刷新接收。</li><li><strong><a href="https://smailpro.com/temporary-email">smailpro.com</a></strong>：几秒内生成一次性 Gmail 和 Outlook 邮箱地址。</li><li><strong><a href="https://22.do/">22.do</a></strong>：提供临时、安全、匿名且免费的电子邮件地址。</li><li><strong><a href="https://www.emailnator.com/">www.emailnator.com</a></strong>：提供真实的 Gmail 临时电子邮件地址，防止垃圾邮件。</li><li><strong><a href="https://rootsh.com/">rootsh.com</a></strong>：提供临时邮箱、10 分钟邮箱等服务，支持自动刷新接收。</li><li><strong><a href="https://tempmail100.com/zh-cn/">tempmail100.com</a></strong>：无需注册，提供安全、匿名的临时邮箱。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>临时邮箱为用户提供了一种便捷、安全、隐私的邮箱使用方案。无论您是出于保护隐私、避免垃圾邮件还是临时注册的需求，都可以从以上列表中选择适合自己的临时邮箱服务。记得收藏本篇文章，以便在需要时随时查阅！</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;临时邮箱汇总&quot;&gt;&lt;a href=&quot;#临时邮箱汇总&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    <category term="灵光荟萃" scheme="https://www.minbit.top/categories/%E7%81%B5%E5%85%89%E8%8D%9F%E8%90%83/"/>
    
    
    <category term="临时邮箱" scheme="https://www.minbit.top/tags/%E4%B8%B4%E6%97%B6%E9%82%AE%E7%AE%B1/"/>
    
  </entry>
  
  <entry>
    <title>051 传输层 —— TCP（上）</title>
    <link href="https://www.minbit.top/posts/42057.html"/>
    <id>https://www.minbit.top/posts/42057.html</id>
    <published>2025-09-20T04:00:00.000Z</published>
    <updated>2025-10-03T04:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="传输层-——-TCP（上）"><a href="#传输层-——-TCP（上）" class="headerlink" title="传输层 —— TCP（上）"></a>传输层 —— TCP（上）</h1><blockquote><p><a href="https://www.bilibili.com/video/BV1WT6SYXE2S/?share_source=copy_web&vd_source=872e5e3ccf44874c39edaf42e30ab0de">你管这破玩意叫 TCP？| B 站（荐）</a></p><p><a href="https://blog.csdn.net/chenlong_cxy/article/details/125234768">传输层协议 ——— TCP 协议 | CSDN</a></p><p><a href="https://blog.csdn.net/weixin_51142926/article/details/143895259">Linux：TCP 保证可靠性的方案（1）| CSDN</a></p></blockquote><h2 id="1-传输控制协议"><a href="#1-传输控制协议" class="headerlink" title="1. 传输控制协议"></a>1. 传输控制协议</h2><h3 id="1-TCP-的本质：传输控制协议-——-“控制”二字是灵魂"><a href="#1-TCP-的本质：传输控制协议-——-“控制”二字是灵魂" class="headerlink" title="1. TCP 的本质：传输控制协议 —— “控制”二字是灵魂"></a>1. TCP 的本质：传输控制协议 —— “控制”二字是灵魂</h3><blockquote><p>TCP 全称 <strong>Transmission Control Protocol（传输控制协议）</strong> —— 人如其名，它的核心职责不是“传输数据”，而是 <strong>对数据的传输过程进行精细、动态、可靠的控制</strong>。</p></blockquote><p>我们平时调用的 <code>write</code>、<code>send</code>、<code>read</code>、<code>recv</code> 等函数，要么将用户缓冲区的内容拷贝到发送缓冲区，要么将接受缓冲区的内容拷贝到用户缓冲区进行处理，本质上都是 <strong>缓冲区拷贝函数</strong>：</p><ul><li><code>send/write</code> → 将用户缓冲区数据拷贝到内核的 <strong>TCP 发送缓冲区</strong>。</li><li><code>recv/read</code> → 将内核的 <strong>TCP 接收缓冲区</strong> 数据拷贝到用户缓冲区。</li></ul><p>通过 TCP 协议控制网络传输，将可靠性数据从一台主机的发送缓冲区安全地交付到另一台主机的接收缓冲区，要求数据原封不动的发送过去，所谓发送，本质上是一种也是一种跨网络的拷贝！其本质就是不断把数据放到网络中。而数据何时发送？发多少？丢包后怎么重传？拥塞时怎么降速？乱序时怎么重组？—— 这些全部由 <strong>TCP 协议栈自主决策</strong>，应用程序完全无感知！当然，对方也可以对我们发送，因为 TCP 是全双工的，有自己的发送缓冲区和接受缓冲区！</p><h3 id="2-TCP-和文件系统的关联？——-“一切皆文件”的完美体现"><a href="#2-TCP-和文件系统的关联？——-“一切皆文件”的完美体现" class="headerlink" title="2. TCP 和文件系统的关联？—— “一切皆文件”的完美体现"></a>2. TCP 和文件系统的关联？—— “一切皆文件”的完美体现</h3><p>在 Linux 中，<strong>文件 I&#x2F;O 和网络 I&#x2F;O 在抽象层面高度统一</strong>，都遵循“缓冲区 → 内核 → 硬件”的模型：</p><table><thead><tr><th>对比</th><th>文件 I&#x2F;O</th><th>网络 I&#x2F;O (TCP)</th></tr></thead><tbody><tr><td>用户调用</td><td><code>write(fd, buf, len)</code></td><td><code>send(sockfd, buf, len, 0)</code></td></tr><tr><td>数据去向</td><td>内核页缓存（Page Cache）</td><td>TCP 发送缓冲区</td></tr><tr><td>最终目标</td><td>磁盘（慢速设备）</td><td>网卡（远程主机，更慢+不可靠）</td></tr><tr><td>刷新时机</td><td>缓冲区刷到磁盘盘由 OS 决定</td><td>由 TCP 协议决定（如窗口、拥塞控制）</td></tr><tr><td>出错处理</td><td>磁盘错误罕见、概率极低，通常忽略</td><td>文件需经过网络，需要有 TCP 来确保可靠性</td></tr></tbody></table><p><strong>核心思想</strong>：</p><ul><li>“文件”是本地存储的抽象，“Socket”是远程通信的抽象 —— 但它们在 I&#x2F;O 模型、缓冲区管理、阻塞&#x2F;非阻塞行为上高度一致。</li><li>这就是 <strong>“Linux 一切皆文件”</strong> 的哲学体现 —— 统一接口，统一缓冲，统一调度，只是底层驱动不同。</li><li>补充：在 Linux 中，socket 也有文件描述符（fd），也能用 <code>read/write</code>，也能设置 <code>O_NONBLOCK</code>，也能被 <code>select/poll/epoll</code> 监控 —— 完全兼容文件接口！</li></ul><h3 id="3-不考虑可靠性，数据在网络中如何流动？"><a href="#3-不考虑可靠性，数据在网络中如何流动？" class="headerlink" title="3. 不考虑可靠性，数据在网络中如何流动？"></a>3. 不考虑可靠性，数据在网络中如何流动？</h3><p>我们想要发送一个网络数据，先在应用层通过相关的协议对结构化数据做序列化，然后放到发送缓冲区中，然后 TCP 会帮我们在适当的时机把数据发送到对方的接收缓冲区，等待对方的应用层通过 read 读取。此时一般会出现两种情况：</p><ol><li><strong>接收方处理慢 → 数据堆积在接收缓冲区：</strong> 对方上层由于忙碌始终无法处理，使得多次发送的报文都堆积在接收缓冲区，当他不忙碌时可能一次 read 就都读上去了！！然后上层再需要对这些数据解析成一个个完整报文（因为是面向字节流的），然后反序列化成结构化数据供上层使用。而如果凑不齐一个报文，就将他们暂时存储在自己的用户层缓冲区，等下次 read 的时候如果凑齐了再一起拿出来解析。</li><li><strong>发送方不发 &#x2F; 网络拥塞 → 接收方 <code>recv</code> 阻塞：</strong> 对方的上层会在合适的时机进行 read，但是如果发送方始终没有发送，或者网络太拥堵导致接收缓冲区一直没有数据，那么 read 就会阻塞住，然后 OS 就会把这个进程设置为 S（Sleep） 状态，而当缓冲区有数据的时候（也就是说 OS 某些资源就绪的时候）OS 会再次调度这个进程去把数据从缓冲区读上来！！！</li></ol><p>所以以前我们觉得 OS 某些资源不就绪从而使得进程暂时进入 S 状态大多数指的是硬件的速度比较慢，所以需要等待硬件资源就绪，但是今天我们发现在网络的情况中，也有可能是因为对方始终不给你发数据，或者由于网络拥塞造成接收缓冲区没有数据可处理，也是属于资源不就绪的情况，此时调用 read 的这个进程就必须阻塞住！！</p><blockquote><p>“资源不就绪”不仅指本地硬件（磁盘、键盘），也包括 <strong>远程资源（网络数据未到达）</strong>。网络 I&#x2F;O 的“等待”，本质是等待 <strong>不可控的外部世界</strong> —— 这是分布式系统复杂性的根源。</p></blockquote><h3 id="4-为什么-UDP-无发送缓冲区，而-TCP-必须有？"><a href="#4-为什么-UDP-无发送缓冲区，而-TCP-必须有？" class="headerlink" title="4. 为什么 UDP 无发送缓冲区，而 TCP 必须有？"></a>4. 为什么 UDP 无发送缓冲区，而 TCP 必须有？</h3><blockquote><p>UDP 发了就是发了，他并不关心对方的接收缓冲区是不是满了，如果满了他就会丢包，此时我们是无感的，UDP 不保证可靠性，但是 TCP 需要保证可靠性啊！</p></blockquote><p>核心区别在于：<strong>可靠性保证</strong>。</p><ol><li><strong>UDP</strong>：直接把数据交给 IP 层发出，发完就不管了，对方收没收到、接收缓冲区满不满，它都不关心，应用层必须自己处理丢包、乱序等问题。</li><li><strong>TCP</strong>：必须保证数据可靠送达，所以发送缓冲区是必不可少的：<ol><li><strong>暂存应用层写入的数据</strong>，等对方确认 ACK 后再清除。</li><li><strong>应对对方接收缓冲区不足</strong>：对方的窗口大小会告诉你“我还能收多少”，如果满了，就得把数据先留在发送缓冲区。</li><li><strong>应对网络抖动</strong>：丢包或超时重传时，也得从发送缓冲区里重新取出数据再发。</li></ol></li></ol><p>如果没有发送缓冲区：应用层写的数据就会“丢在半路”，因为网络或接收方不可能一直实时响应，那就完全无法做到“可靠传输”。</p><h3 id="5-TCP-小结-——-一个“智能缓冲区控制器”"><a href="#5-TCP-小结-——-一个“智能缓冲区控制器”" class="headerlink" title="5. TCP 小结 —— 一个“智能缓冲区控制器”"></a>5. TCP 小结 —— 一个“智能缓冲区控制器”</h3><table><thead><tr><th>层面</th><th>TCP 的角色</th></tr></thead><tbody><tr><td>对应用层</td><td>提供“可靠字节流”抽象，屏蔽网络复杂性</td></tr><tr><td>对内核</td><td>管理发送&#x2F;接收缓冲区，实现流量&#x2F;拥塞控制</td></tr><tr><td>对网络</td><td>动态调整发送策略，对抗丢包、延迟、乱序</td></tr><tr><td>对哲学</td><td>体现“控制”本质 —— 不是搬运工，而是调度大师</td></tr></tbody></table><blockquote><p><strong>TCP 不是“管道”，而是“智能调度器 + 缓冲区管理器 + 错误恢复引擎”，它让不可靠的网络，看起来像“可靠的本地内存拷贝”。</strong></p></blockquote><h2 id="2-协议段格式"><a href="#2-协议段格式" class="headerlink" title="2. 协议段格式"></a>2. 协议段格式</h2><h3 id="1-TCP-的协议段格式"><a href="#1-TCP-的协议段格式" class="headerlink" title="1. TCP 的协议段格式"></a>1. TCP 的协议段格式</h3><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250912191940636.png" alt="PixPin_2025-09-12_19-18-58"></p><p>这依然是一个 <strong>逻辑结构图</strong>，仅用来表示 TCP 首部中各字段的位置、大小和含义。实际传输时，TCP 数据是 <strong>连续的字节流</strong>，按顺序排列在 IP 包中。</p><blockquote><p>在物理传输层面，无论是 TCP 还是 UDP，数据最终都以字节流（比特流）的形式在网络介质中传输。 </p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250912200616461.png" alt="PixPin_2025-09-12_20-06-11"></p><h3 id="2-逐字段详解（重要）"><a href="#2-逐字段详解（重要）" class="headerlink" title="2. 逐字段详解（重要）"></a>2. 逐字段详解（重要）</h3><h4 id="1-16-位源端口号-目的端口号（各-16-位，共-2-2-4-字节）"><a href="#1-16-位源端口号-目的端口号（各-16-位，共-2-2-4-字节）" class="headerlink" title="1. 16 位源端口号 &amp; 目的端口号（各 16 位，共 2+2 &#x3D; 4 字节）"></a>1. 16 位源端口号 &amp; 目的端口号（各 16 位，共 2+2 &#x3D; 4 字节）</h4><p><strong>作用：标识通信双方的应用程序，用途：实现多路复用，一台主机同时跑多个 TCP 连接。</strong></p><ul><li><p><strong>源端口</strong>：发送方的应用使用的端口（如客户端随机端口 54321）。</p></li><li><p><strong>目的端口</strong>：接收方应用监听的端口（比如 HTTP 默认 80，HTTPS 默认 443）。</p></li><li><p><strong>示例：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">客户端 (192.168.1.100:54321) → 服务器 (192.168.1.1:80)</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-32-位序号（4-字节）"><a href="#2-32-位序号（4-字节）" class="headerlink" title="2. 32 位序号（4 字节）"></a>2. 32 位序号（4 字节）</h4><p><strong>作用：给每个字节编号，实现可靠传输、排序、重传，从而保证数据能按顺序组装。</strong> TCP 是 <strong>字节流协议</strong>，不是像 UDP 那样一包一包，发出去的每个字节在字节流里都有编号。</p><ul><li>每个字节都有一个唯一的序号。</li><li>初始值（ISN）由系统随机生成，防止攻击。</li><li>发送时递增，接收方根据序号判断是否乱序或丢失。</li><li>示例：<ul><li>第一个包序号 &#x3D; 1000，载荷 100 字节 → 下一个包序号 &#x3D; 1100</li><li>接收方收到后，会检查序号是否连续，否则要求重传。</li></ul></li></ul><h4 id="3-32-位确认序号（4-字节）"><a href="#3-32-位确认序号（4-字节）" class="headerlink" title="3. 32 位确认序号（4 字节）"></a>3. 32 位确认序号（4 字节）</h4><p><strong>作用：告诉对方“我下一个想收到的字节号”。</strong> 只有当 ACK 标志位为 1 时有效，用于确认对方已成功接收数据。举例：如果确认号 &#x3D; 2001，说明我已经收到对方 <strong>2000 号字节</strong> 之前的所有数据，期待下一个是 2001。这是 <strong>可靠传输</strong> 的核心机制：发送方根据确认号判断数据是否成功送达。示例：</p><ul><li>A 发送了序号 1000~1099 的数据（100 字节）</li><li>B 收到后，回复 ACK &#x3D; 1100，表示“我收到了 1000~1099，期待下一个是 1100”。提示：示例中 “ACK &#x3D; 1100” 里的 1100 是 <strong>确认序号</strong>，不是 ACK 标志位的值。只有当 ACK 标志位为 1 时，确认序号才有效，这里默认 ACK 标志位为 1，表明已收到序号 1100 之前的所有数据。</li></ul><h4 id="4-4-位首部长度（4-位-0-5-字节）"><a href="#4-4-位首部长度（4-位-0-5-字节）" class="headerlink" title="4. 4 位首部长度（4 位 0.5 字节）"></a>4. 4 位首部长度（4 位 0.5 字节）</h4><p>表示 TCP 首部的长度（<strong>以 32 位即 4 字节为单位</strong>）。最小是 5，单位：<strong>以 4 字节为 1 个单位</strong>（即 4*5 &#x3D; 20 字节），因为基本首部固定就是 20 字节。提示：这里单位可能有点不好理解，多读两遍即可。</p><ul><li>范围：5 ~ 15（即 20 ~ 60 字节）。</li><li>最小值 5 → 20 字节（无选项）。</li><li>如果有选项，首部就会变长，从而大于 5，比如三次握手时常见的 MSS 选项。</li></ul><h4 id="5-保留字段（6-位-0-75-字节，了解）"><a href="#5-保留字段（6-位-0-75-字节，了解）" class="headerlink" title="5. 保留字段（6 位 0.75 字节，了解）"></a>5. 保留字段（6 位 0.75 字节，了解）</h4><p>必须设为 0，供未来扩展。</p><h4 id="6-6-个标志位（0-75-字节）"><a href="#6-6-个标志位（0-75-字节）" class="headerlink" title="6. 6 个标志位（0.75 字节）"></a>6. 6 个标志位（0.75 字节）</h4><p>这是 TCP 中最核心的部分之一，控制连接建立、释放和数据传输：</p><table><thead><tr><th>标志</th><th>全称</th><th>含义&#x2F;作用</th><th>常见场景</th></tr></thead><tbody><tr><td><strong>URG</strong></td><td>Urgent</td><td><strong>紧急指针有效</strong>，表示报文中有紧急数据，接收方要 <strong>优先</strong> 处理这部分数据（跳过普通队列）</td><td><strong>几乎不用</strong>，现在应用层自己处理优先级</td></tr><tr><td><strong>ACK</strong></td><td>Acknowledgment</td><td><strong>确认序号是否有效</strong>（几乎总是 1），表明报文头的 <code>ack</code> 字段生效，用于确认收到对方的数据或请求，建立连接之后几乎所有报文都带 ACK</td><td>三次握手、数据传输、四次挥手全过程</td></tr><tr><td><strong>PSH</strong></td><td>Push</td><td>推送数据，提示接收方立即交给应用层，即提示接收端应用程序立刻从 TCP 缓冲区把数据读走，不要等缓冲区填满再交付</td><td><strong>偶尔用</strong>，Telnet、SSH、交互式应用（实时输入 → 实时输出）</td></tr><tr><td><strong>RST</strong></td><td>Reset</td><td>强制断开异常连接，或拒绝无效请求，对方会要求重新建立连接，我们把携带 RST 标识的称为 <strong>复位报文段</strong></td><td>端口未监听时回应、异常关闭、攻击防御</td></tr><tr><td><strong>SYN</strong></td><td>Synchronize</td><td>用于同步序号，<strong>请求建立连接，同时传递初始序列号</strong>，发起连接时置 1。同时，我们把携带 SYN 标识的称为 <strong>同步报文段</strong></td><td>三次握手的第 1 步和第 2 步</td></tr><tr><td><strong>FIN</strong></td><td>Finish</td><td><strong>请求关闭连接</strong>，表示本端数据发完了，准备断开</td><td>四次挥手的第 1 步和第 3 步</td></tr></tbody></table><blockquote><p><strong>特别重要：三次握手（SYN, SYN+ACK, ACK）和四次挥手（FIN, ACK, FIN, ACK）都依赖这些标志位！</strong></p></blockquote><h4 id="7-16-位窗口大小（2-字节）"><a href="#7-16-位窗口大小（2-字节）" class="headerlink" title="7. 16 位窗口大小（2 字节）"></a>7. 16 位窗口大小（2 字节）</h4><p>作用：告诉对方“我还能接收多少字节的数据”（单位：字节）。比如：窗口 &#x3D; 3000，说明“从我期望的确认号开始，我还能接收 3000 个字节”。这样，发送方就不会把数据塞爆接收方的缓冲区，直到收到新窗口通知。</p><ul><li>这是 TCP <strong>流量控制</strong> 的关键，防止发送方过快导致接收方缓冲区溢出。</li><li>动态变化：接收方每收到数据，就更新窗口大小并回传。</li></ul><h4 id="8-16-位检验和（2-字节，了解）"><a href="#8-16-位检验和（2-字节，了解）" class="headerlink" title="8. 16 位检验和（2 字节，了解）"></a>8. 16 位检验和（2 字节，了解）</h4><p>对整个 TCP 段（包括伪首部、首部、数据）进行校验。检测传输错误，若检验和不匹配，丢弃该报文。</p><blockquote><p><strong>注意：TCP 检验和是 必须计算的，而 UDP 检验和是可选的。</strong></p></blockquote><h4 id="9-16-位紧急指针（2-字节）"><a href="#9-16-位紧急指针（2-字节）" class="headerlink" title="9. 16 位紧急指针（2 字节）"></a>9. 16 位紧急指针（2 字节）</h4><p>搭配 URG 标志使用，仅当 URG 标志位为 1 时有效，用于指出本报文中紧急数据的最后一个字节位置。现代应用几乎不用，简单了解就好。示例：序号 &#x3D; 1000，紧急指针 &#x3D; 5 → 紧急数据从 1000 到 1005。</p><h4 id="10-选项（了解）"><a href="#10-选项（了解）" class="headerlink" title="10. 选项（了解）"></a>10. 选项（了解）</h4><p>可变长度，最多 40 字节（总首部最大 60 字节）。常见选项：</p><ul><li><strong>MSS（Maximum Segment Size）</strong>：最大报文段长度，协商双方最大发送大小。</li><li><strong>SACK（Selective ACK）</strong>：选择性确认，提高重传效率。</li><li><strong>Timestamps</strong>：时间戳，用于 RTT 测量和防重放。</li><li><strong>NOP</strong>：填充用，保持对齐。</li></ul><h4 id="11-数据（了解）"><a href="#11-数据（了解）" class="headerlink" title="11. 数据（了解）"></a>11. 数据（了解）</h4><p>紧跟在首部之后，长度由 <code>IP 总长度 - IP 首部长度 - TCP 首部长度</code> 决定，由上层应用（如 HTTP、FTP）提供。</p><p>你这四个问题其实正好把 <strong>TCP 报文头的关键设计思想</strong> 给串起来了，我帮你捋清楚。</p><hr><h3 id="3-TCP-报头如何分离数据？"><a href="#3-TCP-报头如何分离数据？" class="headerlink" title="3. TCP 报头如何分离数据？"></a>3. TCP 报头如何分离数据？</h3><blockquote><p><strong>先读 20 字节 → 再看首部长度 → 根据首部长度决定选项大小 → 剩下的就是数据。</strong></p></blockquote><ol><li><strong>第一步：读取前 20 字节（最小头部）。</strong> 固定部分：TCP 报头最短 <strong>20 字节</strong>，这部分字段顺序固定（源端口、目的端口、序号、确认号…）。</li><li><strong>第二步：解析“首部长度”字段。</strong> 在这 20 个字节里，有一个 <strong>首部长度字段</strong>，它是 4 位，单位是 <strong>32 bit（4 字节）</strong>。提示：这里 4 位是二进制数，最小值是 0101（即十进制的 5），表示 5 个 4 字节，5 × 4 &#x3D; 20 字节。<ul><li>如果首部长度 &#x3D; 5，表示 5 × 4 &#x3D; 20 字节 → 没有选项，只有固定部分。</li><li>如果首部长度 &#x3D; 6，表示 6 × 4 &#x3D; 24 字节 → 有 4 字节选项。</li></ul></li><li><strong>第三步：跳过头部，剩余部分就是“数据”。</strong><ul><li>数据起始位置 &#x3D; <code>IP 数据报起始位置 + IP 头部长度 + TCP 头部长度</code></li><li>数据长度 &#x3D; <code>IP 总长度 - IP 头部长度 - TCP 头部长度</code></li></ul></li></ol><p>和 UDP 类似，区别在于 UDP 的报头固定 8 字节，而且直接有个字段长度，所以简单粗暴。TCP 因为要扩展功能，才搞了个“首部长度 + 选项”的自描述方式。有了“自描述头部长度”，然后从 IP 层“借”总长度来推算数据长度。 </p><h3 id="4-如何交付给上层？"><a href="#4-如何交付给上层？" class="headerlink" title="4. 如何交付给上层？"></a>4. 如何交付给上层？</h3><p>TCP 用 <strong>端口号</strong> 来做区分。每个进程通过 <strong>套接字 (socket &#x3D; IP + 端口)</strong> 来绑定通信，报文里的 <strong>源端口 &#x2F; 目的端口</strong> 就告诉内核：</p><ul><li>这是谁发的？（源端口）</li><li>应该交给哪个进程？（目的端口）</li></ul><p>所以 TCP 收到数据后，靠目的端口查路由表 → 找到本机监听该端口的进程 → 把数据放进它的接收缓冲区 → 应用层再 <code>read()</code>。</p><h3 id="5-关于-16-位校验和"><a href="#5-关于-16-位校验和" class="headerlink" title="5. 关于 16 位校验和"></a>5. 关于 16 位校验和</h3><p>TCP 校验和不光包含 TCP 头和数据，还要算上一个 <strong>伪首部</strong>，里面有源 IP、目的 IP、协议号等字段。</p><p><strong>为什么要多此一举？</strong><br>因为要防止“<strong>收到了正确的数据，但收错了目的地</strong>”这种事。伪首部相当于再确认一次，这数据确实是发给我的。</p><blockquote><p><strong>TCP 校验和覆盖范围 &#x3D; TCP 头 + TCP 数据 + 伪首部，如果校验失败，接收方直接丢掉报文，不给上层进程。</strong></p></blockquote><h3 id="6-为什么-TCP-报头没有长度字段？"><a href="#6-为什么-TCP-报头没有长度字段？" class="headerlink" title="6. 为什么 TCP 报头没有长度字段？"></a>6. 为什么 TCP 报头没有长度字段？</h3><p>这个设计正是因为 <strong>TCP 面向字节流</strong>。UDP 是 <strong>面向报文</strong>，一发就是一块，必须告诉你这块有多长 → 所以有 <code>length</code>。TCP 把数据看作一个 <strong>连续的字节流</strong>，应用层想写多少就写多少，内核可能拆成多个报文段发出去。接收方只管把这些字节按顺序拼接起来。</p><p>对 TCP 来说，<strong>什么时候算一条完整的消息</strong>，由应用层自己决定。所以 TCP 报头里没必要放 “长度”字段，只需要：</p><ul><li>知道首部多长（方便找到数据起点）；</li><li>知道数据流的位置（靠序号 <code>seq</code> 字段来标记每个字节）。</li></ul><blockquote><ul><li><strong>UDP</strong>：像快递小哥，一单一单送，包裹上贴着“这是一个 2kg 的包裹”，所以每个报文都带长度。</li><li><strong>TCP</strong>：像水管输水，不管你倒一桶还是倒十桶，水流不断过去。水分段传输，但水的“总量”是靠序号控制的，不需要每次标记“这一桶多大”。</li></ul></blockquote><h3 id="7-TCP-连接建立可能失败"><a href="#7-TCP-连接建立可能失败" class="headerlink" title="7. TCP 连接建立可能失败"></a>7. TCP 连接建立可能失败</h3><p>TCP 虽然保证 <strong>已建立连接后的数据传输可靠性</strong>，但 <strong>连接建立过程本身可能失败</strong>。三次握手过程中任何一个步骤出现问题都会导致连接失败：</p><ol><li><strong>第一次握手失败</strong>：客户端 SYN 包丢失或被防火墙过滤。</li><li><strong>第二次握手失败</strong>：服务器 SYN-ACK 包丢失。</li><li><strong>第三次握手失败</strong>：客户端 ACK 包丢失。</li></ol><h3 id="8-连接怎样才算成功建立？"><a href="#8-连接怎样才算成功建立？" class="headerlink" title="8. 连接怎样才算成功建立？"></a>8. 连接怎样才算成功建立？</h3><p>TCP 连接的“成功建立”需要 <strong>双方都进入 ESTABLISHED 状态</strong>，但客户端和服务器进入该状态的时机不同：</p><ol><li><strong>客户端视角：</strong> 在收到服务器的 SYN-ACK 后，立即发送 ACK，并 <strong>同时进入 ESTABLISHED 状态</strong>。此时即使该 ACK 报文后续丢失，<strong>客户端仍认为连接已建立</strong>，可立即发送数据。</li><li><strong>服务器视角：</strong> 必须 <strong>实际收到客户端的 ACK</strong>（第三次握手）后，才从 SYN-RCVD 状态转入 ESTABLISHED 状态，认为连接真正建立。</li></ol><blockquote><p>  <strong>因此，只有当双方都进入 ESTABLISHED 状态时，TCP 连接才算完全成功建立。</strong><br>  若第三次握手丢失，服务器会重传 SYN-ACK（最多 <code>tcp_synack_retries</code> 次，一般默认 5 次），若仍无响应则放弃连接；而客户端若已发送数据，服务器在收到数据时也可推断连接应已建立，从而完成状态转换（这是 TCP 的优化机制之一）。 </p></blockquote><h2 id="3-确认应答（ACK）机制"><a href="#3-确认应答（ACK）机制" class="headerlink" title="3. 确认应答（ACK）机制"></a>3. 确认应答（ACK）机制</h2><p><strong>TCP 的确认应答机制就是：接收方通过 ACK 告诉发送方“到某个字节为止我都收到了，下一个字节从这里开始发”，发送方据此判断哪些数据已经成功送达、哪些需要重传，从而保证数据传输的可靠性和有序性。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250912232946880.png" alt="PixPin_2025-09-12_23-29-42"></p><p>TCP 将每个字节的数据都做了编号，即为序列号。每一个 ACK 都带有对应的确认序列号，意思是告诉发送者，我已经收到了哪些数据，下一次你从哪里开始发。</p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250912233052792.png" alt="image-20250912233052654"></p><h2 id="4-超时重传机制"><a href="#4-超时重传机制" class="headerlink" title="4. 超时重传机制"></a>4. 超时重传机制</h2><p>TCP 的超时重传机制是为了在网络不可靠的环境中确保数据可靠传输而设计的重要机制。其核心思想是：<strong>当发送方（如主机 A）发送数据后，若在一定时间内未收到接收方（如主机 B）返回的确认应答（ACK），就认为该数据可能丢失，从而触发重传。</strong> ACK 没收到，可能是因为数据包丢了，也可能是 ACK 自己丢了。TCP 通过 <strong>序列号</strong> 来识别重复数据，避免重复交付。</p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20251003000427268.png"></p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20251003000510790.png" alt="PixPin_2025-10-03_00-05-06"></p><p>由于网络状况动态变化，固定的超时时间难以适应所有场景：设得太短会导致不必要的重复重传，浪费带宽；设得太长则会降低传输效率。因此，TCP 采用 <strong>动态调整的超时时间</strong>，并结合 <strong>指数退避策略</strong> 来平衡效率与可靠性。具体机制如下：</p><ol><li><p><strong>基于序列号去重</strong>：接收方利用 TCP 报文中的序列号识别重复数据包，自动丢弃重复内容，确保数据不被重复处理。</p></li><li><p><strong>初始超时时间</strong>：系统通常以 500 毫秒（0.5 秒）为基本单位（如 Linux、BSD、Windows 等），首次重传的超时时间设为 500ms 的整数倍。</p></li><li><p><strong>指数退避（Exponential Backoff）</strong>：若重传后仍未收到 ACK，则下一次重传的等待时间按指数增长，例如：</p><ul><li>第 1 次重传：等待 1 × 500ms</li><li>第 2 次重传：等待 2 × 500ms</li><li>第 3 次重传：等待 4 × 500ms</li><li>第 4 次重传：等待 8 × 500ms</li><li>以此类推（即每次重传间隔翻倍）。</li></ul></li><li><p><strong>重传上限</strong>：当重传次数达到系统设定的阈值（如 Linux 默认约 15 次），TCP 会判定连接异常（如网络中断或对端宕机），主动终止连接。</p></li></ol><p>通过这种动态、自适应的超时重传机制，TCP 便能在各种网络环境下 <strong>兼顾传输的可靠性与效率</strong>。</p><h2 id="5-连接管理机制"><a href="#5-连接管理机制" class="headerlink" title="5. 连接管理机制"></a>5. 连接管理机制</h2><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20251003000535741.png" alt="PixPin_2025-10-03_00-05-33"></p><h3 id="1-TCP-是“面向连接”的协议"><a href="#1-TCP-是“面向连接”的协议" class="headerlink" title="1. TCP 是“面向连接”的协议"></a>1. TCP 是“面向连接”的协议</h3><p><strong>什么是“面向连接”：</strong> TCP 不是直接在两台主机之间通信，而是在 <strong>两个端点（socket）之间建立一条虚拟的、可靠的逻辑通道</strong>，这条通道称为“连接”。  每个连接由 <strong>四元组</strong> 唯一标识：<code>(源IP, 源端口, 目标IP, 目标端口)</code>，一台服务器可以同时与多个客户端建立多个独立的 TCP 连接。</p><p><strong>为什么需要“连接”：</strong> 如果没有连接的概念，服务器只有一个全局接收缓冲区，所有客户端的数据都会混在一起，无法区分来源，也无法保证顺序、可靠性等。<strong>连接的存在，使得每个通信对都有独立的发送&#x2F;接收缓冲区、序列号、窗口、状态等</strong>，从而实现可靠传输。</p><blockquote><p><strong>结论</strong>：TCP 的所有可靠性机制（如重传、确认、流量控制、拥塞控制）都是 <strong>基于连接</strong> 的，而不是主机到主机的。</p></blockquote><h3 id="2-操作系统如何管理-TCP-连接？"><a href="#2-操作系统如何管理-TCP-连接？" class="headerlink" title="2. 操作系统如何管理 TCP 连接？"></a>2. 操作系统如何管理 TCP 连接？</h3><p>OS 采用“<strong>先描述，再组织</strong>”的方式管理连接：</p><ul><li><p><strong>描述</strong>：用一个内核数据结构（如 <code>struct sock</code> 或 <code>TCB</code> – Transmission Control Block）来描述一个连接，包含：四元组信息、发送&#x2F;接收缓冲区、序列号、确认号、状态（LISTEN、ESTABLISHED、CLOSE_WAIT 等）、超时重传计时器、拥塞控制参数等。</p></li><li><p><strong>组织</strong>：将所有连接结构体组织成高效的数据结构（如哈希表、链表、红黑树，<strong>主要是采用分层 + 哈希 + 链表的混合结构</strong>），便于快速查找、插入、删除。</p></li><li><p><strong>建立连接</strong> &#x3D; 分配并初始化一个连接结构体 + 插入管理结构  。</p></li><li><p><strong>断开连接</strong> &#x3D; 从管理结构中移除 + 释放资源（缓冲区、内存等）。</p></li></ul><blockquote><p>⚠️ <strong>成本</strong>：每个连接都占用内存和 CPU 资源，因此高并发服务器需优化连接管理（如使用连接池、epoll 等）。</p></blockquote><h3 id="3-为什么建立连接需要“三次握手”？"><a href="#3-为什么建立连接需要“三次握手”？" class="headerlink" title="3. 为什么建立连接需要“三次握手”？"></a>3. 为什么建立连接需要“三次握手”？</h3><h4 id="1-一次握手行不行？"><a href="#1-一次握手行不行？" class="headerlink" title="1. 一次握手行不行？"></a>1. 一次握手行不行？</h4><p>如果客户端发 SYN → 服务器收到后直接认为连接建立？那么就会产生 <strong>问题</strong>：服务器无法确认客户端是否真的能收到自己的响应。如果 SYN 是旧的重复包（比如网络延迟很久后到达），服务器会错误地建立连接，浪费资源。</p><h4 id="2-两次握手行不行？"><a href="#2-两次握手行不行？" class="headerlink" title="2. 两次握手行不行？"></a>2. 两次握手行不行？</h4><ul><li>客户端发 SYN  </li><li>服务器回 SYN+ACK，认为连接已建立  </li><li>客户端收到后开始发数据</li></ul><p><strong>产生的问题</strong>：如果客户端的 SYN 丢失了 ACK（即服务器的 SYN+ACK 未被客户端收到），客户端不会重发，但服务器已经认为连接建立了，会一直等待数据 → <strong>资源浪费（SYN Flood 攻击原理）</strong>，更严重的是：<strong>服务器无法确认客户端是否具备接收能力</strong>。</p><blockquote><p><a href="https://www.cloudflare.com/zh-cn/learning/ddos/syn-flood-ddos-attack/">SYN 洪水攻击 | cloudflare</a></p><p><a href="https://info.support.huawei.com/info-finder/encyclopedia/zh/SYN+Flood.html">什么是 SYN Flood？| 华为云</a></p><p>服务器在处理 TCP 连接时维护两个关键队列：<strong>半连接队列</strong> 存放已收到客户端 SYN、回复了 SYN+ACK 但尚未收到最终 ACK 的“半连接”；<strong>全连接队列</strong> 则存放三次握手已完成、等待应用程序（如 Web 服务）调用 <code>accept()</code> 处理的“全连接”。当半连接因客户端未回 ACK 而超时、全连接队列溢出，或客户端与服务器对连接状态认知不一致时，就会出现 <strong>连接不一致问题</strong>，导致资源浪费甚至正常连接被拒绝。</p><p><strong>SYN 洪水（SYN Flood）</strong> 正是利用半连接队列的弱点：攻击者发送大量伪造源 IP 的 SYN 请求，却故意不回 ACK，使服务器堆积大量无效半连接，耗尽队列资源。为放大攻击效果，黑客通常操控大量被控制的“<strong><a href="https://baike.baidu.com/item/%E8%82%89%E6%9C%BA/956813">肉机</a></strong>”（即傀儡机）组成僵尸网络，协同发起攻击。2000 年初那种 “人多 → 肉机多，在浏览器上不断点刷新让服务器无响应” 的攻击，本质是早期简单的分布式拒绝服务（DDoS），虽和 SYN 洪水利用 TCP 漏洞的原理不同，但核心都是靠大量肉机（或真实用户设备）持续提升请求量，耗尽服务器的带宽、CPU、内存等资源，最终让服务器无法响应正常用户。</p></blockquote><h4 id="3-三次握手如何解决？"><a href="#3-三次握手如何解决？" class="headerlink" title="3. 三次握手如何解决？"></a>3. 三次握手如何解决？</h4><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20251003185009119.png" alt="PixPin_2025-10-03_18-49-58"></p><ol><li><strong>第一次</strong>：客户端证明自己能发</li><li><strong>第二次</strong>：服务器证明自己能收+能发</li><li><strong>第三次</strong>：客户端证明自己能收（确认收到服务器的 SYN）</li></ol><p><strong>三次握手确保了</strong>：</p><ul><li>双方都能收、能发（<strong>双向通信能力验证</strong>）</li><li><strong>防止历史重复连接请求造成错误建立</strong></li><li><strong>初始化双方的序列号（避免数据混淆）</strong></li></ul><blockquote><p><strong>三次是最小可靠次数</strong>：少于三次无法同时验证双向通信能力；多于三次则冗余。</p></blockquote><h4 id="4-三次握手绝对可靠吗？"><a href="#4-三次握手绝对可靠吗？" class="headerlink" title="4. 三次握手绝对可靠吗？"></a>4. 三次握手绝对可靠吗？</h4><p>在 <strong>正常网络</strong> 下，三次握手能可靠建立连接。但在极端情况，仍可能失败。不过 TCP 的设计目标是在 <strong>不可靠网络上提供可靠传输</strong>，三次握手是理论和实践平衡下的最优解。</p><h3 id="4-为什么断开连接需要“四次挥手”？"><a href="#4-为什么断开连接需要“四次挥手”？" class="headerlink" title="4. 为什么断开连接需要“四次挥手”？"></a>4. 为什么断开连接需要“四次挥手”？</h3><p>因为 TCP 是 <strong>全双工</strong> 的：数据可以同时双向传输。断开时，<strong>每个方向都要独立关闭</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20251003185056144.png" alt="PixPin_2025-10-03_18-50-53"></p><p><strong>为什么不能合并第 2、3 步？</strong></p><ul><li>第 2 步是 <strong>对客户端 FIN 的确认</strong>，必须立即响应（否则客户端会重传 FIN）。</li><li>第 3 步是 <strong>服务器主动发起关闭</strong>，但服务器可能还有数据要发送，不能立刻发 FIN。</li></ul><blockquote><p>所以：<strong>ACK 和 FIN 通常不能合并</strong>（除非服务器在收到 FIN 时恰好没有待发数据，此时可合并为一次：SYN+ACK 类似，但叫 FIN+ACK）。</p></blockquote><h3 id="5-套接字（Socket）、connect、accept-与三次握手的关系"><a href="#5-套接字（Socket）、connect、accept-与三次握手的关系" class="headerlink" title="5. 套接字（Socket）、connect、accept 与三次握手的关系"></a>5. 套接字（Socket）、connect、accept 与三次握手的关系</h3><h4 id="1-connect-的本质"><a href="#1-connect-的本质" class="headerlink" title="1. connect() 的本质"></a>1. connect() 的本质</h4><p>客户端调用 <code>connect()</code> → 触发 <strong>第一次握手（SYN）</strong>，内核自动完成后续两次握手，<code>connect()</code> 返回时，<strong>三次握手已完成，连接已建立（ESTABLISHED）</strong>。</p><h4 id="2-accept-的本质"><a href="#2-accept-的本质" class="headerlink" title="2. accept() 的本质"></a>2. accept() 的本质</h4><p>服务器调用 <code>listen()</code> 后进入监听状态，当收到客户端的 SYN（第一次握手），内核会为该连接创建一个 <strong>新的 socket 结构体</strong>（子 socket），<code>accept()</code> 的作用是：<strong>从已完成连接队列中取出这个新 socket，并返回给应用程序，注意：</strong> 三次握手在 <code>accept()</code> 调用 <strong>之前</strong> 就已完成！</p><blockquote><p><strong>关键结论：三次握手由操作系统内核自动完成，与应用程序是否调用 <code>accept()</code> 无关。即使服务器没有调用 <code>accept()</code>，只要 <code>listen()</code> 了，内核仍会响应 SYN，完成三次握手，并将连接放入“已完成队列”。如果 <code>accept()</code> 不及时调用，队列满后新连接会被拒绝（backlog 限制）。</strong></p></blockquote><h4 id="3-没有-accept-能建立-TCP-连接吗？"><a href="#3-没有-accept-能建立-TCP-连接吗？" class="headerlink" title="3. 没有 accept() 能建立 TCP 连接吗？"></a>3. 没有 accept() 能建立 TCP 连接吗？</h4><blockquote><p><a href="https://www.bilibili.com/video/BV1vF411M7Vi/?share_source=copy_web&vd_source=872e5e3ccf44874c39edaf42e30ab0de">没有 accept 方法，能建立 TCP 连接吗？| B 站</a></p></blockquote><p><strong>能</strong>！连接在内核层面已经建立（ESTABLISHED 状态）。但应用程序无法通过 <code>accept()</code> 获取该连接的 socket，也就无法读写数据。连接会一直占用内核资源，直到超时或被关闭。</p><h3 id="6-小结"><a href="#6-小结" class="headerlink" title="6. 小结"></a>6. 小结</h3><table><thead><tr><th>问题</th><th>回答</th></tr></thead><tbody><tr><td><strong>为什么 TCP 是面向连接的？</strong></td><td>为了隔离不同通信对，提供独立的可靠传输通道（缓冲区、序列号等）。</td></tr><tr><td><strong>操作系统如何管理连接？</strong></td><td>用结构体描述连接，用数据结构组织，增删查改即连接管理。</td></tr><tr><td><strong>为什么三次握手？</strong></td><td>最小次数验证双方收发能力，防止历史连接干扰。两次不够，一次更不行。</td></tr><tr><td><strong>三次握手绝对可靠吗？</strong></td><td>在常规网络下可靠，是工程与理论的最优平衡。</td></tr><tr><td><strong>为什么四次挥手？</strong></td><td>全双工需双向关闭，每方向关闭需 FIN+ACK。</td></tr><tr><td><strong>第 2、3 次挥手为何不能合并？</strong></td><td>服务器需先 ACK 客户端 FIN，再等自己数据发完才发自己的 FIN。</td></tr><tr><td><strong>connect&#x2F;accept 的本质？</strong></td><td><code>connect</code> 触发握手；<code>accept</code> 从内核队列取已建立的连接。</td></tr><tr><td><strong>没有 accept 能建立连接吗？</strong></td><td>能！三次握手由内核完成，<code>accept</code> 只是应用层获取连接句柄。</td></tr><tr><td><strong>连接建立成功和 accept 有关系吗？</strong></td><td><strong>无直接关系</strong>。连接在 <code>accept</code> 前已建立，<code>accept</code> 只是“领取”连接。</td></tr></tbody></table><hr><h2 id="6-理解-TIME-WAIT-状态"><a href="#6-理解-TIME-WAIT-状态" class="headerlink" title="6. 理解 TIME_WAIT 状态"></a>6. 理解 TIME_WAIT 状态</h2><h3 id="1-如何触发-TIME-WAIT？"><a href="#1-如何触发-TIME-WAIT？" class="headerlink" title="1. 如何触发 TIME_WAIT？"></a>1. 如何触发 TIME_WAIT？</h3><p>当 <strong>主动关闭连接的一方</strong>（即首先发送 <code>FIN</code> 的那一端）完成四次挥手的最后一步（发送最后一个 <code>ACK</code>）后，<strong>会进入 <code>TIME_WAIT</code> 状态</strong>，并持续一段时间（通常是 <strong>2MSL</strong>）。</p><blockquote><p>举例：客户端调用 <code>close()</code> → 发送 FIN → 最终进入 TIME_WAIT。</p></blockquote><h3 id="2-用-netstat-查看-TIME-WAIT"><a href="#2-用-netstat-查看-TIME-WAIT" class="headerlink" title="2. 用 netstat 查看 TIME_WAIT"></a>2. 用 <code>netstat</code> 查看 TIME_WAIT</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">netstat -nltp<span class="comment"># root</span></span><br><span class="line">netstat -an | grep TIME_WAIT</span><br><span class="line"><span class="comment"># 或更详细</span></span><br><span class="line">ss -tan state time-wait</span><br></pre></td></tr></table></figure><h3 id="3-2MSL-是什么？"><a href="#3-2MSL-是什么？" class="headerlink" title="3. 2MSL 是什么？"></a>3. 2MSL 是什么？</h3><p>MSL（Maximum Segment Lifetime）表示 TCP 报文在网络中 <strong>最大存活时间</strong>（通常为 30~120 秒，Linux 中 MSL 默认 <strong>30 秒</strong>），超过 MSL 的报文会被路由器丢弃。</p><p><strong>TIME_WAIT &#x3D; 2MSL 是 TCP 可靠关闭的保障机制，即：2MSL &#x3D; 2 × MSL</strong></p><ul><li>TIME_WAIT 的持续时间 &#x3D; <strong>2MSL</strong>（Linux 默认 <strong>2×30 &#x3D; 60 秒</strong>）。</li><li><strong>目的有两个</strong>：<ol><li><strong>确保最后一个 ACK 能到达对方：</strong> 如果 ACK 丢失，对方会重发 FIN，本端仍处于 TIME_WAIT 可再次响应 ACK，避免对方 stuck 在 LAST_ACK。</li><li><strong>防止旧连接的“迷途报文”干扰新连接：</strong> 等待 2MSL 后，网络中所有属于该连接的旧报文都已消失，此时即使复用相同四元组（如快速重启服务），也不会混淆数据。</li></ol></li></ul><blockquote><p><strong><code>tcp_fin_timeout</code> 可以控制 FIN_WAIT_2 状态的超时时间（即本端发了 FIN，对方 ACK 了，但对方迟迟不发自己的 FIN）。但它不影响 TIME_WAIT 的持续时间 TIME_WAIT 的时长仅由 2MSL 决定，在 Linux 中硬编码为 60 秒（不可通过 sysctl 直接修改）。</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="built_in">cat</span> /proc/sys/net/ipv4/tcp_fin_timeout  <span class="comment"># 默认 60（秒），影响 FIN_WAIT_2</span></span><br><span class="line">&gt;# TIME_WAIT 始终是 60 秒（2 * 30），不受此参数影响</span><br><span class="line">   </span><br><span class="line">&gt;<span class="built_in">echo</span> 30 &gt; /proc/sys/net/ipv4/tcp_fin_timeout<span class="comment"># 将 FIN_WAIT_2 时间缩短到 30 秒</span></span><br></pre></td></tr></table></figure><p>TIME_WAIT 虽不可改时长，但可优化其影响：使用 <code>SO_REUSEADDR</code>，避免服务器主动关闭连接（让客户端先 close），调整 <code>net.ipv4.tcp_max_tw_buckets</code>（限制 TIME_WAIT 数量，超限则提前清除）。</p></blockquote><h2 id="7-解决-TIME-WAIT-状态引起的-bind-失败的方法（作业）"><a href="#7-解决-TIME-WAIT-状态引起的-bind-失败的方法（作业）" class="headerlink" title="7. 解决 TIME_WAIT 状态引起的 bind 失败的方法（作业）"></a>7. 解决 TIME_WAIT 状态引起的 bind 失败的方法（作业）</h2><p>这是我们经常会遇到的一个问题：服务器程序（如 Web 服务）监听 <code>0.0.0.0:8080</code>，程序退出后立即重启 → 调用 <code>bind(8080)</code> 失败，会报错：<strong>Address already in use</strong>。</p><p><strong>原因：</strong></p><ol><li>上次连接由服务器主动关闭 → 服务器进入 TIME_WAIT。</li><li>TIME_WAIT 期间，<strong>四元组（特别是本地 IP+端口）仍被占用</strong>。</li><li>新程序尝试 <code>bind</code> 同一个端口 → 内核拒绝（默认不允许复用处于 TIME_WAIT 的地址）。</li></ol><p><strong>解决方法：使用 <code>SO_REUSEADDR</code> 选项（<code>man setsockopt</code>）</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> opt = <span class="number">1</span>;</span><br><span class="line">setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, <span class="keyword">sizeof</span>(opt));</span><br></pre></td></tr></table></figure><ul><li><strong>作用</strong>：允许新 socket 绑定到处于 TIME_WAIT 状态的地址&#x2F;端口。</li><li><strong>注意</strong>：<code>SO_REUSEADDR</code> <strong>不能复用 ESTABLISHED 状态的端口</strong>，只对 TIME_WAIT 有效。</li></ul><blockquote><p>这就是为什么几乎所有服务器程序在 <code>bind</code> 前都会设置 <code>SO_REUSEADDR</code>。</p></blockquote><h2 id="8-理解-CLOSE-WAIT-状态"><a href="#8-理解-CLOSE-WAIT-状态" class="headerlink" title="8. 理解 CLOSE_WAIT 状态"></a>8. 理解 CLOSE_WAIT 状态</h2><h3 id="1-如何进入-CLOSE-WAIT？"><a href="#1-如何进入-CLOSE-WAIT？" class="headerlink" title="1. 如何进入 CLOSE_WAIT？"></a>1. 如何进入 CLOSE_WAIT？</h3><p>对端（如客户端）发送 FIN → 本端（服务器）收到后，内核自动回复 ACK，此时本端 TCP 状态变为 <strong>CLOSE_WAIT，表示：对端已关闭，本端应尽快调用 <code>close()</code> 关闭自己的方向</strong>。</p><h3 id="2-CLOSE-WAIT-的问题"><a href="#2-CLOSE-WAIT-的问题" class="headerlink" title="2. CLOSE_WAIT 的问题"></a>2. CLOSE_WAIT 的问题</h3><p><strong>CLOSE_WAIT 本身是正常状态，但如果长期存在，说明应用程序忘记调用 <code>close()</code>！后果：</strong></p><ul><li>文件描述符泄漏。</li><li>内存泄漏（接收缓冲区不释放）。</li><li>最终耗尽系统资源，服务崩溃。</li></ul><h3 id="3-排查-CLOSE-WAIT"><a href="#3-排查-CLOSE-WAIT" class="headerlink" title="3. 排查 CLOSE_WAIT"></a>3. 排查 CLOSE_WAIT</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">netstat -an | grep CLOSE_WAIT</span><br><span class="line">lsof -p &lt;pid&gt;  <span class="comment"># 查看进程打开的 fd</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>根本解决</strong>：检查代码，确保在读到 EOF（recv 返回 0）后调用 <code>close()</code>。</p></blockquote>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;传输层-——-TCP（上）&quot;&gt;&lt;a href=&quot;#传输层-——-TCP（上）&quot; class=&quot;headerlink&quot; title=&quot;传输层 —— TCP（上）&quot;&gt;&lt;/a&gt;传输层 —— TCP（上）&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a</summary>
        
      
    
    
    
    <category term="Linux" scheme="https://www.minbit.top/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://www.minbit.top/tags/Linux/"/>
    
    <category term="网络" scheme="https://www.minbit.top/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>02 数据库基础</title>
    <link href="https://www.minbit.top/posts/6432.html"/>
    <id>https://www.minbit.top/posts/6432.html</id>
    <published>2025-09-15T16:00:00.000Z</published>
    <updated>2025-09-23T02:10:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据库基础"><a href="#数据库基础" class="headerlink" title="数据库基础"></a>数据库基础</h1><blockquote><p><a href="https://blog.csdn.net/chenlong_cxy/article/details/128055520">MySQL 数据库基础 | CSDN</a></p></blockquote><h2 id="1-什么是数据库？"><a href="#1-什么是数据库？" class="headerlink" title="1. 什么是数据库？"></a>1. 什么是数据库？</h2><p>数据库这个词，其实可以拆开来看：<strong>数据</strong> + <strong>库</strong>。库的意思就是“存放的地方”，数据库就是一个专门用来 <strong>高效存储、管理和操作数据</strong> 的系统。很多初学者会问：既然文件也能存数据，为什么还要数据库？答案就在于“<strong>管理和使用的便利性</strong>”。</p><blockquote><ol><li>mysql 是数据库服务的客户端。</li><li>mysqld 是数据库服务的服务器端。</li><li>mysql 本质：基于 C（mysql）S（mysqld）模式的一种网络服务。</li></ol><p>数据库本质：对数据内容存储的一套解决方案，我们给出字段或者要求，数据库直接给我们结果就行。</p></blockquote><h3 id="1-用文件存数据的局限"><a href="#1-用文件存数据的局限" class="headerlink" title="1. 用文件存数据的局限"></a>1. 用文件存数据的局限</h3><p>虽然文件也能存储数据（比如.txt、.csv、.cpp），但面对现代应用的需求，文件方式存在明显缺陷：</p><ol><li><strong>安全性差：</strong> 无完善的用户权限控制，数据容易被篡改或泄露。</li><li><strong>查询效率低：</strong> 每次查找都要遍历整个文件，数据量大时极慢。数据库则能用索引和优化算法做到毫秒级的查询。</li><li><strong>管理困难：</strong> 缺乏统一结构，难以维护数据一致性、完整性。文件本质是“死”的存储，而数据库提供“关系模型”，能管理表与表之间的联系。比如订单和用户数据能通过 <code>user_id</code> 关联。</li><li><strong>不支持并发：</strong> 多人同时读写容易冲突、数据错乱。</li><li><strong>扩展性差：</strong> 海量数据（比如 TB 级别）下文件系统难以支撑，IO 瓶颈严重。而数据库天生为大规模数据和高并发而优化。</li><li><strong>程序使用不方便：</strong> 开发者需手动处理锁、缓存、索引、事务等复杂逻辑。而数据库有标准的 SQL（结构化查询语言），用统一的接口即可完成增删改查。</li></ol><p>数据库正是为解决这些问题而生的：它提供 <strong>结构化存储、高效索引、事务支持、并发控制、权限管理、备份恢复等一整套成熟机制</strong>。所以，文件像是一个普通储物柜，而数据库更像是一个带标签、带检索系统、能自动归类、还能自动防盗和备份的智能档案馆。</p><h3 id="2-如何理解数据库？"><a href="#2-如何理解数据库？" class="headerlink" title="2. 如何理解数据库？"></a>2. 如何理解数据库？</h3><ul><li><strong>物理层面：</strong> 数据最终还是存在磁盘或内存中，但数据库通过自己的引擎优化读写。比如把热点数据（经常访问的）放到内存里，以加快访问速度。</li><li><strong>逻辑层面：</strong> 提供表、行、列、索引、视图等抽象，让开发者以“结构化方式”操作数据。</li><li><strong>系统层面：</strong> 是一个独立运行的服务（如 MySQL Server），提供标准接口（如 SQL）供程序调用。</li><li><strong>价值层面：</strong> 是现代信息系统的核心基础设施，是业务数据的“中枢神经”。</li></ul><blockquote><p>数据库水平是衡量程序员能力的一个重要指标 —— 因为几乎所有应用都离不开数据，而高效、稳定、安全地管理数据是硬功夫。 </p></blockquote><hr><h2 id="2-主流数据库"><a href="#2-主流数据库" class="headerlink" title="2. 主流数据库"></a>2. 主流数据库</h2><p>市面上数据库大体可以分为 <strong>关系型数据库（RDBMS）</strong> 和 <strong>非关系型数据库（NoSQL）</strong>，先看几个常见的：</p><table><thead><tr><th>数据库</th><th>特点</th></tr></thead><tbody><tr><td><strong>SQL Server</strong></td><td>微软出品，与 Windows&#x2F;.NET 生态深度集成，适合中大型企业项目，图形化管理工具强大，商业授权。</td></tr><tr><td><strong>Oracle</strong></td><td>企业级王者，功能强大、全面、稳定、适合 <strong>超大型复杂系统</strong>（如银行、电信），缺点：<strong>昂贵</strong>、并发处理上不如 MySQL，却在业务逻辑复杂时很强大。</td></tr><tr><td><strong>MySQL</strong></td><td>世界上使用最广、最流行的 <strong>开源</strong> 关系数据库，轻量、<strong>并发好</strong>、<strong>社区活跃</strong>，广泛用于 Web 应用（电商、SNS、论坛等）。</td></tr><tr><td><strong>PostgreSQL</strong></td><td>学术界起家，功能强大、标准兼容性好、支持 <strong>复杂查询和扩展</strong>，开源免费，学术和商业皆宜，被誉为“最接近 Oracle 的开源数据库”和“最先进的开源数据库”</td></tr><tr><td><strong>SQLite</strong></td><td>嵌入式数据库，零配置、单文件、<strong>极轻量</strong>，不依赖服务器，适合移动端、桌面程序、嵌入式设备。</td></tr><tr><td><strong>H2</strong></td><td>Java 开发的嵌入式数据库，纯内存或文件存储，常用于单元 <strong>测试</strong>、原型开发、<strong>小型 Java 项目</strong>。</td></tr></tbody></table><blockquote><ul><li><strong>关系型数据库：</strong> 用“表格”的方式存数据，数据之间通过关系（外键、约束）来管理，核心是 <strong>SQL</strong>。</li><li><strong>非关系型数据库：</strong> 不用固定表结构，数据可以是键值、文档、图或列存储，更灵活，适合海量和高并发场景。</li></ul></blockquote><h3 id="MariaDB-是什么？"><a href="#MariaDB-是什么？" class="headerlink" title="MariaDB 是什么？"></a>MariaDB 是什么？</h3><p>MariaDB 是 MySQL 被 Oracle 收购后，由 MySQL 原创始人 Michael Widenius 带领团队开发的分支（Fork），初衷是避免开源社区被垄断，保持 MySQL 的开源精神。它与 MySQL 高度兼容，多数场景下可无缝替换，换掉 MySQL 就能直接跑，且在并发性能、存储引擎和新功能上优化更优，发展更活跃。如今，CentOS 等主流 Linux 发行版已将 MariaDB 作为默认数据库，取代了原有的 MySQL。</p><p><strong>MariaDB 的特点：</strong></p><ul><li><strong>完全开源免费</strong>，社区驱动，发展活跃。与 MySQL 高度兼容，基本可以“无缝替换”。</li><li>性能优化更好，尤其在并发和存储引擎方面。新功能更快落地（如窗口函数、JSON 支持、GIS 增强等）。</li></ul><blockquote><p>  简单说：<strong>MariaDB &#x3D; MySQL 的开源精神继承者 + 性能增强版 + 社区友好版</strong> </p></blockquote><hr><h2 id="3-基本使用"><a href="#3-基本使用" class="headerlink" title="3. 基本使用"></a>3. 基本使用</h2><h3 id="1-连接-MySQL-服务器"><a href="#1-连接-MySQL-服务器" class="headerlink" title="1. 连接 MySQL 服务器"></a>1. 连接 MySQL 服务器</h3><p>MySQL 本质上是一个 <strong>服务器进程</strong>，它监听某个端口（默认 3306），我们要通过客户端工具（<code>mysql</code> 命令、Navicat、程序代码）去连接。登录命令行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -h 127.0.0.1 -P 3306 -u root -p</span><br></pre></td></tr></table></figure><p>参数解释：</p><ul><li><code>-h</code>：指明服务器地址（host），本地用 <code>127.0.0.1</code> 或 <code>localhost</code>。</li><li><code>-P</code>：指明要访问的端口（Port）号，默认是 <code>3306</code>，所以通常可以省略。</li><li><code>-u</code>：指明登录用户（名）（User），默认管理员账号是 <code>root</code>。</li><li><code>-p</code>：指明要输入密码，不直接写密码在命令里（更安全）。</li></ul><p><strong>简化版：在本机上，端口没改，账号就是 <code>root</code>，那么我们可以直接使用</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p<span class="comment"># 本机最常用</span></span><br></pre></td></tr></table></figure><p>输入密码（密码不回显）就能进去了。</p><h3 id="2-服务器、数据库、表关系"><a href="#2-服务器、数据库、表关系" class="headerlink" title="2. 服务器、数据库、表关系"></a>2. 服务器、数据库、表关系</h3><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250917143401091.png" alt="PixPin_2025-09-17_14-33-29"></p><ol><li><strong>建立数据库，本质就是 Linux 下的一个目录。</strong> 在 MySQL 的默认配置下，<strong>数据库就是 <code>/var/lib/mysql/</code> 下面的一个子目录。</strong> 在操作数据库时可另起窗口进行观察。</li><li>在数据库内建立表，本质就是在 Linux 下创建对应的文件即可！<strong>（表 &#x3D; 目录里的文件）</strong></li><li>数据库本质其实也是文件！！由 <strong>存储引擎</strong> 管理。只不过这些文件并不由程序员直接操作，而是由数据库服务帮我们进行操作。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">服务器 (MySQL Server)</span><br><span class="line">   │</span><br><span class="line">   └── 实例中包含多个「数据库」(Database / Schema)</span><br><span class="line">           │</span><br><span class="line">           └── 每个数据库包含多个「表」(Table)</span><br><span class="line">                   │</span><br><span class="line">                   └── 每个表包含「行」(Row/Record) 和 「列」(Column/Field)</span><br></pre></td></tr></table></figure><p>可以这样理解：</p><ul><li><strong>MySQL 服务器</strong>：像一个大仓库，负责管理一切数据。</li><li><strong>数据库（Database）</strong>：仓库里的一个“库房”，用来放一类相关数据。</li><li><strong>数据表（Table）</strong>：库房里的“柜子”，存放具体的数据。</li><li><strong>记录（Row）</strong>：柜子里的一条数据，相当于一张表格中的一行。</li><li><strong>字段（Column）</strong>：柜子里每个抽屉，相当于一张表格的一列。</li></ul><p>也就是说：<strong>服务器 &gt; 数据库 &gt; 表 &gt; 行&#x2F;列</strong>。</p><hr><h3 id="3-基本操作案例"><a href="#3-基本操作案例" class="headerlink" title="3. 基本操作案例"></a>3. 基本操作案例</h3><h4 id="1-查看已有数据库"><a href="#1-查看已有数据库" class="headerlink" title="1. 查看已有数据库"></a>1. 查看已有数据库</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> DATABASES;</span><br></pre></td></tr></table></figure><p>默认会有 <code>mysql</code>、<code>information_schema</code> 等系统库。比如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">+</span><span class="comment">--------------------+</span></span><br><span class="line"><span class="operator">|</span> Database           <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+</span></span><br><span class="line"><span class="operator">|</span> information_schema <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> mysql              <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> performance_schema <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> sys                <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+</span></span><br><span class="line"><span class="number">4</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure><blockquote><p>逐个解释一下：</p><ul><li><code>information_schema</code> → 数据库结构字典</li><li><code>mysql</code> → 用户与权限的核心库</li><li><code>performance_schema</code> → 性能原始监控库</li><li><code>sys</code> → 性能友好视图库</li></ul><p>这四个库是 <strong>系统保留库</strong>，一般不会往里面存业务数据，但在调试和管理数据库时经常会用到。</p><hr><p><strong>1. <code>information_schema</code></strong></p><ul><li><strong>作用</strong>：存放数据库的 <strong>元数据</strong>（metadata），也就是“关于数据库的数据”。</li><li>包含的信息：</li><li>哪些数据库、表存在？</li><li>表里有哪些字段、索引？</li><li>权限、字符集等配置信息。</li><li><strong>用途</strong>：可以通过查询它来获取数据库结构，而不是去翻文件。</li></ul><p><strong>2. <code>mysql</code></strong></p><ul><li><strong>作用</strong>：存放 MySQL <strong>核心权限控制和配置数据</strong>。</li><li>内容包括：</li><li>用户账号 (<code>user</code> 表)</li><li>权限分配（哪个用户能操作哪个数据库）</li><li>存储过程、事件调度、时区等系统信息</li><li><strong>用途</strong>：如果要新增用户，其实就是往这里写一行数据。</li></ul><p><strong>3. <code>performance_schema</code></strong></p><ul><li><strong>作用</strong>：用来监控 MySQL 的运行时性能（谁在执行 SQL，消耗了多少时间、锁情况等）。</li><li>特点：</li><li>里面的表大部分是“虚拟表”，只读，用来查看性能指标。</li><li>不保存真实业务数据，重启后数据会刷新。</li><li><strong>用途</strong>：调试慢查询、分析瓶颈。</li></ul><p><strong>4. <code>sys</code></strong></p><ul><li><strong>作用</strong>：算是 <code>performance_schema</code> 的“人性化视图”。</li><li>特点：</li><li>里面封装了很多复杂 SQL，把性能信息转换成 <strong>更直观的视图</strong>。</li><li>比如直接告诉你“哪条 SQL 最耗时”、“哪个库最忙”。</li><li><strong>用途</strong>：DBA（数据库管理员）用它来快速诊断问题。</li></ul></blockquote><h4 id="2-创建一个新的数据库"><a href="#2-创建一个新的数据库" class="headerlink" title="2. 创建一个新的数据库"></a>2. 创建一个新的数据库</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE test;</span><br></pre></td></tr></table></figure><h4 id="3-使用-切换数据库"><a href="#3-使用-切换数据库" class="headerlink" title="3. 使用&#x2F;切换数据库"></a>3. 使用&#x2F;切换数据库</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">USE test;</span><br></pre></td></tr></table></figure><h4 id="4-创建一张（数据库）表"><a href="#4-创建一张（数据库）表" class="headerlink" title="4. 创建一张（数据库）表"></a>4. 创建一张（数据库）表</h4><p>比如建一个学生表 <code>students</code>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> students (</span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span> AUTO_INCREMENT,  <span class="comment">-- 学号，自增主键</span></span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT NULL</span>,          <span class="comment">-- 学生姓名</span></span><br><span class="line">    age <span class="type">INT</span>,                            <span class="comment">-- 年龄</span></span><br><span class="line">    grade <span class="type">VARCHAR</span>(<span class="number">20</span>)                   <span class="comment">-- 年级</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="5-（表中）插入数据"><a href="#5-（表中）插入数据" class="headerlink" title="5. （表中）插入数据"></a>5. （表中）插入数据</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> students (name, age, grade) <span class="keyword">VALUES</span></span><br><span class="line">(<span class="string">&#x27;张三&#x27;</span>, <span class="number">18</span>, <span class="string">&#x27;高三&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;李四&#x27;</span>, <span class="number">17</span>, <span class="string">&#x27;高二&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;王五&#x27;</span>, <span class="number">19</span>, <span class="string">&#x27;大学一年级&#x27;</span>);</span><br></pre></td></tr></table></figure><h4 id="6-查询表数据"><a href="#6-查询表数据" class="headerlink" title="6. 查询表数据"></a>6. 查询表数据</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> students;</span><br></pre></td></tr></table></figure><p>输出结果类似：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">+</span><span class="comment">----+--------+------+-----------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> name   <span class="operator">|</span> age  <span class="operator">|</span> grade           <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+------+-----------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> 张三   <span class="operator">|</span>   <span class="number">18</span> <span class="operator">|</span> 高三            <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> 李四   <span class="operator">|</span>   <span class="number">17</span> <span class="operator">|</span> 高二            <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">3</span> <span class="operator">|</span> 王五   <span class="operator">|</span>   <span class="number">19</span> <span class="operator">|</span> 大学一年级      <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+------+-----------------+</span></span><br><span class="line"><span class="number">3</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><h4 id="7-更新数据"><a href="#7-更新数据" class="headerlink" title="7. 更新数据"></a>7. 更新数据</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> students <span class="keyword">SET</span> grade <span class="operator">=</span> <span class="string">&#x27;大学二年级&#x27;</span> <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;王五&#x27;</span>;</span><br></pre></td></tr></table></figure><h4 id="8-删除数据"><a href="#8-删除数据" class="headerlink" title="8. 删除数据"></a>8. 删除数据</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> students <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure><hr><h4 id="9-补充说明"><a href="#9-补充说明" class="headerlink" title="9. 补充说明"></a>9. 补充说明</h4><p>在 MySQL 里，<strong>SQL 关键字（SELECT、INSERT、UPDATE、DELETE、CREATE…）不区分大小写</strong>。所以：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> students;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> students;</span><br><span class="line"><span class="keyword">SeLeCt</span> <span class="operator">*</span> <span class="keyword">FrOm</span> students;</span><br></pre></td></tr></table></figure><p>结果一模一样，MySQL 都能识别。不过要注意两点：</p><ol><li><strong>表名、库名是否区分大小写</strong><ul><li>在 <strong>Windows</strong> 下（默认不区分大小写），<code>students</code> 和 <code>STUDENTS</code> 是同一个表。</li><li>在 <strong>Linux</strong> 下（取决于 <code>lower_case_table_names</code> 参数和文件系统），通常是区分大小写的，所以 <code>students</code> 和 <code>STUDENTS</code> 可能被当成两个不同的表。建议在 Linux（比如 CentOS）环境中 <strong>统一用小写命名数据库、表、列名</strong>，避免踩坑。</li></ul></li><li><strong>规范习惯</strong><ul><li>通常约定：SQL <strong>关键字用大写</strong>（SELECT、WHERE、INSERT INTO），库名、表名、列名用小写（students、school、id）。</li><li>这样可读性更强，一眼能区分“关键字”和“自定义标识符”。</li></ul></li></ol><p><strong>小结：</strong></p><ul><li><strong>语法关键字</strong>：不区分大小写，大小写随你。</li><li><strong>数据库名、表名、字段名</strong>：在 Linux 下可能区分大小写，建议统一小写。</li><li><strong>写代码习惯</strong>：推荐“关键字大写 + 表名字段小写”。</li></ul><hr><h2 id="4-数据逻辑存储"><a href="#4-数据逻辑存储" class="headerlink" title="4. 数据逻辑存储"></a>4. 数据逻辑存储</h2><p>MySQL 是关系型数据库，它的数据逻辑上就是表格结构（二维表）。</p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250916234845523.png" alt="PixPin_2025-09-16_23-48-27"></p><p>表的每一行：一条记录（比如某个用户的信息），表的每一列：一个属性（比如用户名、年龄），多个表之间通过主键、外键建立关系。物理上数据存在磁盘里，常用存储引擎是 <strong>InnoDB</strong>，它支持事务、行级锁、索引。</p><h2 id="5-MySQL-架构"><a href="#5-MySQL-架构" class="headerlink" title="5. MySQL 架构"></a>5. MySQL 架构</h2><h3 id="1-基本架构一览"><a href="#1-基本架构一览" class="headerlink" title="1. 基本架构一览"></a>1. 基本架构一览</h3><p>MySQL 是一个可移植的数据库，几乎能在当前所有的操作系统上运行，如 Unix&#x2F;Linux、Windows、Mac 和 Solaris。各种系统在底层实现方面各有不同，但是 MySQL 基本上能保证在各个平台上的物理体系结构的一致性。它本质上是一个典型的 <strong>“客户端-服务器”模型 + 插件式存储引擎设计</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250917192943647.png" alt="PixPin_2025-09-17_19-29-34"></p><h3 id="2-详细解释"><a href="#2-详细解释" class="headerlink" title="2. 详细解释"></a>2. 详细解释</h3><h4 id="1-最上层：客户端连接器（Client-Connectors）"><a href="#1-最上层：客户端连接器（Client-Connectors）" class="headerlink" title="1. 最上层：客户端连接器（Client Connectors）"></a>1. 最上层：客户端连接器（Client Connectors）</h4><p>最上面一层，支持各种语言和接口，比如：JDBC、ODBC、.NET、PHP、Python、C API。<strong>作用</strong>：程序员写的代码通过这些接口跟 MySQL 服务器通信。</p><blockquote><p>意思是：用 C++ 写程序，可以用 C++的接口连接 MySQL；用 PHP 写网站，可以用 PHP 驱动连接。</p></blockquote><h4 id="2-中间层：MySQL-Server（服务端核心）"><a href="#2-中间层：MySQL-Server（服务端核心）" class="headerlink" title="2. 中间层：MySQL Server（服务端核心）"></a>2. 中间层：MySQL Server（服务端核心）</h4><p>这是 MySQL 的“大脑”，负责处理所有请求。主要包含以下模块：</p><table><thead><tr><th>模块</th><th>功能</th></tr></thead><tbody><tr><td><strong>Connection Pool</strong>（连接池）</td><td>管理客户端连接，进行身份验证、权限和安全。</td></tr><tr><td><strong>SQL Interface</strong>（SQL 接口）</td><td>负责接收 SQL 命令（增删改查、存储过程、触发器等）。</td></tr><tr><td><strong>Parser</strong>（解析器）</td><td>把 SQL 语句拆开，检查语法对不对（词法分析、语法分析）。比如 <code>SELEC</code> 写错就报错。</td></tr><tr><td><strong>Optimizer</strong>（优化器）</td><td>选择最优执行路径、决定怎么执行 SQL 最快，比如用不用索引，先查哪个表。</td></tr><tr><td><strong>Caches</strong>（缓存）</td><td>缓存查询结果和部分数据，加快重复 SQL 的速度，提升性能。</td></tr><tr><td><strong>Services &amp; Utilities</strong>（服务工具）</td><td>提供备份恢复、复制、分区、集群等高级功能。</td></tr></tbody></table><blockquote><p>这些模块共同构成了 MySQL 的“SQL 层”，处理所有 SQL 请求。</p></blockquote><h4 id="3-下一层：（可插拔）存储引擎（Pluggable-Storage-Engines）"><a href="#3-下一层：（可插拔）存储引擎（Pluggable-Storage-Engines）" class="headerlink" title="3. 下一层：（可插拔）存储引擎（Pluggable Storage Engines）"></a>3. 下一层：（可插拔）存储引擎（Pluggable Storage Engines）</h4><p>一个大特点就是 <strong>存储引擎可插拔</strong>。每张表都可以选择不同的存储引擎，都可以独立工作，就像“插件”一样插入系统中。MySQL 支持多种存储引擎，比如：</p><ul><li><strong>InnoDB</strong>（默认，支持事务、行锁、外键）</li><li><strong>MyISAM</strong>（早期常用，不支持事务，速度快性能高）</li><li><strong>Memory</strong>（内存表，速度快但数据断电丢失）</li><li><strong>Archive</strong>（归档用，压缩存储，不适合频繁写入）</li></ul><p>存储引擎负责真正的 <strong>数据存取</strong>、<strong>索引维护</strong>。</p><blockquote><p>所谓 <strong>可插拔存储引擎</strong>，就是 MySQL 允许在同一个数据库里为不同表选择不同的存储方式（比如 InnoDB、MyISAM、Memory 等），就像电脑的 USB 插槽，可以根据需求插入不同的设备一样，从而实现灵活性和扩展性。</p></blockquote><h4 id="4-最底层：文件系统与日志"><a href="#4-最底层：文件系统与日志" class="headerlink" title="4. 最底层：文件系统与日志"></a>4. 最底层：文件系统与日志</h4><p>最底层，跟操作系统交互，负责把数据落到磁盘：</p><ul><li><strong>File System</strong>：如 Linux 的 ext4、Windows 的 NTFS。</li><li><strong>Logs and Files</strong>：各种日志文件：<ul><li><code>binlog</code>（二进制日志，主从复制、数据恢复用）</li><li><code>error log</code>（错误日志）</li><li><code>slow log</code>（慢查询日志）</li><li><code>redo/undo log</code>（事务恢复机制）</li><li>表文件（<code>.ibd</code>、<code>.frm</code> 等）。</li></ul></li></ul><h3 id="3-小结"><a href="#3-小结" class="headerlink" title="3. 小结"></a>3. 小结</h3><p>一条 SQL 语句会先由客户端发出，经过 MySQL Server 层统一做解析、优化和权限检查，再交给底层的存储引擎去执行，最后由存储引擎把数据读写到磁盘文件中。整个过程体现了 MySQL 的分层设计：<strong>SQL 层管“怎么执行”，存储引擎管“怎么存取”。</strong></p><h2 id="6-SQL-分类"><a href="#6-SQL-分类" class="headerlink" title="6. SQL 分类"></a>6. SQL 分类</h2><ol><li><strong>DDL（数据定义语言）</strong>：定义数据库结构，比如建表、删表、改表结构。代表有 👉 <code>CREATE</code>、<code>DROP</code>、<code>ALTER</code>。</li><li><strong>DML（数据操作语言）</strong>：操作表里的数据（增删改），比如：插入一条记录、删除用户。代表有 👉 <code>INSERT</code>、<code>DELETE</code>、<code>UPDATE</code>。<ul><li>其中 <strong>DQL（数据查询语言）</strong> 是 DML 的子类，用来查数据。如：<code>SELECT</code>。</li></ul></li><li><strong>DCL（数据控制语言）</strong>：用来管理权限和事务。代表有 👉 <code>GRANT</code>、<code>REVOKE</code>、<code>COMMIT</code>。</li></ol><p><strong>记忆口诀：DDL 定结构，DML&#x2F;DQL 动数据，DCL 管权限和事务。</strong></p><h2 id="7-存储引擎"><a href="#7-存储引擎" class="headerlink" title="7. 存储引擎"></a>7. 存储引擎</h2><h3 id="1-存储引擎是什么？"><a href="#1-存储引擎是什么？" class="headerlink" title="1. 存储引擎是什么？"></a>1. 存储引擎是什么？</h3><p>存储引擎就是 <strong>MySQL 负责数据的存储、提取</strong>、索引、更新、查询等 <strong>底层实现机制&#x2F;方式的模块。</strong></p><ul><li>同样一条 <code>CREATE TABLE</code>，可以指定用不同引擎，决定数据如何落盘、索引方式、是否支持事务等。</li><li>它体现了 MySQL 的“<strong>可插拔</strong>”特性，不同引擎像插件一样，可以替换。</li></ul><p>简单说：<strong>存储引擎决定了数据在磁盘（或内存）里“怎么存、怎么查、怎么锁、是否支持事务”等。</strong></p><h3 id="2-在-CentOS-7-6-中查看存储引擎"><a href="#2-在-CentOS-7-6-中查看存储引擎" class="headerlink" title="2. 在 CentOS 7.6 中查看存储引擎"></a>2. 在 CentOS 7.6 中查看存储引擎</h3><p>进入 MySQL 后执行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> ENGINES;<span class="comment">-- 查看当前支持的所有存储引擎</span></span><br><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;default_storage_engine&#x27;</span>;   <span class="comment">-- 查看默认存储引擎</span></span><br></pre></td></tr></table></figure><p>一般 <strong>MySQL 8.0 默认存储引擎是 InnoDB</strong>。</p><h3 id="3-常见存储引擎对比表"><a href="#3-常见存储引擎对比表" class="headerlink" title="3. 常见存储引擎对比表"></a>3. 常见存储引擎对比表</h3><table><thead><tr><th>特性 &#x2F; 存储引擎</th><th align="center">InnoDB（默认，事务型）</th><th align="center">MyISAM（读多写少）</th><th align="center">Memory（内存表）</th><th align="center">Archive（归档表）</th><th align="center">NDB（集群引擎）</th><th align="center">Federated（远程表）</th><th align="center">CSV（文本存储）</th><th align="center">Blackhole（黑洞）</th></tr></thead><tbody><tr><td><strong>是否支持事务</strong></td><td align="center">✅</td><td align="center">❌</td><td align="center">❌</td><td align="center">❌</td><td align="center">✅</td><td align="center">❌</td><td align="center">❌</td><td align="center">❌</td></tr><tr><td><strong>锁定粒度</strong></td><td align="center">行级锁</td><td align="center">表级锁</td><td align="center">表级锁</td><td align="center">行级锁</td><td align="center">行级锁</td><td align="center">依赖远程表</td><td align="center">表级锁</td><td align="center">表级锁</td></tr><tr><td><strong>是否支持外键</strong></td><td align="center">✅</td><td align="center">❌</td><td align="center">❌</td><td align="center">❌</td><td align="center">✅</td><td align="center">❌</td><td align="center">❌</td><td align="center">❌</td></tr><tr><td><strong>是否支持 MVCC &#x2F; 快照读</strong></td><td align="center">✅</td><td align="center">❌</td><td align="center">❌</td><td align="center">❌</td><td align="center">✅</td><td align="center">❌</td><td align="center">❌</td><td align="center">❌</td></tr><tr><td><strong>全文索引支持</strong></td><td align="center">✅（5.6+）</td><td align="center">✅</td><td align="center">❌</td><td align="center">❌</td><td align="center">❌</td><td align="center">❌</td><td align="center">❌</td><td align="center">❌</td></tr><tr><td><strong>B-Tree 索引支持</strong></td><td align="center">✅</td><td align="center">✅</td><td align="center">✅</td><td align="center">❌</td><td align="center">✅</td><td align="center">❌</td><td align="center">❌</td><td align="center">❌</td></tr><tr><td><strong>哈希索引支持</strong></td><td align="center">❌（需手动建）</td><td align="center">❌</td><td align="center">✅（默认）</td><td align="center">❌</td><td align="center">✅</td><td align="center">❌</td><td align="center">❌</td><td align="center">❌</td></tr><tr><td><strong>数据存储位置</strong></td><td align="center">磁盘（.ibd 文件）</td><td align="center">磁盘（.MYD&#x2F;.MYI）</td><td align="center">内存</td><td align="center">磁盘（压缩格式）</td><td align="center">内存 + 磁盘</td><td align="center">远程服务器</td><td align="center">文本 CSV 文件</td><td align="center">丢弃（仅 binlog）</td></tr><tr><td><strong>是否支持数据压缩</strong></td><td align="center">✅（表空间压缩）</td><td align="center">❌</td><td align="center">❌</td><td align="center">✅（高压缩）</td><td align="center">✅</td><td align="center">❌</td><td align="center">❌</td><td align="center">❌</td></tr><tr><td><strong>是否支持数据加密</strong></td><td align="center">✅（TDE &#x2F; 函数）</td><td align="center">❌</td><td align="center">❌</td><td align="center">❌</td><td align="center">✅</td><td align="center">❌</td><td align="center">❌</td><td align="center">❌</td></tr><tr><td><strong>存储容量限制</strong></td><td align="center">最大 64TB</td><td align="center">受文件系统限制</td><td align="center">受内存限制</td><td align="center">无明确上限</td><td align="center">依赖集群规模</td><td align="center">依赖远程库</td><td align="center">文件大小限制</td><td align="center">不存储数据</td></tr><tr><td><strong>适用场景</strong></td><td align="center">高并发、事务系统</td><td align="center">只读&#x2F;统计&#x2F;检索</td><td align="center">临时表、缓存</td><td align="center">历史归档、大量插入</td><td align="center">高可用分布式</td><td align="center">跨库访问远程表</td><td align="center">数据交换</td><td align="center">日志复制测试</td></tr><tr><td><strong>数据持久性</strong></td><td align="center">✅ 崩溃恢复</td><td align="center">✅ 但易损坏</td><td align="center">❌ 重启丢失</td><td align="center">✅</td><td align="center">✅</td><td align="center">✅（依赖远程）</td><td align="center">✅</td><td align="center">❌（不保存）</td></tr><tr><td><strong>是否支持复制</strong></td><td align="center">✅ 主从复制</td><td align="center">✅ 主从复制</td><td align="center">❌</td><td align="center">✅</td><td align="center">✅（原生集群）</td><td align="center">❌（依赖远程库）</td><td align="center">❌</td><td align="center">✅（常用于复制）</td></tr><tr><td><strong>是否支持崩溃恢复</strong></td><td align="center">✅ Undo&#x2F;Redo Log</td><td align="center">❌ 易损坏</td><td align="center">❌</td><td align="center">✅</td><td align="center">✅</td><td align="center">❌</td><td align="center">❌</td><td align="center">❌</td></tr><tr><td><strong>内存&#x2F;资源开销</strong></td><td align="center">中等</td><td align="center">低</td><td align="center">高（全内存）</td><td align="center">低</td><td align="center">高</td><td align="center">低</td><td align="center">低</td><td align="center">极低</td></tr><tr><td><strong>插入性能（批量）</strong></td><td align="center">中</td><td align="center">高</td><td align="center">极高</td><td align="center">极高</td><td align="center">高</td><td align="center">中等（依赖远程）</td><td align="center">低</td><td align="center">极高（丢弃数据）</td></tr><tr><td><strong>查询性能</strong></td><td align="center">高（带索引）</td><td align="center">高（简单查询）</td><td align="center">极高（内存）</td><td align="center">低（无索引）</td><td align="center">高</td><td align="center">取决于远程库</td><td align="center">低（无索引）</td><td align="center">❌（无数据）</td></tr><tr><td><strong>默认引擎（MySQL 5.5+）</strong></td><td align="center">✅</td><td align="center">❌（旧版默认）</td><td align="center">❌</td><td align="center">❌</td><td align="center">❌</td><td align="center">❌</td><td align="center">❌</td><td align="center">❌</td></tr></tbody></table>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;数据库基础&quot;&gt;&lt;a href=&quot;#数据库基础&quot; class=&quot;headerlink&quot; title=&quot;数据库基础&quot;&gt;&lt;/a&gt;数据库基础&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a</summary>
        
      
    
    
    
    <category term="MySQL" scheme="https://www.minbit.top/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="https://www.minbit.top/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>050 传输层 —— UDP</title>
    <link href="https://www.minbit.top/posts/62772.html"/>
    <id>https://www.minbit.top/posts/62772.html</id>
    <published>2025-09-12T04:00:00.000Z</published>
    <updated>2025-09-12T04:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="传输层-——-UDP"><a href="#传输层-——-UDP" class="headerlink" title="传输层 —— UDP"></a>传输层 —— UDP</h1><h2 id="1-再谈端口号"><a href="#1-再谈端口号" class="headerlink" title="1. 再谈端口号"></a>1. 再谈端口号</h2><h3 id="1-端口号与五元组通信模型"><a href="#1-端口号与五元组通信模型" class="headerlink" title="1. 端口号与五元组通信模型"></a>1. 端口号与五元组通信模型</h3><p>端口号（Port）标识了一个主机上进行通信的不同的应用程序。</p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250909115539543.png" alt="PixPin_2025-09-09_11-55-33"></p><p>在 TCP&#x2F;IP 协议中，一个 <strong>通信连接</strong> 由五元组唯一标识：<strong>(源 IP, 源端口, 目的 IP, 目的端口, 协议号)</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250909115657967.png" alt="PixPin_2025-09-09_11-56-47"></p><p><strong>为什么需要五元组？</strong></p><ul><li>一台主机可以同时与多个远程主机通信。</li><li>同一个远程主机可以同时提供多个服务（如 HTTP + SSH）。</li><li>同一个服务可以被多个本地进程（客户端）访问。</li><li>所以必须用五元组才能 <strong>唯一标识一条连接</strong>。</li></ul><p><strong>查看当前连接：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">netstat -n</span><br><span class="line"><span class="comment"># 或更现代的：</span></span><br><span class="line">ss -n</span><br></pre></td></tr></table></figure><h3 id="2-端口号范围划分"><a href="#2-端口号范围划分" class="headerlink" title="2. 端口号范围划分"></a>2. 端口号范围划分</h3><table><thead><tr><th>范围</th><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>0 - 1023</td><td>知名端口</td><td>系统保留，通常需要 root 权限绑定。如 80(HTTP), 443(HTTPS), 22(SSH) 等。</td></tr><tr><td>1024 - 49151</td><td>注册端口</td><td>用户程序或第三方服务可注册使用（如 MySQL 3306, Redis 6379）</td></tr><tr><td>49152 - 65535</td><td>动态&#x2F;私有端口</td><td>操作系统自动分配给客户端程序的临时端口</td></tr></tbody></table><blockquote><p>注：不同系统对“动态端口”的起始值可能不同（Linux 默认从 32768 开始，可通过 <code>cat /proc/sys/net/ipv4/ip_local_port_range</code> 查看）。在我的主机上运行结果是 <code>3276860999</code>，这就表示 Linux 会随机选择 <strong>32768 到 60999</strong> 之间的端口号给我自己的客户端进程进行分配。</p></blockquote><p><strong>查看知名端口映射：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /etc/services</span><br></pre></td></tr></table></figure><p><strong>编辑（不要随意修改！）：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> vim /etc/services<span class="comment"># cat 不好查看这样的长内容，用 vim 观看体验会好一点，但不要进行修改！！</span></span><br></pre></td></tr></table></figure><p><strong>我们自定义程序端口建议避开 0-1023，最好使用 1024 以上未被占用的端口，从而避开这些知名端口号。</strong></p><h3 id="3-两个关键问题"><a href="#3-两个关键问题" class="headerlink" title="3. 两个关键问题"></a>3. 两个关键问题</h3><h4 id="1-一个进程是否可以-bind-多个端口号？"><a href="#1-一个进程是否可以-bind-多个端口号？" class="headerlink" title="1. 一个进程是否可以 bind 多个端口号？"></a>1. 一个进程是否可以 bind 多个端口号？</h4><p><strong>可以！</strong> 一个进程可以创建多个 socket，分别 bind 到不同的端口。例如：Nginx 可以监听 80 和 443；一个程序可以同时提供 HTTP 和管理 API。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 伪代码示意</span></span><br><span class="line">socket1 = socket(); bind(socket1, port=<span class="number">8080</span>);</span><br><span class="line">socket2 = socket(); bind(socket2, port=<span class="number">8081</span>);</span><br></pre></td></tr></table></figure><h4 id="2-一个端口号是否可以被多个进程-bind？"><a href="#2-一个端口号是否可以被多个进程-bind？" class="headerlink" title="2. 一个端口号是否可以被多个进程 bind？"></a>2. 一个端口号是否可以被多个进程 bind？</h4><p><strong>我们一般接触到的情况都不行！</strong></p><ul><li><strong>操作系统规定</strong>：同一时间，一个端口（如 <code>80</code>）只能有一个进程处于 <strong>LISTENING</strong> 状态。否则无法区分到底该把流量交给哪个进程。</li><li>如果强行 bind，会报错 <code>Address already in use</code>。</li></ul><p><strong>但也存在例外情况（了解）：</strong></p><ul><li>使用 <code>SO_REUSEADDR</code> 或 <code>SO_REUSEPORT</code> 选项时，多个进程&#x2F;线程可以监听同一个端口，但一般用于 <strong>负载均衡</strong>（如 Nginx 多 worker）。</li><li>这种情况下，内核会把新连接分配给其中一个进程。</li></ul><h3 id="4-命令详解：netstat-pidof"><a href="#4-命令详解：netstat-pidof" class="headerlink" title="4. 命令详解：netstat, pidof"></a>4. 命令详解：<code>netstat</code>, <code>pidof</code></h3><h4 id="1-netstat-——-查看网络连接、路由、接口等"><a href="#1-netstat-——-查看网络连接、路由、接口等" class="headerlink" title="1. netstat —— 查看网络连接、路由、接口等"></a>1. <code>netstat</code> —— 查看网络连接、路由、接口等</h4><p><strong>常用选项（<code>netstat -tulnp</code>）：</strong></p><ul><li>-t：仅显示 TCP 相关选项。</li><li>-u：仅显示 UDP 相关选项。</li><li>-l：仅列出有在 Listening（监听中的）服务状态。</li><li>-n：拒绝显示别名，能显示数字的全部转化成数字。</li><li>-p：显示建立相关链接的程序名、进程 PID（<strong>需要 root</strong>）。</li><li>-a（all）：显示所有选项默认不显示 LISTEN 相关。</li></ul><p><strong>示例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">netstat -n      <span class="comment"># 用数字显示，不反查域名/服务名</span></span><br><span class="line">netstat -tlnp   <span class="comment"># 显示 TCP 监听端口 + 进程号</span></span><br><span class="line">netstat -anp    <span class="comment"># 显示所有连接 + 进程号</span></span><br><span class="line">netstat -tulnp | grep :80 <span class="comment"># 查看谁在监听 80 端口</span></span><br><span class="line"></span><br><span class="line">ss -tulnp</span><br><span class="line">ss -tuln   <span class="comment"># 查监听</span></span><br><span class="line">ss -tan    <span class="comment"># 查所有 TCP 连接</span></span><br></pre></td></tr></table></figure><blockquote><p>在较新 Linux 系统中，<code>ss</code>（socket statistics）开始逐渐替代 <code>netstat</code>。</p></blockquote><h4 id="2-pidof-——-通过程序名获取进程-PID"><a href="#2-pidof-——-通过程序名获取进程-PID" class="headerlink" title="2. pidof —— 通过程序名获取进程 PID"></a>2. <code>pidof</code> —— 通过程序名获取进程 PID</h4><p><strong>语法：</strong> <code>pidof [程序名]</code>。</p><p><strong>示例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pidof httpd      <span class="comment"># 查 httpd 的进程号</span></span><br><span class="line">pidof nginx      <span class="comment"># 查 nginx 的进程号</span></span><br></pre></td></tr></table></figure><p><strong>常见用法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pidof httpd</span><br><span class="line"><span class="comment"># 确认无误后再</span></span><br><span class="line">pidof httpd | xargs <span class="built_in">kill</span> -9</span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line"><span class="built_in">kill</span> -9 $(pidof httpd)     <span class="comment"># 杀死所有 httpd 进程</span></span><br></pre></td></tr></table></figure><hr><h4 id="3-命令行参数转化问题"><a href="#3-命令行参数转化问题" class="headerlink" title="3. 命令行参数转化问题"></a>3. 命令行参数转化问题</h4><p><strong>命令行示例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps ajx | <span class="built_in">head</span> -1 &amp;&amp; ps ajx | grep httpd | awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span> | xargs <span class="built_in">kill</span> -9</span><br></pre></td></tr></table></figure><p><strong>命令行本意：</strong></p><ol><li><code>ps ajx | head -1</code> → 打印 <code>ps ajx</code> 的表头（列名），方便对照列号</li><li><code>&amp;&amp;</code> → 表示前面命令成功（退出码 0）才执行后面的命令，这里 <code>head -1</code> 几乎总是成功，所以后面一定会执行。</li><li><code>ps ajx | grep httpd</code> → 找出所有含有 <code>httpd</code> 的进程。</li><li><code>awk &#39;{print $2}&#39;</code> → 取第 2 列（以为这一列就是 PID）。</li><li><code>xargs kill -9</code> → 把 PID 传给 <code>kill -9</code>，强制结束进程。</li></ol><p><strong>目的就是：先看看进程表头 → 再杀掉所有 httpd（这个 <code>d</code> 就表示是守护进程 ） 进程。</strong></p><p><strong>为什么有问题？</strong></p><p><strong>本来只想杀掉 <code>httpd</code>，结果不小心连 <code>grep httpd</code> 这个查找命令自己也一起杀了 —— 虽然它“死得快”，但逻辑是错的，还可能误杀别的！</strong> </p><ul><li><code>grep httpd</code> 会把自己也列出来，把自己运行的查找命令也一起杀掉，虽然 <code>grep</code> 命令通常 0.1 秒就结束了，杀它没实际影响，但 <strong>逻辑错误！不专业！</strong></li><li>如果系统里没有 httpd，命令会报错！</li></ul><p><strong>怎么解决？</strong></p><ol><li>最简单 —— 直接用 <code>pkill</code>，<code>pkill -9 httpd（进程名，非ID）</code> → 系统自带的“精准杀手”，专门干这个活，不会杀自己，找不到也不报错。</li><li>用 <code>pidof</code>，<code>pidof httpd | xargs kill -9</code> → <code>pidof</code> 只找“程序名叫 httpd”的进程，不会找 grep，很干净。</li><li>非要自己写，加个“防自杀”技巧：<code>ps ajx | grep [h]ttpd | awk &#39;{print $2}&#39; | xargs kill -9</code> → <code>[h]ttpd</code> 和 <code>httpd</code> 效果一样，但命令名是 <code>grep [h]ttpd</code>，不会匹配自己（也叫“grep 防自爆写法”）。</li></ol><h4 id="4-关于-iostat"><a href="#4-关于-iostat" class="headerlink" title="4. 关于 iostat"></a>4. 关于 <code>iostat</code></h4><blockquote><ul><li><strong><code>iostat</code></strong>：I&#x2F;O statistics → 磁盘、CPU 使用情况。</li><li><strong><code>netstat</code></strong>：network statistics → 网络、端口情况。</li></ul></blockquote><p>它和网络&#x2F;端口无关，它只是一个 <strong>查看磁盘 I&#x2F;O 统计</strong> 的工具，用于收集 <strong>CPU 使用情况</strong> 和 <strong>块设备（磁盘&#x2F;分区）I&#x2F;O 性能数据</strong>，帮助我们了解系统的 I&#x2F;O 瓶颈。安装命令：<code>sudo yum install sysstat</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iostat  <span class="comment"># 显示 CPU 使用率 + 每个设备的 I/O 概况</span></span><br><span class="line">iostat -x 1    <span class="comment"># 每秒刷新，显示扩展统计（x → 显示扩展统计，更详细）</span></span><br></pre></td></tr></table></figure><p><strong>指标讲解（磁盘部分）：</strong></p><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td><code>r/s</code></td><td>每秒读请求数（读 IOPS）</td></tr><tr><td><code>w/s</code></td><td>每秒写请求数（写 IOPS）</td></tr><tr><td><code>rkB/s</code></td><td>每秒读的 KB 数（读吞吐量）</td></tr><tr><td><code>wkB/s</code></td><td>每秒写的 KB 数（写吞吐量）</td></tr><tr><td><code>await</code></td><td>平均每个 I&#x2F;O 请求的等待时间（毫秒），越小越好</td></tr><tr><td><code>svctm</code></td><td>服务一个 I&#x2F;O 请求的时间（毫秒）</td></tr><tr><td><code>%util</code></td><td>磁盘繁忙程度（100% &#x3D; 跑满了）</td></tr></tbody></table><p><strong>直观判断：</strong></p><ul><li><code>%util</code> 接近 100%，磁盘被打爆了。</li><li><code>await</code> 很大，说明 I&#x2F;O 延迟严重。</li><li>IOPS (<code>r/s</code>+<code>w/s</code>) 很高，但 <code>%util</code> 没满 → 磁盘性能还行。</li></ul><p><strong>CPU 部分指标：</strong></p><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td><code>%user</code></td><td>用户态 CPU 占比（应用程序消耗）</td></tr><tr><td><code>%system</code></td><td>内核态 CPU 占比（系统调用消耗）</td></tr><tr><td><code>%iowait</code></td><td>等待 I&#x2F;O 的时间占比（越高越说明磁盘慢）</td></tr><tr><td><code>%idle</code></td><td>空闲时间</td></tr></tbody></table><p><strong>直观判断：</strong></p><ul><li><code>%iowait</code> 很高，说明 CPU 大部分时间都在等磁盘。</li><li><code>%user</code> 高 → 应用很吃 CPU。</li><li><code>%idle</code> 高 → 系统很闲。</li></ul><h2 id="2-UDP-协议"><a href="#2-UDP-协议" class="headerlink" title="2. UDP 协议"></a>2. UDP 协议</h2><h3 id="1-UDP-协议段格式"><a href="#1-UDP-协议段格式" class="headerlink" title="1. UDP 协议段格式"></a>1. UDP 协议段格式</h3><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250909115838060.png" alt="PixPin_2025-09-09_11-58-32"></p><blockquote><p>16 位指 16 个二进制位，即 0 或 1，8 位等于 1 字节，16 位就是 2 字节。</p><p><a href="https://en.wikipedia.org/wiki/UTF-16">UTF-16</a> 不常用，<a href="https://en.wikipedia.org/wiki/UTF-8">UTF-8</a> 更常用。它是一种变长字符编码，简单且直观的来说就是在 UTF-8 中，一个英文字符就占 1 字节，一个中文字符就占 3 字节，少数生僻字等占 4 字节。</p></blockquote><p>UDP 报头总是 <strong>8 字节（64 bit）</strong>，分成四个 16 位字段，按顺序排放：</p><ol><li><strong>源端口号（16 位）</strong></li><li><strong>目的端口号（16 位）</strong></li><li><strong>UDP 长度（16 位）</strong> —— 包括整个 UDP 数据报（头部 + 数据）的长度。</li><li><strong>校验和（16 位）</strong> —— 校验 UDP 报文在传输中是否出错（发送方用特定算法，将伪首部、UDP 首部和数据部分计算出校验和存于报头。接收方同样计算并对比，若不一致 <strong>通常丢弃数据包</strong>，但也可交给上层并附错误报告 ）。</li></ol><p>紧接着就是 <strong>数据（有效载荷）</strong>，长度由 “UDP 长度”字段减去 8（报头大小）得出。</p><p>在 Linux 下用 C 语言实现时，UDP 报头是一个自定义结构体。具体表现为（<code>cat /usr/include/netinet/udp.h</code>）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">udphdr</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">u_int16_t</span> source;</span><br><span class="line">  <span class="type">u_int16_t</span> dest;</span><br><span class="line">  <span class="type">u_int16_t</span> len;</span><br><span class="line">  <span class="type">u_int16_t</span> check;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// u_int16_t是一种类型定义，本质上是 16 位无符号整数，用来定义 UDP 报头中各字段的数据类型，像源端口号、目的端口号等都是 16 位，就用它来定义。</span></span><br></pre></td></tr></table></figure><h3 id="2-UDP-报文是“矩形”的还是线性的？"><a href="#2-UDP-报文是“矩形”的还是线性的？" class="headerlink" title="2. UDP 报文是“矩形”的还是线性的？"></a>2. UDP 报文是“矩形”的还是线性的？</h3><p>图中“矩形”矩形结构只是一种 <strong>逻辑结构图&#x2F;一种可视化方式</strong>，用来帮助理解字段布局、说明各个字段的位置和大小。实际网络上传输时（物理传输层面），报文是 <strong>一维线性的比特流（字节流）</strong>。换句话说，发送出去的数据包在网线上就是一串 0 和 1，不是二维矩形。</p><p>实际在网络中，UDP 数据报是一个连续的字节序列，按顺序排列如下：<code>[源端口][目的端口][长度][检验和][数据...]</code>，举个例子：假设一个 UDP 数据报有 100 字节数据，则总长度为 8（头部）+ 100 &#x3D; 108 字节。这些字节会依次封装进 IP 包中，通过网络传输。</p><blockquote><p>在协议层面 <strong>面向数据报</strong>，UDP 以数据报为单位处理数据，有独立边界；在物理传输层面，为适配网络介质，数据报要转化为 <strong>比特流（字节流）传输</strong>，一个是逻辑处理方式，一个是实际传输形式 。 </p></blockquote><hr><h3 id="3-报头和有效载荷是如何分离的？"><a href="#3-报头和有效载荷是如何分离的？" class="headerlink" title="3. 报头和有效载荷是如何分离的？"></a>3. 报头和有效载荷是如何分离的？</h3><p>关键点是 <strong>UDP 长度字段</strong>，通过它确定报头后 8 字节的边界，从而分离出有效载荷。接收方先看前 8 字节是报头，再找出 “UDP 长度” 这个信息，从第 9 字节开始，用 “UDP 长度” 减 8 得到的字节数就是有效载荷。或者简单说，先确定 8 字节报头，IP 层把数据给 UDP 后，剩下的就是有效载荷。</p><h3 id="4-有效载荷如何交付给上层？"><a href="#4-有效载荷如何交付给上层？" class="headerlink" title="4. 有效载荷如何交付给上层？"></a>4. 有效载荷如何交付给上层？</h3><p>当 UDP 收到数据报后：</p><ol><li>根据 <strong>目的端口号</strong> 查找对应的应用程序（如 DNS、NTP、游戏等）。</li><li>将有效载荷交给该应用程序处理。</li><li>应用程序通常通过 socket 接口接收数据（例如 <code>recvfrom()</code>）。</li></ol><p>比如在线视频播放时，视频流数据通过 UDP 传输，目的端口号对应视频播放应用程序，UDP 把有效载荷交给它，就能播放视频了。</p><blockquote><p>UDP 不保证送达、不排序、不重传，所以交付是“尽力而为”。</p></blockquote><h3 id="5-UDP-的应用场景有哪些？"><a href="#5-UDP-的应用场景有哪些？" class="headerlink" title="5. UDP 的应用场景有哪些？"></a>5. UDP 的应用场景有哪些？</h3><p><strong>UDP 的特点：简单、无连接、不保证可靠传输、面向数据报，但开销小、延迟低。</strong> 适用于：</p><ul><li>实时通信：语音通话（VoIP）、视频会议、在线游戏（延迟比可靠性更重要）。</li><li>简单查询服务：DNS（域名解析）、SNMP（网络管理）、DHCP（动态主机配置）。</li><li>广播、多播：如局域网内的服务发现。</li></ul><h3 id="6-如果-UDP-数据包太大怎么办？"><a href="#6-如果-UDP-数据包太大怎么办？" class="headerlink" title="6. 如果 UDP 数据包太大怎么办？"></a>6. 如果 UDP 数据包太大怎么办？</h3><blockquote><p>分片就像是把大包裹拆成几个小包裹来寄。UDP 数据包太大时，IP 层会把它拆分。丢包就是这些小包裹在运输（网络传输）过程中丢失了。一旦有小包裹丢了，因为 UDP 不会重新发送，整个数据就用不了。</p></blockquote><p><strong>UDP 没分段机制，数据包大小受 MTU（最大传输单元）限制。</strong> 比如 IPv4 的 MTU 一般 1500 字节，减去 IP 头部（20 字节）和 UDP 头部（8 字节）后就是数据最大长度（<strong>最大 UDP 载荷约为 1472 字节</strong>）。超了就由 IP 层分片，像把大文件拆成小文件。但分片可能丢包，现代设备还可能拒绝分片。应对办法有控制数据大小、用路径 MTU 发现或改用 TCP 协议等。 </p><h3 id="7-UDP-的缓冲区"><a href="#7-UDP-的缓冲区" class="headerlink" title="7. UDP 的缓冲区"></a>7. UDP 的缓冲区</h3><p>UDP 无真正发送缓冲区，sendto 调用后数据直给内核再传网络层。它有接收缓冲区，但不能保证接收顺序与发送一致，若缓冲区满，新到的 UDP 数据会被丢弃。UDP 的 socket 可同时读写，具备全双工特性 。 </p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;传输层-——-UDP&quot;&gt;&lt;a href=&quot;#传输层-——-UDP&quot; class=&quot;headerlink&quot; title=&quot;传输层 —— UDP&quot;&gt;&lt;/a&gt;传输层 —— UDP&lt;/h1&gt;&lt;h2 id=&quot;1-再谈端口号&quot;&gt;&lt;a href=&quot;#1-再谈端口号&quot;</summary>
        
      
    
    
    
    <category term="Linux" scheme="https://www.minbit.top/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://www.minbit.top/tags/Linux/"/>
    
    <category term="网络" scheme="https://www.minbit.top/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>洛谷测试点信息</title>
    <link href="https://www.minbit.top/posts/55897.html"/>
    <id>https://www.minbit.top/posts/55897.html</id>
    <published>2025-09-11T16:00:00.000Z</published>
    <updated>2025-09-12T02:10:00.000Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th><strong>评测结果</strong></th><th><strong>缩写</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td><strong>Accepted</strong></td><td>AC</td><td>正确</td></tr><tr><td><strong>Wrong Answer</strong></td><td>WA</td><td>错误</td></tr><tr><td><strong>Time Limit Exceeded</strong></td><td>TLE</td><td>超时</td></tr><tr><td><strong>Memory Limit Exceeded</strong></td><td>MLE</td><td>内存超限</td></tr><tr><td><strong>Runtime Error</strong></td><td>RE</td><td>段错误（如数组越界、除以零等）</td></tr><tr><td><strong>Compilation Error</strong></td><td>CE</td><td>编译错误</td></tr><tr><td><strong>Output Limit Exceeded</strong></td><td>OLE</td><td>输出数据量超出限制</td></tr><tr><td><strong>Unknown Error</strong></td><td>UKE</td><td>未知错误，通常是系统层面的问题。</td></tr><tr><td><strong>Partially Correct</strong></td><td>PC</td><td>部分正确</td></tr></tbody></table><h3 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h3><ul><li><strong>耗时和内存使用</strong>：通常洛谷会显示程序在每个测试点中的实际运行时间和内存消耗。</li><li><strong>部分得分情况</strong>：如果题目支持部分得分，可能会显示得分比例（例如 5&#x2F;10）。</li><li><strong>隐藏测试点</strong>：某些题目可能存在隐藏的测试点，用于防止作弊或验证程序的鲁棒性。</li></ul>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;评测结果&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;缩写&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;含义&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td</summary>
        
      
    
    
    
    <category term="灵光荟萃" scheme="https://www.minbit.top/categories/%E7%81%B5%E5%85%89%E8%8D%9F%E8%90%83/"/>
    
    
  </entry>
  
  <entry>
    <title>01 在 CentOS 7 中安装 MySQL</title>
    <link href="https://www.minbit.top/posts/9972.html"/>
    <id>https://www.minbit.top/posts/9972.html</id>
    <published>2025-09-09T16:00:00.000Z</published>
    <updated>2025-10-11T02:10:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="在-CentOS-7-6-上从零安装并配置-MySQL-详细教程"><a href="#在-CentOS-7-6-上从零安装并配置-MySQL-详细教程" class="headerlink" title="在 CentOS 7.6 上从零安装并配置 MySQL 详细教程"></a>在 CentOS 7.6 上从零安装并配置 MySQL 详细教程</h1><blockquote><p><span style="color:#FF0000;"><strong>配置之前，请先使用 root 账号登录！后续命令都是基于 root 权限的！</strong></span></p></blockquote><blockquote><p><strong>1. 工程实践中的常态</strong></p><p>在公司级、工程级的开发环境里，<strong>数据库几乎都是部署在 Linux 上</strong>。原因很现实：</p><ul><li><strong>稳定性</strong>：Linux 的内核和生态对长时间运行的服务（数据库、Web 服务器）更稳。</li><li><strong>性能</strong>：Linux 的 I&#x2F;O 调度、文件系统、网络栈优化比 Windows 更适合高并发和大数据量场景。</li><li><strong>生态一致性</strong>：大部分运维工具、监控方案（Prometheus、Ansible、Docker&#x2F;K8s）都是围绕 Linux 构建的。</li><li><strong>服务器环境</strong>：绝大多数云服务（阿里云、华为云、AWS、GCP）默认都跑 Linux，不会给你装 Windows Server 再跑 MySQL。</li></ul><p>换句话说，<strong>“工程实践里数据库跑在 Linux 上” 已经是行业共识</strong>。</p><p><strong>2. 那 Windows 下用 MySQL 就“愚蠢”吗？</strong></p><p>也不能这么绝对。Windows 下用 MySQL 有几个合理的场景：</p><ul><li><strong>个人开发&#x2F;学习</strong>：很多初学者直接用 Windows 装 MySQL，图形化界面工具丰富，上手快。</li><li><strong>小型应用&#x2F;测试</strong>：有些实验性项目或 demo，没必要起一台 Linux 服务器。</li><li><strong>企业遗留环境</strong>：部分公司内部系统历史包袱大，早期就跑在 Windows + MySQL 上，一时半会没迁移。</li></ul><p>所以在 <strong>学习&#x2F;个人项目</strong> 阶段，Windows 并不是愚蠢，而是 <strong>易用</strong>。只是它天然不适合工业级、持续稳定运行的数据库。</p><p><strong>3. 为什么大公司更青睐 Linux + MySQL？</strong></p><p>因为要考虑的远不止“能不能跑”：</p><ul><li><strong>集群部署</strong>：Linux 下搭建主从复制、MGR 集群、分布式架构更成熟。</li><li><strong>高可用</strong>：用 Linux 的 keepalived、pacemaker、systemd 脚本能做自动容灾。</li><li><strong>容器化&#x2F;云原生</strong>：MySQL 在 Docker&#x2F;Kubernetes 中的镜像都是基于 Linux。Windows 几乎没有原生容器支持。</li></ul></blockquote><h2 id="1-准备工作：卸载旧的、不要的-MySQL-MariaDB-环境"><a href="#1-准备工作：卸载旧的、不要的-MySQL-MariaDB-环境" class="headerlink" title="1. 准备工作：卸载旧的、不要的 MySQL&#x2F;MariaDB 环境"></a>1. 准备工作：卸载旧的、不要的 MySQL&#x2F;MariaDB 环境</h2><h3 id="1-检查正在运行的-mysqld-mysql-mariadb-进程"><a href="#1-检查正在运行的-mysqld-mysql-mariadb-进程" class="headerlink" title="1. 检查正在运行的 mysqld &#x2F; mysql &#x2F; mariadb 进程"></a>1. 检查正在运行的 mysqld &#x2F; mysql &#x2F; mariadb 进程</h3><p>在安装新版本 MySQL 之前，务必确保系统中没有残留的旧版本数据库，避免冲突。如果有输出，说明有正在运行的 MySQL 或 MariaDB 进程。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ps ajx | grep mysql</span><br><span class="line">ps ajx | grep mariadb</span><br><span class="line"><span class="comment"># 或者：</span></span><br><span class="line">ps aux | egrep <span class="string">&#x27;mysqld|mysql|mariadb&#x27;</span>   <span class="comment"># 列出相关进程</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>注意看最后一列的命令内容。</strong> 如果最后一列显示是 grep …，这个其实是刚刚执行的 grep 本身。比如：<code>14375 14838 14837 14375 pts/0    14837 S+    1000   0:00 grep --color=auto mysql</code>，不要将这个当作 MySQL 的进程！</p></blockquote><h3 id="2-停止正在运行的服务"><a href="#2-停止正在运行的服务" class="headerlink" title="2. 停止正在运行的服务"></a>2. 停止正在运行的服务</h3><p><strong>如果上面检查出了有 mysqld &#x2F; mysql &#x2F; mariadb 进程的存在才需要执行这一步。</strong> 执行下面的命令，如果输出中存在 <code>service not loaded.</code> 的字样说明大概率就是 MySQL&#x2F;MariaDB 服务未安装，我们就可以直接进行下一步了。当然也存在 <strong>及其少见</strong> 的情况：服务名称不同，非常罕见，不做讨论。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop mysql</span><br><span class="line">systemctl stop mariadb</span><br></pre></td></tr></table></figure><h2 id="2-检查系统安装包"><a href="#2-检查系统安装包" class="headerlink" title="2. 检查系统安装包"></a>2. 检查系统安装包</h2><h3 id="1-查找已安装的相关-RPM-包"><a href="#1-查找已安装的相关-RPM-包" class="headerlink" title="1. 查找已安装的相关 RPM 包"></a>1. 查找已安装的相关 RPM 包</h3><blockquote><p>有些人可能会想要备份当前的数据目录和配置，可以执行下方命令，后续可以从 <code>/var/lib/mysql.bak</code> 进行恢复。<strong>当然，我们这里是从 0 安装 MySQL，我想要干净、易于管理就不进行备份了，备份是可选项，个人感觉没有太多必要。</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="built_in">sudo</span> systemctl stop mysqld || <span class="built_in">sudo</span> systemctl stop mariadb || <span class="literal">true</span></span><br><span class="line">&gt;<span class="built_in">sudo</span> <span class="built_in">cp</span> -a /var/lib/mysql /var/lib/mysql.bak      <span class="comment"># 备份数据目录</span></span><br><span class="line">&gt;<span class="built_in">sudo</span> <span class="built_in">cp</span> -a /etc/my.cnf /etc/my.cnf.bak || <span class="literal">true</span>    <span class="comment"># 备份配置文件（如存在）</span></span><br><span class="line">&gt;<span class="built_in">sudo</span> tar czvf /root/mysql_backup_$(<span class="built_in">date</span> +%F).tgz /var/lib/mysql /etc/my.cnf || <span class="literal">true</span></span><br></pre></td></tr></table></figure></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rpm -qa | grep -i mysql<span class="comment"># -i 选项可忽略（下同）</span></span><br><span class="line">rpm -qa | grep -i mariadb</span><br></pre></td></tr></table></figure><h3 id="2-删除已安装的-MySQL-MariaDB-包"><a href="#2-删除已安装的-MySQL-MariaDB-包" class="headerlink" title="2. 删除已安装的 MySQL&#x2F;MariaDB 包"></a>2. 删除已安装的 MySQL&#x2F;MariaDB 包</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rpm -qa | grep -i mysql | xargs yum -y remove<span class="comment"># 删除所有 mysql 相关 rpm</span></span><br><span class="line">rpm -qa | grep -i mariadb | xargs yum -y remove<span class="comment"># 删除 mariadb 相关 rpm</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 再次确认</span></span><br><span class="line">rpm -qa | grep -i mysql || <span class="literal">true</span></span><br><span class="line">rpm -qa | grep -i mariadb || <span class="literal">true</span></span><br></pre></td></tr></table></figure><blockquote><p>使用 <code>xargs</code> 可以将查询结果作为参数传递给 <code>yum remove</code>，实现批量卸载。</p></blockquote><h3 id="3-处理残留文件"><a href="#3-处理残留文件" class="headerlink" title="3. 处理残留文件"></a>3. 处理残留文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> /etc/my.cnf          <span class="comment"># 配置文件</span></span><br><span class="line"><span class="built_in">ls</span> /var/lib/mysql/      <span class="comment"># 数据目录</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@hcss-ecs-be68 ~]# <span class="built_in">which</span> mysql mysqld mysqld_safe<span class="comment"># 检查二进制文件残留（可选）</span></span><br><span class="line">/usr/bin/which: no mysql <span class="keyword">in</span> (/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin)</span><br><span class="line">/usr/bin/which: no mysqld <span class="keyword">in</span> (/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin)</span><br><span class="line">/usr/bin/which: no mysqld_safe <span class="keyword">in</span> (/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin)</span><br><span class="line"></span><br><span class="line"><span class="comment"># mysql（客户端命令），mysqld（服务器主程序），mysqld_safe（服务器安全启动脚本）</span></span><br><span class="line"><span class="comment"># 这些关键二进制文件都不存在于系统的环境变量路径中，进一步证明了 MySQL/MariaDB 相关组件已经被彻底卸载，没有残留的可执行文件。</span></span><br></pre></td></tr></table></figure><p>如有残留，建议删除残留文件，当然这一步是可选的，不清理残留可能会影响后续使用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> -rf /etc/my.cnf</span><br><span class="line"><span class="built_in">rm</span> -rf /var/lib/mysql/</span><br></pre></td></tr></table></figure><h2 id="3-获取-MySQL-官方-yum-源"><a href="#3-获取-MySQL-官方-yum-源" class="headerlink" title="3. 获取 MySQL 官方 yum 源"></a>3. 获取 MySQL 官方 yum 源</h2><p>CentOS 默认 YUM 源中不包含 MySQL 常用版本，需手动添加官方仓库。</p><h3 id="1-确认系统版本"><a href="#1-确认系统版本" class="headerlink" title="1. 确认系统版本"></a>1. 确认系统版本</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /etc/redhat-release</span><br><span class="line"><span class="comment"># 本机输出示例：CentOS Linux release 7.6.1810 (Core)</span></span><br></pre></td></tr></table></figure><p><strong>我们需要选择 MySQL 5.7 安装包，因为大多数公司使用的版本依旧在 5.7 左右，所以选择这个，另外选择这个版本会方便后续出错问题的排查。但是很可惜，我在安装这个版本时出错了，倒腾了很久，遂放弃。所以我们选用 MySQL 8.0（具体是 8.0.43），但后面的讲解依旧会参杂部分的 MySQL 5.7 的讲解。</strong></p><blockquote><p>MySQL 8.0 和 MySQL 5.7 存在一些差异， 基础学习，有差异的地方查一下就行了，SQL 语句基本上是一样的，问题不大。</p></blockquote><h3 id="2-下载并安装-MySQL-YUM-仓库-RPM-包"><a href="#2-下载并安装-MySQL-YUM-仓库-RPM-包" class="headerlink" title="2. 下载并安装 MySQL YUM 仓库 RPM 包"></a>2. 下载并安装 MySQL YUM 仓库 RPM 包</h3><p>在 Windows 中前往 <a href="http://repo.mysql.com/">MySQL YUM Repository</a>，选择对应版本进行下载。由于网页不是很好筛选，在浏览器中右键选择 <strong>查看网页源代码（<code>ctrl+u</code>）</strong> 去寻找对应版本的安装包。这里我选择是</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql-community-release-el7.rp</span><br></pre></td></tr></table></figure><p><strong>通过 <code>rz</code> 命令将下载好的 RPM 包上传至我们的 Linux。</strong> 输入命令 <code>ls /etc/yum.repos.d/ -l</code> 可以查看系统中配置了哪些软件仓库，比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@hcss-ecs-be68 ~]# <span class="built_in">ls</span> /etc/yum.repos.d/ -l</span><br><span class="line">total 48</span><br><span class="line">-rw-r--r--  1 root root 1732 Jul  7  2024 CentOS-Base.repo</span><br><span class="line">-rw-r--r--. 1 root root 1309 Nov 23  2018 CentOS-CR.repo</span><br><span class="line">-rw-r--r--. 1 root root  649 Nov 23  2018 CentOS-Debuginfo.repo</span><br><span class="line">-rw-r--r--. 1 root root  314 Nov 23  2018 CentOS-fasttrack.repo</span><br><span class="line">-rw-r--r--. 1 root root  630 Nov 23  2018 CentOS-Media.repo</span><br><span class="line">-rw-r--r--. 1 root root 1331 Nov 23  2018 CentOS-Sources.repo</span><br><span class="line">-rw-r--r--. 1 root root 5701 Nov 23  2018 CentOS-Vault.repo</span><br><span class="line">-rw-r--r--  1 root root  927 Jul  7  2024 epel.repo</span><br><span class="line">-rw-r--r--  1 root root 1358 Sep  5  2021 epel.repo.rpmnew</span><br><span class="line">-rw-r--r--  1 root root 1457 Sep  5  2021 epel-testing.repo</span><br><span class="line">-rw-r--r--  1 root root  192 Jan 20  2016 wandisco-git.repo</span><br></pre></td></tr></table></figure><p>为了方便管理，可以整理一下目录结构，比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@hcss-ecs-be68 ~]# tree</span><br><span class="line">.</span><br><span class="line">└── MySQL</span><br><span class="line">    └── mysql-community-release-el7.rpm</span><br></pre></td></tr></table></figure><h3 id="3-安装仓库-RPM"><a href="#3-安装仓库-RPM" class="headerlink" title="3. 安装仓库 RPM"></a>3. 安装仓库 RPM</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh mysql-community-release-el7.rpm<span class="comment"># 注意这里是自己实际的 rpm 包名</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例：</span></span><br><span class="line">[root@hcss-ecs-be68 MySQL]# rpm -ivh mysql-community-release-el7.rpm </span><br><span class="line">warning: mysql-community-release-el7.rpm: Header V3 DSA/SHA1 Signature, key ID 5072e1f5: NOKEY</span><br><span class="line">Preparing...                          <span class="comment">################################# [100%]</span></span><br><span class="line">Updating / installing...</span><br><span class="line">   1:mysql80-community-release-el7-3  <span class="comment">################################# [100%]</span></span><br></pre></td></tr></table></figure><h3 id="4-验证仓库是否添加成功"><a href="#4-验证仓库是否添加成功" class="headerlink" title="4. 验证仓库是否添加成功"></a>4. 验证仓库是否添加成功</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> /etc/yum.repos.d/ -l</span><br><span class="line"><span class="comment"># 或者：</span></span><br><span class="line"><span class="built_in">ls</span> /etc/yum.repos.d/ -l | grep mysql</span><br></pre></td></tr></table></figure><p>包含下面的字段，则代表安装成功：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql-community.repo</span><br><span class="line">mysql-community-source.repo</span><br></pre></td></tr></table></figure><blockquote><p><span style="color:#FF0000;"><strong>前提警告：只可远观而不可亵玩焉，不要擅自进行修改！！！</strong></span></p><p>你可以使用 <code>vim /etc/yum.repos.d/mysql-community.repo</code> 进行 MySQL 官方软件仓库的查看，这里面是纯文本配置内容，记录了 MySQL 官方软件仓库的地址、可安装的 MySQL 版本（如 5.7、8.0 等）、软件包校验信息等。给系统的包管理器（yum）指路 —— 告诉 yum 从哪里下载官方正版的 MySQL 软件（包括服务器、客户端等组件），以及如何验证下载的软件是否安全，从而实现通过 <code>yum install mysql</code> 等命令一键安装 &#x2F; 更新 MySQL。</p></blockquote><h3 id="5-检查是否可列出-MySQL-包"><a href="#5-检查是否可列出-MySQL-包" class="headerlink" title="5. 检查是否可列出 MySQL 包"></a>5. 检查是否可列出 MySQL 包</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum list | grep mysql</span><br></pre></td></tr></table></figure><p>首次执行可能较慢（需下载元数据），耐心等待。若看到 <code>mysql-community-server.x86_64</code> 等条目，说明配置成功。</p><blockquote><p>此时可删除下载的 <code>.rpm</code> 文件（非必需）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> mysql-community-release-el7.rpm</span><br></pre></td></tr></table></figure></blockquote><h2 id="4-正式安装-MySQL-服务"><a href="#4-正式安装-MySQL-服务" class="headerlink" title="4. 正式安装 MySQL 服务"></a>4. 正式安装 MySQL 服务</h2><h3 id="1-安装-MySQL-Server"><a href="#1-安装-MySQL-Server" class="headerlink" title="1. 安装 MySQL Server"></a>1. 安装 MySQL Server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y mysql-community-server</span><br></pre></td></tr></table></figure><p>等待安装完成，过程中会自动安装依赖包。</p><blockquote><p>很不幸，我当时在这里出现了报错：<strong>AI 的说法：</strong> 日志末尾出现 <strong>GPG 密钥验证失败报错</strong>，这是导致安装无法继续的核心问题，具体报错信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;The GPG keys listed <span class="keyword">for</span> the <span class="string">&quot;MySQL 8.0 Community Server&quot;</span> repository are already installed but they are not correct <span class="keyword">for</span> this package.</span><br><span class="line">&gt;Check that the correct key URLs are configured <span class="keyword">for</span> this repository.</span><br><span class="line"></span><br><span class="line">&gt;Failing package is: mysql-community-client-8.0.43-1.el7.x86_64</span><br><span class="line">&gt;GPG Keys are configured as: file:///etc/pki/rpm-gpg/RPM-GPG-KEY-mysql</span><br></pre></td></tr></table></figure><p>第一次执行 <code>yum install</code> 时，还出现过 <strong>SSH 连接断开</strong>（<code>Socket error Event: 32 Error: 10053</code>），导致安装过程中途终止；重新连接后再次执行安装，才暴露了 GPG 密钥不匹配的核心报错。</p></blockquote><p><span style="color:#FF0000;"><strong>解决办法：导入 MySQL 官方的 GPG key</strong></span></p><ul><li><p><strong>MySQL 8.0.43</strong> 需要执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm --import https://repo.mysql.com/RPM-GPG-KEY-mysql-2023</span><br></pre></td></tr></table></figure></li><li><p>如果是 MySQL 5.7（或者 8.0 的早期版本 &lt; 8.0.34），才会用旧的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm --import https://repo.mysql.com/RPM-GPG-KEY-mysql</span><br></pre></td></tr></table></figure></li></ul><p>导入完 MySQL 官方的 GPG key 后需要再次执行 <code>yum install -y mysql-community-server</code>。我在这一次才成功，来看看几个关键点：</p><ol><li><strong><code>Transaction test succeeded</code></strong> 👉 说明依赖检查通过，可以正常安装。</li><li><strong><code>Running transaction ... Installing ... Verifying ...</code></strong> 👉 依赖包一个个安装并验证通过，没有报错。</li><li><strong>最后输出 <code>Complete!</code></strong> 👉 这是 yum 安装成功的标志。</li></ol><h3 id="2-验证安装结果"><a href="#2-验证安装结果" class="headerlink" title="2. 验证安装结果"></a>2. 验证安装结果</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> /etc/my.cnf           <span class="comment"># 配置文件应已生成</span></span><br><span class="line"><span class="built_in">which</span> mysqld             <span class="comment"># MySQL 服务程序路径</span></span><br><span class="line"><span class="built_in">which</span> mysql              <span class="comment"># MySQL 客户端路径</span></span><br></pre></td></tr></table></figure><p>输出示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/etc/my.cnf</span><br><span class="line">/usr/sbin/mysqld</span><br><span class="line">/usr/bin/mysql</span><br></pre></td></tr></table></figure><h2 id="5-启动-MySQL-服务并验证"><a href="#5-启动-MySQL-服务并验证" class="headerlink" title="5. 启动 MySQL 服务并验证"></a>5. 启动 MySQL 服务并验证</h2><h3 id="1-启动服务"><a href="#1-启动服务" class="headerlink" title="1. 启动服务"></a>1. 启动服务</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">systemctl start mysqld<span class="comment"># 启动服务</span></span><br><span class="line">systemctl status mysqld<span class="comment"># 检查服务状态</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动成功示例：</span></span><br><span class="line">[root@hcss-ecs-be68 ~]# systemctl start mysqld</span><br><span class="line">[root@hcss-ecs-be68 ~]# systemctl status mysqld</span><br><span class="line">● mysqld.service - MySQL Server</span><br><span class="line">   Loaded: loaded (/usr/lib/systemd/system/mysqld.service; enabled; vendor preset: disabled)</span><br><span class="line">   Active: active (running) since Tue 2025-08-16 20:49:34 CST; 5ms ago</span><br><span class="line">     Docs: man:mysqld(8)</span><br><span class="line">           http://dev.mysql.com/doc/refman/en/using-systemd.html</span><br><span class="line">  Process: 30782 ExecStartPre=/usr/bin/mysqld_pre_systemd (code=exited, status=0/SUCCESS)</span><br><span class="line"> Main PID: 30852 (mysqld)</span><br><span class="line">   Status: <span class="string">&quot;Server is operational&quot;</span></span><br><span class="line">   CGroup: /system.slice/mysqld.service</span><br><span class="line">           └─30852 /usr/sbin/mysqld</span><br></pre></td></tr></table></figure><h3 id="2-设置开机自启（推荐）"><a href="#2-设置开机自启（推荐）" class="headerlink" title="2. 设置开机自启（推荐）"></a>2. 设置开机自启（推荐）</h3><p>在上面的运行启动示例中 <strong>已经显示 MySQL 服务默认配置了开机自启</strong>，如果你不确定开机自启是否启用，可执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> mysqld</span><br></pre></td></tr></table></figure><h3 id="3-检查服务状态"><a href="#3-检查服务状态" class="headerlink" title="3. 检查服务状态"></a>3. 检查服务状态</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ps ajx | grep mysqld     <span class="comment"># 查看守护进程</span></span><br><span class="line"></span><br><span class="line">netstat -nltp | grep 3306 <span class="comment"># 查看监听端口（默认3306）</span></span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line">ss -nltp | grep 3306   <span class="comment"># 查看 3306 端口是否已监听</span></span><br></pre></td></tr></table></figure><p>正常应看到 <code>mysqld</code> 进程及 <code>0.0.0.0:3306</code> 监听状态。</p><blockquote><p>MySQL 本质上其实是一种网络服务，默认监听 3306 端口，可通过防火墙或云平台安全组放行。</p></blockquote><h2 id="6-首次登录-MySQL-并重置-root-密码"><a href="#6-首次登录-MySQL-并重置-root-密码" class="headerlink" title="6. 首次登录 MySQL 并重置 root 密码"></a>6. 首次登录 MySQL 并重置 root 密码</h2><h3 id="1-获取临时密码"><a href="#1-获取临时密码" class="headerlink" title="1. 获取临时密码"></a>1. 获取临时密码</h3><p>安装后 MySQL 默认会生成一个随机 root 密码，写在日志里：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep <span class="string">&#x27;temporary password&#x27;</span> /var/log/mysqld.log</span><br></pre></td></tr></table></figure><p>你会得到类似：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2025-08-16T12:49:30.049756Z 6 [Note] [MY-010454] [Server] A temporary password is generated <span class="keyword">for</span> root@localhost: Rhszstdgg3#!<span class="comment"># 临时密码各不相同！</span></span><br></pre></td></tr></table></figure><p>复制 <code>Rhszstdgg3#!</code> 部分作为临时密码。</p><blockquote><p>⚠️ 如果日志中没有，可能服务未正常启动或未生成，请检查 <code>/var/log/mysqld.log</code> 全文。</p></blockquote><h3 id="2-登录-MySQL"><a href="#2-登录-MySQL" class="headerlink" title="2. 登录 MySQL"></a>2. 登录 MySQL</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure><p>输入上面复制的临时密码进行登录。</p><h3 id="3-修改-root-密码（必须操作）"><a href="#3-修改-root-密码（必须操作）" class="headerlink" title="3. 修改 root 密码（必须操作）"></a>3. 修改 root 密码（必须操作）</h3><p>登录后，立即修改密码，否则多数操作会被拒绝：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;xxxxxxxxxxx&#x27;</span>;</span><br><span class="line"># 你需要把 xxxxxxxxxxx 换成自己实际的密码，注意要用 ; 结尾！！</span><br></pre></td></tr></table></figure><blockquote><p>MySQL 5.7 默认有密码强度策略，密码至少 8 位，包含大小写、数字和特殊字符，否则修改会出错！</p></blockquote><h3 id="4-重新登录（使用自己的密码）"><a href="#4-重新登录（使用自己的密码）" class="headerlink" title="4. 重新登录（使用自己的密码）"></a>4. 重新登录（使用自己的密码）</h3><p>在 MySQL 里输入：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exit;# 注意要一直输入直到退出到 Linux 的 shell 中，不要丢掉了分号结尾！！</span><br></pre></td></tr></table></figure><p>重新登录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p<span class="comment"># 这里再输入自己的密码，注意这里不回显。</span></span><br></pre></td></tr></table></figure><p>如果能成功进入 MySQL，就说明密码修改完成 🎉</p><h2 id="7-配置优化（可选）"><a href="#7-配置优化（可选）" class="headerlink" title="7. 配置优化（可选）"></a>7. 配置优化（可选）</h2><h3 id="1-修改配置文件"><a href="#1-修改配置文件" class="headerlink" title="1. 修改配置文件"></a>1. 修改配置文件</h3><p>可以使用 <code>vim /etc/my.cnf</code> 或者用 VS Code 进行修改，我们需要 <strong>调整字符集为 utf8mb4</strong>（防止后续中文或 emoji 出现乱码）以及一些其他设置，下面是完整文件内容，可以直接复制替换：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># For advice on how to change settings please see</span></span><br><span class="line"><span class="comment"># http://dev.mysql.com/doc/refman/8.0/en/server-configuration-defaults.html</span></span><br><span class="line"></span><br><span class="line"><span class="section">[mysqld]</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Remove leading # and set to the amount of RAM for the most important data</span></span><br><span class="line"><span class="comment"># cache in MySQL. Start at 70% of total RAM for dedicated server, else 10%.</span></span><br><span class="line"><span class="comment"># innodb_buffer_pool_size = 128M</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Remove the leading &quot;# &quot; to disable binary logging</span></span><br><span class="line"><span class="comment"># Binary logging captures changes between backups and is enabled by</span></span><br><span class="line"><span class="comment"># default. It&#x27;s default setting is log_bin=binlog</span></span><br><span class="line"><span class="comment"># disable_log_bin</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Remove leading # to set options mainly useful for reporting servers.</span></span><br><span class="line"><span class="comment"># The server defaults are faster for transactions and fast SELECTs.</span></span><br><span class="line"><span class="comment"># Adjust sizes as needed, experiment to find the optimal values.</span></span><br><span class="line"><span class="comment"># join_buffer_size = 128M</span></span><br><span class="line"><span class="comment"># sort_buffer_size = 2M</span></span><br><span class="line"><span class="comment"># read_rnd_buffer_size = 2M</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Remove leading # to revert to previous value for default_authentication_plugin,</span></span><br><span class="line"><span class="comment"># this will increase compatibility with older clients. For background, see:</span></span><br><span class="line"><span class="comment"># https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html#sysvar_default_authentication_plugin</span></span><br><span class="line"><span class="comment"># default-authentication-plugin=mysql_native_password</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据库存储目录</span></span><br><span class="line"><span class="attr">datadir</span>=/var/lib/mysql</span><br><span class="line"><span class="attr">socket</span>=/var/lib/mysql/mysql.sock</span><br><span class="line"></span><br><span class="line"><span class="comment"># 错误日志和 PID 文件</span></span><br><span class="line"><span class="attr">log-error</span>=/var/log/mysqld.log</span><br><span class="line"><span class="attr">pid-file</span>=/var/run/mysqld/mysqld.pid</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置默认字符集为 utf8mb4，避免中文和 emoji 乱码</span></span><br><span class="line"><span class="attr">character-set-server</span> = utf8mb4</span><br><span class="line"><span class="attr">collation-server</span>     = utf8mb4_general_ci</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开启远程访问（默认只允许本地连接）</span></span><br><span class="line"><span class="attr">bind-address</span> = <span class="number">0.0</span>.<span class="number">0.0</span></span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li><code>character-set-server = utf8mb4</code> → 设置服务端默认字符集为 utf8mb4。</li><li><code>collation-server = utf8mb4_general_ci</code> → 设置默认的排序规则，utf8mb4_general_ci 兼容性好，性能也不错。</li><li><code>bind-address = 0.0.0.0</code> → 默认 MySQL 只监听 127.0.0.1（只能本机访问），加上这行才能接受远程连接。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart mysqld<span class="comment"># 保存退出后，重启 MySQL</span></span><br><span class="line">systemctl status mysqld<span class="comment"># 再检查服务是否起来</span></span><br></pre></td></tr></table></figure><h3 id="2-port-3306-有必要写吗？"><a href="#2-port-3306-有必要写吗？" class="headerlink" title="2. port=3306 有必要写吗？"></a>2. <code>port=3306</code> 有必要写吗？</h3><p><strong>建议：不用额外写，保持默认，除非有特殊需求。MySQL 默认就是 3306，</strong> 我们可以添加字段 <code>port=3306</code>，也可以不添加。<strong>需要改的时候才写</strong>：如果你要跑多个实例，或者公司要求用非默认端口（比如 3307、13306），这时候才需要在 <code>my.cnf</code> 明确写 <code>port=xxx</code>（即 3306 可以自定义成其他值&#x2F;端口）。</p><h3 id="3-default-storage-engine-innodb-有必要吗？"><a href="#3-default-storage-engine-innodb-有必要吗？" class="headerlink" title="3. default-storage-engine=innodb 有必要吗？"></a>3. <code>default-storage-engine=innodb</code> 有必要吗？</h3><p><strong>MySQL 8.0 默认存储引擎就是 InnoDB</strong>，所以写不写效果一样。在 5.1、5.5 那个时代，MyISAM 还是默认引擎，所以 MySQL 5.7 左右的配置里常常会加这行，这里我们就不需要了。</p><h3 id="4-其他补充项"><a href="#4-其他补充项" class="headerlink" title="4. 其他补充项"></a>4. 其他补充项</h3><p><strong>优化项（根据机器内存调整），这里我们就跳过，依旧使用上面的可覆盖文件内容。</strong></p><ul><li><p><code>innodb_buffer_pool_size = 1G</code>（内存充足时设大一点）</p></li><li><p><code>max_connections = 200</code>（并发上限，根据业务调）</p></li><li><p>慢查询日志（调试优化时用）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">slow_query_log = 1</span><br><span class="line">slow_query_log_file = /var/log/mysql-slow.log</span><br><span class="line">long_query_time = 2</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="8-RPM-VS-YUM"><a href="#8-RPM-VS-YUM" class="headerlink" title="8. RPM VS YUM"></a>8. RPM VS YUM</h2><h3 id="1-RPM-是什么？"><a href="#1-RPM-是什么？" class="headerlink" title="1. RPM 是什么？"></a>1. RPM 是什么？</h3><p>RPM（RedHat Package Manager）&#x3D; <strong>一个软件的安装包</strong>。就像一个压缩文件，里面装着：</p><ul><li>可执行程序（比如 <code>/usr/sbin/mysqld</code>）</li><li>配置文件（比如 <code>/etc/my.cnf</code>）</li><li>安装说明（依赖、版本号、校验信息）</li></ul><p>我们可以直接用 <code>rpm -ivh xxx.rpm</code> 安装，就像手工解压+复制到系统目录。特点：只装这个包本身，不会自动去找依赖（比如你装 MySQL，缺少 libaio，它不会帮你装）。</p><h3 id="2-YUM-源是什么？"><a href="#2-YUM-源是什么？" class="headerlink" title="2. YUM 源是什么？"></a>2. YUM 源是什么？</h3><p>YUM（Yellowdog Updater, Modified）&#x3D; <strong>一个包管理工具</strong>。它的任务是：</p><ul><li>根据命令（<code>yum install mysql-community-server</code>），自动去找相应的 RPM 包；</li><li>如果缺少依赖，会自动从仓库里拉依赖包；</li><li>自动校验包的签名，保证安全；</li><li>还负责卸载、升级等操作。</li></ul><p>YUM 源（repo 文件）就是给 YUM 指路的「仓库地址清单」，告诉它：</p><ul><li>仓库的网址（http&#x2F;https 地址）</li><li>里面有哪些 RPM 包（比如 mysql-community-server、mysql-community-client）</li><li>用哪个 GPG key 校验</li></ul><p>特点：一条命令自动装好依赖，比手工 <code>rpm</code> 安全省心。</p><h3 id="3-RPM-与-YUM-源的关系"><a href="#3-RPM-与-YUM-源的关系" class="headerlink" title="3. RPM 与 YUM 源的关系"></a>3. RPM 与 YUM 源的关系</h3><ul><li><strong>RPM 包</strong> → 一个个软件快递盒子。</li><li><strong>YUM 源</strong> → 快递仓库的导航地图。</li><li><strong>我们做的事</strong>：<ol><li><code>rpm -ivh mysql-community-release-el7.rpm</code> → 装了一个「导航地图」（repo 文件），让 yum 知道 MySQL 仓库在哪里。</li><li><code>yum install mysql-community-server</code> → yum 拿着地图去官方仓库，把 MySQL 的 RPM 和依赖都搬到系统里装上。</li></ol></li></ul><h3 id="4-如果只用-RPM，不用-YUM-会怎样？"><a href="#4-如果只用-RPM，不用-YUM-会怎样？" class="headerlink" title="4. 如果只用 RPM，不用 YUM 会怎样？"></a>4. 如果只用 RPM，不用 YUM 会怎样？</h3><p>得自己一个个下载 RPM（server、client、libs、common、依赖库…），可能缺一个依赖包就报错，得再去手动找，过程麻烦，还容易遗漏。而用 YUM，只要源配置好：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y mysql-community-server</span><br></pre></td></tr></table></figure><p>它会自动把 <strong>server + client + libs + common + 依赖库</strong> 都装好。</p><blockquote><p><a href="https://yohifo.blog.csdn.net/article/details/134105001">MySQL 安装『适用于 CentOS 7』 | CSDN</a></p><p><a href="https://blog.csdn.net/weixin_51142926/article/details/145264878">MySQL：安装和 MySQL 基础 | CSDN</a></p></blockquote>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;在-CentOS-7-6-上从零安装并配置-MySQL-详细教程&quot;&gt;&lt;a href=&quot;#在-CentOS-7-6-上从零安装并配置-MySQL-详细教程&quot; class=&quot;headerlink&quot; title=&quot;在 CentOS 7.6 上从零安装并配置 MySQL</summary>
        
      
    
    
    
    <category term="MySQL" scheme="https://www.minbit.top/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="https://www.minbit.top/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>01 在 Ubuntu 22.04 上安装 MySQL</title>
    <link href="https://www.minbit.top/posts/42386.html"/>
    <id>https://www.minbit.top/posts/42386.html</id>
    <published>2025-09-04T16:00:00.000Z</published>
    <updated>2025-10-11T02:10:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="在-Ubuntu-22-04-上安装-MySQL"><a href="#在-Ubuntu-22-04-上安装-MySQL" class="headerlink" title="在 Ubuntu 22.04 上安装 MySQL"></a>在 Ubuntu 22.04 上安装 MySQL</h1><blockquote><p><span style="color:#FF0000;"><strong>安装前请切换至 root 账户！</strong></span></p></blockquote><h2 id="1-第一步：检查是否已安装-MySQL-MariaDB"><a href="#1-第一步：检查是否已安装-MySQL-MariaDB" class="headerlink" title="1. 第一步：检查是否已安装 MySQL &#x2F; MariaDB"></a>1. 第一步：检查是否已安装 MySQL &#x2F; MariaDB</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dpkg -l | grep -i mysql</span><br><span class="line">dpkg -l | grep -i mariadb</span><br></pre></td></tr></table></figure><p>如果有输出（比如 <code>mysql-common</code>, <code>mariadb-client-core</code> 等），建议清理。</p><h2 id="2-第二步：彻底卸载旧版本（安全执行，无残留）"><a href="#2-第二步：彻底卸载旧版本（安全执行，无残留）" class="headerlink" title="2. 第二步：彻底卸载旧版本（安全执行，无残留）"></a>2. 第二步：彻底卸载旧版本（安全执行，无残留）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 停止服务（如果存在）</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl stop mysql mariadb 2&gt;/dev/null</span><br><span class="line"></span><br><span class="line"><span class="comment"># 卸载所有相关包</span></span><br><span class="line"><span class="built_in">sudo</span> apt remove --purge mysql-server mysql-client mysql-common mysql-server-core-* mysql-client-core-* mariadb-client mariadb-server mariadb-common -y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清理依赖和配置</span></span><br><span class="line"><span class="built_in">sudo</span> apt autoremove -y</span><br><span class="line"><span class="built_in">sudo</span> apt autoclean</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除残留数据目录（谨慎！确保无重要数据）</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">rm</span> -rf /etc/mysql /var/lib/mysql</span><br></pre></td></tr></table></figure><blockquote><p><strong>如果你 100% 确定是全新系统，这步可跳过，但执行也无害（没东西可删）。</strong></p></blockquote><h2 id="3-第三步：安装-MySQL-8-0（Ubuntu-22-04-24-04-默认就是-8-0-43-）"><a href="#3-第三步：安装-MySQL-8-0（Ubuntu-22-04-24-04-默认就是-8-0-43-）" class="headerlink" title="3. 第三步：安装 MySQL 8.0（Ubuntu 22.04&#x2F;24.04 默认就是 8.0.43+）"></a>3. 第三步：安装 MySQL 8.0（Ubuntu 22.04&#x2F;24.04 默认就是 8.0.43+）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt install mysql-server -y</span><br></pre></td></tr></table></figure><p>Ubuntu 22.04 默认装 <strong>8.0.39~8.0.43</strong>，24.04 可能更高（如 8.0.39+），都属于 <strong>MySQL 8.0 系列</strong>，完全符合企业主流。</p><h2 id="4-第四步：安全加固（必须做！）"><a href="#4-第四步：安全加固（必须做！）" class="headerlink" title="4. 第四步：安全加固（必须做！）"></a>4. 第四步：安全加固（必须做！）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> mysql_secure_installation</span><br></pre></td></tr></table></figure><p>按提示：</p><ul><li><strong>是否启用密码强度验证？ → 作为初学者直接选 n。</strong> 选 y 就表示要强制高强度密码，如果太弱（如 123456），MySQL 会 <strong>拒绝接受</strong>。</li><li>然后依次问是否 <strong>（全 y）</strong>：<ul><li>删除匿名用户？ → <strong>选 y</strong>。</li><li>禁止 root 远程登录？ → <strong>选 y</strong>。</li><li>删除 test 数据库？ → <strong>选 y</strong>。</li><li>重载权限表？ → <strong>选 y</strong>。</li></ul></li></ul><h2 id="5-第五步：自定义密码"><a href="#5-第五步：自定义密码" class="headerlink" title="5. 第五步：自定义密码"></a>5. 第五步：自定义密码</h2><blockquote><p>为什么没让设置 root 密码？</p><p>因为 Ubuntu 的 MySQL 包默认使用 <strong><code>auth_socket</code> 插件</strong>（也叫 <code>unix_socket</code>）进行认证，而不是密码。<strong><code>auth_socket</code> 是什么？</strong> 它允许 <strong>系统用户 <code>root</code> 直接通过 <code>sudo mysql</code> 无密码登录 MySQL</strong>，前提是你是 Linux 的 root 用户。</p><p>所以：<strong>MySQL 的 root 用户并没有密码</strong>，而是“信任”系统 root。这就是为什么 <code>mysql_secure_installation</code> 里跳过了设密码步骤，并提示：<em>“Skipping password set for root as authentication with auth_socket is used by default.”</em></p></blockquote><p>如果希望像传统方式那样用 <code>mysql -u root -p</code> 输入密码登录，需要手动改认证方式：</p><h3 id="1-步骤-1：用-socket-方式登录（无需密码）"><a href="#1-步骤-1：用-socket-方式登录（无需密码）" class="headerlink" title="1. 步骤 1：用 socket 方式登录（无需密码）"></a>1. 步骤 1：用 socket 方式登录（无需密码）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> mysql</span><br></pre></td></tr></table></figure><h3 id="2-步骤-2：修改-root-用户为密码认证"><a href="#2-步骤-2：修改-root-用户为密码认证" class="headerlink" title="2. 步骤 2：修改 root 用户为密码认证"></a>2. 步骤 2：修改 root 用户为密码认证</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看当前 root 用户的认证方式</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">user</span>, host, plugin <span class="keyword">FROM</span> mysql.user;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 将 root@localhost 改为密码认证（MySQL 8.0 默认插件是 caching_sha2_password）</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;你的强密码&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 刷新权限</span></span><br><span class="line">FLUSH PRIVILEGES;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 退出</span></span><br><span class="line">EXIT;</span><br></pre></td></tr></table></figure><blockquote><p><strong>把 <code>&#39;你的强密码&#39;</code> 换成你自己的密码，比如 <code>&#39;MyRootPass123!&#39;</code>。</strong></p></blockquote><h3 id="3-步骤-3：验证密码登录"><a href="#3-步骤-3：验证密码登录" class="headerlink" title="3. 步骤 3：验证密码登录"></a>3. 步骤 3：验证密码登录</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure><p>输入刚设的密码，就能成功登录。</p><h2 id="6-第六步：配置"><a href="#6-第六步：配置" class="headerlink" title="6. 第六步：配置"></a>6. 第六步：配置</h2><p>修改文件：<code>/etc/mysql/mysql.conf.d/mysqld.cnf</code> 内容（这是主配置文件），下面给出文件全部配置，可直接进行覆盖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">#</span><br><span class="line"># The MySQL database server configuration file.</span><br><span class="line">#</span><br><span class="line"># One can use all long options that the program supports.</span><br><span class="line"># Run program with --help to get a list of available options and with</span><br><span class="line"># --print-defaults to see which it would actually understand and use.</span><br><span class="line">#</span><br><span class="line"># For explanations see</span><br><span class="line"># http://dev.mysql.com/doc/mysql/en/server-system-variables.html</span><br><span class="line"></span><br><span class="line"># Here is entries for some specific programs</span><br><span class="line"># The following values assume you have at least 32M ram</span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line">#</span><br><span class="line"># * Basic Settings</span><br><span class="line">#</span><br><span class="line">user= mysql</span><br><span class="line"># pid-file= /var/run/mysqld/mysqld.pid</span><br><span class="line"># socket= /var/run/mysqld/mysqld.sock</span><br><span class="line"># port= 3306</span><br><span class="line"># datadir= /var/lib/mysql</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># If MySQL is running as a replication slave, this should be</span><br><span class="line"># changed. Ref https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html#sysvar_tmpdir</span><br><span class="line"># tmpdir= /tmp</span><br><span class="line">#</span><br><span class="line"># Instead of skip-networking the default is now to listen only on</span><br><span class="line"># localhost which is more compatible and is not less secure.</span><br><span class="line">bind-address= 127.0.0.1</span><br><span class="line">mysqlx-bind-address= 127.0.0.1</span><br><span class="line"></span><br><span class="line"># ===== 自定义扩展配置 =====</span><br><span class="line"># 设置默认字符集为 utf8mb4，防止中文和 emoji 乱码</span><br><span class="line">character-set-server = utf8mb4</span><br><span class="line">collation-server     = utf8mb4_general_ci</span><br><span class="line"></span><br><span class="line"># 启用远程访问（默认仅本机），保持仅本地访问（通过 Xshell 登录服务器再操作）可将 0.0.0.0 设置为 127.0.0.1</span><br><span class="line">bind-address         = 0.0.0.0</span><br><span class="line">mysqlx-bind-address  = 0.0.0.0</span><br><span class="line"></span><br><span class="line"># 使用传统认证插件，兼容 Navicat、旧版客户端</span><br><span class="line">default-authentication-plugin = mysql_native_password</span><br><span class="line"></span><br><span class="line"># 可选：增加连接稳定性</span><br><span class="line"># max_connections = 200</span><br><span class="line"># wait_timeout = 600</span><br><span class="line"># interactive_timeout = 600</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># * Fine Tuning</span><br><span class="line">#</span><br><span class="line">key_buffer_size= 16M</span><br><span class="line"># max_allowed_packet= 64M</span><br><span class="line"># thread_stack= 256K</span><br><span class="line"></span><br><span class="line"># thread_cache_size       = -1</span><br><span class="line"></span><br><span class="line"># This replaces the startup script and checks MyISAM tables if needed</span><br><span class="line"># the first time they are touched</span><br><span class="line">myisam-recover-options  = BACKUP</span><br><span class="line"></span><br><span class="line"># max_connections        = 151</span><br><span class="line"></span><br><span class="line"># table_open_cache       = 4000</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># * Logging and Replication</span><br><span class="line">#</span><br><span class="line"># Both location gets rotated by the cronjob.</span><br><span class="line">#</span><br><span class="line"># Log all queries</span><br><span class="line"># Be aware that this log type is a performance killer.</span><br><span class="line"># general_log_file        = /var/log/mysql/query.log</span><br><span class="line"># general_log             = 1</span><br><span class="line">#</span><br><span class="line"># Error log - should be very few entries.</span><br><span class="line">#</span><br><span class="line">log_error = /var/log/mysql/error.log</span><br><span class="line">#</span><br><span class="line"># Here you can see queries with especially long duration</span><br><span class="line"># slow_query_log= 1</span><br><span class="line"># slow_query_log_file= /var/log/mysql/mysql-slow.log</span><br><span class="line"># long_query_time = 2</span><br><span class="line"># log-queries-not-using-indexes</span><br><span class="line">#</span><br><span class="line"># The following can be used as easy to replay backup logs or for replication.</span><br><span class="line"># note: if you are setting up a replication slave, see README.Debian about</span><br><span class="line">#       other settings you may need to change.</span><br><span class="line"># server-id= 1</span><br><span class="line"># log_bin= /var/log/mysql/mysql-bin.log</span><br><span class="line"># binlog_expire_logs_seconds= 2592000</span><br><span class="line">max_binlog_size   = 100M</span><br><span class="line"># binlog_do_db= include_database_name</span><br><span class="line"># binlog_ignore_db= include_database_name</span><br></pre></td></tr></table></figure><p>保存后重启服务让配置生效：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl restart mysql</span><br><span class="line"><span class="built_in">sudo</span> systemctl status mysql</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;在-Ubuntu-22-04-上安装-MySQL&quot;&gt;&lt;a href=&quot;#在-Ubuntu-22-04-上安装-MySQL&quot; class=&quot;headerlink&quot; title=&quot;在 Ubuntu 22.04 上安装 MySQL&quot;&gt;&lt;/a&gt;在 Ubuntu</summary>
        
      
    
    
    
    <category term="MySQL" scheme="https://www.minbit.top/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="https://www.minbit.top/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>049 HTTPS 协议原理</title>
    <link href="https://www.minbit.top/posts/34998.html"/>
    <id>https://www.minbit.top/posts/34998.html</id>
    <published>2025-08-28T04:00:00.000Z</published>
    <updated>2025-08-28T04:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HTTPS-协议原理"><a href="#HTTPS-协议原理" class="headerlink" title="HTTPS 协议原理"></a>HTTPS 协议原理</h1><blockquote><p><a href="https://blog.csdn.net/weixin_51142926/article/details/143697206">Linux：HTTPS 协议原理 | CSDN（荐）</a></p><p><a href="https://blog.csdn.net/2402_83315537/article/details/147430000">LINUX 网络基础 [六] - HTTPS 协议 | CSDN</a></p></blockquote><p>先简单回顾一下 TCP&#x2F;IP 四层模型（视频剩余部分可作为了解）：<a href="https://www.bilibili.com/video/BV1Wf4y1E7qs/?share_source=copy_web&vd_source=872e5e3ccf44874c39edaf42e30ab0de">http 和 https 有什么区别吗？(SSL 协议) | B 站</a>。</p><h2 id="1-概念准备"><a href="#1-概念准备" class="headerlink" title="1. 概念准备"></a>1. 概念准备</h2><h3 id="1-HTTPS-是什么？"><a href="#1-HTTPS-是什么？" class="headerlink" title="1. HTTPS 是什么？"></a>1. HTTPS 是什么？</h3><p>HTTPS（HyperText Transfer Protocol Secure）是一个 <strong>应用层协议</strong>，可以理解为是 HTTP 协议的“安全版”。</p><ul><li><strong>核心区别</strong>：在 HTTP 协议的基础上引入了一个 <strong>加密层</strong>。</li><li><strong>原因</strong>：标准的 HTTP 协议是 <strong>明文传输</strong> 的，这意味着传输的数据（如账号、密码、个人信息）在经过路由器、运营商等网络设备时，很容易被“劫持”或“篡改”（例如“运营商劫持”下载链接）。</li><li><strong>目的</strong>：通过加密，保证用户的信息安全，防止数据在传输过程中被窃取或篡改。</li></ul><h3 id="2-什么是加密？"><a href="#2-什么是加密？" class="headerlink" title="2. 什么是加密？"></a>2. 什么是加密？</h3><ul><li><strong>加密</strong>：将要传输的原始信息（称为 <strong>明文</strong>）通过一系列数学变换，生成一段不可读的、看似随机的文本（称为 <strong>密文</strong>）的过程。</li><li><strong>解密</strong>：将 <strong>密文</strong> 通过一系列变换，还原成原始 <strong>明文</strong> 的过程。</li><li><strong><a href="https://baike.baidu.com/item/%E5%AF%86%E9%92%A5/101144?fromModule=lemma_inlink">密钥</a></strong>：在加密和解密过程中，需要用到一个或多个关键数据，这个数据就叫做 <strong>密钥</strong>。它是加密算法的核心，决定了加密和解密的具体方式。</li></ul><h3 id="3-为什么要加密？"><a href="#3-为什么要加密？" class="headerlink" title="3. 为什么要加密？"></a>3. 为什么要加密？</h3><p>主要原因是为了应对网络传输中的安全威胁，特别是 <strong>中间人攻击（Man-in-the-Middle Attack, 简称 MITM 攻击）</strong>。</p><ul><li><strong>明文传输的风险</strong>：HTTP 的明文数据在传输过程中会经过多个物理节点（路由器、运营商等）。任何能接触到这些节点的人都可以 <strong>窃取</strong> 我们的隐私信息（如登录密码、支付信息），甚至可以 <strong>篡改</strong> 传输的内容（如将运营商设备篡改下载链接等等）。</li><li><strong>加密的作用</strong>：通过对信息进行加密，即使数据被劫持，黑客看到的也只是无法理解的密文，从而保护了信息的机密性和完整性。</li></ul><h3 id="4-常见的加密方式"><a href="#4-常见的加密方式" class="headerlink" title="4. 常见的加密方式"></a>4. 常见的加密方式</h3><blockquote><p>下面这些视频我认为讲的非常好，虽然标题各式各样的，但是内容和我们要讲的基本一致，超出的知识就当扩展了，<strong>如果后面的文字讲解难懂，建议先看视频</strong> 👉：</p><p><a href="https://www.bilibili.com/video/BV1RT411272Y/?share_source=copy_web&vd_source=872e5e3ccf44874c39edaf42e30ab0de">HTTPS 是什么?原理是什么？用公钥加密为什么不能用公钥解密？ | B 站</a></p><p><a href="https://www.bilibili.com/video/BV1KY411x7Jp/?share_source=copy_web&vd_source=872e5e3ccf44874c39edaf42e30ab0de">HTTPS 是什么？加密原理和证书。SSL&#x2F;TLS 握手过程 | B 站</a></p><p><a href="https://www.bilibili.com/video/BV1P5k3YHEGo/?share_source=copy_web&vd_source=872e5e3ccf44874c39edaf42e30ab0de">HTTPS 真的安全吗，一个动画秒懂！ | B 站</a></p><p><a href="https://www.bilibili.com/video/BV1tAKozuEkd/?share_source=copy_web&vd_source=872e5e3ccf44874c39edaf42e30ab0de">白话 HTTPS，如何在全世界的眼皮子底下安全密谋？ | B 站</a></p><p><a href="https://www.bilibili.com/video/BV1w7ADeLEPE/?share_source=copy_web&vd_source=872e5e3ccf44874c39edaf42e30ab0de">https 真安全么？ 抓包解密 https 的两种原理+实战  开源软件 mitmproxy 与 wireshark 如何抓包 https | B 站</a></p><p><a href="https://www.bilibili.com/video/BV1mj421d7VE/?share_source=copy_web&vd_source=872e5e3ccf44874c39edaf42e30ab0de">数字签名和 CA 数字证书的核心原理和作用 B 站</a></p><p><a href="https://www.bilibili.com/video/BV1FX4y1C76v/?share_source=copy_web&vd_source=872e5e3ccf44874c39edaf42e30ab0de">12 分钟弄懂 HTTPS 概念与原理 &#x2F; HTTPS 入门教程 | B 站</a></p></blockquote><h4 id="1-对称加密"><a href="#1-对称加密" class="headerlink" title="1. 对称加密"></a>1. 对称加密</h4><ul><li><strong>原理</strong>：使用 <strong>同一个密钥</strong> 进行加密和解密。这个密钥必须由通信双方共同持有。</li><li><strong>特点</strong>：<ul><li><strong>优点</strong>：算法公开、计算量小、<strong>加密速度快、效率高</strong>。</li><li><strong>缺点</strong>：最大的问题是 <strong>密钥的分发</strong>。如何安全地把这个“共享密钥”告诉对方？如果通过网络明文传输密钥，那么密钥本身就会被截获，整个加密就形同虚设。</li></ul></li><li><strong>常见算法</strong>：DES、3DES、AES 等。</li><li><strong>简单示例</strong>：按位异或（XOR）操作。用密钥 <code>key</code> 对明文 <code>a</code> 加密得到密文 <code>b</code>（<code>a ^ key = b</code>），再用同一个密钥 <code>key</code> 对密文 <code>b</code> 解密就能得到明文 <code>a</code>（<code>b ^ key = a</code>）。</li></ul><h4 id="2-非对称加密"><a href="#2-非对称加密" class="headerlink" title="2. 非对称加密"></a>2. 非对称加密</h4><ul><li><strong>原理</strong>：使用 <strong>一对</strong> 密钥，一个 **公钥 ** 和一个 <strong>私钥</strong>。公钥和私钥是成对生成的，它们之间有特殊的数学关系。</li><li><strong>工作方式</strong>：<ul><li>用 <strong>公钥</strong> 加密，只能用对应的 <strong>私钥</strong> 解密。</li><li>用 <strong>私钥</strong> 加密（这通常称为“签名”），只能用对应的 <strong>公钥</strong> 解密（这通常称为“验证”）。</li></ul></li><li><strong>特点</strong>：<ul><li><strong>优点</strong>：解决了密钥分发问题。公钥可以公开给任何人，而私钥自己严格保密。即使公钥被截获，没有私钥也无法解密。</li><li><strong>缺点</strong>：算法复杂，<strong>加密和解密速度比对称加密慢很多</strong>。</li></ul></li><li><strong>常见算法</strong>：RSA、DSA、ECDSA 等。</li><li><strong>生活中的例子</strong>：公钥就像一把 <strong>锁</strong>，可以公开分发。任何人想给你发秘密文件，就把文件放进盒子并用这把“锁”锁上。只有你拥有对应的“钥匙”（私钥），才能打开盒子取出文件。</li></ul><h4 id="3-数据摘要-数据指纹"><a href="#3-数据摘要-数据指纹" class="headerlink" title="3. 数据摘要 &amp;&amp; 数据指纹"></a>3. 数据摘要 &amp;&amp; 数据指纹</h4><blockquote><p><strong>摘要</strong> 就是把 <strong>任意长度的数据</strong>，通过 <strong>Hash 函数</strong> 变成一个 <strong>定长的“指纹”或“身份证”（对原始数据进行单向哈希运算后得到的一串固定长度的字符串）</strong>，能用来验证数据完整性；数据指纹类似，也是通过算法提取数据特征，可用于识别和区分不同数据，它们都像数据的独特 “标识”。</p><p><strong>数据摘要的特点：</strong></p><ul><li><strong>不可逆</strong>：从摘要推不回原文。</li><li><strong>雪崩效应</strong>：原文哪怕改 1 个字节，摘要都会完全不同。</li><li><strong>长度固定</strong>：无论原文多大，都能快速生成摘要，摘要结果都是固定长度（比如 256 位）。</li><li><strong>确定性</strong>：相同输入 → 相同输出。</li><li><strong>抗碰撞性</strong>：极难找到两个不同内容生成相同摘要（防伪造）。</li></ul><p><strong>数据摘要可以理解为：原文 &#x3D; 一大堆内容，摘要 &#x3D; “身份证号” 或 “指纹”（唯一标识这个内容，改了就对不上）。</strong></p></blockquote><ul><li><strong>原理</strong>：利用 <strong>单向散列函数</strong>（Hash 函数，如 <a href="https://zh.wikipedia.org/wiki/MD5"><strong>MD5</strong></a>、SHA1、SHA256）对任意长度的数据进行计算，生成一个 <strong>固定长度</strong> 的、唯一的“数字指纹”或“摘要”。</li><li><strong>关键特性</strong>：<ul><li><strong>定长</strong>：无论输入多长，输出的摘要长度是固定的。</li><li><strong>分散</strong>：输入数据哪怕只改变一个比特，生成的摘要也会发生巨大变化。</li><li><strong>不可逆</strong>：无法从摘要反推出原始数据。</li><li><strong>防碰撞</strong>：理论上不同的数据可能产生相同的摘要（碰撞），但概率极低。</li></ul></li><li><strong>用途</strong>：<strong>严格来说，这不是加密</strong>，因为它没有解密过程。它主要用于 <strong>验证数据的完整性</strong>。接收方可以自己计算收到数据的摘要，然后与发送方提供的摘要进行比对。如果一致，说明数据在传输过程中没有被篡改。</li></ul><h4 id="4-数字签名（后面细说）"><a href="#4-数字签名（后面细说）" class="headerlink" title="4. 数字签名（后面细说）"></a>4. 数字签名（后面细说）</h4><ul><li><strong>原理</strong>：数字签名 &#x3D; <strong>数据摘要 + 非对称加密</strong>。<ol><li>对原始数据（明文）计算一个 <strong>数据摘要</strong>。</li><li>使用发送方的 <strong>私钥</strong> 对这个 <strong>摘要</strong> 进行加密，得到的结果就是 <strong>数字签名</strong>。</li></ol></li><li><strong>验证过程</strong>：<ol><li>接收方收到原始数据和数字签名。</li><li>用发送方的 <strong>公钥</strong> 解密数字签名，得到一个摘要值（我们称之为 <code>摘要A</code>）。</li><li>接收方自己用相同的哈希算法对收到的原始数据计算摘要（我们称之为 <code>摘要B</code>）。</li><li>比较 <code>摘要A</code> 和 <code>摘要B</code>。如果相等，则说明：<ul><li><strong>数据完整性</strong>：数据未被篡改（因为摘要匹配）。</li><li><strong>身份认证</strong>：签名确实是由持有对应私钥的人生成的（因为只有他的公钥才能成功解密）。</li></ul></li></ol></li><li><strong>作用</strong>：数字签名解决了“<strong>我是谁</strong>”和“<strong>内容是否被改过</strong>”的问题。</li></ul><hr><h2 id="2-HTTPS-的-5-种方案探究"><a href="#2-HTTPS-的-5-种方案探究" class="headerlink" title="2. HTTPS 的 5 种方案探究"></a>2. HTTPS 的 5 种方案探究</h2><blockquote><ul><li><p><strong>对称加密</strong>：加密和解密使用同一个密钥。速度快，适合大量数据加密。</p></li><li><p><strong>非对称加密</strong>：有一对密钥 —— 公钥（可公开）和私钥（必须保密）。公钥加密的数据，只有私钥能解密；私钥签名的数据，公钥可验证。优点：不怕公钥被截获；缺点：速度慢，不适合大数据加密。</p></li><li><p><strong>中间人攻击（MITM）</strong>：攻击者在通信双方中间截获、篡改、伪造信息。</p></li></ul></blockquote><h3 id="方案-1：只使用对称加密"><a href="#方案-1：只使用对称加密" class="headerlink" title="方案 1：只使用对称加密"></a>方案 1：只使用对称加密</h3><h4 id="1-场景"><a href="#1-场景" class="headerlink" title="1. 场景"></a>1. 场景</h4><p>客户端和服务器约定用同一个密钥（比如 “123456”）来加密通信。</p><h4 id="2-密钥如何传输？"><a href="#2-密钥如何传输？" class="headerlink" title="2. 密钥如何传输？"></a>2. 密钥如何传输？</h4><p>必须提前“共享”密钥。比如：客户端和服务器事先约定好密钥（不现实，互联网用户千千万），或者，客户端第一次访问时，服务器“明文发送”密钥给客户端。</p><h4 id="3-风险在哪里？"><a href="#3-风险在哪里？" class="headerlink" title="3. 风险在哪里？"></a>3. 风险在哪里？</h4><p><strong>密钥在传输过程中被截获！</strong> 比如：客户端请求：“请给我密钥”，服务器回复：“密钥是 123456” ← 被黑客监听到，之后所有通信，黑客用 123456 解密 → <strong>完全裸奔！</strong></p><h4 id="4-产生的问题"><a href="#4-产生的问题" class="headerlink" title="4. 产生的问题"></a>4. 产生的问题</h4><p>密钥无法安全传递（除非物理见面，不现实），每个用户都要不同密钥？服务器怎么管理？一旦密钥泄露，所有通信都暴露。</p><blockquote><p> 就像我们和朋友约好用同一把钥匙开保险箱，但我们必须先把钥匙寄给他 —— 快递员（黑客）偷了钥匙，就能开你的保险箱。</p></blockquote><h3 id="方案-2：只使用非对称加密"><a href="#方案-2：只使用非对称加密" class="headerlink" title="方案 2：只使用非对称加密"></a>方案 2：只使用非对称加密</h3><h4 id="1-场景-1"><a href="#1-场景-1" class="headerlink" title="1. 场景"></a>1. 场景</h4><p>服务器有公钥和私钥。客户端用服务器的公钥加密数据，服务器用自己的私钥解密。</p><h4 id="2-密钥如何传输？-1"><a href="#2-密钥如何传输？-1" class="headerlink" title="2. 密钥如何传输？"></a>2. 密钥如何传输？</h4><p>服务器把自己的 <strong>公钥</strong> 发给客户端（公钥不怕被截获）→ 客户端用公钥加密数据 → 服务器用私钥解密。</p><h4 id="3-风险在哪里？-1"><a href="#3-风险在哪里？-1" class="headerlink" title="3. 风险在哪里？"></a>3. 风险在哪里？</h4><p><strong>性能问题 + 无法双向加密：</strong></p><ol><li><strong>性能极差</strong>：非对称加密计算量大，传个网页都要几秒，用户体验爆炸。</li><li><strong>服务器无法加密发给客户端</strong>：客户端没有私钥，服务器如果想加密数据发给客户端，必须知道客户端的公钥 —— 但客户端没有公私钥对！如果让客户端也生成公私钥，那就变成方案 3 了。</li></ol><blockquote><p>就像每次寄信都要用特制保险箱（非对称加密），寄一封信要花 10 分钟打包，收件人还要花 10 分钟拆 —— 寄 100 封信？系统崩溃！</p></blockquote><h3 id="方案-3：双方都使用非对称加密"><a href="#方案-3：双方都使用非对称加密" class="headerlink" title="方案 3：双方都使用非对称加密"></a>方案 3：双方都使用非对称加密</h3><h4 id="1-场景-2"><a href="#1-场景-2" class="headerlink" title="1. 场景"></a>1. 场景</h4><p>客户端和服务器各自生成自己的公私钥对。互相交换公钥，然后用对方的公钥加密数据发给对方。</p><h4 id="2-密钥如何传输？-2"><a href="#2-密钥如何传输？-2" class="headerlink" title="2. 密钥如何传输？"></a>2. 密钥如何传输？</h4><p>客户端生成公私钥，把公钥发给服务器 → 服务器生成公私钥，把公钥发给客户端 → 双方用对方公钥加密，用自己的私钥解密。</p><h4 id="3-风险在哪里？-2"><a href="#3-风险在哪里？-2" class="headerlink" title="3. 风险在哪里？"></a>3. 风险在哪里？</h4><p><strong>中间人攻击（MITM）！</strong> 黑客可以这样干：</p><ol><li>客户端 → “我要和服务器通信，请给我公钥”。</li><li>黑客截获，伪造自己是服务器，把自己的公钥发给客户端。</li><li>客户端 → 用“假公钥”加密数据 → 黑客收到后用自己的私钥解密 → 再用真服务器的公钥加密转发。</li><li>服务器 → 回复，黑客同样截获 → 用客户端的假公钥加密再发回去。</li></ol><p><strong>客户端和服务器以为在安全通信，其实所有数据都被黑客看到并转发！</strong></p><h4 id="4-产生的问题-1"><a href="#4-产生的问题-1" class="headerlink" title="4. 产生的问题"></a>4. 产生的问题</h4><ul><li>无法确认“公钥是谁的” —— 公钥被掉包都不知道！  </li><li>性能依然差（非对称加密慢）  </li><li>管理复杂（每个会话都要生成密钥对）</li></ul><blockquote><p>就像我们和朋友交换“加密信箱钥匙”，但快递员偷偷把自己的钥匙塞给我们，说“这是我朋友的”。我寄信给他，他全都能看，再模仿我朋友回信 —— 我们完全被蒙在鼓里！</p></blockquote><h3 id="方案-4：非对称加密-对称加密（混合方案）"><a href="#方案-4：非对称加密-对称加密（混合方案）" class="headerlink" title="方案 4：非对称加密 + 对称加密（混合方案）"></a>方案 4：非对称加密 + 对称加密（混合方案）</h3><blockquote><p>方案 4 在 TLS 1.2 里常见，但 TLS 1.3 已经弃用。现在都用 ECDHE（椭圆曲线 Diffie-Hellman Ephemeral） 做 密钥协商，这样即使服务器长期私钥泄露，历史流量也解不开（前向保密）。换句话说：<strong>对称密钥不是传输过来的，而是双方独立算出来的。</strong></p></blockquote><h4 id="1-场景-3"><a href="#1-场景-3" class="headerlink" title="1. 场景"></a>1. 场景</h4><p>用非对称加密来 <strong>安全传递对称密钥</strong>，之后用对称密钥加密通信数据。</p><h4 id="2-密钥如何传输？-3"><a href="#2-密钥如何传输？-3" class="headerlink" title="2. 密钥如何传输？"></a>2. 密钥如何传输？</h4><ol><li>客户端连接服务器，服务器发送自己的 <strong>公钥</strong>（比如通过证书）  </li><li>客户端生成一个随机的 <strong>对称密钥</strong>（如 AES 密钥）  </li><li>客户端用服务器的 <strong>公钥</strong> 加密这个对称密钥 → 发送给服务器  </li><li>服务器用自己的 <strong>私钥</strong> 解密 → 得到对称密钥  </li><li>之后所有通信，都用这个对称密钥加密&#x2F;解密！</li></ol><h4 id="3-风险在哪里？-3"><a href="#3-风险在哪里？-3" class="headerlink" title="3. 风险在哪里？"></a>3. 风险在哪里？</h4><p><strong>如果公钥是假的，对称密钥就会被黑客截获！</strong> 还是中间人攻击：</p><ol><li>黑客伪造服务器，把自己的公钥发给客户端  </li><li>客户端生成对称密钥，用“假公钥”加密 → 黑客用自己的私钥解密 → 得到真实对称密钥  </li><li>黑客再用真服务器的公钥加密对称密钥发给服务器  </li><li>之后所有通信，黑客都能用对称密钥解密！</li></ol><p><strong>问题根源：客户端无法确认收到的公钥是不是真的属于目标服务器！</strong></p><h4 id="4-优缺点"><a href="#4-优缺点" class="headerlink" title="4. 优缺点"></a>4. 优缺点</h4><ol><li><p>优点：</p><ul><li><p>对称加密快，适合大数据  </p></li><li><p>非对称只用于传密钥，计算量小</p></li></ul></li><li><p>缺点：</p><ul><li>公钥真实性无法保证 → 需要“身份认证”</li></ul></li></ol><blockquote><p>就像我们用防弹车（非对称加密）把保险箱钥匙（对称密钥）送到朋友家，但送错了地址（假服务器），钥匙被坏人拿到，之后我们寄的所有东西他都能打开！</p></blockquote><h3 id="方案-5（最终方案）非对称加密-对称加密-数字证书（HTTPS-真实方案）"><a href="#方案-5（最终方案）非对称加密-对称加密-数字证书（HTTPS-真实方案）" class="headerlink" title="方案 5（最终方案）非对称加密 + 对称加密 + 数字证书（HTTPS 真实方案）"></a>方案 5（最终方案）非对称加密 + 对称加密 + 数字证书（HTTPS 真实方案）</h3><h4 id="1-场景-4"><a href="#1-场景-4" class="headerlink" title="1. 场景"></a>1. 场景</h4><p>在方案 4 基础上，加入 <strong>数字证书</strong> 来验证服务器公钥的真实性！</p><h4 id="2-密钥如何传输？-4"><a href="#2-密钥如何传输？-4" class="headerlink" title="2. 密钥如何传输？"></a>2. 密钥如何传输？</h4><ol><li><strong>客户端发起 HTTPS 请求</strong> → 服务器返回 <strong>数字证书</strong>（包含服务器公钥 + 服务器身份信息 + <a href="https://zh.wikipedia.org/wiki/%E8%AF%81%E4%B9%A6%E9%A2%81%E5%8F%91%E6%9C%BA%E6%9E%84">CA</a> 签名）  </li><li><strong>客户端验证证书</strong>：<ul><li>用操作系统&#x2F;浏览器内置的 <strong>CA 公钥</strong> 验证证书签名是否合法  </li><li>检查证书是否过期、域名是否匹配等 → 如果验证失败，浏览器弹出警告</li></ul></li><li><strong>客户端生成随机对称密钥</strong>（如 AES-256）  </li><li><strong>客户端用证书里的服务器公钥加密对称密钥</strong> → 发送给服务器  </li><li><strong>服务器用自己的私钥解密</strong> → 得到对称密钥  </li><li><strong>之后所有通信都用对称密钥加密</strong>（高效、安全）</li></ol><h4 id="3-如何防御中间人攻击？"><a href="#3-如何防御中间人攻击？" class="headerlink" title="3. 如何防御中间人攻击？"></a>3. 如何防御中间人攻击？</h4><p><strong>数字证书由可信第三方（CA）签名</strong>，黑客无法伪造合法证书！黑客即使拦截通信，也无法伪造一个被 CA 签名的证书（除非攻破 CA，极难），客户端会校验证书，发现域名不符或签名无效 → 直接终止连接！</p><h4 id="4-补充安全机制（了解）"><a href="#4-补充安全机制（了解）" class="headerlink" title="4. 补充安全机制（了解）"></a>4. 补充安全机制（了解）</h4><ul><li><strong>前向保密（PFS）</strong>：每次会话生成临时密钥，即使服务器私钥未来泄露，历史会话也无法解密。（通过 ECDHE 等密钥交换算法实现）  </li><li><strong>证书吊销机制（CRL&#x2F;OCSP）</strong>：应对私钥泄露或证书被盗用。</li></ul><hr><h3 id="6-小结"><a href="#6-小结" class="headerlink" title="6. 小结"></a>6. 小结</h3><table><thead><tr><th>方案</th><th>加密方式</th><th>密钥传输方式</th><th>主要风险</th><th>是否可行</th></tr></thead><tbody><tr><td>方案 1</td><td>对称加密</td><td>明文传输或预共享</td><td>密钥被截获 → 全部暴露</td><td>❌ 不可行</td></tr><tr><td>方案 2</td><td>非对称加密</td><td>公钥公开传输</td><td>性能差 + 无法双向加密</td><td>❌ 不实用</td></tr><tr><td>方案 3</td><td>双方非对称</td><td>交换公钥</td><td>中间人攻击（公钥被替换&#x2F;掉包）</td><td>❌ 不安全</td></tr><tr><td>方案 4</td><td>非对称+对称（混合加密）</td><td>用公钥加密对称密钥</td><td>中间人攻击（公钥未认证，MITM 截获）</td><td>⚠️ 有漏洞</td></tr><tr><td>最终方案</td><td>混合 + 证书</td><td>用认证公钥加密对称密钥</td><td>依赖 CA 体系保障（极少数被攻破案例）</td><td>✅ 安全高效</td></tr></tbody></table><blockquote><p>之前看到的一个很形象、易理解的比喻：想象你要和朋友安全通信：</p><ul><li><strong>方案 1</strong>：你俩约好用同一把钥匙，但你得先寄给他 → 快递员偷了钥匙 → 完蛋。  </li><li><strong>方案 2</strong>：每次说话都用特制密码机，太慢 → 聊两句就卡死。  </li><li><strong>方案 3</strong>：你俩交换密码机的“公开使用说明”，但快递员把自己的说明书冒充你朋友的 → 你按他的说明书操作，他在偷听。  </li><li><strong>方案 4</strong>：你寄一把普通钥匙，但用朋友的“防伪密码箱”寄 → 但如果“防伪密码箱”是假的（快递员给的），钥匙还是被偷。  </li><li><strong>最终方案</strong>：朋友的“防伪密码箱”上有 <strong>公安局盖章认证</strong>（CA 证书）→ 你一看盖章是真的，才放心寄钥匙 → 安全！</li></ul></blockquote><h4 id="1-为什么-HTTPS-最终选择这个方案？"><a href="#1-为什么-HTTPS-最终选择这个方案？" class="headerlink" title="1. 为什么 HTTPS 最终选择这个方案？"></a>1. 为什么 HTTPS 最终选择这个方案？</h4><ol><li><strong>效率高</strong>：对称加密处理海量数据。</li><li><strong>安全强</strong>：非对称加密保护密钥传输。</li><li><strong>身份可信</strong>：CA 证书防止公钥被伪造。</li><li><strong>可扩展</strong>：支持前向保密、吊销、多域名等。</li></ol><h4 id="2-附加：密钥被攻击的几种真实场景"><a href="#2-附加：密钥被攻击的几种真实场景" class="headerlink" title="2. 附加：密钥被攻击的几种真实场景"></a>2. 附加：密钥被攻击的几种真实场景</h4><ol><li><strong>私钥泄露</strong>（服务器被入侵）→ 攻击者可解密历史通信（除非启用前向保密）。</li><li><strong>CA 被攻破</strong> → 攻击者可签发任意假证书（极罕见，如 DigiNotar 事件）。</li><li><strong>用户忽略证书警告</strong> → 主动接受假证书 → 中间人攻击成功。</li><li><strong>弱随机数生成器</strong> → 生成的对称密钥可预测 → 被破解。</li></ol><h3 id="7-理解链-承上启下"><a href="#7-理解链-承上启下" class="headerlink" title="7. 理解链 - 承上启下"></a>7. 理解链 - 承上启下</h3><h4 id="1-对-HTTP-进行对称加密，是否能解决数据通信安全的问题？问题是什么？"><a href="#1-对-HTTP-进行对称加密，是否能解决数据通信安全的问题？问题是什么？" class="headerlink" title="1. 对 HTTP 进行对称加密，是否能解决数据通信安全的问题？问题是什么？"></a>1. 对 HTTP 进行对称加密，是否能解决数据通信安全的问题？问题是什么？</h4><p><strong>不能完全解决，核心问题：密钥的分发。</strong></p><p>假设客户端和服务器都用同一个对称密钥来加密通信，这确实能防止第三方窃听。但是，这个密钥是如何从服务器安全地传递给客户端的呢？如果在连接建立之初，服务器直接把密钥明文发给客户端，那么中间人（黑客）同样可以截获这个密钥。一旦密钥泄露，后续所有的“加密”通信对中间人来说就等于没有加密。这就陷入了“<strong>先有鸡还是先有蛋</strong>”的困境：为了安全传输密钥，我们需要一个密钥来加密它，但这个“用来加密密钥的密钥”又该如何安全传输呢？</p><h4 id="2-为何要用非对称加密？"><a href="#2-为何要用非对称加密？" class="headerlink" title="2. 为何要用非对称加密？"></a>2. 为何要用非对称加密？</h4><p><strong>为了解决“密钥分发”问题</strong>。</p><p>非对称加密的特性（公钥加密，私钥解密）完美地解决了这个问题。服务器可以将自己的 <strong>公钥</strong> 通过明文的方式发送给客户端。客户端用这个公钥加密一个 <strong>对称密钥</strong> 后发送给服务器。即使中间人截获了这个加密后的对称密钥，他也无法解密，因为他没有服务器的 <strong>私钥</strong>。只有服务器能用自己的私钥解密，从而安全地获得对称密钥。</p><h4 id="3-为何不全用非对称加密？"><a href="#3-为何不全用非对称加密？" class="headerlink" title="3. 为何不全用非对称加密？"></a>3. 为何不全用非对称加密？</h4><p><strong>主要原因是性能</strong>。</p><p>非对称加密的算法非常复杂，其 <strong>加密和解密的速度远远慢于对称加密</strong>。如果整个 HTTPS 通信过程都使用非对称加密，会极大地消耗服务器和客户端的计算资源，导致网页加载速度变慢，用户体验很差。<strong>因此，最佳实践是结合两者</strong>：使用非对称加密来安全地 <strong>协商</strong> 一个临时的对称密钥，然后在后续的大量数据传输中，使用这个对称密钥进行高效加密。这就是 HTTPS 的核心工作原理。</p><h4 id="4-CA-签名认证-VS-数字证书-VS-数字签名"><a href="#4-CA-签名认证-VS-数字证书-VS-数字签名" class="headerlink" title="4. CA 签名认证 VS 数字证书 VS 数字签名"></a>4. CA 签名认证 VS 数字证书 VS 数字签名</h4><p><strong>数字签名、数字证书、CA 签名认证</strong> 这三样东西经常被混在一起说，但它们 <strong>不是一个东西</strong>，而是三个环环相扣的概念：<strong><code>CA 签名认证  →  产生合法的数字证书  →  证书里面包含数字签名</code>。</strong></p><ol><li><p><strong>数字签名：</strong> 就是“用私钥对一段数据做的签名”，任何人都能用对应的公钥验证签名是否有效。<strong>用途：</strong> 保证数据没有被篡改（完整性）、保证数据确实是“私钥持有者”发的（身份认证）。<strong>简单例子：</strong></p><ul><li>服务器把自己的公钥信息、域名信息打个包 → 用私钥生成一个签名。</li><li>客户端用服务器的公钥验证签名，能验证这份数据确实出自服务器本人。</li><li>类比：数字签名 &#x3D; 手写签名&#x2F;盖章。别人可以看到签名，验证是你签的，但没法伪造。</li></ul></li><li><p><strong>数字证书：</strong> 一份“带身份证明的公钥”，里面包含：服务器的公钥、服务器的域名信息（比如 <code>www.google.com</code>）、有效期、用途等信息、还有一个 <strong>数字签名</strong>（由 CA 生成的）。</p><ul><li><strong>用途：</strong> 客户端拿到证书后，不仅知道“这是公钥”，还知道“这个公钥是属于哪个网站的”，解决了“公钥是谁的”这个问题。</li><li><strong>类比：</strong> 数字证书 &#x3D; 身份证。身份证上写着你的名字（域名）、照片（公钥），还有公安局的盖章（CA 签名）。</li></ul></li><li><p><strong>CA 签名认证：</strong> 就是证书里的“盖章”部分 —— 证书不是服务器自己随便说“这是我的身份证”，而是交给权威机构（CA，证书颁发机构）去验证，然后 <strong>CA 用自己的私钥签名</strong>，证明这份证书是真的。</p><ul><li><p><strong>流程：</strong></p><ol><li>服务器 → 提交公钥 + 域名信息给 CA。</li><li>CA 审核（域名验证、公司验证等）。</li><li>CA 用自己的 <strong>私钥</strong> 对证书做数字签名。</li><li>浏览器内置了各大 CA 的 <strong>公钥</strong> → 可以验证证书签名是否有效。</li></ol></li><li><p><strong>用途：</strong> 确保证书是真的，不是黑客自己伪造的，确认公钥确实属于 <code>www.xxx.com</code>。</p></li></ul><blockquote><p>  类比：CA 签名认证 &#x3D; 公安局给身份证盖章。别人一看章是真的，就知道身份证不是假造的。</p></blockquote></li></ol><h2 id="3-关于-HTTPS-的一些扩展和思考"><a href="#3-关于-HTTPS-的一些扩展和思考" class="headerlink" title="3. 关于 HTTPS 的一些扩展和思考"></a>3. 关于 HTTPS 的一些扩展和思考</h2><h3 id="1-CA-签名流程是不是先做摘要？"><a href="#1-CA-签名流程是不是先做摘要？" class="headerlink" title="1. CA 签名流程是不是先做摘要？"></a>1. CA 签名流程是不是先做摘要？</h3><p><strong>是的。</strong> CA 在给证书签名时，先对证书内容（域名、公钥、有效期等）做 <strong>Hash 得到摘要</strong>，再用 <strong>CA 私钥加密摘要</strong> → 得到 <strong>数字签名</strong> → 把签名 + 原始证书信息一起 <strong>发送</strong> 给客户端。<strong>证书 &#x3D; 明文信息 + 签名，签名 &#x3D; 用私钥加密“数据的摘要”</strong>。浏览器验证时：先用相同算法对证书内容 hash，再用 CA 公钥解密签名得到摘要，两者对比 → 确认证书没被篡改。</p><h3 id="2-为什么数字签名（如-CA-对证书签名）不直接用私钥加密原始数据（如证书或任意文件），而要先对数据做-Hash-生成摘要，再对摘要进行加密签名？"><a href="#2-为什么数字签名（如-CA-对证书签名）不直接用私钥加密原始数据（如证书或任意文件），而要先对数据做-Hash-生成摘要，再对摘要进行加密签名？" class="headerlink" title="2. 为什么数字签名（如 CA 对证书签名）不直接用私钥加密原始数据（如证书或任意文件），而要先对数据做 Hash 生成摘要，再对摘要进行加密签名？"></a>2. 为什么数字签名（如 CA 对证书签名）不直接用私钥加密原始数据（如证书或任意文件），而要先对数据做 Hash 生成摘要，再对摘要进行加密签名？</h3><p>因为直接用私钥加密原始数据 <strong>效率极低</strong> —— 非对称加密计算慢，且受数据长度限制，不适合大文件或频繁操作；而先对数据做 Hash 生成固定长度的“摘要”，再加密摘要，既大幅 <strong>提升签名速度</strong>，又 <strong>保证了安全性</strong>。更重要的是，Hash 摘要具备“雪崩效应”和抗篡改性：哪怕原文改动一个字节，摘要也会彻底改变，接收方通过比对摘要即可验证完整性。同时，先 Hash 还能 <strong>防御</strong>“长度扩展攻击”等密码学漏洞，确保签名机制在各种场景下（如证书、文件、消息）都安全、高效、标准化。</p><p><strong>所以标准流程：原文 → Hash(摘要) → 用私钥加密(签名)。客户端验证时：收到原文 &amp; 签名 → 原文重新 Hash → 用公钥解密签名 &#x3D; 摘要 → 两个摘要比对一致 → 证明原文没改、签名有效。</strong></p><h3 id="3-如何成为中间人（MITM）"><a href="#3-如何成为中间人（MITM）" class="headerlink" title="3. 如何成为中间人（MITM）"></a>3. 如何成为中间人（MITM）</h3><h4 id="1-ARP-欺骗"><a href="#1-ARP-欺骗" class="headerlink" title="1. ARP 欺骗"></a>1. ARP 欺骗</h4><p>局域网里，电脑通信需要知道对方的 MAC 地址。ARP（地址解析协议）就是负责“IP ↔ MAC 地址绑定”。<strong>漏洞</strong>：ARP 没有验证机制，谁说自己是某个 IP 就信。<strong>攻击方法</strong>：黑客冒充别人：</p><ul><li>主机 A 想访问主机 B → 先广播“B 的 MAC 地址谁知道？”</li><li>黑客抢答：“我是 B，我的 MAC 是 xxx”</li><li>结果 A 把流量都发给黑客，黑客再转发给 B → 黑客变中间人。</li></ul><p>就像在班里传纸条，A 想传给 B，黑客插话说“我就是 B，把纸条给我” → 再偷偷看一眼转交给真 B。</p><h4 id="2-ICMP-重定向攻击"><a href="#2-ICMP-重定向攻击" class="headerlink" title="2. ICMP 重定向攻击"></a>2. ICMP 重定向攻击</h4><p>ICMP 协议里有一种“重定向消息”，路由器可以告诉主机：“嘿，这个目标地址，你应该走另一条更好的路”。<strong>漏洞</strong>：ICMP 没验证，谁都能发。<strong>攻击方法</strong>：</p><ul><li>黑客伪造 ICMP 消息，告诉受害者“要访问外网，请经过我这台路由器”。</li><li>结果受害者的所有流量都经过黑客机器。</li></ul><p>就像问路，路人甲（黑客）冒充警察说“你要去市中心？从我家后门穿过去更快” → 结果你绕进了陷阱。</p><h4 id="3-假-WiFi-假网站"><a href="#3-假-WiFi-假网站" class="headerlink" title="3. 假 WiFi &#x2F; 假网站"></a>3. 假 WiFi &#x2F; 假网站</h4><ul><li><strong>假 WiFi（所谓的钓鱼网络）</strong>：黑客开个和真 WiFi 同名的热点，用户连上去后，所有流量都经过黑客电脑 → 可以监控&#x2F;篡改数据。</li><li><strong>假网站</strong>：黑客在局域网或 DNS 劫持，把 <code>www.google.com</code> 映射到自己控制的假服务器 → 用户以为在访问银行，其实是黑客的钓鱼网站。</li></ul><p>就像黑客开了一家“假银行”，外观和真的一样，但柜员全是演员，用户输入账号密码就等于都交给了他。<strong>本质：中间人就是把流量骗到自己手里，再决定是“只偷听”还是“修改后转发”。</strong></p><h4 id="4-HTTPS-中间人（需用户配合或证书漏洞）"><a href="#4-HTTPS-中间人（需用户配合或证书漏洞）" class="headerlink" title="4. HTTPS 中间人（需用户配合或证书漏洞）"></a>4. HTTPS 中间人（需用户配合或证书漏洞）</h4><p><strong>原理：伪造 SSL 证书，骗浏览器信任。</strong> 操作：黑客作为中间人，拦截 HTTPS 请求 伪造一个“假证书”发给客户端（如自签名或盗用 CA），如果用户点击“继续访问（不安全）”，则攻击成功，防御：浏览器会警告“证书不受信任”，我们用户不点“忽略”就攻不破。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;HTTPS-协议原理&quot;&gt;&lt;a href=&quot;#HTTPS-协议原理&quot; class=&quot;headerlink&quot; title=&quot;HTTPS 协议原理&quot;&gt;&lt;/a&gt;HTTPS 协议原理&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a</summary>
        
      
    
    
    
    <category term="Linux" scheme="https://www.minbit.top/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://www.minbit.top/tags/Linux/"/>
    
    <category term="网络" scheme="https://www.minbit.top/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>048 HTTP 协议</title>
    <link href="https://www.minbit.top/posts/63840.html"/>
    <id>https://www.minbit.top/posts/63840.html</id>
    <published>2025-08-25T04:00:00.000Z</published>
    <updated>2025-08-25T04:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HTTP-协议"><a href="#HTTP-协议" class="headerlink" title="HTTP 协议"></a>HTTP 协议</h1><blockquote><p><a href="https://t4dmw.blog.csdn.net/article/details/123313047">HTTP 协议详解 | CSDN</a></p><p><a href="https://blog.csdn.net/loss_rose777/article/details/132919997?spm=1001.2014.3001.5502">HTTP 协议（超级详细） | CSDN</a></p></blockquote><h2 id="1-HTTP-是什么"><a href="#1-HTTP-是什么" class="headerlink" title="1. HTTP 是什么"></a>1. HTTP 是什么</h2><p>虽然我们说应用层协议是我们程序猿自己定的，但实际上，已经有大佬们定义了一些现成的，又非常好用的应用层协议，供我们直接参考使用。HTTP 就是其中之一，HTTP 全称 <strong>HyperText Transfer Protocol（超文本传输协议）</strong>，它是一个 <strong>应用层协议</strong>，专门规定了浏览器和服务器之间怎么对话。简单来说，就是：</p><ul><li>浏览器（客户端）：“我要资源 A。”</li><li>服务器：“好的，给你资源 A。”</li></ul><p>HTTP 负责 <strong>传输规则</strong>，至于你传的是 HTML、图片、视频、JSON，它根本不管。</p><h2 id="2-工作流程"><a href="#2-工作流程" class="headerlink" title="2. 工作流程"></a>2. 工作流程</h2><p>HTTP 基本流程就是 <strong>请求-响应模型</strong>：</p><ol><li>客户端发起请求（Request）。</li><li>服务器返回响应（Response）。</li></ol><p>请求和响应里，都是一堆 <strong>报文</strong>（Headers + Body），有点像两个人通信时带着信封和正文。</p><h2 id="3-认识-URL"><a href="#3-认识-URL" class="headerlink" title="3. 认识 URL"></a>3. 认识 URL</h2><p>URL（统一资源定位符，Uniform Resource Locator）其实就是“网络上的地址”，就像现实生活中的“国家 → 城市 → 街道 → 门牌号”。<br> 它一共有 <strong>7 个部分</strong>，每个部分都有职责。我们用一个例子来拆开看：</p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250822160233435.png" alt="PixPin_2025-08-22_16-02-22"></p><h3 id="1-协议方案名（scheme）"><a href="#1-协议方案名（scheme）" class="headerlink" title="1. 协议方案名（scheme）"></a>1. 协议方案名（scheme）</h3><p><strong>作用</strong>：指定使用哪种协议来访问资源。这是整个 URL 的“开头”，告诉浏览器该用什么方式去获取资源。常见值：</p><ul><li><code>http</code>：超文本传输协议（不加密）。</li><li><code>https</code>：安全的 HTTP（加密）。</li><li><code>ftp</code>：文件传输协议。</li><li><code>mailto</code>：发送邮件。</li><li><code>file</code>：本地文件。</li></ul><h3 id="2-登录信息（认证信息）"><a href="#2-登录信息（认证信息）" class="headerlink" title="2. 登录信息（认证信息）"></a>2. 登录信息（认证信息）</h3><p><strong>作用</strong>：有些协议可以在 URL 中写用户名和密码，用来登录。<strong>格式</strong>：<code>username:password@</code>，比如：<code>http://admin:123456@myserver.com</code>。注意：现在几乎不用了，因为明文暴露账号密码，巨危险。现代认证一般靠 Token、Cookie、OAuth。</p><h3 id="3-服务器地址（host）"><a href="#3-服务器地址（host）" class="headerlink" title="3. 服务器地址（host）"></a>3. 服务器地址（host）</h3><p><strong>作用</strong>：指定目标服务器的域名或 IP 地址。说明：可以是域名（如 <code>www.example.jp</code>），也可以是 IP 地址（如 <code>192.168.1.1</code>），浏览器先通过 <strong>DNS</strong> 把域名解析成 IP，再去找目标机器。例如：<code>www.baidu.com</code> 就是百度的域名。 </p><p>网络通信的关键是 IP 和端口号，所以只要知道某个网站的 <strong>IP 地址</strong> 和它运行服务的 <strong>端口号</strong>（通常是 80 或 443），就可以直接通过这个 IP 访问它。当然也存在不能访问的情况：服务器直接禁止使用 IP 地址访问、端口未开放、需要额外身份验证或配置等。<strong>域名 &#x3D; IP 的“人类友好版本”</strong>，人记不住 <code>39.156.70.37</code> 这样的数字，所以发明了 <strong>域名系统 DNS</strong>，当输入 <code>baidu.com</code> 时，DNS 会自动查出它对应的 IP 地址 → <code>39.156.70.37</code>，这就是所谓的：</p><ul><li><strong>序列化</strong>：把 <code>baidu.com</code> 转成 <code>39.156.70.37</code>（解析）</li><li><strong>反序列化</strong>：把 <code>39.156.70.37</code> 映射回 <code>baidu.com</code>（反向查询）</li></ul><blockquote><p>  但注意：<strong>域名本身不包含端口信息</strong>。端口默认是 80（HTTP）或 443（HTTPS），除非特别指定。 </p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250822162939678.png" alt="PixPin_2025-08-22_16-29-36"></p><h3 id="4-服务器端口号（port）"><a href="#4-服务器端口号（port）" class="headerlink" title="4. 服务器端口号（port）"></a>4. 服务器端口号（port）</h3><p><strong>作用</strong>：指定服务器上监听的端口，一般情况下 URL 里省略不写。<strong>如果省略</strong>，则使用默认端口，HTTP 默认端口是 80，HTTPS 默认端口是 443。如果用了非默认端口，必须写出来，否则无法连接，<strong>格式：</strong> IP 地址：端口号 </p><h3 id="5-文件路径（path）"><a href="#5-文件路径（path）" class="headerlink" title="5. 文件路径（path）"></a>5. 文件路径（path）</h3><p><strong>作用</strong>：指定服务器上资源的具体路径（类似文件夹结构）。说明：大多数情况下路径从根目录开始（以 <code>/</code> 开头），表示要访问的网页、图片、API 接口等，但也可以配置非根目录下。</p><h3 id="6-查询字符串（Query-String）"><a href="#6-查询字符串（Query-String）" class="headerlink" title="6. 查询字符串（Query String）"></a>6. 查询字符串（Query String）</h3><p><strong>作用</strong>：向服务器传递额外参数，常用于搜索、筛选、用户标识等。通常在 <code>GET</code> 请求里用，格式是 <code>key=value</code>，多个参数用 <code>&amp;</code> 连接，例如：<code>?search=Python&amp;page=2</code> 表示搜索 Python 第 2 页。特点：</p><ul><li>参数由 <code>&amp;</code> 分隔</li><li>键值对之间用 <code>=</code> 连接</li><li>会被发送到服务器，但不会保存在页面中（除非显式存储）</li></ul><h3 id="7-片段标识符（fragment）"><a href="#7-片段标识符（fragment）" class="headerlink" title="7. 片段标识符（fragment）"></a>7. 片段标识符（fragment）</h3><p>片段标识符又叫 <strong>锚点，作用：</strong> 表示页面里的某个位置（控制页面滚动位置）。浏览器拿到页面后，会自动滚动到对应的位置（比如某一章节）。注意：片段不会传给服务器，它只在客户端（浏览器）起作用。</p><blockquote><p>所以 URL 的 7 个部分完整结构：<code>协议://登录信息@服务器地址:端口号/路径?查询字符串#片段</code>。</p></blockquote><h2 id="4-urlencode-和-urldecode"><a href="#4-urlencode-和-urldecode" class="headerlink" title="4. urlencode 和 urldecode"></a>4. urlencode 和 urldecode</h2><p><strong><code>urlencode</code> 是把不安全或特殊字符转成 “URL 能安全传输” 的格式；<code>urldecode</code> 是把它还原回来。</strong> </p><p>像 <code>／？：</code> 等这样的字符，已经被 URL 当做特殊意义理解了，因此这些字符不能随意出现，比如某个参数中需要带有这些特殊字符，就必须先对特殊字符进行转义。</p><p>转义的规则如下：将需要转码的字符转为 16 进制，然后从右到左，取 4 位（不足 4 位直接处理），每 2 位做一位，前面加上%，编码成 %XY 格式。</p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250822233626966.png" alt="PixPin_2025-08-22_23-34-41"></p><p>两个工具 <a href="https://tool.chinaz.com/tools/urlencode.aspx">站长之家</a> 或 <a href="https://www.bejson.com/enc/urlencode/">Json 格式化</a> 可观察编码和解码的结果。</p><h2 id="5-HTTP-请求和响应"><a href="#5-HTTP-请求和响应" class="headerlink" title="5. HTTP 请求和响应"></a>5. HTTP 请求和响应</h2><h3 id="1-请求和响应报文的结构"><a href="#1-请求和响应报文的结构" class="headerlink" title="1. 请求和响应报文的结构"></a>1. 请求和响应报文的结构</h3><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250823001147423.png" alt="PixPin_2025-08-23_00-11-41"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">            HTTP 请求报文结构</span><br><span class="line">┌───────────────────────────────────────────┐</span><br><span class="line">│ &lt;method&gt;  &lt;request-target&gt;  &lt;http-version&gt; │ ← 请求行 (Request Line)</span><br><span class="line">├───────────────────────────────────────────┤</span><br><span class="line">│ Header-Name: Header-Value                 │</span><br><span class="line">│ Header-Name: Header-Value                 │ ← 请求头部 (Request Headers)</span><br><span class="line">│ ...                                       │</span><br><span class="line">│ Content-Length: &lt;length&gt;                  │</span><br><span class="line">├───────────────────────────────────────────┤</span><br><span class="line">│                                           │ ← 空行 (CRLF: \r\n)</span><br><span class="line">└───────────────────────────────────────────┘</span><br><span class="line">┌───────────────────────────────────────────┐</span><br><span class="line">│              &lt;request-body&gt;               │ ← 请求体 (可选)</span><br><span class="line">└───────────────────────────────────────────┘</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            HTTP 响应报文结构</span><br><span class="line">┌───────────────────────────────────────────┐</span><br><span class="line">│ &lt;http-version&gt; &lt;status-code&gt; &lt;reason-phrase&gt; │ ← 状态行 (Status Line)</span><br><span class="line">├───────────────────────────────────────────┤</span><br><span class="line">│ Header-Name: Header-Value                 │</span><br><span class="line">│ Header-Name: Header-Value                 │ ← 响应头部 (Response Headers)</span><br><span class="line">│ ...                                       │</span><br><span class="line">│ Content-Length: &lt;length&gt;                  │</span><br><span class="line">├───────────────────────────────────────────┤</span><br><span class="line">│                                           │ ← 空行 (CRLF: \r\n)</span><br><span class="line">└───────────────────────────────────────────┘</span><br><span class="line">┌───────────────────────────────────────────┐</span><br><span class="line">│              &lt;response-body&gt;              │ ← 响应体 (可选)</span><br><span class="line">└───────────────────────────────────────────┘</span><br></pre></td></tr></table></figure><h4 id="1-HTTP-请求报文结构"><a href="#1-HTTP-请求报文结构" class="headerlink" title="1. HTTP 请求报文结构"></a>1. HTTP 请求报文结构</h4><p>整体格式：见上图，共有 <strong>请求行、请求头部、空行、请求正文&#x2F;请求体（可选）</strong> 4 部分。</p><h5 id="1-请求行"><a href="#1-请求行" class="headerlink" title="1. 请求行"></a>1. 请求行</h5><p><strong>格式：</strong> <code>Method  URL  HTTP-Version</code>。</p><ol><li><p><strong>Method（方法）</strong>：请求方法，表示操作类型，说明要对资源做什么操作，常见方法：<code>GET</code>（获取资源）、<code>POST</code>（提交数据）、<code>PUT</code>（更新资源）、<code>DELETE</code>（删除资源）、<code>HEAD</code>（获取头部信息）、<code>OPTIONS</code>（查询支持的方法）等。</p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250823143453428.png" alt="PixPin_2025-08-23_14-34-44"></p></li><li><p><strong>URL（路径）</strong>：请求的目标资源的位置&#x2F;路径，比如 <code>/index.html</code>、<code>/api/user</code>。</p></li><li><p><strong>HTTP-Version（协议版本）</strong>：常见 <code>HTTP/1.0</code>、<code>HTTP/1.1</code>、<code>HTTP/2</code>、<code>HTTP/3</code>。</p></li></ol><blockquote><ul><li><code>HTTP/1.0</code>：早期版本，性能较差。</li><li><code>HTTP/1.1</code>：目前最广泛使用的版本。</li><li><code>HTTP/2</code>：提升性能，支持多路复用。</li><li><code>HTTP/3</code>：基于 UDP，进一步优化延迟”。</li></ul></blockquote><h5 id="2-请求头部"><a href="#2-请求头部" class="headerlink" title="2. 请求头部"></a>2. 请求头部</h5><p>由 <strong>若干个 <code>Key: Value</code> 形式的键值对</strong> 组成，每行一个，描述请求的 <strong>元信息</strong>，用于传递客户端的附加信息。</p><p>常见头部字段：</p><ul><li><code>Host</code>: 指定请求的目标主机名（必须存在）</li><li><code>User-Agent</code>: 标识客户端软件（如浏览器类型）</li><li><code>Content-Type</code>: 指明请求体的媒体类型（如 <code>application/json</code>、<code>application/x-www-form-urlencoded</code>）</li><li><code>Content-Length</code>: 请求体的字节数（若使用 <code>Transfer-Encoding: chunked</code> 可省略）</li><li><code>Authorization</code>: 认证信息（如 Bearer Token）</li><li><code>Cookie</code>: 发送存储在客户端的 Cookie</li></ul><blockquote><p>  头部字段不区分大小写，但通常首字母大写（如 <code>Content-Type</code>） 。</p></blockquote><h5 id="3-空行"><a href="#3-空行" class="headerlink" title="3. 空行"></a>3. 空行</h5><p>用 <code>\r\n</code>（回车 + 换行）表示，<strong>必须存在</strong>，用于分隔请求头和请求体。如果没有空行，服务器无法判断头部结束，会解析出错。 </p><h5 id="4-请求正文-体"><a href="#4-请求正文-体" class="headerlink" title="4. 请求正文&#x2F;体"></a>4. 请求正文&#x2F;体</h5><p>可选，用于存放实际传给服务器的数据。</p><hr><h4 id="2-HTTP-响应报文结构"><a href="#2-HTTP-响应报文结构" class="headerlink" title="2. HTTP 响应报文结构"></a>2. HTTP 响应报文结构</h4><p>整体格式：见上图，有 <strong>状态行、响应头、空行、响应正文&#x2F;响应体</strong> 4 部分。</p><h5 id="1-状态行"><a href="#1-状态行" class="headerlink" title="1. 状态行"></a>1. 状态行</h5><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTTP-Version  Status-Code  Reason-Phrase</span><br></pre></td></tr></table></figure><ol><li><p><strong>HTTP-Version</strong>：同上，常见 <code>HTTP/1.0</code>、<code>HTTP/1.1</code>、<code>HTTP/2</code>、<code>HTTP/3</code>。</p></li><li><p><strong>Status-Code（状态码）</strong>：三位数字，表示处理结果。</p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250823143342110.png" alt="PixPin_2025-08-23_14-33-31"></p><p>常见：<code>200</code> 成功、<code>301</code> 永久重定向、<code>404</code> 未找到资源（客户端错误）、<code>500</code> 服务器内部错误。</p></li><li><p><strong>Reason-Phrase</strong>：状态码的简短文字描述，比如 <code>OK</code>、<code>Not Found</code>。</p></li></ol><blockquote><p><a href="https://www.runoob.com/http/http-status-codes.html">HTTP 状态码 | 菜鸟教程</a></p><p><a href="https://cloud.tencent.com.cn/developer/article/2540361">HTTP 状态码全部完整列表 | 腾讯云</a></p></blockquote><h5 id="2-响应头部"><a href="#2-响应头部" class="headerlink" title="2. 响应头部"></a>2. 响应头部</h5><p>同样是若干个 <code>Key: Value</code> 格式的键值对，描述服务端返回数据的元信息。</p><p>常见字段：</p><ul><li><code>Content-Type</code>: 响应体的媒体类型（如 <code>text/html</code>、<code>application/json</code>）。</li><li><code>Content-Length</code>: 响应体的字节数。</li><li><code>Server</code>: 服务器软件信息（如 Apache、Nginx）。</li><li><code>Set-Cookie</code>: 设置客户端 Cookie。</li><li><code>Location</code>: 重定向地址（配合 3xx 状态码）。</li><li><code>Cache-Control</code>: 缓存策略。</li><li><code>Date</code>: 响应生成时间。</li></ul><h5 id="3-空行-1"><a href="#3-空行-1" class="headerlink" title="3. 空行"></a>3. 空行</h5><p>同样用 <code>\r\n</code> 表示，<strong>必须存在</strong>，用于分隔响应头和响应体。</p><h5 id="4-响应正文-体"><a href="#4-响应正文-体" class="headerlink" title="4. 响应正文&#x2F;体"></a>4. 响应正文&#x2F;体</h5><p>服务器返回的实际内容。类型取决于 <code>Content-Type</code>：</p><ul><li><code>text/html</code> → HTML 页面</li><li><code>application/json</code> → JSON 数据</li><li><code>image/png</code> → 图片二进制</li><li><code>video/mp4</code> → 视频流</li></ul><h3 id="2-网络调试工具"><a href="#2-网络调试工具" class="headerlink" title="2. 网络调试工具"></a>2. 网络调试工具</h3><table><thead><tr><th>工具</th><th>定位</th><th>主要用途</th></tr></thead><tbody><tr><td><strong><a href="https://www.telerik.com/fiddler">Fiddler</a></strong></td><td>专业抓包代理（被动监听&#x2F;拦截）</td><td>捕获流量、调试网络、分析问题</td></tr><tr><td><strong><a href="https://www.postman.com/downloads/">Postman</a></strong></td><td>API 客户端（主动请求）</td><td>构造请求、测试接口、管理 API</td></tr></tbody></table><p>在 Linux 中，<code>telnet</code> 是一个基于 TCP 协议的远程登录与调试工具。简单说来，它就像一个 <strong>万能的 TCP 客户端</strong>，可以用它连接到任意 TCP 服务（HTTP、Redis……），然后手动输入命令。<strong>注意：Telnet 是明文传输，数据不加密，所以要小心使用，我们一般仅用来调试网络服务、测试端口连通性、模拟发送请求。</strong> 安装命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> yum install -y telnet<span class="comment"># -y 表示自动安装，不需要确认</span></span><br><span class="line"><span class="built_in">sudo</span> yum install telnet</span><br></pre></td></tr></table></figure><p>基本语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># telnet [主机名或IP地址] [端口号]，比如：</span></span><br><span class="line">telnet baidu.com 80</span><br><span class="line"><span class="comment"># 连通后的示例输出：</span></span><br><span class="line">Trying 220.181.7.203...</span><br><span class="line">Connected to baidu.com.</span><br><span class="line">Escape character is <span class="string">&#x27;^]&#x27;</span>.</span><br></pre></td></tr></table></figure><p>注意：如果省略端口号，默认连接远程主机的 23 端口（Telnet 服务默认端口）。退出 Telnet 连接： Telnet 交互界面中，按 Ctrl + ] 进入命令模式，然后输入 quit 退出。</p><h3 id="3-一个简单的-HTTP-服务器-Demo"><a href="#3-一个简单的-HTTP-服务器-Demo" class="headerlink" title="3. 一个简单的 HTTP 服务器 Demo"></a>3. 一个简单的 HTTP 服务器 Demo</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Socket.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Log.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">uint16_t</span> default_port = <span class="number">8082</span>;      <span class="comment">// 服务器默认监听端口</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> BUFFER_SIZE = <span class="number">10240</span>;                  <span class="comment">// 缓冲区大小，用于接收 HTTP 请求</span></span><br><span class="line"><span class="type">const</span> std::string wwwroot = <span class="string">&quot;./wwwroot&quot;</span>;        <span class="comment">// Web 根目录，所有静态资源都放在这个文件夹下</span></span><br><span class="line"><span class="type">const</span> std::string home_page = <span class="string">&quot;index.html&quot;</span>;     <span class="comment">// 主页文件名</span></span><br><span class="line"><span class="type">const</span> std::string sep = <span class="string">&quot;\r\n&quot;</span>;                 <span class="comment">// HTTP 请求行和头之间的分隔符</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Thread_Data</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Thread_Data</span>(<span class="type">int</span> fd)                         <span class="comment">// 构造函数：保存客户端 socket 文件描述符</span></span><br><span class="line">    : <span class="built_in">sockfd</span>(fd)</span><br><span class="line">    &#123;&#125;          </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> sockfd;                                 <span class="comment">// 客户端连接的 socket fd</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// HTTP 请求类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HTTP_Request</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::vector&lt;std::string&gt; req_header;</span><br><span class="line">    std::string text;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析结果</span></span><br><span class="line">    std::string method;                         <span class="comment">// 请求方法</span></span><br><span class="line">    std::string url;                            <span class="comment">// 请求 URL</span></span><br><span class="line">    std::string version;                        <span class="comment">// HTTP 版本</span></span><br><span class="line">    std::string file_path;                      <span class="comment">// 请求文件路径</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// HTTP_Request()</span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Deserialize</span><span class="params">(std::string req)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            std::<span class="type">size_t</span> pos = req.<span class="built_in">find</span>(sep);    <span class="comment">// 查找每行的结束位置（\r\n）</span></span><br><span class="line">            <span class="keyword">if</span>(pos == std::string::npos)        <span class="comment">// 找不到</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            std::string temp = req.<span class="built_in">substr</span>(<span class="number">0</span>, pos);          <span class="comment">// 提取当前行</span></span><br><span class="line">            <span class="keyword">if</span>(temp.<span class="built_in">empty</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;                          <span class="comment">// 空行表示请求头结束</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            req_header.<span class="built_in">push_back</span>(temp);</span><br><span class="line">            req = req.<span class="built_in">substr</span>(pos + <span class="number">2</span>);          <span class="comment">// 去掉当前行和分隔符</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        text = req;                             <span class="comment">// 剩余部分是请求正文，可能为空</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Parse</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::stringstream <span class="title">ss</span><span class="params">(req_header[<span class="number">0</span>])</span></span>;    <span class="comment">// 将请求行解析为字符串流</span></span><br><span class="line">        ss &gt;&gt; method &gt;&gt; url &gt;&gt; version;         <span class="comment">// 解析请求行</span></span><br><span class="line"></span><br><span class="line">        file_path = wwwroot;                    <span class="comment">// 默认请求文件路径为 wwwroot</span></span><br><span class="line">        <span class="keyword">if</span>(url == <span class="string">&quot;/&quot;</span> || url == <span class="string">&quot;index.html&quot;</span>)   <span class="comment">// 请求根目录或主页</span></span><br><span class="line">        &#123;</span><br><span class="line">            file_path += (<span class="string">&quot;/&quot;</span> + home_page);     <span class="comment">// 文件路径为 wwwroot/index.html</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            file_path += url;                   <span class="comment">// 请求文件路径为 wwwroot/url</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DebugPrint</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;it : req_header)</span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; it &lt;&lt; <span class="string">&quot;\n\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;method: &quot;</span> &lt;&lt; method &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;url: &quot;</span> &lt;&lt; url &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;version: &quot;</span> &lt;&lt; version &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;text: &quot;</span> &lt;&lt; text &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// HTTP 服务器类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HTTP_Server</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Sock listensock_;                           <span class="comment">// 监听 socket 封装对象</span></span><br><span class="line">    <span class="type">uint16_t</span> port_;                             <span class="comment">// 服务器监听端口号</span></span><br><span class="line">    std::unordered_map&lt;std::string, std::string&gt; content_type; <span class="comment">// MIME 映射表</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">HTTP_Server</span>(<span class="type">uint16_t</span> port = default_port)   <span class="comment">// 构造函数：初始化监听端口</span></span><br><span class="line">        : <span class="built_in">port_</span>(port)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ~<span class="built_in">HTTP_Server</span>()</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动服务器，进入主循环：监听 -&gt; 接收连接 -&gt; 为连接分配线程处理</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Start</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        listensock_.<span class="built_in">Socket</span>();                   <span class="comment">// 创建监听 socket</span></span><br><span class="line">        listensock_.<span class="built_in">Bind</span>(port_);                <span class="comment">// 绑定端口</span></span><br><span class="line">        listensock_.<span class="built_in">Listen</span>();                   <span class="comment">// 开始监听</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;)</span><br><span class="line">        &#123;</span><br><span class="line">            std::string clientip;</span><br><span class="line">            <span class="type">uint16_t</span> clientport;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 接受一个新连接（阻塞等待）</span></span><br><span class="line">            <span class="type">int</span> sockfd = listensock_.<span class="built_in">Accept</span>(&amp;clientip, &amp;clientport);</span><br><span class="line">            <span class="keyword">if</span> (sockfd &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;                       <span class="comment">// 失败则跳过，继续等待下一个连接</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">log_</span>(Info, <span class="string">&quot;get a new connect, sockfd: %d&quot;</span>, sockfd);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 为每个连接分配一个线程进行处理</span></span><br><span class="line">            <span class="type">pthread_t</span> tid;</span><br><span class="line">            Thread_Data* td = <span class="keyword">new</span> <span class="built_in">Thread_Data</span>(sockfd);</span><br><span class="line">            <span class="built_in">pthread_create</span>(&amp;tid, <span class="literal">nullptr</span>, Thread_Run, td);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理 HTTP 请求：读取请求报文，构造并发送 HTTP 响应</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">HandlerHttp1</span><span class="params">(<span class="type">int</span> sockfd)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">char</span> buf[BUFFER_SIZE];</span><br><span class="line">        <span class="type">ssize_t</span> n = <span class="built_in">recv</span>(sockfd, buf, BUFFER_SIZE - <span class="number">1</span>, <span class="number">0</span>);          <span class="comment">// 读取请求数据</span></span><br><span class="line">        <span class="keyword">if</span>(n &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            buf[n] = <span class="string">&#x27;\0&#x27;</span>;                      <span class="comment">// 添加字符串结束符</span></span><br><span class="line">            std::cout &lt;&lt; buf;</span><br><span class="line"></span><br><span class="line">            std::string text =<span class="string">&quot;Hello Linux!&quot;</span>;   <span class="comment">// 响应正文内容</span></span><br><span class="line"></span><br><span class="line">            std::string response_line = <span class="string">&quot;HTTP/1.1 200 OK\r\n&quot;</span>;      <span class="comment">// 状态行</span></span><br><span class="line">            std::string response_header = <span class="string">&quot;Content-Length: &quot;</span>;       <span class="comment">// 响应头</span></span><br><span class="line">            response_header += std::<span class="built_in">to_string</span>(text.<span class="built_in">size</span>());</span><br><span class="line">            response_header += <span class="string">&quot;\r\n&quot;</span>;</span><br><span class="line">            std::string blank_line = <span class="string">&quot;\r\n&quot;</span>;    <span class="comment">// 空行</span></span><br><span class="line"></span><br><span class="line">            std::string response = response_line;</span><br><span class="line">            response += response_header;</span><br><span class="line">            response += blank_line;</span><br><span class="line">            response += text;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">send</span>(sockfd, response.<span class="built_in">c_str</span>(), response.<span class="built_in">size</span>(), <span class="number">0</span>);     <span class="comment">// 发送响应</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">close</span>(sockfd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> std::string <span class="title">Read_Htmlfile</span><span class="params">(<span class="type">const</span> std::string &amp;path)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::ifstream <span class="title">in</span><span class="params">(path)</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(!in.<span class="built_in">is_open</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;404 Not Found&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        std::string content;</span><br><span class="line">        std::string line;</span><br><span class="line">        <span class="keyword">while</span>(std::<span class="built_in">getline</span>(in, line))</span><br><span class="line">        &#123;</span><br><span class="line">            content += line;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        in.<span class="built_in">close</span>();</span><br><span class="line">        <span class="keyword">return</span> content;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">HandlerHttp2</span><span class="params">(<span class="type">int</span> sockfd)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">char</span> buf[BUFFER_SIZE];</span><br><span class="line">        <span class="type">ssize_t</span> n = <span class="built_in">recv</span>(sockfd, buf, BUFFER_SIZE - <span class="number">1</span>, <span class="number">0</span>);          <span class="comment">// 读取请求数据</span></span><br><span class="line">        <span class="keyword">if</span>(n &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            buf[n] = <span class="string">&#x27;\0&#x27;</span>;                      <span class="comment">// 添加字符串结束符</span></span><br><span class="line">            std::cout &lt;&lt; buf;</span><br><span class="line"></span><br><span class="line">            std::string text = <span class="built_in">Read_Htmlfile</span>(<span class="string">&quot;wwwroot/index.html&quot;</span>); <span class="comment">// 读取并构造响应正文内容</span></span><br><span class="line"></span><br><span class="line">            std::string response_line = <span class="string">&quot;HTTP/1.1 200 OK\r\n&quot;</span>;      <span class="comment">// 状态行</span></span><br><span class="line">            std::string response_header = <span class="string">&quot;Content-Length: &quot;</span>;       <span class="comment">// 响应头</span></span><br><span class="line">            response_header += std::<span class="built_in">to_string</span>(text.<span class="built_in">size</span>());</span><br><span class="line">            response_header += <span class="string">&quot;\r\n&quot;</span>;</span><br><span class="line">            std::string blank_line = <span class="string">&quot;\r\n&quot;</span>;    <span class="comment">// 空行</span></span><br><span class="line"></span><br><span class="line">            std::string response = response_line;</span><br><span class="line">            response += response_header;</span><br><span class="line">            response += blank_line;</span><br><span class="line">            response += text;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">send</span>(sockfd, response.<span class="built_in">c_str</span>(), response.<span class="built_in">size</span>(), <span class="number">0</span>);     <span class="comment">// 发送响应</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">close</span>(sockfd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">HandlerHttp3</span><span class="params">(<span class="type">int</span> sockfd)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">char</span> buf[BUFFER_SIZE];</span><br><span class="line">        <span class="type">ssize_t</span> n = <span class="built_in">recv</span>(sockfd, buf, BUFFER_SIZE - <span class="number">1</span>, <span class="number">0</span>);          <span class="comment">// 读取请求数据</span></span><br><span class="line">        <span class="keyword">if</span>(n &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            buf[n] = <span class="string">&#x27;\0&#x27;</span>;                      <span class="comment">// 添加字符串结束符</span></span><br><span class="line">            std::cout &lt;&lt; buf;</span><br><span class="line"></span><br><span class="line">            HTTP_Request req;</span><br><span class="line">            req.<span class="built_in">Deserialize</span>(buf);</span><br><span class="line">            req.<span class="built_in">Parse</span>();</span><br><span class="line">            req.<span class="built_in">DebugPrint</span>();</span><br><span class="line"></span><br><span class="line">            std::string text = <span class="built_in">Read_Htmlfile</span>(req.file_path);        <span class="comment">// 读取并构造响应正文内容</span></span><br><span class="line"></span><br><span class="line">            std::string response_line = <span class="string">&quot;HTTP/1.1 200 OK\r\n&quot;</span>;      <span class="comment">// 状态行</span></span><br><span class="line">            std::string response_header = <span class="string">&quot;Content-Length: &quot;</span>;       <span class="comment">// 响应头</span></span><br><span class="line">            response_header += std::<span class="built_in">to_string</span>(text.<span class="built_in">size</span>());</span><br><span class="line">            response_header += <span class="string">&quot;\r\n&quot;</span>;</span><br><span class="line">            std::string blank_line = <span class="string">&quot;\r\n&quot;</span>;    <span class="comment">// 空行</span></span><br><span class="line"></span><br><span class="line">            std::string response = response_line;</span><br><span class="line">            response += response_header;</span><br><span class="line">            response += blank_line;</span><br><span class="line">            response += text;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">send</span>(sockfd, response.<span class="built_in">c_str</span>(), response.<span class="built_in">size</span>(), <span class="number">0</span>);     <span class="comment">// 发送响应</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">close</span>(sockfd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">HandlerHttp4</span><span class="params">(<span class="type">int</span> sockfd)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">char</span> buf[BUFFER_SIZE];</span><br><span class="line">        <span class="type">ssize_t</span> n = <span class="built_in">recv</span>(sockfd, buf, BUFFER_SIZE - <span class="number">1</span>, <span class="number">0</span>);          <span class="comment">// 读取请求数据</span></span><br><span class="line">        <span class="keyword">if</span>(n &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            buf[n] = <span class="string">&#x27;\0&#x27;</span>;                      <span class="comment">// 添加字符串结束符</span></span><br><span class="line">            std::cout &lt;&lt; buf;</span><br><span class="line"></span><br><span class="line">            HTTP_Request req;</span><br><span class="line">            req.<span class="built_in">Deserialize</span>(buf);</span><br><span class="line">            req.<span class="built_in">Parse</span>();</span><br><span class="line">            req.<span class="built_in">DebugPrint</span>();</span><br><span class="line"></span><br><span class="line">            <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">            std::string text = <span class="built_in">Read_Htmlfile</span>(req.file_path);        <span class="comment">// 读取并构造响应正文内容</span></span><br><span class="line">            <span class="keyword">if</span>(text.<span class="built_in">empty</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                std::string err_thml = wwwroot + <span class="string">&quot;/err.html&quot;</span>;</span><br><span class="line">                text = <span class="built_in">Read_Htmlfile</span>(err_thml);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            std::string response_line;          <span class="comment">// 状态行</span></span><br><span class="line">            <span class="keyword">if</span>(flag)</span><br><span class="line">            &#123;</span><br><span class="line">                response_line = <span class="string">&quot;HTTP/1.1 200 OK\r\n&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                response_line = <span class="string">&quot;HTTP/1.1 404 Not Found\r\n&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            std::string response_header = <span class="string">&quot;Content-Length: &quot;</span>;       <span class="comment">// 响应头</span></span><br><span class="line">            response_header += std::<span class="built_in">to_string</span>(text.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 示例：重定向（可取消注释使用）</span></span><br><span class="line">            <span class="comment">//response_header += &quot;Location: https://minbit.top\r\n&quot;;</span></span><br><span class="line"></span><br><span class="line">            response_header += <span class="string">&quot;\r\n&quot;</span>;</span><br><span class="line">            std::string blank_line = <span class="string">&quot;\r\n&quot;</span>;    <span class="comment">// 空行</span></span><br><span class="line"></span><br><span class="line">            std::string response = response_line;</span><br><span class="line">            response += response_header;</span><br><span class="line">            response += blank_line;</span><br><span class="line">            response += text;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">send</span>(sockfd, response.<span class="built_in">c_str</span>(), response.<span class="built_in">size</span>(), <span class="number">0</span>);     <span class="comment">// 发送响应</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">close</span>(sockfd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程运行函数：分离线程 -&gt; 调用处理函数 -&gt; 清理资源</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="title">Thread_Run</span><span class="params">(<span class="type">void</span>* args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">pthread_detach</span>(<span class="built_in">pthread_self</span>());         <span class="comment">// 分离线程，自动回收资源</span></span><br><span class="line">        Thread_Data* td = <span class="built_in">static_cast</span>&lt;Thread_Data*&gt;(args);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用服务器请求处理函数，这里可以选择HandlerHttp1、HandlerHttp2、HandlerHttp3、HandlerHttp4进行不同处理</span></span><br><span class="line">        <span class="comment">// 然而，这些方法并不能使网页上的图片进行显示，原因是图片的Content-Type类型并没有被设置，因此需要在 HTTP 响应头中添加 Content-Type 字段</span></span><br><span class="line">        <span class="comment">// 于是我创建了HTTP_Server_image.hpp对图片（二进制）的处理，并在HTTP_Server_image.cc中调用HTTP_Server_image.hpp的处理函数</span></span><br><span class="line">        <span class="built_in">HandlerHttp4</span>(td-&gt;sockfd);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">delete</span> td;                              <span class="comment">// 释放申请的 Thread_Data</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>由于文件较多，不便展示，这里仅展示关键代码，完整代码详见 <a href="https://github.com/huangcancan-xbc/Linux/tree/master/coding/network/HTTP">GitHub</a>。食用方法：浏览器输入对应的 IP 和端口（示例：主机 IP：端口号），可选访问的路径，但是路径不存在就无法访问。👉 <a href="https://www.bilibili.com/video/BV16MexzkE8P/?share_source=copy_web&vd_source=872e5e3ccf44874c39edaf42e30ab0de">简单的 HTTP 服务器 Demo 演示 | B 站演示</a>。下面简单了解一下 HTTP 请求的请求头：</p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250824231803892.png" alt="PixPin_2025-08-24_23-17-53"></p><blockquote><p>User-Agent（用户代理）是服务器判断客户端身份的关键依据：一方面，爬虫可以通过伪装成真实浏览器的 User-Agent（如 Chrome、Edge 等）来绕过反爬虫机制，避免被封禁；另一方面，网站会根据 User-Agent 中包含的操作系统（如 Windows、Android）和设备类型，在浏览器中会自动推送对应版本的下载链接或适配页面，实现“你用什么设备访问，就给你什么内容”。</p></blockquote><h2 id="6-Cookie-和-Session"><a href="#6-Cookie-和-Session" class="headerlink" title="6. Cookie 和 Session"></a>6. Cookie 和 Session</h2><blockquote><p><a href="https://blog.csdn.net/m0_61832361/article/details/133021177">【HTTP】Cookie 和 Session 详解 | CSDN</a></p><p><a href="https://blog.csdn.net/chenlong_cxy/article/details/124787316">应用层协议 ——— HTTP 协议 | CSDN</a></p><p><a href="https://www.bilibili.com/video/BV1ob4y1Y7Ep/?share_source=copy_web&vd_source=872e5e3ccf44874c39edaf42e30ab0de">Cookie、Session、Token 究竟区别在哪？如何进行身份认证，保持用户登录状态？ | B 站</a></p><p><a href="https://www.bilibili.com/video/BV1eHoqYkEsA/?share_source=copy_web&vd_source=872e5e3ccf44874c39edaf42e30ab0de">浏览器是如何既保护又泄漏你的隐私？ | 从 Cookie、第三方 Cookie 到浏览器指纹 | B 站</a></p><p><a href="https://www.bilibili.com/video/BV1FsSoYdEUG/?share_source=copy_web&vd_source=872e5e3ccf44874c39edaf42e30ab0de">【白】竟然有这么多人不知道 cookie 是什么？雷普了！ | B 站</a></p><p><a href="https://www.bilibili.com/video/BV1tYgazjENg/?share_source=copy_web&vd_source=872e5e3ccf44874c39edaf42e30ab0de">程序员必看：cookie session token 这三者的区别与用途是什么？讲的最通透的一次！ | B 站</a></p><p><a href="https://www.bilibili.com/video/BV1a5411b7HU/?share_source=copy_web&vd_source=872e5e3ccf44874c39edaf42e30ab0de">【前端知识大科普】cookie 到底是什么？ | B 站</a></p></blockquote><blockquote><p>  [!TIP]</p><p>  <strong>上面的视频讲解非常详细，强烈建议观看，下面直接给结论，就不解释原因了。</strong></p></blockquote><h3 id="1-Cookie-基础"><a href="#1-Cookie-基础" class="headerlink" title="1. Cookie 基础"></a>1. Cookie 基础</h3><ol><li><strong>本质</strong>：存放在浏览器端的小型文本数据（<code>key = value</code> 格式），随请求头自动带到服务端。</li><li><strong>用途</strong>：<ul><li>记录用户身份（保持登录状态）。</li><li>存储用户偏好（语言、主题）。</li><li>实现统计&#x2F;追踪（广告、分析）。</li></ul></li><li><strong>分类</strong>：<ul><li><strong>会话 Cookie</strong>（内存级）：存放在内存中，关闭浏览器就没了。</li><li><strong>持久 Cookie</strong>（文件级）：写到磁盘里，有过期时间，可以长期保存。</li></ul></li><li><strong>重要属性</strong>：<ul><li><code>Expires/Max-Age</code>：过期时间。</li><li><code>HttpOnly</code>：JS 不能访问，防止 XSS。</li><li><code>Secure</code>：只能在 HTTPS 传输。</li><li><code>SameSite</code>：防止 CSRF 攻击。</li></ul></li></ol><h3 id="2-Session-基础"><a href="#2-Session-基础" class="headerlink" title="2. Session 基础"></a>2. Session 基础</h3><ol><li><strong>本质</strong>：存在 <strong>服务器端</strong> 的一份用户状态数据，通常用来保存登录信息、购物车等。</li><li><strong>关联方式</strong>：服务端会生成一个 <code>session_id</code>，通过 Cookie（或 URL 参数）传给浏览器。下次请求时，浏览器带上 <code>session_id</code>，服务端根据它找到该用户对应的 Session 数据。</li><li><strong>特点</strong>：<ul><li>更安全（数据不在客户端存，只保存一个 ID）。</li><li>存储空间大（由服务器控制，不受 Cookie 4KB 限制）。</li><li>需要服务器内存&#x2F;数据库支持。</li></ul></li></ol><h3 id="3-Cookie-vs-Session"><a href="#3-Cookie-vs-Session" class="headerlink" title="3. Cookie vs Session"></a>3. Cookie vs Session</h3><table><thead><tr><th>特点</th><th>Cookie (客户端存)</th><th>Session (服务端存)</th></tr></thead><tbody><tr><td>存储位置</td><td>浏览器</td><td>服务器</td></tr><tr><td>存储容量</td><td>单个 4KB，数量有限</td><td>理论无限，取决于服务器资源</td></tr><tr><td>安全性</td><td>容易被窃取&#x2F;篡改，需要加密</td><td>更安全，客户端只保存一个 ID</td></tr><tr><td>生命周期</td><td>由过期时间控制</td><td>一般随会话&#x2F;服务器配置而定</td></tr><tr><td>常见用途</td><td>记住登录状态、个性化配置</td><td>登录态验证、购物车、权限控制</td></tr></tbody></table><h3 id="4-扩展"><a href="#4-扩展" class="headerlink" title="4. 扩展"></a>4. 扩展</h3><ol><li><strong>为什么需要 Session，不能只靠 Cookie？</strong><ul><li>Cookie 存储在客户端，容易篡改、不安全，且存储空间有限；Session 更适合保存关键业务数据。</li></ul></li><li><strong>Session 的实现原理？</strong><ul><li>服务端维护一个 <code>session_id -&gt; 数据</code> 的映射表。客户端每次请求时带上 <code>session_id</code>（通常在 Cookie 里），服务端根据这个 ID 找回对应数据。</li></ul></li><li><strong>Cookie 被禁用了怎么办？</strong><ul><li>可以把 <code>session_id</code> 放到 URL 参数里，但安全性差，一般结合其他手段。</li></ul></li><li><strong>分布式部署时 Session 怎么保持一致？</strong><ul><li>需要做 <strong>Session 共享&#x2F;持久化</strong>，常用方法是把 Session 存在 Redis、数据库里，所有服务器共享。</li></ul></li><li><strong>Token（JWT）和 Session 的区别？</strong><ul><li>Session：状态保存在服务器。</li><li>Token（JWT）：状态保存在客户端（自包含），服务端只做校验，不保存状态，更适合分布式&#x2F;无状态架构。</li></ul></li></ol>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;HTTP-协议&quot;&gt;&lt;a href=&quot;#HTTP-协议&quot; class=&quot;headerlink&quot; title=&quot;HTTP 协议&quot;&gt;&lt;/a&gt;HTTP 协议&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a</summary>
        
      
    
    
    
    <category term="Linux" scheme="https://www.minbit.top/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://www.minbit.top/tags/Linux/"/>
    
    <category term="网络" scheme="https://www.minbit.top/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
</feed>
