<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小米里的大麦</title>
  
  
  <link href="https://www.minbit.top/atom.xml" rel="self"/>
  
  <link href="https://www.minbit.top/"/>
  <updated>2025-12-31T16:00:00.000Z</updated>
  <id>https://www.minbit.top/</id>
  
  <author>
    <name>小米里的大麦</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2025 年度总结</title>
    <link href="https://www.minbit.top/posts/22243.html"/>
    <id>https://www.minbit.top/posts/22243.html</id>
    <published>2025-12-31T16:00:00.000Z</published>
    <updated>2025-12-31T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2025-年度总结"><a href="#2025-年度总结" class="headerlink" title="2025 年度总结"></a>2025 年度总结</h1><p>因为我在写这篇文章的时候正发着烧，所以我想再打磨打磨再公布~</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;2025-年度总结&quot;&gt;&lt;a href=&quot;#2025-年度总结&quot; class=&quot;headerlink&quot; title=&quot;2025 年度总结&quot;&gt;&lt;/a&gt;2025</summary>
        
      
    
    
    
    <category term="历程" scheme="https://www.minbit.top/categories/%E5%8E%86%E7%A8%8B/"/>
    
    
    <category term="历程" scheme="https://www.minbit.top/tags/%E5%8E%86%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>08 表的增删改查下</title>
    <link href="https://www.minbit.top/posts/39993.html"/>
    <id>https://www.minbit.top/posts/39993.html</id>
    <published>2025-12-12T16:00:00.000Z</published>
    <updated>2025-12-16T02:10:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="表的增删改查下"><a href="#表的增删改查下" class="headerlink" title="表的增删改查下"></a>表的增删改查下</h1><h2 id="1-update（修改）"><a href="#1-update（修改）" class="headerlink" title="1. update（修改）"></a>1. update（修改）</h2><h3 id="1-语法"><a href="#1-语法" class="headerlink" title="1. 语法"></a>1. 语法</h3><p>UPDATE 用于修改已有数据，必须配合 WHERE 精确更新；并发场景下要用原子更新和事务，避免先查再改。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> 表名</span><br><span class="line"><span class="keyword">SET</span> 列<span class="number">1</span> <span class="operator">=</span> 值<span class="number">1</span>,</span><br><span class="line">    列<span class="number">2</span> <span class="operator">=</span> 值<span class="number">2</span></span><br><span class="line"><span class="keyword">WHERE</span> 条件;</span><br></pre></td></tr></table></figure><p><strong>注意：UPDATE 会对 <code>WHERE</code> 条件匹配到的「所有行」，统一执行同一套修改，匹配多少行，就改多少行。没有 WHERE &#x3D; 全表修改（极其危险）。</strong></p><h3 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h3><h4 id="1-按主键更新（常用、安全）"><a href="#1-按主键更新（常用、安全）" class="headerlink" title="1. 按主键更新（常用、安全）"></a>1. 按主键更新（常用、安全）</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 按主键更新（常用、安全）：通过主键id精准定位，只改<span class="number">1</span>行</span><br><span class="line"><span class="keyword">UPDATE</span> users</span><br><span class="line"><span class="keyword">SET</span> name <span class="operator">=</span> <span class="string">&#x27;张三&#x27;</span>,  # 把name改成“张三”</span><br><span class="line">    age <span class="operator">=</span> <span class="number">20</span>       # 把age改成<span class="number">20</span></span><br><span class="line"><span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;      # 只改id<span class="operator">=</span><span class="number">1</span>的所有行</span><br></pre></td></tr></table></figure><h4 id="2-更新单个字段"><a href="#2-更新单个字段" class="headerlink" title="2. 更新单个字段"></a>2. 更新单个字段</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 更新单个字段：只修改一个字段的值</span><br><span class="line"><span class="keyword">UPDATE</span> users</span><br><span class="line"><span class="keyword">SET</span> age <span class="operator">=</span> <span class="number">18</span>       # 仅把age改成<span class="number">18</span></span><br><span class="line"><span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">100</span>;    # 只改id<span class="operator">=</span><span class="number">100</span>的所有行</span><br></pre></td></tr></table></figure><h4 id="3-条件更新多行"><a href="#3-条件更新多行" class="headerlink" title="3. 条件更新多行"></a>3. 条件更新多行</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 找出 所有最后登录时间早于 <span class="number">2025</span><span class="number">-01</span><span class="number">-01</span> 的用户，把它们的 id 全部改成 <span class="number">0</span></span><br><span class="line"><span class="keyword">UPDATE</span> users</span><br><span class="line"><span class="keyword">SET</span> id <span class="operator">=</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">WHERE</span> last_login <span class="operator">&lt;</span> <span class="string">&#x27;2025-01-01&#x27;</span>;</span><br></pre></td></tr></table></figure><h4 id="4-自增-自减更新（高频）"><a href="#4-自增-自减更新（高频）" class="headerlink" title="4. 自增 &#x2F; 自减更新（高频）"></a>4. 自增 &#x2F; 自减更新（高频）</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> t1</span><br><span class="line"><span class="keyword">SET</span> cnt <span class="operator">=</span> cnt <span class="operator">-</span> <span class="number">1</span># 用当前cnt值减<span class="number">1</span>，直接更新</span><br><span class="line"><span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">UPDATE</span> t2</span><br><span class="line"><span class="keyword">SET</span> new_count <span class="operator">=</span> new_count <span class="operator">+</span> <span class="number">1</span># 用当前new_count值加<span class="number">1</span>，直接更新</span><br><span class="line"><span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">5</span>;</span><br></pre></td></tr></table></figure><p><strong>注意：不要先 SELECT 查值再 UPDATE（并发场景会出错）。</strong></p><h4 id="5-UPDATE-表达式（能用但要小心）"><a href="#5-UPDATE-表达式（能用但要小心）" class="headerlink" title="5. UPDATE + 表达式（能用但要小心）"></a>5. UPDATE + 表达式（能用但要小心）</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> users</span><br><span class="line"><span class="keyword">SET</span> age <span class="operator">=</span> age <span class="operator">+</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">WHERE</span> birthday <span class="operator">&lt;</span> <span class="string">&#x27;2005-01-01&#x27;</span>;</span><br></pre></td></tr></table></figure><p><strong>注意：SET 中写表达式没问题，WHERE 中尽量别对列做计算</strong></p><h3 id="3-UPDATE-子查询（常见）"><a href="#3-UPDATE-子查询（常见）" class="headerlink" title="3. UPDATE + 子查询（常见）"></a>3. UPDATE + 子查询（常见）</h3><h4 id="1-用查询结果更新"><a href="#1-用查询结果更新" class="headerlink" title="1. 用查询结果更新"></a>1. 用查询结果更新</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> users</span><br><span class="line"><span class="keyword">SET</span> val <span class="operator">=</span> <span class="number">2</span># 把val改成<span class="number">2</span></span><br><span class="line"><span class="keyword">WHERE</span> id <span class="keyword">IN</span> (# 只改id在子查询结果里的行</span><br><span class="line">    <span class="keyword">SELECT</span> id <span class="keyword">FROM</span> t3# 子查询：取t3表中的id</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="2-UPDATE-JOIN（非常常用）"><a href="#2-UPDATE-JOIN（非常常用）" class="headerlink" title="2. UPDATE JOIN（非常常用）"></a>2. UPDATE JOIN（非常常用）</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># <span class="keyword">UPDATE</span> <span class="keyword">JOIN</span>：关联两张表，基于关联条件更新</span><br><span class="line"><span class="keyword">UPDATE</span> orders o  # 给orders表起别名o</span><br><span class="line"><span class="keyword">JOIN</span> users u <span class="keyword">ON</span> o.user_id <span class="operator">=</span> u.id  # 关联orders和users表（通过user_id匹配）</span><br><span class="line"><span class="keyword">SET</span> o.status <span class="operator">=</span> <span class="number">1</span>  # 把orders表的status改成<span class="number">1</span></span><br><span class="line"><span class="keyword">WHERE</span> u.vip <span class="operator">=</span> <span class="number">1</span>;  # 只改“关联到的用户是VIP（u.vip<span class="operator">=</span><span class="number">1</span>）”的订单</span><br><span class="line"># 作用：把所有VIP用户的订单，状态设为<span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="2-Delete（删除）"><a href="#2-Delete（删除）" class="headerlink" title="2. Delete（删除）"></a>2. Delete（删除）</h2><blockquote><ul><li><strong>DELETE</strong>：按条件删“行”，可回滚，可触发器，慢但安全。</li><li><strong>TRUNCATE</strong>：一刀 <strong>清空</strong> 整张表，<strong>不可回滚</strong>，极快，危险。</li></ul></blockquote><h3 id="1-DELETE-删除数据"><a href="#1-DELETE-删除数据" class="headerlink" title="1. DELETE 删除数据"></a>1. DELETE 删除数据</h3><h4 id="1-语法-1"><a href="#1-语法-1" class="headerlink" title="1. 语法"></a>1. 语法</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> 条件;</span><br></pre></td></tr></table></figure><p><strong>注意：没有 WHERE &#x3D; 清空全表数据！</strong></p><h4 id="2-示例-1"><a href="#2-示例-1" class="headerlink" title="2. 示例"></a>2. 示例</h4><h5 id="1-按条件删除（常用）"><a href="#1-按条件删除（常用）" class="headerlink" title="1. 按条件删除（常用）"></a>1. 按条件删除（常用）</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;# 删除users表中所有id<span class="operator">=</span><span class="number">1</span>的行（如果id是主键，只会删<span class="number">1</span>行）</span><br></pre></td></tr></table></figure><h5 id="2-批量删除多行"><a href="#2-批量删除多行" class="headerlink" title="2. 批量删除多行"></a>2. 批量删除多行</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> age <span class="operator">=</span> <span class="number">18</span>; # 删除t1表中所有年龄等于<span class="number">18</span>的行</span><br></pre></td></tr></table></figure><h5 id="3-DELETE-LIMIT（MySQL-特有）"><a href="#3-DELETE-LIMIT（MySQL-特有）" class="headerlink" title="3. DELETE + LIMIT（MySQL 特有）"></a>3. DELETE + LIMIT（MySQL 特有）</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> logs       # 操作logs表</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> created_at    # 按创建时间排序（默认升序，即最早的记录在前）</span><br><span class="line">LIMIT <span class="number">1000</span>;            # 只删除前<span class="number">1000</span>条</span><br></pre></td></tr></table></figure><p>用途：分批清理数据、防止一次删太多（锁表）。</p><h3 id="2-TRUNCATE-截断表（清空表数据）"><a href="#2-TRUNCATE-截断表（清空表数据）" class="headerlink" title="2. TRUNCATE 截断表（清空表数据）"></a>2. TRUNCATE 截断表（清空表数据）</h3><h4 id="1-语法-2"><a href="#1-语法-2" class="headerlink" title="1. 语法"></a>1. 语法</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> 表名;</span><br></pre></td></tr></table></figure><p><code>TRUNCATE</code> 用于想要 <strong>快速清空全表、不要数据（清空表数据，但不删除表）</strong> 的场景。</p><table><thead><tr><th>对比</th><th>TRUNCATE（截断表）</th><th>DELETE（删除）</th></tr></thead><tbody><tr><td>操作类型</td><td>DDL（数据定义语言）</td><td>DML（数据操作语言）</td></tr><tr><td>能否回滚</td><td>不支持（执行后无法恢复数据）</td><td>支持（事务中可回滚）</td></tr><tr><td>清空效率</td><td>极高（直接重置表，不记录单行操作）</td><td>低（逐行删除，记录日志）</td></tr><tr><td>自增主键</td><td>重置为初始值（如自增 id 回到 1）</td><td>保留原自增最大值（如 id 从 100 继续）</td></tr><tr><td>适用场景</td><td>彻底清空表（无需恢复、追求速度）</td><td>条件删除 &#x2F; 部分删除（需可控、可回滚）</td></tr></tbody></table><h4 id="2-示例-2"><a href="#2-示例-2" class="headerlink" title="2. 示例"></a>2. 示例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"># 创建t2表，id为自增主键，name为字符串字段</span><br><span class="line">mysql&gt; create table t2(</span><br><span class="line">    -&gt; id int auto_increment primary key,</span><br><span class="line">    -&gt; name varchar(20));</span><br><span class="line"></span><br><span class="line"># 插入3条数据，id自动从1开始递增</span><br><span class="line">mysql&gt; insert into t2(name) values(&#x27;张三&#x27;),(&#x27;李四&#x27;),(&quot;王五&quot;);</span><br><span class="line"></span><br><span class="line"># 查看t2表所有数据，id依次为1、2、3</span><br><span class="line">mysql&gt; select *from t2;</span><br><span class="line">+----+--------+</span><br><span class="line">| id | name   |</span><br><span class="line">+----+--------+</span><br><span class="line">|  1 | 张三   |</span><br><span class="line">|  2 | 李四   |</span><br><span class="line">|  3 | 王五   |</span><br><span class="line">+----+--------+</span><br><span class="line"></span><br><span class="line"># 截断t2表：清空所有数据，保留表结构，自增主键重置</span><br><span class="line">mysql&gt; truncate table t2;</span><br><span class="line"></span><br><span class="line"># 查看截断后的表，无数据</span><br><span class="line">mysql&gt; select *from t2;</span><br><span class="line">Empty set (0.00 sec)</span><br><span class="line"></span><br><span class="line"># 重新插入2条数据，自增id从1重新开始</span><br><span class="line">mysql&gt; insert into t2(name) values (&quot;赵六&quot;),(&quot;孙奇&quot;);</span><br><span class="line"></span><br><span class="line"># 查看重新插入后的数据，id为1、2</span><br><span class="line">mysql&gt; select *from t2;</span><br><span class="line">+----+--------+</span><br><span class="line">| id | name   |</span><br><span class="line">+----+--------+</span><br><span class="line">|  1 | 赵六   |</span><br><span class="line">|  2 | 孙奇   |</span><br><span class="line">+----+--------+</span><br></pre></td></tr></table></figure><h2 id="3-插入查询结果"><a href="#3-插入查询结果" class="headerlink" title="3. 插入查询结果"></a>3. 插入查询结果</h2><p><strong>插入查询结果用 <code>INSERT INTO ... SELECT ...</code>，意思是：把 SELECT 查出来的结果，直接插入到另一张表，效率高，常用于数据迁移和批量插入，但要求列数和类型严格匹配！而且 <code>INSERT SELECT</code> 是“一条原子操作”，中途出错、整条语句失败、不会插一半！</strong></p><h3 id="1-语法-3"><a href="#1-语法-3" class="headerlink" title="1. 语法"></a>1. 语法</h3><p>插入查询结果的基本用法模板：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> 目标表 (列<span class="number">1</span>, 列<span class="number">2</span>, ...)</span><br><span class="line"><span class="keyword">SELECT</span> 列<span class="number">1</span>, 列<span class="number">2</span>, ...</span><br><span class="line"><span class="keyword">FROM</span> 来源表</span><br><span class="line"><span class="keyword">WHERE</span> 条件;</span><br></pre></td></tr></table></figure><p><strong>插入查询结果表示 SELECT 查什么，INSERT 就插入什么。</strong></p><h3 id="2-示例-3"><a href="#2-示例-3" class="headerlink" title="2. 示例"></a>2. 示例</h3><h4 id="1-把一张表的数据复制到另一张表"><a href="#1-把一张表的数据复制到另一张表" class="headerlink" title="1. 把一张表的数据复制到另一张表"></a>1. 把一张表的数据复制到另一张表</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> x (id, name, age)</span><br><span class="line"><span class="keyword">SELECT</span> id, name, age</span><br><span class="line"><span class="keyword">FROM</span> y;</span><br></pre></td></tr></table></figure><p>把 x 表里的 id、name、age 的数据全部复制到 y 表，不过需要注意：两边列的 <strong>数量和类型要对得上</strong>、顺序按 INSERT 的列顺序来。</p><h4 id="2-按条件插入"><a href="#2-按条件插入" class="headerlink" title="2. 按条件插入"></a>2. 按条件插入</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> x (id, name)</span><br><span class="line"><span class="keyword">SELECT</span> id, name</span><br><span class="line"><span class="keyword">FROM</span> users</span><br><span class="line"><span class="keyword">WHERE</span> age <span class="operator">=</span> <span class="number">18</span>;</span><br></pre></td></tr></table></figure><p>把 age &#x3D; 18 的用户插入到 x 表中。</p><h4 id="3-插入“计算后的结果”"><a href="#3-插入“计算后的结果”" class="headerlink" title="3. 插入“计算后的结果”"></a>3. 插入“计算后的结果”</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> x (id, score)</span><br><span class="line"><span class="keyword">SELECT</span> id, age <span class="operator">*</span> <span class="number">10</span></span><br><span class="line"><span class="keyword">FROM</span> users;</span><br></pre></td></tr></table></figure><p>说明：SELECT 里可以是表达式，插入的是 <strong>计算结果</strong>。所以，这条 sql 语句的意思是：从 <code>users</code> 表中读取所有行的 <code>id</code>，并把 age×10 得到新值，把这些新值插入到 x 表中：<code>users.id</code> 对应 <code>x.id</code>，<code>age×10</code> 对应 <code>x.score</code>。</p><h4 id="4-从多表查询结果插入（JOIN、进阶）"><a href="#4-从多表查询结果插入（JOIN、进阶）" class="headerlink" title="4. 从多表查询结果插入（JOIN、进阶）"></a>4. 从多表查询结果插入（JOIN、进阶）</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 关联查询<span class="operator">+</span>批量插入：从y表和users表关联查询数据，再插回y表</span><br><span class="line"><span class="keyword">INSERT INTO</span> y (id, name)  # 往y表的id、name字段插入数据</span><br><span class="line"><span class="keyword">SELECT</span> o.id, u.name       # 取y表（别名o）的id、users表（别名u）的name</span><br><span class="line"><span class="keyword">FROM</span> y o                  # 数据源<span class="number">1</span>：y表，起别名o</span><br><span class="line"><span class="keyword">JOIN</span> users u <span class="keyword">ON</span> o.user_id <span class="operator">=</span> u.id;  # 关联users表（别名u）：y.user_id <span class="operator">=</span> users.id</span><br></pre></td></tr></table></figure><h3 id="3-INSERT-SELECT-和普通-INSERT-的区别"><a href="#3-INSERT-SELECT-和普通-INSERT-的区别" class="headerlink" title="3. INSERT SELECT 和普通 INSERT 的区别"></a>3. INSERT SELECT 和普通 INSERT 的区别</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> x <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">&#x27;test&#x27;</span>, <span class="number">20</span>);# 手写值、一次一行（少量）</span><br><span class="line"><span class="keyword">INSERT INTO</span> y <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users;# 来源是查询结果、可一次插 成千上万行、效率高</span><br></pre></td></tr></table></figure><h3 id="4-和主键-唯一键冲突怎么办？"><a href="#4-和主键-唯一键冲突怎么办？" class="headerlink" title="4. 和主键 &#x2F; 唯一键冲突怎么办？"></a>4. 和主键 &#x2F; 唯一键冲突怎么办？</h3><h4 id="1-冲突就失败（默认）"><a href="#1-冲突就失败（默认）" class="headerlink" title="1. 冲突就失败（默认）"></a>1. 冲突就失败（默认）</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> x (id, name) <span class="keyword">SELECT</span> id, name <span class="keyword">FROM</span> users;# 如果id已存在，直接报错，整条失败</span><br></pre></td></tr></table></figure><h4 id="2-忽略冲突行（不推荐滥用）"><a href="#2-忽略冲突行（不推荐滥用）" class="headerlink" title="2. 忽略冲突行（不推荐滥用）"></a>2. 忽略冲突行（不推荐滥用）</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> IGNORE <span class="keyword">INTO</span> x (id, name) <span class="keyword">SELECT</span> id, name <span class="keyword">FROM</span> users;# 冲突的行被跳过、不报错、容易悄悄丢数据</span><br></pre></td></tr></table></figure><h4 id="3-冲突就更新（常用）"><a href="#3-冲突就更新（常用）" class="headerlink" title="3. 冲突就更新（常用）"></a>3. 冲突就更新（常用）</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 有就更新，没有就插入：</span><br><span class="line"><span class="keyword">INSERT INTO</span> x (id, name)</span><br><span class="line"><span class="keyword">SELECT</span> id, name <span class="keyword">FROM</span> users</span><br><span class="line"><span class="keyword">ON</span> DUPLICATE KEY <span class="keyword">UPDATE</span></span><br><span class="line">name <span class="operator">=</span> <span class="keyword">VALUES</span>(name);</span><br></pre></td></tr></table></figure><h2 id="4-聚合函数"><a href="#4-聚合函数" class="headerlink" title="4. 聚合函数"></a>4. 聚合函数</h2><blockquote><p>  聚合函数可以把多行数据计算成一个结果，常与 GROUP BY 和 HAVING 配合使用，WHERE 负责聚合前过滤，HAVING 负责聚合后过滤。</p></blockquote><h3 id="1-常见聚合函数一览"><a href="#1-常见聚合函数一览" class="headerlink" title="1. 常见聚合函数一览"></a>1. 常见聚合函数一览</h3><table><thead><tr><th align="center">函数</th><th>作用</th><th>解释</th></tr></thead><tbody><tr><td align="center"><code>COUNT()</code></td><td>计数</td><td>有多少行</td></tr><tr><td align="center"><code>SUM()</code></td><td>求和</td><td>数字加起来</td></tr><tr><td align="center"><code>AVG()</code></td><td>平均值</td><td>求平均</td></tr><tr><td align="center"><code>MAX()</code></td><td>最大值</td><td>找最大的</td></tr><tr><td align="center"><code>MIN()</code></td><td>最小值</td><td>找最小的</td></tr></tbody></table><h4 id="1-COUNT（计数、常用）"><a href="#1-COUNT（计数、常用）" class="headerlink" title="1. COUNT（计数、常用）"></a>1. COUNT（计数、常用）</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> users;# 统计users表一共有多少行数据(<span class="operator">*</span>会统计<span class="keyword">NULL</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(列名) <span class="keyword">FROM</span> users;# 不会统计<span class="keyword">NULL</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(email) <span class="keyword">FROM</span> users;# 只统计email不为<span class="keyword">NULL</span>的行数</span><br></pre></td></tr></table></figure><h4 id="2-SUM（求和）"><a href="#2-SUM（求和）" class="headerlink" title="2. SUM（求和）"></a>2. SUM（求和）</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">SUM</span>(列名) <span class="keyword">FROM</span> users;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">SUM</span>(id) <span class="keyword">FROM</span> users;# 把users表中所有的id加和</span><br></pre></td></tr></table></figure><p><strong>注意：列必须是数字、NULL 会被自动忽略。</strong></p><h4 id="3-AVG（平均值）"><a href="#3-AVG（平均值）" class="headerlink" title="3. AVG（平均值）"></a>3. AVG（平均值）</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">AVG</span>(列名) <span class="keyword">FROM</span> users;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">AVG</span>(age) <span class="keyword">FROM</span> users;# 统计users表中所有年龄的平均值</span><br></pre></td></tr></table></figure><p><strong>注意：NULL 不参与计算、返回值可能是小数。</strong></p><h4 id="4-MAX-MIN（最大最小）"><a href="#4-MAX-MIN（最大最小）" class="headerlink" title="4. MAX &#x2F; MIN（最大最小）"></a>4. MAX &#x2F; MIN（最大最小）</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MAX</span>(age), <span class="built_in">MIN</span>(age) <span class="keyword">FROM</span> users;# 找出users表中最大和最小年龄</span><br></pre></td></tr></table></figure><h4 id="5-示例"><a href="#5-示例" class="headerlink" title="5. 示例"></a>5. 示例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"># 查看t1表所有数据</span><br><span class="line">mysql&gt; select *from t1;</span><br><span class="line">+-----+--------------+------+</span><br><span class="line">| id  | name         | age  |</span><br><span class="line">+-----+--------------+------+</span><br><span class="line">|   1 | 张三         |   20 |</span><br><span class="line">|   2 | 李四         |   20 |</span><br><span class="line">|   4 | 李四         |   25 |</span><br><span class="line">|   5 | 王五         |   18 |</span><br><span class="line">|   7 | 小明         |   18 |</span><br><span class="line">|  99 | 小红红       |   18 |</span><br><span class="line">| 100 | 我已修改     |   88 |</span><br><span class="line">| 101 | 李四         |  111 |</span><br><span class="line">| 102 | 李四         |  111 |</span><br><span class="line">+-----+--------------+------+</span><br><span class="line"></span><br><span class="line"># 统计t1表中id字段的非空行数（即表的总记录数）</span><br><span class="line">mysql&gt; select count(id) from t1;</span><br><span class="line">+-----------+</span><br><span class="line">| count(id) |</span><br><span class="line">+-----------+</span><br><span class="line">|         9 |  # 共9条记录</span><br><span class="line">+-----------+</span><br><span class="line"></span><br><span class="line"># 计算t1表中所有id字段值的总和</span><br><span class="line">mysql&gt; select sum(id) from t1;</span><br><span class="line">+---------+</span><br><span class="line">| sum(id) |</span><br><span class="line">+---------+</span><br><span class="line">|     421 |  # 1+2+4+5+7+99+100+101+102=421</span><br><span class="line">+---------+</span><br><span class="line"></span><br><span class="line"># 计算t1表中age字段的平均值（保留4位小数）</span><br><span class="line">mysql&gt; select avg(age) from t1;</span><br><span class="line">+----------+</span><br><span class="line">| avg(age) |</span><br><span class="line">+----------+</span><br><span class="line">|  47.6667 |  # (20+20+25+18+18+18+88+111+111)/9 ≈ 47.6667</span><br><span class="line">+----------+</span><br><span class="line"></span><br><span class="line"># 同时查询t1表中age字段的最大值和最小值</span><br><span class="line">mysql&gt; select max(age),min(age) from t1;</span><br><span class="line">+----------+----------+</span><br><span class="line">| max(age) | min(age) |</span><br><span class="line">+----------+----------+</span><br><span class="line">|      111 |       18 |  # age最大值111，最小值18</span><br><span class="line">+----------+----------+</span><br></pre></td></tr></table></figure><h3 id="2-聚合-WHERE（常见）"><a href="#2-聚合-WHERE（常见）" class="headerlink" title="2. 聚合 + WHERE（常见）"></a>2. 聚合 + WHERE（常见）</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) </span><br><span class="line"><span class="keyword">FROM</span> users</span><br><span class="line"><span class="keyword">WHERE</span> age <span class="operator">=</span> <span class="number">18</span>;</span><br></pre></td></tr></table></figure><h2 id="5-分组查询"><a href="#5-分组查询" class="headerlink" title="5. 分组查询"></a>5. 分组查询</h2><p><strong>分组查询就是把查询结果按某个字段分成一组一组的，然后每组算一次。</strong></p><h3 id="1-语法-4"><a href="#1-语法-4" class="headerlink" title="1. 语法"></a>1. 语法</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 分组列, 聚合函数</span><br><span class="line"><span class="keyword">FROM</span> 表</span><br><span class="line"><span class="keyword">WHERE</span> 条件</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> 分组列;</span><br></pre></td></tr></table></figure><p>执行顺序：WHERE（先筛选行）→ GROUP BY（再分组）→ 聚合函数（每组算一次）→ HAVING（对分组后的结果筛选）→ ORDER BY（排序） → LIMIT（分页）。</p><h3 id="2-示例-4"><a href="#2-示例-4" class="headerlink" title="2. 示例"></a>2. 示例</h3><h4 id="1-按某个字段分组统计数量"><a href="#1-按某个字段分组统计数量" class="headerlink" title="1. 按某个字段分组统计数量"></a>1. 按某个字段分组统计数量</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 按age字段分组，统计每个年龄的人数</span><br><span class="line"><span class="keyword">SELECT</span> age, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> cnt# 查age值，用<span class="built_in">COUNT</span>(<span class="operator">*</span>)统计每组的行数，别名cnt</span><br><span class="line"><span class="keyword">FROM</span> users# 查的是users表</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> age;# 按age字段分组（相同age的行是一组）</span><br></pre></td></tr></table></figure><h4 id="2-分组-WHERE（常见）"><a href="#2-分组-WHERE（常见）" class="headerlink" title="2. 分组 + WHERE（常见）"></a>2. 分组 + WHERE（常见）</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 先找age<span class="operator">=</span><span class="number">18</span>的用户，再按id分组统计</span><br><span class="line"><span class="keyword">SELECT</span> id, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> my_id# 查id，统计每组行数，别名my_id</span><br><span class="line"><span class="keyword">FROM</span> users# 查的是users表</span><br><span class="line"><span class="keyword">WHERE</span> age <span class="operator">=</span> <span class="number">18</span># 先找出age<span class="operator">=</span><span class="number">18</span>的行</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> id;# 再按id分组</span><br></pre></td></tr></table></figure><h4 id="3-分组-多个聚合函数"><a href="#3-分组-多个聚合函数" class="headerlink" title="3. 分组 + 多个聚合函数"></a>3. 分组 + 多个聚合函数</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> class_id,  # 按班级分组，展示班级ID</span><br><span class="line">  <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> student_count,  # 统计每个班级的学生总数（别名student_count）</span><br><span class="line">  <span class="built_in">SUM</span>(age) <span class="keyword">AS</span> total_age,      # 计算每个班级学生的年龄总和（别名total_age）</span><br><span class="line">  <span class="built_in">MAX</span>(age) <span class="keyword">AS</span> max_age         # 找出每个班级学生的最大年龄（别名max_age）</span><br><span class="line"><span class="keyword">FROM</span> students  # 学生表</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> class_id;  # 按班级ID分组（同一班级的学生归为一组）</span><br></pre></td></tr></table></figure><hr><h3 id="3-GROUP-BY"><a href="#3-GROUP-BY" class="headerlink" title="3. GROUP BY"></a>3. GROUP BY</h3><blockquote><ul><li><strong>非聚合列</strong>：比如 <code>id</code>、<code>age</code>（是直接从表中取的字段，不是聚合计算的结果）。</li><li><strong>聚合列</strong>：比如 <code>COUNT(*)</code>（是对一组数据计算后的结果）。</li></ul></blockquote><p><strong>SELECT 里出现的非聚合列，必须出现在 GROUP BY 中：</strong> <code>SELECT</code> 中出现的 <strong>非聚合列</strong>（直接取的学生 &#x2F; 班级字段，如 <code>class_id</code>、<code>gender</code>），必须出现在 <code>GROUP BY</code> 里，只有 <strong>聚合列</strong>（COUNT&#x2F;SUM&#x2F;AVG 等计算结果），可以不出现在 <code>GROUP BY</code> 里。这句话可能不要好理解，说白了就是：<strong>只要 SELECT 里所有 “直接抄的字段”（非聚合列），在后面 GROUP BY 中出现就合法，不管聚合列有 1 个还是 10 个，都绝对安全，反之，哪怕只漏 1 个非聚合列，就会报错&#x2F;出脏数据。</strong></p><h4 id="1-错误示例"><a href="#1-错误示例" class="headerlink" title="1. 错误示例"></a>1. 错误示例</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 错误写法：<span class="keyword">SELECT</span>里有class_id、gender（两个非聚合列），但<span class="keyword">GROUP</span> <span class="keyword">BY</span>只写了class_id</span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  class_id,  # 非聚合列<span class="number">1</span></span><br><span class="line">  gender,    # 非聚合列<span class="number">2</span>（未出现在<span class="keyword">GROUP</span> <span class="keyword">BY</span>）</span><br><span class="line">  <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> student_num  # 聚合列（统计人数）</span><br><span class="line"><span class="keyword">FROM</span> student</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> class_id;  # 仅按班级分组</span><br></pre></td></tr></table></figure><p>原因：同一个 class_id 可能有多条 gender，MySQL 不知道该选哪一个。</p><h4 id="2-正确使用"><a href="#2-正确使用" class="headerlink" title="2. 正确使用"></a>2. 正确使用</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># class_id是分组依据（非聚合列），出现在<span class="keyword">GROUP</span> <span class="keyword">BY</span>里；<span class="built_in">COUNT</span>(<span class="operator">*</span>)是对每个班级的学生数做聚合计算，不需要<span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line"><span class="keyword">SELECT</span> class_id,  # 非聚合列（出现在<span class="keyword">GROUP</span> <span class="keyword">BY</span>，作为分组依据）</span><br><span class="line">  <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> student_num  # 聚合列（无需在<span class="keyword">GROUP</span> <span class="keyword">BY</span>）</span><br><span class="line"><span class="keyword">FROM</span> student</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> class_id;  # 分组依据：班级ID</span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># class_id和gender都是非聚合列，且都出现在<span class="keyword">GROUP</span> <span class="keyword">BY</span>里，MySQL会按班级<span class="operator">+</span>性别组合分组（比如<span class="number">1</span>班<span class="operator">+</span>男为一组）</span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  class_id,  # 非聚合列<span class="number">1</span>（加入<span class="keyword">GROUP</span> <span class="keyword">BY</span>）</span><br><span class="line">  gender,    # 非聚合列<span class="number">2</span>（加入<span class="keyword">GROUP</span> <span class="keyword">BY</span>）</span><br><span class="line">  <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> student_num  # 聚合列</span><br><span class="line"><span class="keyword">FROM</span> student</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> class_id, gender;  # 所有非聚合列都在<span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br></pre></td></tr></table></figure><h3 id="4-GROUP-BY-多列分组（实用）"><a href="#4-GROUP-BY-多列分组（实用）" class="headerlink" title="4. GROUP BY 多列分组（实用）"></a>4. GROUP BY 多列分组（实用）</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id, age, <span class="built_in">COUNT</span>(<span class="operator">*</span>)</span><br><span class="line"><span class="keyword">FROM</span> users</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> id, age;# 先按id分再按年龄分</span><br></pre></td></tr></table></figure><h3 id="5-HAVING-——-分组后的-WHERE"><a href="#5-HAVING-——-分组后的-WHERE" class="headerlink" title="5. HAVING —— 分组后的 WHERE"></a>5. HAVING —— 分组后的 WHERE</h3><h4 id="1-为什么需要-HAVING？"><a href="#1-为什么需要-HAVING？" class="headerlink" title="1. 为什么需要 HAVING？"></a>1. 为什么需要 HAVING？</h4><p><code>HAVING</code> 是 <strong>对「分组后的结果」进行筛选</strong>（过滤掉不满足条件的分组），搭配 <code>GROUP BY</code> 使用。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> class_id,</span><br><span class="line">  <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> student_num</span><br><span class="line"><span class="keyword">FROM</span> student</span><br><span class="line"><span class="keyword">WHERE</span> age <span class="operator">&gt;=</span> <span class="number">18</span>  # 分组前：只保留年龄≥<span class="number">18</span>的学生</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> class_id;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> class_id,</span><br><span class="line">  <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> student_num</span><br><span class="line"><span class="keyword">FROM</span> student</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> class_id</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="operator">&gt;=</span> <span class="number">3</span>;  # 分组后：只保留学生数≥<span class="number">3</span>的班级</span><br></pre></td></tr></table></figure><h4 id="2-WHERE-vs-HAVING"><a href="#2-WHERE-vs-HAVING" class="headerlink" title="2. WHERE vs HAVING"></a>2. WHERE vs HAVING</h4><table><thead><tr><th>对比</th><th>WHERE</th><th>HAVING</th></tr></thead><tbody><tr><td>筛选时机</td><td>分组 <strong>之前</strong> 筛选行</td><td>分组 <strong>之后</strong> 筛选分组</td></tr><tr><td>作用对象</td><td>原始行（比如单个学生）</td><td>分组结果（比如整个班级）</td></tr><tr><td>是否依赖 GROUP BY</td><td>不需要（可单独用）</td><td>必须搭配 GROUP BY 使用</td></tr><tr><td>能否用聚合函数</td><td>不能（只能用原始字段，如 <code>age &lt; 18</code>）</td><td>能（可以用聚合函数，如 <code>COUNT(*) &gt; 2</code>）</td></tr></tbody></table><h4 id="3-示例"><a href="#3-示例" class="headerlink" title="3. 示例"></a>3. 示例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT class_id,</span><br><span class="line">  COUNT(*) AS student_num</span><br><span class="line">FROM student</span><br><span class="line">GROUP BY class_id          # 步骤1：按班级分组统计人数</span><br><span class="line">HAVING COUNT(*) &gt;= 2       # 步骤2：过滤出人数≥2的班级</span><br><span class="line">ORDER BY student_num DESC, class_id ASC;  # 步骤3：对过滤后的结果排序</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT class_id, gender,</span><br><span class="line">  COUNT(*) AS student_num</span><br><span class="line">FROM student</span><br><span class="line">GROUP BY class_id, gender  # 步骤1：按“班级+性别”分组统计</span><br><span class="line">HAVING COUNT(*) &gt;= 2       # 步骤2：过滤出人数≥2的分组</span><br><span class="line">ORDER BY student_num DESC, class_id ASC;  # 步骤3：对过滤后的结果排序</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;表的增删改查下&quot;&gt;&lt;a href=&quot;#表的增删改查下&quot; class=&quot;headerlink&quot; title=&quot;表的增删改查下&quot;&gt;&lt;/a&gt;表的增删改查下&lt;/h1&gt;&lt;h2 id=&quot;1-update（修改）&quot;&gt;&lt;a href=&quot;#1-update（修改）&quot;</summary>
        
      
    
    
    
    <category term="MySQL" scheme="https://www.minbit.top/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="https://www.minbit.top/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu 22.04 中安装 thefuck 与 tldr 工具</title>
    <link href="https://www.minbit.top/posts/38170.html"/>
    <id>https://www.minbit.top/posts/38170.html</id>
    <published>2025-11-22T04:00:00.000Z</published>
    <updated>2025-11-22T04:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Ubuntu-22-04-中安装-thefuck-与-tldr-工具"><a href="#Ubuntu-22-04-中安装-thefuck-与-tldr-工具" class="headerlink" title="Ubuntu 22.04 中安装 thefuck 与 tldr 工具"></a>Ubuntu 22.04 中安装 thefuck 与 tldr 工具</h1><p>作为一名经常使用终端的开发者，拥有高效的命令行工具能极大提升工作效率。本文将详细介绍如何在 Ubuntu 22.04 系统上安装和配置两款非常实用的终端工具：<code>thefuck</code>（命令纠错工具）和 <code>tldr</code>（简洁帮助文档工具），并分享安装过程中遇到的问题及解决方案。</p><h2 id="1-工具介绍"><a href="#1-工具介绍" class="headerlink" title="1. 工具介绍"></a>1. 工具介绍</h2><h3 id="1-thefuck：智能命令纠错工具"><a href="#1-thefuck：智能命令纠错工具" class="headerlink" title="1. thefuck：智能命令纠错工具"></a>1. <a href="https://github.com/nvbn/thefuck">thefuck</a>：智能命令纠错工具</h3><p><code>thefuck</code> 是一款神奇的<strong>命令行纠错工具</strong>，当你输入错误的命令时，只需输入 <code>fuck</code>，它就能智能分析并纠正你的命令错误。支持纠正拼写错误、权限问题、命令不存在等多种常见错误。</p><h3 id="2-tldr：简洁明了的帮助文档"><a href="#2-tldr：简洁明了的帮助文档" class="headerlink" title="2. tldr：简洁明了的帮助文档"></a>2. <a href="https://github.com/tldr-pages/tldr">tldr</a>：简洁明了的帮助文档</h3><p><code>tldr</code>（Too Long; Didn’t Read）是传统 <code>man</code> 命令的替代品，提供简洁明了的命令使用示例，特别适合快速查询命令用法。支持多语言，本文将配置为中文。</p><h2 id="2-thefuck-安装与配置"><a href="#2-thefuck-安装与配置" class="headerlink" title="2. thefuck 安装与配置"></a>2. thefuck 安装与配置</h2><h3 id="第一步：安装依赖包"><a href="#第一步：安装依赖包" class="headerlink" title="第一步：安装依赖包"></a>第一步：安装依赖包</h3><p>首先确保系统已安装必要的 Python 依赖：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt install python3-dev python3-pip python3-setuptools</span><br></pre></td></tr></table></figure><h3 id="第二步：安装-thefuck"><a href="#第二步：安装-thefuck" class="headerlink" title="第二步：安装 thefuck"></a>第二步：安装 thefuck</h3><h4 id="方法一：使用-pip-安装（推荐）"><a href="#方法一：使用-pip-安装（推荐）" class="headerlink" title="方法一：使用 pip 安装（推荐）"></a>方法一：使用 pip 安装（推荐）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install thefuck --user</span><br></pre></td></tr></table></figure><p>安装完成后，会出现以下警告信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WARNING: The scripts fuck and thefuck are installed <span class="keyword">in</span> <span class="string">&#x27;/root/.local/bin&#x27;</span> <span class="built_in">which</span> is not on PATH.</span><br></pre></td></tr></table></figure><p>这表明安装路径不在系统的 PATH 环境变量中，需要手动添加。</p><h4 id="方法二：使用-apt-安装（备选方案）"><a href="#方法二：使用-apt-安装（备选方案）" class="headerlink" title="方法二：使用 apt 安装（备选方案）"></a>方法二：使用 apt 安装（备选方案）</h4><p>如果 pip 安装遇到问题，也可以使用系统包管理器安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install thefuck</span><br></pre></td></tr></table></figure><h3 id="第三步：配置环境变量和别名"><a href="#第三步：配置环境变量和别名" class="headerlink" title="第三步：配置环境变量和别名"></a>第三步：配置环境变量和别名</h3><p>编辑 <code>.bashrc</code> 文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.bashrc</span><br></pre></td></tr></table></figure><p>添加以下内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加 thefuck 安装路径到 PATH</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="string">&quot;<span class="variable">$HOME</span>/.local/bin:<span class="variable">$PATH</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置 thefuck 别名</span></span><br><span class="line"><span class="built_in">eval</span> <span class="string">&quot;<span class="subst">$(thefuck --alias)</span>&quot;</span></span><br></pre></td></tr></table></figure><p>使配置生效：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure><h3 id="第四步：验证安装"><a href="#第四步：验证安装" class="headerlink" title="第四步：验证安装"></a>第四步：验证安装</h3><p>测试 <code>thefuck</code> 是否正常工作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 故意输入错误命令</span></span><br><span class="line">lt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 fuck 纠正</span></span><br><span class="line">fuck</span><br></pre></td></tr></table></figure><p>正常情况下，<code>thefuck</code> 会智能识别错误并提供修正建议：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get install looptools &amp;&amp; lt [enter/↑/↓/ctrl+c]</span><br></pre></td></tr></table></figure><h2 id="3-tldr-安装与配置（中文版本）"><a href="#3-tldr-安装与配置（中文版本）" class="headerlink" title="3. tldr 安装与配置（中文版本）"></a>3. tldr 安装与配置（中文版本）</h2><h3 id="第一步：安装-pipx"><a href="#第一步：安装-pipx" class="headerlink" title="第一步：安装 pipx"></a>第一步：安装 pipx</h3><p><code>tldr</code> 推荐使用 <code>pipx</code> 进行安装，以确保隔离性：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt update &amp;&amp; <span class="built_in">sudo</span> apt install -y pipx</span><br><span class="line"></span><br><span class="line">pipx ensurepath</span><br></pre></td></tr></table></figure><h3 id="第二步：安装-tldr"><a href="#第二步：安装-tldr" class="headerlink" title="第二步：安装 tldr"></a>第二步：安装 tldr</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pipx install tldr</span><br></pre></td></tr></table></figure><h4 id="解决网络超时问题"><a href="#解决网络超时问题" class="headerlink" title="解决网络超时问题"></a>解决网络超时问题</h4><p>如果遇到以下超时错误：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip._vendor.urllib3.exceptions.ReadTimeoutError: HTTPSConnectionPool(host=<span class="string">&#x27;files.pythonhosted.org&#x27;</span>, port=443): Read timed out.</span><br></pre></td></tr></table></figure><p>可以配置 pip 国内镜像源加速下载：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p ~/.pip</span><br><span class="line"><span class="built_in">cat</span> &gt; ~/.pip/pip.conf &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[global]</span></span><br><span class="line"><span class="string">index-url = https://mirrors.aliyun.com/pypi/simple/</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[install]</span></span><br><span class="line"><span class="string">trusted-host = mirrors.aliyun.com</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure><p>然后重新安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pipx uninstall tldr</span><br><span class="line">pipx install tldr</span><br></pre></td></tr></table></figure><h3 id="第三步：配置中文显示"><a href="#第三步：配置中文显示" class="headerlink" title="第三步：配置中文显示"></a>第三步：配置中文显示</h3><h4 id="安装中文语言包"><a href="#安装中文语言包" class="headerlink" title="安装中文语言包"></a>安装中文语言包</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install -y locales language-pack-zh-hans</span><br></pre></td></tr></table></figure><h4 id="配置-locale"><a href="#配置-locale" class="headerlink" title="配置 locale"></a>配置 locale</h4><p>运行 locale 配置工具：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> dpkg-reconfigure locales</span><br></pre></td></tr></table></figure><p>在图形界面中：</p><ol><li><p>找到 <code>zh_CN.UTF-8 UTF-8</code>，按空格键勾选。</p></li><li><p>选择 <code>zh_CN.UTF-8</code> 作为默认 locale。</p></li><li><p>按 Tab 键切换到 OK，回车确认。</p></li></ol><h4 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h4><p>编辑 <code>.bashrc</code> 文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.bashrc</span><br></pre></td></tr></table></figure><p>添加以下内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置中文环境</span></span><br><span class="line"><span class="built_in">export</span> LANGUAGE=<span class="string">&quot;zh:en&quot;</span></span><br><span class="line"><span class="built_in">export</span> LC_MESSAGES=<span class="string">&quot;zh\_CN.UTF-8&quot;</span></span><br><span class="line"><span class="built_in">export</span> LC_ALL=<span class="string">&quot;zh\_CN.UTF-8&quot;</span></span><br></pre></td></tr></table></figure><p>使配置生效：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure><h3 id="第四步：同步-tldr-数据"><a href="#第四步：同步-tldr-数据" class="headerlink" title="第四步：同步 tldr 数据"></a>第四步：同步 tldr 数据</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tldr --update</span><br></pre></td></tr></table></figure><h3 id="第五步：验证安装"><a href="#第五步：验证安装" class="headerlink" title="第五步：验证安装"></a>第五步：验证安装</h3><p>测试 tldr 是否正常工作并显示中文：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tldr <span class="built_in">ls</span></span><br></pre></td></tr></table></figure><p>正常情况下，会显示中文的简洁帮助文档：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">root@hcss-ecs-be68:~# tldr <span class="built_in">ls</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">ls</span></span><br><span class="line"></span><br><span class="line">  列出目录中的内容。</span><br><span class="line">  更多信息：https://www.gnu.org/software/coreutils/manual/html_node/ls-invocation.html.</span><br><span class="line"></span><br><span class="line">  - 列出目录中的文件，每个文件占一行：</span><br><span class="line">    <span class="built_in">ls</span> -1</span><br><span class="line"></span><br><span class="line">  - 列出包含隐藏文件的所有文件：</span><br><span class="line">    <span class="built_in">ls</span> --all</span><br><span class="line"></span><br><span class="line">  - 列出所有文件，如果是目录，则在目录名后面加上「/」：</span><br><span class="line">    <span class="built_in">ls</span> --classify</span><br><span class="line"></span><br><span class="line">  - 列出包含隐藏文件的所有文件信息，包括权限，所有者，大小和修改日期：</span><br><span class="line">    <span class="built_in">ls</span> --all -l</span><br><span class="line"></span><br><span class="line">  - 列出所有文件信息，大小用人类可读的单位表示（KiB, MiB, GiB）：</span><br><span class="line">    <span class="built_in">ls</span> -l --human-readable</span><br><span class="line"></span><br><span class="line">  - 列出所有文件信息，按大小降序排序：</span><br><span class="line">    <span class="built_in">ls</span> -lSR|-lS --recursive</span><br><span class="line"></span><br><span class="line">  - 列出所有文件信息，按修改日期从旧到新排序：</span><br><span class="line">    <span class="built_in">ls</span> -lt --reverse</span><br><span class="line"></span><br><span class="line">  - 只列出目录：</span><br><span class="line">    <span class="built_in">ls</span> --directory */</span><br></pre></td></tr></table></figure><h2 id="4-常见问题及解决方案"><a href="#4-常见问题及解决方案" class="headerlink" title="4. 常见问题及解决方案"></a>4. 常见问题及解决方案</h2><h3 id="问题一：thefuck-命令找不到"><a href="#问题一：thefuck-命令找不到" class="headerlink" title="问题一：thefuck 命令找不到"></a>问题一：thefuck 命令找不到</h3><p><strong>错误信息</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Command <span class="string">&#x27;thefuck&#x27;</span> not found</span><br></pre></td></tr></table></figure><p><strong>解决方案</strong>：</p><p>确保 <code>/root/.local/bin</code> 已添加到 PATH 环境变量：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=<span class="string">&quot;<span class="variable">$HOME</span>/.local/bin:<span class="variable">$PATH</span>&quot;</span></span><br></pre></td></tr></table></figure><h3 id="问题二：中文-locale-配置错误"><a href="#问题二：中文-locale-配置错误" class="headerlink" title="问题二：中文 locale 配置错误"></a>问题二：中文 locale 配置错误</h3><p><strong>错误信息</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-bash: warning: setlocale: LC_MESSAGES: cannot change locale (zh_CN.UTF-8): No such file or directory</span><br></pre></td></tr></table></figure><p><strong>解决方案</strong>：</p><p>安装中文语言包并重新配置 locale：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install -y language-pack-zh-hans</span><br><span class="line"><span class="built_in">sudo</span> dpkg-reconfigure locales</span><br></pre></td></tr></table></figure><h3 id="问题三：pipx-安装-tldr-超时"><a href="#问题三：pipx-安装-tldr-超时" class="headerlink" title="问题三：pipx 安装 tldr 超时"></a>问题三：pipx 安装 tldr 超时</h3><p><strong>错误信息</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReadTimeoutError: HTTPSConnectionPool(host=<span class="string">&#x27;files.pythonhosted.org&#x27;</span>, port=443): Read timed out.</span><br></pre></td></tr></table></figure><p><strong>解决方案</strong>：</p><p>配置 pip 国内镜像源，或使用代理加速下载。</p><h2 id="5-工具使用技巧"><a href="#5-工具使用技巧" class="headerlink" title="5. 工具使用技巧"></a>5. 工具使用技巧</h2><h3 id="1-thefuck-使用技巧"><a href="#1-thefuck-使用技巧" class="headerlink" title="1. thefuck 使用技巧"></a>1. thefuck 使用技巧</h3><ol><li><p><strong>基本使用</strong>：输入错误命令后，直接输入 <code>fuck</code> 即可纠正。</p></li><li><p><strong>跳过确认</strong>：使用 <code>fuck --yeah</code> 或 <code>fuck -y</code> 直接执行修正后的命令。</p></li><li><p><strong>递归纠正</strong>：使用 <code>fuck -r</code> 递归纠正命令直到成功。</p></li></ol><h3 id="2-tldr-使用技巧"><a href="#2-tldr-使用技巧" class="headerlink" title="2. tldr 使用技巧"></a>2. tldr 使用技巧</h3><ol><li><p><strong>基本查询</strong>：<code>tldr &lt;命令&gt;</code> 显示指定命令的帮助。</p></li><li><p><strong>指定平台</strong>：<code>tldr -p linux &lt;命令&gt;</code> 显示特定平台的命令用法。</p></li><li><p><strong>更新数据</strong>：定期运行 <code>tldr --update</code> 同步最新的帮助文档。</p></li><li><p><strong>搜索命令</strong>：<code>tldr --search &lt;关键词&gt;</code> 搜索相关命令。</p></li></ol><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><p><a href="https://github.com/nvbn/thefuck">thefuck 官方 GitHub 仓库</a></p></li><li><p><a href="https://github.com/tldr-pages/tldr">tldr-pages 官方 GitHub 仓库</a></p></li><li><p><a href="https://ubuntu.com/">Ubuntu 官方文档</a></p></li><li><p><a href="https://pypa.github.io/pipx/">pipx 官方文档</a></p></li></ul>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;Ubuntu-22-04-中安装-thefuck-与-tldr-工具&quot;&gt;&lt;a href=&quot;#Ubuntu-22-04-中安装-thefuck-与-tldr-工具&quot; class=&quot;headerlink&quot; title=&quot;Ubuntu 22.04 中安装</summary>
        
      
    
    
    
    <category term="Linux" scheme="https://www.minbit.top/categories/Linux/"/>
    
    
    <category term="灵光荟萃" scheme="https://www.minbit.top/tags/%E7%81%B5%E5%85%89%E8%8D%9F%E8%90%83/"/>
    
    <category term="工具" scheme="https://www.minbit.top/tags/%E5%B7%A5%E5%85%B7/"/>
    
    <category term="Linux" scheme="https://www.minbit.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>CodeX CLI 的使用备忘</title>
    <link href="https://www.minbit.top/posts/31539.html"/>
    <id>https://www.minbit.top/posts/31539.html</id>
    <published>2025-11-19T04:00:00.000Z</published>
    <updated>2025-11-25T04:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CodeX-CLI-的使用备忘"><a href="#CodeX-CLI-的使用备忘" class="headerlink" title="CodeX CLI 的使用备忘"></a>CodeX CLI 的使用备忘</h1><p>想要使用 CodeX 得要是 ChatGPT 的 plus 及以上用户才能使用，但是网上也存在接入国产模型的教程，下面是我在使用 CodeX CLI 的一些备忘，非教程：</p><blockquote><p><a href="%5BCodex%5D(https://chatgpt.com/codex)">CodeX 官网</a></p></blockquote><p>要使用 CodeX 得先有 <a href="https://nodejs.org/en/download">Node</a>，这里我之前装过了，直接使用官方提供的命令 <code>npm i -g @openai/codex</code> 进行 CodeX CLI 的安装，安装完会提示让使用 Windows 的 Linux 子系统（会体验到更多更完整的功能），记得不错的话，选择选项 2，继续使用 Windows 的，个人感觉用的地方不是很多，也不会用到太多功能，所以直接化繁为简了，后面就是一些提示和默认设置信息一路回车默认都是可以的。想要开始使用就在终端中输入 <code>codex</code> 即可启动，没事也可以使用 <code>npm i -g @openai/codex@latest</code> 对其进行更新。</p><p>要重新进行 Codex CLI 的登录，可以按照以下步骤操作：</p><ol><li><p><strong>清除之前的登录状态（如果有的话）</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">codex <span class="built_in">logout</span></span><br></pre></td></tr></table></figure></li><li><p><strong>重新登录 Codex CLI</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">codex login</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;CodeX-CLI-的使用备忘&quot;&gt;&lt;a href=&quot;#CodeX-CLI-的使用备忘&quot; class=&quot;headerlink&quot; title=&quot;CodeX CLI 的使用备忘&quot;&gt;&lt;/a&gt;CodeX CLI 的使用备忘&lt;/h1&gt;&lt;p&gt;想要使用 CodeX 得要是</summary>
        
      
    
    
    
    <category term="AI" scheme="https://www.minbit.top/categories/AI/"/>
    
    
    <category term="灵光荟萃" scheme="https://www.minbit.top/tags/%E7%81%B5%E5%85%89%E8%8D%9F%E8%90%83/"/>
    
    <category term="AI" scheme="https://www.minbit.top/tags/AI/"/>
    
    <category term="工具" scheme="https://www.minbit.top/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>免费白嫖 ChatGPT Go 套餐</title>
    <link href="https://www.minbit.top/posts/41191.html"/>
    <id>https://www.minbit.top/posts/41191.html</id>
    <published>2025-11-04T16:00:00.000Z</published>
    <updated>2025-11-15T02:10:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="免费白嫖-ChatGPT-Go-套餐-12-个月（一年）"><a href="#免费白嫖-ChatGPT-Go-套餐-12-个月（一年）" class="headerlink" title="免费白嫖 ChatGPT Go 套餐 12 个月（一年）"></a>免费白嫖 ChatGPT Go 套餐 12 个月（一年）</h1><h2 id="1-前提说明"><a href="#1-前提说明" class="headerlink" title="1. 前提说明"></a>1. 前提说明</h2><blockquote><p><strong>官方说明：</strong></p><p><a href="https://help.openai.com/zh-hans-cn/articles/11989085-what-is-chatgpt-go">什么是 ChatGPT Go？</a></p><p><a href="https://help.openai.com/zh-hans-cn/articles/12739021-chatgpt-go-promotion-india">ChatGPT Go 推广活动（印度）</a></p></blockquote><p>ChatGPT Go 是 OpenAI 于 2025 年 11 月 4 日在印度地区推出的全新套餐服务，据说使用额度限制是免费版的 10 倍左右，上下文窗口是免费版的 2 倍左右，官方套餐说明：</p><ul><li>对 GPT-5 的扩展访问权限</li><li>扩展的消息和上传限额</li><li>扩展且较快的图片生成</li><li>更全面的记忆和背景信息</li><li>有限的深度研究</li><li>项目、任务、自定义 GPT</li></ul><h3 id="1-基本条件"><a href="#1-基本条件" class="headerlink" title="1. 基本条件"></a>1. 基本条件</h3><ul><li>PayPal 账户</li><li>印度 IP</li><li>GPT 的新注册用户&#x2F;免费用户&#x2F;状态良好的 ChatGPT Go 的订阅者</li></ul><h3 id="2-疑难解答"><a href="#2-疑难解答" class="headerlink" title="2. 疑难解答"></a>2. 疑难解答</h3><h4 id="Q1-获得套餐后是否需要持续使用印度节点？"><a href="#Q1-获得套餐后是否需要持续使用印度节点？" class="headerlink" title="Q1: 获得套餐后是否需要持续使用印度节点？"></a>Q1: 获得套餐后是否需要持续使用印度节点？</h4><p><strong>A</strong>: 实测验证，成功订阅 ChatGPT Go 套餐后，可使用 <strong>任意地区</strong> 节点访问。网页界面会持续显示 ChatGPT Go 套餐状态，所有功能正常使用，无任何限制影响。</p><h4 id="Q2-免费使用的关键注意事项？"><a href="#Q2-免费使用的关键注意事项？" class="headerlink" title="Q2: 免费使用的关键注意事项？"></a>Q2: 免费使用的关键注意事项？</h4><p><strong>A</strong>: ChatGPT Go 套餐采用每月自动续订模式。若提前取消订阅，套餐权益将立即终止。套餐到期后若未取消，系统将自动按月扣除 4 美元费用。<strong>想要最大化免费使用其额度就选择在套餐到期的最后一个月进行取消订阅</strong>。</p><h2 id="2-注册一个-paypal-账户"><a href="#2-注册一个-paypal-账户" class="headerlink" title="2. 注册一个 paypal 账户"></a>2. 注册一个 paypal 账户</h2><p>虽然不会产生实际扣费，但订阅过程需要验证支付方式，<strong>注册地址</strong>：<a href="https://www.paypal.com/c2/home">中国区 PayPal 官方网站</a>，不会注册的自行百度。</p><h2 id="3-订阅-ChatGPT-Go-套餐"><a href="#3-订阅-ChatGPT-Go-套餐" class="headerlink" title="3. 订阅 ChatGPT Go 套餐"></a>3. 订阅 ChatGPT Go 套餐</h2><h3 id="1-显示套餐"><a href="#1-显示套餐" class="headerlink" title="1. 显示套餐"></a>1. 显示套餐</h3><p>我们使用 <strong>印度地区</strong> 节点访问 ChatGPT 网页版，刷新页面后即可看到 ChatGPT Go 套餐选项</p><p><img src="https://zycs-img-8kd.pages.dev/v2/cFvNihE.png"></p><p><img src="https://zycs-img-8kd.pages.dev/v2/TDv7azn.png"></p><h3 id="2-订购套餐"><a href="#2-订购套餐" class="headerlink" title="2. 订购套餐"></a>2. 订购套餐</h3><p><strong>注意：千万不要着急进行订购！</strong> 印度是不支持 PayPal 支付的，所以在订购页面的右下角可以看到 <strong>选择国家</strong>，这里选择支持 PayPal 支付的国家，欧洲国家一般都支持，我们以法国为例，将国家切换至法国，然后再进行订购，此时可以看到，折扣是 100%即 0 元购，支付方式选择 PayPal，输入刚才注册 PayPal 账号的信息，即可订购成功！</p><blockquote><p><strong>再次声明：一定要在套餐期限内取消订购，否则超期会自动扣款！</strong></p></blockquote><h2 id="4-彩蛋时间"><a href="#4-彩蛋时间" class="headerlink" title="4. 彩蛋时间"></a>4. 彩蛋时间</h2><p>既然已经有了 PayPal，那么想要白嫖 <a href="https://www.perplexity.ai/join/p/paypal-subscription">Perplexity Pro</a> 也是顺手的事，操作也是大同小异，这里就不多赘述了，<a href="https://www.perplexity.ai/">Perplexity</a> 大概就是一个 AI 搜索引擎，不得不说这些 AI 搜索引擎在某些方面的能力确实很强，能够查到一些比较“封闭”的资源，根据个人所需选择了。</p><blockquote><p><strong>白嫖的感觉确实很爽，但我还是要真心说一句：我支持付费，也鼓励付费。老话说得好，免费的才是最贵的，但像这样一个月成百上千块钱的付费确实挺贵，期待未来当您有能力时，愿意为真正有价值的产品和服务买单，以表对优质产品和服务的支持！</strong></p></blockquote><hr><blockquote><p>  [!CAUTION]</p><p>  截至时间 2025.11.15，似乎白嫖 ChatGPT Go 套餐的账户已经陆续回退至免费账户，具体原因不详。下面是官方说明：OpenAI 原本针对 <strong>印度地区的合格用户</strong> 推出了 ChatGPT Go 的促销活动，但由于支付系统的技术错误，这个优惠被错误地应用到了 <strong>印度以外地区的 PayPal 订单</strong> 中，官方的处理措施：</p><ul><li>已经修复了支付系统的漏洞；</li><li>会 <strong>撤销账户上错误应用的促销折扣</strong>；</li><li>ChatGPT Go 订阅会 <strong>恢复到原始状态</strong>（如果之前是免费版，就会回到免费版；如果是付费版，会按原付费规则执行），且 <strong>不会自动续费</strong>。</li></ul></blockquote>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;免费白嫖-ChatGPT-Go-套餐-12-个月（一年）&quot;&gt;&lt;a href=&quot;#免费白嫖-ChatGPT-Go-套餐-12-个月（一年）&quot; class=&quot;headerlink&quot; title=&quot;免费白嫖 ChatGPT Go 套餐 12</summary>
        
      
    
    
    
    <category term="AI" scheme="https://www.minbit.top/categories/AI/"/>
    
    
    <category term="灵光荟萃" scheme="https://www.minbit.top/tags/%E7%81%B5%E5%85%89%E8%8D%9F%E8%90%83/"/>
    
    <category term="AI" scheme="https://www.minbit.top/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>07 表的增删改查上</title>
    <link href="https://www.minbit.top/posts/60665.html"/>
    <id>https://www.minbit.top/posts/60665.html</id>
    <published>2025-11-02T16:00:00.000Z</published>
    <updated>2025-12-16T02:10:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="表的增删改查上"><a href="#表的增删改查上" class="headerlink" title="表的增删改查上"></a>表的增删改查上</h1><h2 id="1-Create（创建）"><a href="#1-Create（创建）" class="headerlink" title="1. Create（创建）"></a>1. Create（创建）</h2><h3 id="1-单行插入-全列插入（最基础）"><a href="#1-单行插入-全列插入（最基础）" class="headerlink" title="1. 单行插入 + 全列插入（最基础）"></a>1. 单行插入 + 全列插入（最基础）</h3><h4 id="1-语法格式"><a href="#1-语法格式" class="headerlink" title="1. 语法格式"></a>1. 语法格式</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> 表名 <span class="keyword">VALUES</span> (值<span class="number">1</span>, 值<span class="number">2</span>, ..., 值N);</span><br></pre></td></tr></table></figure><blockquote><p>  省略列名时，<strong>必须按表定义的列顺序且写齐所有列</strong>（可用 <code>NULL</code> 或 <code>DEFAULT</code> 占位）。</p></blockquote><h4 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> t (</span><br><span class="line">  id <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span> AUTO_INCREMENT,</span><br><span class="line">  name <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">  age <span class="type">INT</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"># 全列插入（省略列名），id 用 <span class="keyword">NULL</span> 占位触发自增</span><br><span class="line"><span class="keyword">INSERT INTO</span> t <span class="keyword">VALUES</span> (<span class="keyword">NULL</span>, <span class="string">&#x27;张三&#x27;</span>, <span class="number">20</span>);</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li>简短但 <strong>易错</strong>（列顺序变动或新增列会导致问题）。</li><li>若主键自增，用 <code>NULL</code> 或 <code>DEFAULT</code> 占位。</li><li>若某列 <code>NOT NULL</code> 且无 <code>DEFAULT</code>，必须提供值。</li></ul><h3 id="2-多行插入-指定列插入（高效写法）"><a href="#2-多行插入-指定列插入（高效写法）" class="headerlink" title="2. 多行插入 + 指定列插入（高效写法）"></a>2. 多行插入 + 指定列插入（高效写法）</h3><h4 id="1-语法格式（指定列，支持多行）"><a href="#1-语法格式（指定列，支持多行）" class="headerlink" title="1. 语法格式（指定列，支持多行）"></a>1. 语法格式（指定列，支持多行）</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> 表名 (列<span class="number">1</span>, 列<span class="number">2</span>, ...) <span class="keyword">VALUES</span></span><br><span class="line">  (值<span class="number">11</span>, 值<span class="number">12</span>, ...),</span><br><span class="line">  (值<span class="number">21</span>, 值<span class="number">22</span>, ...),</span><br><span class="line">  ...;</span><br></pre></td></tr></table></figure><h4 id="2-示例-1"><a href="#2-示例-1" class="headerlink" title="2. 示例"></a>2. 示例</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 只插入 name 和 age，id 用自增</span><br><span class="line"><span class="keyword">INSERT INTO</span> t (name, age) <span class="keyword">VALUES</span></span><br><span class="line">  (<span class="string">&#x27;李四&#x27;</span>, <span class="number">22</span>),</span><br><span class="line">  (<span class="string">&#x27;王五&#x27;</span>, <span class="number">19</span>),</span><br><span class="line">  (<span class="string">&#x27;赵六&#x27;</span>, <span class="number">21</span>);</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li><strong>一次多行插入性能远优于循环单条插入</strong>。</li><li>可以省略不需要赋值的列（使用默认值或 NULL）。</li><li>若有唯一&#x2F;主键冲突，会整个语句失败（除非用 IGNORE 或 ON DUPLICATE）。</li></ul><h3 id="3-插入否则更新：INSERT-ON-DUPLICATE-KEY-UPDATE"><a href="#3-插入否则更新：INSERT-ON-DUPLICATE-KEY-UPDATE" class="headerlink" title="3. 插入否则更新：INSERT ... ON DUPLICATE KEY UPDATE"></a>3. 插入否则更新：<code>INSERT ... ON DUPLICATE KEY UPDATE</code></h3><h4 id="1-语法格式-1"><a href="#1-语法格式-1" class="headerlink" title="1. 语法格式"></a>1. 语法格式</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> 表名 (列<span class="number">1</span>, 列<span class="number">2</span>, ...)</span><br><span class="line"><span class="keyword">VALUES</span> (值<span class="number">1</span>, 值<span class="number">2</span>, ...)</span><br><span class="line"><span class="keyword">ON</span> DUPLICATE KEY <span class="keyword">UPDATE</span></span><br><span class="line">  列A <span class="operator">=</span> 新值A, 列B <span class="operator">=</span> 新值B, ...;</span><br></pre></td></tr></table></figure><p>在插入行与表中已有行在 <strong>主键或唯一索引</strong> 冲突时，MySQL 执行 <code>UPDATE</code> 子句而不是报错或忽略。</p><h4 id="2-示例（常见用法：计数、冲突合并）"><a href="#2-示例（常见用法：计数、冲突合并）" class="headerlink" title="2. 示例（常见用法：计数、冲突合并）"></a>2. 示例（常见用法：计数、冲突合并）</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> item (</span><br><span class="line">  id <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span>,</span><br><span class="line">  name <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">  cnt <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>,</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY (name)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"># 尝试插入新名字；若 name 冲突就把 cnt 累加</span><br><span class="line"><span class="keyword">INSERT INTO</span> item (id, name, cnt)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">&#x27;apple&#x27;</span>, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">ON</span> DUPLICATE KEY <span class="keyword">UPDATE</span> cnt <span class="operator">=</span> cnt <span class="operator">+</span> <span class="keyword">VALUES</span>(cnt);</span><br></pre></td></tr></table></figure><p><code>VALUES(cnt)</code> 在 MySQL 8.0.20 以后用 <code>VALUES()</code> 被废弃，可用 <code>VALUES()</code> 的替代 <code>NEW</code>，实际推荐写法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">... <span class="keyword">ON</span> DUPLICATE KEY <span class="keyword">UPDATE</span> cnt <span class="operator">=</span> cnt <span class="operator">+</span> <span class="keyword">VALUES</span>(cnt);</span><br></pre></td></tr></table></figure><p>（在很多 MySQL 版本仍通用；新版本可用 <code>INSERT ... AS new</code> 结构或 <code>VALUES()</code> 替代注意兼容）</p><h4 id="3-常见变体：直接覆盖部分字段"><a href="#3-常见变体：直接覆盖部分字段" class="headerlink" title="3. 常见变体：直接覆盖部分字段"></a>3. 常见变体：直接覆盖部分字段</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> users (id, name, email)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;t@x&#x27;</span>)</span><br><span class="line"><span class="keyword">ON</span> DUPLICATE KEY <span class="keyword">UPDATE</span></span><br><span class="line">  name <span class="operator">=</span> <span class="keyword">VALUES</span>(name), email <span class="operator">=</span> <span class="keyword">VALUES</span>(email);</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li>触发器 <code>BEFORE INSERT</code> &#x2F; <code>AFTER INSERT</code> 等仍会按插入流程触发，冲突时也会触发 <code>UPDATE</code> 相关触发器。</li><li><code>ON DUPLICATE KEY UPDATE</code> 会把冲突情况视为更新，可能影响 <code>AUTO_INCREMENT</code> 值（插入失败仍可能消耗自增）。</li><li>性能：对高并发唯一冲突场景，可能产生较多锁竞争。</li><li><code>VALUES(col)</code> 返回插入语句中指定的值（注意版本兼容）。</li></ul><h3 id="4-替换数据：REPLACE-INTO"><a href="#4-替换数据：REPLACE-INTO" class="headerlink" title="4. 替换数据：REPLACE INTO"></a>4. 替换数据：<code>REPLACE INTO</code></h3><h4 id="1-语法格式-2"><a href="#1-语法格式-2" class="headerlink" title="1. 语法格式"></a>1. 语法格式</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">REPLACE <span class="keyword">INTO</span> 表名 (列<span class="number">1</span>, 列<span class="number">2</span>, ...)</span><br><span class="line"><span class="keyword">VALUES</span> (...);</span><br></pre></td></tr></table></figure><p><code>REPLACE</code> 语句会首先删除表中与新数据冲突的旧记录（通常是主键或唯一索引冲突），然后插入新数据（相当于 DELETE + INSERT）。也就是说，如果插入的数据已存在，MySQL 会先删除原来的数据，再插入新的数据。</p><h4 id="2-示例-2"><a href="#2-示例-2" class="headerlink" title="2. 示例"></a>2. 示例</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 若 id<span class="operator">=</span><span class="number">1</span> 存在，则先删除 id<span class="operator">=</span><span class="number">1</span> 的行，再插入新行</span><br><span class="line">REPLACE <span class="keyword">INTO</span> t (id, name, age) <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">&#x27;Tom&#x27;</span>, <span class="number">30</span>);</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li><code>REPLACE</code> 是 <code>DELETE</code> + <code>INSERT</code> 的组合：会导致被删除行的所有外键级联、触发器、以及自增等副作用（比如被删除行上的外键约束、触发器会触发）。</li><li>被删除的行会被真正删除，删除可能触发 <code>ON DELETE</code> 级联或触发器。</li><li><code>REPLACE</code> 会导致新的行有新的自增 id（如果使用自增列且没有给出 id，则新插入会产生新 id）。</li><li><code>REPLACE</code> 不如 <code>INSERT ... ON DUPLICATE KEY UPDATE</code> 温和，慎用在有外键或审计需求的表上。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><span class="line"># 创建t1表：id主键自增，age默认18</span><br><span class="line">mysql&gt; create table t1(</span><br><span class="line">    -&gt; id int primary key auto_increment comment &#x27;这是id，会自增长&#x27;,</span><br><span class="line">    -&gt; name varchar(20) comment &#x27;这是姓名&#x27;,</span><br><span class="line">    -&gt; age int default 18 comment &#x27;这是年龄，默认18&#x27;);</span><br><span class="line"></span><br><span class="line"># 错误：查看表无show 表名语法</span><br><span class="line">mysql&gt; show t1;</span><br><span class="line">ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#x27;t1&#x27; at line 1</span><br><span class="line"></span><br><span class="line"># 查看表结构：id非空自增，age默认18</span><br><span class="line">mysql&gt; desc t1;</span><br><span class="line">+-------+-------------+------+-----+---------+----------------+</span><br><span class="line">| Field | Type        | Null | Key | Default | Extra          |</span><br><span class="line">+-------+-------------+------+-----+---------+----------------+</span><br><span class="line">| id    | int         | NO   | PRI | NULL    | auto_increment |</span><br><span class="line">| name  | varchar(20) | YES  |     | NULL    |                |</span><br><span class="line">| age   | int         | YES  |     | 18      |                |</span><br><span class="line">+-------+-------------+------+-----+---------+----------------+</span><br><span class="line"></span><br><span class="line"># 插入数据：id=1，name=张三，age=20</span><br><span class="line">mysql&gt; insert into t1 values(1,&#x27;张三&#x27;,20);</span><br><span class="line"></span><br><span class="line"># 错误：值数量与字段数不匹配</span><br><span class="line">mysql&gt; insert t1 values(null,&#x27;李四&#x27;);</span><br><span class="line">ERROR 1136 (21S01): Column count doesn&#x27;t match value count at row 1</span><br><span class="line"></span><br><span class="line"># 插入数据：id用null触发自增（→2），name=李四，age=20</span><br><span class="line">mysql&gt; insert t1 values(null,&#x27;李四&#x27;,20);</span><br><span class="line"></span><br><span class="line"># 插入数据：指定name和age，id自增→3</span><br><span class="line">mysql&gt; insert t1(name,age) values(&#x27;赵七&#x27;,25);</span><br><span class="line"></span><br><span class="line"># 批量插入错误：id=3已存在，主键重复</span><br><span class="line">mysql&gt; insert into t1(id,name) </span><br><span class="line">    -&gt; values(3,&#x27;王五&#x27;),</span><br><span class="line">    -&gt; (4,&#x27;小明&#x27;),</span><br><span class="line">    -&gt; (5,&#x27;小红&#x27;);</span><br><span class="line">ERROR 1062 (23000): Duplicate entry &#x27;3&#x27; for key &#x27;t1.PRIMARY&#x27;</span><br><span class="line"></span><br><span class="line"># 查看数据：现有3条记录</span><br><span class="line">mysql&gt; select *from t1;</span><br><span class="line">+----+--------+------+</span><br><span class="line">| id | name   | age  |</span><br><span class="line">+----+--------+------+</span><br><span class="line">|  1 | 张三   |   20 |</span><br><span class="line">|  2 | 李四   |   20 |</span><br><span class="line">|  3 | 赵七   |   25 |</span><br><span class="line">+----+--------+------+</span><br><span class="line"></span><br><span class="line"># 批量插入：id=5/7/8（无重复），age用默认18</span><br><span class="line">mysql&gt; insert into t1(id,name) values</span><br><span class="line">    -&gt; (5,&#x27;王五&#x27;),</span><br><span class="line">    -&gt; (7,&#x27;小明&#x27;),</span><br><span class="line">    -&gt; (8,&#x27;小红&#x27;);</span><br><span class="line">Query OK, 3 rows affected (0.01 sec)</span><br><span class="line">Records: 3  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line"># 查看数据：新增3条，age默认18</span><br><span class="line">mysql&gt; select *from t1;</span><br><span class="line">+----+--------+------+</span><br><span class="line">| id | name   | age  |</span><br><span class="line">+----+--------+------+</span><br><span class="line">|  1 | 张三   |   20 |</span><br><span class="line">|  2 | 李四   |   20 |</span><br><span class="line">|  3 | 赵七   |   25 |</span><br><span class="line">|  5 | 王五   |   18 |</span><br><span class="line">|  7 | 小明   |   18 |</span><br><span class="line">|  8 | 小红   |   18 |</span><br><span class="line">+----+--------+------+</span><br><span class="line"></span><br><span class="line"># 插入错误：id=3已存在，主键重复</span><br><span class="line">mysql&gt; insert into t1(id,name) values(3,&#x27;李四&#x27;);</span><br><span class="line">ERROR 1062 (23000): Duplicate entry &#x27;3&#x27; for key &#x27;t1.PRIMARY&#x27;</span><br><span class="line"></span><br><span class="line"># 错误：on duplicate key update后无更新内容，语法不完整</span><br><span class="line">mysql&gt; insert into t1(id,name) values(3,&#x27;李四&#x27;) on duplicate key update;</span><br><span class="line">ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#x27;&#x27; at line 1</span><br><span class="line"></span><br><span class="line"># 主键重复时更新：更新原有id=3的行，id改为4、name改为李四</span><br><span class="line">mysql&gt; insert into t1(id,name) values(3,&#x27;李四&#x27;) on duplicate key update id=4,name=&#x27;李四&#x27;;</span><br><span class="line"></span><br><span class="line"># 查看数据：原id=3的行被更新为id=4，id=3消失</span><br><span class="line">mysql&gt; select *from t1;</span><br><span class="line">+----+--------+------+</span><br><span class="line">| id | name   | age  |</span><br><span class="line">+----+--------+------+</span><br><span class="line">|  1 | 张三   |   20 |</span><br><span class="line">|  2 | 李四   |   20 |</span><br><span class="line">|  4 | 李四   |   25 |</span><br><span class="line">|  5 | 王五   |   18 |</span><br><span class="line">|  7 | 小明   |   18 |</span><br><span class="line">|  8 | 小红   |   18 |</span><br><span class="line">+----+--------+------+</span><br><span class="line"></span><br><span class="line"># 主键重复时更新：更新原有id=8的行，id改为99、name改为小红红</span><br><span class="line">mysql&gt; insert into t1(id,name) values(8,&#x27;小红&#x27;) on duplicate key update id=99,name=&#x27;小红红&#x27;;</span><br><span class="line"></span><br><span class="line"># 查看数据：原id=8的行被更新为id=99，id=8消失</span><br><span class="line">mysql&gt; select *from t1;</span><br><span class="line">+----+-----------+------+</span><br><span class="line">| id | name      | age  |</span><br><span class="line">+----+-----------+------+</span><br><span class="line">|  1 | 张三      |   20 |</span><br><span class="line">|  2 | 李四      |   20 |</span><br><span class="line">|  4 | 李四      |   25 |</span><br><span class="line">|  5 | 王五      |   18 |</span><br><span class="line">|  7 | 小明      |   18 |</span><br><span class="line">| 99 | 小红红    |   18 |</span><br><span class="line">+----+-----------+------+</span><br><span class="line"></span><br><span class="line"># 插入数据：仅age=100，id自增→100，name=null</span><br><span class="line">mysql&gt; insert into t1(age) values(100) on duplicate key update age=100;</span><br><span class="line"></span><br><span class="line"># 查看数据：新增id=100（name=null）</span><br><span class="line">mysql&gt; select *from t1;</span><br><span class="line">+-----+-----------+------+</span><br><span class="line">| id  | name      | age  |</span><br><span class="line">+-----+-----------+------+</span><br><span class="line">|   1 | 张三      |   20 |</span><br><span class="line">|   2 | 李四      |   20 |</span><br><span class="line">|   4 | 李四      |   25 |</span><br><span class="line">|   5 | 王五      |   18 |</span><br><span class="line">|   7 | 小明      |   18 |</span><br><span class="line">|  99 | 小红红    |   18 |</span><br><span class="line">| 100 | NULL      |  100 |</span><br><span class="line">+-----+-----------+------+</span><br><span class="line"></span><br><span class="line"># 插入数据：name=李四、age=100，id自增→101（无重复）</span><br><span class="line">mysql&gt; insert into t1(name,age) values(&#x27;李四&#x27;,100) on duplicate key update age=66;</span><br><span class="line"></span><br><span class="line"># 查看数据：新增id=101</span><br><span class="line">mysql&gt; select *from t1;</span><br><span class="line">+-----+-----------+------+</span><br><span class="line">| id  | name      | age  |</span><br><span class="line">+-----+-----------+------+</span><br><span class="line">|   1 | 张三      |   20 |</span><br><span class="line">|   2 | 李四      |   20 |</span><br><span class="line">|   4 | 李四      |   25 |</span><br><span class="line">|   5 | 王五      |   18 |</span><br><span class="line">|   7 | 小明      |   18 |</span><br><span class="line">|  99 | 小红红    |   18 |</span><br><span class="line">| 100 | NULL      |  100 |</span><br><span class="line">| 101 | 李四      |  100 |</span><br><span class="line">+-----+-----------+------+</span><br><span class="line"></span><br><span class="line"># 插入数据：name=李四、age=100，id自增→102（无重复）</span><br><span class="line">mysql&gt; insert into t1(name,age) values(&#x27;李四&#x27;,100) on duplicate key update age=66;</span><br><span class="line"></span><br><span class="line"># 查看数据：新增id=102</span><br><span class="line">mysql&gt; select *from t1;</span><br><span class="line">+-----+-----------+------+</span><br><span class="line">| id  | name      | age  |</span><br><span class="line">+-----+-----------+------+</span><br><span class="line">|   1 | 张三      |   20 |</span><br><span class="line">|   2 | 李四      |   20 |</span><br><span class="line">|   4 | 李四      |   25 |</span><br><span class="line">|   5 | 王五      |   18 |</span><br><span class="line">|   7 | 小明      |   18 |</span><br><span class="line">|  99 | 小红红    |   18 |</span><br><span class="line">| 100 | NULL      |  100 |</span><br><span class="line">| 101 | 李四      |  100 |</span><br><span class="line">| 102 | 李四      |  100 |</span><br><span class="line">+-----+-----------+------+</span><br></pre></td></tr></table></figure><hr><h2 id="2-Retrieve（查）"><a href="#2-Retrieve（查）" class="headerlink" title="2. Retrieve（查）"></a>2. Retrieve（查）</h2><blockquote><p><strong>WHERE + DISTINCT &#x2F; ORDER &#x2F; LIMIT 的顺序（记这个）</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> 列</span><br><span class="line"><span class="operator">&gt;</span><span class="keyword">FROM</span> 表</span><br><span class="line"><span class="operator">&gt;</span><span class="keyword">WHERE</span> 条件</span><br><span class="line"><span class="operator">&gt;</span><span class="keyword">ORDER</span> <span class="keyword">BY</span> 列</span><br><span class="line"><span class="operator">&gt;</span>LIMIT 跳过数，每页条数;</span><br></pre></td></tr></table></figure><p><strong>WHERE 永远在 SELECT 后、ORDER BY 前。</strong></p></blockquote><h3 id="1-select-列"><a href="#1-select-列" class="headerlink" title="1. select 列"></a>1. select 列</h3><h4 id="1-全列查询（查询所有列）"><a href="#1-全列查询（查询所有列）" class="headerlink" title="1. 全列查询（查询所有列）"></a>1. 全列查询（查询所有列）</h4><p>全列查询表示从表中查询所有的列。只需要使用 <code>SELECT *</code> 即可。</p><h5 id="1-语法"><a href="#1-语法" class="headerlink" title="1. 语法"></a>1. 语法</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM 表名;</span><br><span class="line">select * from users;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 使用 <code>*</code> 查询会返回表中所有列，如果表的列很多或者数据量大，会影响性能，通常建议只查询需要的列。</p><h5 id="2-示例-3"><a href="#2-示例-3" class="headerlink" title="2. 示例"></a>2. 示例</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from t1;</span><br><span class="line">+-----+-----------+------+</span><br><span class="line">| id  | name      | age  |</span><br><span class="line">+-----+-----------+------+</span><br><span class="line">|   1 | 张三      |   20 |</span><br><span class="line">|   2 | 李四      |   20 |</span><br><span class="line">|   4 | 李四      |   25 |</span><br><span class="line">|   5 | 王五      |   18 |</span><br><span class="line">|   7 | 小明      |   18 |</span><br><span class="line">|  99 | 小红红    |   18 |</span><br><span class="line">| 100 | NULL      |  100 |</span><br><span class="line">| 101 | 李四      |  100 |</span><br><span class="line">| 102 | 李四      |  100 |</span><br><span class="line">+-----+-----------+------+</span><br></pre></td></tr></table></figure><h4 id="2-指定列查询"><a href="#2-指定列查询" class="headerlink" title="2. 指定列查询"></a>2. 指定列查询</h4><p>指定列查询用于查询表中的特定列，而不是所有列，需要通过列名来选择需要的列。</p><h5 id="1-语法-1"><a href="#1-语法-1" class="headerlink" title="1. 语法"></a>1. 语法</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT 列名1, 列名2, ... FROM 表名;</span><br></pre></td></tr></table></figure><h5 id="2-示例-4"><a href="#2-示例-4" class="headerlink" title="2. 示例"></a>2. 示例</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select id from t1;</span><br><span class="line">+-----+</span><br><span class="line">| id  |</span><br><span class="line">+-----+</span><br><span class="line">|   1 |</span><br><span class="line">|   2 |</span><br><span class="line">|   4 |</span><br><span class="line">|   5 |</span><br><span class="line">|   7 |</span><br><span class="line">|  99 |</span><br><span class="line">| 100 |</span><br><span class="line">| 101 |</span><br><span class="line">| 102 |</span><br><span class="line">+-----+</span><br><span class="line"></span><br><span class="line">mysql&gt; select name, age from t1;</span><br><span class="line">+-----------+------+</span><br><span class="line">| name      | age  |</span><br><span class="line">+-----------+------+</span><br><span class="line">| 张三      |   20 |</span><br><span class="line">| 李四      |   20 |</span><br><span class="line">| 李四      |   25 |</span><br><span class="line">| 王五      |   18 |</span><br><span class="line">| 小明      |   18 |</span><br><span class="line">| 小红红    |   18 |</span><br><span class="line">| NULL      |  100 |</span><br><span class="line">| 李四      |  100 |</span><br><span class="line">| 李四      |  100 |</span><br><span class="line">+-----------+------+</span><br></pre></td></tr></table></figure><h4 id="3-查询字段为表达式"><a href="#3-查询字段为表达式" class="headerlink" title="3. 查询字段为表达式"></a>3. 查询字段为表达式</h4><p><code>SELECT</code> 语句中可以使用表达式（例如算术运算、字符串拼接、函数等）来处理数据，并将结果作为查询结果的一部分。</p><h5 id="1-语法-2"><a href="#1-语法-2" class="headerlink" title="1. 语法"></a>1. 语法</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT 表达式 FROM 表名;</span><br></pre></td></tr></table></figure><h5 id="2-示例-5"><a href="#2-示例-5" class="headerlink" title="2. 示例"></a>2. 示例</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"># 查询t1表所有数据</span><br><span class="line">mysql&gt; select * from t1;</span><br><span class="line">+-----+-----------+------+</span><br><span class="line">| id  | name      | age  |</span><br><span class="line">+-----+-----------+------+</span><br><span class="line">|   1 | 张三      |   20 |</span><br><span class="line">|   2 | 李四      |   20 |</span><br><span class="line">|   4 | 李四      |   25 |</span><br><span class="line">|   5 | 王五      |   18 |</span><br><span class="line">|   7 | 小明      |   18 |</span><br><span class="line">|  99 | 小红红    |   18 |</span><br><span class="line">| 100 | NULL      |  100 |</span><br><span class="line">| 101 | 李四      |  100 |</span><br><span class="line">| 102 | 李四      |  100 |</span><br><span class="line">+-----+-----------+------+</span><br><span class="line"></span><br><span class="line"># 每行判断id&lt;50、age&gt;=20，结果以1/0展示，返回所有行</span><br><span class="line">mysql&gt; select id&lt;50,name, age&gt;=20 from t1;</span><br><span class="line">+-------+-----------+---------+</span><br><span class="line">| id&lt;50 | name      | age&gt;=20 |</span><br><span class="line">+-------+-----------+---------+</span><br><span class="line">|     1 | 张三      |       1 |</span><br><span class="line">|     1 | 李四      |       1 |</span><br><span class="line">|     1 | 李四      |       1 |</span><br><span class="line">|     1 | 王五      |       0 |</span><br><span class="line">|     1 | 小明      |       0 |</span><br><span class="line">|     0 | 小红红    |       0 |</span><br><span class="line">|     0 | NULL      |       1 |</span><br><span class="line">|     0 | 李四      |       1 |</span><br><span class="line">|     0 | 李四      |       1 |</span><br><span class="line">+-------+-----------+---------+</span><br><span class="line"></span><br><span class="line"># 筛选age&gt;20且&lt;=50的行，只展示age列</span><br><span class="line">mysql&gt; select age from t1 where age&gt;20 and age &lt;=50;</span><br><span class="line">+------+</span><br><span class="line">| age  |</span><br><span class="line">+------+</span><br><span class="line">|   25 |</span><br><span class="line">+------+</span><br><span class="line"></span><br><span class="line"># 筛选age&gt;20且&lt;=500的行，展示id、name、age列</span><br><span class="line">mysql&gt; select id,name,age from t1 where age&gt;20 and age &lt;=500;</span><br><span class="line">+----+--------+------+</span><br><span class="line">| id | name   | age  |</span><br><span class="line">+----+--------+------+</span><br><span class="line">|  4 | 李四   |   25 |</span><br><span class="line">+----+--------+------+</span><br><span class="line"></span><br><span class="line"># 展示id、name，age乘2并命名为double_age，返回所有行</span><br><span class="line">mysql&gt; select id,name, age*2 as double_age from t1;</span><br><span class="line">+-----+-----------+------------+</span><br><span class="line">| id  | name      | double_age |</span><br><span class="line">+-----+-----------+------------+</span><br><span class="line">|   1 | 张三      |         40 |</span><br><span class="line">|   2 | 李四      |         40 |</span><br><span class="line">|   4 | 李四      |         50 |</span><br><span class="line">|   5 | 王五      |         36 |</span><br><span class="line">|   7 | 小明      |         36 |</span><br><span class="line">|  99 | 小红红    |         36 |</span><br><span class="line">| 100 | NULL      |        200 |</span><br><span class="line">| 101 | 李四      |        200 |</span><br><span class="line">| 102 | 李四      |        200 |</span><br><span class="line">+-----+-----------+------------+</span><br></pre></td></tr></table></figure><h4 id="4-为查询结果指定别名"><a href="#4-为查询结果指定别名" class="headerlink" title="4. 为查询结果指定别名"></a>4. 为查询结果指定别名</h4><p>通过 <code>AS</code> 关键字，可以给查询结果的字段指定别名，使结果更具可读性，通常用于表达式或列名较长时。</p><h5 id="1-语法-3"><a href="#1-语法-3" class="headerlink" title="1. 语法"></a>1. 语法</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT 列名 AS 别名 FROM 表名;</span><br></pre></td></tr></table></figure><h5 id="2-示例-6"><a href="#2-示例-6" class="headerlink" title="2. 示例"></a>2. 示例</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select id as my_id,name,age as my_age from t1;</span><br><span class="line">+-------+-----------+--------+</span><br><span class="line">| my_id | name      | my_age |</span><br><span class="line">+-------+-----------+--------+</span><br><span class="line">|     1 | 张三      |     20 |</span><br><span class="line">|     2 | 李四      |     20 |</span><br><span class="line">|     4 | 李四      |     25 |</span><br><span class="line">|     5 | 王五      |     18 |</span><br><span class="line">|     7 | 小明      |     18 |</span><br><span class="line">|    99 | 小红红    |     18 |</span><br><span class="line">|   100 | NULL      |    100 |</span><br><span class="line">|   101 | 李四      |    100 |</span><br><span class="line">|   102 | 李四      |    100 |</span><br><span class="line">+-------+-----------+--------+</span><br></pre></td></tr></table></figure><h4 id="5-结果去重"><a href="#5-结果去重" class="headerlink" title="5. 结果去重"></a>5. 结果去重</h4><p>当我们只关心某些列的不同值时，可以用 <code>DISTINCT</code> 返回去除重复值的查询结果。</p><h5 id="1-语法-4"><a href="#1-语法-4" class="headerlink" title="1. 语法"></a>1. 语法</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT DISTINCT 列名 FROM 表名;</span><br></pre></td></tr></table></figure><p><strong>注意：<code>distinct</code> 是对 “所选字段的组合” 去重，不是单字段去重！<code>DISTINCT</code> 必须紧跟 <code>SELECT</code> 关键字，且只能写一次，不能插在字段列表中间&#x2F;后面。</strong></p><h5 id="2-示例-7"><a href="#2-示例-7" class="headerlink" title="2. 示例"></a>2. 示例</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"># 只对name字段去重，不管age/id</span><br><span class="line">mysql&gt; select distinct name from t1;</span><br><span class="line">+-----------+</span><br><span class="line">| name      |</span><br><span class="line">+-----------+</span><br><span class="line">| 张三      |</span><br><span class="line">| 李四      |</span><br><span class="line">| 王五      |</span><br><span class="line">| 小明      |</span><br><span class="line">| 小红红    |</span><br><span class="line">| NULL      |</span><br><span class="line">+-----------+</span><br><span class="line"></span><br><span class="line"># distinct作用于(name,age)组合，去重重复的姓名+年龄组合</span><br><span class="line">mysql&gt; select distinct name,age from t1;</span><br><span class="line">+-----------+------+</span><br><span class="line">| name      | age  |</span><br><span class="line">+-----------+------+</span><br><span class="line">| 张三      |   20 |</span><br><span class="line">| 李四      |   20 |</span><br><span class="line">| 李四      |   25 |</span><br><span class="line">| 王五      |   18 |</span><br><span class="line">| 小明      |   18 |</span><br><span class="line">| 小红红    |   18 |</span><br><span class="line">| NULL      |  100 |</span><br><span class="line">| 李四      |  100 |</span><br><span class="line">+-----------+------+</span><br></pre></td></tr></table></figure><h3 id="2-where-条件"><a href="#2-where-条件" class="headerlink" title="2. where 条件"></a>2. where 条件</h3><p><strong>WHERE 用来“筛选行”</strong>，不满足条件的记录，<strong>直接不返回</strong>。</p><h4 id="1-语法-5"><a href="#1-语法-5" class="headerlink" title="1. 语法"></a>1. 语法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT 列名</span><br><span class="line">FROM 表名</span><br><span class="line">WHERE 条件;</span><br></pre></td></tr></table></figure><p>WHERE 常用比较与条件运算符速查表：</p><table><thead><tr><th align="center">分类</th><th>运算符 &#x2F; 语法</th><th>含义</th><th>典型示例</th><th>注意事项（重点）</th></tr></thead><tbody><tr><td align="center">比较</td><td><code>&gt;</code> <code>&gt;=</code> <code>&lt;</code> <code>&lt;=</code></td><td>大于 &#x2F; 大于等于 &#x2F; 小于 &#x2F; 小于等于</td><td><code>age &gt;= 18</code></td><td>常用，配合索引效果好</td></tr><tr><td align="center">比较</td><td><code>=</code></td><td>等于</td><td><code>id = 1</code></td><td><strong>NULL 不安全</strong>，<code>NULL = NULL</code> 结果是 NULL</td></tr><tr><td align="center">比较</td><td><code>&lt;=&gt;</code></td><td>等于（NULL 安全）</td><td><code>col &lt;=&gt; NULL</code></td><td>一般不用，判断 NULL 优先用 <code>IS NULL</code></td></tr><tr><td align="center">比较</td><td><code>!=</code> <code>&lt;&gt;</code></td><td>不等于</td><td><code>status != 0</code></td><td>两者等价，常用 <code>!=</code></td></tr><tr><td align="center">范围</td><td><code>BETWEEN a AND b</code></td><td>在区间内（含边界）</td><td><code>age BETWEEN 18 AND 30</code></td><td>等价于 <code>&gt;= a AND &lt;= b</code></td></tr><tr><td align="center">集合</td><td><code>IN (v1, v2, ...)</code></td><td>在给定集合中</td><td><code>id IN (1,3,5)</code></td><td>值不要太多</td></tr><tr><td align="center">集合</td><td><code>NOT IN (v1, v2, ...)</code></td><td>不在给定集合中</td><td><code>id NOT IN (1,3)</code></td><td><strong>集合中有 NULL 会出大坑</strong></td></tr><tr><td align="center">空值</td><td><code>IS NULL</code></td><td>是 NULL</td><td><code>email IS NULL</code></td><td>判断 NULL <strong>只能用它</strong></td></tr><tr><td align="center">空值</td><td><code>IS NOT NULL</code></td><td>不是 NULL</td><td><code>email IS NOT NULL</code></td><td>可正常用索引</td></tr><tr><td align="center">模糊</td><td><code>LIKE &#39;xxx%&#39;</code></td><td>以 xxx 开头</td><td><code>name LIKE &#39;tom%&#39;</code></td><td><strong>能用索引，推荐</strong></td></tr><tr><td align="center">模糊</td><td><code>LIKE &#39;%xxx&#39;</code></td><td>以 xxx 结尾</td><td><code>name LIKE &#39;%tom&#39;</code></td><td><strong>不能用索引，慢</strong></td></tr><tr><td align="center">模糊</td><td><code>LIKE &#39;%xxx%&#39;</code></td><td>包含 xxx</td><td><code>name LIKE &#39;%tom%&#39;</code></td><td>大表慎用</td></tr><tr><td align="center">模糊</td><td><code>NOT LIKE</code></td><td>不匹配</td><td><code>name NOT LIKE &#39;test%&#39;</code></td><td>常配合 AND</td></tr><tr><td align="center">逻辑</td><td><code>AND</code></td><td>同时满足</td><td><code>age&gt;=18 AND age&lt;=30</code></td><td>xxxxxxxxxx6 1SELECT class_id, gender,2  COUNT(<em>) AS student_num3FROM student4GROUP BY class_id, gender  # 步骤1：按“班级+性别”分组统计5HAVING COUNT(</em>) &gt;&#x3D; 2       # 步骤2：过滤出人数≥2的分组6ORDER BY student_num DESC, class_id ASC;  # 步骤3：对过滤后的结果排序mysql</td></tr><tr><td align="center">逻辑</td><td><code>OR</code></td><td>满足一个即可</td><td><code>city=&#39;bj&#39; OR city=&#39;sh&#39;</code></td><td>一定配合括号</td></tr><tr><td align="center">逻辑</td><td><code>NOT</code></td><td>条件取反</td><td><code>NOT status=1</code></td><td>常和 IN &#x2F; LIKE 用</td></tr></tbody></table><p>LIKE 通配符说明：</p><table><thead><tr><th>符号</th><th>含义</th></tr></thead><tbody><tr><td><code>%</code></td><td>任意多个字符（包括 0 个）</td></tr><tr><td><code>_</code></td><td>任意 1 个字符（<code>name LIKE &#39;a_%&#39; </code> 表示以 a 开头，至少 2 个字符）</td></tr></tbody></table><blockquote><p><strong>实用规则：</strong></p><ul><li><strong>判断 NULL 永远用 <code>IS NULL / IS NOT NULL</code></strong></li><li><strong>AND &#x2F; OR 混用、条件多时，一定加括号保证逻辑清晰</strong></li><li><strong>优先用等值查询（&#x3D;），能用 <code>=</code> 就别用 <code>LIKE</code></strong></li><li><strong>WHERE 里的列尽量别参与计算</strong></li><li><strong>写 UPDATE &#x2F; DELETE 前先写 SELECT 验证</strong></li></ul></blockquote><h4 id="2-示例-8"><a href="#2-示例-8" class="headerlink" title="2. 示例"></a>2. 示例</h4><h5 id="1-等值查询（常用）"><a href="#1-等值查询（常用）" class="headerlink" title="1. 等值查询（常用）"></a>1. 等值查询（常用）</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><ul><li>查 id 等于 1 的那一行</li><li><strong>主键 &#x2F; 唯一键查询最常见</strong></li><li><strong>注意：字符串要加单引号</strong></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;tom&#x27;</span>;</span><br></pre></td></tr></table></figure><h5 id="2-不等于-大小比较"><a href="#2-不等于-大小比较" class="headerlink" title="2. 不等于 &#x2F; 大小比较"></a>2. 不等于 &#x2F; 大小比较</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> age <span class="operator">&gt;</span> <span class="number">18</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> age <span class="operator">&gt;=</span> <span class="number">18</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> age <span class="operator">&lt;</span> <span class="number">60</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> age <span class="operator">!=</span> <span class="number">30</span>;</span><br></pre></td></tr></table></figure><h5 id="3-AND-OR-组合条件（常用）"><a href="#3-AND-OR-组合条件（常用）" class="headerlink" title="3. AND &#x2F; OR 组合条件（常用）"></a>3. AND &#x2F; OR 组合条件（常用）</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users</span><br><span class="line"><span class="keyword">WHERE</span> age <span class="operator">&gt;=</span> <span class="number">18</span> <span class="keyword">AND</span> age <span class="operator">&lt;=</span> <span class="number">30</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users</span><br><span class="line"><span class="keyword">WHERE</span> city <span class="operator">=</span> <span class="string">&#x27;beijing&#x27;</span> <span class="keyword">OR</span> city <span class="operator">=</span> <span class="string">&#x27;shanghai&#x27;</span>;</span><br></pre></td></tr></table></figure><p><strong>注意：优先级坑（重点）</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WHERE</span> a <span class="operator">=</span> <span class="number">1</span> <span class="keyword">OR</span> b <span class="operator">=</span> <span class="number">2</span> <span class="keyword">AND</span> c <span class="operator">=</span> <span class="number">3</span></span><br><span class="line"># 等价于：</span><br><span class="line"><span class="keyword">WHERE</span> a <span class="operator">=</span> <span class="number">1</span> <span class="keyword">OR</span> (b <span class="operator">=</span> <span class="number">2</span> <span class="keyword">AND</span> c <span class="operator">=</span> <span class="number">3</span>)</span><br><span class="line"># 实际开发一定加括号</span><br><span class="line"><span class="keyword">WHERE</span> (a <span class="operator">=</span> <span class="number">1</span> <span class="keyword">OR</span> b <span class="operator">=</span> <span class="number">2</span>) <span class="keyword">AND</span> c <span class="operator">=</span> <span class="number">3</span>;</span><br></pre></td></tr></table></figure><h5 id="4-IN（多个值之一）"><a href="#4-IN（多个值之一）" class="headerlink" title="4. IN（多个值之一）"></a>4. IN（多个值之一）</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> id <span class="keyword">IN</span> (<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line"># 等价于：</span><br><span class="line"><span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">OR</span> id <span class="operator">=</span> <span class="number">3</span> <span class="keyword">OR</span> id <span class="operator">=</span> <span class="number">5</span>;</span><br></pre></td></tr></table></figure><p><strong>注意：IN 里值不要太多（几百上千会慢）！</strong></p><h5 id="5-BETWEEN（范围查询）"><a href="#5-BETWEEN（范围查询）" class="headerlink" title="5. BETWEEN（范围查询）"></a>5. BETWEEN（范围查询）</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> age <span class="keyword">BETWEEN</span> <span class="number">18</span> <span class="keyword">AND</span> <span class="number">30</span>;</span><br><span class="line"># 等价于：</span><br><span class="line"><span class="keyword">WHERE</span> age <span class="operator">&gt;=</span> <span class="number">18</span> <span class="keyword">AND</span> age <span class="operator">&lt;=</span> <span class="number">30</span>;</span><br></pre></td></tr></table></figure><h5 id="6-LIKE（模糊查询）"><a href="#6-LIKE（模糊查询）" class="headerlink" title="6. LIKE（模糊查询）"></a>6. LIKE（模糊查询）</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> name <span class="keyword">LIKE</span> <span class="string">&#x27;tom%&#x27;</span>;</span><br></pre></td></tr></table></figure><p>常见写法：</p><table><thead><tr><th>写法</th><th>含义</th></tr></thead><tbody><tr><td><code>&#39;tom%&#39;</code></td><td>以 tom 开头</td></tr><tr><td><code>&#39;%tom&#39;</code></td><td>以 tom 结尾</td></tr><tr><td><code>&#39;%tom%&#39;</code></td><td>包含 tom</td></tr></tbody></table><p>重要性能点：<strong><code>%xxx</code> 开头基本用不到索引</strong>、大表慎用模糊查询。</p><h5 id="7-IS-NULL-IS-NOT-NULL"><a href="#7-IS-NULL-IS-NOT-NULL" class="headerlink" title="7. IS NULL &#x2F; IS NOT NULL"></a>7. IS NULL &#x2F; IS NOT NULL</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> email <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> email <span class="keyword">IS</span> <span class="keyword">NOT NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">WHERE</span> email <span class="operator">=</span> <span class="keyword">NULL</span>;# 错误写法！！！</span><br></pre></td></tr></table></figure><h5 id="8-WHERE-中用表达式（能用但要小心）"><a href="#8-WHERE-中用表达式（能用但要小心）" class="headerlink" title="8. WHERE 中用表达式（能用但要小心）"></a>8. WHERE 中用表达式（能用但要小心）</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users</span><br><span class="line"><span class="keyword">WHERE</span> age <span class="operator">+</span> <span class="number">1</span> <span class="operator">=</span> <span class="number">19</span>;</span><br><span class="line"># 注意：列参与计算，索引基本失效，实际应写成：</span><br><span class="line"><span class="keyword">WHERE</span> age <span class="operator">=</span> <span class="number">18</span>;</span><br></pre></td></tr></table></figure><h3 id="3-结果排序"><a href="#3-结果排序" class="headerlink" title="3. 结果排序"></a>3. 结果排序</h3><p>结果排序用 <code>ORDER BY</code>，默认升序；会影响性能，尤其在大表上。</p><h4 id="1-语法-6"><a href="#1-语法-6" class="headerlink" title="1. 语法"></a>1. 语法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT 列</span><br><span class="line">FROM 表</span><br><span class="line">WHERE 条件</span><br><span class="line">ORDER BY 列 [ASC|DESC];</span><br></pre></td></tr></table></figure><ul><li><code>ASC</code>：升序（默认，可不写）。</li><li><code>DESC</code>：降序。</li></ul><p><strong>注意：升序（ASC）时 NULL 在最前，降序（DESC）时 NULL 在最后，因为 MySQL 把 NULL 当成“最小的值”来排序。NULL 代表“没有值”，不是具体数据，所以排序时统一放在最小端，ASC 就排前面，DESC 就被放到最后。</strong></p><h4 id="2-示例-9"><a href="#2-示例-9" class="headerlink" title="2. 示例"></a>2. 示例</h4><h5 id="1-单列排序"><a href="#1-单列排序" class="headerlink" title="1. 单列排序"></a>1. 单列排序</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">ORDER</span> <span class="keyword">BY</span> age [<span class="keyword">ASC</span><span class="operator">|</span><span class="keyword">DESC</span>];</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select name,age from t1 order by age asc;</span><br><span class="line">+-----------+------+</span><br><span class="line">| name      | age  |</span><br><span class="line">+-----------+------+</span><br><span class="line">| 王五      |   18 |</span><br><span class="line">| 小明      |   18 |</span><br><span class="line">| 小红红    |   18 |</span><br><span class="line">| 张三      |   20 |</span><br><span class="line">| 李四      |   20 |</span><br><span class="line">| 李四      |   25 |</span><br><span class="line">| NULL      |  100 |</span><br><span class="line">| 李四      |  100 |</span><br><span class="line">| 李四      |  100 |</span><br><span class="line">+-----------+------+</span><br><span class="line"></span><br><span class="line">mysql&gt; select name,age from t1 order by age desc;</span><br><span class="line">+-----------+------+</span><br><span class="line">| name      | age  |</span><br><span class="line">+-----------+------+</span><br><span class="line">| NULL      |  100 |</span><br><span class="line">| 李四      |  100 |</span><br><span class="line">| 李四      |  100 |</span><br><span class="line">| 李四      |   25 |</span><br><span class="line">| 张三      |   20 |</span><br><span class="line">| 李四      |   20 |</span><br><span class="line">| 王五      |   18 |</span><br><span class="line">| 小明      |   18 |</span><br><span class="line">| 小红红    |   18 |</span><br><span class="line">+-----------+------+</span><br></pre></td></tr></table></figure><h5 id="2-多列排序（真实项目常用）"><a href="#2-多列排序（真实项目常用）" class="headerlink" title="2. 多列排序（真实项目常用）"></a>2. 多列排序（真实项目常用）</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">ORDER</span> <span class="keyword">BY</span> age <span class="keyword">DESC</span>, id <span class="keyword">ASC</span>;# 先按 age 排，age 相同，再按 id 排</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 按id降序、name升序、age降序多级排序</span><br><span class="line">mysql&gt; select * from t1 order by id desc, name asc, age desc;</span><br><span class="line">+-----+-----------+------+</span><br><span class="line">| id  | name      | age  |</span><br><span class="line">+-----+-----------+------+</span><br><span class="line">| 102 | 李四      |  100 |</span><br><span class="line">| 101 | 李四      |  100 |</span><br><span class="line">| 100 | NULL      |  100 |</span><br><span class="line">|  99 | 小红红    |   18 |</span><br><span class="line">|   7 | 小明      |   18 |</span><br><span class="line">|   5 | 王五      |   18 |</span><br><span class="line">|   4 | 李四      |   25 |</span><br><span class="line">|   2 | 李四      |   20 |</span><br><span class="line">|   1 | 张三      |   20 |</span><br><span class="line">+-----+-----------+------+</span><br></pre></td></tr></table></figure><h5 id="3-ORDER-BY-WHERE（常见组合）"><a href="#3-ORDER-BY-WHERE（常见组合）" class="headerlink" title="3. ORDER BY + WHERE（常见组合）"></a>3. ORDER BY + WHERE（常见组合）</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users</span><br><span class="line"><span class="keyword">WHERE</span> age <span class="operator">&gt;=</span> <span class="number">18</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> created_at <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure><p><strong>执行顺序：</strong></p><ol><li>WHERE 过滤</li><li>ORDER BY 排序</li><li>返回结果</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 先给 age 起别名，再按别名排序</span><br><span class="line">mysql&gt; select *, age as my_age from t1 where age&lt;30 order by my_age desc;</span><br><span class="line">+----+-----------+------+--------+</span><br><span class="line">| id | name      | age  | my_age |</span><br><span class="line">+----+-----------+------+--------+</span><br><span class="line">|  4 | 李四      |   25 |     25 |</span><br><span class="line">|  1 | 张三      |   20 |     20 |</span><br><span class="line">|  2 | 李四      |   20 |     20 |</span><br><span class="line">|  5 | 王五      |   18 |     18 |</span><br><span class="line">|  7 | 小明      |   18 |     18 |</span><br><span class="line">| 99 | 小红红    |   18 |     18 |</span><br><span class="line">+----+-----------+------+--------+</span><br></pre></td></tr></table></figure><hr><h4 id="3-ORDER-BY-的几种进阶写法"><a href="#3-ORDER-BY-的几种进阶写法" class="headerlink" title="3. ORDER BY 的几种进阶写法"></a>3. ORDER BY 的几种进阶写法</h4><h5 id="1-按别名排序"><a href="#1-按别名排序" class="headerlink" title="1. 按别名排序"></a>1. 按别名排序</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> age <span class="operator">+</span> <span class="number">1</span> <span class="keyword">AS</span> new_age</span><br><span class="line"><span class="keyword">FROM</span> users</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> new_age <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure><p>可读性好，<strong>表达式排序可能慢</strong>！</p><h5 id="2-按表达式排序（能用但慎用）"><a href="#2-按表达式排序（能用但慎用）" class="headerlink" title="2. 按表达式排序（能用但慎用）"></a>2. 按表达式排序（能用但慎用）</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> age <span class="operator">+</span> score <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure><p><strong>风险：索引失效、数据量大时很慢。</strong></p><h5 id="3-ORDER-BY-NULL（禁止排序）"><a href="#3-ORDER-BY-NULL（禁止排序）" class="headerlink" title="3. ORDER BY NULL（禁止排序）"></a>3. ORDER BY NULL（禁止排序）</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> users <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure><p>用途：明确告诉 MySQL <strong>不需要排序</strong>，聚合查询时可微优化。</p><hr><h4 id="4-常见坑（重点）"><a href="#4-常见坑（重点）" class="headerlink" title="4. 常见坑（重点）"></a>4. 常见坑（重点）</h4><h5 id="1-ORDER-BY-大表非常慢"><a href="#1-ORDER-BY-大表非常慢" class="headerlink" title="1. ORDER BY 大表非常慢"></a>1. ORDER BY 大表非常慢</h5><p>原因：排序需要额外内存 &#x2F; 磁盘。</p><p>解决思路：</p><ul><li><strong>ORDER BY 的列尽量建索引</strong>。</li><li>排序方向要一致（ASC &#x2F; DESC）。</li></ul><h5 id="2-ORDER-BY-和索引方向不一致"><a href="#2-ORDER-BY-和索引方向不一致" class="headerlink" title="2. ORDER BY 和索引方向不一致"></a>2. ORDER BY 和索引方向不一致</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 索引： (age <span class="keyword">ASC</span>)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> age <span class="keyword">DESC</span>;  # 可能用不上索引</span><br></pre></td></tr></table></figure><h5 id="3-ORDER-BY-随机排序（千万别用）"><a href="#3-ORDER-BY-随机排序（千万别用）" class="headerlink" title="3. ORDER BY 随机排序（千万别用）"></a>3. ORDER BY 随机排序（千万别用）</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> RAND();  # 大表灾难</span><br></pre></td></tr></table></figure><h3 id="4-筛选分页结果"><a href="#4-筛选分页结果" class="headerlink" title="4. 筛选分页结果"></a>4. 筛选分页结果</h3><p><strong>“筛选分页结果”&#x3D; <code>WHERE</code> 先筛选 + <code>ORDER BY</code> 定序 + <code>LIMIT</code> 分页</strong>，顺序写错、方式选错，<strong>要么结果乱、要么性能炸</strong>。</p><h4 id="1-语法-7"><a href="#1-语法-7" class="headerlink" title="1. 语法"></a>1. 语法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT 列</span><br><span class="line">FROM 表</span><br><span class="line">WHERE 条件</span><br><span class="line">ORDER BY 排序列</span><br><span class="line">LIMIT offset, page_size; # 注意：LIMIT单参数表示仅取前n条数据（非分页），双参数表示跳过前x条、取后续n条数据（属于分页）</span><br></pre></td></tr></table></figure><p><strong>分页计算逻辑：</strong></p><p><code>LIMIT offset, page_size</code> 是 MySQL 分页语法：</p><ul><li><code>offset</code>：需要跳过的记录数（计算方式：<code>(页码 - 1) * 每页条数</code>&#x2F;<code>offset = (page - 1) * page_size</code>）。</li><li><code>page_size</code>：每页显示的条数（这里是 10）。</li></ul><p><strong>示例：</strong> 假设需要取第 3 页的数据，每页显示 10 条，那么：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM users</span><br><span class="line">WHERE status = 1  # 筛选条件（只查status=1的记录）</span><br><span class="line">ORDER BY id DESC  # 按id降序排列</span><br><span class="line">LIMIT 20, 10;     # 分页：跳过前20条，取接下来的10条(offset = (3-1)*10 = 20)</span><br></pre></td></tr></table></figure><h4 id="2-示例-10"><a href="#2-示例-10" class="headerlink" title="2. 示例"></a>2. 示例</h4><h5 id="1-首页-最新列表（常用）"><a href="#1-首页-最新列表（常用）" class="headerlink" title="1. 首页 &#x2F; 最新列表（常用）"></a>1. 首页 &#x2F; 最新列表（常用）</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM users</span><br><span class="line">WHERE age = 18</span><br><span class="line">ORDER BY created_at DESC</span><br><span class="line">LIMIT 10;# 只取器前10条数据（非分页）</span><br></pre></td></tr></table></figure><h5 id="2-条件-分页（）"><a href="#2-条件-分页（）" class="headerlink" title="2. 条件 + 分页（）"></a>2. 条件 + 分页（）</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM users</span><br><span class="line">WHERE id = 1001</span><br><span class="line">  AND age = 18</span><br><span class="line">ORDER BY id DESC</span><br><span class="line">LIMIT 0, 20;# 跳过前0条数据，取紧接着后面的20条数据（分页）</span><br><span class="line"></span><br><span class="line">SELECT * FROM users</span><br><span class="line">ORDER BY id DESC</span><br><span class="line">LIMIT 20 OFFSET 40;# 等价写法，但 LIMIT 40, 20; 更常见</span><br></pre></td></tr></table></figure><h4 id="3-注意事项（坑点）"><a href="#3-注意事项（坑点）" class="headerlink" title="3. 注意事项（坑点）"></a>3. 注意事项（坑点）</h4><h5 id="1-没写-ORDER-BY（致命）"><a href="#1-没写-ORDER-BY（致命）" class="headerlink" title="1. 没写 ORDER BY（致命）"></a>1. 没写 ORDER BY（致命）</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM users LIMIT 10;</span><br></pre></td></tr></table></figure><p>问题：每次返回顺序可能不同、翻页会 <strong>重复 &#x2F; 丢数据</strong>，<strong>分页必须 ORDER BY</strong>！</p><h5 id="2-ORDER-BY-LIMIT-深分页（性能杀手）"><a href="#2-ORDER-BY-LIMIT-深分页（性能杀手）" class="headerlink" title="2. ORDER BY + LIMIT 深分页（性能杀手）"></a>2. ORDER BY + LIMIT 深分页（性能杀手）</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LIMIT <span class="number">100000</span>, <span class="number">20</span>;  # 非常慢，MySQL需要先扫描<span class="number">100000</span>条，再丢掉，只取<span class="number">20</span>条。</span><br></pre></td></tr></table></figure><h4 id="4-高性能分页方式（进阶重点）"><a href="#4-高性能分页方式（进阶重点）" class="headerlink" title="4. 高性能分页方式（进阶重点）"></a>4. 高性能分页方式（进阶重点）</h4><h5 id="1-游标分页（强烈推荐）"><a href="#1-游标分页（强烈推荐）" class="headerlink" title="1. 游标分页（强烈推荐）"></a>1. 游标分页（强烈推荐）</h5><p><strong>思想：用“上一页最后一条数据”翻页</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM users</span><br><span class="line">WHERE id &lt; 10000</span><br><span class="line">ORDER BY id DESC</span><br><span class="line">LIMIT 20;</span><br></pre></td></tr></table></figure><p>特点：不用 offset、越往后 <strong>速度越快</strong>、实际项目常用。</p><h5 id="2-时间游标分页"><a href="#2-时间游标分页" class="headerlink" title="2. 时间游标分页"></a>2. 时间游标分页</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM users</span><br><span class="line">WHERE created_at &lt; &#x27;2025-01-01 10:00:00&#x27;</span><br><span class="line">ORDER BY created_at DESC</span><br><span class="line">LIMIT 20;</span><br></pre></td></tr></table></figure><h5 id="3-分页-索引的黄金组合"><a href="#3-分页-索引的黄金组合" class="headerlink" title="3. 分页 + 索引的黄金组合"></a>3. 分页 + 索引的黄金组合</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">WHERE 条件</span><br><span class="line">ORDER BY id DESC</span><br><span class="line">LIMIT 20;</span><br></pre></td></tr></table></figure><p><strong>排序列必须有索引</strong>，否则分页再小也慢。推荐：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INDEX(id)</span><br><span class="line">INDEX(created_at)</span><br></pre></td></tr></table></figure><h5 id="4-分页时统计总数（常见需求）"><a href="#4-分页时统计总数（常见需求）" class="headerlink" title="4. 分页时统计总数（常见需求）"></a>4. 分页时统计总数（常见需求）</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 正确做法：分两条 SQL，不要在一条 SQL 里又分页又 count（慢）</span><br><span class="line"># 查数据</span><br><span class="line">SELECT * FROM users</span><br><span class="line">WHERE age = 18</span><br><span class="line">ORDER BY id DESC</span><br><span class="line">LIMIT 20;</span><br><span class="line"></span><br><span class="line"># 查总数</span><br><span class="line">SELECT COUNT(*) FROM users WHERE age = 1;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;表的增删改查上&quot;&gt;&lt;a href=&quot;#表的增删改查上&quot; class=&quot;headerlink&quot; title=&quot;表的增删改查上&quot;&gt;&lt;/a&gt;表的增删改查上&lt;/h1&gt;&lt;h2 id=&quot;1-Create（创建）&quot;&gt;&lt;a href=&quot;#1-Create（创建）&quot;</summary>
        
      
    
    
    
    <category term="MySQL" scheme="https://www.minbit.top/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="https://www.minbit.top/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>06 表的约束</title>
    <link href="https://www.minbit.top/posts/37148.html"/>
    <id>https://www.minbit.top/posts/37148.html</id>
    <published>2025-11-01T16:00:00.000Z</published>
    <updated>2025-11-03T02:10:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="表的约束"><a href="#表的约束" class="headerlink" title="表的约束"></a>表的约束</h1><h2 id="1-什么是表的约束？"><a href="#1-什么是表的约束？" class="headerlink" title="1. 什么是表的约束？"></a>1. 什么是表的约束？</h2><p>表的约束就是 <strong>限制字段中能存什么数据、不能存什么数据</strong> 的规则，目的：<strong>防止脏数据进入数据库</strong>。举例理解：</p><ul><li>不允许“性别”列里填手机号。</li><li>不允许“年龄”列为空或写成负数。</li><li>不允许两个人用同一个账号。</li><li>……</li></ul><h2 id="2-空属性（NULL-NOT-NULL）"><a href="#2-空属性（NULL-NOT-NULL）" class="headerlink" title="2. 空属性（NULL / NOT NULL）"></a>2. 空属性（<code>NULL / NOT NULL</code>）</h2><h3 id="1-空属性介绍"><a href="#1-空属性介绍" class="headerlink" title="1. 空属性介绍"></a>1. 空属性介绍</h3><table><thead><tr><th>属性</th><th>含义</th><th>特点</th></tr></thead><tbody><tr><td><code>NULL</code></td><td>可以不填</td><td>默认状态</td></tr><tr><td><code>NOT NULL</code></td><td>必须有值</td><td>插入时没写就会报错</td></tr></tbody></table><p><strong>注意：</strong></p><ul><li>空值 <code>NULL</code> 不等于空字符串 <code>&#39;&#39;</code>，也不等于 0。</li><li><code>NULL</code> 参与运算的结果仍是 <code>NULL</code>，比如：<code>NULL + 1 = NULL</code>。</li><li>实际开发中：<strong>能不为空的字段尽量设置 NOT NULL</strong>。</li></ul><h3 id="2-语法格式"><a href="#2-语法格式" class="headerlink" title="2. 语法格式"></a>2. 语法格式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">列名 数据类型 [NULL | NOT NULL]</span><br></pre></td></tr></table></figure><h3 id="3-基本使用"><a href="#3-基本使用" class="headerlink" title="3. 基本使用"></a>3. 基本使用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"># 创建表t1，字段约束说明：name：非空（not null），必须提供值；age和room：允许为null（默认可省略null关键字）</span><br><span class="line">create table t1(</span><br><span class="line">    name varchar(20) not null,</span><br><span class="line">    age varchar(20) null,</span><br><span class="line">    room varchar(20));</span><br><span class="line"></span><br><span class="line"># 查看表结构：Null列显示NO表示非空（name），YES表示允许为空（age、room）；Default均为NULL</span><br><span class="line">desc t1;</span><br><span class="line">+-------+-------------+------+-----+---------+-------+</span><br><span class="line">| Field | Type        | Null | Key | Default | Extra |</span><br><span class="line">+-------+-------------+------+-----+---------+-------+</span><br><span class="line">| name  | varchar(20) | NO   |     | NULL    |       |  # 非空字段，必须赋值</span><br><span class="line">| age   | varchar(20) | YES  |     | NULL    |       |  # 可空字段，可省略赋值</span><br><span class="line">| room  | varchar(20) | YES  |     | NULL    |       |  # 可空字段，可省略赋值</span><br><span class="line">+-------+-------------+------+-----+---------+-------+</span><br><span class="line"></span><br><span class="line"># 插入时未给非空字段name赋值 → 报错（非空字段必须提供值）</span><br><span class="line">insert into t1(age) values(18);</span><br><span class="line">ERROR 1364 (HY000): Field &#x27;name&#x27; doesn&#x27;t have a default value</span><br><span class="line"></span><br><span class="line"># 只给非空字段name赋值，可空字段age、room省略 → 成功（省略字段自动为NULL）</span><br><span class="line">insert into t1(name) values(&#x27;张三&#x27;);</span><br><span class="line"></span><br><span class="line"># 未给非空字段name赋值，只给可空字段赋值 → 报错</span><br><span class="line">insert into t1(age,room) values(18,520);</span><br><span class="line">ERROR 1364 (HY000): Field &#x27;name&#x27; doesn&#x27;t have a default value</span><br><span class="line"></span><br><span class="line"># 给非空字段name和可空字段room赋值，age省略 → 成功</span><br><span class="line">insert into t1(name,room) values(&#x27;张三&#x27;,520);</span><br></pre></td></tr></table></figure><h2 id="3-默认值（DEFAULT）"><a href="#3-默认值（DEFAULT）" class="headerlink" title="3. 默认值（DEFAULT）"></a>3. 默认值（<code>DEFAULT</code>）</h2><h3 id="1-默认值介绍"><a href="#1-默认值介绍" class="headerlink" title="1. 默认值介绍"></a>1. 默认值介绍</h3><p><code>DEFAULT</code> 表示字段在 <strong>没写值时自动填默认值</strong>。</p><h3 id="2-语法格式-1"><a href="#2-语法格式-1" class="headerlink" title="2. 语法格式"></a>2. 语法格式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">列名 数据类型 [DEFAULT 默认值]</span><br><span class="line">age INT DEFAULT 18# 向表中插入时没写 age，会自动补 18。如果写了值，则按自己写的为准。</span><br></pre></td></tr></table></figure><p><strong>常见用法：</strong></p><ul><li><code>DEFAULT 0</code> 表示默认值为 0。</li><li><code>DEFAULT CURRENT_TIMESTAMP</code> 表示默认当前时间。</li></ul><h3 id="3-基本使用-1"><a href="#3-基本使用-1" class="headerlink" title="3. 基本使用"></a>3. 基本使用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># 创建表t2，定义4个字段并为部分字段设置默认值：</span><br><span class="line"># id：无默认值（需显式赋值）；age：默认值18；status：默认值&#x27;未激活&#x27;；create_time：默认当前时间</span><br><span class="line">create table t2(</span><br><span class="line">    id int,</span><br><span class="line">    age int default 18,  # 整数类型，未赋值时默认填充18</span><br><span class="line">    status VARCHAR(10) DEFAULT &#x27;未激活&#x27;,  # 字符串类型，未赋值时默认填充&#x27;未激活&#x27;</span><br><span class="line">    create_time DATETIME DEFAULT CURRENT_TIMESTAMP);  # 日期时间类型，未赋值时默认当前系统时间</span><br><span class="line"></span><br><span class="line"># 仅给id赋值，其他字段使用默认值：age→18（默认）、status→&#x27;未激活&#x27;（默认）、create_time→插入时的当前时间</span><br><span class="line">insert into t2(id) values(100);</span><br><span class="line"></span><br><span class="line"># 给所有字段赋值，其中create_time用default显式调用默认值（当前时间）：</span><br><span class="line"># id=200、age=50（覆盖默认18）、status=&#x27;已激活&#x27;（覆盖默认&#x27;未激活&#x27;）、create_time→当前时间</span><br><span class="line">insert into t2 values(200,50,&#x27;已激活&#x27;,default);</span><br><span class="line"></span><br><span class="line"># 查询结果：第一条记录：未赋值字段均显示默认值；第二条记录：显式赋值字段覆盖默认，create_time仍用当前时间</span><br><span class="line">select * from t2;</span><br><span class="line">+------+------+-----------+---------------------+</span><br><span class="line">| id   | age  | status    | create_time         |</span><br><span class="line">+------+------+-----------+---------------------+</span><br><span class="line">|  100 |   18 | 未激活    | 2025-10-02 19:32:48 |  # age=18、status=未激活（默认），create_time为第一条插入时间</span><br><span class="line">|  200 |   50 | 已激活    | 2025-10-02 19:34:07 |  # age=50、status=已激活（覆盖默认），create_time为第二条插入时间</span><br><span class="line">+------+------+-----------+---------------------+</span><br></pre></td></tr></table></figure><h3 id="4-同时设置-not-null-和-default"><a href="#4-同时设置-not-null-和-default" class="headerlink" title="4. 同时设置 not null 和 default"></a>4. 同时设置 <code>not null</code> 和 <code>default</code></h3><p><strong>一旦给某一字段设置了默认值，那么该字段将不会出现空值，因为就算插入数据时没有指明该字段的值，也会使用该字段的默认值进行填充。而给某一字段设置 not null 属性的目的是约束该字段不能为空，因此一个字段设置了 default 属性后，再设置 not null 属性就没有意义了。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"># 1. 创建表t3：故意只给age设default、不给name设default，用于对比</span><br><span class="line">create table t3(</span><br><span class="line">    name varchar(20) not null,  # 仅设not null，无default</span><br><span class="line">    age int not null default 18  # 同时设not null + default</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"># 查看表结构：确认约束生效</span><br><span class="line">desc t3;</span><br><span class="line">+-------+-------------+------+-----+---------+-------+</span><br><span class="line">| Field | Type        | Null | Key | Default | Extra |</span><br><span class="line">+-------+-------------+------+-----+---------+-------+</span><br><span class="line">| name  | varchar(20) | NO   |     | NULL    |       |  # 仅not null，Default为NULL</span><br><span class="line">| age   | int         | NO   |     | 18      |       |  # not null+default，Default为18</span><br><span class="line">+-------+-------------+------+-----+---------+-------+</span><br><span class="line"></span><br><span class="line"># 2. 实验1：插入时不指定name（仅not null无default）→ 报错</span><br><span class="line"># 原因：name是not null但无默认值，未赋值时无法填充，触发非空约束</span><br><span class="line">insert into t3(age) values(20);</span><br><span class="line">ERROR 1364 (HY000): Field &#x27;name&#x27; doesn&#x27;t have a default value</span><br><span class="line"></span><br><span class="line"># 3. 实验2：插入时不指定age（not null+default）→ 成功</span><br><span class="line"># 原因：age虽为not null，但有default 18，未赋值时自动用默认值填充，满足非空约束</span><br><span class="line">insert into t3(name) values(&#x27;张三&#x27;);</span><br><span class="line"></span><br><span class="line"># 4. 实验3：显式给age赋值（覆盖默认值）→ 成功，验证：default不影响显式赋值，仅在“未赋值”时生效</span><br><span class="line">insert into t3(name, age) values(&#x27;李四&#x27;, 22);</span><br><span class="line"></span><br><span class="line"># 5. 查看结果：确认default的填充效果</span><br><span class="line">select * from t3;</span><br><span class="line">+------+-----+</span><br><span class="line">| name | age |</span><br><span class="line">+------+-----+</span><br><span class="line">| 张三 |  18 |  # 未给age赋值，自动填充default 18（满足not null）</span><br><span class="line">| 李四 |  22 |  # 显式赋值22，覆盖默认值</span><br><span class="line">+------+-----+</span><br><span class="line"></span><br><span class="line"># 6. 反证实验：若age只设default、不设not null（模拟“认为default足够”的场景）</span><br><span class="line">create table t4(</span><br><span class="line">    age int default 18  # 仅设default，无not null</span><br><span class="line">);</span><br><span class="line"># 插入时主动给age赋null → 成功（此时出现空值，违背“不允许空”的初衷）</span><br><span class="line">insert into t4(age) values(null);</span><br><span class="line"></span><br><span class="line"># 查看结果：出现了空值，证明仅靠default无法约束“主动插入null”</span><br><span class="line">select * from t4;</span><br><span class="line">+------+</span><br><span class="line">| age  |</span><br><span class="line">+------+</span><br><span class="line">| NULL |  # 主动插入null时，default失效</span><br><span class="line">+------+</span><br></pre></td></tr></table></figure><p>但也会用于强制字段非空 + 自动填充（即确保开发者不能主动插入 null，只能自动或手动写具体值）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create table users(</span><br><span class="line">    status tinyint not null default 0 comment &#x27;0=未激活,1=已激活&#x27;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="4-列描述"><a href="#4-列描述" class="headerlink" title="4. 列描述"></a>4. 列描述</h2><h3 id="1-列描述介绍"><a href="#1-列描述介绍" class="headerlink" title="1. 列描述介绍"></a>1. 列描述介绍</h3><p>给表或字段添加说明文字，用来 <strong>描述字段含义</strong>，不会影响功能，只是为了 <strong>方便阅读与维护</strong>。</p><h3 id="2-语法格式-2"><a href="#2-语法格式-2" class="headerlink" title="2. 语法格式"></a>2. 语法格式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">列名 数据类型 [约束] COMMENT &#x27;描述信息&#x27;;</span><br><span class="line"># 或者在创建表时添加表注释：</span><br><span class="line">CREATE TABLE 表名 (</span><br><span class="line">    ...</span><br><span class="line">) COMMENT=&#x27;表的说明&#x27;;</span><br></pre></td></tr></table></figure><h3 id="3-基本使用-2"><a href="#3-基本使用-2" class="headerlink" title="3. 基本使用"></a>3. 基本使用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 创建表t3，为每个字段添加comment（字段注释，说明字段含义）</span><br><span class="line">create table t3(</span><br><span class="line">    id int comment &#x27;这是id编号&#x27;,  # 给id字段加注释</span><br><span class="line">    name varchar(20) comment &#x27;这是姓名&#x27;,  # 给name字段加注释</span><br><span class="line">    age int default 18 comment &#x27;这是年龄&#x27;);  # 给age字段加注释（同时有默认值）</span><br><span class="line"></span><br><span class="line"># 查看t3的完整创建语句，确认注释是否生效</span><br><span class="line">show create table t3\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">       Table: t3</span><br><span class="line">Create Table: CREATE TABLE `t3` (</span><br><span class="line">  `id` int DEFAULT NULL COMMENT &#x27;这是id编号&#x27;,  # 字段注释显示在字段定义后</span><br><span class="line">  `name` varchar(20) COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT &#x27;这是姓名&#x27;,  # 字段注释生效</span><br><span class="line">  `age` int DEFAULT &#x27;18&#x27; COMMENT &#x27;这是年龄&#x27;  # 字段注释+默认值同时生效</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"># 创建表t4，在表定义末尾添加comment（表级注释，说明表的用途）</span><br><span class="line">create table t4(</span><br><span class="line">    id int,</span><br><span class="line">    name varchar(20)</span><br><span class="line">    ) comment=&#x27;学生信息表&#x27;;  # 给表本身加注释</span><br><span class="line"></span><br><span class="line"># 查看t4的表状态信息，确认表注释是否生效</span><br><span class="line">show table status like &#x27;t4&#x27;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           Name: t4</span><br><span class="line">         Engine: InnoDB</span><br><span class="line">        Version: 10</span><br><span class="line">     Row_format: Dynamic</span><br><span class="line">           Rows: 0</span><br><span class="line"> Avg_row_length: 0</span><br><span class="line">    Data_length: 16384</span><br><span class="line">Max_data_length: 0</span><br><span class="line">   Index_length: 0</span><br><span class="line">      Data_free: 0</span><br><span class="line"> Auto_increment: NULL</span><br><span class="line">    Create_time: 2025-10-02 19:51:30</span><br><span class="line">    Update_time: NULL</span><br><span class="line">     Check_time: NULL</span><br><span class="line">      Collation: utf8mb4_general_ci</span><br><span class="line">       Checksum: NULL</span><br><span class="line"> Create_options: </span><br><span class="line">        Comment: 学生信息表  # 表注释显示在Comment字段中</span><br></pre></td></tr></table></figure><h2 id="5-ZEROFILL（补零属性）"><a href="#5-ZEROFILL（补零属性）" class="headerlink" title="5. ZEROFILL（补零属性）"></a>5. ZEROFILL（补零属性）</h2><h3 id="1-zerofill-介绍"><a href="#1-zerofill-介绍" class="headerlink" title="1. zerofill 介绍"></a>1. zerofill 介绍</h3><p>数字类型前自动补零，主要用于 <strong>统一显示位数</strong>，常用于编号、ID、订单号等字段。</p><h3 id="2-语法格式-3"><a href="#2-语法格式-3" class="headerlink" title="2. 语法格式"></a>2. 语法格式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">列名 数据类型(ZEROFILL)</span><br></pre></td></tr></table></figure><p><strong>特性说明:</strong></p><ol><li>自动加上 <strong>UNSIGNED</strong>（无符号）属性，即不允许负数！</li><li>只影响 <strong>显示</strong>，不会改变实际存储的数值。</li><li>括号中的数字是 <strong>显示宽度</strong>，不是有效位数。</li><li>在 MySQL 8.0.17 之后，<code>ZEROFILL</code> 已 <strong>不推荐使用（废弃特性）</strong>，建议用 <code>LPAD()</code> 函数代替。</li></ol><h3 id="3-基本使用-3"><a href="#3-基本使用-3" class="headerlink" title="3. 基本使用"></a>3. 基本使用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"># 创建表t5，id字段加zerofill（数字前补0）</span><br><span class="line">create table t5(id int zerofill);</span><br><span class="line"></span><br><span class="line"># 插入1，显示时补0到int默认长度（10位）</span><br><span class="line">insert into t5 values(1);</span><br><span class="line"></span><br><span class="line"># 插入12，补0到10位</span><br><span class="line">insert into t5 values(12);</span><br><span class="line"></span><br><span class="line"># 插入123，补0到10位</span><br><span class="line">insert into t5 values(123);</span><br><span class="line"></span><br><span class="line"># 插入负数，zerofill隐含unsigned（无符号），负数不允许</span><br><span class="line">insert into t5 values(-123);</span><br><span class="line">ERROR 1264 (22003): Out of range value for column &#x27;id&#x27; at row 1</span><br><span class="line"></span><br><span class="line"># 插入0，补0到10位</span><br><span class="line">insert into t5 values(0);</span><br><span class="line"></span><br><span class="line"># 查询结果：数字不足10位的，前面补0凑够长度</span><br><span class="line">select *from t5;</span><br><span class="line">+------------+</span><br><span class="line">| id         |</span><br><span class="line">+------------+</span><br><span class="line">| 0000000001 |</span><br><span class="line">| 0000000012 |</span><br><span class="line">| 0000000123 |</span><br><span class="line">| 0000000000 |</span><br><span class="line">+------------+</span><br></pre></td></tr></table></figure><h2 id="6-主键（PRIMARY-KEY）"><a href="#6-主键（PRIMARY-KEY）" class="headerlink" title="6. 主键（PRIMARY KEY）"></a>6. 主键（PRIMARY KEY）</h2><h3 id="1-主键介绍"><a href="#1-主键介绍" class="headerlink" title="1. 主键介绍"></a>1. 主键介绍</h3><p>主键用于 <strong>唯一标识一行数据</strong>，就像身份证号一样，表中每行数据都要有一个主键值。<strong>主键列的值不能重复，也不能为空（NOT NULL）</strong>。</p><h3 id="2-语法格式-4"><a href="#2-语法格式-4" class="headerlink" title="2. 语法格式"></a>2. 语法格式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">列名 数据类型 PRIMARY KEY</span><br><span class="line"># 或者单独写在最后：</span><br><span class="line">PRIMARY KEY (列名)</span><br></pre></td></tr></table></figure><table><thead><tr><th>特性</th><th>说明</th></tr></thead><tbody><tr><td>不能重复</td><td>每行唯一</td></tr><tr><td>不能为空</td><td>必须有值</td></tr><tr><td>每张表只能有一个主键</td><td>但可由多个列组成（联合主键）</td></tr><tr><td>通常与 AUTO_INCREMENT 一起用</td><td>自动编号更方便</td></tr></tbody></table><h3 id="3-基本使用-4"><a href="#3-基本使用-4" class="headerlink" title="3. 基本使用"></a>3. 基本使用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 创建表t6，id设为主键（primary key，唯一且非空）</span><br><span class="line">create table t6(</span><br><span class="line">    id int primary key,</span><br><span class="line">    name varchar(20));</span><br><span class="line"></span><br><span class="line"># 正确插入：id=108（主键），符合格式</span><br><span class="line">insert into t6 values(108,&#x27;minbit&#x27;);</span><br><span class="line"></span><br><span class="line"># 插入重复主键：id=108已存在，主键必须唯一，报错</span><br><span class="line">insert into t6 values(108,&#x27;小米里的大麦&#x27;);</span><br><span class="line">ERROR 1062 (23000): 主键值108重复</span><br><span class="line"></span><br><span class="line"># 插入新主键：id=100（新值），成功</span><br><span class="line">insert into t6 values(100,&#x27;小米里的大麦&#x27;);</span><br></pre></td></tr></table></figure><p><strong>添加联合（复合）主键（多个字段一起作为主键）：</strong></p><ul><li>多个字段共同组成主键。</li><li>常用于需要联合唯一标识一行数据的场景，比如学生 + 课程。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE 表名 ADD PRIMARY KEY (列名1, 列名2);</span><br><span class="line"></span><br><span class="line"># 同一个学生在同一门课中只能有一条成绩记录</span><br><span class="line">CREATE TABLE score (</span><br><span class="line">    student_id INT,</span><br><span class="line">    course_id INT,</span><br><span class="line">    score INT,</span><br><span class="line">    PRIMARY KEY (student_id, course_id)   # 联合/复合主键</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><strong>（表创建后）添加主键：</strong></p><ul><li>给表中某个字段设置主键约束。</li><li>如果字段中已有重复值或空值，命令会失败（因为主键必须唯一且非空）。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE 表名 ADD PRIMARY KEY (列名);</span><br><span class="line">alter table students ADD PRIMARY KEY (id);</span><br></pre></td></tr></table></figure><p><strong>删除主键：</strong></p><ul><li>删除表中的主键约束。</li><li>注意：如果主键列是 <code>AUTO_INCREMENT</code>，删除主键后自增属性会失效。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE 表名 DROP PRIMARY KEY;</span><br><span class="line">alter table students DROP PRIMARY KEY;</span><br></pre></td></tr></table></figure><table><thead><tr><th>操作</th><th>通用语法</th><th>说明</th></tr></thead><tbody><tr><td>添加主键</td><td><code>ALTER TABLE 表名 ADD PRIMARY KEY (列名);</code></td><td>为现有字段设置主键</td></tr><tr><td>删除主键</td><td><code>ALTER TABLE 表名 DROP PRIMARY KEY;</code></td><td>删除主键约束</td></tr><tr><td>联合主键</td><td><code>ALTER TABLE 表名 ADD PRIMARY KEY (列1, 列2);</code></td><td>多列联合唯一</td></tr><tr><td>修改主键</td><td>先 <code>DROP</code> 再 <code>ADD</code></td><td>重新指定主键</td></tr></tbody></table><h2 id="7-自增长（AUTO-INCREMENT）"><a href="#7-自增长（AUTO-INCREMENT）" class="headerlink" title="7. 自增长（AUTO_INCREMENT）"></a>7. 自增长（AUTO_INCREMENT）</h2><h3 id="1-自增长介绍"><a href="#1-自增长介绍" class="headerlink" title="1. 自增长介绍"></a>1. 自增长介绍</h3><p><code>AUTO_INCREMENT</code> 表示 <strong>自动编号</strong>，插入新数据时自动加 1，最常与主键一起使用。</p><h3 id="2-语法格式-5"><a href="#2-语法格式-5" class="headerlink" title="2. 语法格式"></a>2. 语法格式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">列名 数据类型 AUTO_INCREMENT</span><br><span class="line"># 一般配合主键：</span><br><span class="line">id INT PRIMARY KEY AUTO_INCREMENT</span><br></pre></td></tr></table></figure><p><strong>注意事项：</strong></p><ol><li>一张表只能有 <strong>一个自增字段</strong>。</li><li>自增字段必须是整数类型。</li><li>一般与主键一起用。</li><li>删除数据不会回退编号（除非手动重置）。</li></ol><blockquote><p><strong>如果删除最后一行，再插入新行，id 不会复用旧编号，想手动恢复编号，可执行：<code>alter table 表名 auto_increment = 新编号;</code>。如果表被 <code>TRUNCATE TABLE</code> 清空（比 delete 快），自增编号会被重置为 1。</strong></p></blockquote><h3 id="3-基本使用-5"><a href="#3-基本使用-5" class="headerlink" title="3. 基本使用"></a>3. 基本使用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"># 创建表t7，id设为主键且自动增长（auto_increment）</span><br><span class="line">create table t7(</span><br><span class="line">    id int primary key auto_increment,  # id自动生成唯一值，无需手动插入</span><br><span class="line">    name varchar(20) );</span><br><span class="line"></span><br><span class="line"># 插入数据时，只需指定name，id会自动增长（插入时没写 id，MySQL 自动编号）</span><br><span class="line">insert into t7 (name) values (&#x27;张三&#x27;);  # id自动为1</span><br><span class="line">insert into t7 (name) values (&#x27;李四&#x27;);  # id自动为2</span><br><span class="line">insert into t7 (name) values (&#x27;王五&#x27;);  # id自动为3</span><br><span class="line"></span><br><span class="line"># 查询结果：id按插入顺序自动生成1、2、3</span><br><span class="line">select * from t7;</span><br><span class="line">+----+--------+</span><br><span class="line">| id | name   |</span><br><span class="line">+----+--------+</span><br><span class="line">|  1 | 张三   |</span><br><span class="line">|  2 | 李四   |</span><br><span class="line">|  3 | 王五   |</span><br><span class="line">+----+--------+</span><br><span class="line"></span><br><span class="line"># 删除name为&quot;李四&quot;的记录（id=2）</span><br><span class="line">delete from t7 where name = &quot;李四&quot;;</span><br><span class="line"></span><br><span class="line"># 再次查询：id=2的记录被删除，后续插入的id不会填补空缺</span><br><span class="line">select * from t7;</span><br><span class="line">+----+--------+</span><br><span class="line">| id | name   |</span><br><span class="line">+----+--------+</span><br><span class="line">|  1 | 张三   |</span><br><span class="line">|  3 | 王五   |  # id仍为3，自动增长不会回退</span><br><span class="line">+----+--------+</span><br><span class="line"></span><br><span class="line"># 修改t7表的自增起始值为1000（不影响已有数据）</span><br><span class="line">alter table t7 auto_increment = 1000;</span><br><span class="line"></span><br><span class="line"># 查看表数据：已有id不变（1、3）</span><br><span class="line">select * from t7;</span><br><span class="line">+----+--------+</span><br><span class="line">| id | name   |</span><br><span class="line">+----+--------+</span><br><span class="line">|  1 | 张三   |</span><br><span class="line">|  3 | 王五   |</span><br><span class="line">+----+--------+</span><br><span class="line"></span><br><span class="line"># 插入新数据：新id从1000开始（按修改后的自增值）</span><br><span class="line">insert into t7 (name) values (&#x27;老李&#x27;);</span><br><span class="line"></span><br><span class="line"># 新记录id为1000，符合设置的起始值</span><br><span class="line">select * from t7;</span><br><span class="line">+------+--------+</span><br><span class="line">| id   | name   |</span><br><span class="line">+------+--------+</span><br><span class="line">|    1 | 张三   |</span><br><span class="line">|    3 | 王五   |</span><br><span class="line">| 1000 | 老李   |</span><br><span class="line">+------+--------+</span><br><span class="line"></span><br><span class="line"># 查看表状态：Auto_increment显示下一个自增值为1001（当前最大id+1）</span><br><span class="line">show table status like &#x27;t7&#x27;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           Name: t7</span><br><span class="line">         Engine: InnoDB</span><br><span class="line">        Version: 10</span><br><span class="line">     Row_format: Dynamic</span><br><span class="line">           Rows: 3</span><br><span class="line"> Avg_row_length: 5461</span><br><span class="line">    Data_length: 16384</span><br><span class="line">Max_data_length: 0</span><br><span class="line">   Index_length: 0</span><br><span class="line">      Data_free: 0</span><br><span class="line"> Auto_increment: 1001# 下一次插入将使用1001</span><br><span class="line">    Create_time: 2025-10-02 20:33:15</span><br><span class="line">    Update_time: 2025-10-02 20:34:12</span><br><span class="line">     Check_time: NULL</span><br><span class="line">      Collation: utf8mb4_general_ci</span><br><span class="line">       Checksum: NULL</span><br><span class="line"> Create_options: </span><br><span class="line">        Comment:</span><br><span class="line"></span><br><span class="line"># 尝试将自增起始值改回1（但受已有最大id影响）</span><br><span class="line">alter table t7 auto_increment=1;</span><br><span class="line"></span><br><span class="line"># 已有数据id仍不变</span><br><span class="line">select * from t7;</span><br><span class="line">+------+--------+</span><br><span class="line">| id   | name   |</span><br><span class="line">+------+--------+</span><br><span class="line">|    1 | 张三   |</span><br><span class="line">|    3 | 王五   |</span><br><span class="line">| 1000 | 老李   |</span><br><span class="line">+------+--------+</span><br><span class="line"></span><br><span class="line"># 插入新数据：自增值不会小于已有最大id（1000），故新id为1001</span><br><span class="line">insert into t7 (name) values (&#x27;老王&#x27;);</span><br><span class="line"></span><br><span class="line"># 新记录id为1001（下一个自增值）</span><br><span class="line">select * from t7;</span><br><span class="line">+------+--------+</span><br><span class="line">| id   | name   |</span><br><span class="line">+------+--------+</span><br><span class="line">|    1 | 张三   |</span><br><span class="line">|    3 | 王五   |</span><br><span class="line">| 1000 | 老李   |</span><br><span class="line">| 1001 | 老王   |</span><br><span class="line">+------+--------+</span><br></pre></td></tr></table></figure><h2 id="8-唯一键（UNIQUE）"><a href="#8-唯一键（UNIQUE）" class="headerlink" title="8. 唯一键（UNIQUE）"></a>8. 唯一键（UNIQUE）</h2><h3 id="1-唯一键介绍"><a href="#1-唯一键介绍" class="headerlink" title="1. 唯一键介绍"></a>1. 唯一键介绍</h3><p><strong><code>UNIQUE KEY</code> 用于保证字段值不重复，与主键类似，但区别是：唯一键 可以为空（NULL）、一张表可以有多个唯一键。</strong></p><h3 id="2-语法格式-6"><a href="#2-语法格式-6" class="headerlink" title="2. 语法格式"></a>2. 语法格式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">列名 数据类型 UNIQUE</span><br><span class="line"># 或单独添加：</span><br><span class="line">ALTER TABLE 表名 ADD UNIQUE (列名);</span><br></pre></td></tr></table></figure><table><thead><tr><th>操作</th><th>通用语法</th><th>示例</th></tr></thead><tbody><tr><td>删除唯一键</td><td><code>ALTER TABLE 表名 DROP INDEX 索引名;</code></td><td><code>ALTER TABLE t8 DROP INDEX user;</code></td></tr><tr><td>添加唯一键</td><td><code>ALTER TABLE 表名 ADD UNIQUE (列名);</code></td><td><code>ALTER TABLE t8 ADD UNIQUE (user);</code></td></tr><tr><td>添加唯一键（自定义名）</td><td><code>ALTER TABLE 表名 ADD CONSTRAINT 索引名 UNIQUE (列名);</code></td><td><code>ALTER TABLE t8 ADD CONSTRAINT un_user UNIQUE (user);</code></td></tr></tbody></table><h3 id="3-基本使用-6"><a href="#3-基本使用-6" class="headerlink" title="3. 基本使用"></a>3. 基本使用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"># 建t8表，给user和email加unique（唯一约束）：两字段值都不能重复</span><br><span class="line">create table t8(</span><br><span class="line">    user varchar(20) unique,</span><br><span class="line">    email varchar(20) unique);</span><br><span class="line"></span><br><span class="line"># 正确插入：user=minbit、email=abc.com（均为新值，符合唯一约束）</span><br><span class="line">insert into t8 values(&#x27;minbit&#x27;,&#x27;abc.com&#x27;);</span><br><span class="line"></span><br><span class="line"># 插入重复值：user和email都和已有记录重复，触发user字段唯一约束报错</span><br><span class="line">insert into t8 values(&#x27;minbit&#x27;,&#x27;abc.com&#x27;);</span><br><span class="line">ERROR 1062 (23000): Duplicate entry &#x27;minbit&#x27; for key &#x27;t8.user&#x27;</span><br><span class="line"></span><br><span class="line"># 插入重复user：仅user重复，仍触发唯一约束报错</span><br><span class="line">insert into t8 values(&#x27;minbit&#x27;,&#x27;123.com&#x27;);</span><br><span class="line">ERROR 1062 (23000): Duplicate entry &#x27;minbit&#x27; for key &#x27;t8.user&#x27;</span><br><span class="line"></span><br><span class="line"># 插入新user和新email：均为新值，成功</span><br><span class="line">insert into t8 values(&#x27;tim&#x27;,&#x27;123.com&#x27;);</span><br><span class="line"></span><br><span class="line"># 插入重复email：email=123.com已存在，触发email字段唯一约束报错</span><br><span class="line">insert into t8 values(&#x27;sam&#x27;,&#x27;123.com&#x27;);</span><br><span class="line">ERROR 1062 (23000): Duplicate entry &#x27;123.com&#x27; for key &#x27;t8.email&#x27;</span><br><span class="line"></span><br><span class="line"># 插入null值：unique约束允许null（null不视为重复），成功</span><br><span class="line">insert into t8 values(null,null);</span><br><span class="line"></span><br><span class="line"># 再插入null值：仍允许（null不比较重复），成功</span><br><span class="line">insert into t8 values(null,null);</span><br><span class="line"></span><br><span class="line"># 查询结果：有重复null，但非null值均唯一</span><br><span class="line">select * from t8;</span><br><span class="line">+--------+---------+</span><br><span class="line">| user   | email   |</span><br><span class="line">+--------+---------+</span><br><span class="line">| minbit | abc.com |  # 首次插入的非null记录</span><br><span class="line">| tim    | 123.com |  # 第二次插入的非null记录</span><br><span class="line">| NULL   | NULL    |  # 允许null</span><br><span class="line">| NULL   | NULL    |  # 允许重复null</span><br><span class="line">+--------+---------+</span><br></pre></td></tr></table></figure><blockquote><p>如果多列组成唯一组合，可写：<code>alter table users add unique (user, email);</code>，表示 <code>user + email</code> 组合唯一，但单独字段可重复。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"># 查看t8表的索引信息（\G垂直显示更清晰）</span><br><span class="line">mysql&gt; show index from t8\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">        Table: t8</span><br><span class="line">   Non_unique: 0 # 唯一索引（对应email的unique约束）</span><br><span class="line">     Key_name: user  # 索引名（和字段名一致）</span><br><span class="line"> Seq_in_index: 1  # 字段在索引中的位置（单字段索引为1）</span><br><span class="line">  Column_name: user  # 索引对应的字段</span><br><span class="line">    Collation: A</span><br><span class="line">  Cardinality: 3</span><br><span class="line">     Sub_part: NULL</span><br><span class="line">       Packed: NULL</span><br><span class="line">         Null: YES</span><br><span class="line">   Index_type: BTREE</span><br><span class="line">      Comment:</span><br><span class="line">Index_comment: </span><br><span class="line">      Visible: YES</span><br><span class="line">   Expression: NULL</span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">        Table: t8</span><br><span class="line">   Non_unique: 0  # 唯一索引（对应email的unique约束）</span><br><span class="line">     Key_name: email  # 索引名（和字段名一致）</span><br><span class="line"> Seq_in_index: 1  # 单字段索引，位置1</span><br><span class="line">  Column_name: email </span><br><span class="line">    Collation: A</span><br><span class="line">  Cardinality: 3</span><br><span class="line">     Sub_part: NULL </span><br><span class="line">       Packed: NULL</span><br><span class="line">         Null: YES</span><br><span class="line">   Index_type: BTREE</span><br><span class="line">      Comment: </span><br><span class="line">Index_comment: </span><br><span class="line">      Visible: YES </span><br><span class="line">   Expression: NULL</span><br><span class="line"></span><br><span class="line"># 删除t8表中名为user的索引（即删除user字段的unique约束）</span><br><span class="line">mysql&gt; alter table t8 drop index user;</span><br><span class="line"></span><br><span class="line"># 删除t8表中名为email的索引（即删除email字段的unique约束）</span><br><span class="line">mysql&gt; alter table t8 drop index email;</span><br><span class="line"></span><br><span class="line"># 再次查看t8表索引：已无索引（unique约束已删除）</span><br><span class="line">mysql&gt; show index from t8\G</span><br><span class="line">Empty set (0.00 sec)</span><br><span class="line"></span><br><span class="line"># 给t8表的user字段重新添加unique约束（自动创建同名索引）</span><br><span class="line">mysql&gt; alter table t8 add unique (user);</span><br><span class="line"></span><br><span class="line"># 给t8表的email字段重新添加unique约束（自动创建同名索引）</span><br><span class="line">mysql&gt; ALTER TABLE t8 ADD UNIQUE (email);</span><br><span class="line"></span><br><span class="line"># 查看索引：user和email的唯一索引已恢复</span><br><span class="line">mysql&gt; show index from t8\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">        Table: t8</span><br><span class="line">   Non_unique: 0</span><br><span class="line">     Key_name: user  # 索引名（和字段名一致）</span><br><span class="line"> Seq_in_index: 1  # 字段在索引中的位置（单字段索引为1）</span><br><span class="line">  Column_name: user  # 索引对应的字段</span><br><span class="line">    Collation: A</span><br><span class="line">  Cardinality: 3</span><br><span class="line">     Sub_part: NULL</span><br><span class="line">       Packed: NULL</span><br><span class="line">         Null: YES</span><br><span class="line">   Index_type: BTREE</span><br><span class="line">      Comment:</span><br><span class="line">Index_comment: </span><br><span class="line">      Visible: YES</span><br><span class="line">   Expression: NULL</span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">        Table: t8 </span><br><span class="line">   Non_unique: 0  # 唯一索引（对应email的unique约束）</span><br><span class="line">     Key_name: email  # 索引名（和字段名一致）</span><br><span class="line"> Seq_in_index: 1  # 单字段索引，位置1</span><br><span class="line">  Column_name: email </span><br><span class="line">    Collation: A</span><br><span class="line">  Cardinality: 3</span><br><span class="line">     Sub_part: NULL </span><br><span class="line">       Packed: NULL</span><br><span class="line">         Null: YES</span><br><span class="line">   Index_type: BTREE</span><br><span class="line">      Comment: </span><br><span class="line">Index_comment: </span><br><span class="line">      Visible: YES </span><br><span class="line">   Expression: NULL</span><br></pre></td></tr></table></figure><h2 id="9-外键（FOREIGN-KEY）"><a href="#9-外键（FOREIGN-KEY）" class="headerlink" title="9. 外键（FOREIGN KEY）"></a>9. 外键（FOREIGN KEY）</h2><h3 id="1-外键介绍"><a href="#1-外键介绍" class="headerlink" title="1. 外键介绍"></a>1. 外键介绍</h3><p>外键用于 <strong>建立两张表之间的关联关系</strong>，保证数据一致性，通常表示“一张表的数据依赖另一张表”。</p><p>例如：</p><ul><li>学生表（students）依赖班级表（classes）的班级号；</li><li>删除班级时，相关学生数据不能孤立。</li></ul><h3 id="2-语法格式-7"><a href="#2-语法格式-7" class="headerlink" title="2. 语法格式"></a>2. 语法格式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[CONSTRAINT 外键名]</span><br><span class="line">FOREIGN KEY (当前表字段)</span><br><span class="line">REFERENCES 被关联表(被关联字段)</span><br><span class="line">[ON DELETE 操作] [ON UPDATE 操作];</span><br></pre></td></tr></table></figure><p><strong>外键级联规则说明：</strong></p><table><thead><tr><th>操作</th><th>含义</th></tr></thead><tbody><tr><td><code>ON DELETE CASCADE</code></td><td>删除父表记录 → 自动删除子表对应记录</td></tr><tr><td><code>ON UPDATE CASCADE</code></td><td>更新父表主键 → 自动更新子表对应外键</td></tr><tr><td><code>ON DELETE SET NULL</code></td><td>删除父表记录 → 子表字段设为 NULL</td></tr><tr><td><code>ON DELETE RESTRICT</code></td><td>删除父表记录 → 若子表存在关联数据则拒绝删除（默认）</td></tr></tbody></table><p><strong>外键注意事项：</strong></p><ol><li>外键字段必须与被引用字段类型相同。</li><li>外键列和被引用列必须使用相同的存储引擎（InnoDB）。</li><li>被引用的列必须是主键或唯一键。</li><li>外键会影响删除、更新操作性能，不建议在高并发系统中过度使用。</li></ol><h3 id="3-基本使用-7"><a href="#3-基本使用-7" class="headerlink" title="3. 基本使用"></a>3. 基本使用</h3><p><strong>创建时定义外键：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 含义：students.class_id 必须对应 classes.id 中已有的值，不能插入不存在的班级号</span><br><span class="line">create table classes (</span><br><span class="line">    id int primary key,</span><br><span class="line">    name varchar(50)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">create table students (</span><br><span class="line">    id int primary key,</span><br><span class="line">    name varchar(50),</span><br><span class="line">    class_id int,</span><br><span class="line">    foreign key (class_id) references classes(id)   # 建立外键关联</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><strong>表创建后添加外键：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alter table students</span><br><span class="line">add constraint fk_class</span><br><span class="line">foreign key (class_id) references classes(id);</span><br></pre></td></tr></table></figure><p><strong>删除外键：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table students drop foreign key fk_class;</span><br></pre></td></tr></table></figure><p><strong>设置级联操作（ON DELETE &#x2F; ON UPDATE）：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">create table students (</span><br><span class="line">    id int primary key,</span><br><span class="line">    name varchar(50),</span><br><span class="line">    class_id int,</span><br><span class="line">    foreign key (class_id)</span><br><span class="line">    references classes(id)</span><br><span class="line">    on delete cascade       # 删除班级时自动删除相关学生</span><br><span class="line">    on update cascade       # 修改班级id时自动同步学生表</span><br><span class="line">);</span><br></pre></td></tr></table></figure><table><thead><tr><th>特性</th><th><strong>主键（PRIMARY KEY）</strong></th><th><strong>唯一键（UNIQUE KEY）</strong></th><th><strong>外键（FOREIGN KEY）</strong></th></tr></thead><tbody><tr><td>是否唯一</td><td>✅ 是</td><td>✅ 是</td><td>❌ 否（用于关联）</td></tr><tr><td>是否可空</td><td>❌ 否</td><td>✅ 可为空</td><td>✅ 可为空</td></tr><tr><td>可否多个</td><td>❌ 只能一个</td><td>✅ 可多个</td><td>✅ 可多个</td></tr><tr><td>用途</td><td>唯一标识行</td><td>保证字段唯一</td><td>建立表间关系</td></tr><tr><td>是否自动索引</td><td>✅ 自动创建</td><td>✅ 自动创建</td><td>❌ 不自动创建</td></tr><tr><td>依赖其他表</td><td>❌ 否</td><td>❌ 否</td><td>✅ 是</td></tr></tbody></table><h2 id="10-小结"><a href="#10-小结" class="headerlink" title="10. 小结"></a>10. 小结</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">create table t9 (</span><br><span class="line">    id int primary key auto_increment comment &#x27;学生编号，主键且自动增长&#x27;,  # 主键 + 自增 + 注释</span><br><span class="line">    name varchar(30) not null comment &#x27;学生姓名，不能为空&#x27;,               # 非空约束</span><br><span class="line">    gender char(1) default &#x27;男&#x27; comment &#x27;性别，默认值为男&#x27;,              # 默认值</span><br><span class="line">    age tinyint unsigned default 18 comment &#x27;年龄，默认18岁&#x27;,            # 默认值 + 无符号</span><br><span class="line">    student_no char(10) unique comment &#x27;学号，唯一&#x27;,                     # 唯一约束</span><br><span class="line">    class_id int comment &#x27;班级编号，对应班级表id&#x27;,                       # 外键列</span><br><span class="line">    score decimal(5,2) zerofill comment &#x27;成绩，补零显示，最大999.99&#x27;,    # 补零效果（仅显示）</span><br><span class="line">    enroll_date date default (current_date) comment &#x27;入学日期，默认当天&#x27;, # 默认值为当前日期</span><br><span class="line">    foreign key (class_id) references classes(id)                        # 外键约束</span><br><span class="line">        on delete set null                                                # 删除班级后学生class_id置空</span><br><span class="line">        on update cascade                                                 # 更新班级id后同步更新</span><br><span class="line">) comment=&#x27;学生信息表&#x27;;</span><br></pre></td></tr></table></figure><table><thead><tr><th align="left">约束类型</th><th>作用</th><th>是否可为空</th><th align="left">是否唯一</th><th>可否多个</th><th>常见定义方式</th><th>常见用途与说明</th></tr></thead><tbody><tr><td align="left"><strong>NOT NULL</strong></td><td>限制字段不能为空</td><td>❌ 否</td><td align="left">❌ 否</td><td>✅ 可多个</td><td><code>age INT NOT NULL</code></td><td>防止出现空值，保证字段必须有内容</td></tr><tr><td align="left"><strong>DEFAULT</strong></td><td>指定默认值</td><td>✅ 可为空（若未定义）</td><td align="left">❌ 否</td><td>✅ 可多个</td><td><code>age INT DEFAULT 18</code></td><td>插入数据未指定该字段时自动填入默认值</td></tr><tr><td align="left"><strong>COMMENT</strong></td><td>添加列或表的注释说明</td><td>✅ 可为空</td><td align="left">❌ 否</td><td>✅ 可多个</td><td><code>name VARCHAR(20) COMMENT &#39;学生姓名&#39;</code></td><td>提示说明作用，不影响功能</td></tr><tr><td align="left"><strong>ZEROFILL</strong></td><td>数字显示前自动补零</td><td>✅ 可为空</td><td align="left">❌ 否</td><td>✅ 可多个</td><td><code>id INT(5) ZEROFILL</code></td><td>仅影响显示效果，新版已弃用（推荐 <code>LPAD()</code>）</td></tr><tr><td align="left"><strong>PRIMARY KEY</strong></td><td>主键，唯一标识表中每行数据</td><td>❌ 否</td><td align="left">✅ 是</td><td>❌ 仅一个</td><td><code>id INT PRIMARY KEY</code> &#x2F; <code>ALTER TABLE ... ADD PRIMARY KEY(id)</code></td><td>强制唯一且非空，可配合 <code>AUTO_INCREMENT</code> 使用</td></tr><tr><td align="left"><strong>AUTO_INCREMENT</strong></td><td>自动增长字段</td><td>❌ 否</td><td align="left">✅ 是</td><td>❌ 仅一个</td><td><code>id INT PRIMARY KEY AUTO_INCREMENT</code></td><td>通常与主键一起使用，自动编号</td></tr><tr><td align="left"><strong>UNIQUE KEY</strong></td><td>唯一约束，防止重复</td><td>✅ 可为空</td><td align="left">✅ 是</td><td>✅ 可多个</td><td><code>email VARCHAR(50) UNIQUE</code> &#x2F; <code>ALTER TABLE ... ADD UNIQUE(email)</code></td><td>保证字段值唯一，可有多个 NULL</td></tr><tr><td align="left"><strong>FOREIGN KEY</strong></td><td>外键约束，建立表与表之间的关系</td><td>✅ 可为空</td><td align="left">❌ 否</td><td>✅ 可多个</td><td><code>FOREIGN KEY(class_id) REFERENCES classes(id)</code></td><td>保证数据一致性，可配合 <code>ON DELETE</code>、<code>ON UPDATE</code> 实现级联操作</td></tr></tbody></table>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;表的约束&quot;&gt;&lt;a href=&quot;#表的约束&quot; class=&quot;headerlink&quot; title=&quot;表的约束&quot;&gt;&lt;/a&gt;表的约束&lt;/h1&gt;&lt;h2 id=&quot;1-什么是表的约束？&quot;&gt;&lt;a href=&quot;#1-什么是表的约束？&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    <category term="MySQL" scheme="https://www.minbit.top/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="https://www.minbit.top/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>回调函数</title>
    <link href="https://www.minbit.top/posts/45103.html"/>
    <id>https://www.minbit.top/posts/45103.html</id>
    <published>2025-10-29T08:40:00.000Z</published>
    <updated>2025-10-29T08:40:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h1><blockquote><p><a href="https://www.bilibili.com/video/BV1cW421N7P2/?share_source=copy_web&vd_source=872e5e3ccf44874c39edaf42e30ab0de">3 分钟彻底理解回调函数 | B 站</a></p><p><a href="https://www.bilibili.com/video/BV1NA4m1A7qr/?share_source=copy_web&vd_source=872e5e3ccf44874c39edaf42e30ab0de">3 分钟搞懂回调函数 每个开发者都具备的基础能力 | B 站</a></p><p><a href="https://www.bilibili.com/video/BV1vL411t78b/?share_source=copy_web&vd_source=872e5e3ccf44874c39edaf42e30ab0de">『教程』回调函数是个啥？ | B 站</a></p></blockquote><h2 id="1-认识回调函数？"><a href="#1-认识回调函数？" class="headerlink" title="1. 认识回调函数？"></a>1. 认识回调函数？</h2><h3 id="1-什么是回调函数？"><a href="#1-什么是回调函数？" class="headerlink" title="1. 什么是回调函数？"></a>1. 什么是回调函数？</h3><p>回调函数（Callback Function）是 <strong>函数指针的一种应用形式</strong>，它的核心思想是：<strong>“把函数作为参数传给另一个函数，由那个函数在合适的时机再调用它。”</strong> 通常用于 <strong>“别人调用你自己的函数”</strong>，你把函数地址传给某个函数，等它内部逻辑执行到某个阶段时，再“反过来”调用你传入的函数。换句话说：</p><ul><li><strong>你写函数 A</strong>（定义了“要做什么”）。</li><li><strong>别人写函数 B</strong>（控制“什么时候做”）。</li><li>你把 A 的函数地址交给 B，B 内部“回头”去调用 A。这就是“回调”。</li></ul><p><strong>如果你还是不理解，那么我先在这里埋一个伏笔：对于我来说，回调函数虽然从英文翻译过来回调不太好理解，但是用过函数传参就能直接上手回调函数，它的用法就是将函数作为参数进行传递，传到对方函数中，类比变量一样被调用，这！就是回调函数，还是很好理解吧，后面来几个示例就能深入理解和上手啦。</strong></p><h3 id="2-使用场景"><a href="#2-使用场景" class="headerlink" title="2. 使用场景"></a>2. 使用场景</h3><p>回调函数常用于以下几种情况：</p><ol><li><strong>事件驱动</strong>：如网络库 muduo 等库中，收到数据时触发回调函数。</li><li><strong>异步编程</strong>：任务完成后调用回调报告结果。</li><li><strong>通用算法</strong>：如 <code>qsort()</code> 让用户自定义排序比较规则。</li><li><strong>钩子机制</strong>：插件式扩展、信号槽系统。</li></ol><table><thead><tr><th>场景示例</th><th>回调的含义</th></tr></thead><tbody><tr><td>GUI 按钮点击事件</td><td>用户点击按钮后，系统调用你的“回调函数”处理事件</td></tr><tr><td>网络 I&#x2F;O</td><td>有数据到达时，框架调用注册好的“onMessage”函数</td></tr><tr><td>排序算法</td><td>排序逻辑由库提供，比较规则由你提供的“比较回调函数”定义</td></tr></tbody></table><p>当然，回调函数的使用场景远不止于此！</p><h2 id="2-回调函数的使用"><a href="#2-回调函数的使用" class="headerlink" title="2. 回调函数的使用"></a>2. 回调函数的使用</h2><h3 id="1-函数指针定义"><a href="#1-函数指针定义" class="headerlink" title="1. 函数指针定义"></a>1. 函数指针定义</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">返回类型 (*函数指针名)(参数列表);</span><br><span class="line"><span class="comment">// 注意：函数名 ≠ 函数指针，但是实际使用中，直接传递函数名会自动退化为函数指针（等价于 &amp;函数名），所以有：</span></span><br><span class="line">返回类型 (函数名)(参数列表);</span><br></pre></td></tr></table></figure><h3 id="2-基本使用（C-风格）"><a href="#2-基本使用（C-风格）" class="headerlink" title="2. 基本使用（C 风格）"></a>2. 基本使用（C 风格）</h3><h4 id="1-代码示例-1"><a href="#1-代码示例-1" class="headerlink" title="1. 代码示例 1"></a>1. 代码示例 1</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无参无值的回调函数：</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无参无值的回调函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Hello, world!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(<span class="type">int</span> x, <span class="type">void</span> (*callback)())</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; x; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">callback</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">test</span>(<span class="number">3</span>, print);</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">//Hello, world!</span></span><br><span class="line"><span class="comment">//Hello, world!</span></span><br><span class="line"><span class="comment">//Hello, world!</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个代码中，<code>print</code> 函数就是回调函数，它被当作参数在 <code>test</code> 函数中进行传递，注意传参的写法：<code>返回值 (*函数指针)(参数列表)</code>，只是这里无参无返回值，然后回调函数 <code>print</code> 在 for 循环中的 <code>callback();</code> 被调用。</p><h4 id="2-代码示例-2"><a href="#2-代码示例-2" class="headerlink" title="2. 代码示例 2"></a>2. 代码示例 2</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有参有返回值的回调函数（add、sub、mul、divi 都是回调函数）</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sub</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mul</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">divi</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (b == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;除 0 错误！&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> a / b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">calculate</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> (*callback)(<span class="type">int</span> x, <span class="type">int</span> y))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;开始计算&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;和&quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot;的运算结果:&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;结果为：&quot;</span> &lt;&lt; <span class="built_in">callback</span>(a, b) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">calculate</span>(<span class="number">10</span>, <span class="number">5</span>, add);</span><br><span class="line"><span class="built_in">calculate</span>(<span class="number">10</span>, <span class="number">5</span>, sub);</span><br><span class="line"><span class="built_in">calculate</span>(<span class="number">10</span>, <span class="number">5</span>, mul);</span><br><span class="line"><span class="built_in">calculate</span>(<span class="number">10</span>, <span class="number">5</span>, divi);</span><br><span class="line"><span class="built_in">calculate</span>(<span class="number">10</span>, <span class="number">0</span>, divi);</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//开始计算10和5的运算结果:</span></span><br><span class="line"><span class="comment">//结果为：15</span></span><br><span class="line"><span class="comment">//开始计算10和5的运算结果 :</span></span><br><span class="line"><span class="comment">//结果为：5</span></span><br><span class="line"><span class="comment">//开始计算10和5的运算结果 :</span></span><br><span class="line"><span class="comment">//结果为：50</span></span><br><span class="line"><span class="comment">//开始计算10和5的运算结果 :</span></span><br><span class="line"><span class="comment">//结果为：2</span></span><br><span class="line"><span class="comment">//开始计算10和0的运算结果 :</span></span><br><span class="line"><span class="comment">//除 0 错误！</span></span><br><span class="line"><span class="comment">//结果为： - 1</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个代码中，加减乘除 4 个函数都是回调函数，在 <code>calculate</code> 函数中当作参数进行传递，注意此时传参写法：<code>int (*callback)(int x, int y)</code>，指明了返回值、函数指针及其参数，由 <code>callback(a, b)</code> 执行回调逻辑，即每个回调函数自己内部的代码逻辑。</p><blockquote><p><strong>上面的代码虽然简单，但是也差不多能看出来回调函数用处的强大，回调函数有着很多高级用法，本文暂不涉及，用的多了，和其他语法、库、容器等搭配使用才能领略回调的强大！</strong></p></blockquote><h3 id="3-取别名"><a href="#3-取别名" class="headerlink" title="3. 取别名"></a>3. 取别名</h3><p>不知道大家初看上面的代码感觉咋样，反正我觉得不那么好看&#x2F;好辩认，所以通常会用到取别名，回调函数取别名的方法主要用 <code>typede</code> 和 <code>using</code>（C++11 及其往后），先介绍一下 <strong><code>typedef</code> 和回调函数搭配的语法：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> 返回值类型 (*类型名)(参数列表);</span><br><span class="line"><span class="comment">// typedef 旧名字 新名字// 适用简单类型（也是常见用法）</span></span><br></pre></td></tr></table></figure><h4 id="1-typedef-为回调函数取别名"><a href="#1-typedef-为回调函数取别名" class="headerlink" title="1. typedef 为回调函数取别名"></a>1. <code>typedef</code> 为回调函数取别名</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 定义一个函数指针类型：返回 string，参数 (int, string)</span></span><br><span class="line"><span class="comment">// 格式：typedef 返回值类型 (*类型名)(参数列表)</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">string</span><span class="params">(*callback)</span><span class="params">(<span class="type">int</span>, string)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 回调函数：把字符串 s 拼接 x 次</span></span><br><span class="line"><span class="function">string <span class="title">append</span><span class="params">(<span class="type">int</span> x, string s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; x; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        res += s;    <span class="comment">// 拼接 x 次</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试函数：接收字符串 + 回调函数 + 次数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(string s, <span class="type">int</span> x, callback cb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string ret = s + <span class="built_in">cb</span>(x, <span class="string">&quot;World&quot;</span>);<span class="comment">// 调用回调函数，得到拼接结果</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test</span>(<span class="string">&quot;Hello&quot;</span>, <span class="number">3</span>, append);</span><br><span class="line">    <span class="comment">// 输出：HelloWorldWorldWorld</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是初学者可能会对这个 <code>typedef</code> 的用法比较疑惑，没关系，我来解答：<code>typedef</code> 的语法本质是 “<strong>先写一个该类型的变量声明，再把变量名换成新类型名</strong>”。<strong><code>typedef 旧名字 新名字</code></strong> 这种用法应该比较常见的，但这种用法仅只适用于 <strong>简单类型</strong>（比如 <code>typedef int MyInt;</code>），但对于 <strong>复杂类型</strong>，比如指针、数组、函数指针就会存在一点区别：</p><ol><li><strong>简单类型：</strong> 想给 <code>int</code> 起个别名 <code>MyInt</code> 会用到 <code>typedef int MyInt</code>，此时 <code>MyInt</code> 是 <code>int</code> 的别名。</li><li><strong>指针类型：</strong> 想给 <code>int</code> 起个别名 <code>IntPtr</code> 会用到 <code>typedef int* IntPtr</code>，此时 <code>IntPtr</code> 是 <code>int</code> 的别名。</li><li><strong>函数指针类型：</strong> 想给 <strong>指向 <code>void (int)</code> 函数的指针</strong> 起个别名 <code>callback</code>： 先写 <strong>定义一个这种指针的变量 cb</strong>：<code>void (*cb)(int);</code>，这里的 cb 是一个指针，指向 <strong>参数为 int、返回 void 的函数</strong>，加 typedef，把变量名 cb 换成新类型名 callback 就得到了 <code>typedef void (* callback)(int); </code>，此时 <code>callback</code> 是 <code>void (*)(int)</code> 这个函数指针类型的别名。</li><li>……（更多复杂类型）</li></ol><p><strong><code>void (*callback)(int)</code> 它表示：<code>callback</code> 是一个 指向函数的指针，该函数 返回类型为 void，并且 参数列表为 (int)。可以用自然语言读成：callback 是一个指向接受一个 int 参数、返回 void 的函数的指针。所以，当你再次遇到它样子变种时，知道怎么看了吧。</strong></p><blockquote><p><strong>注意括号的作用：</strong> <code>void *callback(int)</code> 是完全不同的意思（它表示“返回 <code>void*</code> 的函数”），只有加括号 <code>void (*callback)(int)</code> 才表示“<strong>指向函数的指针</strong>”！</p></blockquote><h4 id="2-using-为回调函数取别名"><a href="#2-using-为回调函数取别名" class="headerlink" title="2. using 为回调函数取别名"></a>2. <code>using</code> 为回调函数取别名</h4><p><strong>语法格式（C++11 及其以后）：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> 别名 = 返回值类型 (*)(参数列表);</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 定义一个函数指针类型：返回 string，参数 (int, string)</span></span><br><span class="line"><span class="comment">// 格式：using 别名 = 返回值类型 (*)(参数列表);</span></span><br><span class="line"><span class="keyword">using</span> callback = <span class="built_in">string</span> (*)(<span class="type">int</span>, string);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 回调函数：把字符串 s 拼接 x 次</span></span><br><span class="line"><span class="function">string <span class="title">append</span><span class="params">(<span class="type">int</span> x, string s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; x; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        res += s;    <span class="comment">// 拼接 x 次</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试函数：接收字符串 + 回调函数 + 次数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(string s, <span class="type">int</span> x, callback cb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string ret = s + <span class="built_in">cb</span>(x, <span class="string">&quot;World&quot;</span>);<span class="comment">// 调用回调函数，得到拼接结果</span></span><br><span class="line">    cout &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test</span>(<span class="string">&quot;Hello&quot;</span>, <span class="number">3</span>, append);</span><br><span class="line">    <span class="comment">// 输出：HelloWorldWorldWorld</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我觉得这里应该什么疑问吧，按照格式套就行。</p><h4 id="3-模板支持（为什么推荐使用-using？）"><a href="#3-模板支持（为什么推荐使用-using？）" class="headerlink" title="3. 模板支持（为什么推荐使用 using？）"></a>3. 模板支持（为什么推荐使用 <code>using</code>？）</h4><p>先来看看下面 2 个代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码1：</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//C++11 引入using后，支持直接将using与template结合，定义 “模板类型别名”，无需嵌套类，使用时也无需额外语法。</span></span><br><span class="line"><span class="comment">//实现步骤：</span></span><br><span class="line"><span class="comment">//直接用 “template &lt;模板参数&gt; using 别名 = 目标类型” 的语法，一步定义模板化的类型别名。</span></span><br><span class="line"><span class="comment">//使用时，直接用 “别名&lt;具体类型&gt;” 调用，和普通类型别名的使用逻辑一致。</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> callback = <span class="built_in">void</span> (*)(T);  <span class="comment">// 模板化回调类型</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printI</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Int: &quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printS</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;String: &quot;</span> &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printD</span><span class="params">(<span class="type">double</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Double: &quot;</span> &lt;&lt; d &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 多种写法：</span></span><br><span class="line">callback&lt;<span class="type">int</span>&gt; intCb = printI;</span><br><span class="line"><span class="function">callback&lt;string&gt; <span class="title">strCb</span><span class="params">(printS)</span></span>;         <span class="comment">// 用构造方式初始化（函数指针的初始化）</span></span><br><span class="line">callback&lt;<span class="type">double</span>&gt; doubleCb = &amp;printD;    <span class="comment">// 与原写法等价，&amp;可省略</span></span><br><span class="line"><span class="comment">// auto ……也可以</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">intCb</span>(<span class="number">100</span>);         <span class="comment">// 输出：Int: 100</span></span><br><span class="line">(*strCb)(<span class="string">&quot;test&quot;</span>);   <span class="comment">// 输出：String: test</span></span><br><span class="line"><span class="built_in">doubleCb</span>(<span class="number">3.14</span>);     <span class="comment">// 输出：Double: 3.14</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 代码2：</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//typedef本身不能直接跟模板参数结合，但可以把它放在一个类模板内部，通过类模板的参数间接实现 “模板化的类型别名”。</span></span><br><span class="line"><span class="comment">//实现步骤：</span></span><br><span class="line"><span class="comment">//定义一个类模板，在类内部用typedef定义目标类型别名。</span></span><br><span class="line"><span class="comment">//使用时，必须通过 “类模板名&lt;具体类型&gt;::type” 的语法调用，不能直接用类模板名简化。</span></span><br><span class="line"><span class="comment">// 用类模板嵌套 typedef 实现模板化回调类型（间接支持模板）</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">callback</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*Type)</span><span class="params">(T)</span></span>;        <span class="comment">// 在类内部用 typedef 定义函数指针类型</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printI</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Int: &quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printS</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;String: &quot;</span> &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printD</span><span class="params">(<span class="type">double</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Double: &quot;</span> &lt;&lt; d &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 必须通过 &quot;类模板名&lt;类型&gt;::Type&quot; 访问 typedef 定义的类型</span></span><br><span class="line">callback&lt;<span class="type">int</span>&gt;::Type intCb = printI;</span><br><span class="line">callback&lt;string&gt;::<span class="function">Type <span class="title">strCb</span><span class="params">(printS)</span></span>;  <span class="comment">// 构造方式初始化</span></span><br><span class="line">callback&lt;<span class="type">double</span>&gt;::Type doubleCb = &amp;printD;  <span class="comment">// &amp; 可省略</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">intCb</span>(<span class="number">100</span>);         <span class="comment">// 输出：Int: 100</span></span><br><span class="line">(*strCb)(<span class="string">&quot;test&quot;</span>);   <span class="comment">// 输出：String: test</span></span><br><span class="line"><span class="built_in">doubleCb</span>(<span class="number">3.14</span>);     <span class="comment">// 输出：Double: 3.14</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 观察上面2段代码：</span></span><br><span class="line"><span class="comment">// typedef 对模板支持较弱，需要依赖类模板嵌套，使用繁琐。</span></span><br><span class="line"><span class="comment">// using是 C++11 为解决这个问题设计的方案，能直接定义模板类型别名，在模板场景下（包括模板化回调函数）完全优于typedef。</span></span><br><span class="line"><span class="comment">// 实际开发中，只要环境支持 C++11 及以上，涉及模板化的类型别名（如通用回调、容器别名），都应该优先用using。</span></span><br></pre></td></tr></table></figure><p>相信看完上面的代码，在回调函数和模板同时存在时，你再也不想用 <code>typedef</code> 了，还是 <code>using</code> 来的香，当遇到更复杂的场景，你第一个想到的是 <code>typedef</code> 还是 <code>using</code> 呢？言归正传，即使在非回调函数的场景中，<strong>我们始终推荐使用 <code>using</code>！</strong></p><h3 id="4-std-function-——-通用的函数包装器"><a href="#4-std-function-——-通用的函数包装器" class="headerlink" title="4. std::function —— 通用的函数包装器"></a>4. <code>std::function</code> —— 通用的函数包装器</h3><p>C++11 及以后标准中，用 <code>std::function</code>、<code>std::bind</code>、Lambda 等来封装、传递和调用回调函数。<strong>注意：它能存储：普通函数、Lambda 表达式、成员函数、仿函数对象等，它让“函数”也能像普通变量一样传来传去，用于回调最方便，这一点在后面会遇到。</strong></p><h4 id="1-基本语法结构"><a href="#1-基本语法结构" class="headerlink" title="1. 基本语法结构"></a>1. 基本语法结构</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line">std::function&lt;返回类型(参数类型列表)&gt; 变量名;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; cb;   <span class="comment">// 可以存储任何“接收int、返回void”的可调用对象</span></span><br></pre></td></tr></table></figure><h4 id="2-代码示例-1（入门）"><a href="#2-代码示例-1（入门）" class="headerlink" title="2. 代码示例 1（入门）"></a>2. 代码示例 1（入门）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Hello, World!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test1</span><span class="params">(<span class="type">int</span> n, function&lt;<span class="type">void</span>()&gt; callback)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">callback</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print2</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test2</span><span class="params">(<span class="type">int</span> n, function&lt;<span class="type">void</span>(string)&gt; callback)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">callback</span>(<span class="string">&quot;hello, callback!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test3</span><span class="params">(<span class="type">int</span> n, function&lt;<span class="type">void</span>(string)&gt; callback)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">stringstream ss;</span><br><span class="line">ss &lt;&lt; <span class="string">&quot;这是第 &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; 次调用&quot;</span>;</span><br><span class="line"><span class="built_in">callback</span>(ss.<span class="built_in">str</span>());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">test1</span>(<span class="number">3</span>, print1);</span><br><span class="line"><span class="built_in">test2</span>(<span class="number">3</span>, print2);</span><br><span class="line"><span class="built_in">test3</span>(<span class="number">3</span>, print2);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果上面传统 C 风格的回调函数会用了，那么这里了解完 <code>std::function</code> 的语法格式，代码其实很浅显易懂了，锻炼一下不要注释能不能理解，真不是我懒得不想写注释 🤪。</p><h4 id="3-代码示例-2（进阶）"><a href="#3-代码示例-2（进阶）" class="headerlink" title="3. 代码示例 2（进阶）"></a>3. 代码示例 2（进阶）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例1：</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;普通函数: &quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(<span class="type">int</span> n, function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; cb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cb</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test</span>(<span class="number">3</span>, print);   <span class="comment">// 直接传函数名</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例2：</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 语法格式：using 别名 = std::function&lt;返回值类型(参数类型...)&gt;;</span></span><br><span class="line"><span class="keyword">using</span> <span class="type">func_t</span> = function&lt;<span class="built_in">void</span>(<span class="type">int</span>)&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(<span class="type">int</span> n, <span class="type">func_t</span> cb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cb</span>(i);   <span class="comment">// 调用回调函数，这个 i 会传递给 lambda 表达式，即下面的 int x 部分</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 理解：将 lambda 表达式作为参数传递给 test 函数，test 函数将 lambda 表达式作为回调函数调用。</span></span><br><span class="line">    <span class="comment">// 可以理解为：这里的 lambda 表达式就是回调函数。</span></span><br><span class="line">    <span class="comment">// lambda 表达式拿到上面传过来的 i 值，然后输出。</span></span><br><span class="line">    <span class="built_in">test</span>(<span class="number">3</span>, [](<span class="type">int</span> x) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Lambda 回调: &quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例3：</span></span><br><span class="line"><span class="comment">// std::function 的本质是一个 “函数包装器”，可以存储任何可调用对象（函数、lambda、函数对象等）。</span></span><br><span class="line"><span class="comment">// 它内部会管理这些可调用对象的拷贝或引用，就像一个 “函数指针的升级版”，但更灵活。</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> Callback = function&lt;<span class="built_in">void</span>(<span class="type">int</span>)&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Server</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 注意：_onMessage 就像一个 “函数容器”（本身是 std::function 类型，专门用来存放函数），初始时这个容器是空的。</span></span><br><span class="line">    <span class="comment">// 可以理解成 _onMessage 是一个回调函数类型，初始是空的，不包含任何逻辑</span></span><br><span class="line">    Callback _onMessage;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set</span><span class="params">(Callback cb)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _onMessage = cb;    <span class="comment">// 这里就会将 lambda 表达式（的逻辑）拷贝给 _onMessage，从而拥有和下面lambda一样的效果</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">simulateMessage</span><span class="params">(<span class="type">int</span> data)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (_onMessage)     <span class="comment">// 初始_onMessage是空的，所以这里不会执行，后续拥有lambda一样的逻辑效果才会进入</span></span><br><span class="line">        &#123;</span><br><span class="line">            _onMessage(data);   <span class="comment">// 走到这里才会将传进来的42导向回调逻辑，即_onMessage（lambda的逻辑）</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Server s;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册回调</span></span><br><span class="line">    <span class="comment">// lambda[](int x) &#123; ... &#125; 本质上是一个 “匿名函数”，它有明确的参数（int x）和返回值（void），</span></span><br><span class="line">    <span class="comment">// 正好匹配 Callback 类型（function&lt;void(int)&gt;）。</span></span><br><span class="line">    <span class="comment">// set 方法调用时，这个 lambda 会被拷贝到 _onMessage 中（std::function 会负责存储这个拷贝）。</span></span><br><span class="line">    s.<span class="built_in">set</span>([](<span class="type">int</span> x) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;收到消息：&quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟事件触发</span></span><br><span class="line">    s.<span class="built_in">simulateMessage</span>(<span class="number">42</span>);  <span class="comment">// 当把42传给 _onMessage 时，_onMessage拥有和lambda一样的效果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就推荐以后直接用 <code>using</code> 了，<strong>和 <code>std::function</code> 搭配的语法格式：<code>using 别名 = std::function&lt;返回值类型(参数类型...)&gt;;</code> 需要注意一下。</strong> 示例 3 的代码可能需要细细品味一下……</p><h4 id="4-std-bind-和占位符的使用"><a href="#4-std-bind-和占位符的使用" class="headerlink" title="4. std::bind 和占位符的使用"></a>4. <code>std::bind</code> 和占位符的使用</h4><p><strong><code>std::bind</code> 的本质是：把一个函数和它的部分参数“提前绑定”起来，生成一个新的可调用对象，其语法结构是：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> 新函数 = <span class="built_in">bind</span>(函数地址, 参数<span class="number">1</span>, 参数<span class="number">2</span>, ...);</span><br><span class="line"><span class="comment">// placeholders::_1, placeholders::_2, placeholders::_3, …… 表示占位符，对应该函数未来的参数。</span></span><br><span class="line"><span class="comment">// 返回一个新的可调用对象，可以存到 std::function 里。</span></span><br></pre></td></tr></table></figure><p><strong>代码示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::placeholders;  <span class="comment">// 可打开命名空间简写，但通常不推荐，可读性差！</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> f = <span class="built_in">bind</span>(show, _1, <span class="number">100</span>);  <span class="comment">// _1 表示占位，将来会传给第1个参数</span></span><br><span class="line">    <span class="built_in">f</span>(<span class="number">10</span>);                         <span class="comment">// 等价于 show(10, 100)，输出：10 100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>占位符 <code>_1</code>、<code>_2</code> 的意义：<code>std::bind</code> 可以“延后传入”某些参数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = <span class="built_in">bind</span>(show, _2, _1);</span><br><span class="line"><span class="built_in">f</span>(<span class="number">10</span>, <span class="number">20</span>);  <span class="comment">// 会调用 show(20, 10)</span></span><br></pre></td></tr></table></figure><p>换句话说，<code>_1</code>, <code>_2</code> 只是告诉编译器：以后当我调用这个函数时，把第 1 个、2 个实参放到对应位置。这似乎很简单，没什么难的吧，下面要介绍 <strong>2 个注意点：<code>bind</code> 的本质是 “提前绑定部分参数，生成一个新的函数对象”，这个新函数对象的参数数量是固定的 —— 等于你在 <code>bind</code> 时使用的占位符个数 ，所以：<code>bind</code> 生成的函数对象必须在一次调用中补全所有未绑定的占位符，无法分多条语句逐个补充，只要有占位符未被赋值，就无法触发函数执行。</strong></p><ul><li><strong>只能用一条语句全部补充：</strong> 意思是 <code>bind</code> 中存在占位符导致参数“不完整”，后续 <strong>只能用一条语句全部补充完整</strong>！</li><li><strong>全部补充完毕才会执行回调&#x2F;只要有缺失就永远不会回调：</strong> 意思是只有当 <code>bind</code> 的参数真正完整的那一条语句才会执行回调函数，如果不完整，参数缺失（占位符没被填补），那么回调函数就永远不会生效、永远不会被调用！</li></ul><p>再来看一小段代码巩固一下吧：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//using namespace std::placeholders;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> f1 = <span class="built_in">bind</span>(show, std::placeholders::_1, <span class="number">20</span>, <span class="number">30</span>);            <span class="comment">// 绑定两个参数</span></span><br><span class="line">    <span class="built_in">f1</span>(<span class="number">10</span>);                                                         <span class="comment">// show(10,20,30)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> f2 = <span class="built_in">bind</span>(show, placeholders::_2, placeholders::_1, <span class="number">30</span>);   <span class="comment">// 绑定三个参数（注意这里的顺序！）</span></span><br><span class="line">    <span class="comment">// f2(10);  // 报错！</span></span><br><span class="line">    <span class="built_in">f2</span>(<span class="number">10</span>, <span class="number">20</span>);                                                     <span class="comment">// show(20,10,30)</span></span><br><span class="line">    <span class="comment">// 补充的顺序默认就是第一个，第二个，第三个...第一个参数会补充给placeholders::_1，第二个参数会补充给placeholders::_2，以此类推</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> f3 = <span class="built_in">bind</span>(show, <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>);       <span class="comment">// 没有占位符</span></span><br><span class="line">    <span class="built_in">f3</span>();                                   <span class="comment">// show(10,20,30)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-bind-的返回值是什么？"><a href="#5-bind-的返回值是什么？" class="headerlink" title="5. bind 的返回值是什么？"></a>5. bind 的返回值是什么？</h4><p><code>std::bind</code> 会返回一个 <strong>可调用对象</strong>，这个对象的类型是编译器自动生成的匿名类型（类似 lambda 表达式的类型），因此无法直接用具体的类型名声明（比如不能写成 <code>std::bind_type f = ...</code>）。</p><h5 id="1-万能-auto"><a href="#1-万能-auto" class="headerlink" title="1. 万能 auto"></a>1. 万能 <code>auto</code></h5><p><code>auto</code> 是个好东西，我不关心，直接就无脑 <code>auto</code> 就行了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> f = std::<span class="built_in">bind</span>(func, <span class="number">1</span>, std::placeholders::_1); </span><br><span class="line"><span class="comment">// f的类型是匿名的，只能用auto接收</span></span><br></pre></td></tr></table></figure><h5 id="2-显式指定类型的方法：用-std-function-包装"><a href="#2-显式指定类型的方法：用-std-function-包装" class="headerlink" title="2. 显式指定类型的方法：用 std::function 包装"></a>2. 显式指定类型的方法：用 <code>std::function</code> 包装</h5><p>虽然 <code>bind</code> 的返回值类型匿名，但可以根据 <strong>原函数的签名和绑定后的参数要求</strong>，用 <code>std::function</code> 显式指定类型。具体规则是：<strong><code>std::function</code> 的模板参数 &#x3D; 绑定后需要传入的参数类型 + 返回值类型</strong>。</p><p>示例 1：绑定后需要传入 1 个参数，返回值为 void。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 绑定规则：show的第1个参数固定为100，第2个参数由调用时传入（_1）</span></span><br><span class="line">    <span class="comment">// 绑定后，调用f时需要传入1个int，返回值为void → 对应function&lt;void(int)&gt;</span></span><br><span class="line">    function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; f = <span class="built_in">bind</span>(show, <span class="number">100</span>, placeholders::_1);</span><br><span class="line">    <span class="built_in">f</span>(<span class="number">200</span>); <span class="comment">// 等价于show(100, 200)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例 2：绑定后不需要传入参数，返回值为 int。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 绑定规则：a=10，b=20，调用时不需要传参，返回int → 对应function&lt;int()&gt;</span></span><br><span class="line">    function&lt;<span class="type">int</span>()&gt; f = <span class="built_in">bind</span>(add, <span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">    cout &lt;&lt; <span class="built_in">f</span>() &lt;&lt; endl; <span class="comment">// 等价于add(10, 20) → 输出30</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例 3：绑定后需要传入 2 个参数，返回值为 bool</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">compare</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a + b) &gt; c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 绑定规则：c固定为100，a和b由调用时传入（_1和_2）</span></span><br><span class="line">    <span class="comment">// 调用时需要传入2个int，返回bool → 对应function&lt;bool(int, int)&gt;</span></span><br><span class="line">    function&lt;<span class="type">bool</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; f = <span class="built_in">bind</span>(compare, placeholders::_1, placeholders::_2, <span class="number">100</span>);</span><br><span class="line">    cout &lt;&lt; <span class="built_in">f</span>(<span class="number">60</span>, <span class="number">50</span>) &lt;&lt; endl; <span class="comment">// 等价于compare(60,50,100) → 110&gt;100 → 输出1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-如何确定-std-function-的类型？"><a href="#3-如何确定-std-function-的类型？" class="headerlink" title="3. 如何确定 std::function 的类型？"></a>3. 如何确定 <code>std::function</code> 的类型？</h5><p>只需明确一个问题：<strong>调用 <code>bind</code> 生成的函数对象时，需要传入几个参数？每个参数的类型是什么？返回值类型是什么？</strong></p><p>步骤拆解：</p><ol><li>确定原函数的返回值类型（比如 <code>void</code>、<code>int</code>、<code>bool</code>）。</li><li>统计 <code>bind</code> 中使用的占位符数量（<code>_1</code>、<code>_2</code>…），这就是调用时需要传入的参数个数。</li><li>占位符的类型对应原函数中未被固定的参数类型（比如 <code>_1</code> 对应原函数中第一个未绑定的参数类型）。</li><li>组合上述信息，得到 <strong><code>std::function&lt;返回值类型(参数类型1, 参数类型2...)&gt;</code></strong>。</li></ol><blockquote><p>似乎来的不如 <code>auto</code> 香，所以实际怎么写，不用我多说了吧 🤪。</p></blockquote><h4 id="6-什么时候必须显式指定类型？"><a href="#6-什么时候必须显式指定类型？" class="headerlink" title="6. 什么时候必须显式指定类型？"></a>6. 什么时候必须显式指定类型？</h4><ol><li><p><strong>作为类的成员变量</strong>：类成员变量不能用 <code>auto</code> 声明，必须显式指定类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 显式指定bind返回值的类型为function&lt;void(int)&gt;</span></span><br><span class="line">    function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; callback; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setCallback</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        callback = <span class="built_in">bind</span>(show, <span class="number">100</span>, placeholders::_1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>作为函数的返回值</strong>：函数返回值不能用 <code>auto</code>（C++14 起允许，但显式类型更清晰）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数返回一个&quot;需要传入int、返回void&quot;的可调用对象</span></span><br><span class="line"><span class="function">function&lt;<span class="title">void</span><span class="params">(<span class="type">int</span>)</span>&gt; <span class="title">getCallback</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">bind</span>(show, <span class="number">100</span>, placeholders::_1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="5-扩展"><a href="#5-扩展" class="headerlink" title="5. 扩展"></a>5. 扩展</h3><h4 id="1-std-ref-std-cref-——-引用包装器"><a href="#1-std-ref-std-cref-——-引用包装器" class="headerlink" title="1. std::ref &#x2F; std::cref —— 引用包装器"></a>1. <code>std::ref</code> &#x2F; <code>std::cref</code> —— 引用包装器</h4><p><code>bind</code>、<code>function</code> 默认会“拷贝”参数。若想 <strong>传引用</strong>（例如防止对象被拷贝），要用 <code>ref()</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;x = &quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    ++x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">auto</span> f = <span class="built_in">bind</span>(print, <span class="built_in">ref</span>(a));  <span class="comment">// 传引用，不是拷贝</span></span><br><span class="line">    <span class="built_in">f</span>();  <span class="comment">// x=5</span></span><br><span class="line">    <span class="built_in">f</span>();  <span class="comment">// x=6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若不用 <code>ref()</code>，bind 会拷贝一份 a，打印永远是 5。此外，<code>ref()</code> 比较简单就不多说了，直接当 <code>&amp;</code> 这个引用用就行，其他章节也会有涉及。</p><h4 id="2-std-mem-fn-——-将“成员函数指针”转成可调用对象"><a href="#2-std-mem-fn-——-将“成员函数指针”转成可调用对象" class="headerlink" title="2. std::mem_fn —— 将“成员函数指针”转成可调用对象"></a>2. <code>std::mem_fn</code> —— 将“成员函数指针”转成可调用对象</h4><p>有时我们希望把 <strong>成员函数当普通函数一样用</strong>，<code>mem_fn</code> 就是干这个的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;x = &quot;</span> &lt;&lt; x &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Foo f;</span><br><span class="line">    <span class="keyword">auto</span> fn = <span class="built_in">mem_fn</span>(&amp;Foo::show);  <span class="comment">// 转成可调用对象</span></span><br><span class="line">    <span class="built_in">fn</span>(f, <span class="number">42</span>);                     <span class="comment">// 等价于 f.show(42)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>适用于回调场景中成员函数的统一封装。</p><h4 id="3-std-not-fn（C-17）——-对逻辑函数取反"><a href="#3-std-not-fn（C-17）——-对逻辑函数取反" class="headerlink" title="3. std::not_fn（C++17）—— 对逻辑函数取反"></a>3. <code>std::not_fn</code>（C++17）—— 对逻辑函数取反</h4><p>如果你有个函数&#x2F;谓词返回 bool，<code>not_fn</code> 可以生成一个“逻辑相反”的版本。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isEven</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x % <span class="number">2</span> == <span class="number">0</span>; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> isOdd = <span class="built_in">not_fn</span>(isEven);</span><br><span class="line">    cout &lt;&lt; <span class="built_in">isOdd</span>(<span class="number">3</span>) &lt;&lt; endl;  <span class="comment">// 1</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">isOdd</span>(<span class="number">4</span>) &lt;&lt; endl;  <span class="comment">// 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>  常用于 <code>std::find_if_not</code>、<code>std::remove_if</code> 等 STL 算法的逻辑反转。</p></blockquote><h4 id="4-仿函数（函数对象）-std-function-一起用"><a href="#4-仿函数（函数对象）-std-function-一起用" class="headerlink" title="4. 仿函数（函数对象）+ std::function 一起用"></a>4. 仿函数（函数对象）+ <code>std::function</code> 一起用</h4><p>C++ 把“重载 <code>operator()</code> 的类”也当作函数来使用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Add</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> a + b; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    function&lt;<span class="type">int</span>(<span class="type">int</span>,<span class="type">int</span>)&gt; f = <span class="built_in">Add</span>();</span><br><span class="line">    cout &lt;&lt; <span class="built_in">f</span>(<span class="number">1</span>,<span class="number">2</span>) &lt;&lt; endl; <span class="comment">// 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>bind</code>、<code>lambda</code>、仿函数等其实都能混合搭配出更高级的用法。</p><h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3. 小结"></a>3. 小结</h2><p>看到这里，你或多或少也该理解回调函数了吧，所以，还记得文章开头的伏笔吗？回调函数就是把函数当作参数传递使用，和传普通参数大同小异！简单回顾一下吧：</p><ul><li>函数指针的定义：<code>返回类型 (*函数指针名)(参数列表);</code>&#x2F;<code>返回类型 (函数名)(参数列表);</code>。</li><li>取别名推荐使用：<code>using 别名 = 返回值类型 (*)(参数列表);</code>，既因为 <code>typedef</code> 模板支持较弱，又因为语法糖 🍭。</li><li>C++11 库支持后推荐使用：<code>std::function&lt;返回类型(参数类型列表)&gt; 变量名;</code>。</li><li><code>bind</code> 和占位符：<code>auto 新函数 = bind(函数地址, 参数1, 参数2, ...);</code>；<code>placeholders::_1</code>, <code>placeholders::_2</code>, <code>placeholders::_3</code>, ……</li></ul>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;回调函数&quot;&gt;&lt;a href=&quot;#回调函数&quot; class=&quot;headerlink&quot; title=&quot;回调函数&quot;&gt;&lt;/a&gt;回调函数&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a</summary>
        
      
    
    
    
    <category term="C++" scheme="https://www.minbit.top/categories/C/"/>
    
    
    <category term="C++" scheme="https://www.minbit.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++ 语言层面上的多线程</title>
    <link href="https://www.minbit.top/posts/26657.html"/>
    <id>https://www.minbit.top/posts/26657.html</id>
    <published>2025-10-25T08:40:00.000Z</published>
    <updated>2025-11-13T08:40:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-语言层面上的多线程"><a href="#C-语言层面上的多线程" class="headerlink" title="C++ 语言层面上的多线程"></a>C++ 语言层面上的多线程</h1><blockquote><p><a href="https://wyqz.top/p/2668140628.html">C++11 多线程 | 行码棋</a></p></blockquote><h2 id="1-C-11-的线程模型-vs-pthread-的对应关系"><a href="#1-C-11-的线程模型-vs-pthread-的对应关系" class="headerlink" title="1. C++11 的线程模型 vs pthread 的对应关系"></a>1. C++11 的线程模型 vs pthread 的对应关系</h2><table><thead><tr><th>pthread API</th><th>C++11 对应写法</th><th>说明</th></tr></thead><tbody><tr><td><code>pthread_create()</code></td><td><code>std::thread(func, args...)</code></td><td>创建并启动线程</td></tr><tr><td><code>pthread_self()</code></td><td><code>std::this_thread::get_id()</code></td><td>获取当前线程 ID</td></tr><tr><td><code>pthread_join()</code></td><td><code>t.join()</code></td><td>等待线程结束</td></tr><tr><td><code>pthread_detach()</code></td><td><code>t.detach()</code></td><td>分离线程</td></tr><tr><td><code>pthread_exit()</code></td><td><code>return</code> 即可</td><td>函数返回自动结束线程</td></tr><tr><td><code>pthread_cancel()</code></td><td>无直接等价（需自定义退出标志）</td><td>C++ <strong>不建议</strong> 强制终止线程</td></tr><tr><td><code>pthread_mutex_*</code></td><td><code>std::mutex</code> &#x2F; <code>std::lock_guard</code></td><td>自动 RAII 锁管理</td></tr><tr><td><code>pthread_cond_*</code></td><td><code>std::condition_variable</code></td><td>条件变量</td></tr></tbody></table><h2 id="2-线程的使用"><a href="#2-线程的使用" class="headerlink" title="2. 线程的使用"></a>2. 线程的使用</h2><h3 id="1-语法"><a href="#1-语法" class="headerlink" title="1. 语法"></a>1. 语法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::thread <span class="title">t</span><span class="params">(func, arg1, arg2, ...)</span></span>;</span><br><span class="line"><span class="comment">// std:: thread 变量名(要执行的函数, 参数...)</span></span><br></pre></td></tr></table></figure><p>可以传 <strong>任意个参数</strong>（0 个也行），只要函数能接收即可，默认是 <strong>值传递</strong>（参数 <strong>自动复制一份</strong> 传入线程中），如果要让线程内修改外部变量，使用 <strong><code>std::ref(变量)</code>（头文件 <code>&lt;functional&gt;</code>）</strong> 包一层表示传引用，比如：<code>std::ref(var)</code>，线程启动后立即执行传入函数。如果要创建一个 <strong>无参的线程对象</strong>（不执行任何函数，这种情况很少见），有两种正确写法：</p><ol><li><strong>省略括号：</strong> <code>std::thread t1;</code>，此时会默认构造一个 <code>std::thread</code> 对象（不关联任何线程，<code>joinable()</code> 返回 <code>false</code>）。</li><li><strong>使用统一初始化语法（C++11 起）：</strong> <code>std::thread t1{};</code>，显式调用默认构造函数，效果与 <code>std::thread t1;</code> 相同。</li></ol><h3 id="2-代码示例"><a href="#2-代码示例" class="headerlink" title="2. 代码示例"></a>2. 代码示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span>&amp; x)</span> </span>&#123; x = <span class="number">100</span>; &#125;</span><br><span class="line"><span class="type">int</span> val = <span class="number">0</span>;</span><br><span class="line"><span class="function">thread <span class="title">t</span><span class="params">(func, ref(val))</span></span>;  <span class="comment">// 传引用</span></span><br><span class="line">t.<span class="built_in">join</span>();</span><br><span class="line">cout &lt;&lt; val;  <span class="comment">// 输出 100</span></span><br></pre></td></tr></table></figure><h4 id="1-传普通函数"><a href="#1-传普通函数" class="headerlink" title="1. 传普通函数"></a>1. 传普通函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;我拿到了一个值：&quot;</span> &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">thread <span class="title">t1</span><span class="params">(func, <span class="number">100</span>)</span></span>;</span><br><span class="line"><span class="comment">// 注意：每个 std:: thread 对象，在销毁前必须被 join() 或 detach()，否则会造成资源泄漏</span></span><br><span class="line"><span class="comment">// 分别测试下面 3 中情况观察现象：全注释掉或者使用其中任意一个</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 等待线程结束，确保安全</span></span><br><span class="line"><span class="comment">//t1.join();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 分离线程，让它独立运行。注意：主线程可能在子线程打印之前就结束了，所以输出可能看不到！用 Sleep 等它一等</span></span><br><span class="line">t<span class="number">1.</span><span class="built_in">detach</span>();</span><br><span class="line"><span class="built_in">Sleep</span>(<span class="number">1</span>); <span class="comment">// 等待线程结束</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>C++ 标准库要求：<strong>线程对象销毁前，必须显式处理线程的执行状态（要么 <code>join</code> 等待其完成，要么 <code>detach</code> 让其后台运行）</strong>。如果不处理，线程对象销毁时会触发异常，导致程序 <code>abort</code>（“Debug Error! abort () has been called”）。</p><p>这是 C++ 标准委员会为了 <strong>防止资源泄漏和未定义行为</strong> 而做的安全设计：<code>std::thread</code> 是 RAII 对象，它的析构应该清理资源。如果不强制 <code>join</code> 或 <code>detach</code>，程序员很容易忘记，导致线程悬空、资源泄露、甚至访问非法内存。相比于 <code>pthread</code> 的“自由放任”，<code>std::thread</code> 更偏向“安全第一”。</p></blockquote><h4 id="2-传引用参数（想修改主线程变量时）"><a href="#2-传引用参数（想修改主线程变量时）" class="headerlink" title="2. 传引用参数（想修改主线程变量时）"></a>2. 传引用参数（想修改主线程变量时）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x += <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> value = <span class="number">5</span>;</span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">(add, ref(value))</span></span>; <span class="comment">// 用 std:: ref 表示按引用传参</span></span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;value = &quot;</span> &lt;&lt; value &lt;&lt; endl; <span class="comment">// 输出 15</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>不加 <code>ref()</code>，参数会被复制（传值），加 <code>ref()</code>，可修改主线程变量（传引用）。</strong></p><h4 id="3-传-lambda（常用）"><a href="#3-传-lambda（常用）" class="headerlink" title="3. 传 lambda（常用）"></a>3. 传 lambda（常用）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">([&amp;n]() &#123;   <span class="comment">// 捕获外部变量 n 的引用</span></span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) n++;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;n = &quot;</span> &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-传成员函数"><a href="#4-传成员函数" class="headerlink" title="4. 传成员函数"></a>4. 传成员函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Task</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">(<span class="type">int</span> times)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; times; ++i)</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Task 工作中...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Task obj;</span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">(&amp;Task::run, &amp;obj, <span class="number">3</span>)</span></span>; <span class="comment">// 第一个参数：成员函数指针；第二个参数：对象指针；后续参数：传给函数的参数</span></span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="3-join-和-detach"><a href="#3-join-和-detach" class="headerlink" title="3. join 和 detach"></a>3. join 和 detach</h2><blockquote><ul><li><code>join()</code>：主线程等待子线程执行完毕，再继续执行。<strong>适用于需要同步的场景。</strong></li><li><code>detach()</code>：子线程与主线程 “分离”，在后台独立运行（主线程退出后，子线程可能继续执行，由系统回收资源）。<strong>适用于后台任务，不关心何时结束。</strong></li></ul></blockquote><p><code>join</code> 其实非常好理解和上手使用，但是 <code>detach</code> 有一个注意事项：<code>detach()</code> 使线程后台运行，不再与主线程同步，若主线程提前退出，<strong>资源可能已被销毁</strong>，线程访问将非法。所以：</p><ol><li><strong><code>join</code> 的使用场景：</strong> 需要等待线程执行完成的情况，需要获取线程执行结果的情况，主线程退出前必须确保子线程完成的情况。</li><li><strong><code>detach</code> 的使用场景：</strong> 线程需要长时间运行（如后台服务），主线程不需要等待线程完成，线程不需要返回结果给主线程。<strong>注意事项</strong>：detach 后无法再对线程进行 join，要确保 detach 的线程不会访问已经被释放的资源，一旦主线程从 <code>main()</code> 返回或程序调用 <code>exit()</code>，整个进程将终止，此时所有后台线程（包括已 detach 的）都会被操作系统强制销毁，无论其是否完成。</li></ol><hr><h2 id="4-线程结束与终止机制"><a href="#4-线程结束与终止机制" class="headerlink" title="4. 线程结束与终止机制"></a>4. 线程结束与终止机制</h2><p>C++ 中线程终止的推荐方式与 Linux 的 pthread 有所不同：C++ 标准没有提供 <code>pthread_cancel</code> 那样的 <strong>外部强制终止线程</strong>，因为这种行为可能在 C++ 对象析构时造成资源泄露（破坏 RAII）。</p><table><thead><tr><th>方式</th><th>说明</th><th>推荐程度</th></tr></thead><tbody><tr><td><code>return</code> &#x2F; 函数执行完</td><td>正常退出（推荐）</td><td>⭐⭐⭐⭐⭐</td></tr><tr><td>标志位控制</td><td>用于特殊场景的控制</td><td>⭐⭐⭐</td></tr><tr><td>抛出异常（未捕获则线程终止）</td><td>用于错误情况</td><td>⭐⭐⭐</td></tr><tr><td>调用 <code>std::terminate()</code> &#x2F; <code>exit()</code> &#x2F; <code>_exit()</code></td><td>会终止整个进程，而非仅线程</td><td>❌ <strong>十分不推荐</strong></td></tr></tbody></table><p><strong>代码示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread_function</span><span class="params">()</span> <span class="comment">// 执行任务</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ……</span></span><br><span class="line">    <span class="keyword">return</span>; <span class="comment">// 线程函数自然 return 返回，正常结束（推荐）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>正常退出的优点</strong>：自动调用线程函数中所有对象的析构函数、正确释放线程堆栈内存、设置正确的退出代码、递减线程内核对象使用计数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 标志位控制线程退出：</span></span><br><span class="line"><span class="function">std::atomic&lt;<span class="type">bool</span>&gt; <span class="title">stop_flag</span><span class="params">(<span class="literal">false</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread_function</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!stop_flag)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 执行循环任务</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 清理工作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在主线程中设置标志位</span></span><br><span class="line">stop_flag = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p>使用 <strong>原子标志位</strong> 控制线程逻辑：不通过强制“杀死线程”，而是让线程 <strong>自己检测退出信号</strong>。 这种方式资源安全、可控，是现代 C++ 推荐的线程终止模式。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">atomic&lt;<span class="type">bool</span>&gt; <span class="title">stopFlag</span><span class="params">(<span class="literal">false</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">worker</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!stopFlag)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;工作中...&quot;</span> &lt;&lt; endl;</span><br><span class="line">        this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">milliseconds</span>(<span class="number">500</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;线程安全退出&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">(worker)</span></span>;</span><br><span class="line">    this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">seconds</span>(<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">    stopFlag = <span class="literal">true</span>; <span class="comment">// 通知线程退出</span></span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="5-线程休眠"><a href="#5-线程休眠" class="headerlink" title="5. 线程休眠"></a>5. 线程休眠</h2><p>在 C++ 层面，不再使用 <code>sleep()</code> 或 <code>usleep()</code>，推荐下面 2 种，用于替代 Windows 的 <code>Sleep()</code> 和 Linux 的 <code>usleep()</code>，可跨平台。</p><table><thead><tr><th>函数</th><th>头文件</th><th>作用</th></tr></thead><tbody><tr><td><code>std::this_thread::sleep_for(duration)</code></td><td><code>&lt;thread&gt;</code> + <code>&lt;chrono&gt;</code></td><td>休眠指定时间</td></tr><tr><td><code>std::this_thread::sleep_until(time_point)</code></td><td><code>&lt;thread&gt;</code> + <code>&lt;chrono&gt;</code></td><td>休眠到指定时间</td></tr></tbody></table><blockquote><ul><li><strong><code>using namespace std::chrono;</code></strong>：作用是引入 <code>std::chrono</code> 命名空间下的 <strong>时间类型和时钟类型</strong>，例如：</li><li>时长类型：<code>std::chrono::seconds</code>、<code>std::chrono::milliseconds</code> 等。</li><li>时钟类型：<code>std::chrono::system_clock</code>、<code>std::chrono::steady_clock</code> 等。</li><li>时间点类型：<code>std::chrono::time_point</code> 等。</li><li><strong><code>using namespace std::chrono_literals;</code></strong>：作用是引入 <strong>C++14 新增的时间单位字面量</strong>（如 <code>s</code>、<code>ms</code>、<code>us</code>、<code>ns</code>、<code>min</code>、<code>h</code>），可以用更简洁的方式表示时长，例如：</li><li><code>1s</code> 等价于 <code>std::chrono::seconds(1)</code>。</li><li><code>500ms</code> 等价于 <code>std::chrono::milliseconds(500)</code>。</li><li><code>2min</code> 等价于 <code>std::chrono::minutes(2)</code>。</li><li><code>1h</code> 等价于 <code>std::chrono::hours(1)</code>。</li></ul></blockquote><p><strong>示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span>  <span class="comment">// 提供时间单位和时长类型</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono_literals;  <span class="comment">// 启用时间字面量（s, ms, us 等）</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 休眠 1 秒（1s 等价于 std::chrono:: seconds(1)）</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(<span class="number">1</span>s);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 休眠 500 毫秒（0.5 秒）</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(<span class="number">500</span>ms);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 休眠 200 微秒（0.0002 秒）</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(<span class="number">200u</span>s);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 休眠 1000 纳秒（0.000001 秒）</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(<span class="number">1000</span>ns);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>理解方式：<code>std::this_thread::sleep_for(duration)</code> 让当前线程休眠一段时间（“睡多久”），即延迟执行后面的代码。“sleep for X” &#x3D; 从现在起暂停 X 时间再继续执行，假如当前时间是 10:00:00，<code>sleep_for(3s)</code> → 线程在 10:00:03 再醒。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前系统时间（以系统时钟为准，包含日期时间）</span></span><br><span class="line">    <span class="keyword">auto</span> now = system_clock::<span class="built_in">now</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算目标时间点：当前时间 + 2 秒（即 2 秒后）</span></span><br><span class="line">    <span class="keyword">auto</span> target_time = now + <span class="number">2</span>s;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 休眠到目标时间点</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_until</span>(target_time);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 到达目标时间点后执行</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;已到达目标时间点！&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里 <code>now</code> 是 <code>system_clock::time_point</code> 类型。</p></blockquote><p><strong>理解方式：<code>std::this_thread::sleep_until(time_point)</code> 让当前线程休眠到指定的时刻，即“睡到什么时候”。“sleep until T” &#x3D; 睡到某个时间点 T，假设现在是 10:00:00，指定 10:00:03 → 线程睡到那时醒，若调用时系统时间已超过目标时间，函数立即返回。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="comment">// 通常会同时引入 chrono 命名空间和时间字面量命名空间</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono_literals;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 使用字面量表示时长</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(<span class="number">1</span>s);    <span class="comment">// 1 秒</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(<span class="number">500</span>ms); <span class="comment">// 500 毫秒</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(<span class="number">2</span>min);  <span class="comment">// 2 分钟</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(<span class="number">1</span>h);    <span class="comment">// 1 小时</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 chrono 类型和时钟</span></span><br><span class="line">    <span class="keyword">auto</span> now = system_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="keyword">auto</span> target = now + <span class="number">100</span>ms; <span class="comment">// 结合字面量和 chrono 类型</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_until</span>(target);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="6-锁：std-mutex"><a href="#6-锁：std-mutex" class="headerlink" title="6. 锁：std::mutex"></a>6. 锁：<code>std::mutex</code></h2><h3 id="C-互斥锁的三种常见用法"><a href="#C-互斥锁的三种常见用法" class="headerlink" title="C++ 互斥锁的三种常见用法"></a>C++ 互斥锁的三种常见用法</h3><p>C++语言层面提供了三种常用锁，都在头文件 <code>&lt;mutex&gt;</code> 中：</p><table><thead><tr><th>锁类型</th><th>是否自动解锁</th><th>功能特点</th><th>推荐使用场景</th></tr></thead><tbody><tr><td><code>std::mutex</code></td><td>❌ 否</td><td>最基础的互斥锁，需手动 lock&#x2F;unlock</td><td>灵活控制锁时机</td></tr><tr><td><code>std::lock_guard&lt;std::mutex&gt;</code></td><td>✅ 是</td><td>自动加锁、自动释放，作用域结束自动解锁</td><td>简单作用域加锁</td></tr><tr><td><code>std::unique_lock&lt;std::mutex&gt;</code></td><td>✅ 是</td><td>功能更强（可延迟加锁、可解锁再加锁）</td><td>条件变量、复杂锁逻辑</td></tr></tbody></table><h4 id="1-手动加解锁（像-pthread）"><a href="#1-手动加解锁（像-pthread）" class="headerlink" title="1. 手动加解锁（像 pthread）"></a>1. 手动加解锁（像 pthread）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mutex mtx;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mtx.<span class="built_in">lock</span>();</span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">    mtx.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：不要忘记 <code>unlock()</code>，异常时无法释放锁！若函数中有异常或提前 <code>return</code>，可能导致未解锁，不推荐在复杂逻辑中使用。如果临界区代码抛出异常，锁将无法释放，可能会导致死锁！</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">mutex mtx;    <span class="comment">// 全局互斥锁</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mtx.<span class="built_in">lock</span>();   <span class="comment">// 手动加锁</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;线程 &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; 正在执行&quot;</span> &lt;&lt; endl;</span><br><span class="line">    mtx.<span class="built_in">unlock</span>(); <span class="comment">// 手动解锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(print, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(print, <span class="number">2</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-RAII-自动锁：std-lock-guard"><a href="#2-RAII-自动锁：std-lock-guard" class="headerlink" title="2. RAII 自动锁：std::lock_guard"></a>2. RAII 自动锁：<code>std::lock_guard</code></h4><p><code>std::lock_guard</code> 是 <strong>最简单、最轻量、不能折腾的锁</strong>。</p><p>只能：</p><ul><li>构造 → 自动 <code>lock()</code>。</li><li>析构 → 自动 <code>unlock()</code>。</li></ul><p>不能：</p><ul><li>中途 unlock</li><li>不能 lock</li><li>不能移动</li><li>不能延迟加锁</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mutex mtx;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">lock_guard&lt;mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>; <span class="comment">// 构造时加锁，析构时自动解锁</span></span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">&#125; <span class="comment">// 作用域结束自动 unlock</span></span><br></pre></td></tr></table></figure><p>比较常用、安全的写法。<code>lock_guard&lt;mutex&gt;</code> 是一个模板类，<code>&lt;mutex&gt;</code> 指模板参数的类型，即“锁的类型”，必须是 <code>mutex</code>，不能写成 <code>int</code> 或 <code>string</code>，<code>(mtx)</code> 是构造参数，表示传入要保护的那把锁，离开作用域（函数返回、异常抛出等）时会 <strong>自动调用 unlock()</strong>，非常安全。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">mutex mtx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">lock_guard&lt;mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;  <span class="comment">// 自动加锁，作用域结束自动解锁</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;线程 &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; 正在执行&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(print, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(print, <span class="number">2</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-可灵活控制的锁：std-unique-lock"><a href="#3-可灵活控制的锁：std-unique-lock" class="headerlink" title="3. 可灵活控制的锁：std::unique_lock"></a>3. 可灵活控制的锁：<code>std::unique_lock</code></h4><p><code>std::unique_lock</code> 是 <strong>功能全面版的锁</strong>，为了处理复杂情况设计的，它允许：</p><ul><li>中途 unlock()</li><li>中途 lock()</li><li>可以使用 try_lock</li><li>可以延迟加锁（defer_lock）</li><li>可以转移所有权（移动语义）</li><li>可以和 condition_variable 协作（这是重点）</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mutex mtx;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>; <span class="comment">// 可随时 lock/unlock</span></span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">    lock.<span class="built_in">unlock</span>();                <span class="comment">// 手动解锁</span></span><br><span class="line">    <span class="comment">// ...执行其他代码</span></span><br><span class="line">    lock.<span class="built_in">lock</span>();                  <span class="comment">// 再次加锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(_mutex)</span></span>;  <span class="comment">// 自动 lock()</span></span><br><span class="line">    <span class="comment">// ……</span></span><br><span class="line">&#125; <span class="comment">// 自动 unlock()</span></span><br></pre></td></tr></table></figure><p><code>unique_lock&lt;mutex&gt;</code> 也接受 <code>mutex</code> 类型作为模板参数，可以选择何时加锁、解锁，更灵活，常用于 <code>condition_variable</code>（条件变量）场景。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">mutex mtx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">(<span class="type">int</span> id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;   <span class="comment">// 自动加锁</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;线程 &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; 获取锁&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    lock.<span class="built_in">unlock</span>();                  <span class="comment">// 手动释放锁</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;线程 &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; 解锁后执行其他操作&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    lock.<span class="built_in">lock</span>();                    <span class="comment">// 再次加锁</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;线程 &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; 重新加锁执行&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(work, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(work, <span class="number">2</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>平时开发中，常用的差不多就这些，更多高深的较少用到，需要时简单查阅一下就行，扩展：了解一下递归锁，大概就是在递归中的用的锁，但是实际开发中递归也比较少用，所以这里不作为重点。</p></blockquote><hr><h2 id="7-原子操作：std-atomic"><a href="#7-原子操作：std-atomic" class="headerlink" title="7. 原子操作：std::atomic"></a>7. 原子操作：<code>std::atomic</code></h2><h3 id="1-std-mutex-vs-std-atomic：两种完全不同的思路"><a href="#1-std-mutex-vs-std-atomic：两种完全不同的思路" class="headerlink" title="1. std::mutex vs std::atomic：两种完全不同的思路"></a>1. <code>std::mutex</code> vs <code>std::atomic</code>：两种完全不同的思路</h3><table><thead><tr><th>对比点</th><th><code>std::mutex</code>（互斥锁）</th><th><code>std::atomic</code>（原子变量）</th></tr></thead><tbody><tr><td>保护范围</td><td>一整段代码（临界区）</td><td>一个变量本身</td></tr><tr><td>操作粒度</td><td>粗（可包住多行逻辑）</td><td>细（只保护单个读写）</td></tr><tr><td>原理</td><td>多线程竞争锁 → 内核或自旋控制</td><td>CPU 提供原子指令实现</td></tr><tr><td>阻塞</td><td>会阻塞（等待锁）</td><td>不阻塞或轻量阻塞（硬件原子指令）</td></tr><tr><td>使用场景</td><td>复杂临界区，修改多个共享变量或复杂逻辑（多步骤操作、多变量共享）</td><td>简单操作：计数、状态标志、单变量累加等</td></tr><tr><td>开销</td><td>较大（系统级锁，涉及内核态切换）</td><td>极小（硬件原语，用户态操作，接近普通变量）</td></tr><tr><td>可替代关系</td><td>原子操作不能代替锁保护复杂逻辑</td><td>锁可以保护一切，但性能低</td></tr></tbody></table><ul><li><strong><code>mutex</code></strong>：锁的是“一段代码”（临界区）。</li><li><strong><code>atomic</code></strong>：锁的是“一个变量的单个读写”。</li></ul><hr><h3 id="2-为什么需要-atomic？"><a href="#2-为什么需要-atomic？" class="headerlink" title="2. 为什么需要 atomic？"></a>2. 为什么需要 <code>atomic</code>？</h3><blockquote><p><strong><code>atomic</code> 的自增操作底层是硬件级原子指令（如 <code>LOCK XADD</code>），不会被中断打断，也不会出现竞争。</strong></p></blockquote><p>因为有时候我们只是做一个 <strong>简单的共享数值操作</strong>（例如计数器），用互斥锁反而太重，<code>std::atomic</code> 直接让这些操作变为 <strong>无锁且线程安全</strong>。</p><p><strong>mutex 版：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">mutex mtx;</span><br><span class="line"><span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">lock_guard&lt;mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        ++counter; <span class="comment">// 被锁保护</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(work)</span>, <span class="title">t2</span><span class="params">(work)</span></span>;</span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>(); t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">    cout &lt;&lt; counter &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>atomic 版：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">atomic&lt;<span class="type">int</span>&gt; <span class="title">counter</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; ++i)</span><br><span class="line">        ++counter; <span class="comment">// 原子自增，无需锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(work)</span>, <span class="title">t2</span><span class="params">(work)</span></span>;</span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>(); t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">    cout &lt;&lt; counter.<span class="built_in">load</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-atomic-的使用"><a href="#3-atomic-的使用" class="headerlink" title="3. atomic 的使用"></a>3. <code>atomic</code> 的使用</h3><h4 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h4><p><strong>头文件：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br></pre></td></tr></table></figure><p><strong>定义方式：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">atomic&lt;<span class="type">int</span>&gt; <span class="title">cnt</span><span class="params">(<span class="number">0</span>)</span></span>;       <span class="comment">// 定义原子整型变量并初始化成 0</span></span><br><span class="line"><span class="function">atomic&lt;<span class="type">bool</span>&gt; <span class="title">ready</span><span class="params">(<span class="literal">false</span>)</span></span>;    <span class="comment">// 原子布尔变量，初始化成 flase</span></span><br><span class="line"><span class="function">atomic&lt;<span class="type">long</span> <span class="type">long</span>&gt; <span class="title">total</span><span class="params">(<span class="number">0</span>)</span></span>;   <span class="comment">// 原子长整型并初始化成 0</span></span><br><span class="line"><span class="function">std::atomic&lt;<span class="type">int</span>*&gt; <span class="title">atomic_ptr</span><span class="params">(<span class="literal">nullptr</span>)</span></span>;   <span class="comment">// 原子指针初始化成空</span></span><br></pre></td></tr></table></figure><h4 id="2-常用操作"><a href="#2-常用操作" class="headerlink" title="2. 常用操作"></a>2. 常用操作</h4><table><thead><tr><th>操作</th><th>含义</th><th>示例</th></tr></thead><tbody><tr><td><code>load()</code></td><td>读取当前值</td><td><code>int x = cnt.load();</code></td></tr><tr><td><code>store(val)</code></td><td>写入值</td><td><code>cnt.store(10);</code></td></tr><tr><td><code>fetch_add(n)</code></td><td>加法并返回旧值</td><td><code>cnt.fetch_add(1);</code></td></tr><tr><td><code>fetch_sub(n)</code></td><td>减法并返回旧值</td><td><code>cnt.fetch_sub(1);</code></td></tr><tr><td><code>++</code>、<code>--</code></td><td>原子自增、自减</td><td><code>++cnt;</code>、<code>--cnt;</code></td></tr><tr><td><code>exchange(val)</code></td><td>原子地替换值</td><td><code>cnt.exchange(100);</code></td></tr><tr><td><code>compare_exchange_strong(expected, desired)</code></td><td>CAS 操作</td><td>如果当前值 &#x3D;&#x3D; expected，则更新为 desired</td></tr></tbody></table><h4 id="3-代码示例"><a href="#3-代码示例" class="headerlink" title="3. 代码示例"></a>3. 代码示例</h4><p><strong>示例一：多线程计数器（替代 mutex）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">atomic&lt;<span class="type">int</span>&gt; <span class="title">cnt</span><span class="params">(<span class="number">0</span>)</span></span>;  <span class="comment">// 原子计数器, 避免使用 count 命名，可能与库中的冲突</span></span><br><span class="line"><span class="comment">//int cnt = 0;  // 非原子计数器</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; ++i)</span><br><span class="line">        ++cnt;       <span class="comment">// 原子自增，无需加锁（等价于 cnt.fetch_add(1);，线程安全）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(work)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(work)</span></span>;</span><br><span class="line"></span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;最终计数结果: &quot;</span> &lt;&lt; cnt.<span class="built_in">load</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; &quot;最终计数结果: &quot; &lt;&lt; cnt &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p><strong>示例二：线程通信（退出标志）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> chrono_literals;</span><br><span class="line"></span><br><span class="line"><span class="function">atomic&lt;<span class="type">bool</span>&gt; <span class="title">flag</span><span class="params">(<span class="literal">false</span>)</span></span>;  <span class="comment">// 线程共享标志</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">worker</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// while (! flag)// 也可以，更简洁，且等价</span></span><br><span class="line">    <span class="keyword">while</span> (!flag.<span class="built_in">load</span>())   <span class="comment">// 检查标志</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;工作中...&quot;</span> &lt;&lt; endl;</span><br><span class="line">        this_thread::<span class="built_in">sleep_for</span>(<span class="number">500</span>ms);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;收到停止信号，退出线程&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">(worker)</span></span>;</span><br><span class="line"></span><br><span class="line">    this_thread::<span class="built_in">sleep_for</span>(<span class="number">2</span>s);</span><br><span class="line">    flag.<span class="built_in">store</span>(<span class="literal">true</span>);      <span class="comment">// 改变标志，通知线程退出</span></span><br><span class="line"></span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例三：compare_exchange_strong（CAS），CAS（Compare And Swap）是底层原子操作的基础。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">val</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> expected = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试将 val 从 10 改为 20</span></span><br><span class="line"><span class="type">bool</span> success = val.<span class="built_in">compare_exchange_weak</span>(expected, <span class="number">20</span>);</span><br><span class="line"><span class="comment">// 若 val 原本是 10：success = true，val 变为 20</span></span><br><span class="line"><span class="comment">// 若 val 被其他线程修改为 30：success = false，expected 变为 30</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通常配合循环使用（处理 weak 版本的伪失败）</span></span><br><span class="line">expected = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">while</span> (!val.<span class="built_in">compare_exchange_weak</span>(expected, <span class="number">20</span>))    <span class="comment">// 失败时，expected 已被更新为当前值，需重置为目标预期值</span></span><br><span class="line">&#123;</span><br><span class="line">    expected = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">atomic&lt;<span class="type">int</span>&gt; <span class="title">value</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> expected = <span class="number">10</span>;      <span class="comment">// 期望值</span></span><br><span class="line">    <span class="type">int</span> desired  = <span class="number">20</span>;      <span class="comment">// 想要更新的值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (value.<span class="built_in">compare_exchange_strong</span>(expected, desired))</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;更新成功，新值=&quot;</span> &lt;&lt; value.<span class="built_in">load</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;更新失败，当前值=&quot;</span> &lt;&lt; value.<span class="built_in">load</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-注意事项"><a href="#4-注意事项" class="headerlink" title="4. 注意事项"></a>4. 注意事项</h3><ol><li><strong>不支持复杂操作：</strong> 原子类型仅保证 <strong>单个操作</strong> 的原子性，若要执行多步操作（如 <code>a += b</code> 且 <code>b</code> 也是共享变量），仍需用 <code>mutex</code> 保护。</li><li><strong>避免过度使用：</strong> 原子类型的性能虽高，但比普通变量仍有开销。若变量无需多线程共享，用普通类型即可。</li><li><strong>类型限制：</strong> 并非所有类型都能作为 <code>std::atomic</code> 的模板参数，仅支持 “可平凡复制” 的类型（如基本类型、指针、简单结构体）。复杂类型需用 <code>mutex</code> 保护。</li><li><strong>内存序（Memory Order）：</strong> 上述示例省略了内存序参数（默认 <code>std::memory_order_seq_cst</code>，最严格），复杂场景可通过指定内存序（如 <code>std::memory_order_relaxed</code>）优化性能，目前用不到，需要时查一下即可。扩展：实际开发中，理解内存序对于编写正确的并发代码比较有帮助。</li></ol>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;C-语言层面上的多线程&quot;&gt;&lt;a href=&quot;#C-语言层面上的多线程&quot; class=&quot;headerlink&quot; title=&quot;C++ 语言层面上的多线程&quot;&gt;&lt;/a&gt;C++ 语言层面上的多线程&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a</summary>
        
      
    
    
    
    <category term="C++" scheme="https://www.minbit.top/categories/C/"/>
    
    
    <category term="C++" scheme="https://www.minbit.top/tags/C/"/>
    
    <category term="线程" scheme="https://www.minbit.top/tags/%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>057 高级 IO 之 epoll 详解与 CMake 入门</title>
    <link href="https://www.minbit.top/posts/4211.html"/>
    <id>https://www.minbit.top/posts/4211.html</id>
    <published>2025-10-19T04:00:00.000Z</published>
    <updated>2025-10-29T04:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="epoll-和-CMake-的使用"><a href="#epoll-和-CMake-的使用" class="headerlink" title="epoll 和 CMake 的使用"></a>epoll 和 CMake 的使用</h1><h2 id="1-epoll-简介"><a href="#1-epoll-简介" class="headerlink" title="1. epoll 简介"></a>1. epoll 简介</h2><p>epoll 是 Linux 系统提供的一种 IO 多路复用机制，用来替代传统的 select 和 poll。它的核心优势是：</p><ul><li><strong>高效</strong>：性能不会随着监听的文件描述符数量增加而下降。</li><li><strong>内存友好</strong>：只返回就绪的事件，而不是遍历所有文件描述符。</li><li><strong>支持边缘触发</strong>：可以更灵活地控制事件触发方式。</li></ul><h2 id="2-epoll-的三大函数"><a href="#2-epoll-的三大函数" class="headerlink" title="2. epoll 的三大函数"></a>2. epoll 的三大函数</h2><p><code>epoll_create</code>、<code>epoll_ctl</code> 和 <code>epoll_wait</code> 是 epoll 机制的三个核心函数，可以类比为：</p><ul><li><code>epoll_create()</code>：创建一个 epoll 实例（相当于创建一个事件监听器）。</li><li><code>epoll_ctl()</code>：管理要监听的文件描述符（添加、修改、删除监听列表中的 fd）。</li><li><code>epoll_wait()</code>：等待事件发生（阻塞等待，直到有事件发生或超时）。</li></ul><blockquote><p>这三兄弟的关系就像一个管理系统的三个操作：</p><ol><li><code>epoll_create()</code>：创建一个管理办公室。</li><li><code>epoll_ctl()</code>：向办公室登记&#x2F;修改&#x2F;删除要监控的员工（文件描述符）。</li><li><code>epoll_wait()</code>：在办公室等待，当有员工出事（事件发生）时进行通知。</li></ol><p>这种设计使得 epoll 可以高效地管理大量文件描述符，特别适合高并发的服务器程序。</p></blockquote><h2 id="3-epoll-create-epoll-create1-——-创建-epoll-实例"><a href="#3-epoll-create-epoll-create1-——-创建-epoll-实例" class="headerlink" title="3. epoll_create&#x2F;epoll_create1 —— 创建 epoll 实例"></a>3. <code>epoll_create</code>&#x2F;<code>epoll_create1</code> —— 创建 epoll 实例</h2><p><strong>介绍</strong>：创建一个 epoll 实例，返回一个文件描述符，后续的所有 epoll 操作都通过这个 fd 进行。</p><p><strong>函数原型：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_create</span><span class="params">(<span class="type">int</span> size)</span></span>;<span class="comment">// 旧版</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_create1</span><span class="params">(<span class="type">int</span> flags)</span></span>;<span class="comment">// 推荐：带 flags（如 EPOLL_CLOEXEC）</span></span><br></pre></td></tr></table></figure><p><strong>参数</strong>：</p><ul><li><code>size</code>：告诉内核你 <strong>大概</strong> 要监听多少个文件描述符，它只是一个 <strong>提示值</strong>，在较新的内核中这个参数已经不重要了，但必须大于 0，内核会动态调整内部数据结构的大小，实际可以监听的 fd 数量 <strong>只受系统资源限制</strong>（如文件描述符限制、内存等），定义 <code>size = 10</code>，但实际监听 1000 个 fd 也没问题。</li><li><code>flags</code> 常用 <code>0</code> 或 <code>EPOLL_CLOEXEC</code>（在 exec 时自动关闭 epfd），即：<code>epoll_create1(0)</code>、<code>epoll_create1(EPOLL_CLOEXEC)</code>。</li></ul><p><strong>返回值</strong>：</p><ul><li>成功：返回一个 epoll 文件描述符 <code>epfd</code>（&gt;&#x3D; 0），后续用这个 fd 来操作 epoll</li><li>失败：返回 -1，同时设置 errno。</li></ul><p><strong>使用示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> epfd = <span class="built_in">epoll_create</span>(<span class="number">1024</span>);  <span class="comment">// 创建一个 epoll 实例，预计监听1024个fd</span></span><br><span class="line"><span class="keyword">if</span> (epfd == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">perror</span>(<span class="string">&quot;epoll_create failed&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="4-epoll-ctl-——-控制监听列表（注册-修改-删除-关注的-fd）"><a href="#4-epoll-ctl-——-控制监听列表（注册-修改-删除-关注的-fd）" class="headerlink" title="4. epoll_ctl —— 控制监听列表（注册 &#x2F; 修改 &#x2F; 删除 关注的 fd）"></a>4. <code>epoll_ctl</code> —— 控制监听列表（注册 &#x2F; 修改 &#x2F; 删除 关注的 fd）</h2><p><strong>介绍</strong>：向 epoll 实例中添加、修改或删除要监听的文件描述符。</p><p><strong>函数原型：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> op, <span class="type">int</span> fd, <span class="keyword">struct</span> epoll_event *event)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>epoll_event 结构体</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">epoll_event</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> events;    <span class="comment">// 要监听的事件类型</span></span><br><span class="line">    <span class="type">epoll_data_t</span> data;  <span class="comment">// 用户数据，可以存储fd或指针</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> <span class="title class_">epoll_data</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span>        *ptr;   <span class="comment">// 可以指向任意数据</span></span><br><span class="line">    <span class="type">int</span>          fd;    <span class="comment">// 文件描述符</span></span><br><span class="line">    <span class="type">uint32_t</span>     u32;   <span class="comment">// 32位无符号整数</span></span><br><span class="line">    <span class="type">uint64_t</span>     u64;   <span class="comment">// 64位无符号整数</span></span><br><span class="line">&#125; <span class="type">epoll_data_t</span>;</span><br></pre></td></tr></table></figure><p><strong>参数：</strong></p><ul><li><p><code>epfd</code>：<code>epoll_create</code> 返回的 epoll 文件描述符。</p></li><li><p><code>op</code>：操作类型，告诉 epoll 要做什么。</p><ul><li><code>EPOLL_CTL_ADD</code>：<strong>添加</strong> 一个新的文件描述符到监听列表。</li><li><code>EPOLL_CTL_MOD</code>：<strong>修改</strong> 已存在文件描述符的监听事件。</li><li><code>EPOLL_CTL_DEL</code>：从监听列表中 <strong>删除</strong> 一个文件描述符。</li></ul></li><li><p><code>fd</code>：目标被监控的文件描述符&#x2F;要操作的文件描述符（socket、管道、文件等）。</p></li><li><p><code>event</code>：指向 epoll_event 结构体的指针。</p><ul><li><code>events</code> 指定要关注&#x2F;监听的事件，<strong>常用的 events 事件</strong>：<ul><li><code>EPOLLIN</code>：文件描述符 <strong>可读</strong>。</li><li><code>EPOLLOUT</code>：文件描述符 <strong>可写</strong>。</li><li><code>EPOLLERR</code>：文件描述符 <strong>错误</strong>。</li><li><code>EPOLLPRI</code>：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）。</li><li><code>EPOLLRDHUP</code>：对端文件描述符关闭（连接）。</li><li><code>EPOLLET</code>：边缘触发模式。</li><li><code>EPOLLONESHOT</code>：只监听一次事件，当监听完这次事件之后，如果还需要继续监听该文件描述符的话，需要重新将该文件描述符添加到 epoll 模型中。</li></ul></li><li><code>data</code> 用于回传用户自定义数据（通常存 <code>fd</code> 或结构体指针）。<code>event</code> 对 <code>EPOLL_CTL_DEL</code> 可传 <code>NULL</code>（在某些内核版本仍需有效结构，传地址更保险）。</li></ul></li></ul><blockquote><p><strong>注意</strong>：添加前务必确保 fd 是合法且已打开。若使用 <code>EPOLLET</code>（边沿触发），<strong>必须</strong> 把 fd 设为非阻塞（<code>fcntl</code> + <code>O_NONBLOCK</code>），<code>EPOLL_CTL_MOD</code> 用于修改同一 fd 的事件或 user data。</p><p><strong>只有删除操作(EPOLL_CTL_DEL)可以传 nullptr，添加和修改操作必须传有效的 epoll_event 指针：</strong></p><ul><li>EPOLL_CTL_ADD：需要告诉内核监听什么事件 → 必须传 <code>struct epoll_event *</code>。</li><li>EPOLL_CTL_MOD：需要告诉内核修改成什么事件 → 必须传 <code>struct epoll_event *</code>。</li><li>EPOLL_CTL_DEL：只是删除，不需要指定事件 → 可以传 <code>nullptr</code>。</li></ul><p>传 nullptr 的含义：删除操作不需要关心事件类型，只要告诉内核要删除哪个 fd 即可，内核只需要 fd 值就能找到红黑树（下文会提到）中对应的节点并删除，传 nullptr 可以避免传递不必要的参数，提高效率。</p></blockquote><p><strong>返回值</strong>：</p><ul><li>成功：返回 0。</li><li>失败：返回 -1，同时设置 errno。</li></ul><p><strong>使用示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">epoll_event</span> ev;</span><br><span class="line">ev.events = EPOLLIN | EPOLLET;  <span class="comment">// 监听可读事件，使用边缘触发</span></span><br><span class="line">ev.data.fd = client_fd;         <span class="comment">// 将客户端fd保存到data中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加客户端fd到epoll监听列表</span></span><br><span class="line"><span class="type">int</span> ret = <span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_ADD, client_fd, &amp;ev);</span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">perror</span>(<span class="string">&quot;epoll_ctl add failed&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="5-epoll-wait-——-等待事件发生"><a href="#5-epoll-wait-——-等待事件发生" class="headerlink" title="5. epoll_wait —— 等待事件发生"></a>5. <code>epoll_wait</code> —— 等待事件发生</h2><p><strong>介绍</strong>：阻塞等待，直到有文件描述符上的事件发生，然后返回所有就绪的事件。</p><p><strong>函数原型：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event *events, <span class="type">int</span> maxevents, <span class="type">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>参数（结构体同上）</strong>：</p><ul><li><code>epfd</code>：<code>epoll_create</code> 返回的 epoll 文件描述符。</li><li><code>events</code>：指向 epoll_event 数组的指针，用于接收（内核返回）就绪的事件信息。</li><li><code>maxevents</code>：数组大小（能接收的最大就绪事件数）。</li><li><code>timeout</code>：超时&#x2F;最长等待时间（毫秒）。<ul><li><code>-1</code>：永久阻塞，直到有事件发生。</li><li><code>0</code>：非阻塞，立即返回。</li><li><code>&gt; 0</code>：最多等待 timeout 毫秒。</li></ul></li></ul><blockquote><p><strong>要点</strong>：</p><ul><li><code>events[i].data</code> 是你在 <code>epoll_ctl</code> 时设置的数据（常用来快速拿到对应的 fd 或连接结构体）。</li><li><code>epoll_wait</code> 返回后应遍历 <code>events</code> 数组并处理每个就绪项。</li><li><code>maxevents</code> 不应小于你预计一次处理的并发就绪数，通常设置为 64、128 或更大。</li></ul></blockquote><p><strong>返回值</strong>：</p><ul><li><code>&gt; 0</code>：返回就绪事件的数量（events [0..ret-1]）。</li><li><code>0</code>：超时（在指定时间内没有事件发生）。</li><li><code>-1</code>：出错，同时设置 errno。</li></ul><p><strong>使用示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_EVENTS 10</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">epoll_event</span> events[MAX_EVENTS];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待事件发生，最多返回10个就绪事件，超时时间为-1（永久等待）</span></span><br><span class="line"><span class="type">int</span> num_events = <span class="built_in">epoll_wait</span>(epfd, events, MAX_EVENTS, <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">if</span> (num_events == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">perror</span>(<span class="string">&quot;epoll_wait failed&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理所有就绪的事件</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_events; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd = events[i].data.fd;         <span class="comment">// 获取发生事件的文件描述符</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (events[i].events &amp; EPOLLIN)     <span class="comment">// 如果是可读事件</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 处理读操作</span></span><br><span class="line">        <span class="keyword">if</span> (fd == listen_fd)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 监听socket可读，说明有新连接</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 客户端socket可读，接收数据</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-epoll-的底层原理"><a href="#6-epoll-的底层原理" class="headerlink" title="6. epoll 的底层原理"></a>6. epoll 的底层原理</h2><p><code>epoll</code> 之所以比 <code>select</code>、<code>poll</code> 快、高效不是靠单一技术，而是 <strong>数据结构 + 算法 + 机制</strong> 的完美结合：它用了 <strong>“红黑树 + 就绪队列 + 回调机制”</strong> 这三样核心设计，让“监听谁”“谁就绪了”“怎么取结果”都高效完成，避免了反复轮询和复制。</p><h3 id="1-epoll-的三大核心组件"><a href="#1-epoll-的三大核心组件" class="headerlink" title="1. epoll 的三大核心组件"></a>1. epoll 的三大核心组件</h3><table><thead><tr><th>名称</th><th>数据结构</th><th>作用</th></tr></thead><tbody><tr><td><strong>红黑树 rbr</strong></td><td><code>struct rb_root rbr;</code></td><td>存放“我要关注哪些 fd、关心哪些事件”的集合（监控列表）</td></tr><tr><td><strong>就绪队列 rdlist</strong></td><td><code>struct list_head rdlist;</code></td><td>存放“已经就绪的 fd 事件”，等 <code>epoll_wait</code> 来取</td></tr><tr><td><strong>回调机制 ep_poll_callback</strong></td><td>函数指针</td><td>当设备驱动检测到某个 fd 就绪时自动触发，把它加入就绪队列</td></tr></tbody></table><ul><li><strong>红黑树（rbr）</strong>：存储要监听的所有文件描述符，就像“购物清单”，记录了所有要关注的商品（文件描述符），文件描述符天然作为红黑树的 key，查找速度很快 O(log n)，每次调用 <code>epoll_ctl</code> 就是在这张清单上增删改项目。</li><li><strong>就绪队列（rdlist）</strong>：存储已经就绪的文件描述符，就像“已到货通知单”，记录了哪些商品已经到了，可以取货，每次调用 <code>epoll_wait</code> 就是来取这张通知单。</li></ul><p>这三个东西组合在一起，就构成了一个完整的 epoll 模型（对应内核结构 <code>eventpoll</code>）。</p><h3 id="2-一个核心机制：回调-——-epoll-高效的-秘密武器！"><a href="#2-一个核心机制：回调-——-epoll-高效的-秘密武器！" class="headerlink" title="2. 一个核心机制：回调 —— epoll 高效的 秘密武器！"></a>2. 一个核心机制：回调 —— epoll 高效的 <strong>秘密武器</strong>！</h3><ul><li><strong>select&#x2F;poll 的问题：</strong> 程序问操作系统：”我关注的这些 fd，哪些有数据了？”，操作系统：”我一个一个帮你查一遍…”，每次都要遍历所有 fd，效率随 fd 数量增加而下降。</li><li><strong>epoll 的聪明做法</strong>：程序告诉操作系统：”我要关注这些 fd 的事件”，操作系统在内核里建立回调函数（ep_poll_callback），当网卡收到数据时，硬件直接通知内核：”fd 3 有数据了！”，内核自动调用回调函数，把 fd 3 从红黑树移到就绪队列，程序调用 <code>epoll_wait</code> 时，直接取就绪队列就行。</li></ul><p><strong>比喻理解：</strong> 想象你在网上购物：</p><ul><li><strong>select&#x2F;poll</strong>：你每隔几分钟就去快递点问：”我的包裹到了吗？”，快递员要查所有包裹。</li><li><strong>epoll</strong>：快递员有你的电话，包裹一到就给你打电话，你再过去取。</li></ul><h3 id="3-整体流程概览"><a href="#3-整体流程概览" class="headerlink" title="3. 整体流程概览"></a>3. 整体流程概览</h3><p>三个函数 <code>epoll_create</code>、<code>epoll_ctl</code>、<code>epoll_wait</code>，分别对应底层三个阶段：</p><table><thead><tr><th>用户函数</th><th>内核动作</th><th>对应的数据结构</th></tr></thead><tbody><tr><td><code>epoll_create</code></td><td>创建一个 <code>eventpoll</code> 实例</td><td>初始化红黑树 rbr、就绪队列 rdlist</td></tr><tr><td><code>epoll_ctl</code></td><td>把 fd 添加&#x2F;修改&#x2F;删除到红黑树</td><td>操作红黑树节点（每个节点是 epitem）</td></tr><tr><td><code>epoll_wait</code></td><td>等待就绪事件</td><td>从就绪队列里取出已经准备好的事件</td></tr></tbody></table><h3 id="4-内部关键对象：epitem"><a href="#4-内部关键对象：epitem" class="headerlink" title="4. 内部关键对象：epitem"></a>4. 内部关键对象：<code>epitem</code></h3><p>每一个通过 <code>epoll_ctl</code> 加入监听的 fd，内核都会创建一个对应的结构体 <code>epitem</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">epitem</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">rb_node</span> rbn;            <span class="comment">// 红黑树节点 (对应 epoll_ctl 增删改)</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">list_head</span> rdllink;      <span class="comment">// 链表节点 (对应就绪队列)</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_filefd</span> ffd;       <span class="comment">// 文件描述符信息</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">eventpoll</span> *ep;          <span class="comment">// 所属 epoll 实例</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> event;      <span class="comment">// 要监听的事件类型</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p><strong>可以理解为：红黑树节点：表示我关注了 fd 上的这些事件，就绪队列节点：表示 fd 上的事件真的发生了，ffd + event：是谁、关心什么。</strong></p></blockquote><h3 id="5-特殊处理"><a href="#5-特殊处理" class="headerlink" title="5. 特殊处理"></a>5. 特殊处理</h3><ul><li><strong>普通模式</strong>：事件就绪后，继续保留在红黑树中，下次还会通知。</li><li><strong>EPOLLONESHOT 模式</strong>：事件就绪后，会 <strong>自动从红黑树删除</strong>，想再次监听这个 fd，必须重新添加（调用 <code>epoll_ctl(ADD)</code>），常用于多线程模式，防止同一个 fd 被多个线程同时处理。</li><li><strong>EPOLLET（边沿触发）：</strong> 只在状态变化时通知一次，必须配合非阻塞 IO，否则可能漏事件，减少系统调用次数，进一步提升性能。</li></ul><h3 id="6-线程安全保障"><a href="#6-线程安全保障" class="headerlink" title="6. 线程安全保障"></a>6. 线程安全保障</h3><ul><li>就绪队列用互斥锁保护，多线程访问安全</li><li>等待队列处理多个线程同时访问的情况</li></ul><h3 id="7-为什么比-select-poll-高效？"><a href="#7-为什么比-select-poll-高效？" class="headerlink" title="7. 为什么比 select&#x2F;poll 高效？"></a>7. 为什么比 select&#x2F;poll 高效？</h3><ol><li><strong>O(1) 查找</strong>：红黑树保证添加&#x2F;删除操作是 O(log n)，比数组快。</li><li><strong>按需通知</strong>：只有事件真正发生时才通知，不需要轮询。</li><li><strong>批量处理</strong>：一次 <code>epoll_wait</code> 可以返回多个就绪事件。</li><li><strong>内存友好</strong>：只返回就绪的 fd，不是所有 fd。</li></ol><h2 id="7-代码示例（epoll-LT）"><a href="#7-代码示例（epoll-LT）" class="headerlink" title="7. 代码示例（epoll LT）"></a>7. 代码示例（epoll LT）</h2><blockquote><p><strong>完整代码请前往 <a href="https://github.com/huangcancan-xbc/Linux-Ubuntu/tree/main/Coding/Advanced_IO/epoll(LT)">GitHub</a> 查看。</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Socket.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;noCopy.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Epoller.hpp&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义epoll事件类型常量</span></span><br><span class="line"><span class="type">uint32_t</span> EVENT_IN = (EPOLLIN);                              <span class="comment">// 可读事件（EPOLLIN）</span></span><br><span class="line"><span class="type">uint32_t</span> EVENT_OUT = (EPOLLOUT);                            <span class="comment">// 可写事件（EPOLLOUT）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EpollServer</span> : <span class="keyword">public</span> noCopy                           <span class="comment">// 继承防拷贝基类，确保服务器对象不能被拷贝</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> num = <span class="number">64</span>;                              <span class="comment">// epoll_wait最多返回的事件数量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">EpollServer</span>(<span class="type">uint16_t</span> port)                              <span class="comment">// 构造函数，接收端口号</span></span><br><span class="line">        : _port(port),                                      <span class="comment">// 初始化端口号</span></span><br><span class="line">          _listsocket_ptr(<span class="keyword">new</span> <span class="built_in">Sock</span>()),                      <span class="comment">// 创建监听socket智能指针</span></span><br><span class="line">          _epoller_ptr(<span class="keyword">new</span> <span class="built_in">Epoller</span>())                       <span class="comment">// 创建epoller智能指针</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">EpollServer</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        _listsocket_ptr-&gt;<span class="built_in">Close</span>();                            <span class="comment">// 关闭监听socket</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _listsocket_ptr-&gt;<span class="built_in">Socket</span>();                           <span class="comment">// 创建socket</span></span><br><span class="line">        _listsocket_ptr-&gt;<span class="built_in">Bind</span>(_port);                        <span class="comment">// 绑定端口</span></span><br><span class="line">        _listsocket_ptr-&gt;<span class="built_in">Listen</span>();                           <span class="comment">// 开始监听</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">log_</span>(Info, <span class="string">&quot;create listen socket success! fd = %d&quot;</span>, _listsocket_ptr-&gt;<span class="built_in">Fd</span>()); <span class="comment">// 记录监听socket创建成功日志</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理新连接</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Accept</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::string client_ip;                               <span class="comment">// 存储客户端IP</span></span><br><span class="line">        <span class="type">uint16_t</span> client_port;                                <span class="comment">// 存储客户端端口</span></span><br><span class="line">        <span class="type">int</span> sockfd = _listsocket_ptr-&gt;<span class="built_in">Accept</span>(&amp;client_ip, &amp;client_port);             <span class="comment">// 接收新连接</span></span><br><span class="line">        <span class="keyword">if</span> (sockfd &gt; <span class="number">0</span>)                                      <span class="comment">// 如果接收连接成功</span></span><br><span class="line">        &#123;</span><br><span class="line">            _epoller_ptr-&gt;<span class="built_in">EpollerUpdate</span>(EPOLL_CTL_ADD, sockfd, EVENT_IN);           <span class="comment">// 将新连接的fd添加到epoll监听列表，监听可读事件</span></span><br><span class="line">            <span class="built_in">log_</span>(Info, <span class="string">&quot;获得一个新的连接：客户端说：%s:%d&quot;</span>, client_ip.<span class="built_in">c_str</span>(), client_port);    <span class="comment">// 记录新连接日志</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理数据接收</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Recver</span><span class="params">(<span class="type">int</span> fd)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">char</span> buffer[<span class="number">1024</span>];                                  <span class="comment">// 临时缓冲区，用于接收数据</span></span><br><span class="line">        <span class="type">int</span> n = <span class="built_in">read</span>(fd, buffer, <span class="built_in">sizeof</span>(buffer) - <span class="number">1</span>);       <span class="comment">// 从指定fd读取数据</span></span><br><span class="line">        <span class="keyword">if</span> (n &gt; <span class="number">0</span>)                                          <span class="comment">// 成功读取到数据</span></span><br><span class="line">        &#123;</span><br><span class="line">            buffer[n] = <span class="string">&#x27;\0&#x27;</span>;                               <span class="comment">// 添加字符串结束符</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;收到消息：&quot;</span> &lt;&lt; buffer &lt;&lt; std::endl;<span class="comment">// 输出收到的消息</span></span><br><span class="line"></span><br><span class="line">            std::string echo_str = <span class="string">&quot;Sverver echo # &quot;</span> + std::<span class="built_in">string</span>(buffer);     <span class="comment">// 构造回显消息</span></span><br><span class="line">            <span class="built_in">write</span>(fd, echo_str.<span class="built_in">c_str</span>(), echo_str.<span class="built_in">size</span>());   <span class="comment">// 将回显消息写回客户端</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">0</span>)                                    <span class="comment">// 客户端关闭连接（读到文件结束符）</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">log_</span>(Info, <span class="string">&quot;客户端断开连接: fd=%d&quot;</span>, fd);         <span class="comment">// 记录客户端断开连接日志</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;客户端断开连接&quot;</span> &lt;&lt; std::endl;      <span class="comment">// 输出断开连接信息</span></span><br><span class="line">            _epoller_ptr-&gt;<span class="built_in">EpollerUpdate</span>(EPOLL_CTL_DEL, fd, <span class="number">0</span>);      <span class="comment">// 从epoll监听列表中删除该fd</span></span><br><span class="line">            <span class="built_in">close</span>(fd);                                      <span class="comment">// 关闭该连接的文件描述符</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>                                                <span class="comment">// 读取数据出错</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">log_</span>(Error, <span class="string">&quot;read error: fd=%d&quot;</span>, fd);           <span class="comment">// 记录读取错误日志</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;read error&quot;</span> &lt;&lt; std::endl;         <span class="comment">// 输出错误信息</span></span><br><span class="line">            _epoller_ptr-&gt;<span class="built_in">EpollerUpdate</span>(EPOLL_CTL_DEL, fd, <span class="number">0</span>);      <span class="comment">// 从epoll监听列表中删除该fd</span></span><br><span class="line">            <span class="built_in">close</span>(fd);                                      <span class="comment">// 关闭该连接的文件描述符</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Dispatcher</span><span class="params">(<span class="keyword">struct</span> epoll_event revs[], <span class="type">int</span> num)</span>     <span class="comment">// 事件分发器，处理所有就绪的事件</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num; i++)                       <span class="comment">// 遍历所有就绪的事件</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">uint32_t</span> events = revs[i].events;               <span class="comment">// 获取事件类型</span></span><br><span class="line">            <span class="type">int</span> fd = revs[i].data.fd;                       <span class="comment">// 获取发生事件的文件描述符</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (events &amp; EVENT_IN)                          <span class="comment">// 如果是可读事件</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (fd == _listsocket_ptr-&gt;<span class="built_in">Fd</span>())            <span class="comment">// 如果是监听socket可读（有新连接）</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">Accept</span>();                               <span class="comment">// 处理新连接</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">Recver</span>(fd);                             <span class="comment">// 处理数据接收</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (events &amp; EVENT_OUT)                    <span class="comment">// 如果是可写事件</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 可写事件处理逻辑</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>                                            <span class="comment">// 其他事件</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 其他事件处理逻辑</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> <span class="built_in">Start</span>()                                            <span class="comment">// 启动服务器主循环</span></span><br><span class="line">    &#123;</span><br><span class="line">        _epoller_ptr-&gt;<span class="built_in">EpollerUpdate</span>(EPOLL_CTL_ADD, _listsocket_ptr-&gt;<span class="built_in">Fd</span>(), EVENT_IN);    <span class="comment">// 将监听socket添加到epoll监听列表</span></span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">epoll_event</span> revs[num];                       <span class="comment">// 创建epoll_event数组，用于接收就绪事件</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;)                                            <span class="comment">// 服务器无限循环</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> n = _epoller_ptr-&gt;<span class="built_in">EpollerWait</span>(revs, num);   <span class="comment">// 等待事件发生，最多返回num个事件</span></span><br><span class="line">            <span class="keyword">if</span> (n &gt; <span class="number">0</span>)                                      <span class="comment">// 有事件发生</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">log_</span>(Info, <span class="string">&quot;有事件已经就绪，开始处理……其文件描述符是：%d&quot;</span>, revs[<span class="number">0</span>].data.fd);<span class="comment">// 记录第一个就绪事件的fd</span></span><br><span class="line">                <span class="built_in">Dispatcher</span>(revs, n);                        <span class="comment">// 分发处理所有就绪的事件</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">0</span>)                                <span class="comment">// 超时（没有事件发生）</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">log_</span>(Info, <span class="string">&quot;timeout...&quot;</span>);                   <span class="comment">// 记录超时日志</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>                                            <span class="comment">// epoll_wait出错</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">log_</span>(Error, <span class="string">&quot;epoll_wait error!&quot;</span>);           <span class="comment">// 记录错误日志</span></span><br><span class="line">                <span class="comment">// break;                                   // 出错时可以选择退出循环</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::shared_ptr&lt;Sock&gt; _listsocket_ptr;                  <span class="comment">// 监听socket的智能指针</span></span><br><span class="line">    std::shared_ptr&lt;Epoller&gt; _epoller_ptr;                  <span class="comment">// Epoller对象的智能指针</span></span><br><span class="line">    <span class="type">uint16_t</span> _port;                                         <span class="comment">// 服务器端口号</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="8-epoll-的工作方式"><a href="#8-epoll-的工作方式" class="headerlink" title="8. epoll 的工作方式"></a>8. epoll 的工作方式</h2><h3 id="1-核心区别"><a href="#1-核心区别" class="headerlink" title="1. 核心区别"></a>1. 核心区别</h3><table><thead><tr><th>模式</th><th>触发时机</th><th>是否重复通知</th><th>是否必须非阻塞</th><th>实现复杂度</th><th><strong>通知频率</strong></th></tr></thead><tbody><tr><td><strong>LT（Level Triggered，epoll 的默认模式）</strong></td><td>只要内核缓冲区里有数据（高电平状态）</td><td>会 <strong>一直</strong> 通知</td><td>不强制，可阻塞或非阻塞</td><td>简单：可分多次处理事件</td><td>高（只要事件存在就反复通知）</td></tr><tr><td><strong>ET（Edge Triggered）</strong></td><td>只有“状态变化”时触发（从无到有&#x2F;有到多）</td><td>只通知一次</td><td><strong>必须</strong> 非阻塞（否则可能永久阻塞）</td><td>复杂：必须一次性处理完所有数据</td><td>低（仅状态变化时通知一次）</td></tr></tbody></table><p><strong>类比理解：</strong> 可以把内核数据缓冲区理解为“水桶”：</p><ul><li><strong>LT 模式：</strong> 只要桶里有水（数据没读完），内核就会一遍又一遍告诉你“有水！”，所以你可以慢慢舀，不急着一次读完。</li><li><strong>ET 模式：</strong> 只有桶第一次被装满、或者水又多了一点时，才会告诉你一次，之后不会再提醒。所以必须一次把水全舀光，否则漏掉的数据就永远没人告诉你了。</li></ul><p><strong>性能与设计取舍：</strong></p><table><thead><tr><th>对比项</th><th>LT</th><th>ET</th></tr></thead><tbody><tr><td>内核通知次数</td><td>多（每次都通知）</td><td>少（状态变化才通知）</td></tr><tr><td>CPU 开销</td><td>稍高</td><td>更低</td></tr><tr><td>编程难度</td><td>简单</td><td>较高</td></tr><tr><td>安全性</td><td>容错性强（可多次处理）</td><td>容错性低（必须彻底处理）</td></tr><tr><td>实际应用</td><td>select、poll 属于 LT</td><td>Nginx、Redis 使用 ET</td></tr></tbody></table><h3 id="2-ET-模式的编程要点"><a href="#2-ET-模式的编程要点" class="headerlink" title="2. ET 模式的编程要点"></a>2. ET 模式的编程要点</h3><ol><li><p><strong>必须设置非阻塞：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> flags = <span class="built_in">fcntl</span>(fd, F_GETFL, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">fcntl</span>(fd, F_SETFL, flags | O_NONBLOCK);</span><br></pre></td></tr></table></figure></li><li><p><strong>循环读写直到返回错误：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">ssize_t</span> n = <span class="built_in">recv</span>(fd, buf, <span class="built_in">sizeof</span>(buf), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (errno == EAGAIN || errno == EWOULDBLOCK)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// 读完</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;recv error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 对端关闭</span></span><br><span class="line">        <span class="built_in">close</span>(fd);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 正常读取</span></span><br><span class="line">        <span class="built_in">process</span>(buf, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写同理，循环 send，直到 EAGAIN</span></span><br></pre></td></tr></table></figure></li><li><p><strong>注册事件时带上 <code>EPOLLET</code>：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">epoll_event ev;</span><br><span class="line">ev.data.fd = fd;</span><br><span class="line">ev.events = EPOLLIN | EPOLLET;</span><br><span class="line"><span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_ADD, fd, &amp;ev);</span><br></pre></td></tr></table></figure></li></ol><hr><h3 id="3-疑难解答"><a href="#3-疑难解答" class="headerlink" title="3. 疑难解答"></a>3. 疑难解答</h3><h4 id="1-LT-模式下，如果我把-fd-设为非阻塞，并在第一次通知时就循环读完所有数据，那和-ET-有什么区别？"><a href="#1-LT-模式下，如果我把-fd-设为非阻塞，并在第一次通知时就循环读完所有数据，那和-ET-有什么区别？" class="headerlink" title="1. LT 模式下，如果我把 fd 设为非阻塞，并在第一次通知时就循环读完所有数据，那和 ET 有什么区别？"></a>1. LT 模式下，如果我把 fd 设为非阻塞，并在第一次通知时就循环读完所有数据，那和 ET 有什么区别？</h4><p><strong>逻辑行为上几乎一样，性能也接近</strong>。但 LT 模式仍有“条件判断 + 冗余通知”的系统开销，ET 是内核级别的“只在状态变化时触发”，性能更纯粹：</p><ul><li>LT 仍然会“准备通知”，但因为你已经清空了缓冲区，所以下次 <code>epoll_wait</code> 不会再返回该 fd。</li><li>但 LT 仍保留“兜底”能力：万一你漏读了，下次还会提醒你。</li><li>所以：<strong>ET 的优势不是“必须更快”，而是“强制你写出高效代码”</strong>。</li></ul><blockquote><p>  实际上，<strong>高性能服务器（如 Redis、Nginx）选择 ET，是为了避免“意外的重复通知”带来的开销</strong>，尤其是在连接数极高的场景。 </p></blockquote><h4 id="2-为什么-ET-必须用非阻塞-IO？"><a href="#2-为什么-ET-必须用非阻塞-IO？" class="headerlink" title="2. 为什么 ET 必须用非阻塞 IO？"></a>2. 为什么 ET 必须用非阻塞 IO？</h4><p>因为 ET 要求你 <strong>一次性读完所有数据</strong>。如果使用阻塞 IO，当你读到最后一次（缓冲区已空），<code>recv</code> 会 <strong>永远阻塞</strong>，因为没有新数据到来，epoll 也不会再通知你。非阻塞 IO 在无数据时立即返回 <code>-1</code> 并设置 <code>errno = EAGAIN</code>，让你知道“本次数据已读完”。</p><h4 id="3-ET-模式真的更高效吗？"><a href="#3-ET-模式真的更高效吗？" class="headerlink" title="3. ET 模式真的更高效吗？"></a>3. ET 模式真的更高效吗？</h4><p><strong>在特定条件下是的</strong>：</p><ul><li><strong>减少 epoll_wait 的唤醒次数</strong> → 降低系统调用开销。</li><li><strong>促使应用层批量处理数据</strong> → 更好的 cache locality 和吞吐。</li><li><strong>TCP 窗口优化</strong>：当接收方快速消费数据（ET 强制你这么做），TCP 接收窗口更大，发送方可以一次发更多数据，减少小包和 ACK 开销。</li></ul><p><strong>注意：如果 ET 实现不当（如漏读、未设非阻塞），反而会导致连接“假死”，比 LT 更危险。</strong></p><h2 id="9-代码示例（epoll-ET）"><a href="#9-代码示例（epoll-ET）" class="headerlink" title="9. 代码示例（epoll ET）"></a>9. 代码示例（epoll ET）</h2><blockquote><p><strong>完整代码请前往 <a href="https://github.com/huangcancan-xbc/Linux-Ubuntu/tree/main/Coding/Advanced_IO/epoll(ET)">GitHub</a> 查看。</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cerrno&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Log.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;noCopy.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Epoller.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Socket.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Comm.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 前向声明Connection和TcpServer类，避免循环包含</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Connection</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TcpServer</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> EVENT_IN = (EPOLLIN | EPOLLET);            <span class="comment">// 定义读事件掩码（EPOLLIN | EPOLLET）</span></span><br><span class="line"><span class="type">uint32_t</span> EVENT_OUT = (EPOLLOUT | EPOLLET);          <span class="comment">// 定义写事件掩码（EPOLLOUT | EPOLLET）</span></span><br><span class="line"><span class="type">const</span> <span class="type">static</span> <span class="type">int</span> g_buffer_size = <span class="number">1024</span>;              <span class="comment">// 定义缓冲区大小为1024字节</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// using func_t = std::function&lt;void(std::shared_ptr&lt;Connection&gt;)&gt;;</span></span><br><span class="line"><span class="keyword">using</span> <span class="type">func_t</span> = std::function&lt;<span class="built_in">void</span>(std::weak_ptr&lt;Connection&gt;)&gt;;      <span class="comment">// 定义回调函数类型，参数为weak_ptr类型的连接对象</span></span><br><span class="line"><span class="keyword">using</span> except_func = std::function&lt;<span class="built_in">void</span>(std::weak_ptr&lt;Connection&gt;)&gt;; <span class="comment">// 定义异常处理函数类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Connection类：管理单个客户端连接</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Connection</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数，接收socket文件描述符</span></span><br><span class="line">    <span class="comment">// Connection(int sock, std::shared_ptr&lt;TcpServer&gt; tcp_server_ptr)</span></span><br><span class="line">    <span class="comment">//     : _sock(sock),</span></span><br><span class="line">    <span class="comment">//     _tcp_server_ptr(tcp_server_ptr)</span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="built_in">Connection</span>(<span class="type">int</span> sock)</span><br><span class="line">        : _sock(sock)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置连接的回调函数</span></span><br><span class="line">    <span class="comment">// void SetHandler(func_t recv_cb, func_t send_cb, func_t except_cb)</span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">//     _recv_cb = recv_cb;</span></span><br><span class="line">    <span class="comment">//     _send_cb = send_cb;</span></span><br><span class="line">    <span class="comment">//     _except_cb = except_cb;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetHandler</span><span class="params">(<span class="type">func_t</span> recv_cb, <span class="type">func_t</span> send_cb, except_func except_cb)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _recv_cb = recv_cb;</span><br><span class="line">        _send_cb = send_cb;</span><br><span class="line">        _except_cb = except_cb;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取socket文件描述符</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">SockFd</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _sock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向输入缓冲区追加数据</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AppendInBuffer</span><span class="params">(<span class="type">const</span> std::string&amp; data)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _inbuffer += data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向输出缓冲区追加数据</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AppendOutBuffer</span><span class="params">(<span class="type">const</span> std::string&amp; info)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _outbuffer += info;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// const std::string&amp; Inbuffer()</span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">//     return _inbuffer;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// 获取输入缓冲区的引用</span></span><br><span class="line">    <span class="function">std::string&amp; <span class="title">Inbuffer</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _inbuffer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取输出缓冲区的引用</span></span><br><span class="line">    <span class="function">std::string&amp; <span class="title">OutBuffer</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _outbuffer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置指向TCP服务器的弱引用指针</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetWeakPtr</span><span class="params">(std::weak_ptr&lt;TcpServer&gt; tcp_server_ptr)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _tcp_server_ptr = tcp_server_ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Connection</span>()</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _sock;                      <span class="comment">// socket文件描述符</span></span><br><span class="line">    std::string _inbuffer;          <span class="comment">// 输入缓冲区</span></span><br><span class="line">    std::string _outbuffer;         <span class="comment">// 输出缓冲区</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">func_t</span> _recv_cb;                <span class="comment">// 读回调函数</span></span><br><span class="line">    <span class="type">func_t</span> _send_cb;                <span class="comment">// 写回调函数</span></span><br><span class="line">    <span class="comment">// func_t _except_cb;</span></span><br><span class="line">    except_func _except_cb;         <span class="comment">// 异常回调函数</span></span><br><span class="line"></span><br><span class="line">    std::weak_ptr&lt;TcpServer&gt; _tcp_server_ptr;   <span class="comment">// 指向TCP服务器的弱引用</span></span><br><span class="line">    std::string _ip;                <span class="comment">// 客户端IP地址</span></span><br><span class="line">    <span class="type">uint16_t</span> _port;                 <span class="comment">// 客户端端口号</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// TcpServer类：TCP服务器主类，支持epoll事件驱动</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TcpServer</span> : <span class="keyword">public</span> std::enable_shared_from_this&lt;TcpServer&gt;, <span class="keyword">public</span> noCopy</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> num = <span class="number">64</span>;      <span class="comment">// 定义epoll事件数组大小为64</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TcpServer</span>(<span class="type">uint16_t</span> port, <span class="type">func_t</span> OnMessage)          <span class="comment">// 构造函数，接收端口号和消息处理函数</span></span><br><span class="line">        : _port(port),                                  <span class="comment">// 服务器端口号</span></span><br><span class="line">        _OnMessage(OnMessage),                          <span class="comment">// 消息处理函数</span></span><br><span class="line">        _quit(<span class="literal">true</span>),                                    <span class="comment">// 退出标志</span></span><br><span class="line">        _epoller_ptr(<span class="keyword">new</span> <span class="built_in">Epoller</span>()),                    <span class="comment">// epoll对象指针</span></span><br><span class="line">        _listensock_ptr(<span class="keyword">new</span> <span class="built_in">Sock</span>())                     <span class="comment">// 监听socket对象指针</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">()</span>                     <span class="comment">// 初始化服务器</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _listensock_ptr-&gt;<span class="built_in">Socket</span>();  <span class="comment">// 创建socket</span></span><br><span class="line">        <span class="built_in">SetNonBlockOrDie</span>(_listensock_ptr-&gt;<span class="built_in">Fd</span>());        <span class="comment">// 设置为非阻塞模式</span></span><br><span class="line">        _listensock_ptr-&gt;<span class="built_in">Bind</span>(_port);   <span class="comment">// 绑定端口</span></span><br><span class="line">        _listensock_ptr-&gt;<span class="built_in">Listen</span>();  <span class="comment">// 开始监听</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// log_(Info, &quot;创建listen socket成功，fd：&quot;, _listensock_ptr-&gt;Fd());</span></span><br><span class="line">        <span class="built_in">log_</span>(Info, <span class="string">&quot;TCP服务器初始化成功，监听端口: %d, listen socket fd: %d&quot;</span>, _port, _listensock_ptr-&gt;<span class="built_in">Fd</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将监听socket添加到epoll中，设置读事件回调</span></span><br><span class="line">        <span class="built_in">AddConnection</span>(_listensock_ptr-&gt;<span class="built_in">Fd</span>(), EVENT_IN, std::<span class="built_in">bind</span>(&amp;TcpServer::Accepter, <span class="keyword">this</span>, std::placeholders::_1), <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// void AddConnection(int sockfd, uint32_t event, func_t recv_cb, func_t send_cb, func_t except_cb, const std::string &amp;ip = &quot;0.0.0.0&quot;, uint16_t port = 0)</span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">//     // std::shared_ptr&lt;Connection&gt; new_connection=std::make_shared&lt;Connection&gt;(sockfd, std::shared_ptr&lt;TcpServer&gt;(this));</span></span><br><span class="line">    <span class="comment">//     std::shared_ptr&lt;Connection&gt; new_connection = std::make_shared&lt;Connection&gt;(sockfd, std::shared_ptr&lt;TcpServer&gt;(this));</span></span><br><span class="line">    <span class="comment">//     new_connection-&gt;SetHandler(recv_cb, send_cb, except_cb);</span></span><br><span class="line">    <span class="comment">//     new_connection-&gt;_ip=ip;</span></span><br><span class="line">    <span class="comment">//     new_connection-&gt;_port=port;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//     _connections.insert(std::make_pair(sockfd, new_connection));</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//     _epoller_ptr-&gt;EpollerUpdate(EPOLL_CTL_ADD, sockfd, event);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//     log_(Debug, &quot;添加一个新的连接，fd：&quot;, sockfd);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// 添加连接到服务器</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AddConnection</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">uint32_t</span> event, <span class="type">func_t</span> recv_cb, <span class="type">func_t</span> send_cb, except_func except_cb, <span class="type">const</span> std::string&amp; ip = <span class="string">&quot;0.0.0.0&quot;</span>, <span class="type">uint16_t</span> port = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::shared_ptr&lt;Connection&gt; <span class="title">new_connection</span><span class="params">(<span class="keyword">new</span> Connection(sockfd))</span></span>;     <span class="comment">// 创建新的连接对象</span></span><br><span class="line">        new_connection-&gt;<span class="built_in">SetWeakPtr</span>(<span class="built_in">shared_from_this</span>());                         <span class="comment">// 设置连接对象对服务器的弱引用</span></span><br><span class="line">        new_connection-&gt;<span class="built_in">SetHandler</span>(recv_cb, send_cb, except_cb);                <span class="comment">// 设置连接的回调函数</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置客户端IP和端口</span></span><br><span class="line">        new_connection-&gt;_ip = ip;</span><br><span class="line">        new_connection-&gt;_port = port;</span><br><span class="line"></span><br><span class="line">        _connections.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(sockfd, new_connection));            <span class="comment">// 将连接添加到连接映射表中</span></span><br><span class="line"></span><br><span class="line">        _epoller_ptr-&gt;<span class="built_in">EpollerUpdate</span>(EPOLL_CTL_ADD, sockfd, event);              <span class="comment">// 将socket添加到epoll监控列表中</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">log_</span>(Debug, <span class="string">&quot;成功添加新连接，fd: %d, 客户端IP: %s, 客户端端口: %d&quot;</span>, sockfd, ip.<span class="built_in">c_str</span>(), port);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 链接管理器</span></span><br><span class="line">    <span class="comment">// void Accepter(std::shared_ptr&lt;Connection&gt; connection)</span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">//     while (true)</span></span><br><span class="line">    <span class="comment">//     &#123;</span></span><br><span class="line">    <span class="comment">//         struct sockaddr_in peer;</span></span><br><span class="line">    <span class="comment">//         socklen_t len = sizeof(peer);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//         int sockfd = ::accept(connection-&gt;SockFd(), (struct sockaddr*)&amp;peer, &amp;len);</span></span><br><span class="line">    <span class="comment">//         if (sockfd &gt; 0)</span></span><br><span class="line">    <span class="comment">//         &#123;</span></span><br><span class="line">    <span class="comment">//             uint16_t peer_port = ntohs(peer.sin_port);</span></span><br><span class="line">    <span class="comment">//             char ipbuf[128];</span></span><br><span class="line">    <span class="comment">//             inet_ntop(AF_INET, &amp;peer.sin_addr.s_addr, ipbuf, sizeof(ipbuf));</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//             log_(Debug, &quot;收到一个新的客户端连接，得到的消息：[%s:%d], sockfd：%d&quot;, ipbuf, peer_port, sockfd);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//             SetNonBlockOrDie(sockfd);</span></span><br><span class="line">    <span class="comment">//             // listensock只需要设置_recv_cb，其他sock，读，写，异常都设置</span></span><br><span class="line">    <span class="comment">//             // AddConnection(sockfd, EVENT_IN, nullptr, nullptr, nullptr);</span></span><br><span class="line">    <span class="comment">//             AddConnection(sockfd, EVENT_IN, std::bind(&amp;TcpServer::Recver, this, std::placeholders::_1), std::bind(&amp;TcpServer::Sender, this, std::placeholders::_1), std::bind(&amp;TcpServer::Excepter, this, std::placeholders::_1), ipbuf, peer_port);</span></span><br><span class="line">    <span class="comment">//         &#125;</span></span><br><span class="line">    <span class="comment">//         else</span></span><br><span class="line">    <span class="comment">//         &#123;</span></span><br><span class="line">    <span class="comment">//             if (errno == EWOULDBLOCK)</span></span><br><span class="line">    <span class="comment">//             &#123;</span></span><br><span class="line">    <span class="comment">//                 break;</span></span><br><span class="line">    <span class="comment">//             &#125;</span></span><br><span class="line">    <span class="comment">//             else if (errno == EINTR)</span></span><br><span class="line">    <span class="comment">//             &#123;</span></span><br><span class="line">    <span class="comment">//                 continue;</span></span><br><span class="line">    <span class="comment">//             &#125;</span></span><br><span class="line">    <span class="comment">//             else</span></span><br><span class="line">    <span class="comment">//             &#123;</span></span><br><span class="line">    <span class="comment">//                 break;</span></span><br><span class="line">    <span class="comment">//             &#125;</span></span><br><span class="line">    <span class="comment">//         &#125;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接受新连接的处理函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Accepter</span><span class="params">(std::weak_ptr&lt;Connection&gt; connection)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> connection_ptr = connection.<span class="built_in">lock</span>();                <span class="comment">// 将weak_ptr转换为shared_ptr以安全访问连接对象</span></span><br><span class="line">        <span class="keyword">if</span> (!connection_ptr)                                    <span class="comment">// 检查转换是否成功</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// log_(Warning, &quot;无法获取连接对象指针，可能已被销毁&quot;);</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> peer;</span><br><span class="line">            <span class="type">socklen_t</span> len = <span class="built_in">sizeof</span>(peer);</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> sockfd = ::<span class="built_in">accept</span>(connection_ptr-&gt;<span class="built_in">SockFd</span>(), (<span class="keyword">struct</span> sockaddr*)&amp;peer, &amp;len);         <span class="comment">// 接受新的客户端连接</span></span><br><span class="line">            <span class="keyword">if</span> (sockfd &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">uint16_t</span> peer_port = <span class="built_in">ntohs</span>(peer.sin_port);</span><br><span class="line">                <span class="type">char</span> ipbuf[<span class="number">128</span>];</span><br><span class="line">                <span class="built_in">inet_ntop</span>(AF_INET, &amp;peer.sin_addr.s_addr, ipbuf, <span class="built_in">sizeof</span>(ipbuf));</span><br><span class="line"></span><br><span class="line">                <span class="comment">// log_(Debug, &quot;收到一个新的客户端连接，得到的消息：[%s:%d], sockfd：%d&quot;, ipbuf, peer_port, sockfd);</span></span><br><span class="line">                <span class="built_in">log_</span>(Info, <span class="string">&quot;收到新的客户端连接，客户端IP: %s, 客户端端口: %d, 连接fd: %d&quot;</span>, ipbuf, peer_port, sockfd);</span><br><span class="line"></span><br><span class="line">                <span class="built_in">SetNonBlockOrDie</span>(sockfd);       <span class="comment">// 设置新连接为非阻塞模式</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 为新连接添加到服务器管理中，设置各种回调函数</span></span><br><span class="line">                <span class="built_in">AddConnection</span>(sockfd, EVENT_IN,</span><br><span class="line">                    std::<span class="built_in">bind</span>(&amp;TcpServer::Recver, <span class="keyword">this</span>, std::placeholders::_1),</span><br><span class="line">                    std::<span class="built_in">bind</span>(&amp;TcpServer::Sender, <span class="keyword">this</span>, std::placeholders::_1),</span><br><span class="line">                    std::<span class="built_in">bind</span>(&amp;TcpServer::Excepter, <span class="keyword">this</span>, std::placeholders::_1),</span><br><span class="line">                    ipbuf, peer_port);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (errno == EWOULDBLOCK)       <span class="comment">// 处理accept返回错误的情况</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;                      <span class="comment">// 没有更多连接，退出循环</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (errno == EINTR)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;                   <span class="comment">// 被信号中断，继续循环</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">log_</span>(Error, <span class="string">&quot;accept调用失败，错误码: %d, 错误信息: %s&quot;</span>, errno, <span class="built_in">strerror</span>(errno));</span><br><span class="line">                    <span class="keyword">break</span>;                      <span class="comment">// 其他错误，退出循环</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 事件管理器</span></span><br><span class="line">    <span class="comment">// void Recver(std::shared_ptr&lt;Connection&gt; connection)</span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">//     // std::cout &lt;&lt; &quot;haha, got you!!!, sockfd:&quot; &lt;&lt; connection-&gt;SockFd() &lt;&lt; std::endl;</span></span><br><span class="line">    <span class="comment">//     int sockfd = connection-&gt;SockFd();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//     while(true)</span></span><br><span class="line">    <span class="comment">//     &#123;</span></span><br><span class="line">    <span class="comment">//         char buffer[g_buffer_size];</span></span><br><span class="line">    <span class="comment">//         memset(buffer, 0, sizeof(buffer));</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//         ssize_t n = recv(sockfd, buf, sizeof(buffer) - 1, 0);</span></span><br><span class="line">    <span class="comment">//         if (n &gt; 0)</span></span><br><span class="line">    <span class="comment">//         &#123;</span></span><br><span class="line">    <span class="comment">//             connection-&gt;Append(buffer);</span></span><br><span class="line">    <span class="comment">//         &#125;</span></span><br><span class="line">    <span class="comment">//         else if(n == 0)</span></span><br><span class="line">    <span class="comment">//         &#123;</span></span><br><span class="line">    <span class="comment">//             log_(Debug,&quot;客户端断开连接，&quot; ,sockfd,  connection-&gt;_ip.c_str(),connection-&gt;_port);</span></span><br><span class="line">    <span class="comment">//             connection-&gt;excepter(connection);</span></span><br><span class="line">    <span class="comment">//         &#125;</span></span><br><span class="line">    <span class="comment">//         else</span></span><br><span class="line">    <span class="comment">//         &#123;</span></span><br><span class="line">    <span class="comment">//             if (errno ==EWOULDBLOCK)</span></span><br><span class="line">    <span class="comment">//             &#123;</span></span><br><span class="line">    <span class="comment">//                 break;</span></span><br><span class="line">    <span class="comment">//             &#125;</span></span><br><span class="line">    <span class="comment">//             else if (errno == EINTR)</span></span><br><span class="line">    <span class="comment">//             &#123;</span></span><br><span class="line">    <span class="comment">//                 continue;</span></span><br><span class="line">    <span class="comment">//             &#125;</span></span><br><span class="line">    <span class="comment">//             else</span></span><br><span class="line">    <span class="comment">//             &#123;</span></span><br><span class="line">    <span class="comment">//                 log_(Warning,&quot;sockfd: %d,客户端断开连接，errno: %d&quot;,fd,connection-&gt;_ip.c_str(),connection-&gt;_port);</span></span><br><span class="line">    <span class="comment">//                 connection-&gt;excepter(connection);</span></span><br><span class="line">    <span class="comment">//                 break;</span></span><br><span class="line">    <span class="comment">//             &#125;</span></span><br><span class="line">    <span class="comment">//         &#125;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//     OnMessage(connection);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收数据的处理函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Recver</span><span class="params">(std::weak_ptr&lt;Connection&gt; connection)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (connection.<span class="built_in">expired</span>())           <span class="comment">// 检查连接对象是否已经过期</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// log_(Warning, &quot;连接对象已过期，无法处理接收事件&quot;);</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将weak_ptr转换为shared_ptr以安全访问连接对象</span></span><br><span class="line">        <span class="keyword">auto</span> connection_ptr = connection.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="type">int</span> sockfd = connection_ptr-&gt;<span class="built_in">SockFd</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">char</span> buffer[g_buffer_size];</span><br><span class="line">            <span class="built_in">memset</span>(buffer, <span class="number">0</span>, <span class="built_in">sizeof</span>(buffer));</span><br><span class="line"></span><br><span class="line">            <span class="type">ssize_t</span> n = <span class="built_in">recv</span>(sockfd, buffer, <span class="built_in">sizeof</span>(buffer) - <span class="number">1</span>, <span class="number">0</span>);    <span class="comment">// 从socket接收数据</span></span><br><span class="line">            <span class="keyword">if</span> (n &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                connection_ptr-&gt;<span class="built_in">AppendInBuffer</span>(buffer);         <span class="comment">// 接收到数据，添加到输入缓冲区</span></span><br><span class="line">                <span class="built_in">log_</span>(Debug, <span class="string">&quot;从客户端fd: %d 接收到 %ld 字节数据&quot;</span>, sockfd, n);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">0</span>)                                    <span class="comment">// 客户端关闭连接</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// log_(Debug, &quot;sockfd: %d,客户端消息：%s : %d断开连接(退出)&quot;, sockfd, connection_ptr-&gt;_ip.c_str(), connection_ptr-&gt;_port);</span></span><br><span class="line">                <span class="built_in">log_</span>(Info, <span class="string">&quot;客户端fd: %d (IP: %s, 端口: %d) 主动断开连接&quot;</span>, sockfd, connection_ptr-&gt;_ip.<span class="built_in">c_str</span>(), connection_ptr-&gt;_port);</span><br><span class="line">                connection_ptr-&gt;_except_cb(connection_ptr);     <span class="comment">// 调用异常回调函数处理连接断开</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (errno == EWOULDBLOCK)                       <span class="comment">// 处理接收错误</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// log_(Debug, &quot;客户端fd: %d 数据接收完毕&quot;, sockfd);</span></span><br><span class="line">                    <span class="keyword">break</span>;                                      <span class="comment">// 没有更多数据可读，退出循环</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (errno == EINTR)                        <span class="comment">// 被信号中断，继续循环</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>                                            <span class="comment">// 其他错误</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// log_(Warning, &quot;sockfd: %d,客户端信息：%s : %d接收错误&quot;, sockfd, connection_ptr-&gt;_ip.c_str(), connection_ptr-&gt;_port);</span></span><br><span class="line">                    <span class="built_in">log_</span>(Error, <span class="string">&quot;从客户端fd: %d 接收数据失败，错误码: %d, 错误信息: %s&quot;</span>, sockfd, errno, <span class="built_in">strerror</span>(errno));</span><br><span class="line">                    connection_ptr-&gt;_except_cb(connection_ptr);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        _OnMessage(connection_ptr);                             <span class="comment">// 调用上层消息处理函数处理接收到的数据</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送数据的处理函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Sender</span><span class="params">(std::weak_ptr&lt;Connection&gt; connection)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (connection.<span class="built_in">expired</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// log_(Warning, &quot;连接对象已过期，无法处理发送事件&quot;);</span></span><br><span class="line">            <span class="keyword">return</span>;             <span class="comment">// 检查连接对象是否已经过期</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将weak_ptr转换为shared_ptr以安全访问连接对象</span></span><br><span class="line">        <span class="keyword">auto</span> connection_ptr = connection.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="keyword">auto</span>&amp; outbuffer = connection_ptr-&gt;<span class="built_in">OutBuffer</span>();</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 发送数据到客户端</span></span><br><span class="line">            <span class="type">ssize_t</span> n = <span class="built_in">send</span>(connection_ptr-&gt;<span class="built_in">SockFd</span>(), outbuffer.<span class="built_in">c_str</span>(), outbuffer.<span class="built_in">size</span>(), <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (n &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// log_(Debug, &quot;向客户端fd: %d 成功发送 %ld 字节数据&quot;, connection_ptr-&gt;SockFd(), n);</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 成功发送部分数据，从输出缓冲区中删除已发送的数据</span></span><br><span class="line">                outbuffer.<span class="built_in">erase</span>(<span class="number">0</span>, n);</span><br><span class="line">                <span class="keyword">if</span> (outbuffer.<span class="built_in">empty</span>())</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// log_(Debug, &quot;客户端fd: %d 输出缓冲区已清空&quot;, connection_ptr-&gt;SockFd());</span></span><br><span class="line">                    <span class="keyword">break</span>;                  <span class="comment">// 缓冲区清空，退出循环</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// log_(Debug, &quot;向客户端fd: %d 发送0字节数据&quot;, connection_ptr-&gt;SockFd());</span></span><br><span class="line">                <span class="keyword">return</span>;                     <span class="comment">// 发送0字节，退出</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 处理发送错误</span></span><br><span class="line">                <span class="keyword">if</span> (errno == EWOULDBLOCK)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">log_</span>(Debug, <span class="string">&quot;客户端fd: %d socket发送缓冲区已满，等待下次发送&quot;</span>, connection_ptr-&gt;<span class="built_in">SockFd</span>());</span><br><span class="line">                    <span class="keyword">break</span>;                  <span class="comment">// socket缓冲区满，退出循环</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (errno == EINTR)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;               <span class="comment">// 被信号中断，继续循环</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>                        <span class="comment">// 其他错误</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// log_(Warning, &quot;sockfd: %d, 客户端消息： %s : %d 发送错误&quot;, connection_ptr-&gt;SockFd(), connection_ptr-&gt;_ip.c_str(), connection_ptr-&gt;_port);</span></span><br><span class="line">                    <span class="built_in">log_</span>(Error, <span class="string">&quot;向客户端fd: %d 发送数据失败，错误码: %d, 错误信息: %s&quot;</span>, connection_ptr-&gt;<span class="built_in">SockFd</span>(), errno, <span class="built_in">strerror</span>(errno));</span><br><span class="line">                    connection_ptr-&gt;_except_cb(connection_ptr);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!outbuffer.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 开启对写事件的关心</span></span><br><span class="line">            <span class="built_in">EnableEvent</span>(connection_ptr-&gt;<span class="built_in">SockFd</span>(), <span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line">            <span class="comment">// log_(Debug, &quot;为客户端fd: %d 启用写事件监控&quot;, connection_ptr-&gt;SockFd());</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 关闭对写事件的关心</span></span><br><span class="line">            <span class="built_in">EnableEvent</span>(connection_ptr-&gt;<span class="built_in">SockFd</span>(), <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">            <span class="comment">// log_(Debug, &quot;为客户端fd: %d 禁用写事件监控&quot;, connection_ptr-&gt;SockFd());</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异常处理函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Excepter</span><span class="params">(std::weak_ptr&lt;Connection&gt; connection)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (connection.<span class="built_in">expired</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// log_(Warning, &quot;连接对象已过期，无法处理异常事件&quot;);</span></span><br><span class="line">            <span class="keyword">return</span>;             <span class="comment">// 检查连接对象是否已经过期</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> conn = connection.<span class="built_in">lock</span>();          <span class="comment">// 将weak_ptr转换为shared_ptr以安全访问连接对象</span></span><br><span class="line">        <span class="keyword">if</span> (!conn)                              <span class="comment">// 检查转换是否成功</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// log_(Warning, &quot;无法获取连接对象指针，可能已被销毁&quot;);</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> fd = conn-&gt;<span class="built_in">SockFd</span>();</span><br><span class="line">        <span class="comment">// log_(Warning, &quot;异常处理程序套接字文件描述符: %d, 客户端消息：%s : %d 异常退出&quot;, conn-&gt;SockFd(), conn-&gt;_ip.c_str(), conn-&gt;_port);</span></span><br><span class="line">        <span class="built_in">log_</span>(Warning, <span class="string">&quot;处理异常连接，fd: %d, 客户端IP: %s, 客户端端口: %d&quot;</span>, conn-&gt;<span class="built_in">SockFd</span>(), conn-&gt;_ip.<span class="built_in">c_str</span>(), conn-&gt;_port);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 1. 移除对特定fd的关心</span></span><br><span class="line">        <span class="comment">// EnableEvent(connection-&gt;SockFd(), false, false);</span></span><br><span class="line">        _epoller_ptr-&gt;<span class="built_in">EpollerUpdate</span>(EPOLL_CTL_DEL, fd, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 2. 关闭异常的文件描述符</span></span><br><span class="line">        <span class="built_in">log_</span>(Debug, <span class="string">&quot;关闭异常连接的文件描述符: %d&quot;</span>, fd);</span><br><span class="line">        <span class="built_in">close</span>(fd);</span><br><span class="line">        <span class="comment">// 3. 从unordered_map中(连接映射表中)移除</span></span><br><span class="line">        <span class="built_in">log_</span>(Debug, <span class="string">&quot;从连接管理器中移除异常连接: %d&quot;</span>, fd);</span><br><span class="line"></span><br><span class="line">        _connections.<span class="built_in">erase</span>(fd);</span><br><span class="line">        <span class="built_in">log_</span>(Info, <span class="string">&quot;异常连接处理完成，fd: %d&quot;</span>, fd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启用或禁用socket的读写事件监控</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">EnableEvent</span><span class="params">(<span class="type">int</span> sock, <span class="type">bool</span> readable, <span class="type">bool</span> writeable)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">uint32_t</span> events = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据参数设置事件掩码</span></span><br><span class="line">        events |= ((readable ? EPOLLIN : <span class="number">0</span>) | (writeable ? EPOLLOUT : <span class="number">0</span>) | EPOLLET);</span><br><span class="line">        _epoller_ptr-&gt;<span class="built_in">EpollerUpdate</span>(EPOLL_CTL_MOD, sock, events);</span><br><span class="line">        <span class="comment">// log_(Debug, &quot;更新socket: %d 的事件监控，可读: %s, 可写: %s&quot;, sock, readable ? &quot;是&quot; : &quot;否&quot;, writeable ? &quot;是&quot; : &quot;否&quot;);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查指定的socket文件描述符是否在服务器管理中</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">IsConnectionSafe</span><span class="params">(<span class="type">int</span> sockfd)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> iter = _connections.<span class="built_in">find</span>(sockfd);</span><br><span class="line">        <span class="keyword">if</span> (iter == _connections.<span class="built_in">end</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// log_(Debug, &quot;检查连接安全状态，fd: %d 不存在于连接管理器中&quot;, sockfd);</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// log_(Debug, &quot;检查连接安全状态，fd: %d 存在于连接管理器中&quot;, sockfd);</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 事件分发器，处理epoll返回的事件</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Dispatcher</span><span class="params">(<span class="type">int</span> timeout)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = _epoller_ptr-&gt;<span class="built_in">EpollerWait</span>(revs, num, timeout);  <span class="comment">// 等待epoll事件</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// if (n &lt; 0)</span></span><br><span class="line">        <span class="comment">// &#123;</span></span><br><span class="line">        <span class="comment">//     log_(Error, &quot;epoll_wait调用失败，错误码: %d, 错误信息: %s&quot;, errno, strerror(errno));</span></span><br><span class="line">        <span class="comment">//     return;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// else if (n == 0)</span></span><br><span class="line">        <span class="comment">// &#123;</span></span><br><span class="line">        <span class="comment">//     log_(Debug, &quot;epoll_wait超时，未检测到任何事件&quot;);</span></span><br><span class="line">        <span class="comment">//     return;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// log_(Debug, &quot;epoll_wait返回 %d 个事件&quot;, n);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">uint32_t</span> events = revs[i].events;</span><br><span class="line">            <span class="type">int</span> sockfd = revs[i].data.fd;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// if (evets &amp; EPOLLERR)</span></span><br><span class="line">            <span class="comment">// &#123;</span></span><br><span class="line">            <span class="comment">//     events |= (EPOLLIN | EPOLLOUT);</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// if (evets &amp; EPOLLHUP)</span></span><br><span class="line">            <span class="comment">// &#123;</span></span><br><span class="line">            <span class="comment">//     events |= (EPOLLIN | EPOLLOUT);</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 处理读事件</span></span><br><span class="line">            <span class="keyword">if</span> ((events &amp; EPOLLIN) &amp;&amp; <span class="built_in">IsConnectionSafe</span>(sockfd))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (_connections[sockfd]-&gt;_recv_cb)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// log_(Debug, &quot;处理读事件，fd: %d&quot;, sockfd);</span></span><br><span class="line">                    _connections[sockfd]-&gt;_recv_cb(_connections[sockfd]);   <span class="comment">// 调用读回调函数</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 处理写事件</span></span><br><span class="line">            <span class="keyword">if</span> ((events &amp; EPOLLOUT) &amp;&amp; <span class="built_in">IsConnectionSafe</span>(sockfd))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (_connections[sockfd]-&gt;_send_cb)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// log_(Debug, &quot;处理写事件，fd: %d&quot;, sockfd);</span></span><br><span class="line">                    _connections[sockfd]-&gt;_send_cb(_connections[sockfd]);   <span class="comment">// 调用写回调函数</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 服务器主循环</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Loop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _quit = <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">log_</span>(Info, <span class="string">&quot;TCP服务器主循环开始运行，端口: %d&quot;</span>, _port);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// AddConnection(_listensock_ptr-&gt;Fd(), EVENT_IN, std::bind(&amp;TcpServer::Accept, this, std::placeholders::_1),nullptr,nullptr);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!_quit)              <span class="comment">// 持续处理事件直到服务器退出</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">Dispatcher</span>(<span class="number">3000</span>);</span><br><span class="line">            <span class="built_in">PrintConnection</span>();      <span class="comment">// 可选，如果需要打印连接状态可以取消注释</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">log_</span>(Info, <span class="string">&quot;TCP服务器主循环结束&quot;</span>);</span><br><span class="line">        _quit = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印当前连接列表（调试用）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PrintConnection</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">log_</span>(Debug, <span class="string">&quot;当前连接总数: %zu&quot;</span>, _connections.<span class="built_in">size</span>());</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;当前连接列表:&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; connection : _connections)</span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; connection.second-&gt;<span class="built_in">SockFd</span>() &lt;&lt; <span class="string">&quot;, &quot;</span>;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;inbuffer: &quot;</span> &lt;&lt; connection.second-&gt;<span class="built_in">Inbuffer</span>().<span class="built_in">c_str</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">TcpServer</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">log_</span>(Info, <span class="string">&quot;TCP服务器正在关闭，清理资源&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::shared_ptr&lt;Epoller&gt; _epoller_ptr;      <span class="comment">// epoll对象指针</span></span><br><span class="line">    std::shared_ptr&lt;Sock&gt; _listensock_ptr;      <span class="comment">// 监听socket对象指针</span></span><br><span class="line">    std::unordered_map&lt;<span class="type">int</span>, std::shared_ptr&lt;Connection&gt;&gt; _connections;  <span class="comment">// 连接管理映射表</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> revs[num];               <span class="comment">// epoll事件数组</span></span><br><span class="line">    <span class="type">uint16_t</span> _port;                             <span class="comment">// 服务器端口号</span></span><br><span class="line">    <span class="type">bool</span> _quit;                                 <span class="comment">// 退出标志</span></span><br><span class="line"></span><br><span class="line">    <span class="type">func_t</span> _OnMessage;                          <span class="comment">// 消息处理函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="10-快速上手-CMake"><a href="#10-快速上手-CMake" class="headerlink" title="10. 快速上手 CMake"></a>10. 快速上手 CMake</h2><h3 id="1-CMake-是干什么的"><a href="#1-CMake-是干什么的" class="headerlink" title="1. CMake 是干什么的"></a>1. CMake 是干什么的</h3><p>CMake 是一个跨平台的 <strong>自动化构建工具</strong>。它的核心作用是：<strong>根据 CMakeLists.txt 自动生成 Makefile</strong>，然后我们只需执行 <code>make</code> 就能编译整个项目。</p><p>简单说：写一份 CMakeLists.txt → 执行 cmake → 自动生成 Makefile → 执行 make → 生成可执行文件。</p><h3 id="2-安装-CMake"><a href="#2-安装-CMake" class="headerlink" title="2. 安装 CMake"></a>2. 安装 CMake</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt install cmake -y</span><br></pre></td></tr></table></figure><p>检查版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake --version</span><br></pre></td></tr></table></figure><h3 id="3-编写最简-CMakeLists-txt"><a href="#3-编写最简-CMakeLists-txt" class="headerlink" title="3. 编写最简 CMakeLists.txt"></a>3. 编写最简 CMakeLists.txt</h3><p>在项目的根目录中创建一个名为 <code>CMakeLists.txt</code> 的文件写入内容：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)<span class="comment"># 指定最低CMake版本</span></span><br><span class="line"><span class="keyword">project</span>(EpollServer)<span class="comment"># 工程名</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)<span class="comment"># 使用C++11标准</span></span><br><span class="line"><span class="keyword">add_executable</span>(EpollServer Main.cc log.cpp) <span class="comment"># 生成可执行文件 main</span></span><br></pre></td></tr></table></figure><p>这就是最基本的版本。<strong>注意：CMake 严格要求文件名必须是 <code>CMakeLists.txt</code>，大小写都必须完全匹配。</strong> 原因很简单：CMake 的解析器在目录下只会自动搜索这个 <strong>精确名字</strong> 的文件（<code>CMakeLists.txt</code>）。不是变量名，不是模糊匹配，也不会识别 <code>CMakelists.txt</code>、<code>cmakelist.txt</code> 等写法。比如：</p><ul><li>✅ 正确：<code>CMakeLists.txt</code>。</li><li>❌ 错误：<code>CMakelists.txt</code> &#x2F; <code>cmakelists.txt</code>。</li></ul><blockquote><p><code>project(EpollServer)</code>：只是一个 <strong>工程名字</strong>，主要用于 CMake 内部标识，与目录名没强绑定。通常我们会让它与最终生成的可执行文件同名，这样方便。</p></blockquote><h3 id="4-编译和运行"><a href="#4-编译和运行" class="headerlink" title="4. 编译和运行"></a>4. 编译和运行</h3><p>我们建议在项目根目录执行下面的代码，这样生成的临时文件都在 build 里，不会污染源代码目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> build</span><br><span class="line"><span class="built_in">cd</span> build</span><br></pre></td></tr></table></figure><p>运行 cmake 命令生成 Makefile</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake ..</span><br></pre></td></tr></table></figure><p>解释：<code>..</code> 表示让 CMake 去上一级（也就是项目根目录）找 <code>CMakeLists.txt</code>。执行完这步后，<code>build/</code> 目录里会生成：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Makefile</span><br><span class="line">CMakeCache.txt</span><br><span class="line">CMakeFiles/</span><br></pre></td></tr></table></figure><p>执行 make 编译：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure><p>CMake 会自动调用 g++ 编译 <code>Main.cc</code> 并生成可执行文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EpollServer</span><br></pre></td></tr></table></figure><p>可选：运行程序</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./EpollServer</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;epoll-和-CMake-的使用&quot;&gt;&lt;a href=&quot;#epoll-和-CMake-的使用&quot; class=&quot;headerlink&quot; title=&quot;epoll 和 CMake 的使用&quot;&gt;&lt;/a&gt;epoll 和 CMake 的使用&lt;/h1&gt;&lt;h2</summary>
        
      
    
    
    
    <category term="Linux" scheme="https://www.minbit.top/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://www.minbit.top/tags/Linux/"/>
    
    <category term="IO" scheme="https://www.minbit.top/tags/IO/"/>
    
  </entry>
  
  <entry>
    <title>05 数据类型</title>
    <link href="https://www.minbit.top/posts/57353.html"/>
    <id>https://www.minbit.top/posts/57353.html</id>
    <published>2025-10-18T16:00:00.000Z</published>
    <updated>2025-11-02T02:10:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="1-常用数据类型一览"><a href="#1-常用数据类型一览" class="headerlink" title="1. 常用数据类型一览"></a>1. 常用数据类型一览</h2><table><thead><tr><th><strong>分类</strong></th><th><strong>数据类型</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>数值类型</strong></td><td><span style="color:#FF0000;"><strong>BIT(M)</strong></span></td><td>位类型。M 指定位数，默认值 1，范围 1–64。</td></tr><tr><td></td><td><span style="color:#FF0000;"><strong>TINYINT [UNSIGNED]</strong></span></td><td>很小的整数。带符号范围：-128 ~ 127；无符号范围：0 ~ 255。默认为有符号。</td></tr><tr><td></td><td><strong>BOOL &#x2F; BOOLEAN</strong></td><td>布尔类型，是 <code>TINYINT(1)</code> 的同义词，<code>0</code> 表示 <code>FALSE</code>，非 <code>0</code> 表示 <code>TRUE</code>。</td></tr><tr><td></td><td><strong>SMALLINT [UNSIGNED]</strong></td><td>小整数。带符号范围：-32,768 ~ 32,767；无符号范围：0 ~ 65,535。</td></tr><tr><td></td><td><span style="color:#FF0000;"><strong>INT &#x2F; INTEGER [UNSIGNED]</strong></span></td><td><strong>最常用的整数类型</strong>。带符号范围：-2,147,483,648 ~ 2,147,483,647；无符号范围：0 ~ 4,294,967,295。</td></tr><tr><td></td><td><strong>BIGINT [UNSIGNED]</strong></td><td>大整数。带符号范围：-9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807；无符号范围：0 ~ 18,446,744,073,709,551,615。</td></tr><tr><td></td><td><span style="color:#FF0000;"><strong>FLOAT(M,D) [UNSIGNED]</strong></span></td><td>单精度浮点数。M 为总位数，D 为小数位数。占用 4 字节。存在精度误差。</td></tr><tr><td></td><td><strong>DOUBLE(M, D) [UNSIGNED]</strong></td><td>双精度浮点数。比 FLOAT 精度更高，占用 8 字节。</td></tr><tr><td></td><td><span style="color:#FF0000;"><strong>DECIMAL(M,D) [UNSIGNED]</strong></span></td><td>定点数（<strong>高精度</strong>）。M 为总位数，D 为小数位数。用于 <strong>货币、金额计算</strong>，不会产生精度误差。</td></tr><tr><td><strong>字符串与二进制类型</strong></td><td><span style="color:#FF0000;"><strong>CHAR(size)</strong></span></td><td>定长字符串，最大长度 255 字符。不足部分用空格填充。性能稳定但浪费空间。</td></tr><tr><td></td><td><span style="color:#FF0000;"><strong>VARCHAR(size)</strong></span></td><td><strong>最常用字符串类型</strong>，可变长度字符串，最大 65,535 字符。节省空间，性能较好。</td></tr><tr><td></td><td><span style="color:#FF0000;"><strong>TEXT</strong></span></td><td>长文本对象，最大 65,535 字符。<strong>不支持默认值</strong>。</td></tr><tr><td></td><td>TINYTEXT &#x2F; MEDIUMTEXT &#x2F; <strong>LONGTEXT</strong></td><td>不同大小的文本类型，最大长度分别为 255、16MB、4GB。</td></tr><tr><td></td><td><strong>BLOB</strong></td><td>二进制大对象，用于存储图片、文件、音频等。</td></tr><tr><td></td><td>TINYBLOB &#x2F; MEDIUMBLOB &#x2F; LONGBLOB</td><td>不同大小的二进制对象类型。</td></tr><tr><td><strong>时间日期类型</strong></td><td><span style="color:#FF0000;"><strong>DATE</strong></span></td><td>日期类型，格式 <code>YYYY-MM-DD</code>，范围 <code>&#39;1000-01-01&#39;</code> ~ <code>&#39;9999-12-31&#39;</code>。</td></tr><tr><td></td><td><span style="color:#FF0000;"><strong>DATETIME</strong></span></td><td><strong>最常用时间类型</strong>，格式 <code>YYYY-MM-DD HH:MM:SS</code>，范围 <code>&#39;1000-01-01 00:00:00&#39;</code> ~ <code>&#39;9999-12-31 23:59:59&#39;</code>。不受时区影响。</td></tr><tr><td></td><td><span style="color:#FF0000;"><strong>TIMESTAMP</strong></span></td><td>时间戳类型，格式 <code>YYYY-MM-DD HH:MM:SS</code>，范围 <code>&#39;1970-01-01 00:00:01&#39;</code> UTC ~ <code>&#39;2038-01-19 03:14:07&#39;</code> UTC。受时区影响，插入&#x2F;更新自动设置当前时间。</td></tr><tr><td></td><td>TIME</td><td>时间类型，格式 <code>HH:MM:SS</code> 或 <code>HHH:MM:SS</code>（可表示超过 24 小时的时间）。</td></tr><tr><td></td><td>YEAR</td><td>年份类型，可为 2 位或 4 位数字格式（推荐 4 位）。</td></tr><tr><td><strong>字符串枚举类型</strong></td><td><span style="color:#FF0000;"><strong>ENUM(‘v1’,’v2’,…)</strong></span></td><td>枚举类型，列值必须是预定义列表中的一个值。内部按数字存储。节省空间但灵活性差。</td></tr><tr><td></td><td><span style="color:#FF0000;"><strong>SET(‘v1’,’v2’,…)</strong></span></td><td>集合类型，可同时存储多个预定义值（以逗号分隔）。每个成员值本身不能含逗号。</td></tr></tbody></table><h3 id="1-补充说明"><a href="#1-补充说明" class="headerlink" title="1. 补充说明"></a>1. 补充说明</h3><table><thead><tr><th>项</th><th>说明</th></tr></thead><tbody><tr><td><strong>[UNSIGNED]</strong></td><td>表示无符号数，只能存储正数和零。</td></tr><tr><td><strong>M, D 参数</strong></td><td>在 <code>FLOAT</code>、<code>DOUBLE</code> 中：M 为显示宽度，D 为小数位数；在 <code>DECIMAL</code> 中：M 为总位数，D 为小数位数。</td></tr><tr><td><strong>size 参数</strong></td><td>对于 <code>CHAR</code>、<code>VARCHAR</code>，表示 <strong>字符数</strong> 而非字节数。UTF8 编码下一个字符占 1–3 字节，UTF8MB4 下占 1–4 字节。</td></tr><tr><td><strong>TIMESTAMP 特性</strong></td><td>默认在插入或更新时自动设为当前时间，受服务器时区影响。</td></tr><tr><td><strong>ENUM &#x2F; SET 内部存储</strong></td><td>虽然是字符串类型，但内部以整数映射存储，在性能上优于 <code>VARCHAR</code>，但修改枚举值需要重建表。</td></tr></tbody></table><h3 id="2-实际开发常用推荐表"><a href="#2-实际开发常用推荐表" class="headerlink" title="2. 实际开发常用推荐表"></a>2. 实际开发常用推荐表</h3><table><thead><tr><th>场景</th><th>推荐数据类型</th><th>理由</th></tr></thead><tbody><tr><td>主键、自增 ID</td><td><strong>BIGINT UNSIGNED</strong></td><td>足够大、可自增，不会溢出。</td></tr><tr><td>数量、状态码</td><td><strong>INT &#x2F; TINYINT</strong></td><td>占用少，查询快。</td></tr><tr><td>金额、精确计算</td><td><strong>DECIMAL(10,2)</strong></td><td>高精度，避免浮点误差。</td></tr><tr><td>姓名、标题</td><td><strong>VARCHAR(100)</strong></td><td>适合变长字符串。</td></tr><tr><td>内容、备注</td><td><strong>TEXT</strong></td><td>存放长文本。</td></tr><tr><td>日期时间</td><td><strong>DATETIME</strong></td><td>直观、不受时区影响。</td></tr><tr><td>更新时间</td><td><strong>TIMESTAMP</strong></td><td>自动更新特性方便日志记录。</td></tr><tr><td>性别、状态、类型</td><td><strong>ENUM</strong></td><td>固定选项值，节省空间。</td></tr></tbody></table><h2 id="2-数值类型"><a href="#2-数值类型" class="headerlink" title="2. 数值类型"></a>2. 数值类型</h2><h3 id="1-tinyint-类型"><a href="#1-tinyint-类型" class="headerlink" title="1. tinyint 类型"></a>1. tinyint 类型</h3><h4 id="1-作用"><a href="#1-作用" class="headerlink" title="1. 作用"></a>1. 作用</h4><p><code>TINYINT</code> 是 MySQL 中 <strong>最小的整数类型</strong>，常用于存储范围较小的整数值（例如状态标识、布尔值、性别、等级、标志位等）。它只占用 <strong>1 个字节（8 位）</strong> 存储空间，因此在性能和空间利用上非常高效。</p><h4 id="2-数据范围"><a href="#2-数据范围" class="headerlink" title="2. 数据范围"></a>2. 数据范围</h4><table><thead><tr><th>类型</th><th>取值范围</th></tr></thead><tbody><tr><td><strong>tinyint（有符号）</strong></td><td>-128 ~ 127</td></tr><tr><td><strong>tinyint unsigned（无符号）</strong></td><td>0 ~ 255</td></tr></tbody></table><blockquote><p>  <code>UNSIGNED</code> 关键字用于声明“无符号整数”，即不存储负数，范围翻倍。</p></blockquote><h4 id="3-基本使用"><a href="#3-基本使用" class="headerlink" title="3. 基本使用"></a>3. 基本使用</h4><p>inyint 类型占用 1 字节，有符号 tinyint 的取值范围为 -128~127，插入该范围内的数据时都能成功插入，如果插入的数据不在 -128～127 范围内，那么插入数据时就会产生报错：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># 创建表 t1，字段 num 类型为 tinyint（默认有符号）</span><br><span class="line"><span class="keyword">create table</span> t1(</span><br><span class="line">    num tinyint</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"># 插入范围内的数据（<span class="number">100</span> 在 <span class="number">-128</span><span class="operator">~</span><span class="number">127</span> 之间，成功）</span><br><span class="line"><span class="keyword">insert into</span> t1 <span class="keyword">values</span> (<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"># 插入有符号 tinyint 的最小值（<span class="number">-128</span>，成功）</span><br><span class="line"><span class="keyword">insert into</span> t1 <span class="keyword">values</span> (<span class="number">-128</span>);</span><br><span class="line"></span><br><span class="line"># 插入超出范围的数据（<span class="number">-129</span> 小于最小值 <span class="number">-128</span>，报错）</span><br><span class="line"><span class="keyword">insert into</span> t1 <span class="keyword">values</span> (<span class="number">-129</span>);</span><br><span class="line">ERROR <span class="number">1264</span> (<span class="number">22003</span>): <span class="keyword">Out</span> <span class="keyword">of</span> <span class="keyword">range</span> <span class="keyword">value</span> <span class="keyword">for</span> <span class="keyword">column</span> <span class="string">&#x27;num&#x27;</span> <span class="keyword">at</span> <span class="type">row</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"># 查询表 t1 中的数据，验证插入结果</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1;</span><br><span class="line"><span class="operator">+</span><span class="comment">------+</span></span><br><span class="line"><span class="operator">|</span> num  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">100</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">-128</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+</span></span><br></pre></td></tr></table></figure><p>由于 tinyint 类型占用 1 字节，因此无符号 tinyint 的取值范围为 0<del>255，插入该范围的数据时都能成功插入。如果插入的数据不在 0</del>255 范围内，那么插入数据时就会产生报错：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"># 创建表 t2，字段 num 类型为 tinyint unsigned（无符号，范围 <span class="number">0</span><span class="operator">~</span><span class="number">255</span>）</span><br><span class="line"><span class="keyword">create table</span> t2(</span><br><span class="line">    num tinyint unsigned</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"># 插入范围内的数据（<span class="number">100</span> 在 <span class="number">0</span><span class="operator">~</span><span class="number">255</span> 之间，成功）</span><br><span class="line"><span class="keyword">insert into</span> t2 <span class="keyword">values</span> (<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"># 插入负数（<span class="number">-1</span> 小于 <span class="number">0</span>，无符号不允许负数，报错）</span><br><span class="line"><span class="keyword">insert into</span> t2 <span class="keyword">values</span> (<span class="number">-1</span>);</span><br><span class="line">ERROR <span class="number">1264</span> (<span class="number">22003</span>): <span class="keyword">Out</span> <span class="keyword">of</span> <span class="keyword">range</span> <span class="keyword">value</span> <span class="keyword">for</span> <span class="keyword">column</span> <span class="string">&#x27;num&#x27;</span> <span class="keyword">at</span> <span class="type">row</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"># 插入超出最大值的数据（<span class="number">256</span> 大于 <span class="number">255</span>，报错）</span><br><span class="line"><span class="keyword">insert into</span> t2 <span class="keyword">values</span> (<span class="number">256</span>);</span><br><span class="line">ERROR <span class="number">1264</span> (<span class="number">22003</span>): <span class="keyword">Out</span> <span class="keyword">of</span> <span class="keyword">range</span> <span class="keyword">value</span> <span class="keyword">for</span> <span class="keyword">column</span> <span class="string">&#x27;num&#x27;</span> <span class="keyword">at</span> <span class="type">row</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"># 插入无符号 tinyint 的最大值（<span class="number">255</span>，成功）</span><br><span class="line"><span class="keyword">insert into</span> t2 <span class="keyword">values</span> (<span class="number">255</span>);</span><br><span class="line"></span><br><span class="line"># 查询表 t2 中的数据，验证插入结果</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t2;</span><br><span class="line"><span class="operator">+</span><span class="comment">------+</span></span><br><span class="line"><span class="operator">|</span> num  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">100</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">255</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+</span></span><br></pre></td></tr></table></figure><h4 id="4-表示布尔值（最常见）"><a href="#4-表示布尔值（最常见）" class="headerlink" title="4. 表示布尔值（最常见）"></a>4. 表示布尔值（最常见）</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># tinyint 的常见用途：表示布尔值（<span class="number">0</span> 代表 <span class="literal">false</span>，<span class="number">1</span> 代表 <span class="literal">true</span>）</span><br><span class="line"># 例如创建一个表示&quot;是否启用&quot;的字段，用 tinyint 存储更节省空间</span><br><span class="line"><span class="keyword">create table</span> status_table(</span><br><span class="line">    is_enabled tinyint  # <span class="number">0</span><span class="operator">=</span>禁用，<span class="number">1</span><span class="operator">=</span>启用</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">is_active TINYINT(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="number">1</span> COMMENT <span class="string">&#x27;是否启用：0=禁用，1=启用&#x27;</span>;</span><br></pre></td></tr></table></figure><blockquote><p>  说明一下：MySQL 本身是不支持 bool 类型的，当把一个数据设置成 bool 类型时，数据库会自动将其转换成 tinyint(1) 的数据类型，其实这个就是变相的 bool 类型，因为 tinyint(1) 只有 1 和 0 两种取值，可以分别对应 bool 类型的 true 和 false。</p><ul><li><code>TINYINT(1)</code> 实际上与 <code>BOOL</code> &#x2F; <code>BOOLEAN</code> 等价；</li><li>存储时底层仍是整数，<code>0</code> 表示 <code>FALSE</code>，非 <code>0</code> 表示 <code>TRUE</code>；</li><li>建议在逻辑字段中统一约定：<code>0</code> &#x3D; 否，<code>1</code> &#x3D; 是。</li></ul></blockquote><h4 id="5-表示小范围状态码"><a href="#5-表示小范围状态码" class="headerlink" title="5. 表示小范围状态码"></a>5. 表示小范围状态码</h4><p>适用于枚举值较少的场景（如状态、类型、标志），取值有限时优先用 <code>TINYINT</code> 而不是 <code>INT</code>，节省空间。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">status TINYINT UNSIGNED <span class="keyword">DEFAULT</span> <span class="number">0</span> COMMENT <span class="string">&#x27;状态：0=未开始，1=进行中，2=已完成&#x27;</span>;</span><br></pre></td></tr></table></figure><h4 id="6-作为计数或等级字段"><a href="#6-作为计数或等级字段" class="headerlink" title="6. 作为计数或等级字段"></a>6. 作为计数或等级字段</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">level TINYINT UNSIGNED <span class="keyword">DEFAULT</span> <span class="number">1</span> COMMENT <span class="string">&#x27;等级：1~10&#x27;</span>;</span><br></pre></td></tr></table></figure><blockquote><p>  适合范围小的整数类型，如用户级别、权限等级、重试次数等。</p></blockquote><h4 id="7-注意事项"><a href="#7-注意事项" class="headerlink" title="7. 注意事项"></a>7. 注意事项</h4><table><thead><tr><th>项目</th><th>说明</th></tr></thead><tbody><tr><td><strong>(1)</strong></td><td><code>TINYINT(1)</code> 中的数字 <code>1</code> <strong>不是长度限制</strong>，而是“显示宽度”，几乎无效。从 MySQL 8.0.17 起被完全废弃。</td></tr><tr><td><strong>(2)</strong></td><td>若定义为 <code>UNSIGNED</code>，再插入负数会报错或被截断为 0。</td></tr><tr><td><strong>(3)</strong></td><td><code>TINYINT</code> 与 <code>BOOLEAN</code> 只是语法同义词，底层存储一样。</td></tr><tr><td><strong>(4)</strong></td><td>若需要表示超过 ±128 的范围，建议改用 <code>SMALLINT</code> 或 <code>INT</code>。</td></tr><tr><td><strong>(5)</strong></td><td>对布尔字段建立索引意义不大（因为区分度太低）。</td></tr></tbody></table><h4 id="8-详细示例"><a href="#8-详细示例" class="headerlink" title="8. 详细示例"></a>8. 详细示例</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> user_status (</span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;用户ID&#x27;</span>,</span><br><span class="line">    is_active TINYINT(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="number">1</span> COMMENT <span class="string">&#x27;是否启用：0=否，1=是&#x27;</span>,</span><br><span class="line">    status TINYINT UNSIGNED <span class="keyword">DEFAULT</span> <span class="number">0</span> COMMENT <span class="string">&#x27;状态：0=未激活，1=已激活，2=冻结&#x27;</span>,</span><br><span class="line">    level TINYINT UNSIGNED <span class="keyword">DEFAULT</span> <span class="number">1</span> COMMENT <span class="string">&#x27;等级：1~10&#x27;</span></span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 COMMENT<span class="operator">=</span><span class="string">&#x27;用户状态信息表&#x27;</span>;</span><br></pre></td></tr></table></figure><p>执行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DESC</span> user_status;</span><br></pre></td></tr></table></figure><p>输出示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">+</span><span class="comment">-----------+--------------------+------+-----+---------+-------+</span></span><br><span class="line"><span class="operator">|</span> Field     <span class="operator">|</span> Type               <span class="operator">|</span> <span class="keyword">Null</span> <span class="operator">|</span> Key <span class="operator">|</span> <span class="keyword">Default</span> <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+--------------------+------+-----+---------+-------+</span></span><br><span class="line"><span class="operator">|</span> id        <span class="operator">|</span> <span class="type">int</span>(<span class="number">11</span>)            <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span> PRI <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> auto_increment <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> is_active <span class="operator">|</span> tinyint(<span class="number">1</span>)         <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="number">1</span>       <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> status    <span class="operator">|</span> tinyint unsigned   <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="number">0</span>       <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> level     <span class="operator">|</span> tinyint unsigned   <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="number">1</span>       <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+--------------------+------+-----+---------+-------+</span></span><br></pre></td></tr></table></figure><h3 id="2-bit-类型"><a href="#2-bit-类型" class="headerlink" title="2. bit 类型"></a>2. bit 类型</h3><blockquote><p>一个 <code>TINYINT</code> 存一个状态，而一个 <code>BIT(8)</code> 可以在一个字节中同时存 8 个二进制标志。</p></blockquote><h4 id="1-作用-1"><a href="#1-作用-1" class="headerlink" title="1. 作用"></a>1. 作用</h4><p><code>BIT</code> 类型用于存储 <strong>二进制位数据（bit data）</strong>，常用于表示 <strong>标志位、状态开关、权限标识、布尔组合等场景</strong>。它能更高效地存储多个开关量，相当于一组二进制“位标志位数组”。</p><h4 id="2-数据范围-1"><a href="#2-数据范围-1" class="headerlink" title="2. 数据范围"></a>2. 数据范围</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BIT[(M)]</span><br></pre></td></tr></table></figure><table><thead><tr><th>项目</th><th>说明</th></tr></thead><tbody><tr><td><strong>M</strong></td><td>表示位数，取值范围为 <strong>1–64</strong>。如果省略，默认为 1。</td></tr><tr><td><strong>存储空间</strong></td><td>每 8 位占用 1 字节（向上取整）。</td></tr><tr><td><strong>值范围</strong></td><td>可存储从 <code>0</code> 到 <code>2^M - 1</code> 的整数值。</td></tr></tbody></table><table><thead><tr><th>MySQL 类型</th><th>位数</th><th>存储空间</th><th>C 语言类比</th><th>取值范围（有符号）</th></tr></thead><tbody><tr><td><code>BIT(1)</code></td><td>1 位</td><td>约 1 位（实际存储会按字节对齐，通常占 1 字节）</td><td><code>unsigned char</code>（低 1 位）</td><td>0 ～ 1</td></tr><tr><td><code>BIT(4)</code></td><td>4 位</td><td>约 4 位（实际存储占 1 字节）</td><td><code>unsigned char</code>（低 4 位）</td><td>0 ～ 15</td></tr><tr><td><code>BIT(8)</code></td><td>8 位</td><td>1 字节</td><td><code>unsigned char</code></td><td>0 ～ 255</td></tr><tr><td><code>BIT(16)</code></td><td>16 位</td><td>2 字节</td><td><code>unsigned short</code></td><td>0 ～ 65,535</td></tr><tr><td><code>BIT(32)</code></td><td>32 位</td><td>4 字节</td><td><code>unsigned int</code></td><td>0 ～ 4,294,967,295</td></tr><tr><td><code>BIT(64)</code></td><td>64 位</td><td>8 字节</td><td><code>unsigned long long</code></td><td>0 ～ 18,446,744,073,709,551,615</td></tr></tbody></table><h4 id="3-基本使用-1"><a href="#3-基本使用-1" class="headerlink" title="3. 基本使用"></a>3. 基本使用</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">create table</span> t3 (id <span class="type">int</span>,num bit(<span class="number">8</span>));# 定义 num 为 <span class="number">8</span> 位的 bit 类型</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">insert into</span> t3 <span class="keyword">values</span> (<span class="number">10</span>,<span class="number">10</span>);# 插入十进制 <span class="number">10</span>，自动转为 <span class="number">8</span> 位二进制 <span class="number">00001010</span></span><br><span class="line"></span><br><span class="line"># 也可以用二进制格式插入等价数据：</span><br><span class="line"><span class="keyword">insert into</span> t3 <span class="keyword">values</span> (<span class="number">11</span>, b<span class="string">&#x27;00001010&#x27;</span>);  # 二进制 <span class="number">00001010</span> 等价于十进制 <span class="number">10</span></span><br><span class="line"><span class="keyword">insert into</span> t3 <span class="keyword">values</span> (<span class="number">12</span>, <span class="number">0</span>b00001010);   # <span class="number">0</span>b 前缀也表示二进制</span><br></pre></td></tr></table></figure><p>直接查询 <code>bit</code> 类型字段时，MySQL 会默认以 <strong>十六进制字符串</strong> 显示，如果想查看十进制或二进制值，需用函数转换：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"># 示例查询结果（默认十六进制）</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t3;</span><br><span class="line"><span class="operator">+</span><span class="comment">------+------------+</span></span><br><span class="line"><span class="operator">|</span> id   <span class="operator">|</span> num        <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">10</span>   <span class="operator">|</span> <span class="number">0x0A</span>       <span class="operator">|</span>  # <span class="number">0x0A</span> 是十六进制，对应二进制 <span class="number">00001010</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------------+</span></span><br><span class="line"></span><br><span class="line"># 用 hex() 函数显式查看十六进制（和默认一致），语法：<span class="keyword">select</span> id, hex(num) <span class="keyword">from</span> 表名;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> id, hex(num) <span class="keyword">from</span> t3;# 结果：<span class="number">10</span> <span class="operator">|</span> <span class="number">0</span>A</span><br><span class="line"><span class="operator">+</span><span class="comment">------+----------+</span></span><br><span class="line"><span class="operator">|</span> id   <span class="operator">|</span> hex(num) <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+----------+</span></span><br><span class="line"><span class="operator">|</span>   <span class="number">10</span> <span class="operator">|</span> A        <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>   <span class="number">11</span> <span class="operator">|</span> A        <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>   <span class="number">12</span> <span class="operator">|</span> A        <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+----------+</span></span><br><span class="line"></span><br><span class="line"># 用 bin() 函数查看二进制（补全位数），语法：<span class="keyword">select</span> id, bin(num) <span class="keyword">from</span> 表名;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> id, bin(num) <span class="keyword">from</span> t3;# 结果：<span class="number">10</span> <span class="operator">|</span> <span class="number">1010</span>（注意：MySQL 会省略前导 <span class="number">0</span>，实际存储是 <span class="number">8</span> 位 <span class="number">00001010</span>）</span><br><span class="line"><span class="operator">+</span><span class="comment">------+----------+</span></span><br><span class="line"><span class="operator">|</span> id   <span class="operator">|</span> bin(num) <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+----------+</span></span><br><span class="line"><span class="operator">|</span>   <span class="number">10</span> <span class="operator">|</span> <span class="number">1010</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>   <span class="number">11</span> <span class="operator">|</span> <span class="number">1010</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>   <span class="number">12</span> <span class="operator">|</span> <span class="number">1010</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+----------+</span></span><br><span class="line"></span><br><span class="line"># 用 <span class="built_in">cast</span>() 转换为十进制整数查看，语法：<span class="keyword">select</span> id, <span class="built_in">cast</span>(num <span class="keyword">as</span> unsigned) <span class="keyword">from</span> 表名;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> id, <span class="built_in">cast</span>(num <span class="keyword">as</span> unsigned) <span class="keyword">from</span> t3;# 结果：<span class="number">10</span> <span class="operator">|</span> <span class="number">10</span>（转回十进制）</span><br><span class="line"><span class="operator">+</span><span class="comment">------+-----------------------+</span></span><br><span class="line"><span class="operator">|</span> id   <span class="operator">|</span> <span class="built_in">cast</span>(num <span class="keyword">as</span> unsigned) <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+-----------------------+</span></span><br><span class="line"><span class="operator">|</span>   <span class="number">10</span> <span class="operator">|</span>                    <span class="number">10</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>   <span class="number">11</span> <span class="operator">|</span>                    <span class="number">10</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>   <span class="number">12</span> <span class="operator">|</span>                    <span class="number">10</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+-----------------------+</span></span><br></pre></td></tr></table></figure><h4 id="4-存储布尔值或开关状态（节省空间）"><a href="#4-存储布尔值或开关状态（节省空间）" class="headerlink" title="4. 存储布尔值或开关状态（节省空间）"></a>4. 存储布尔值或开关状态（节省空间）</h4><p><code>bit(1)</code> 可存储 1 位二进制（0 或 1），适合表示布尔值（如 <code>是否有效</code>、<code>开关状态</code> 等），比 <code>tinyint</code> 更节省空间（1 位 vs 1 字节）。比如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">create table</span> t4 (</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span>   id <span class="type">int</span>,</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span>   gender bit(<span class="number">1</span>)  # <span class="number">1</span> 表示男，<span class="number">0</span> 表示女</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> );</span><br><span class="line"></span><br><span class="line"># 插入 id<span class="operator">=</span><span class="number">1</span>、性别为男（用 <span class="number">1</span> 表示）的记录</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">insert into</span> t4 <span class="keyword">values</span> (<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"># 插入 id<span class="operator">=</span><span class="number">2</span>、性别为女（用 <span class="number">0</span> 表示）的记录</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">insert into</span> t4 <span class="keyword">values</span> (<span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"># 若插入非 <span class="number">0</span><span class="operator">/</span><span class="number">1</span> 的值（如 <span class="number">2</span>），会报错（bit(<span class="number">1</span>) 只能存 <span class="number">1</span> 位二进制，范围 <span class="number">0</span><span class="operator">~</span><span class="number">1</span>）</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">insert into</span> t4 <span class="keyword">values</span> (<span class="number">3</span>, <span class="number">2</span>);</span><br><span class="line">ERROR <span class="number">1406</span> (<span class="number">22001</span>): Data too long <span class="keyword">for</span> <span class="keyword">column</span> <span class="string">&#x27;gender&#x27;</span> <span class="keyword">at</span> <span class="type">row</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t4;</span><br><span class="line"><span class="operator">+</span><span class="comment">------+----------------+</span></span><br><span class="line"><span class="operator">|</span> id   <span class="operator">|</span> gender         <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+----------------+</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span> <span class="number">0x01</span>           <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span> <span class="number">0x00</span>           <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+----------------+</span></span><br><span class="line"></span><br><span class="line"># 用 <span class="built_in">cast</span>(gender <span class="keyword">as</span> unsigned) 转为十进制，再给列起别名 （如 gender_desc），结果更易理解</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> </span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span>   id,</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span>   <span class="built_in">cast</span>(gender <span class="keyword">as</span> unsigned) <span class="keyword">as</span> gender_code,  # 转十进制 后显示 <span class="number">0</span><span class="operator">/</span><span class="number">1</span>（性别编码）</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span>   <span class="keyword">case</span> <span class="built_in">cast</span>(gender <span class="keyword">as</span> unsigned)  # 用 <span class="keyword">case</span> 语句将 <span class="number">0</span><span class="operator">/</span><span class="number">1</span>  转为具体文字（可选，更友好）</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span>     <span class="keyword">when</span> <span class="number">1</span> <span class="keyword">then</span> <span class="string">&#x27;男&#x27;</span> </span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span>     <span class="keyword">when</span> <span class="number">0</span> <span class="keyword">then</span> <span class="string">&#x27;女&#x27;</span> </span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span>   <span class="keyword">end</span> <span class="keyword">as</span> gender_desc</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">from</span> t4;</span><br><span class="line"><span class="operator">+</span><span class="comment">------+-------------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id   <span class="operator">|</span> gender_code <span class="operator">|</span> gender_desc <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+-------------+-------------+</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>           <span class="number">1</span> <span class="operator">|</span> 男          <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span>           <span class="number">0</span> <span class="operator">|</span> 女          <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+-------------+-------------+</span></span><br></pre></td></tr></table></figure><h3 id="3-小数类型"><a href="#3-小数类型" class="headerlink" title="3. 小数类型"></a>3. 小数类型</h3><h4 id="1-float-类型"><a href="#1-float-类型" class="headerlink" title="1. float 类型"></a>1. float 类型</h4><h5 id="1-作用-2"><a href="#1-作用-2" class="headerlink" title="1. 作用"></a>1. 作用</h5><p><code>float</code> 是用于存储单精度浮点数的数值类型，主要用于表示带小数部分的数值（如身高、体重、温度等），其核心特点是 <strong>占用空间小、计算效率高</strong>，但精度有限（适用于对精度要求不高的场景）。</p><h5 id="2-数据范围-2"><a href="#2-数据范围-2" class="headerlink" title="2. 数据范围"></a>2. 数据范围</h5><ul><li><strong>存储空间</strong>：4 字节（32 位）。</li><li><strong>取值范围：</strong> 绝对值最大能达到接近 10^38^ 数量级。</li><li><strong>精度限制</strong>：约 6~7 位有效数字（超过后可能产生精度丢失，这是浮点数的固有特性）。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span>(M, D)</span><br></pre></td></tr></table></figure><ul><li><code>M</code>：<strong>总位数</strong>（整数部分 + 小数部分的总长度，范围 1~255）。</li><li><code>D</code>：<strong>小数位数</strong>（小数点后的位数，范围 0~30，且 <code>D</code> 必须小于 <code>M</code>）。</li></ul><p>例如 <code>float(5, 2)</code> 表示：总长度 5 位，其中小数部分占 2 位，整数部分最多 3 位（可存储范围：-999.99 ~ 999.99）。<strong>如果省略 <code>M</code> 和 <code>D</code>（直接写 <code>float</code>），MySQL 会根据插入的数据自动分配存储空间（默认单精度，占用 4 字节）。</strong></p><h5 id="3-基本使用-2"><a href="#3-基本使用-2" class="headerlink" title="3. 基本使用"></a>3. 基本使用</h5><p>以 <code>float(5, 2)</code> 为例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"># <span class="type">float</span>(M,D) 中：M<span class="operator">=</span><span class="number">5</span> 表示总位数（整数<span class="operator">+</span>小数共<span class="number">5</span>位），D<span class="operator">=</span><span class="number">2</span> 表示小数部分占<span class="number">2</span>位</span><br><span class="line"># 因此整数部分最多 <span class="number">3</span> 位（<span class="number">5</span><span class="number">-2</span><span class="operator">=</span><span class="number">3</span>），取值范围为 <span class="number">-999.99</span> <span class="operator">~</span> <span class="number">999.99</span></span><br><span class="line"><span class="keyword">create table</span> t5(height <span class="type">float</span>(<span class="number">5</span>,<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line"># 插入 <span class="number">99.99</span>：整数部分<span class="number">2</span>位 <span class="operator">+</span> 小数<span class="number">2</span>位，总<span class="number">4</span>位（未超过<span class="number">5</span>位），符合范围 → 成功</span><br><span class="line"><span class="keyword">insert into</span> t5 <span class="keyword">values</span>(<span class="number">99.99</span>);</span><br><span class="line"></span><br><span class="line"># 插入 <span class="number">-99.99</span>：负数同样遵循范围约束（<span class="number">-99.99</span> 在 <span class="number">-999.99</span> <span class="operator">~</span> <span class="number">999.99</span> 之间）→ 成功</span><br><span class="line"><span class="keyword">insert into</span> t5 <span class="keyword">values</span>(<span class="number">-99.99</span>);</span><br><span class="line"></span><br><span class="line"># 插入 <span class="number">1000.1</span>：整数部分<span class="number">4</span>位（<span class="number">1000</span>）<span class="operator">+</span> 小数<span class="number">1</span>位，总位数超过<span class="number">5</span>位 → 超出范围，报错</span><br><span class="line"><span class="keyword">insert into</span> t5 <span class="keyword">values</span>(<span class="number">1000.1</span>);</span><br><span class="line">ERROR <span class="number">1264</span> (<span class="number">22003</span>): <span class="keyword">Out</span> <span class="keyword">of</span> <span class="keyword">range</span> <span class="keyword">value</span> <span class="keyword">for</span> <span class="keyword">column</span> <span class="string">&#x27;height&#x27;</span> <span class="keyword">at</span> <span class="type">row</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"># 插入 <span class="number">999.99</span>：整数部分<span class="number">3</span>位（<span class="number">999</span>）<span class="operator">+</span> 小数<span class="number">2</span>位，总<span class="number">5</span>位（刚好达到上限）→ 成功</span><br><span class="line"><span class="keyword">insert into</span> t5 <span class="keyword">values</span>(<span class="number">999.99</span>);</span><br><span class="line"></span><br><span class="line"># 插入 <span class="number">999.994</span>：小数部分实际<span class="number">3</span>位（<span class="number">994</span>），定义为<span class="number">2</span>位 → 四舍五入后为<span class="number">999.99</span>（未超上限）→ 成功</span><br><span class="line"><span class="keyword">insert into</span> t5 <span class="keyword">values</span>(<span class="number">999.994</span>);</span><br><span class="line"></span><br><span class="line"># 插入 <span class="number">999.995</span>：四舍五入后为<span class="number">1000.00</span>，整数部分变为<span class="number">4</span>位（<span class="number">1000</span>），总位数超过<span class="number">5</span>位 → 超出范围，报错</span><br><span class="line"><span class="keyword">insert into</span> t5 <span class="keyword">values</span>(<span class="number">999.995</span>);</span><br><span class="line">ERROR <span class="number">1264</span> (<span class="number">22003</span>): <span class="keyword">Out</span> <span class="keyword">of</span> <span class="keyword">range</span> <span class="keyword">value</span> <span class="keyword">for</span> <span class="keyword">column</span> <span class="string">&#x27;height&#x27;</span> <span class="keyword">at</span> <span class="type">row</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"># <span class="number">-999.995</span> 需四舍五入到<span class="number">2</span>位小数：小数点后第<span class="number">3</span>位是<span class="number">5</span>，向前进<span class="number">1</span> → 结果为 <span class="number">-1000.00</span> 超过<span class="number">5</span>位限制 → 报错</span><br><span class="line"><span class="keyword">insert into</span> t5 <span class="keyword">values</span>(<span class="number">-999.995</span>);</span><br><span class="line">ERROR <span class="number">1264</span> (<span class="number">22003</span>): <span class="keyword">Out</span> <span class="keyword">of</span> <span class="keyword">range</span> <span class="keyword">value</span> <span class="keyword">for</span> <span class="keyword">column</span> <span class="string">&#x27;height&#x27;</span> <span class="keyword">at</span> <span class="type">row</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"># <span class="number">-999.994</span> 四舍五入到<span class="number">2</span>位小数：小数点后第<span class="number">3</span>位是<span class="number">4</span>，舍去 → 结果为 <span class="number">-999.99</span> 符合 <span class="type">float</span>(<span class="number">5</span>,<span class="number">2</span>) 约束 → 成功</span><br><span class="line"><span class="keyword">insert into</span> t5 <span class="keyword">values</span>(<span class="number">-999.994</span>);</span><br></pre></td></tr></table></figure><p>创建表 t6，定义 height 为 <code> float(4,2) unsigned</code> 进行演示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"># <span class="type">float</span>(<span class="number">4</span>,<span class="number">2</span>) 表示总位数≤<span class="number">4</span>，小数部分固定<span class="number">2</span>位 → 整数部分最多<span class="number">2</span>位（<span class="number">4</span><span class="number">-2</span><span class="operator">=</span><span class="number">2</span>）</span><br><span class="line"># unsigned 表示无符号 → 只能存储非负数（≥<span class="number">0</span>）</span><br><span class="line"><span class="keyword">create table</span> t6(height <span class="type">float</span>(<span class="number">4</span>,<span class="number">2</span>)  unsigned);</span><br><span class="line"></span><br><span class="line"># 插入 <span class="number">-0.1</span>：负数，违反 unsigned 无符号约束（只能存≥<span class="number">0</span>的值）→ 报错</span><br><span class="line"><span class="keyword">insert into</span> t6 <span class="keyword">values</span> (<span class="number">-0.1</span>);</span><br><span class="line">ERROR <span class="number">1264</span> (<span class="number">22003</span>): <span class="keyword">Out</span> <span class="keyword">of</span> <span class="keyword">range</span> <span class="keyword">value</span> <span class="keyword">for</span> <span class="keyword">column</span> <span class="string">&#x27;height&#x27;</span> <span class="keyword">at</span> <span class="type">row</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"># 插入 <span class="number">0</span>：<span class="number">0</span> 是非负数，且总位数（<span class="number">0.00</span>，整数<span class="number">0</span>位<span class="operator">+</span>小数<span class="number">2</span>位）符合 <span class="type">float</span>(<span class="number">4</span>,<span class="number">2</span>) → 成功</span><br><span class="line"><span class="keyword">insert into</span> t6 <span class="keyword">values</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"># 插入 <span class="number">-0.01</span>：负数，违反 unsigned 约束 → 报错</span><br><span class="line"><span class="keyword">insert into</span> t6 <span class="keyword">values</span>(<span class="number">-0.01</span>);</span><br><span class="line">ERROR <span class="number">1264</span> (<span class="number">22003</span>): <span class="keyword">Out</span> <span class="keyword">of</span> <span class="keyword">range</span> <span class="keyword">value</span> <span class="keyword">for</span> <span class="keyword">column</span> <span class="string">&#x27;height&#x27;</span> <span class="keyword">at</span> <span class="type">row</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"># 插入 <span class="number">99.94</span>：整数部分<span class="number">2</span>位（<span class="number">99</span>）<span class="operator">+</span> 小数<span class="number">2</span>位 → 总位数<span class="number">4</span>，且非负数 → 符合约束 → 成功</span><br><span class="line"><span class="keyword">insert into</span> t6 <span class="keyword">values</span>(<span class="number">99.94</span>);</span><br><span class="line"></span><br><span class="line"># 插入 <span class="number">99.95</span>：整数部分<span class="number">2</span>位 <span class="operator">+</span> 小数<span class="number">2</span>位 → 总位数<span class="number">4</span>，非负数 → 成功</span><br><span class="line"><span class="keyword">insert into</span> t6 <span class="keyword">values</span>(<span class="number">99.95</span>);</span><br><span class="line"></span><br><span class="line"># 插入 <span class="number">99.99</span>：整数部分<span class="number">2</span>位 <span class="operator">+</span> 小数<span class="number">2</span>位 → 总位数<span class="number">4</span>，非负数 → 成功（达到理论最大值）</span><br><span class="line"><span class="keyword">insert into</span> t6 <span class="keyword">values</span>(<span class="number">99.99</span>);</span><br><span class="line"></span><br><span class="line"># 插入 <span class="number">99.994</span>：需四舍五入到<span class="number">2</span>位小数 → <span class="number">99.99</span>（整数<span class="number">2</span>位<span class="operator">+</span>小数<span class="number">2</span>位，总<span class="number">4</span>位）→ 成功</span><br><span class="line"><span class="keyword">insert into</span> t6 <span class="keyword">values</span>(<span class="number">99.994</span>);</span><br><span class="line"></span><br><span class="line"># 插入 <span class="number">99.995</span>：四舍五入到<span class="number">2</span>位小数 → <span class="number">100.00</span>（整数部分变为<span class="number">3</span>位，总位数<span class="operator">=</span><span class="number">3</span><span class="operator">+</span><span class="number">2</span><span class="operator">=</span><span class="number">5</span>＞<span class="number">4</span>）→ 超出范围 → 报错</span><br><span class="line"><span class="keyword">insert into</span> t6 <span class="keyword">values</span>(<span class="number">99.995</span>);</span><br><span class="line">ERROR <span class="number">1264</span> (<span class="number">22003</span>): <span class="keyword">Out</span> <span class="keyword">of</span> <span class="keyword">range</span> <span class="keyword">value</span> <span class="keyword">for</span> <span class="keyword">column</span> <span class="string">&#x27;height&#x27;</span> <span class="keyword">at</span> <span class="type">row</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="2-decimal-类型"><a href="#2-decimal-类型" class="headerlink" title="2. decimal 类型"></a>2. decimal 类型</h4><p><code>decimal</code> 和 <code>float</code> 类型的使用方式 <strong>一模一样</strong>，但 <strong><code>decimal</code> 的精度比 <code>float</code> 更高</strong>。这里就不详细讲解，类比使用：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># 创建表 t7，定义两个字段：</span><br><span class="line"># n1 为 <span class="type">float</span>(<span class="number">10</span>,<span class="number">8</span>)：单精度浮点数，总位数<span class="number">10</span>位，小数部分<span class="number">8</span>位（整数部分最多<span class="number">2</span>位）</span><br><span class="line"># n2 为 <span class="type">decimal</span>(<span class="number">10</span>,<span class="number">8</span>)：高精度小数（定点数），总位数<span class="number">10</span>位，小数部分<span class="number">8</span>位（整数部分最多<span class="number">2</span>位）</span><br><span class="line"># 对比两者在存储精度上的差异</span><br><span class="line"><span class="keyword">create table</span> t7(n1 <span class="type">float</span>(<span class="number">10</span>,<span class="number">8</span>),n2 <span class="type">decimal</span>(<span class="number">10</span>,<span class="number">8</span>));</span><br><span class="line"></span><br><span class="line"># 插入相同的数值 <span class="number">3.1415926</span>（小数部分<span class="number">7</span>位）到两个字段</span><br><span class="line"><span class="keyword">insert into</span> t7 <span class="keyword">values</span>(<span class="number">3.1415926</span>,<span class="number">3.1415926</span>);</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line"># 查询结果，观察精度差异：</span><br><span class="line"># n1（<span class="type">float</span>类型）：存储结果为 <span class="number">3.14159250</span>，与原始值有细微偏差（精度丢失）</span><br><span class="line"># 原因：<span class="type">float</span>是浮点数，用二进制近似存储，无法精确表示某些十进制小数，超过<span class="number">6</span><span class="number">-7</span>位有效数字后会失真</span><br><span class="line"># n2（<span class="type">decimal</span>类型）：存储结果为 <span class="number">3.14159260</span>，完全精确（补全<span class="number">8</span>位小数为<span class="number">9260</span>）</span><br><span class="line"># 原因：<span class="type">decimal</span>是定点数，按十进制存储，能精确表示小数，适合对精度要求高的场景（如金额）</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t7;</span><br><span class="line"><span class="operator">+</span><span class="comment">------------+------------+</span></span><br><span class="line"><span class="operator">|</span> n1         <span class="operator">|</span> n2         <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------+------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">3.14159250</span> <span class="operator">|</span> <span class="number">3.14159260</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------+------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><h2 id="3-字符串类型"><a href="#3-字符串类型" class="headerlink" title="3. 字符串类型"></a>3. 字符串类型</h2><h3 id="1-char-类型"><a href="#1-char-类型" class="headerlink" title="1. char 类型"></a>1. char 类型</h3><h4 id="1-作用-3"><a href="#1-作用-3" class="headerlink" title="1. 作用"></a>1. 作用</h4><p><code>char</code> 是一种 <strong>固定长度</strong> 的字符串类型，适用于存储长度固定或变化很小的字符串（如手机号、身份证号、性别标识等）。其核心特点是 <strong>存储空间固定，无论实际存储的字符串长度如何，都会占用预设的固定字节数。</strong></p><h4 id="2-数据范围-3"><a href="#2-数据范围-3" class="headerlink" title="2. 数据范围"></a>2. 数据范围</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>(L)</span><br></pre></td></tr></table></figure><ul><li><code>L</code> 表示字符串的长度（即最多能存储的字符数），范围是 0~255（单位：字符，不是字节）。</li><li>例如 <code>char(10)</code> 表示该字段最多存储 10 个字符，无论实际插入的字符串是 1 个还是 10 个字符，都会占用 10 个字符对应的存储空间（具体字节数取决于字符集，如 UTF8 中一个字符可能占 1~3 字节）。</li></ul><h4 id="3-基本使用-3"><a href="#3-基本使用-3" class="headerlink" title="3. 基本使用"></a>3. 基本使用</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"># 创建表 t8，定义 str 字段为 <span class="type">char</span>(<span class="number">6</span>)（固定存储<span class="number">6</span>个字符）</span><br><span class="line"><span class="keyword">create table</span> t8(str <span class="type">char</span>(<span class="number">6</span>));</span><br><span class="line"></span><br><span class="line"># 插入值时未用引号包裹&quot;minbit&quot;，MySQL会误认为是列名，导致&quot;未知列&quot;错误，注意：字符串值必须用单引号(<span class="string">&#x27;&#x27;</span>)或双引号(&quot;&quot;)包裹</span><br><span class="line"><span class="keyword">insert into</span> t8 <span class="keyword">values</span> (minbit);</span><br><span class="line">ERROR <span class="number">1054</span> (<span class="number">42</span>S22): <span class="literal">Unknown</span> <span class="keyword">column</span> <span class="string">&#x27;minbit&#x27;</span> <span class="keyword">in</span> <span class="string">&#x27;field list&#x27;</span></span><br><span class="line"></span><br><span class="line"># 用单引号包裹字符串&quot;minbit&quot;（长度<span class="number">6</span>个字符，刚好符合<span class="type">char</span>(<span class="number">6</span>)的长度）→ 插入成功</span><br><span class="line"><span class="keyword">insert into</span> t8 <span class="keyword">values</span> (<span class="string">&#x27;minbit&#x27;</span>);</span><br><span class="line"></span><br><span class="line"># 用双引号包裹字符串&quot;minbit&quot;（效果同单引号，MySQL支持单<span class="operator">/</span>双引号表示字符串）→ 插入成功</span><br><span class="line"><span class="keyword">insert into</span> t8 <span class="keyword">values</span> (&quot;minbit&quot;);</span><br><span class="line"></span><br><span class="line"># 插入字符串&quot;minbit1&quot;（长度<span class="number">7</span>个字符，超过<span class="type">char</span>(<span class="number">6</span>)定义的最大长度<span class="number">6</span>）→ 超长报错</span><br><span class="line"><span class="keyword">insert into</span> t8 <span class="keyword">values</span> (&quot;minbit1&quot;);</span><br><span class="line">ERROR <span class="number">1406</span> (<span class="number">22001</span>): Data too long <span class="keyword">for</span> <span class="keyword">column</span> <span class="string">&#x27;str&#x27;</span> <span class="keyword">at</span> <span class="type">row</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"># 插入中文字符串&quot;小米里的大麦&quot;（长度<span class="number">6</span>个汉字，每个汉字按<span class="number">1</span>个字符计数，符合<span class="type">char</span>(<span class="number">6</span>)）→ 成功</span><br><span class="line"># 说明：<span class="type">char</span>(L)中的L是&quot;字符数&quot;，不是字节数，中文也按<span class="number">1</span>个字符算（具体字节数取决于字符集）</span><br><span class="line"><span class="keyword">insert into</span> t8 <span class="keyword">values</span> (&quot;小米里的大麦&quot;);</span><br><span class="line"></span><br><span class="line"># 插入&quot;小米里的大麦1&quot;（<span class="number">6</span>个汉字<span class="operator">+</span><span class="number">1</span>个字母，共<span class="number">7</span>个字符，超过<span class="number">6</span>）→ 超长报错</span><br><span class="line"><span class="keyword">insert into</span> t8 <span class="keyword">values</span> (&quot;小米里的大麦1&quot;);</span><br><span class="line">ERROR <span class="number">1406</span> (<span class="number">22001</span>): Data too long <span class="keyword">for</span> <span class="keyword">column</span> <span class="string">&#x27;str&#x27;</span> <span class="keyword">at</span> <span class="type">row</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"># 插入字符串&quot;1&quot;（长度<span class="number">1</span>个字符，短于<span class="number">6</span>）→ 成功（MySQL会自动补<span class="number">5</span>个空格至<span class="number">6</span>个字符长度）</span><br><span class="line"><span class="keyword">insert into</span> t8 <span class="keyword">values</span> (&quot;1&quot;);</span><br><span class="line"></span><br><span class="line"># 插入空字符串&quot;&quot;（长度<span class="number">0</span>，符合<span class="type">char</span>(<span class="number">6</span>)允许的范围）→ 成功（存储<span class="number">6</span>个空格）</span><br><span class="line"><span class="keyword">insert into</span> t8 <span class="keyword">values</span> (&quot;&quot;);</span><br><span class="line"></span><br><span class="line"># 查询表中数据，注意：</span><br><span class="line"># <span class="number">1.</span> 短于<span class="number">6</span>个字符的字符串（如&quot;1&quot;），查询时自动去除末尾填充的空格，显示原始长度</span><br><span class="line"># <span class="number">2.</span> 空字符串显示为空白（实际存储<span class="number">6</span>个空格，查询时去除后为空）</span><br><span class="line"># <span class="number">3.</span> 刚好<span class="number">6</span>个字符的字符串（如&quot;minbit&quot;、&quot;小米里的大麦&quot;）原样显示</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span><span class="keyword">from</span> t8;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+</span></span><br><span class="line"><span class="operator">|</span> str                <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+</span></span><br><span class="line"><span class="operator">|</span> minbit             <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> minbit             <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 小米里的大麦       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1</span>                  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>                    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+</span></span><br></pre></td></tr></table></figure><h3 id="2-varchar-类型"><a href="#2-varchar-类型" class="headerlink" title="2. varchar 类型"></a>2. varchar 类型</h3><h4 id="1-作用-4"><a href="#1-作用-4" class="headerlink" title="1. 作用"></a>1. 作用</h4><p><code>varchar</code> 是一种 <strong>可变长度的字符串类型</strong>，适用于存储长度不固定或变化较大的字符串（如用户名、地址、备注等）。其核心特点是 <strong>存储空间随实际字符串长度变化</strong>，避免了固定长度类型（如 <code>char</code>）的空间浪费。</p><h4 id="2-数据范围-4"><a href="#2-数据范围-4" class="headerlink" title="2. 数据范围"></a>2. 数据范围</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">varchar</span>(L)</span><br></pre></td></tr></table></figure><ul><li><code>L</code> 表示字符串的最大长度（最多能存储的字符数），范围根据 MySQL 版本和存储引擎有所不同（通常为 0<del>65535，实际受表中其他字段总长度限制），**注意：其中有 1</del>2 字节用来表示实际数据长度，还有 1 字节来存储其他控制信息，因此 varchar 类型的有效字节数最多是 65532 字节。**</li><li>例如 <code>varchar(50)</code> 表示该字段最多存储 50 个字符，实际存储时会根据插入的字符串长度动态分配空间（不会像 <code>char</code> 那样固定占用 50 个字符的空间）。</li></ul><p><strong>注意：</strong> 在 MySQL 中，<code>VARCHAR</code> 类型的最大长度不是以“字符数”为上限，而是受 <strong>存储字节数</strong> 限制。理论上，单行数据总字节上限为 <strong>65535 字节</strong>（含记录开销），因此 <code>VARCHAR(L)</code> 的最大值要根据字符集计算：例如在 <code>utf8</code> 编码下，一个字符最多占 3 字节，理论上 <code>65532 ÷ 3 ≈ 21844</code>，而在 <code>gbk</code> 编码下为 <code>65532 ÷ 2 ≈ 32766</code>。但在实际中，<strong>InnoDB 存储引擎</strong>（尤其是默认 <code>COMPACT</code> 或 <code>REDUNDANT</code> 行格式）会对单个 <code>VARCHAR</code> 字段额外限制其最大存储字节数为 <strong>16383 字节</strong>，超出即报错：<code>ERROR 1074 (42000): Column length too big for column &#39;str&#39; (max = 16383); use BLOB or TEXT instead</code>。比如下面是我的配置：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"># 查看指定表（如t9）的状态信息，\G表示按行垂直显示结果（更易读）</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> <span class="keyword">TABLE</span> STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;t9&#x27;</span>\G</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">           Name: t9                  # 表名</span><br><span class="line">         Engine: InnoDB              # 存储引擎为InnoDB（MySQL默认的事务型引擎）</span><br><span class="line">        Version: <span class="number">10</span>                  # 表结构版本</span><br><span class="line">     Row_format: <span class="keyword">Dynamic</span>             # 行格式为<span class="keyword">Dynamic</span>（InnoDB动态行格式，支持变长字段高效存储）</span><br><span class="line">           <span class="keyword">Rows</span>: <span class="number">4</span>                   # 估算的行数（非精确值，InnoDB通过统计信息计算）</span><br><span class="line"> Avg_row_length: <span class="number">4096</span>                # 平均每行占用的字节数（总数据长度<span class="operator">/</span>行数）</span><br><span class="line">    Data_length: <span class="number">16384</span>               # 表数据占用的字节数（<span class="number">16384</span>字节<span class="operator">=</span><span class="number">16</span>KB，InnoDB最小分配单位）</span><br><span class="line">Max_data_length: <span class="number">0</span>                   # 表可存储的最大数据量（InnoDB不限制，故为<span class="number">0</span>）</span><br><span class="line">   Index_length: <span class="number">0</span>                   # 索引占用的字节数（该表无索引，故为<span class="number">0</span>）</span><br><span class="line">      Data_free: <span class="number">0</span>                   # 已分配但未使用的空间（该表数据紧凑，故为<span class="number">0</span>）</span><br><span class="line"> Auto_increment: <span class="keyword">NULL</span>                # 自增字段的下一个值（该表无自增字段，故为<span class="keyword">NULL</span>）</span><br><span class="line">    Create_time: <span class="number">2025</span><span class="number">-10</span><span class="number">-10</span> <span class="number">15</span>:<span class="number">00</span>:<span class="number">57</span> # 表的创建时间</span><br><span class="line">    Update_time: <span class="number">2025</span><span class="number">-10</span><span class="number">-10</span> <span class="number">15</span>:<span class="number">02</span>:<span class="number">17</span> # 表数据最后更新时间</span><br><span class="line">     Check_time: <span class="keyword">NULL</span>                # 最后一次检查表的时间（未检查过，故为<span class="keyword">NULL</span>）</span><br><span class="line">      <span class="keyword">Collation</span>: utf8mb4_general_ci  # 表的默认字符集排序规则（utf8mb4编码对应的通用排序）</span><br><span class="line">       Checksum: <span class="keyword">NULL</span>                # 表的校验和（未启用，故为<span class="keyword">NULL</span>）</span><br><span class="line"> Create_options:                     # 创建表时的额外选项（无特殊选项，故为空）</span><br><span class="line">        Comment:                     # 表的注释（无注释，故为空）</span><br><span class="line"></span><br><span class="line"># 查看数据库默认字符集（当前为utf8mb4，支持emoji和所有Unicode字符）</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;character_set_database&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">------------------------+---------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name          <span class="operator">|</span> <span class="keyword">Value</span>   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------------+---------+</span></span><br><span class="line"><span class="operator">|</span> character_set_database <span class="operator">|</span> utf8mb4 <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------------+---------+</span></span><br><span class="line"></span><br><span class="line"># 查看数据库默认排序规则（utf8mb4_general_ci为utf8mb4的通用不区分大小写排序）</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;collation_database&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+--------------------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name      <span class="operator">|</span> <span class="keyword">Value</span>              <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+--------------------+</span></span><br><span class="line"><span class="operator">|</span> collation_database <span class="operator">|</span> utf8mb4_general_ci <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+--------------------+</span></span><br><span class="line"></span><br><span class="line"># 查看InnoDB文件格式（MySQL <span class="number">8.0</span>已移除该参数，默认使用Barracuda格式，故为空）</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;innodb_file_format&#x27;</span>;</span><br><span class="line"><span class="keyword">Empty</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line"># 查看InnoDB默认行格式（<span class="keyword">Dynamic</span>为动态行格式，适合存储变长字段，节省空间）</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;innodb_default_row_format&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------+---------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name             <span class="operator">|</span> <span class="keyword">Value</span>   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------+---------+</span></span><br><span class="line"><span class="operator">|</span> innodb_default_row_format <span class="operator">|</span> <span class="keyword">dynamic</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------+---------+</span></span><br><span class="line"></span><br><span class="line"># 查看是否启用独立表空间（<span class="keyword">ON</span>表示每张表单独存储为.ibd文件，便于管理）</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;innodb_file_per_table&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------+-------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name         <span class="operator">|</span> <span class="keyword">Value</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------+-------+</span></span><br><span class="line"><span class="operator">|</span> innodb_file_per_table <span class="operator">|</span> <span class="keyword">ON</span>    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------+-------+</span></span><br><span class="line"></span><br><span class="line"># 查看MySQL服务器版本（当前为<span class="number">8.0</span><span class="number">.43</span>，基于Ubuntu <span class="number">22.04</span>系统）</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> VERSION();</span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------+</span></span><br><span class="line"><span class="operator">|</span> VERSION()               <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">8.0</span><span class="number">.43</span><span class="number">-0</span>ubuntu0<span class="number">.22</span><span class="number">.04</span><span class="number">.2</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------+</span></span><br><span class="line"></span><br><span class="line"># 查看服务器默认字符集（与数据库一致，均为utf8mb4）</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;character_set_server&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------+---------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name        <span class="operator">|</span> <span class="keyword">Value</span>   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------+---------+</span></span><br><span class="line"><span class="operator">|</span> character_set_server <span class="operator">|</span> utf8mb4 <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------+---------+</span></span><br><span class="line"></span><br><span class="line"># 查看服务器默认排序规则（与数据库一致，确保字符处理规则统一）</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;collation_server&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+--------------------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name    <span class="operator">|</span> <span class="keyword">Value</span>              <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+--------------------+</span></span><br><span class="line"><span class="operator">|</span> collation_server <span class="operator">|</span> utf8mb4_general_ci <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+--------------------+</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>配置一览</th><th>当前配置</th><th>说明</th></tr></thead><tbody><tr><td><strong>MySQL 版本</strong></td><td>8.0.43</td><td>新版 InnoDB，默认行格式已为 Dynamic</td></tr><tr><td><strong>存储引擎</strong></td><td>InnoDB</td><td>支持大字段分离存储</td></tr><tr><td><strong>行格式</strong></td><td>Dynamic</td><td>允许单行超出 8KB，字段可溢出页外存储</td></tr><tr><td><strong>字符集</strong></td><td>utf8mb4</td><td>每字符最多 4 字节</td></tr><tr><td><strong>校验规则</strong></td><td>utf8mb4_general_ci</td><td>默认排序规则</td></tr><tr><td><strong>每表独立文件</strong></td><td>ON</td><td>每张表独立存储，支持更大数据量</td></tr></tbody></table><p>我的配置只能配置 <code>varchar(16383)</code>。</p><h4 id="3-基本使用-4"><a href="#3-基本使用-4" class="headerlink" title="3. 基本使用"></a>3. 基本使用</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"># 创建表 t9，定义 str 字段为 <span class="type">varchar</span>(<span class="number">6</span>)（可变长度字符串，最大<span class="number">6</span>个字符）</span><br><span class="line"><span class="keyword">create table</span> t9(str <span class="type">varchar</span>(<span class="number">6</span>));</span><br><span class="line"></span><br><span class="line"># 插入数值<span class="number">1</span>（未加引号，MySQL会自动转为字符串&quot;1&quot;，长度<span class="number">1</span> ≤ <span class="number">6</span>）→ 成功，说明：<span class="type">varchar</span> 是字符串类型，插入数值时会隐式转换为字符串存储</span><br><span class="line"><span class="keyword">insert into</span> t9 <span class="keyword">values</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"># 插入单引号包裹的字符串&quot;minbit&quot;（长度<span class="number">6</span>个字符，刚好达到 <span class="type">varchar</span>(<span class="number">6</span>) 的最大限制）→ 成功</span><br><span class="line"><span class="keyword">insert into</span> t9 <span class="keyword">values</span>(<span class="string">&#x27;minbit&#x27;</span>);</span><br><span class="line"></span><br><span class="line"># 插入双引号包裹的中文字符串&quot;小米里的大麦&quot;（长度<span class="number">6</span>个汉字，每个汉字按<span class="number">1</span>个字符计数，符合最大长度<span class="number">6</span>）→ 成功</span><br><span class="line"># 注意：<span class="type">varchar</span>(L) 中的 L 是字符数，中文、字母、数字均按<span class="number">1</span>个字符计算</span><br><span class="line"><span class="keyword">insert into</span> t9 <span class="keyword">values</span>(&quot;小米里的大麦&quot;);</span><br><span class="line"></span><br><span class="line"># 插入&quot;小米里的大麦1&quot;（<span class="number">6</span>个汉字<span class="operator">+</span><span class="number">1</span>个数字，共<span class="number">7</span>个字符，超过 <span class="type">varchar</span>(<span class="number">6</span>) 的最大长度）→ 超长报错</span><br><span class="line"><span class="keyword">insert into</span> t9 <span class="keyword">values</span>(&quot;小米里的大麦1&quot;);</span><br><span class="line">ERROR <span class="number">1406</span> (<span class="number">22001</span>): Data too long <span class="keyword">for</span> <span class="keyword">column</span> <span class="string">&#x27;str&#x27;</span> <span class="keyword">at</span> <span class="type">row</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"># 插入空值（未指定具体值，等价于插入 <span class="keyword">NULL</span> 或空字符串，符合长度要求）→ 成功</span><br><span class="line"># <span class="type">varchar</span> 允许存储空值，此时不占用额外空间（仅存储长度标识）</span><br><span class="line"><span class="keyword">insert into</span> t9 <span class="keyword">values</span>();</span><br><span class="line"></span><br><span class="line"># 查询 t9 表中的所有数据，观察 <span class="type">varchar</span>(<span class="number">6</span>) 字段的存储结果</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span><span class="keyword">from</span> t9;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+</span></span><br><span class="line"><span class="operator">|</span> str                <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1</span>                  <span class="operator">|</span>  # 对应插入的数值<span class="number">1</span>，自动转为字符串&quot;1&quot;（长度<span class="number">1</span>，按实际长度存储）</span><br><span class="line"><span class="operator">|</span> minbit             <span class="operator">|</span>  # 插入的<span class="number">6</span>字符字符串，刚好达到<span class="type">varchar</span>(<span class="number">6</span>)的最大长度，完整存储</span><br><span class="line"><span class="operator">|</span> 小米里的大麦       <span class="operator">|</span>  # 插入的<span class="number">6</span>个汉字（<span class="number">6</span>字符），符合长度限制，完整存储（<span class="type">varchar</span>对中文按字符计数）</span><br><span class="line"><span class="operator">|</span> <span class="keyword">NULL</span>               <span class="operator">|</span>  # 对应插入的空值（<span class="keyword">values</span>()），<span class="type">varchar</span>允许存储<span class="keyword">NULL</span>，显示为<span class="keyword">NULL</span>（区别于空字符串&quot;&quot;）</span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+</span></span><br></pre></td></tr></table></figure><h3 id="3-char-VS-varchar"><a href="#3-char-VS-varchar" class="headerlink" title="3. char VS varchar"></a>3. char VS varchar</h3><h4 id="1-功能与定义差异"><a href="#1-功能与定义差异" class="headerlink" title="1. 功能与定义差异"></a>1. 功能与定义差异</h4><table><thead><tr><th>特性</th><th><strong>CHAR(L)</strong></th><th><strong>VARCHAR(L)</strong></th></tr></thead><tbody><tr><td><strong>存储方式</strong></td><td>定长（固定长度）</td><td>变长（按实际长度存储）</td></tr><tr><td><strong>最大存储上限</strong></td><td>255 个字符</td><td>与字符集和表结构相关（utf8mb4 下约 16383 字符）</td></tr><tr><td><strong>空间分配</strong></td><td>无论实际存储多少字符，都占 L 个字符空间</td><td>仅占实际字符所需空间 + 1~3 字节长度信息</td></tr><tr><td><strong>超出定义长度</strong></td><td>报错</td><td>报错</td></tr><tr><td><strong>是否需要额外字节</strong></td><td>否</td><td>是（1~3 字节记录长度）</td></tr></tbody></table><h4 id="2-性能与效率差异"><a href="#2-性能与效率差异" class="headerlink" title="2. 性能与效率差异"></a>2. 性能与效率差异</h4><table><thead><tr><th>对比项</th><th><strong>CHAR</strong></th><th><strong>VARCHAR</strong></th></tr></thead><tbody><tr><td><strong>空间利用率</strong></td><td>较低（浪费空间）</td><td>较高（按需分配）</td></tr><tr><td><strong>访问效率</strong></td><td>高（定长数据定位快）</td><td>稍低（需先解析长度字节）</td></tr><tr><td><strong>更新效率</strong></td><td>高（不易产生碎片）</td><td>低（长度变化可能导致页分裂）</td></tr><tr><td><strong>适用场景</strong></td><td>数据长度固定</td><td>数据长度不固定</td></tr></tbody></table><h3 id="4-日期和时间类型"><a href="#4-日期和时间类型" class="headerlink" title="4. 日期和时间类型"></a>4. 日期和时间类型</h3><h4 id="1-常用的三种时间日期类型"><a href="#1-常用的三种时间日期类型" class="headerlink" title="1. 常用的三种时间日期类型"></a>1. 常用的三种时间日期类型</h4><table><thead><tr><th>类型</th><th>格式</th><th>占用空间</th><th>说明</th></tr></thead><tbody><tr><td><strong>DATE</strong></td><td><code>YYYY-MM-DD</code></td><td>3 字节</td><td>只保存日期，不含时间。适合存储生日、入职日期等。</td></tr><tr><td><strong>DATETIME</strong></td><td><code>YYYY-MM-DD HH:MM:SS</code></td><td>8 字节</td><td>保存完整的日期与时间。与时区无关，适合通用业务时间记录。</td></tr><tr><td><strong>TIMESTAMP</strong></td><td><code>YYYY-MM-DD HH:MM:SS</code></td><td>4 字节</td><td>自动记录插入或更新时间，会受时区影响。常用于“创建时间”、“修改时间”等字段。</td></tr></tbody></table><h4 id="2-基本使用"><a href="#2-基本使用" class="headerlink" title="2. 基本使用"></a>2. 基本使用</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"># 创建表 t10，包含三种日期时间类型：</span><br><span class="line"># t1: <span class="type">date</span>（仅存储日期，格式YYYY<span class="operator">-</span>MM<span class="operator">-</span>DD）</span><br><span class="line"># t2: datetime（存储日期<span class="operator">+</span>时间，格式YYYY<span class="operator">-</span>MM<span class="operator">-</span>DD HH:MM:SS）</span><br><span class="line"># t3: <span class="type">timestamp</span>（存储日期<span class="operator">+</span>时间，受时区影响，默认可自动更新）</span><br><span class="line"><span class="keyword">create table</span> t10( t1 <span class="type">date</span>, t2 datetime, t3 <span class="type">timestamp</span>);</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.03</span> sec)</span><br><span class="line"></span><br><span class="line"># 查看表结构：</span><br><span class="line"># t3 字段类型为 <span class="type">timestamp</span>，但 Extra 列无特殊标识（默认不自动更新，需显式配置）</span><br><span class="line"><span class="keyword">desc</span> t10;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------+-----------+------+-----+---------+-------+</span></span><br><span class="line"><span class="operator">|</span> Field <span class="operator">|</span> Type      <span class="operator">|</span> <span class="keyword">Null</span> <span class="operator">|</span> Key <span class="operator">|</span> <span class="keyword">Default</span> <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+-----------+------+-----+---------+-------+</span></span><br><span class="line"><span class="operator">|</span> t1    <span class="operator">|</span> <span class="type">date</span>      <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> t2    <span class="operator">|</span> datetime  <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> t3    <span class="operator">|</span> <span class="type">timestamp</span> <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span>  # 无 <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="built_in">CURRENT_TIMESTAMP</span>，故不自动更新</span><br><span class="line"><span class="operator">+</span><span class="comment">-------+-----------+------+-----+---------+-------+</span></span><br><span class="line"></span><br><span class="line"># 插入时未用引号包裹日期时间值，MySQL 会解析为表达式（<span class="number">2025</span><span class="number">-01</span><span class="number">-01</span> 被当作数学计算），导致语法错误</span><br><span class="line"><span class="keyword">insert into</span> t10 (t1,t2) <span class="keyword">values</span>(<span class="number">2025</span><span class="number">-01</span><span class="number">-01</span>,<span class="number">2025</span><span class="number">-01</span><span class="number">-01</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>);</span><br><span class="line">ERROR <span class="number">1064</span> (<span class="number">42000</span>): You have an error <span class="keyword">in</span> your <span class="keyword">SQL</span> syntax; <span class="keyword">check</span> the manual that corresponds <span class="keyword">to</span> your MySQL server version <span class="keyword">for</span> the <span class="keyword">right</span> syntax <span class="keyword">to</span> use near <span class="string">&#x27;00:00:00)&#x27;</span> <span class="keyword">at</span> line <span class="number">1</span></span><br><span class="line"></span><br><span class="line"># 插入数据时，为 t1、t2 赋值（t3 未指定，默认为 <span class="keyword">NULL</span>）</span><br><span class="line"># 日期时间字符串需用单引号包裹，格式符合要求（<span class="string">&#x27;YYYY-MM-DD&#x27;</span> 或 <span class="string">&#x27;YYYY-MM-DD HH:MM:SS&#x27;</span>）</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">insert into</span> t10 (t1,t2) <span class="keyword">values</span>(<span class="string">&#x27;2025-01-01&#x27;</span>,<span class="string">&#x27;2025-01-01 00:00:00&#x27;</span>);  # 完整语句补全后</span><br><span class="line"></span><br><span class="line"># 用双引号包裹日期时间字符串（效果同单引号），符合语法规则，插入成功</span><br><span class="line"><span class="keyword">insert into</span> t10 (t1,t2) <span class="keyword">values</span>(&quot;2025-01-01&quot;,&quot;2025-01-01 00:00:00&quot;);</span><br><span class="line"></span><br><span class="line"># 查询结果：t3 均为 <span class="keyword">NULL</span>（因插入时未赋值，且未配置自动更新）</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span><span class="keyword">from</span> t10;</span><br><span class="line"><span class="operator">+</span><span class="comment">------------+---------------------+------+</span></span><br><span class="line"><span class="operator">|</span> t1         <span class="operator">|</span> t2                  <span class="operator">|</span> t3   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------+---------------------+------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">2025</span><span class="number">-01</span><span class="number">-01</span> <span class="operator">|</span> <span class="number">2025</span><span class="number">-01</span><span class="number">-01</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>  # t3 未赋值，保持 <span class="keyword">NULL</span></span><br><span class="line"><span class="operator">|</span> <span class="number">2025</span><span class="number">-01</span><span class="number">-01</span> <span class="operator">|</span> <span class="number">2025</span><span class="number">-01</span><span class="number">-01</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>  # t3 未赋值，保持 <span class="keyword">NULL</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------+---------------------+------+</span></span><br></pre></td></tr></table></figure><p>注意：<code>default current_timestamp on update current_timestamp</code> 这类规则只能在 <strong>创建表时定义字段</strong> 或 <strong>修改表结构时</strong> 配置，不能在 <code>insert</code> 语句中直接使用！必须在 <code>create table</code> 或 <code>alter table</code> 时声明，属于表结构的一部分！<strong>创建表时配置规则</strong>（推荐）：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create table</span> t11(</span><br><span class="line">  t1 <span class="type">date</span>,</span><br><span class="line">  t2 datetime,</span><br><span class="line">  t3 <span class="type">timestamp</span> <span class="keyword">default</span> <span class="built_in">current_timestamp</span> <span class="keyword">on</span> <span class="keyword">update</span> <span class="built_in">current_timestamp</span>  # 定义时配置规则</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert into</span> t11 (t3) <span class="keyword">values</span> (<span class="keyword">default</span>);  # 使用 t3 字段定义的默认值（当前时间）</span><br></pre></td></tr></table></figure><p><strong>对于已存在的表，用 <code>alter table</code> 补充规则：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter table</span> t11</span><br><span class="line">modify <span class="keyword">column</span> t3 <span class="type">timestamp</span> </span><br><span class="line"><span class="keyword">default</span> <span class="built_in">current_timestamp</span> <span class="keyword">on</span> <span class="keyword">update</span> <span class="built_in">current_timestamp</span>;</span><br></pre></td></tr></table></figure><h3 id="5-enum-和-set"><a href="#5-enum-和-set" class="headerlink" title="5. enum 和 set"></a>5. enum 和 set</h3><h4 id="1-enum-类型（枚举）"><a href="#1-enum-类型（枚举）" class="headerlink" title="1. enum 类型（枚举）"></a>1. enum 类型（枚举）</h4><p><code>enum</code> 用于存储 “多选一” 的值，即字段值只能是预定义选项中的 <strong>一个</strong>。</p><h5 id="1-数据范围"><a href="#1-数据范围" class="headerlink" title="1. 数据范围"></a>1. 数据范围</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enum(<span class="string">&#x27;值1&#x27;</span>, <span class="string">&#x27;值2&#x27;</span>, ..., <span class="string">&#x27;值n&#x27;</span>)</span><br></pre></td></tr></table></figure><p>选项列表最多支持 65535 个值（实际使用中通常远少于此），选项区分大小写（取决于表的字符集排序规则，如 <code>utf8mb4_general_ci</code> 不区分大小写，<code>utf8mb4_bin</code> 区分）。</p><h5 id="2-基本使用-1"><a href="#2-基本使用-1" class="headerlink" title="2. 基本使用"></a>2. 基本使用</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"># 创建表 t12，定义 gender 为 enum 类型（枚举，只能从预定义选项中选一个）</span><br><span class="line"># enum(<span class="string">&#x27;男&#x27;</span>,&quot;女&quot;,<span class="string">&#x27;未知&#x27;</span>) 表示可选值为 <span class="string">&#x27;男&#x27;</span>、<span class="string">&#x27;女&#x27;</span>、<span class="string">&#x27;未知&#x27;</span>（单<span class="operator">/</span>双引号均可）</span><br><span class="line"><span class="keyword">create table</span> t12(</span><br><span class="line">    id <span class="type">int</span>,</span><br><span class="line">    gender enum(<span class="string">&#x27;男&#x27;</span>,&quot;女&quot;,<span class="string">&#x27;未知&#x27;</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"># 插入符合 enum 选项的值（单<span class="operator">/</span>双引号包裹均可），均成功</span><br><span class="line"><span class="keyword">insert into</span> t12 <span class="keyword">values</span></span><br><span class="line">(<span class="number">1</span>,<span class="string">&#x27;男&#x27;</span>),    # 选 <span class="string">&#x27;男&#x27;</span></span><br><span class="line">(<span class="number">2</span>,&quot;女&quot;),    # 选 <span class="string">&#x27;女&#x27;</span>（双引号）</span><br><span class="line">(<span class="number">3</span>,<span class="string">&#x27;未知&#x27;</span>);  # 选 <span class="string">&#x27;未知</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 插入未在 enum 选项中的值 &#x27;</span>保密<span class="string">&#x27; → 不符合预定义范围，报错，错误提示：字段值被截断（实际因值不在选项中，无法存储）</span></span><br><span class="line"><span class="string">insert into t12 values (4,&quot;保密&quot;);</span></span><br><span class="line"><span class="string">ERROR 1265 (01000): Data truncated for column &#x27;</span>gender<span class="string">&#x27; at row 1</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 插入数字 1 → enum 支持用数字索引（从1开始）表示选项，1 对应第一个选项 &#x27;</span>男<span class="string">&#x27; → 成功</span></span><br><span class="line"><span class="string">insert into t12 values (4,1);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 插入数字 3 → 3 对应第三个选项 &#x27;</span>未知<span class="string">&#x27; → 成功</span></span><br><span class="line"><span class="string">insert into t12 values (4,3);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 插入数字 4 → enum 选项只有3个（索引1~3），4 超出范围 → 报错</span></span><br><span class="line"><span class="string">insert into t12 values (4,4);</span></span><br><span class="line"><span class="string">ERROR 1265 (01000): Data truncated for column &#x27;</span>gender<span class="string">&#x27; at row 1</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 查询结果：</span></span><br><span class="line"><span class="string"># 数字索引会自动转换为对应的选项值（1→&#x27;</span>男<span class="string">&#x27;，3→&#x27;</span>未知<span class="string">&#x27;）</span></span><br><span class="line"><span class="string">select * from t12;</span></span><br><span class="line"><span class="string">+------+--------+</span></span><br><span class="line"><span class="string">| id   | gender |</span></span><br><span class="line"><span class="string">+------+--------+</span></span><br><span class="line"><span class="string">|    1 | 男     |  # 直接插入 &#x27;</span>男<span class="string">&#x27;</span></span><br><span class="line"><span class="string">|    2 | 女     |  # 直接插入 &#x27;</span>女<span class="string">&#x27;</span></span><br><span class="line"><span class="string">|    3 | 未知   |  # 直接插入 &#x27;</span>未知<span class="string">&#x27;</span></span><br><span class="line"><span class="string">|    4 | 男     |  # 插入 1 → 对应 &#x27;</span>男<span class="string">&#x27;</span></span><br><span class="line"><span class="string">|    4 | 未知   |  # 插入 3 → 对应 &#x27;</span>未知<span class="string">&#x27;</span></span><br><span class="line"><span class="string">+------+--------+</span></span><br></pre></td></tr></table></figure><h4 id="2-set-类型（集合）"><a href="#2-set-类型（集合）" class="headerlink" title="2. set 类型（集合）"></a>2. set 类型（集合）</h4><p><code>set</code> 用于存储 “多选多” 的值，即字段值可以是预定义选项中的 <strong>多个（0 个或多个）</strong>，值之间用逗号分隔。</p><h5 id="1-数据范围-1"><a href="#1-数据范围-1" class="headerlink" title="1. 数据范围"></a>1. 数据范围</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(<span class="string">&#x27;值1&#x27;</span>, <span class="string">&#x27;值2&#x27;</span>, ..., <span class="string">&#x27;值n&#x27;</span>)</span><br></pre></td></tr></table></figure><p>选项列表最多支持 64 个值（因存储方式限制），选项同样区分大小写（规则同 <code>enum</code>）。</p><h5 id="2-基本使用-2"><a href="#2-基本使用-2" class="headerlink" title="2. 基本使用"></a>2. 基本使用</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"># 创建表 t13，定义 s 为 <span class="keyword">set</span> 类型（集合，可从预定义选项中选多个值）</span><br><span class="line"># <span class="keyword">set</span>(<span class="string">&#x27;吃饭&#x27;</span>,&quot;睡觉&quot;,<span class="string">&#x27;打豆豆&#x27;</span>,&quot;编码&quot;) 表示可选值为这<span class="number">4</span>个，支持多选（用逗号分隔）</span><br><span class="line"><span class="keyword">create table</span> t13 (</span><br><span class="line">    id <span class="type">int</span>,</span><br><span class="line">    s <span class="keyword">set</span>(<span class="string">&#x27;吃饭&#x27;</span>,&quot;睡觉&quot;,<span class="string">&#x27;打豆豆&#x27;</span>,&quot;编码&quot;)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"># 插入符合 <span class="keyword">set</span> 规则的值（单<span class="operator">/</span>双引号均可）：</span><br><span class="line"># <span class="number">1.</span> 选<span class="number">1</span>个值；<span class="number">2.</span> 空值（选<span class="number">0</span>个）；<span class="number">3.</span> 选多个值（用逗号分隔）；<span class="number">4.</span> 选<span class="number">1</span>个值</span><br><span class="line"><span class="keyword">insert into</span> t13 <span class="keyword">values</span></span><br><span class="line">(<span class="number">1</span>,<span class="string">&#x27;吃饭&#x27;</span>),</span><br><span class="line">(<span class="number">2</span>,&quot;&quot;),  # 空字符串表示不选任何值</span><br><span class="line">(<span class="number">3</span>,&quot;吃饭,睡觉,编码&quot;),  # 多选值用逗号分隔</span><br><span class="line">(<span class="number">4</span>,<span class="string">&#x27;编码&#x27;</span>);</span><br><span class="line"></span><br><span class="line"># 插入重复值 <span class="string">&#x27;吃饭,吃饭&#x27;</span> → <span class="keyword">set</span> 会自动去重，存储为 <span class="string">&#x27;吃饭&#x27;</span> → 成功</span><br><span class="line"><span class="keyword">insert into</span> t13 <span class="keyword">values</span> (<span class="number">5</span>,<span class="string">&#x27;吃饭,吃饭&#x27;</span>);</span><br><span class="line"></span><br><span class="line"># 插入未在 <span class="keyword">set</span> 选项中的 <span class="string">&#x27;打游戏&#x27;</span> → 不在预定义范围，报错</span><br><span class="line"><span class="keyword">insert into</span> t13 <span class="keyword">values</span> (<span class="number">5</span>,&quot;打游戏&quot;);</span><br><span class="line">ERROR <span class="number">1265</span> (<span class="number">01000</span>): Data truncated <span class="keyword">for</span> <span class="keyword">column</span> <span class="string">&#x27;s&#x27;</span> <span class="keyword">at</span> <span class="type">row</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"># 插入数字 <span class="number">11</span> → <span class="keyword">set</span> 支持用二进制位对应的数字表示选项（每个选项对应一个位，从左到右为 <span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">8.</span>..）</span><br><span class="line"># 选项对应关系：<span class="string">&#x27;吃饭&#x27;</span><span class="operator">=</span><span class="number">1</span>（<span class="number">2</span><span class="operator">^</span><span class="number">0</span>）、<span class="string">&#x27;睡觉&#x27;</span><span class="operator">=</span><span class="number">2</span>（<span class="number">2</span><span class="operator">^</span><span class="number">1</span>）、<span class="string">&#x27;打豆豆&#x27;</span><span class="operator">=</span><span class="number">4</span>（<span class="number">2</span><span class="operator">^</span><span class="number">2</span>）、<span class="string">&#x27;编码&#x27;</span><span class="operator">=</span><span class="number">8</span>（<span class="number">2</span><span class="operator">^</span><span class="number">3</span>）</span><br><span class="line"># <span class="number">11</span> <span class="operator">=</span> <span class="number">8</span> <span class="operator">+</span> <span class="number">2</span> <span class="operator">+</span> <span class="number">1</span> → 对应 <span class="string">&#x27;吃饭,睡觉,编码&#x27;</span> → 成功</span><br><span class="line"><span class="keyword">insert into</span> t13 <span class="keyword">values</span> (<span class="number">5</span>,<span class="number">11</span>);</span><br><span class="line"></span><br><span class="line"># 插入数字 <span class="number">10</span> → <span class="number">10</span> <span class="operator">=</span> <span class="number">8</span> <span class="operator">+</span> <span class="number">2</span> → 对应 <span class="string">&#x27;睡觉,编码&#x27;</span> → 成功</span><br><span class="line"><span class="keyword">insert into</span> t13 <span class="keyword">values</span> (<span class="number">5</span>,<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"># 插入数字 <span class="number">000</span>（即 <span class="number">0</span>）→ <span class="number">0</span> 表示不选任何值（等价于空字符串）→ 成功</span><br><span class="line"><span class="keyword">insert into</span> t13 <span class="keyword">values</span> (<span class="number">5</span>,<span class="number">000</span>);</span><br><span class="line"></span><br><span class="line"># 插入数字 <span class="number">0001</span>（即 <span class="number">1</span>）→ <span class="number">1</span> 对应 <span class="string">&#x27;吃饭&#x27;</span> → 成功</span><br><span class="line"><span class="keyword">insert into</span> t13 <span class="keyword">values</span> (<span class="number">5</span>,<span class="number">0001</span>);</span><br><span class="line"></span><br><span class="line"># 插入数字 <span class="number">1111</span> → 该 <span class="keyword">set</span> 只有<span class="number">4</span>个选项（最大对应数字 <span class="number">1</span><span class="operator">+</span><span class="number">2</span><span class="operator">+</span><span class="number">4</span><span class="operator">+</span><span class="number">8</span><span class="operator">=</span><span class="number">15</span>），<span class="number">1111</span> 超出范围（<span class="number">1111</span>是十进制<span class="number">4369</span>）→ 报错</span><br><span class="line"><span class="keyword">insert into</span> t13 <span class="keyword">values</span> (<span class="number">5</span>,<span class="number">1111</span>);</span><br><span class="line">ERROR <span class="number">1265</span> (<span class="number">01000</span>): Data truncated <span class="keyword">for</span> <span class="keyword">column</span> <span class="string">&#x27;s&#x27;</span> <span class="keyword">at</span> <span class="type">row</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"># 查询结果：</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span><span class="keyword">from</span> t13;</span><br><span class="line"><span class="operator">+</span><span class="comment">------+----------------------+</span></span><br><span class="line"><span class="operator">|</span> id   <span class="operator">|</span> s                    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+----------------------+</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span> 吃饭                 <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span>                      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">3</span> <span class="operator">|</span> 吃饭,睡觉,编码       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">4</span> <span class="operator">|</span> 编码                 <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">5</span> <span class="operator">|</span> 吃饭                 <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">5</span> <span class="operator">|</span> 吃饭,睡觉,编码       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">5</span> <span class="operator">|</span> 睡觉,编码            <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">5</span> <span class="operator">|</span>                      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">5</span> <span class="operator">|</span> 吃饭                 <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+----------------------+</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;数据类型&quot;&gt;&lt;a href=&quot;#数据类型&quot; class=&quot;headerlink&quot; title=&quot;数据类型&quot;&gt;&lt;/a&gt;数据类型&lt;/h1&gt;&lt;h2 id=&quot;1-常用数据类型一览&quot;&gt;&lt;a href=&quot;#1-常用数据类型一览&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    <category term="MySQL" scheme="https://www.minbit.top/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="https://www.minbit.top/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>056 高级 IO</title>
    <link href="https://www.minbit.top/posts/7814.html"/>
    <id>https://www.minbit.top/posts/7814.html</id>
    <published>2025-10-14T04:00:00.000Z</published>
    <updated>2025-10-22T04:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="高级-IO"><a href="#高级-IO" class="headerlink" title="高级 IO"></a>高级 IO</h1><blockquote><p><a href="https://blog.csdn.net/chenlong_cxy/article/details/126050039">Linux 高级 IO | CSDN</a></p></blockquote><h2 id="1-正确认识-IO"><a href="#1-正确认识-IO" class="headerlink" title="1. 正确认识 IO"></a>1. 正确认识 IO</h2><h3 id="1-IO-的本质"><a href="#1-IO-的本质" class="headerlink" title="1. IO 的本质"></a>1. IO 的本质</h3><p>I&#x2F;O（Input &#x2F; Output）指的是 <strong>CPU 与外设之间的数据交互过程</strong>。在冯·诺依曼结构中，系统由：<strong>CPU</strong>（运算与控制）、<strong>内存</strong>（暂存数据与指令）、<strong>外设</strong>（磁盘、网卡、显示器、键盘等）组成。</p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Blog/20250623200921613.png"></p><p>I&#x2F;O 就是：数据在「内存 ↔ 外设」之间的传输。所以：</p><ul><li><strong>输入（Input）</strong>：外设 → 内存（例如：键盘输入、磁盘读文件、网卡收包）。</li><li><strong>输出（Output）</strong>：内存 → 外设（例如：屏幕显示、磁盘写文件、网卡发包）。</li></ul><h3 id="2-IO-的关键特征"><a href="#2-IO-的关键特征" class="headerlink" title="2. IO 的关键特征"></a>2. IO 的关键特征</h3><ol><li><strong>慢</strong>：外设的速度远慢于 CPU 和内存。因此，IO 通常是性能瓶颈。</li><li><strong>异步性</strong>：外设工作时 CPU 可去做别的事。操作系统通过 <strong>中断、DMA（直接内存访问）</strong> 来提高效率。</li></ol><h3 id="3-文件-IO-与-网络-IO"><a href="#3-文件-IO-与-网络-IO" class="headerlink" title="3. 文件 IO 与 网络 IO"></a>3. 文件 IO 与 网络 IO</h3><table><thead><tr><th>IO 类型</th><th>外设</th><th>操作系统抽象</th><th>本质</th></tr></thead><tbody><tr><td>文件 IO</td><td>磁盘</td><td>文件描述符（fd）</td><td>把数据从磁盘读入内存或写出</td></tr><tr><td>网络 IO</td><td>网卡</td><td>套接字（socket）</td><td>把数据从网卡缓冲区读入内存或写出</td></tr></tbody></table><p>对操作系统来说，<strong>一切皆文件</strong>，无论是磁盘文件、管道、套接字，本质都是「文件描述符 + 缓冲区」上的读写操作。</p><h3 id="4-系统调用层面"><a href="#4-系统调用层面" class="headerlink" title="4. 系统调用层面"></a>4. 系统调用层面</h3><p>C&#x2F;C++ 层面对 IO 的最底层接口如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span></span>;   <span class="comment">// 从 fd 读数据到内存</span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span></span>;  <span class="comment">// 从内存写数据到 fd</span></span><br></pre></td></tr></table></figure><ul><li>读文件时，数据路径是：磁盘 → 内核缓存 → 用户内存。</li><li>读网络时，数据路径是：网卡 → 内核缓冲区 → 用户内存。</li></ul><blockquote><p><strong>应用层 <code>read</code> &amp;&amp; <code>write</code> 的时候，本质就是把数据从用户层写给 OS，即“拷贝函数”。此时我们只需要知道：<span style="color:#FF0000;">IO &#x3D; 等 + 拷贝</span>。要进行拷贝，必须先判断读写事件这个条件成立！</strong></p><p><strong>什么叫做高效 IO 呢？知道 IO &#x3D; 等 + 拷贝后，就可以得出结论：单位时间内，IO 的过程中，等的比重越小，IO 效率越高！反之，等的比重越大，IO 效率越低。几乎所有提高 IO 效率的策略，本质就是这个！</strong></p></blockquote><hr><h2 id="2-五种-IO-模型"><a href="#2-五种-IO-模型" class="headerlink" title="2. 五种 IO 模型"></a>2. 五种 IO 模型</h2><h3 id="1-小故事入题"><a href="#1-小故事入题" class="headerlink" title="1. 小故事入题"></a>1. 小故事入题</h3><ol><li><p>张三是个钓鱼佬，他的钓鱼方式是一根儿鱼竿儿，钓鱼时就一直一动不动地盯着鱼漂，直到有鱼上钩。在这段时间内他不能干别的事，我们管这种方式叫做 <strong>阻塞式 IO</strong>。</p><ul><li>对应到计算机上：<code>read()</code> 一调用，就会 <strong>阻塞当前线程</strong>，操作系统先等数据准备好（等待阶段），数据准备好后，再拷贝到用户空间（拷贝阶段），两步都做完，<code>read()</code> 才返回。<strong>特点</strong>：简单、直观，但效率最低。CPU 在“等鱼”的时间被浪费掉。</li></ul></li><li><p>李四也是钓鱼佬，他也是一根儿鱼竿儿，但他的钓鱼方式是：抛完杆儿，等一会了去喝个茶回来看一看上没上鱼，看会书回来看一看，睡一觉回来看一看，跟张三说完话回来看一看（张三并不想搭理李四），这种方式叫做 <strong>非阻塞式 IO，即非阻塞轮询，特点：</strong> 线程不会被卡死，但 CPU 不停在空转查询，效率依然不高（多线程或高并发场景中非常浪费 CPU）。</p></li><li><p>王五一样，但是他很聪明，他在鱼竿上绑了一个铃铛，期间可以看书、睡觉、打游戏，摸鱼……当铃铛响了说明上鱼了，才去看鱼竿儿，这属于 <strong>信号驱动式 IO</strong>。</p><ul><li>系统上：程序先注册一个信号回调函数（<code>sigaction</code>），当内核检测到数据可读时，会发信号通知用户进程，用户进程再调用 <code>read()</code> 把数据拷贝到用户空间。<strong>特点</strong>：通过信号机制通知事件，比轮询更高效。但信号机制复杂、调度开销大，所以实际使用较少。</li></ul></li><li><p>赵六是个有钱人，他直接开了一大卡车的鱼竿儿，机械化钓鱼，就假设他布置好了 1000 根鱼竿儿，他不可能盯着每一根，于是雇了个助手，<br>助手负责统一盯着所有鱼竿，一旦某根竿有动静就通知他。此时水里的鱼是一定的，但赵六上鱼的概率远远高于其他人，这就是 <strong>多路复用&#x2F;转接。</strong></p><ul><li><strong>这就是 select&#x2F;poll&#x2F;epoll 的核心思想。</strong> 系统提供一个统一的接口，一次性监听多个文件描述符（鱼竿），当其中任意一个“准备就绪”时再通知进程。<strong>特点</strong>：可同时管理大量连接（高并发）、赵六只需要等“通知”即可，效率大大提升、是高性能网络服务器（如 Nginx、Redis）最常用的模式。</li></ul></li><li><p>田七照样是个有钱人，看到他们在钓鱼，于是也想吃鱼，就准备一起，但是很不巧临时有事要走，他一想：我就想吃鱼，怎么来的不重要，于是就叫随行的司机拿着工具去钓鱼，田七则去办其他的事情，告诉司机等他钓好鱼后直接给他打电话就行。这就是 <strong>异步 IO，值得注意的是这里的司机其实就是 OS</strong>。</p><ul><li>系统中：用户调用 <code>aio_read()</code> 之后立即返回，操作系统后台完成“数据准备 + 拷贝”两个阶段，完成后通过事件或回调通知应用。<strong>特点</strong>：真正的 <strong>非阻塞 + 无等待</strong>，CPU 可以同时干别的工作，适用于 I&#x2F;O 密集型高并发场景。</li></ul></li></ol><p>我们知道 <strong>IO &#x3D; 等 + 拷贝</strong>，所有 IO 模型的区别，都在于这两个阶段是 <strong>谁在做</strong>、<strong>怎么做</strong>。在这个钓鱼的过程中只有田七是异步 IO，其他人都属于同步 IO，因为其他人都直接参与了等的环节，但田七则是间接做了等的操作，实际不参与 IO，田七只是发起 IO，最后拿结果就行，就像我交给你一个黑盒，我不管你干了什么，到时候我从黑盒中拿结果就行。还有一点就是同步 IO 是&#x2F;属于线程同步吗？答案是老婆和老婆饼的关系 —— 没有关系！</p><h3 id="2-深入理解-IO-等-拷贝-的思维模型"><a href="#2-深入理解-IO-等-拷贝-的思维模型" class="headerlink" title="2. 深入理解 IO &#x3D; 等 + 拷贝 的思维模型"></a>2. 深入理解 IO &#x3D; 等 + 拷贝 的思维模型</h3><p>无论哪种 IO，本质都要经历两个阶段：</p><ol><li><strong>等待数据准备好</strong>（等待鱼上钩）。</li><li><strong>数据从内核缓冲区拷贝到用户空间</strong>（把鱼拽上来）。</li></ol><p>区别在于：谁来“等”（线程自己、统一管理者、还是操作系统），什么时候返回（等完再返回，还是先返回之后回调）。</p><table><thead><tr><th>模型类型</th><th>等待阶段</th><th>拷贝阶段</th><th>是否阻塞</th><th>谁来等</th><th>典型调用</th><th>适用场景</th></tr></thead><tbody><tr><td>阻塞 I&#x2F;O</td><td>阻塞</td><td>阻塞</td><td>是</td><td>应用线程</td><td><code>read()</code></td><td>简单场景</td></tr><tr><td>非阻塞 I&#x2F;O</td><td>轮询</td><td>阻塞</td><td>否（轮询）</td><td>应用线程</td><td><code>fcntl(fd, O_NONBLOCK)</code></td><td>少量连接</td></tr><tr><td>信号驱动 I&#x2F;O</td><td>信号触发</td><td>阻塞</td><td>否</td><td>内核发信号</td><td><code>sigaction()</code></td><td>特殊场合</td></tr><tr><td>I&#x2F;O 多路复用</td><td>阻塞等待事件</td><td>阻塞拷贝</td><td>部分阻塞</td><td>统一等待者（select&#x2F;poll&#x2F;epoll）</td><td>高并发服务器</td><td>高性能</td></tr><tr><td>异步 I&#x2F;O</td><td>非阻塞</td><td>非阻塞</td><td>否</td><td>全交给内核</td><td><code>aio_read()</code></td><td>真正异步场景</td></tr></tbody></table><hr><h2 id="3-fcntl-函数原型"><a href="#3-fcntl-函数原型" class="headerlink" title="3. fcntl 函数原型"></a>3. <code>fcntl</code> 函数原型</h2><h3 id="1-功能-作用"><a href="#1-功能-作用" class="headerlink" title="1. 功能 &#x2F; 作用"></a>1. 功能 &#x2F; 作用</h3><p><code>fcntl()</code> —— 它是 Linux 文件描述符控制的“瑞士军刀”，非常常见于网络编程和 I&#x2F;O 模型设置中，比如设置非阻塞套接字。<code>fcntl()</code>（file control）用于 <strong>对已打开的文件描述符进行各种控制操作</strong>。几乎所有“修改文件描述符行为”的操作都要通过它完成，例如：设置 &#x2F; 清除文件描述符的标志（如非阻塞模式）、获取 &#x2F; 修改文件状态、复制文件描述符、锁定文件、调整文件特性等。</p><h3 id="2-函数原型"><a href="#2-函数原型" class="headerlink" title="2. 函数原型"></a>2. 函数原型</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fcntl</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> cmd, ... <span class="comment">/* arg */</span>)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="3-参数详解"><a href="#3-参数详解" class="headerlink" title="3. 参数详解"></a>3. 参数详解</h3><table><thead><tr><th>参数位置</th><th>含义</th></tr></thead><tbody><tr><td><strong>第 1 个参数：fd</strong></td><td>要操作哪个文件描述符（文件、socket 等）</td></tr><tr><td><strong>第 2 个参数：cmd</strong></td><td>要执行的命令&#x2F;控制操作（告诉内核你想干什么）</td></tr><tr><td><strong>第 3 个参数：arg（可选）</strong></td><td>如果需要，就传入新的标志值（常用“旧标志 | 新功能”）</td></tr></tbody></table><h4 id="1-第二个参数（cmd）——-要执行的操作类型"><a href="#1-第二个参数（cmd）——-要执行的操作类型" class="headerlink" title="1. 第二个参数（cmd）—— 要执行的操作类型"></a>1. 第二个参数（cmd）—— 要执行的操作类型</h4><table><thead><tr><th>命令（cmd）</th><th>含义</th><th>第三个参数（arg）</th><th>常用场景</th></tr></thead><tbody><tr><td><strong>F_GETFL</strong></td><td>获取文件状态标志</td><td>无</td><td>读取当前 fd 的打开模式（只读、非阻塞等）</td></tr><tr><td><strong>F_SETFL</strong></td><td>设置文件状态标志</td><td>新标志（通常是“旧标志 | 新标志”）</td><td>修改 fd 行为，如设为非阻塞</td></tr><tr><td><strong>F_GETFD</strong></td><td>获取文件描述符标志</td><td>无</td><td>判断 fd 是否带有 FD_CLOEXEC</td></tr><tr><td><strong>F_SETFD</strong></td><td>设置文件描述符标志</td><td><code>FD_CLOEXEC</code> 等</td><td>设置执行 exec() 时是否自动关闭 fd</td></tr><tr><td><strong>F_DUPFD</strong></td><td>复制一个新的文件描述符</td><td>最小可用 fd 编号</td><td>类似 dup()，但可指定起始编号</td></tr><tr><td><strong>F_SETLK</strong></td><td>设置文件锁（非阻塞）</td><td><code>struct flock *</code></td><td>文件加锁，不会阻塞</td></tr><tr><td><strong>F_SETLKW</strong></td><td>设置文件锁（阻塞）</td><td><code>struct flock *</code></td><td>文件加锁，会阻塞等待</td></tr><tr><td><strong>F_GETLK</strong></td><td>获取文件锁状态</td><td><code>struct flock *</code></td><td>查询当前文件锁</td></tr></tbody></table><p>实际开发中 <strong>最常用的就是 <code>F_GETFL</code> 和 <code>F_SETFL</code></strong>，尤其用于：设置非阻塞 IO（<code>O_NONBLOCK</code>）、设置追加写（<code>O_APPEND</code>）。</p><h4 id="2-第三个参数（arg）——-状态标志"><a href="#2-第三个参数（arg）——-状态标志" class="headerlink" title="2. 第三个参数（arg）—— 状态标志"></a>2. 第三个参数（arg）—— 状态标志</h4><table><thead><tr><th>标志</th><th>含义</th><th>常见场景</th></tr></thead><tbody><tr><td><strong>O_RDONLY</strong></td><td>只读打开</td><td>打开文件用</td></tr><tr><td><strong>O_WRONLY</strong></td><td>只写打开</td><td>打开文件用</td></tr><tr><td><strong>O_RDWR</strong></td><td>可读可写</td><td>打开文件用</td></tr><tr><td><strong>O_APPEND</strong></td><td>写操作追加到文件末尾</td><td>日志文件</td></tr><tr><td><strong>O_NONBLOCK</strong></td><td>非阻塞模式</td><td>网络 I&#x2F;O</td></tr><tr><td><strong>O_SYNC</strong></td><td>同步写入（每次写都落盘）</td><td>文件系统安全要求高的场景</td></tr><tr><td><strong>O_ASYNC</strong></td><td>异步 I&#x2F;O 模式</td><td>很少单独使用</td></tr><tr><td><strong>O_CREAT</strong></td><td>不存在则创建</td><td>文件打开</td></tr><tr><td><strong>O_TRUNC</strong></td><td>打开时清空文件内容</td><td>文件重写</td></tr><tr><td><strong>FD_CLOEXEC</strong></td><td>执行 exec() 时自动关闭 fd</td><td>防止文件描述符泄漏</td></tr></tbody></table><h4 id="3-快速记忆法"><a href="#3-快速记忆法" class="headerlink" title="3. 快速记忆法"></a>3. 快速记忆法</h4><table><thead><tr><th>操作类型</th><th>缩写记忆</th><th>用途</th></tr></thead><tbody><tr><td><code>F_GETFL</code> &#x2F; <code>F_SETFL</code></td><td>FL &#x3D; File status Flags</td><td>控制读写行为</td></tr><tr><td><code>F_GETFD</code> &#x2F; <code>F_SETFD</code></td><td>FD &#x3D; File Descriptor</td><td>控制描述符自身属性</td></tr><tr><td><code>O_NONBLOCK</code></td><td>Non-blocking</td><td>设置非阻塞</td></tr><tr><td><code>FD_CLOEXEC</code></td><td>Close on exec</td><td>执行新程序时关闭 fd</td></tr></tbody></table><h3 id="4-返回值"><a href="#4-返回值" class="headerlink" title="4. 返回值"></a>4. 返回值</h3><ul><li><strong>成功：</strong> 返回值依赖于 <code>cmd</code>，一般为 <strong>非负数</strong>。</li><li><strong>失败：</strong> 返回 <strong>-1</strong>，并设置 <code>errno</code>。</li></ul><h3 id="5-示例：设置非阻塞套接字"><a href="#5-示例：设置非阻塞套接字" class="headerlink" title="5. 示例：设置非阻塞套接字"></a>5. 示例：设置非阻塞套接字</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setNoBlock</span><span class="params">(<span class="type">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> fl = <span class="built_in">fcntl</span>(fd, F_GETFL);                <span class="comment">// 获取原来文件描述符的属性</span></span><br><span class="line">    <span class="keyword">if</span>(fl &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;fcntl&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fcntl</span>(fd, F_GETFL, fl | O_NONBLOCK);        <span class="comment">// 在原标志基础上加上非阻塞</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;设置 &quot;</span> &lt;&lt; fd &lt;&lt; <span class="string">&quot; 为非阻塞模式成功！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">setNoBlock</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// printf(&quot;please enter: &quot;);</span></span><br><span class="line">        <span class="comment">// fflush(stdout);</span></span><br><span class="line"></span><br><span class="line">        <span class="type">ssize_t</span> n = <span class="built_in">read</span>(<span class="number">0</span>, buffer, <span class="built_in">sizeof</span>(buffer) - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(n &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            buffer[n - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;echo: &quot;</span> &lt;&lt; buffer &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;read EOF/read done!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cerr &lt;&lt; <span class="string">&quot;read error, n = &quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&quot;error code: &quot;</span> &lt;&lt; errno &lt;&lt; <span class="string">&quot;error string: &quot;</span> &lt;&lt; <span class="built_in">strerror</span>(errno) &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>设置成为非阻塞，如果底层 fd 数据没有就绪，recv&#x2F;read&#x2F;write&#x2F;send, 返回值会以出错的形式返回，错误形式的两种情况：a. 真的出错，b. 底层没有就绪。怎么区分呢？需要通过 errno 区分！！！</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> sockfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);  <span class="comment">// 创建 TCP 套接字</span></span><br><span class="line">    <span class="keyword">if</span> (sockfd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;socket error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前文件状态标志</span></span><br><span class="line">    <span class="type">int</span> flags = <span class="built_in">fcntl</span>(sockfd, F_GETFL, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (flags &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;fcntl F_GETFL error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置非阻塞模式（加上 O_NONBLOCK）</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fcntl</span>(sockfd, F_SETFL, flags | O_NONBLOCK) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;fcntl F_SETFL error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;套接字已设置为非阻塞模式&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(sockfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-IO-多路转接之-select-函数原型"><a href="#4-IO-多路转接之-select-函数原型" class="headerlink" title="4. IO 多路转接之 select 函数原型"></a>4. IO 多路转接之 select 函数原型</h2><blockquote><p><a href="https://blog.csdn.net/chenlong_cxy/article/details/126189616">IO 多路转接 ——— select、poll、epoll | CSDN</a></p></blockquote><h3 id="1-作用"><a href="#1-作用" class="headerlink" title="1. 作用"></a>1. 作用</h3><p><code>select</code> 是最早的 I&#x2F;O 多路复用函数，用来 <strong>同时监控多个文件描述符（fd）是否可读、可写或有异常事件</strong>。</p><h3 id="2-函数原型-1"><a href="#2-函数原型-1" class="headerlink" title="2. 函数原型"></a>2. 函数原型</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">select</span><span class="params">(<span class="type">int</span> nfds,</span></span></span><br><span class="line"><span class="params"><span class="function">           fd_set *readfds,</span></span></span><br><span class="line"><span class="params"><span class="function">           fd_set *writefds,</span></span></span><br><span class="line"><span class="params"><span class="function">           fd_set *exceptfds,</span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="keyword">struct</span> timeval *timeout)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="3-参数解释"><a href="#3-参数解释" class="headerlink" title="3. 参数解释"></a>3. 参数解释</h3><table><thead><tr><th>参数名</th><th>含义</th></tr></thead><tbody><tr><td><code>nfds</code></td><td><strong>监控的最大文件描述符 + 1</strong>（例如要监控 <code>fd=5</code>，就写 <code>nfds=6</code>）</td></tr><tr><td><code>readfds</code></td><td>想监控“<strong>可读事件</strong>”的文件描述符集合（如 <code>recv()</code>、<code>read()</code> 是否不阻塞）</td></tr><tr><td><code>writefds</code></td><td>想监控“<strong>可写事件</strong>”的文件描述符集合（如 <code>send()</code>、<code>write()</code> 是否不阻塞）</td></tr><tr><td><code>exceptfds</code></td><td>监控“<strong>异常事件</strong>”的文件描述符集合（一般不用，传 <code>NULL</code>）</td></tr><tr><td><code>timeout</code></td><td>超时时间（阻塞多久）。传 <code>NULL</code> 就是 <strong>一直阻塞</strong>。</td></tr></tbody></table><h4 id="1-nfds-参数"><a href="#1-nfds-参数" class="headerlink" title="1. nfds 参数"></a>1. <code>nfds</code> 参数</h4><p><code>nfds</code> &#x3D; <strong>要监控的最高文件描述符编号 + 1</strong>。</p><ul><li>想监控 fd 3, fd 5？最高是 5，<code>nfds</code> 就写 <code>5 + 1 = 6</code>。</li><li>想监控 fd 1, fd 2, fd 100？最高是 100，<code>nfds</code> 就是 <code>100 + 1 = 101</code>。</li><li><strong>不是系统最大支持的文件描述符大小！</strong> 那个值通常很大（如 1024 或 65536），不需要监控那么多。</li></ul><p><strong>记住：<code>nfds</code> 是一个范围</strong>：<code>select</code> 会检查从 0 到 <code>nfds - 1</code> 这个范围内的所有 fd（只要在 <code>fd_set</code> 里设置了它们）。<code>nfds</code> 就是这个范围的 <strong>上限</strong>（不包含）。<strong>简化记忆</strong>：<code>nfds = max_fd + 1</code>。<code>select</code> 会在这个范围 <code>[0, max_fd]</code> 内，看你 <code>fd_set</code> 里标记了哪些 fd，然后监控它们。</p><h4 id="2-fd-set-的本质"><a href="#2-fd-set-的本质" class="headerlink" title="2. fd_set 的本质"></a>2. <code>fd_set</code> 的本质</h4><p><strong><code>fd_set</code> 是内核与用户空间之间传递“文件描述符就绪信息”的一张位图。</strong></p><table><thead><tr><th>阶段</th><th>谁在操作</th><th>含义</th></tr></thead><tbody><tr><td><strong>输入阶段（用户 → 内核）</strong></td><td>用户调用 <code>select()</code> 前</td><td>告诉内核：“我关心这些 fd（读、写、异常）。”</td></tr><tr><td><strong>输出阶段（内核 → 用户）</strong></td><td>内核执行完 I&#x2F;O 检查后</td><td>告诉用户：“这些 fd 已经就绪（比特位 &#x3D; 1）。”</td></tr></tbody></table><p><strong>也就是说：<code>readfds</code> 是输入输出双向参数（既是输入，也会被输出修改），每一位对应一个 <code>fd</code>，<code>1</code> 表示就绪；<code>0</code> 表示未就绪。调用后必须重新设置 <code>fd_set</code>，因为 <code>select</code> 会修改它。<code>fd_set</code> 的内部形式：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> fds_bits[__FD_SETSIZE / (<span class="number">8</span> * <span class="built_in">sizeof</span>(<span class="type">long</span>))];</span><br><span class="line">&#125; fd_set;</span><br></pre></td></tr></table></figure><p>本质就是一个 <strong>位图</strong>，每个 bit 对应一个文件描述符号位（fd 号），比如：<code>fd=3</code> -&gt; <code>fds_bits[0]</code> 的第 3 位。<code>select()</code> 的核心：用户传一张“关注表”（<code>fd_set</code>）给内核，内核帮你看这些 fd 是否有事件，等结果出来后，内核再把“结果表”写回给你。</p><h4 id="3-常用辅助宏"><a href="#3-常用辅助宏" class="headerlink" title="3. 常用辅助宏"></a>3. 常用辅助宏</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">FD_CLR</span>(<span class="type">int</span> fd, fd_set* set);<span class="comment">// 把fd从集合中移除（对应 bit = 0）</span></span><br><span class="line"><span class="built_in">FD_ISSET</span>(<span class="type">int</span> fd, fd_set* set);<span class="comment">// 判断fd是否在集合中就绪（bit==1 返回 true）</span></span><br><span class="line"><span class="built_in">FD_SET</span>(<span class="type">int</span> fd, fd_set* set);<span class="comment">// 把fd加入集合（设置对应 bit = 1）</span></span><br><span class="line"><span class="built_in">FD_ZERO</span>(fd_set* set);<span class="comment">// 清空集合（所有 bit 置 0）</span></span><br></pre></td></tr></table></figure><p>一般是这么操作的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">fd_set readfds;          <span class="comment">// 定义一个fd集合</span></span><br><span class="line"><span class="built_in">FD_ZERO</span>(&amp;readfds);       <span class="comment">// 清空集合</span></span><br><span class="line"><span class="built_in">FD_SET</span>(sockfd, &amp;readfds); <span class="comment">// 把sockfd加入关注集合</span></span><br><span class="line"><span class="built_in">FD_SET</span>(STDIN_FILENO, &amp;readfds); <span class="comment">// 把标准输入加入集合</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用select，监听读事件</span></span><br><span class="line"><span class="type">int</span> ret = <span class="built_in">select</span>(maxfd + <span class="number">1</span>, &amp;readfds, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;timeout);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">FD_ISSET</span>(sockfd, &amp;readfds))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// sockfd 可读</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">FD_ISSET</span>(STDIN_FILENO, &amp;readfds))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 标准输入可读</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用后，<code>readfds</code> 会被内核修改，表示哪些 fd 已经 <strong>就绪</strong>。</p><h4 id="4-struct-timeval-的含义"><a href="#4-struct-timeval-的含义" class="headerlink" title="4. struct timeval 的含义"></a>4. <code>struct timeval</code> 的含义</h4><blockquote><p><code>timeout</code> 就是给 <code>select</code> 设置一个 <strong>最长等待时间</strong> 的 <strong>闹钟</strong>。如果在闹钟响之前有事（fd 就绪），就立即叫醒你（返回）；如果闹钟响了还没事（fd 未就绪），也叫醒你（返回 0）。如果设置为永不响（<code>NULL</code>），就会一直睡（阻塞）；如果设置为立刻响（<code>{0, 0}</code>），就不会睡（非阻塞）。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">timeval</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">time_t</span>      tv_sec;   <span class="comment">// Seconds —— 秒</span></span><br><span class="line">    <span class="type">suseconds_t</span> tv_usec;  <span class="comment">// Microseconds —— 微秒（1秒=1,000,000微秒）</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>{seconds, microseconds}</code>: <code>select</code> 最多等待 <code>seconds</code> 秒 + <code>microseconds</code> 微秒。</p><ul><li>如果在 <strong>这个时间之内</strong>，有你监控的 fd 就绪了，<code>select</code> 会 <strong>立即返回</strong>，告诉你哪些 fd 就绪了，剩余的等待时间会被写回到 <code>timeout</code> 结构体中（通常在实际编程中，会每次都重新设置这个值）。</li><li>如果 <strong>这个时间之内</strong>，没有任何你监控的 fd 就绪，<code>select</code> 会 <strong>超时返回</strong>（返回值为 0）。</li></ul><p><strong>示例：</strong></p><ul><li><code>NULL</code> → 永久阻塞（传统阻塞式 I&#x2F;O）。</li><li><code>{5,0}</code> → 最多阻塞 5 秒（带超时的阻塞）。</li><li><code>{0,0}</code> → 不阻塞，<strong>非阻塞轮询式 I&#x2F;O</strong>。</li></ul><h3 id="4-返回值-1"><a href="#4-返回值-1" class="headerlink" title="4. 返回值"></a>4. 返回值</h3><ul><li><code>&gt; 0</code>：有多少个文件描述符就绪（可读 &#x2F; 可写 &#x2F; 异常）。</li><li><code>= 0</code>：超时，没有任何事件发生，没有错误，但是也没有 fd 就绪。</li><li><code>&lt; 0</code>：出错（一般是信号中断或参数错误）。</li></ul><h3 id="5-使用示例"><a href="#5-使用示例" class="headerlink" title="5. 使用示例"></a>5. 使用示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fd_set readfds;                  <span class="comment">// 创建fd集合</span></span><br><span class="line">    <span class="built_in">FD_ZERO</span>(&amp;readfds);               <span class="comment">// 清空集合</span></span><br><span class="line">    <span class="built_in">FD_SET</span>(STDIN_FILENO, &amp;readfds);  <span class="comment">// 把标准输入加入监控集合</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">timeval</span> tv;</span><br><span class="line">    tv.tv_sec = <span class="number">5</span>;                   <span class="comment">// 最多阻塞5秒</span></span><br><span class="line">    tv.tv_usec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;等待输入中...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">select</span>(STDIN_FILENO + <span class="number">1</span>, &amp;readfds, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;tv);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">FD_ISSET</span>(STDIN_FILENO, &amp;readfds))</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;检测到输入：&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">            <span class="built_in">read</span>(STDIN_FILENO, buf, <span class="built_in">sizeof</span>(buf));</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;你输入了: &quot;</span> &lt;&lt; buf;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;超时，没有输入&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;select 出错&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>一个基于 <code>select</code> 系统调用的单进程、单线程 TCP 服务器：</strong></p><blockquote><p>完整代码请前往 <a href="https://github.com/huangcancan-xbc/Linux-Ubuntu/tree/main/Coding/Advanced_IO/select">GitHub</a> 进行查看！</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Socket.hpp&quot;</span></span></span><br><span class="line"><span class="comment">// #include &quot;Log.hpp&quot;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">uint16_t</span> defaultport = <span class="number">8080</span>;                   <span class="comment">// 默认端口号8080</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> fd_num_max = (<span class="built_in">sizeof</span>(fd_set) * <span class="number">8</span>);         <span class="comment">// 计算fd_set能容纳的最大文件描述符数量，每个bit位代表一个fd</span></span><br><span class="line"><span class="type">int</span> defaultfd = <span class="number">-1</span>;                                         <span class="comment">// 无效文件描述符，用来标识数组中空闲的位置</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SelectServer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SelectServer</span>(<span class="type">uint16_t</span> port = defaultport)</span><br><span class="line">        : _port(port)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; fd_num_max; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            fd_array[i] = defaultfd;                        <span class="comment">// 将数组中所有位置都初始化为-1，表示空闲</span></span><br><span class="line">            <span class="comment">// std::cout &lt;&lt; &quot;fd_array[&quot; &lt;&lt; i &lt;&lt; &quot;]&quot; &lt;&lt; &quot; : &quot; &lt;&lt; fd_array[i] &lt;&lt; std::endl;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">SelectServer</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        _listensock.<span class="built_in">Close</span>();                                <span class="comment">// 关闭监听socket</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化服务器：创建socket、绑定端口、开始监听</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _listensock.<span class="built_in">Socket</span>();                               <span class="comment">// 创建监听socket</span></span><br><span class="line">        _listensock.<span class="built_in">Bind</span>(_port);                            <span class="comment">// 绑定端口</span></span><br><span class="line">        _listensock.<span class="built_in">Listen</span>();                               <span class="comment">// 开始监听</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印当前在线的文件描述符列表</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PrintFd</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;在线_fd_列表： &quot;</span>;                          <span class="comment">// 输出提示信息</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; fd_num_max; i++)               <span class="comment">// 遍历fd_array数组</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (fd_array[i] == defaultfd)                  <span class="comment">// 如果是空闲位置，跳过</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            cout &lt;&lt; fd_array[i] &lt;&lt; <span class="string">&quot; &quot;</span>;                    <span class="comment">// 输出有效的文件描述符</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Accepter</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 连接事件已经就绪</span></span><br><span class="line">        std::string client_ip;                              <span class="comment">// 客户端的IP</span></span><br><span class="line">        <span class="type">uint16_t</span> client_port;                               <span class="comment">// 客户端的端口</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> sock = _listensock.<span class="built_in">Accept</span>(&amp;client_ip, &amp;client_port);    <span class="comment">// 从监听socket获取新的连接，不会阻塞，因为select已经告诉我们有连接事件就绪</span></span><br><span class="line">        <span class="keyword">if</span> (sock &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;  <span class="comment">// 如果accept失败，直接返回</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">log_</span>(Info, <span class="string">&quot;新连接建立成功：客户端IP：%s，客户端端口：%d，socket fd：%d&quot;</span>, client_ip.<span class="built_in">c_str</span>(), client_port, sock);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Info, 新连接建立成功：客户端IP：&quot;</span> &lt;&lt; client_ip &lt;&lt; <span class="string">&quot;，客户端端口：&quot;</span> &lt;&lt; client_port &lt;&lt; <span class="string">&quot;，socket fd：&quot;</span> &lt;&lt; sock &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将新连接的文件描述符存入fd_array数组中</span></span><br><span class="line">        <span class="type">int</span> pos = <span class="number">1</span>;                                       <span class="comment">// 从数组索引1开始找空闲位置（索引0存放监听socket）</span></span><br><span class="line">        <span class="keyword">for</span> (; pos &lt; fd_num_max; pos++)                    <span class="comment">// 查找数组中空闲的位置</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (fd_array[pos] != defaultfd)                <span class="comment">// 如果当前位置不为空（-1），继续找下一个</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>                                           <span class="comment">// 找到空闲位置，跳出循环</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pos == fd_num_max)                             <span class="comment">// 如果遍历完整个数组都没找到空闲位置</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">log_</span>(Warning, <span class="string">&quot;服务器已满，立即关闭%d！&quot;</span>, sock); <span class="comment">// 服务器已满，关闭新连接</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Warning, 服务器已满，立即关闭&quot;</span> &lt;&lt; sock &lt;&lt; <span class="string">&quot;！&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="built_in">close</span>(sock);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>                                               <span class="comment">// 找到了空闲位置</span></span><br><span class="line">        &#123;</span><br><span class="line">            fd_array[pos] = sock;                          <span class="comment">// 将新连接的fd放入数组</span></span><br><span class="line">            <span class="built_in">PrintFd</span>();                                     <span class="comment">// 打印当前在线的fd列表</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 后续可能还有其他处理</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理数据接收的函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Recver</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> pos)</span>                            <span class="comment">// fd是需要读取数据的文件描述符，pos是该fd在数组中的位置</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// demo，接收客户端数据</span></span><br><span class="line">        <span class="type">char</span> buffer[<span class="number">1024</span>];                                  <span class="comment">// 临时缓冲区，用于存储接收的数据</span></span><br><span class="line">        <span class="type">ssize_t</span> n = <span class="built_in">read</span>(fd, buffer, <span class="built_in">sizeof</span>(buffer) - <span class="number">1</span>);   <span class="comment">// 从指定fd读取数据到缓冲区，预留1字节给字符串结束符</span></span><br><span class="line">        <span class="keyword">if</span> (n &gt; <span class="number">0</span>)                                          <span class="comment">// 读取到数据</span></span><br><span class="line">        &#123;</span><br><span class="line">            buffer[n] = <span class="number">0</span>;                                  <span class="comment">// 手动添加字符串结束符</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;收到一条消息：&quot;</span> &lt;&lt; buffer &lt;&lt; endl;      <span class="comment">// 输出接收到的消息</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">0</span>)                                    <span class="comment">// 客户端断开连接（读到文件结束符）</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">log_</span>(Info, <span class="string">&quot;客户端退出了，关闭连接的文件描述符是%d&quot;</span>, fd);  <span class="comment">// 记录客户端断开日志</span></span><br><span class="line">            <span class="built_in">close</span>(fd);                                      <span class="comment">// 关闭该连接的文件描述符</span></span><br><span class="line">            fd_array[pos] = defaultfd;                      <span class="comment">// 将数组中对应位置重置为-1，表示该位置空闲（这里本质是从select中移除该fd）</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>                                                <span class="comment">// 读取错误</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">log_</span>(Warning, <span class="string">&quot;接收文件错误，描述符是: %d&quot;</span>, fd);  <span class="comment">// 记录接收错误日志</span></span><br><span class="line">            <span class="built_in">close</span>(fd);                                      <span class="comment">// 关闭该连接的文件描述符</span></span><br><span class="line">            fd_array[pos] = defaultfd;                      <span class="comment">// 将数组中对应位置重置为-1，表示该位置空闲（这里本质是从select中移除该fd）</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 事件分发函数：根据select返回的结果，处理就绪的文件描述符</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Dispatcher</span><span class="params">(fd_set&amp; rfds)</span>                           <span class="comment">// rfds是select调用后被修改的fd_set，其中包含了就绪的fd</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; fd_num_max; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> fd = fd_array[i];                           <span class="comment">// 获取数组中第i个位置的fd</span></span><br><span class="line">            <span class="keyword">if</span> (fd == defaultfd)                            <span class="comment">// 如果是无效fd（-1），跳过</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 检查这个fd是否在select返回的就绪fd集合中</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">FD_ISSET</span>(fd, &amp;rfds))                         <span class="comment">// FD_ISSET宏用于检查fd是否在rfds集合中</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(fd == _listensock.<span class="built_in">Fd</span>())                  <span class="comment">// 如果就绪的fd是监听socket</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">Accepter</span>();                             <span class="comment">// 说明有新的连接请求，调用Accepter处理</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>                                        <span class="comment">// 如果就绪的fd不是监听socket，而是普通的数据连接socket</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">Recver</span>(fd, i);                          <span class="comment">// 调用Recver处理数据接收</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 服务器主循环：使用select实现IO多路复用</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Start</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> listensock = _listensock.<span class="built_in">Fd</span>();                  <span class="comment">// 获取监听socket的文件描述符</span></span><br><span class="line">        fd_array[<span class="number">0</span>] = listensock;                           <span class="comment">// 将监听socket放在数组第0个位置</span></span><br><span class="line">        <span class="comment">// 程序启动时，只有数组第0个位置有值，是监听socket的fd，但是，程序运行过程中，Accepter 会向数组中其他位置添加新的连接fd！</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;)                                            <span class="comment">// 无限循环，服务器持续运行</span></span><br><span class="line">        &#123;</span><br><span class="line">            fd_set readfds;                                 <span class="comment">// 定义一个fd_set变量，用于存储待检测的读就绪文件描述符集合</span></span><br><span class="line">            <span class="built_in">FD_ZERO</span>(&amp;readfds);                              <span class="comment">// 清空readfds集合，将所有位都设置为0</span></span><br><span class="line">            <span class="comment">// 每次进入循环，都要重新构建readfds集合，因为select会修改它。</span></span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> maxfds = fd_array[<span class="number">0</span>];                       <span class="comment">// 记录当前最大的文件描述符值，用于select调用</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; fd_num_max;i++)          <span class="comment">// 第一次循环，遍历fd_array数组，准备select的参数</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (fd_array[i] == defaultfd)               <span class="comment">// 如果数组中该位置是空闲的（-1），跳过</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="comment">// 这个 continue 非常有用！如果不跳过，fd_array[i] 是 -1，FD_SET(-1, &amp;readfds) 会出错或行为未定义。</span></span><br><span class="line">                    <span class="comment">// 并且，如果当前只有监听socket，数组后面的位置都是-1，这个循环会遍历所有位置，</span></span><br><span class="line">                    <span class="comment">// 但由于 continue，只有有效的fd（比如监听socket）会被处理。</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">FD_SET</span>(fd_array[i], &amp;readfds);              <span class="comment">// 将有效的fd添加到readfds集合中，让select监控这些fd的读就绪状态</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(fd_array[i] &gt; maxfds)</span><br><span class="line">                &#123;</span><br><span class="line">                    maxfds = fd_array[i];                   <span class="comment">// 更新最大fd值</span></span><br><span class="line">                    <span class="built_in">log_</span>(Info,<span class="string">&quot;最大文件描述符更新，最大文件描述符为：%d&quot;</span>, maxfds);</span><br><span class="line">                    std::cout &lt;&lt; <span class="string">&quot;最大文件描述符更新，最大文件描述符为：&quot;</span> &lt;&lt; maxfds &lt;&lt; std::endl;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">struct</span> <span class="title class_">timeval</span> timeout = &#123;<span class="number">5</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 调用select系统调用，监控maxfds+1个文件描述符（0到maxfds），readfds是读就绪集合，nullptr表示不监控写和异常</span></span><br><span class="line">            <span class="type">int</span> n = <span class="built_in">select</span>(maxfds + <span class="number">1</span>, &amp;readfds, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;timeout); <span class="comment">// 最后一个参数为nullptr表示不超时，阻塞等待</span></span><br><span class="line">            <span class="comment">// select 现在监控的是 0 到 maxfds 范围内所有在 readfds 位图中被置位的 fd。</span></span><br><span class="line">            <span class="comment">// 如果只有监听socket，它只监控监听socket。如果有多个连接，它会监控监听socket 和 所有已连接的socket。</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 根据select返回值进行处理</span></span><br><span class="line">            <span class="keyword">switch</span>(n)</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="comment">// select超时处理</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;time out, timeout: &quot;</span> &lt;&lt; timeout.tv_sec &lt;&lt; <span class="string">&quot;.&quot;</span> &lt;&lt; timeout.tv_usec &lt;&lt; endl;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// select调用出错处理</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;select error, errno:&quot;</span> &lt;&lt; errno &lt;&lt; endl;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// select成功处理</span></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;得到了一个新的连接请求！&quot;</span> &lt;&lt; endl;</span><br><span class="line">                <span class="built_in">Dispatcher</span>(readfds); <span class="comment">// 调用Dispatcher处理所有就绪的事件</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Sock _listensock;                <span class="comment">// 监听socket对象</span></span><br><span class="line">    <span class="type">uint16_t</span> _port;                  <span class="comment">// 服务器端口号</span></span><br><span class="line">    <span class="type">int</span> fd_array[fd_num_max];        <span class="comment">// 文件描述符数组，用于维护当前所有有效的连接fd（包括监听fd）</span></span><br><span class="line">    <span class="comment">// int wfd_array[fd_num_max];    // 扩展写事件处理</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>测试连接：<code>telnet 127.0.0.1 8080</code>，尝试输入一些内容……</strong> 初学时，这段代码要理解其实有一定难度，让我们详细梳理一下：</p><ol><li><p><strong>初始状态</strong>：</p><ul><li><code>listensock = 3</code>，监听 socket 的 fd，0、1、2 默认被占用就不解释了。</li><li><code>fd_array[0] = 3</code>。</li><li><code>fd_array[1]</code> 到 <code>fd_array[fd_num_max-1]</code> 都是 <code>-1</code>。</li></ul></li><li><p><strong>第一次 <code>Start</code> 循环</strong>：</p><ul><li><code>fd_set readfds</code> 被清空。</li><li>遍历 <code>fd_array</code>，只有 <code>fd_array[0]</code> (值为 3) 有效，所以 <code>FD_SET(3, &amp;readfds)</code>。<code>maxfds = 3</code>。</li><li><code>select(4, &amp;readfds, ...)</code> 被调用，监控 fd 3。</li><li>假设现在 <strong>客户端 A</strong> 连接服务器。</li><li><code>select</code> 发现 fd 3 (监听 socket) 可读（有新连接），返回值 &gt; 0。</li><li>进入 <code>Dispatcher(readfds)</code>。</li><li><code>Dispatcher</code> 遍历 <code>fd_array</code>。</li><li><code>i=0</code>: <code>fd = fd_array[0] = 3</code>。<code>FD_ISSET(3, &amp;readfds)</code> 为真。<code>fd (3) == _listensock.Fd()</code> 为真。调用 <code>Accepter()</code>。</li></ul></li><li><p><strong><code>Accepter</code> 执行</strong>：</p><ul><li><code>accept</code> 被调用，获取 <strong>客户端 A</strong> 的连接。</li><li>假设此时进程内最小可用 fd 是 4（因为 0,1,2 被占用，3 是监听 socket），所以 <code>accept</code> 返回 <code>sock = 4</code>。</li><li><code>Accepter</code> 开始查找 <code>fd_array</code> 中的空闲位置：<code>pos = 1</code>: <code>fd_array[1] = -1</code> (defaultfd)。找到空闲位置，<code>break</code>。</li><li><code>pos</code> 不等于 <code>fd_num_max</code>，所以执行 <code>else</code> 分支：<ul><li><code>fd_array[1] = 4</code> (将客户端 A 的 fd 存入数组)。</li><li><code>PrintFd()</code>。</li></ul></li></ul></li><li><p><strong>第二次 <code>Start</code> 循环</strong>：</p><ul><li><code>fd_set readfds</code> 被清空。</li><li>遍历 <code>fd_array</code>：<ul><li><code>i=0</code>: <code>fd_array[0] = 3</code> (监听 socket)。有效，<code>FD_SET(3, &amp;readfds)</code>。<code>maxfds</code> 更新为 3。</li><li><code>i=1</code>: <code>fd_array[1] = 4</code> (客户端 A 的 socket)。有效，<code>FD_SET(4, &amp;readfds)</code>。<code>maxfds</code> 更新为 4。</li><li><code>i=2</code> 到 <code>fd_num_max-1</code>: <code>fd_array[i] = -1</code>。跳过。</li></ul></li><li><code>select(5, &amp;readfds, ...)</code> 被调用，<strong>现在监控 fd 3 和 fd 4</strong>！</li><li>假设现在 <strong>客户端 A</strong> 发送了一条消息 “Hello”。</li><li><code>select</code> 发现 <strong>fd 4</strong> (客户端 A 的 socket) 可读（有数据到达），返回值 &gt; 0。</li><li>进入 <code>Dispatcher(readfds)</code>。</li><li><code>Dispatcher</code> 遍历 <code>fd_array</code>：<ul><li><code>i=0</code>: <code>fd = fd_array[0] = 3</code>。检查 <code>FD_ISSET(3, &amp;readfds)</code>。因为这次是 fd 4 就绪，fd 3 没就绪，所以 <code>FD_ISSET(3, &amp;readfds)</code> 为假。<strong>跳过</strong>。</li><li><code>i=1</code>: <code>fd = fd_array[1] = 4</code>。检查 <code>FD_ISSET(4, &amp;readfds)</code>。因为这次是 fd 4 就绪，所以 <code>FD_ISSET(4, &amp;readfds)</code> 为真。<code>fd (4) != _listensock.Fd()</code> 为真。<strong>进入 <code>else</code> 分支</strong>。</li><li>调用 <code>Recver(4, 1)</code>。<strong><code>Recver</code> 被成功调用了！</strong></li></ul></li></ul></li><li><p><strong><code>Recver</code> 执行</strong>：</p><ul><li><code>Recver</code> 从 fd 4 (客户端 A 的 socket) 读取数据 “Hello”，并处理它（例如打印）。</li></ul></li></ol><p><strong>关键点：</strong></p><ul><li><code>accept</code> 返回的 <strong>不是</strong> 监听 socket 的 fd。它返回的是一个 <strong>全新的、代表新客户端连接的 socket 的 fd</strong>。这个新 fd 会被存储到 <code>fd_array</code> 中。</li><li><code>Start</code> 循环中的 <code>for</code> 循环会 <strong>持续更新</strong> <code>select</code> 监控的 fd 集合 (<code>readfds</code>)。每次循环，它都会将 <code>fd_array</code> 中所有非 <code>-1</code> 的 fd（包括监听 socket 和所有已连接的客户端 socket）都添加到监控集合中。</li><li><code>Dispatcher</code> 循环会 <strong>持续检查</strong> <code>fd_array</code> 中所有非 <code>-1</code> 的 fd，看它们是否在 <code>select</code> 返回的就绪集合 (<code>readfds</code>) 中。</li><li>如果就绪的 fd 是 <strong>监听 socket 的 fd</strong>，说明有新连接，走 <code>Accepter</code>。</li><li>如果就绪的 fd 是 <strong><code>fd_array</code> 中某个已存储的客户端 socket 的 fd</strong>（即 <code>fd != _listensock.Fd()</code>），说明这个特定客户端发送了数据，走 <code>Recver</code>。</li></ul><p><strong><code>Accepter</code> 中查找空闲位置的意义：</strong></p><ul><li><strong><code>fd_array</code></strong> 是服务器用来 <strong>追踪和管理</strong> 所有当前连接（包括监听 socket）的 <strong>本地数据结构</strong>。</li><li><code>accept</code> 返回的 fd 必须被 <strong>记录</strong> 下来，否则服务器就无法知道有哪些客户端连接，也无法监控它们。</li><li>查找空闲位置并存入 <code>fd_array</code>，是为了让 <code>Start</code> 和 <code>Dispatcher</code> 能够 <strong>知道</strong> 这个新连接的存在，并将其加入到 <code>select</code> 的监控范围和事件分发范围中。</li><li><code>if (pos == fd_num_max)</code> 检查是为了防止 <code>fd_array</code> 被填满，实现连接数限制。</li></ul><p><strong>注意：</strong> <code>Recver</code> <strong>非常重要且会被使用</strong>。每当任何一个已连接的客户端发送数据时，<code>select</code> 就会检测到该客户端对应的 fd 就绪，<code>Dispatcher</code> 就会找到该 fd 在 <code>fd_array</code> 中的位置，并调用 <code>Recver</code> 来处理该客户端的数据。<code>fd_array</code> 和 <code>Accepter</code> 的查找逻辑是实现多客户端管理的关键。</p><h3 id="6-快速上手-select-的编写步骤（重要）"><a href="#6-快速上手-select-的编写步骤（重要）" class="headerlink" title="6. 快速上手 select 的编写步骤（重要）"></a>6. 快速上手 <code>select</code> 的编写步骤（重要）</h3><p>想象你是一个 <strong>服务员</strong>，要同时服务多个客户（文件描述符）。</p><ol><li><strong>准备工具</strong>：创建一个 <code>fd_set</code>（想象成一个 <strong>点名册</strong>），清空它 (<code>FD_ZERO</code>)。</li><li><strong>记录客户</strong>：把你需要服务的客户（文件描述符）一个个记到点名册上 (<code>FD_SET</code>)。比如客户 A (fd &#x3D; 3)，客户 B (fd &#x3D; 5)。</li><li><strong>确定范围</strong>：看看你记下的客户里，编号最大的是谁？比如是客户 B (fd &#x3D; 5)。<strong><code>nfds</code> 就是这个最大编号 + 1</strong>，也就是 6。告诉老板（操作系统）：”我要服务编号 0 到 5 的客户”。</li><li><strong>开始观察</strong>：调用 <code>select(6, &amp;点名册, NULL, NULL, NULL)</code>。你开始观察点名册上记录的客户，等待他们有需要（比如按铃表示可读）。</li><li><strong>响应需求</strong>：<code>select</code> 告诉你哪些客户按铃了。你再次查看点名册（<code>FD_ISSET</code>），看具体是哪个客户按的。然后去服务这个客户（比如读取数据）。</li><li><strong>循环往复</strong>：回到第 1 步，继续准备、记录、观察、响应。</li></ol><p><strong>编写步骤：</strong></p><ol><li><strong>初始化</strong>：创建监听 socket，绑定，监听。</li><li><strong>准备容器</strong>：用一个数组（如 <code>fd_array</code>）或链表存储所有要监控的 fd。</li><li><strong>主循环 (<code>Start</code>)</strong>：<ul><li>清空 <code>fd_set</code>。</li><li>遍历你的容器（<code>fd_array</code>），将所有有效 fd (<code>fd != -1</code>) 添加到 <code>fd_set</code> (<code>FD_SET</code>)。</li><li>同时记录这些 fd 中的 <strong>最大值</strong> (<code>maxfd</code>)。</li><li>调用 <code>select(maxfd + 1, &amp;fd_set, ...)</code>.</li></ul></li><li><strong>事件分发 (<code>Dispatcher</code>)</strong>：<ul><li>再次遍历你的容器（<code>fd_array</code>）。</li><li>对于每个有效 fd，用 <code>FD_ISSET(fd, &amp;fd_set)</code> 检查它是否在 <code>select</code> 返回的就绪集合中。</li><li>如果是监听 fd 就绪，调用 <code>Accepter</code>。</li><li>如果是普通连接 fd 就绪，调用 <code>Recver</code> 或相应的处理函数。</li></ul></li><li><strong>处理连接 (<code>Accepter</code>)</strong>：<code>accept</code> 得到新 fd，将其添加到你的容器（<code>fd_array</code>）中。</li><li><strong>处理数据 (<code>Recver</code>)</strong>：读取数据，处理。如果连接断开，从你的容器（<code>fd_array</code>）中移除该 fd（设置为 <code>-1</code>）。</li></ol><p><strong>核心思想</strong>：用一个 <strong>容器</strong>（数组&#x2F;链表）管理所有 fd，用 <code>select</code> <strong>监控</strong> 这个容器里的所有 fd，用 <code>select</code> 的返回结果 <strong>分发</strong> 事件给相应的处理函数。</p><h3 id="7-select-优缺点总结"><a href="#7-select-优缺点总结" class="headerlink" title="7. select 优缺点总结"></a>7. select 优缺点总结</h3><p><strong>优点：</strong></p><ol><li>可同时等待多个文件描述符，提高 IO 利用率。</li><li>“等待”与“操作”分离，IO 操作本身不会被阻塞。</li><li>实现简单，兼容性好，几乎所有平台都支持。</li></ol><p><strong>缺点：</strong></p><ol><li><strong>fd 数量有限</strong>（通常上限 1024）。</li><li><strong>每次调用都要重置 fd 集合</strong>，使用繁琐。</li><li><strong>用户态到内核态频繁拷贝</strong>，开销大。</li><li><strong>内核遍历所有 fd</strong> 检查状态，效率低。</li><li><strong>用户态也需维护 fd 集合</strong>，多次遍历，复杂度高。</li></ol><p>select 能多路等待，但机制老、开销大、扩展性差，设计比较久远，具有局限性，对初学者也并不友好，于是就有了 <strong>Poll 的多路转接方案</strong>，<code>poll</code> 是对 <code>select</code> 的改进版，解决了它的一些局限。</p><h2 id="5-poll-的函数原型"><a href="#5-poll-的函数原型" class="headerlink" title="5. poll 的函数原型"></a>5. poll 的函数原型</h2><h3 id="1-作用-1"><a href="#1-作用-1" class="headerlink" title="1. 作用"></a>1. 作用</h3><blockquote><p><code>poll</code> &#x3D; “用数组替代位图的 select”，功能一样但更方便、无 fd 上限。</p></blockquote><p><code>poll</code> 是比 <code>select</code> 新的 I&#x2F;O 多路复用函数，用来 <strong>同时监控多个文件描述符的可读、可写或异常事件</strong>。功能和 <code>select</code> 一样，但使用方式更简单、限制更少。</p><h3 id="2-函数原型-2"><a href="#2-函数原型-2" class="headerlink" title="2. 函数原型"></a>2. 函数原型</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">poll</span><span class="params">(<span class="keyword">struct</span> pollfd *fds, <span class="type">nfds_t</span> nfds, <span class="type">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="3-参数解释-1"><a href="#3-参数解释-1" class="headerlink" title="3. 参数解释"></a>3. 参数解释</h3><table><thead><tr><th>参数名</th><th>含义</th><th>与 <code>select</code> 对比</th></tr></thead><tbody><tr><td><code>fds</code></td><td>一个 <code>pollfd</code> 结构体数组，每个元素描述一个要监控的 fd</td><td>类似于 <code>readfds</code> &#x2F; <code>writefds</code> &#x2F; <code>exceptfds</code> 三个集合的合并版</td></tr><tr><td><code>nfds</code></td><td>数组中有多少个元素，即可以传入多少个文件描述符</td><td>等价于 <code>select</code> 的 <code>nfds</code>（监控的 fd 数量）</td></tr><tr><td><code>timeout</code></td><td>超时&#x2F;最长等待时间（毫秒）</td><td>功能同 <code>select</code> 的 <code>timeout</code>，只是单位不同（毫秒）</td></tr></tbody></table><h4 id="1-struct-pollfd-结构体"><a href="#1-struct-pollfd-结构体" class="headerlink" title="1. struct pollfd 结构体"></a>1. <code>struct pollfd</code> 结构体</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">pollfd</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span>   fd;        <span class="comment">// 要监控的文件描述符</span></span><br><span class="line">    <span class="type">short</span> events;    <span class="comment">// 想监控哪些事件（输入参数）</span></span><br><span class="line">    <span class="type">short</span> revents;   <span class="comment">// 实际发生的事件（输出参数，由内核填充）</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="2-事件标志（events-和-revents-的取值）"><a href="#2-事件标志（events-和-revents-的取值）" class="headerlink" title="2. 事件标志（events 和 revents 的取值）"></a>2. 事件标志（<code>events</code> 和 <code>revents</code> 的取值）</h4><table><thead><tr><th>事件</th><th>描述</th><th>是否可作为输入</th><th>是否可作为输出</th></tr></thead><tbody><tr><td><strong><code>POLLIN</code></strong></td><td><strong>数据（包括普通数据和优先数据）可读</strong></td><td><strong>是</strong></td><td><strong>是</strong></td></tr><tr><td>POLLRDNORM</td><td>普通数据可读</td><td>是</td><td>是</td></tr><tr><td>POLLRDBAND</td><td>优先级带数据可读（Linux 不支持）</td><td>是</td><td>是</td></tr><tr><td>POLLPRI</td><td>高优先级数据可读，比如 TCP 带外数据</td><td>是</td><td>是</td></tr><tr><td><strong><code>POLLOUT</code></strong></td><td><strong>数据（包括普通数据和优先数据）可写</strong></td><td><strong>是</strong></td><td><strong>是</strong></td></tr><tr><td>POLLWRNORM</td><td>普通数据可写</td><td>是</td><td>是</td></tr><tr><td>POLLWRBAND</td><td>优先级带数据可写</td><td>是</td><td>是</td></tr><tr><td>POLLRDHUP</td><td>TCP 连接被对方关闭，或者对方关闭了写操作，它由 GNU 引入</td><td>是</td><td>是</td></tr><tr><td><strong><code>POLLERR</code></strong></td><td><strong>错误</strong></td><td><strong>否</strong></td><td><strong>是</strong></td></tr><tr><td>POLLHUP</td><td>挂起。比如管道的写端被关闭后，读端描述符上将收到 POLLHUP 事件</td><td>否</td><td>是</td></tr><tr><td><strong><code>POLLNVAL</code></strong></td><td><strong>文件描述符没有打开</strong></td><td><strong>否</strong></td><td><strong>是</strong></td></tr></tbody></table><table><thead><tr><th><strong>常用的事件标志</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td><strong><code>POLLIN</code></strong></td><td><strong>可读（读缓冲区有数据）</strong></td></tr><tr><td><strong><code>POLLOUT</code></strong></td><td><strong>可写（写缓冲区可用）</strong></td></tr><tr><td><strong><code>POLLERR</code></strong></td><td><strong>错误（比如连接异常）</strong></td></tr><tr><td><strong><code>POLLHUP</code></strong></td><td><strong>对端关闭连接（挂断）</strong></td></tr><tr><td><strong><code>POLLNVAL</code></strong></td><td><strong>无效的 fd</strong></td></tr></tbody></table><h4 id="3-超时-最长等待时间（timeout）含义"><a href="#3-超时-最长等待时间（timeout）含义" class="headerlink" title="3. 超时&#x2F;最长等待时间（timeout）含义"></a>3. 超时&#x2F;最长等待时间（timeout）含义</h4><table><thead><tr><th align="center">取值</th><th>含义</th></tr></thead><tbody><tr><td align="center"><code>&gt;0</code></td><td>最多等待指定毫秒数（超时返回 0）</td></tr><tr><td align="center"><code>0</code></td><td>立即返回（非阻塞轮询）</td></tr><tr><td align="center"><code>-1</code></td><td>一直阻塞（直到有事件）</td></tr></tbody></table><h3 id="4-返回值-2"><a href="#4-返回值-2" class="headerlink" title="4. 返回值"></a>4. 返回值</h3><ul><li><strong><code>&gt;0</code>：</strong> 有多少个 fd 就绪。</li><li><strong><code>=0</code>：</strong> 超时。</li><li><strong><code>&lt;0</code>：</strong> 出错。</li></ul><h3 id="5-使用示例-1"><a href="#5-使用示例-1" class="headerlink" title="5. 使用示例"></a>5. 使用示例</h3><blockquote><p>完整代码请前往 <a href="https://github.com/huangcancan-xbc/Linux-Ubuntu/tree/main/Coding/Advanced_IO/poll">GitHub</a> 查看。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Socket.hpp&quot;</span></span></span><br><span class="line"><span class="comment">// #include &quot;Log.hpp&quot;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">uint16_t</span> defaultport = <span class="number">8080</span>;           <span class="comment">// 默认端口号8080</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> fd_num_max = <span class="number">64</span>;                   <span class="comment">// poll数组的最大容量，最多同时监听64个文件描述符</span></span><br><span class="line"><span class="type">int</span> defaultfd = <span class="number">-1</span>;                                 <span class="comment">// 无效文件描述符，用来标识数组中空闲的位置</span></span><br><span class="line"><span class="type">int</span> no_event = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PollServer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">PollServer</span>(<span class="type">uint16_t</span> port = defaultport)</span><br><span class="line">        : _port(port)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; fd_num_max; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            _event_fds[i].fd = defaultfd;           <span class="comment">// 初始化每个位置的fd为-1（表示未使用）</span></span><br><span class="line">            _event_fds[i].events = no_event;        <span class="comment">// 初始化每个位置的监听事件为0（不监听任何事件）</span></span><br><span class="line">            _event_fds[i].revents = no_event;       <span class="comment">// 初始化每个位置的返回事件为0（无事件发生）</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// std::cout &lt;&lt; &quot;fd_array[&quot; &lt;&lt; i &lt;&lt; &quot;]&quot; &lt;&lt; &quot; : &quot; &lt;&lt; fd_array[i] &lt;&lt; std::endl;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">PollServer</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        _listensock.<span class="built_in">Close</span>();                        <span class="comment">// 关闭监听socket</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化服务器：创建socket、绑定端口、开始监听</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _listensock.<span class="built_in">Socket</span>();                       <span class="comment">// 创建监听socket</span></span><br><span class="line">        _listensock.<span class="built_in">Bind</span>(_port);                    <span class="comment">// 绑定端口</span></span><br><span class="line">        _listensock.<span class="built_in">Listen</span>();                       <span class="comment">// 开始监听</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印当前在线的文件描述符列表</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PrintFd</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;在线_fd_列表： &quot;</span>;                  <span class="comment">// 输出提示信息</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; fd_num_max; i++)       <span class="comment">// 遍历_event_fds数组</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (_event_fds[i].fd == defaultfd)     <span class="comment">// 如果是空闲位置（fd为-1），跳过</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            cout &lt;&lt; _event_fds[i].fd &lt;&lt; <span class="string">&quot; &quot;</span>;       <span class="comment">// 输出有效的文件描述符</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Accepter</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 有新的客户端连接请求到来</span></span><br><span class="line">        std::string client_ip;                     <span class="comment">// 客户端的IP</span></span><br><span class="line">        <span class="type">uint16_t</span> client_port;                      <span class="comment">// 客户端的端口</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> sock = _listensock.<span class="built_in">Accept</span>(&amp;client_ip, &amp;client_port);    <span class="comment">// 接收新的客户端连接</span></span><br><span class="line">        <span class="keyword">if</span> (sock &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;                                <span class="comment">// 如果accept失败，直接返回</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">log_</span>(Info, <span class="string">&quot;新连接建立成功：客户端IP：%s，客户端端口：%d，socket fd：%d&quot;</span>, client_ip.<span class="built_in">c_str</span>(), client_port, sock);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Info, 新连接建立成功：客户端IP：&quot;</span> &lt;&lt; client_ip &lt;&lt; <span class="string">&quot;，客户端端口：&quot;</span> &lt;&lt; client_port &lt;&lt; <span class="string">&quot;，socket fd：&quot;</span> &lt;&lt; sock &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将新连接的文件描述符添加到poll数组中</span></span><br><span class="line">        <span class="type">int</span> pos = <span class="number">1</span>;                               <span class="comment">// 从数组索引1开始找空闲位置（索引0存放监听socket）</span></span><br><span class="line">        <span class="keyword">for</span> (; pos &lt; fd_num_max; pos++)            <span class="comment">// 查找数组中空闲的位置</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (_event_fds[pos].fd != defaultfd)   <span class="comment">// 如果当前位置已被占用（fd不为-1），继续找下一个</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>                                   <span class="comment">// 找到空闲位置，跳出循环</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pos == fd_num_max)                     <span class="comment">// 如果遍历完整个数组都没找到空闲位置</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">log_</span>(Warning, <span class="string">&quot;服务器已满，立即关闭%d！&quot;</span>, sock);        <span class="comment">// 服务器连接数已达上限，关闭新连接</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Warning, 服务器已满，立即关闭&quot;</span> &lt;&lt; sock &lt;&lt; <span class="string">&quot;！&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="built_in">close</span>(sock);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// 找到了空闲位置</span></span><br><span class="line">        &#123;</span><br><span class="line">            _event_fds[pos].fd = sock;             <span class="comment">// 将新连接的fd放入数组</span></span><br><span class="line">            _event_fds[pos].events = POLLIN;       <span class="comment">// 设置该fd的监听事件为POLLIN（监听数据可读）</span></span><br><span class="line">            _event_fds[pos].revents = no_event;    <span class="comment">// 清空返回事件</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">PrintFd</span>();                             <span class="comment">// 打印当前在线的fd列表</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 后续可能还有其他处理</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理数据接收的函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Recver</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> pos)</span>                   <span class="comment">// fd是需要读取数据的文件描述符，pos是该fd在数组中的位置</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 接收客户端发送的数据</span></span><br><span class="line">        <span class="type">char</span> buffer[<span class="number">1024</span>];                         <span class="comment">// 临时缓冲区，用于存储接收的数据</span></span><br><span class="line">        <span class="type">ssize_t</span> n = <span class="built_in">read</span>(fd, buffer, <span class="built_in">sizeof</span>(buffer) - <span class="number">1</span>);       <span class="comment">// 从指定fd读取数据到缓冲区，预留1字节给字符串结束符</span></span><br><span class="line">        <span class="keyword">if</span> (n &gt; <span class="number">0</span>)                                 <span class="comment">// 读取到数据</span></span><br><span class="line">        &#123;</span><br><span class="line">            buffer[n] = <span class="string">&#x27;\0&#x27;</span>;                      <span class="comment">// 手动添加字符串结束符</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;收到一条消息：&quot;</span> &lt;&lt; buffer &lt;&lt; endl;          <span class="comment">// 输出接收到的消息</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">0</span>)                           <span class="comment">// 客户端断开连接（读到文件结束符）</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">log_</span>(Info, <span class="string">&quot;客户端退出了，关闭连接的文件描述符是%d&quot;</span>, fd);   <span class="comment">// 记录客户端断开日志</span></span><br><span class="line">            <span class="built_in">close</span>(fd);                             <span class="comment">// 关闭该连接的文件描述符</span></span><br><span class="line">            _event_fds[pos].fd = defaultfd;        <span class="comment">// 将数组中对应位置重置为-1，表示该位置空闲（从poll监听列表中移除该fd）</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>                                       <span class="comment">// 读取错误</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">log_</span>(Warning, <span class="string">&quot;接收文件错误，描述符是: %d&quot;</span>, fd);      <span class="comment">// 记录接收错误日志</span></span><br><span class="line">            <span class="built_in">close</span>(fd);                             <span class="comment">// 关闭该连接的文件描述符</span></span><br><span class="line">            _event_fds[pos].fd = defaultfd;        <span class="comment">// 将数组中对应位置重置为-1，表示该位置空闲（从poll监听列表中移除该fd）</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 事件分发函数：处理所有就绪的事件</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Dispatcher</span><span class="params">()</span>                              <span class="comment">// 遍历poll数组，检查哪些fd的事件已经就绪</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; fd_num_max; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> fd = _event_fds[i].fd;             <span class="comment">// 获取数组中第i个位置的fd</span></span><br><span class="line">            <span class="keyword">if</span> (fd == defaultfd)                   <span class="comment">// 如果是无效fd（-1），跳过</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (_event_fds[i].revents &amp; POLLIN)    <span class="comment">// 如果这个fd的POLLIN事件已经就绪（有数据可读）</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (fd == _listensock.<span class="built_in">Fd</span>())        <span class="comment">// 如果就绪的fd是监听socket</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">Accepter</span>();                    <span class="comment">// 说明有新的连接请求，调用Accepter处理</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>                               <span class="comment">// 如果就绪的fd不是监听socket，而是普通的数据连接socket</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">Recver</span>(fd, i);                 <span class="comment">// 调用Recver处理数据接收</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 服务器主循环：使用poll实现IO多路复用</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Start</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _event_fds[<span class="number">0</span>].fd = _listensock.<span class="built_in">Fd</span>();       <span class="comment">// 把监听socket的fd放到数组的第一个位置</span></span><br><span class="line">        _event_fds[<span class="number">0</span>].events = POLLIN;             <span class="comment">// 监听socket只关心POLLIN事件（新连接请求）</span></span><br><span class="line">        <span class="type">int</span> timeout = <span class="number">3000</span>;                        <span class="comment">// 设置poll超时时间为3000毫秒（3秒），如果3秒内没有事件发生，poll会返回0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;)                                   <span class="comment">// 服务器无限循环，持续监听和处理事件</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> n = <span class="built_in">poll</span>(_event_fds, fd_num_max, timeout);   <span class="comment">// 调用poll等待事件发生</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 根据poll返回值进行处理</span></span><br><span class="line">            <span class="keyword">switch</span> (n)</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="comment">// poll超时处理（timeout时间内没有事件发生）</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;time out, timeout: &quot;</span> &lt;&lt; timeout &lt;&lt; endl;   <span class="comment">// poll超时，没有事件发生</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// poll调用出错处理</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;select error, errno:&quot;</span> &lt;&lt; errno &lt;&lt; endl;    <span class="comment">// poll调用出错</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// poll成功处理（有事件发生）</span></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;得到了一个新的连接请求！&quot;</span> &lt;&lt; endl;           <span class="comment">// poll成功，有事件发生（注意：这里注释可能不准确，有事件发生不一定都是连接请求）</span></span><br><span class="line">                <span class="built_in">Dispatcher</span>();                      <span class="comment">// 调用Dispatcher处理所有就绪的事件</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Sock _listensock;                             <span class="comment">// 监听socket对象</span></span><br><span class="line">    <span class="type">uint16_t</span> _port;                               <span class="comment">// 服务器端口号</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">pollfd</span> _event_fds[fd_num_max];         <span class="comment">// poll需要的数组，存储要监听的fd和事件（结构体数组，数组每一个位置都是结构体）</span></span><br><span class="line">    <span class="comment">// struct pollfd *_event_fds;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// int fd_array[fd_num_max];</span></span><br><span class="line">    <span class="comment">// int wfd_array[fd_num_max];                 // 扩展写事件处理</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="6-poll-小结"><a href="#6-poll-小结" class="headerlink" title="6. poll 小结"></a>6. <code>poll</code> 小结</h3><h4 id="1-poll-的优点"><a href="#1-poll-的优点" class="headerlink" title="1. poll 的优点"></a>1. <code>poll</code> 的优点</h4><ol><li><strong>输入输出参数分离：</strong> <code>struct pollfd</code> 里有 <code>events</code>（输入）和 <code>revents</code>（输出），不像 <code>select</code> 那样每次都要重新设置集合。</li><li><strong>监控数量不限：</strong> 不再受 <code>fd_set</code> 的 1024 比特位限制，想监控多少个 fd，就传多少个 <code>pollfd</code> 元素，具体监控多少个由第二个参数 <code>nfds</code> 决定。</li><li><strong>同时等待多个 fd，提高效率：</strong>“等”的时间可以重叠，IO 效率比阻塞式 IO 高得多。</li></ol><h4 id="2-poll-的缺点"><a href="#2-poll-的缺点" class="headerlink" title="2. poll 的缺点"></a>2. <code>poll</code> 的缺点</h4><ol><li><strong>返回后仍需遍历：</strong> 需要遍历整个 <code>fds</code> 数组，找出哪些 fd 已经就绪。</li><li><strong>用户态与内核态拷贝开销大：</strong> 每次调用都要把整个 <code>pollfd</code> 数组复制进内核，fd 多时性能会明显下降。</li><li><strong>内核仍是线性扫描：</strong> 内核依然要挨个检查每个 fd，就绪检测效率低，当 fd 数量非常大时，性能退化明显。</li></ol><h4 id="3-与-select-的核心区别"><a href="#3-与-select-的核心区别" class="headerlink" title="3. 与 select 的核心区别"></a>3. 与 <code>select</code> 的核心区别</h4><table><thead><tr><th>对比项</th><th><code>select</code></th><th><code>poll</code></th></tr></thead><tbody><tr><td>fd 表达方式</td><td>位图 (<code>fd_set</code>)</td><td>结构体数组 (<code>pollfd[]</code>)</td></tr><tr><td>fd 数量限制</td><td>有（通常 1024）</td><td>理论无限（由系统资源决定）</td></tr><tr><td>参数是否要重置</td><td>每次都要重新设置</td><td>不用重置，只更新有变化的项</td></tr><tr><td>内核检测机制</td><td>遍历所有 fd</td><td>同样遍历，但结构更清晰</td></tr></tbody></table><blockquote><p>  <strong><code>poll</code> 是 <code>select</code> 的改良版，解决了 fd 数量上限和参数重置的问题，但底层依然是“遍历式检测”，性能瓶颈依旧。</strong></p></blockquote>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;高级-IO&quot;&gt;&lt;a href=&quot;#高级-IO&quot; class=&quot;headerlink&quot; title=&quot;高级 IO&quot;&gt;&lt;/a&gt;高级 IO&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a</summary>
        
      
    
    
    
    <category term="Linux" scheme="https://www.minbit.top/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://www.minbit.top/tags/Linux/"/>
    
    <category term="IO" scheme="https://www.minbit.top/tags/IO/"/>
    
  </entry>
  
  <entry>
    <title>055 其他重要协议和技术</title>
    <link href="https://www.minbit.top/posts/48372.html"/>
    <id>https://www.minbit.top/posts/48372.html</id>
    <published>2025-10-12T04:00:00.000Z</published>
    <updated>2025-10-12T04:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="其他重要协议和技术"><a href="#其他重要协议和技术" class="headerlink" title="其他重要协议和技术"></a>其他重要协议和技术</h1><blockquote><p><a href="https://blog.csdn.net/chenlong_cxy/article/details/124788487">DNS 协议、ICMP 协议、NAT 技术 | CSDN</a></p></blockquote><h2 id="1-DNS"><a href="#1-DNS" class="headerlink" title="1. DNS"></a>1. DNS</h2><h3 id="1-DNS-背景与作用"><a href="#1-DNS-背景与作用" class="headerlink" title="1. DNS 背景与作用"></a>1. DNS 背景与作用</h3><blockquote><p>  <strong>DNS（Domain Name System，域名系统）</strong> 是互联网中 <strong>负责把域名转换为 IP 地址</strong> 的系统。人记域名（如 <code>www.baidu.com</code>），机器识别 IP（如 <code>110.242.69.21</code>）。DNS 就是充当这两者之间的“翻译官”。</p></blockquote><p><strong>为什么需要 DNS？</strong></p><ul><li>IP 地址难记、会变动，而域名容易记。</li><li>访问网站、发邮件、请求 API 时都依赖域名解析到具体主机。</li></ul><h3 id="2-域名简介"><a href="#2-域名简介" class="headerlink" title="2. 域名简介"></a>2. 域名简介</h3><p>域名是分层结构（<strong>从右往左层级递减</strong>）：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">www.example.com.</span><br><span class="line">│   │       └── 顶级域（TLD）：.com / .org / .cn / .edu</span><br><span class="line">│   └────────── 二级域（注册主体）：example</span><br><span class="line">└────────────── 主机名（子域）：www（可省略）</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li><strong>根域</strong>：隐藏的 “.”，由全球 13 组根 DNS 服务器管理。</li><li><strong>顶级域（TLD）</strong>：如 <code>.com</code>：商业类；<code>.net</code>：网络服务类；<code>.org</code>：开源组织或非盈利组织。</li><li><strong>二级域</strong>：企业或组织自行注册（如 baidu.com）。</li><li><strong>子域（三级及以下）</strong>：如 <code>www.baidu.com</code>、<code>api.baidu.com</code>。</li></ul><h3 id="3-DNS-解析过程（简化说明）"><a href="#3-DNS-解析过程（简化说明）" class="headerlink" title="3. DNS 解析过程（简化说明）"></a>3. DNS 解析过程（简化说明）</h3><blockquote><p>DNS 查询是一个“从根到叶”的 <strong>分层查找过程</strong>，递归服务器负责一层层问下去，直到拿到最终结果。</p></blockquote><p>假设用户访问 <code>www.baidu.com</code>：</p><ol><li><p><strong>浏览器缓存查询：</strong> 先查本地浏览器缓存，看是否已有 IP。</p></li><li><p><strong>操作系统缓存查询：</strong> 若浏览器无，则查 OS 缓存（Linux 可看 <code>/etc/hosts</code>）。</p></li><li><p><strong>本地 DNS 服务器查询：</strong>（通常是自己所在网络的 DNS，如 8.8.8.8）本地 DNS 会缓存常见记录，若命中则直接返回。</p></li><li><p><strong>递归查询</strong>（若本地 DNS 未命中）：</p><ul><li><p>向 <strong>根 DNS</strong> 请求：谁管 <code>.com</code>？</p></li><li><p>根 DNS 返回顶级域服务器地址。</p></li><li><p>向 <strong>.com 顶级域 DNS</strong> 请求：谁管 <code>baidu.com</code>？</p></li><li><p>返回 <code>baidu.com</code> 的权威 DNS 地址。</p></li><li><p>向 <strong>baidu.com 权威 DNS</strong> 请求：<code>www</code> 的 IP 是多少？</p></li><li><p>最终得到 <code>110.242.69.21</code>。</p></li></ul></li></ol><hr><h3 id="4-dig-工具简介与安装"><a href="#4-dig-工具简介与安装" class="headerlink" title="4. dig 工具简介与安装"></a>4. <code>dig</code> 工具简介与安装</h3><blockquote><p><code>dig</code>（Domain Information Groper）是 DNS 调试利器，用于查询域名解析信息。<a href="https://www.imooc.com/article/26971?block_id=tuijian_wz">linux dig 命令使用方法 | 慕课网</a>。</p></blockquote><p>安装命令：</p><h4 id="1-CentOS-7-6"><a href="#1-CentOS-7-6" class="headerlink" title="1. CentOS 7.6"></a>1. CentOS 7.6</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> yum install bind-utils -y</span><br></pre></td></tr></table></figure><h4 id="2-Ubuntu-22-04"><a href="#2-Ubuntu-22-04" class="headerlink" title="2. Ubuntu 22.04"></a>2. Ubuntu 22.04</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt install dnsutils -y</span><br></pre></td></tr></table></figure><hr><h3 id="5-浏览器输入-URL-后发生的事情（核心）"><a href="#5-浏览器输入-URL-后发生的事情（核心）" class="headerlink" title="5. 浏览器输入 URL 后发生的事情（核心）"></a>5. 浏览器输入 URL 后发生的事情（核心）</h3><blockquote><p><strong>整体流程可以概括为五个阶段：输入域名 → DNS 解析 → 建立连接 → 请求响应 → 页面渲染。其中 DNS 是从域名到 IP 的入口，TCP 是可靠通信的保障，HTTP&#x2F;HTTPS 是传输层的协议规范，最后浏览器负责把字节变成视觉结果。</strong></p><p><a href="https://blog.csdn.net/wuhenliushui/article/details/20038819/">当你在浏览器地址栏输入一个 URL 后回车，将会发生的事情？ | CSDN</a></p></blockquote><ol><li><p>DNS 解析：浏览器 → 操作系统 → 本地 DNS→ 根 →TLD→ 权威 DNS → 得到服务器 IP。</p></li><li><p>建立 TCP 连接：通过三次握手（SYN → SYN+ACK → ACK）。若是 HTTPS，会在 TCP 之后进行 <strong>TLS 握手</strong>（证书校验 + 加密协商）。</p></li><li><p>发送 HTTP 请求：浏览器发出请求报文：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>www.baidu.com</span><br></pre></td></tr></table></figure></li><li><p>服务器处理请求：Web 服务器（如 Nginx）解析请求，调用后端逻辑，生成响应。</p></li><li><p>返回 HTTP 响应：返回状态码、响应头、HTML 正文等。</p></li><li><p>浏览器渲染页面</p><ul><li>解析 HTML → 构建 DOM 树。</li><li>解析 CSS → 构建 CSSOM 树。</li><li>执行 JS、合成渲染树、布局、绘制页面。</li></ul></li><li><p>建立持久连接（Keep-Alive）：用于减少后续请求的延迟。</p></li></ol><hr><h2 id="2-ICMP-协议"><a href="#2-ICMP-协议" class="headerlink" title="2. ICMP 协议"></a>2. ICMP 协议</h2><blockquote><p><strong>ICMP 是 IP 协议的辅助协议，主要用于网络诊断与错误报告。常见命令有 ping（检测连通性）和 traceroute（追踪路由路径）。ICMP 不属于传输层，没有端口号，而是直接封装在 IP 报文中。它让网络具备了‘自我反馈’能力，帮助发现问题所在。</strong></p></blockquote><h3 id="1-ICMP-是什么？"><a href="#1-ICMP-是什么？" class="headerlink" title="1. ICMP 是什么？"></a>1. ICMP 是什么？</h3><p><strong>ICMP（Internet Control Message Protocol）是 IP 协议的“信使”，负责在主机和路由器之间传递网络错误与状态信息。它不传输用户数据，只传递“控制消息”，用来检测、诊断和报告网络问题。</strong></p><h3 id="2-ICMP-的位置和关系"><a href="#2-ICMP-的位置和关系" class="headerlink" title="2. ICMP 的位置和关系"></a>2. ICMP 的位置和关系</h3><table><thead><tr><th>层级</th><th>常见协议</th></tr></thead><tbody><tr><td>应用层</td><td>HTTP、DNS</td></tr><tr><td>传输层</td><td>TCP、UDP</td></tr><tr><td>网络层</td><td>IP、ICMP、IGMP</td></tr><tr><td>数据链路层</td><td>MAC 帧、ARP、RARP</td></tr></tbody></table><p>ICMP 属于 <strong>网络层协议</strong>，但它是 <strong>IP 的上层协议</strong>（使用 IP 封装），IP 报文中 <code>Protocol 字段 = 1</code> 时，就表示这是一个 <strong>ICMP 报文</strong>。类比理解：</p><ul><li><strong>IP：送快递的司机。</strong></li><li><strong>ICMP：告诉司机“路堵了 &#x2F; 地址不存在 &#x2F; 包送到了”的消息员。</strong></li></ul><h3 id="3-ICMP-的功能"><a href="#3-ICMP-的功能" class="headerlink" title="3. ICMP 的功能"></a>3. ICMP 的功能</h3><ol><li><p><strong>错误报告：</strong> → 通知发送方网络中出现的问题。常见错误：</p><ul><li><p>目标不可达（Destination Unreachable）</p></li><li><p>超时（Time Exceeded）</p></li><li><p>重定向（Redirect）</p></li></ul></li><li><p><strong>诊断查询：</strong> → 用于检测网络状态，典型命令：<code>ping</code>、<code>traceroute</code>。</p></li></ol><h3 id="4-ICMP-常见类型"><a href="#4-ICMP-常见类型" class="headerlink" title="4. ICMP 常见类型"></a>4. ICMP 常见类型</h3><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20251010134038655.png" alt="PixPin_2025-10-10_13-40-34"></p><p>我们记几个关键的就行：</p><table><thead><tr><th>类型值</th><th>含义</th><th>应用场景</th></tr></thead><tbody><tr><td>0</td><td>Echo Reply</td><td>ping 回复</td></tr><tr><td>3</td><td>Destination Unreachable</td><td>目标不可达</td></tr><tr><td>5</td><td>Redirect</td><td>路由重定向</td></tr><tr><td>8</td><td>Echo Request</td><td>ping 请求</td></tr><tr><td>11</td><td>Time Exceeded</td><td>TTL 超时（用于 traceroute）</td></tr></tbody></table><h3 id="5-ICMP-报文格式（了解）"><a href="#5-ICMP-报文格式（了解）" class="headerlink" title="5. ICMP 报文格式（了解）"></a>5. ICMP 报文格式（了解）</h3><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20251010134259972.png" alt="PixPin_2025-10-10_13-42-56"></p><table><thead><tr><th>字段</th><th>说明</th></tr></thead><tbody><tr><td>Type</td><td>报文类型（例如 8 表示 Echo Request）</td></tr><tr><td>Code</td><td>进一步说明原因</td></tr><tr><td>Checksum</td><td>校验和</td></tr><tr><td>其他字段</td><td>根据类型不同变化</td></tr></tbody></table><hr><h3 id="6-两个典型工具：Ping-与-Traceroute"><a href="#6-两个典型工具：Ping-与-Traceroute" class="headerlink" title="6. 两个典型工具：Ping 与 Traceroute"></a>6. 两个典型工具：Ping 与 Traceroute</h3><h4 id="1-ping-命令工作流程"><a href="#1-ping-命令工作流程" class="headerlink" title="1. ping 命令工作流程"></a>1. ping 命令工作流程</h4><ol><li><code>ping www.baidu.com</code>。</li><li>DNS 解析 → <code>110.242.69.21</code>。</li><li>构造 IP 包：<code>Protocol=1</code>，ICMP 头 <code>Type=8</code>。</li><li>发送 → 目标主机收到后，<strong>自动返回 <code>Type=0</code></strong>。</li><li>统计：往返时间（RTT）、TTL、丢包率。</li></ol><blockquote><p><strong>常见面试陷阱：Q: ping 使用哪个端口？</strong><br><strong>A: 没有端口！ICMP 工作在网络层，绕过 TCP&#x2F;UDP，不涉及端口号。</strong></p></blockquote><h4 id="2-traceroute-命令"><a href="#2-traceroute-命令" class="headerlink" title="2. traceroute 命令"></a>2. traceroute 命令</h4><p><strong>功能：</strong> 追踪数据包经过的路径（每一跳路由器），也是基于 ICMP 协议实现，能够打印出可执行程序主机，一直到目标主机之前经历多少路由器。</p><p><strong>工作原理：</strong> 发送多个 IP 包，从 <code>TTL=1</code> 开始逐步递增，每经过一个路由器，TTL 就减 1，当 TTL 减为 0 时，该路由器丢弃包并返回 <code>ICMP Time Exceeded</code>，traceroute 收集所有返回的 IP → 得出路径。</p><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">traceroute www.baidu.com</span><br></pre></td></tr></table></figure><p>返回：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">root@hcss-ecs-be68:~# traceroute www.baidu.com</span><br><span class="line">traceroute to www.baidu.com (180.101.51.73), 30 hops max, 60 byte packets</span><br><span class="line"> 1  * * *</span><br><span class="line"> 2  * * *</span><br><span class="line"> 3  * * *</span><br><span class="line"> 4  * * *</span><br><span class="line"> 5  11.87.210.128 (11.87.210.128)  1.183 ms 11.87.111.128 (11.87.111.128)  1.284 ms 11.87.210.134 (11.87.210.134)  1.694 ms</span><br><span class="line"> 6  * * *</span><br><span class="line"> 7  * * *</span><br><span class="line"> 8  * * *</span><br><span class="line"> 9  172.16.65.70 (172.16.65.70)  3.104 ms  3.306 ms 180.163.107.161 (180.163.107.161)  4.342 ms</span><br><span class="line">10  180.163.107.177 (180.163.107.177)  3.115 ms  3.309 ms 101.95.246.65 (101.95.246.65)  4.649 ms</span><br><span class="line">11  101.95.224.125 (101.95.224.125)  5.762 ms 101.95.226.245 (101.95.226.245)  5.271 ms 101.95.219.21 (101.95.219.21)  4.961 ms</span><br><span class="line">12  * 101.95.219.65 (101.95.219.65)  4.649 ms 202.97.52.222 (202.97.52.222)  10.990 ms</span><br><span class="line">13  58.213.95.214 (58.213.95.214)  26.524 ms 202.97.101.54 (202.97.101.54)  7.736 ms 180.110.207.18 (180.110.207.18)  10.984 ms</span><br><span class="line">14  * * *</span><br><span class="line">15  58.213.96.50 (58.213.96.50)  10.689 ms * *</span><br><span class="line">16  * * *</span><br><span class="line">17  * * *</span><br><span class="line">18  * * *</span><br><span class="line">19  * * *</span><br><span class="line">20  * * *</span><br><span class="line">21  * * *</span><br><span class="line">22  * * *</span><br><span class="line">23  * * *</span><br><span class="line">24  * * *</span><br><span class="line">25  * * *</span><br><span class="line">26  * * *</span><br><span class="line">27  * * *</span><br><span class="line">28  * * *</span><br><span class="line">29  * * *</span><br><span class="line">30  * * *</span><br></pre></td></tr></table></figure><p>解释：</p><ul><li>1-4 跳：均显示 * * *，表示这些跳数的路由器未返回响应（可能因防火墙屏蔽或网络配置限制）。</li><li>第 5 跳：首次出现响应的节点（11.87.210.128 等），延迟约 1-1.7 毫秒，推测为本地网络内部的网关或交换机。</li><li>第 9-13 跳：连续出现响应的节点（如 172.16.65.70、180.163.107.161 等），延迟逐渐增加到 26 毫秒左右，这些是运营商骨干网的路由节点，逐步向百度服务器靠近。</li><li>14-30 跳：再次出现连续 * * *，说明到达目标前的最后几跳路由未响应，或目标服务器本身不返回 ICMP 响应。</li></ul><p>网络路径在经过 13 跳后未能完全到达目标服务器（百度可能屏蔽了追踪响应），前几跳的屏蔽通常是网络安全策略导致，属于正常现象，从响应节点的延迟来看，本地网络到运营商骨干网的连接正常（延迟较低）。</p><hr><h2 id="3-NAT-技术"><a href="#3-NAT-技术" class="headerlink" title="3. NAT 技术"></a>3. NAT 技术</h2><blockquote><p><a href="https://www.bilibili.com/video/BV1TK3YzmEJx/?share_source=copy_web&vd_source=872e5e3ccf44874c39edaf42e30ab0de">NAT(网络地址转换)是什么？一个视频带你看懂它 | B 站</a></p><p>[[网络知识] NAT 是什么？它有什么作用？一个视频带你了解清楚 NAT！ | B 站](<a href="https://www.bilibili.com/video/BV1rN89zCE1r/?share_source">https://www.bilibili.com/video/BV1rN89zCE1r/?share_source</a> &#x3D; copy_web&amp;vd_source &#x3D; 872e5e3ccf44874c39edaf42e30ab0de)</p><p><a href="https://www.bilibili.com/video/BV11M4y1J7zP/?share_source=copy_web&vd_source=872e5e3ccf44874c39edaf42e30ab0de">【虚拟机网络模式】NAT | NAT 网络 | 桥接 Bridged | 内部网络 Internal | 仅主机(Host-Only) | B 站</a></p></blockquote><blockquote><p><strong>摘自《趣味网络图解 —— 从基础到应用》46 页：</strong></p><ul><li>IPv4 地址有限，但通过 NAT 路由器，可以使得整个内网的多台机器对外只使用一个公网 IP 地址，大大节省了 IP 地址资源。</li><li>内网机器主动连接公网 IP 地址，中间的 NAT 会将内网机器的内网 IP 地址转换为公网 IP 地址，从而实现内网和外网的数据交互。</li><li>普通的 NAT 技术只会修改网络包中的发送端和接收端 IP 地址，当内网设备较多时，将有可能导致冲突。因此一般会使用 NAPT 技术，同时修改发送端和接收端的 <strong>IP 地址和端口</strong>。</li><li>由于 NAT 的存在，公网 IP 地址是无法访问内网服务的，但通过内网穿透技术，就可以让公网 IP 地址访问内网服务。一拨操作下来，就可以在公司的网络里访问家里的计算机。</li></ul></blockquote><h3 id="1-NAT-技术背景"><a href="#1-NAT-技术背景" class="headerlink" title="1. NAT 技术背景"></a>1. NAT 技术背景</h3><h4 id="1-问题来源"><a href="#1-问题来源" class="headerlink" title="1. 问题来源"></a>1. 问题来源</h4><p>IPv4 的地址是 32 位，最多支持约 43 亿个地址，随着网络设备爆炸式增长，公网 IP 远远不够用。</p><h4 id="2-解决思路"><a href="#2-解决思路" class="headerlink" title="2. 解决思路"></a>2. 解决思路</h4><p><strong>NAT（Network Address Translation，网络地址转换）：通过 “让多个内网设备共享一个公网 IP 上网”，解决 IP 不足问题。简单说：NAT 就是让一整个局域网看起来像只有一台主机在上网。</strong></p><h4 id="3-关键前提"><a href="#3-关键前提" class="headerlink" title="3. 关键前提"></a>3. 关键前提</h4><ul><li><strong>私有 IP</strong>：仅内网有效（如 <code>192.168.x.x</code>），可重复使用。</li><li><strong>公网 IP</strong>：全球唯一，由 ISP 分配。</li></ul><blockquote><p>  <strong>本质</strong>：NAT 是 <strong>IPv4 时代的“地址复用”技术</strong>，不是协议升级，而是“ workaround”。 </p></blockquote><h4 id="4-补充价值"><a href="#4-补充价值" class="headerlink" title="4. 补充价值"></a>4. 补充价值</h4><p>除了节省公网 IP，NAT 还能：</p><ul><li><strong>隐藏内网结构</strong>（提升安全性）。</li><li><strong>阻止外部主动访问内网主机</strong>（除非端口映射）。</li></ul><hr><h3 id="2-NAT-IP-转换过程（理解核心）"><a href="#2-NAT-IP-转换过程（理解核心）" class="headerlink" title="2. NAT IP 转换过程（理解核心）"></a>2. NAT IP 转换过程（理解核心）</h3><p>假设局域网有三台主机：A、B、C，它们都通过一台 <strong>NAT 路由器</strong> 上网。</p><h4 id="1-局域网-→-公网（出站）"><a href="#1-局域网-→-公网（出站）" class="headerlink" title="1. 局域网 → 公网（出站）"></a>1. 局域网 → 公网（出站）</h4><table><thead><tr><th>阶段</th><th>源 IP</th><th>目的 IP</th><th>说明</th></tr></thead><tbody><tr><td>主机 A 发包</td><td>192.168.1.10</td><td>8.8.8.8</td><td>源为私有 IP</td></tr><tr><td>路由器 NAT 转换</td><td><strong>203.0.113.5</strong></td><td>8.8.8.8</td><td>源地址改为路由器公网 IP</td></tr><tr><td>公网传输</td><td>203.0.113.5</td><td>8.8.8.8</td><td>已是公网间通信</td></tr></tbody></table><h4 id="2-公网-→-局域网（入站）"><a href="#2-公网-→-局域网（入站）" class="headerlink" title="2. 公网 → 局域网（入站）"></a>2. 公网 → 局域网（入站）</h4><table><thead><tr><th>阶段</th><th>源 IP</th><th>目的 IP</th><th>说明</th></tr></thead><tbody><tr><td>服务器发回</td><td>8.8.8.8</td><td><strong>203.0.113.5</strong></td><td>目标为 NAT 公网 IP</td></tr><tr><td>路由器查表</td><td>8.8.8.8</td><td>192.168.1.10</td><td>查 NAT 表反向转换</td></tr><tr><td>转发给主机 A</td><td>8.8.8.8</td><td>192.168.1.10</td><td>主机 A 收到数据</td></tr></tbody></table><blockquote><p>  NAT 路由器维护一张 “转换表”，记录了私网 IP ↔ 公网 IP 的映射关系。</p></blockquote><h3 id="3-NAPT（端口转换）-——-NAT-的升级版"><a href="#3-NAPT（端口转换）-——-NAT-的升级版" class="headerlink" title="3. NAPT（端口转换） —— NAT 的升级版"></a>3. NAPT（端口转换） —— NAT 的升级版</h3><h4 id="1-为什么需要-NAPT？"><a href="#1-为什么需要-NAPT？" class="headerlink" title="1. 为什么需要 NAPT？"></a>1. 为什么需要 NAPT？</h4><p>如果 A、B 两台主机同时访问同一个公网服务器：它们的源 IP 都被改成了同一个公网 IP（NAT 路由器的 IP），服务器返回时，路由器无法区分响应该转给谁，于是需要引入端口号。</p><h4 id="2-核心思路：IP-端口共同唯一标识一次通信"><a href="#2-核心思路：IP-端口共同唯一标识一次通信" class="headerlink" title="2. 核心思路：IP + 端口共同唯一标识一次通信"></a>2. 核心思路：IP + 端口共同唯一标识一次通信</h4><table><thead><tr><th>局域网主机</th><th>源 IP: 端口</th><th>映射后公网 IP: 端口</th></tr></thead><tbody><tr><td>主机 A</td><td>192.168.1.10:1025</td><td>203.0.113.5:1025</td></tr><tr><td>主机 B</td><td>192.168.1.11:1025</td><td>203.0.113.5:1026</td></tr></tbody></table><p>当服务器返回时：数据包目的地址 &#x3D; <code>203.0.113.5</code>，端口号 &#x3D; 1025 或 1026，路由器查表即可知道数据属于谁。这样既能让多台主机共享一个公网 IP，又能通过端口区分不同连接。</p><h3 id="4-NAT-技术的缺陷"><a href="#4-NAT-技术的缺陷" class="headerlink" title="4. NAT 技术的缺陷"></a>4. NAT 技术的缺陷</h3><ul><li><strong>无法从外网主动访问内网主机：</strong> 因为公网只看到 NAT 的一个 IP，不知道内部真实 IP，如果想访问内部服务器，需做“端口映射”。</li><li><strong>转换表有性能消耗：</strong> 每个连接都要建立 &#x2F; 查找 &#x2F; 维护映射表。</li><li><strong>连接中断问题：</strong> NAT 路由器重启或切换时，表清空 → 所有 TCP 连接断开。</li><li><strong>破坏端到端原则：</strong> 原本 IP 层应是“点到点”通信，NAT 插入其中，导致某些协议（如 P2P、IPsec）无法直接使用。</li></ul><h3 id="5-内网穿透"><a href="#5-内网穿透" class="headerlink" title="5. 内网穿透"></a>5. 内网穿透</h3><blockquote><p><a href="https://www.bilibili.com/video/BV1FV4xz9EPt/?share_source=copy_web&vd_source=872e5e3ccf44874c39edaf42e30ab0de">使用云服务器搭建内网穿透！纵享独属于个人的丝滑体验！| B 站</a></p></blockquote><p>内网穿透就是把位于私有网络、被 NAT 隐藏的内网服务暴露到公网，从而让公网客户端能访问内网主机。常见方法有端口映射、VPN、点对点打洞和中继&#x2F;反向代理等。NAT 把内网地址隐藏在路由器后面，若无公网地址或无端口映射，外部无法主动连入，内网穿透要么打洞（利用 NAT 的出站连接建立返向通路），要么中继&#x2F;代理（内网主动连到公网服务器，由公网服务器转发流量）。常见技术分类：</p><ul><li>端口映射&#x2F;端口转发：在路由器上手动映射端口。最简单但需路由器权限。</li><li>UDP&#x2F;TCP Hole Punching（打洞）：借助公服协调，让双方同时发起出站连接实现直连。适用于对称 NAT 以外的场景，不保证总能成功。</li><li>VPN &#x2F; 专线：把内网主机加入到公网可路由的虚拟网段，复杂但稳定。</li><li>中继&#x2F;反向代理（Relay&#x2F;Reverse Proxy）：内网客户端主动与公网中继服建立长连接，公网客户端连中继服由中继转发到内网。最稳健但需要公网服务器带宽。</li></ul><blockquote><p><strong>HTTP 隧道技术</strong>：在 HTTP 请求正文中携带加密的有效载荷数据，绕过运营商检测，实现外网访问，响应也进行加密处理后返回，还可套着 HTTP 壳子携带其他数据，如游戏数据。</p></blockquote><hr><h3 id="6-NAT-与代理服务器的区别（很容易混淆）"><a href="#6-NAT-与代理服务器的区别（很容易混淆）" class="headerlink" title="6. NAT 与代理服务器的区别（很容易混淆）"></a>6. NAT 与代理服务器的区别（很容易混淆）</h3><table><thead><tr><th>对比维度</th><th>NAT</th><th>代理服务器（Proxy）</th></tr></thead><tbody><tr><td>工作层次</td><td>网络层</td><td>应用层</td></tr><tr><td>处理对象</td><td>IP、端口</td><td>应用数据（HTTP、FTP 等）</td></tr><tr><td>主要目的</td><td>节省 IP、隐藏内网</td><td>缓存、访问控制、负载均衡</td></tr><tr><td>部署位置</td><td>路由器、防火墙设备</td><td>软件部署在服务器上</td></tr><tr><td>示例</td><td>家用无线路由器</td><td>Nginx、Squid、Apache</td></tr><tr><td>连接方向</td><td>双向透明</td><td>客户端或服务器主动配置</td></tr><tr><td>是否缓存内容</td><td>否</td><td>可缓存网页、资源</td></tr></tbody></table><blockquote><p>  <strong>NAT 是 IP 层的代理，Proxy 是 应用层的代理。</strong></p></blockquote><hr><h3 id="7-正向代理-vs-反向代理"><a href="#7-正向代理-vs-反向代理" class="headerlink" title="7. 正向代理 vs 反向代理"></a>7. 正向代理 vs 反向代理</h3><blockquote><p><strong>正向代理原理</strong>：利用国内可访问外网的服务器，将请求交给该服务器，经外网访问目标服务器，再将响应返回，服务器充当正向代理角色。</p></blockquote><h4 id="1-正反向代理"><a href="#1-正反向代理" class="headerlink" title="1. 正反向代理"></a>1. 正反向代理</h4><table><thead><tr><th>类型</th><th>位置</th><th>谁在用</th><th>作用</th></tr></thead><tbody><tr><td>正向代理</td><td>客户端侧</td><td>客户端搭建</td><td>访问受限网站、缓存内容</td></tr><tr><td>反向代理</td><td>服务端侧</td><td>服务端搭建</td><td>负载均衡、安全防护（如 Nginx）</td></tr></tbody></table><ul><li><p><strong>正向代理</strong>：<strong>客户端</strong> 用的（如公司上网代理，帮用户访问服务器）→ 隐藏客户端。</p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20251010164447854.png" alt="PixPin_2025-10-10_16-44-42"></p></li><li><p><strong>反向代理</strong>：<strong>服务端</strong> 用的（如帮服务器服务用户：Nginx 做负载均衡）→ 隐藏服务器。</p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20251010164542739.png" alt="PixPin_2025-10-10_16-45-37"></p></li></ul><h4 id="2-FRP-的介绍"><a href="#2-FRP-的介绍" class="headerlink" title="2. FRP 的介绍"></a>2. FRP 的介绍</h4><p><a href="https://github.com/fatedier/frp">FRP</a>（Fast Reverse Proxy）属于 <strong>反向代理 &#x2F; 中继型内网穿透工具</strong>。主要特点：分为 <code>frps</code>（部署在有公网 IP 的服务器）和 <code>frpc</code>（部署在内网主机），内网的 <code>frpc</code> 主动与 <code>frps</code> 建立并维持长连接，公网客户端连接 <code>frps</code> 的某个公网端口或域名，<code>frps</code> 将流量通过已建立的连接反向代理到对应的 <code>frpc</code>，支持 TCP&#x2F;UDP&#x2F;http&#x2F;https&#x2F;websocket 等协议和多路复用。</p><p>注意：FRP 不是纯打洞工具，它通过“内网发起出站连接到公服，然后公服中转”来实现穿透，适合不能修改路由器或无法打洞的场景。</p><h4 id="3-FRP-的工作流程（简短步骤）"><a href="#3-FRP-的工作流程（简短步骤）" class="headerlink" title="3. FRP 的工作流程（简短步骤）"></a>3. FRP 的工作流程（简短步骤）</h4><ol><li>在公网主机运行 <code>frps</code>，监听公网端口。</li><li>在内网主机运行 <code>frpc</code>，主动与 <code>frps</code> 建立持久连接并注册要暴露的服务。</li><li>公网用户访问 <code>frps</code> 的公网端口。</li><li><code>frps</code> 把流量通过 <code>frpc</code> 的长连接转发到内网服务。</li></ol><hr><h2 id="4-网络协议总结"><a href="#4-网络协议总结" class="headerlink" title="4. 网络协议总结"></a>4. 网络协议总结</h2><h3 id="1-应用层"><a href="#1-应用层" class="headerlink" title="1. 应用层"></a>1. 应用层</h3><ul><li>应用层的作用：负责应用程序间沟通，完成一系列业务处理所需服务。</li><li>能够根据自己的需求，设计对应的应用层协议。</li><li>了解 HTTP 协议。</li><li>理解 DNS 的原理和工作流程。</li></ul><h3 id="2-传输层"><a href="#2-传输层" class="headerlink" title="2. 传输层"></a>2. 传输层</h3><ul><li>传输层的作用：负责为两个网络通信进程之间的通信提供服务，更多的是为数据的传输提供一些策略。</li><li>理解端口号的概念。</li><li>认识 TCP 协议，理解 TCP 协议的可靠性，理解 TCP 协议的状态转化。</li><li>掌握 TCP 的连接管理、确认应答、超时重传、滑动窗口、流量控制、拥塞控制、延迟应答、捎带应答特性。</li><li>理解 TCP 面向字节流，理解粘包问题和解决方案。</li><li>能够基于 UDP 实现可靠传输。</li><li>理解 MTU 对 UDP&#x2F;TCP 的影响。</li></ul><h3 id="3-网络层"><a href="#3-网络层" class="headerlink" title="3. 网络层"></a>3. 网络层</h3><ul><li>网络层的作用：在复杂的网络环境中确定一条合适的路径。</li><li>理解 IP 地址，理解 IP 地址和 MAC 地址的区别。</li><li>理解 IP 协议格式。</li><li>理解如何解决 IP 数目不足的问题，掌握网段划分的两种方案，理解私有 IP 和公网 IP。</li><li>理解网络层的 IP 地址路由过程，理解一个数据包如何跨网段到达最终目的地。</li><li>理解 IP 数据包分片的原因。</li><li>了解 ICMP 协议。</li><li>了解 NAT 设备的工作原理。</li></ul><h3 id="4-数据链路层"><a href="#4-数据链路层" class="headerlink" title="4. 数据链路层"></a>4. 数据链路层</h3><ul><li>数据链路层的作用：负责局域网内两个设备之间的数据传递。</li><li>理解以太网通信原理</li><li>以太网帧格式。</li><li>理解 MAC 地址。</li><li>理解 ARP 协议。</li><li>理解 MTU。</li></ul>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;其他重要协议和技术&quot;&gt;&lt;a href=&quot;#其他重要协议和技术&quot; class=&quot;headerlink&quot; title=&quot;其他重要协议和技术&quot;&gt;&lt;/a&gt;其他重要协议和技术&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a</summary>
        
      
    
    
    
    <category term="Linux" scheme="https://www.minbit.top/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://www.minbit.top/tags/Linux/"/>
    
    <category term="网络" scheme="https://www.minbit.top/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>04 表的操作</title>
    <link href="https://www.minbit.top/posts/41394.html"/>
    <id>https://www.minbit.top/posts/41394.html</id>
    <published>2025-10-10T16:00:00.000Z</published>
    <updated>2025-10-20T02:10:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="表的操作"><a href="#表的操作" class="headerlink" title="表的操作"></a>表的操作</h1><h2 id="1-创建表"><a href="#1-创建表" class="headerlink" title="1. 创建表"></a>1. 创建表</h2><h3 id="1-语法格式"><a href="#1-语法格式" class="headerlink" title="1. 语法格式"></a>1. 语法格式</h3><p><code>CREATE TABLE</code> 用于在数据库中创建一张新的表，可以定义字段名、数据类型、约束等信息。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> [IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] 表名 (</span><br><span class="line">    列名<span class="number">1</span> 数据类型 [列级约束],</span><br><span class="line">    列名<span class="number">2</span> 数据类型 [列级约束],</span><br><span class="line">    ...</span><br><span class="line">    [表级约束]</span><br><span class="line">) [ENGINE<span class="operator">=</span>存储引擎] [<span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>字符集] [<span class="keyword">COLLATE</span><span class="operator">=</span>校验规则];</span><br></pre></td></tr></table></figure><p><strong>参数说明：</strong></p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>IF NOT EXISTS</code></td><td>如果表已存在则报错，<strong>没有才创建</strong></td></tr><tr><td><code>数据类型</code></td><td>定义字段所能存储的数据类型，如 <code>INT、CHAR、VARCHAR、DATE、FLOAT</code> 等</td></tr><tr><td><code>列级约束</code></td><td>针对单个列的约束，如 <code>NOT NULL、DEFAULT、AUTO_INCREMENT、PRIMARY KEY</code></td></tr><tr><td><code>表级约束</code></td><td>跨列的约束，如联合主键、外键等</td></tr><tr><td><code>ENGINE</code></td><td>存储引擎，如 <code>InnoDB</code>、<code>MyISAM</code></td></tr><tr><td><code>CHARSET</code></td><td>字符集，用于指定表所采用的 <strong>编码格式</strong>，如果没有指定则以所在数据库的编码格式为准。</td></tr><tr><td><code>COLLATE</code></td><td>字符比较&#x2F;校验规则，用于指定表所采用的校验规则，如果没有指定则以所在数据库的校验规则为准。</td></tr></tbody></table><table><thead><tr><th>常用字段数据类型简表</th><th>说明</th></tr></thead><tbody><tr><td><code>INT</code></td><td>整数（4 字节），范围类比 C++的 <code>int</code></td></tr><tr><td><code>BIGINT</code></td><td>大整数（8 字节），范围类比 C++的 <code>long long</code></td></tr><tr><td><code>VARCHAR(N)</code></td><td>可变长字符串，N 为最大字符数（如 <code>VARCHAR(50)</code>）</td></tr><tr><td><code>CHAR(N)</code></td><td>定长字符串（不足补空格）</td></tr><tr><td><code>TEXT</code></td><td>长文本（最大 65535 字节）</td></tr><tr><td><code>DATETIME</code></td><td>日期时间（格式：<code>YYYY-MM-DD HH:MM:SS</code>）</td></tr><tr><td><code>TIMESTAMP</code></td><td>时间戳（自动记录修改时间，范围较小）</td></tr><tr><td><code>DECIMAL(M,D)</code></td><td>精确小数，M 为总位数，D 为小数位数（如 <code>DECIMAL(10,2)</code>）</td></tr></tbody></table><blockquote><p>  <strong>建议</strong>：字符串优先用 <code>VARCHAR</code>，文本内容多用 <code>TEXT</code>；时间用 <code>DATETIME</code> 更直观。 </p></blockquote><table><thead><tr><th>常见的列级约束</th><th>作用</th><th>示例</th></tr></thead><tbody><tr><td><code>NOT NULL</code></td><td>该列值不能为空</td><td><code>name VARCHAR(50) NOT NULL</code></td></tr><tr><td><code>DEFAULT</code></td><td>设置默认值</td><td><code>age INT DEFAULT 18</code></td></tr><tr><td><code>AUTO_INCREMENT</code></td><td>自动增长（仅整数列可用）</td><td><code>id INT AUTO_INCREMENT</code></td></tr><tr><td><code>PRIMARY KEY</code></td><td>指定该列为主键（唯一且非空）</td><td><code>id INT PRIMARY KEY</code></td></tr><tr><td><code>UNIQUE</code></td><td>唯一约束</td><td><code>email VARCHAR(100) UNIQUE</code></td></tr><tr><td><code>COMMENT</code></td><td>添加列注释</td><td><code>grade VARCHAR(20) COMMENT &#39;学生年级&#39;</code></td></tr></tbody></table><hr><h3 id="2-创建表示例"><a href="#2-创建表示例" class="headerlink" title="2. 创建表示例"></a>2. 创建表示例</h3><blockquote><p>在 <code>CREATE TABLE</code> 语句中，括号内需要定义表的列结构（<strong>至少要有一个列</strong>），比如 <code>create table students();</code> 括号内是空的，没有指定任何列，这不符合 MySQL 的语法规则，会报错！</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 创建学生表（如果不存在）</span><br><span class="line"><span class="keyword">CREATE TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> students(</span><br><span class="line">    id <span class="type">int</span> comment <span class="string">&#x27;用户的ID&#x27;</span>,  # 学生的唯一标识ID</span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">50</span>) comment <span class="string">&#x27;用户的姓名&#x27;</span>,  # 学生的姓名信息</span><br><span class="line">    age <span class="type">int</span> <span class="keyword">default</span> <span class="number">18</span> comment <span class="string">&#x27;学生的年龄，默认值为18&#x27;</span>,  # 学生的年龄，未指定时默认为<span class="number">18</span></span><br><span class="line">    enrollment_date <span class="type">DATE</span> comment <span class="string">&#x27;学生的入学日期&#x27;</span>  # 学生办理入学的日期</span><br><span class="line">)ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8mb4_unicode_ci comment <span class="string">&#x27;存储学生基本信息的表&#x27;</span>;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong> 创建的表会自动存储在当前数据库对应的目录中（如 <code>/var/lib/mysql/test/students.ibd</code>），如果忘记写 <code>IF NOT EXISTS</code>，当表名重复时会报错。</p><blockquote><p>说明一下：</p><ul><li>采用不同的存储引擎，创建表时所产生的文件不一样。 </li><li>比如采用 InnoDB 存储引擎建表，会产生对应的 xxx.frm（表结构）和 xxx.ibd（表数据+表索引）文件。 </li><li>比如采用 MyISAM 存储引擎建表，会产生对应的 xxx.frm（表结构）、xxx.MYD（表数据）和 xxx.MYI（表索引）文件。</li></ul></blockquote><h3 id="3-插入数据"><a href="#3-插入数据" class="headerlink" title="3. 插入数据"></a>3. 插入数据</h3><p><code>INSERT INTO</code> 用于向表中添加新的数据行，其基本语法有两种形式：<strong>指定列插入</strong> 和 <strong>全列插入</strong>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 语法<span class="number">1</span>：指定列插入（推荐写法）</span><br><span class="line"><span class="keyword">INSERT INTO</span> 表名 (列<span class="number">1</span>, 列<span class="number">2</span>, 列<span class="number">3</span>, ...)</span><br><span class="line"><span class="keyword">VALUES</span> (值<span class="number">1</span>, 值<span class="number">2</span>, 值<span class="number">3</span>, ...);</span><br><span class="line"></span><br><span class="line"># 语法<span class="number">2</span>：全列插入（列名可省略，但必须按顺序写全）</span><br><span class="line"><span class="keyword">INSERT INTO</span> 表名</span><br><span class="line"><span class="keyword">VALUES</span> (值<span class="number">1</span>, 值<span class="number">2</span>, 值<span class="number">3</span>, ...);</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 插入数据时，<strong>列名与值的顺序和数量必须一一对应</strong>，如果某列有默认值或允许为 <code>NULL</code>，可在插入时省略，字符串和日期型值需用 <strong>单引号 <code>&#39; &#39;</code></strong> 包裹。假设表结构：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> students (</span><br><span class="line">    id <span class="type">INT</span> AUTO_INCREMENT <span class="keyword">PRIMARY KEY</span> COMMENT <span class="string">&#x27;学号&#x27;</span>,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;姓名&#x27;</span>,</span><br><span class="line">    age <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">18</span> COMMENT <span class="string">&#x27;年龄&#x27;</span>,</span><br><span class="line">    enrollment_date <span class="type">DATE</span> COMMENT <span class="string">&#x27;入学日期&#x27;</span></span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4;</span><br></pre></td></tr></table></figure><p>插入数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># 插入所有列（标准写法）</span><br><span class="line"><span class="keyword">insert into</span> students (name, age, enrollment_date)</span><br><span class="line"><span class="keyword">values</span> (<span class="string">&#x27;张三&#x27;</span>, <span class="number">20</span>, <span class="string">&#x27;2025-01-01&#x27;</span>);</span><br><span class="line"></span><br><span class="line"># 省略可默认列（自动填默认值），age 会默认填 <span class="number">18</span>，id 自动递增</span><br><span class="line"><span class="keyword">insert into</span> students (name)</span><br><span class="line"><span class="keyword">values</span> (<span class="string">&#x27;李四&#x27;</span>);</span><br><span class="line"></span><br><span class="line"># 同时插入多条数据</span><br><span class="line"><span class="keyword">insert into</span> students (name, age, enrollment_date)</span><br><span class="line"><span class="keyword">values</span> </span><br><span class="line">(<span class="string">&#x27;王五&#x27;</span>, <span class="number">19</span>, <span class="string">&#x27;2024-09-01&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;赵六&#x27;</span>, <span class="number">21</span>, <span class="string">&#x27;2023-09-01&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;钱七&#x27;</span>, <span class="number">22</span>, <span class="string">&#x27;2022-09-01&#x27;</span>);</span><br><span class="line"></span><br><span class="line"># 插入所有列（不写列名）：必须按照建表时字段的定义顺序填写所有列</span><br><span class="line">#  如果主键为自增列，可使用 <span class="keyword">NULL</span> 或 <span class="keyword">DEFAULT</span> 占位</span><br><span class="line"><span class="keyword">insert into</span> students</span><br><span class="line"><span class="keyword">values</span> (<span class="keyword">NULL</span>, <span class="string">&#x27;刘八&#x27;</span>, <span class="number">23</span>, <span class="string">&#x27;2022-09-01&#x27;</span>);</span><br><span class="line"></span><br><span class="line"># ……</span><br></pre></td></tr></table></figure><hr><h2 id="2-查看表结构"><a href="#2-查看表结构" class="headerlink" title="2. 查看表结构"></a>2. 查看表结构</h2><h3 id="1-查看当前数据库中所有表"><a href="#1-查看当前数据库中所有表" class="headerlink" title="1. 查看当前数据库中所有表"></a>1. 查看当前数据库中所有表</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> TABLES;</span><br><span class="line"><span class="keyword">show</span> tables;</span><br></pre></td></tr></table></figure><h3 id="2-查看表结构定义"><a href="#2-查看表结构定义" class="headerlink" title="2. 查看表结构定义"></a>2. 查看表结构定义</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DESC</span> 表名;</span><br><span class="line"><span class="keyword">DESCRIBE</span> 表名;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">desc</span> students;</span><br><span class="line"><span class="keyword">describe</span> students;</span><br></pre></td></tr></table></figure><p>输出示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">desc</span> students;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+-------------+------+-----+---------+-------+</span></span><br><span class="line"><span class="operator">|</span> Field           <span class="operator">|</span> Type        <span class="operator">|</span> <span class="keyword">Null</span> <span class="operator">|</span> Key <span class="operator">|</span> <span class="keyword">Default</span> <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+-------------+------+-----+---------+-------+</span></span><br><span class="line"><span class="operator">|</span> id              <span class="operator">|</span> <span class="type">int</span>         <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> name            <span class="operator">|</span> <span class="type">varchar</span>(<span class="number">50</span>) <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> age             <span class="operator">|</span> <span class="type">int</span>         <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="number">18</span>      <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> enrollment_date <span class="operator">|</span> <span class="type">date</span>        <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+-------------+------+-----+---------+-------+</span></span><br><span class="line"><span class="number">4</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><table><thead><tr><th>列名（表头）</th><th>含义</th></tr></thead><tbody><tr><td><strong>Field</strong></td><td>列名（字段名），即表中每一列的名称</td></tr><tr><td><strong>Type</strong></td><td><strong>数据类型</strong>，例如 <code>int</code>、<code>varchar(50)</code>、<code>date</code> 等</td></tr><tr><td><strong>Null</strong></td><td>是否允许为 <code>NULL</code>，<code>YES</code> 表示可为空，<code>NO</code> 表示必须有值</td></tr><tr><td><strong>Key</strong></td><td>键类型（约束标识） ：<br>空：无约束<br><code>PRI</code>：主键（Primary Key）<br><code>UNI</code>：唯一键（Unique）<br><code>MUL</code>：普通索引（Multiple，可重复）</td></tr><tr><td><strong>Default</strong></td><td>默认值，如果未指定则为 <code>NULL</code> 或系统默认</td></tr><tr><td><strong>Extra</strong></td><td>额外属性，如：<br><code>auto_increment</code>：自动增长<br><code>on update CURRENT_TIMESTAMP</code>：自动更新时间</td></tr></tbody></table><h3 id="3-查看建表语句"><a href="#3-查看建表语句" class="headerlink" title="3. 查看建表语句"></a>3. 查看建表语句</h3><blockquote><p>还是一样，<code>SHOW CREATE TABLE 表名;</code> 大概率会有点乱码的感觉，不太美观，加上 <code>\G</code> 选项会好一点。</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE TABLE</span> 表名;</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create table</span> students;</span><br></pre></td></tr></table></figure><p>输出示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> <span class="keyword">create table</span> students\G;</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">       <span class="keyword">Table</span>: students</span><br><span class="line"><span class="keyword">Create Table</span>: <span class="keyword">CREATE TABLE</span> `students` (</span><br><span class="line">  `id` <span class="type">int</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;用户的ID&#x27;</span>,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">COLLATE</span> utf8mb4_unicode_ci <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;用户的姓名&#x27;</span>,</span><br><span class="line">  `age` <span class="type">int</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;18&#x27;</span> COMMENT <span class="string">&#x27;学生的年龄，默认值为18&#x27;</span>,</span><br><span class="line">  `enrollment_date` <span class="type">date</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;学生的入学日期&#x27;</span></span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8mb4_unicode_ci COMMENT<span class="operator">=</span><span class="string">&#x27;存储学生基本信息的表&#x27;</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure><blockquote><p>  <code>SHOW CREATE TABLE</code> 可用于复制表结构、备份或迁移时查看完整建表 SQL。</p></blockquote><hr><h3 id="4-查看表中数据"><a href="#4-查看表中数据" class="headerlink" title="4. 查看表中数据"></a>4. 查看表中数据</h3><h4 id="1-语法格式-1"><a href="#1-语法格式-1" class="headerlink" title="1. 语法格式"></a>1. 语法格式</h4><p><code>SELECT</code> 语句用于 <strong>从表中查询数据</strong>，是最常用的 SQL 语句之一。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> [字段列表 <span class="operator">|</span> <span class="operator">*</span>]</span><br><span class="line"><span class="keyword">FROM</span> 表名</span><br><span class="line">[<span class="keyword">WHERE</span> 条件]</span><br><span class="line">[<span class="keyword">ORDER</span> <span class="keyword">BY</span> 字段 [<span class="keyword">ASC</span><span class="operator">|</span><span class="keyword">DESC</span>]]</span><br><span class="line">[LIMIT 偏移量, 行数];</span><br></pre></td></tr></table></figure><p><strong>说明：</strong> <code>SELECT *</code> 表示查询所有字段，查询结果不会修改数据，是 <strong>只读操作</strong>，查询时可以加上条件、排序、分页等功能。</p><h4 id="2-基本查询"><a href="#2-基本查询" class="headerlink" title="2. 基本查询"></a>2. 基本查询</h4><p><strong>查询所有数据：</strong> 查询整张表的所有字段和所有记录。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 表名;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 表名</span><br></pre></td></tr></table></figure><p><strong>查询指定字段：</strong> 只查询所需的列，提高查询效率。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id, name, age <span class="keyword">FROM</span> students;</span><br></pre></td></tr></table></figure><p>为字段添加别名（方便阅读）：<code>AS</code> 可选，用于重命名列标题。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id <span class="keyword">AS</span> 学号, name <span class="keyword">AS</span> 姓名, age <span class="keyword">AS</span> 年龄 <span class="keyword">FROM</span> students;</span><br></pre></td></tr></table></figure><h4 id="3-条件查询"><a href="#3-条件查询" class="headerlink" title="3. 条件查询"></a>3. 条件查询</h4><p>用于 <strong>筛选</strong> 符合条件的数据行，支持运算符：<code>=</code>, <code>!=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>, <code>AND</code>, <code>OR</code>, <code>IN</code>, <code>LIKE</code>, <code>BETWEEN</code> 等。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 查询年龄大于 <span class="number">18</span> 的学生</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> students <span class="keyword">WHERE</span> age <span class="operator">&gt;</span> <span class="number">18</span>;</span><br><span class="line"></span><br><span class="line"># 查询年龄在 <span class="number">18</span> 到 <span class="number">22</span> 之间的学生</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> students <span class="keyword">where</span> age <span class="keyword">between</span> <span class="number">18</span> <span class="keyword">and</span> <span class="number">22</span>;</span><br><span class="line"></span><br><span class="line"># 查询名字为张三的学生</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> students <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;张三&#x27;</span>;</span><br><span class="line"></span><br><span class="line"># 查询名字中包含“张”的学生（模糊匹配）</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> students <span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;%张%&#x27;</span>;</span><br></pre></td></tr></table></figure><h4 id="4-排序"><a href="#4-排序" class="headerlink" title="4. 排序"></a>4. 排序</h4><p>用于按指定字段对结果进行 <strong>升序</strong> 或 <strong>降序</strong> 排序，<strong>默认排序为 <code>ASC</code>（升序），降序需显式写 <code>DESC</code>。</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 按年龄升序排列</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> students <span class="keyword">ORDER</span> <span class="keyword">BY</span> age <span class="keyword">ASC</span>;</span><br><span class="line"></span><br><span class="line"># 按入学日期降序排列</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> students <span class="keyword">order</span> <span class="keyword">by</span> enrollment_date <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure><h4 id="5-限制返回行数"><a href="#5-限制返回行数" class="headerlink" title="5. 限制返回行数"></a>5. 限制返回行数</h4><p><strong>用于分页或仅查看前几条数据。格式：<code>LIMIT 起始偏移量, 行数</code>。</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 查看前 <span class="number">5</span> 条记录</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> students LIMIT <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"># 跳过前 <span class="number">5</span> 条，显示接下来的 <span class="number">5</span> 条（常用于分页）</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> students LIMIT <span class="number">5</span>, <span class="number">5</span>;</span><br></pre></td></tr></table></figure><h4 id="6-扩展：去重查询"><a href="#6-扩展：去重查询" class="headerlink" title="6. 扩展：去重查询"></a>6. 扩展：去重查询</h4><p>如果想去除重复值，可使用 <code>DISTINCT</code>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> age <span class="keyword">FROM</span> students;# 查询表中出现过的年龄，不重复显示。</span><br></pre></td></tr></table></figure><h4 id="7-小结"><a href="#7-小结" class="headerlink" title="7. 小结"></a>7. 小结</h4><table><thead><tr><th>功能</th><th>关键字</th><th>示例</th></tr></thead><tbody><tr><td><strong>查询所有字段</strong></td><td><strong><code>SELECT * FROM 表名;</code></strong></td><td><strong>查询整表数据</strong></td></tr><tr><td>查询部分字段</td><td><code>SELECT 列1,列2 FROM 表名;</code></td><td>查询指定列</td></tr><tr><td>条件筛选</td><td><code>WHERE</code></td><td><code>WHERE age&gt;18</code></td></tr><tr><td>排序</td><td><code>ORDER BY</code></td><td><code>ORDER BY age DESC</code></td></tr><tr><td>限制行数</td><td><code>LIMIT</code></td><td><code>LIMIT 10</code></td></tr><tr><td>去重</td><td><code>DISTINCT</code></td><td><code>SELECT DISTINCT age</code></td></tr><tr><td>列别名</td><td><code>AS</code></td><td><code>name AS 姓名</code></td></tr></tbody></table><h2 id="3-修改表"><a href="#3-修改表" class="headerlink" title="3. 修改表"></a>3. 修改表</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># <span class="number">1.</span> 修改表名</span><br><span class="line"><span class="keyword">ALTER TABLE</span> 旧表名 RENAME <span class="keyword">TO</span> 新表名;</span><br><span class="line"><span class="keyword">ALTER TABLE</span> 旧表名 RENAME <span class="keyword">AS</span> 新表名;</span><br><span class="line"></span><br><span class="line"># <span class="number">2.</span> 新增字段</span><br><span class="line"><span class="keyword">ALTER TABLE</span> 表名 <span class="keyword">ADD</span> [<span class="keyword">COLUMN</span>] 新增列名 数据类型 [约束条件] [<span class="keyword">FIRST</span><span class="operator">|</span>AFTER 现有列名];</span><br><span class="line"></span><br><span class="line"># <span class="number">3.</span> 删除字段</span><br><span class="line"><span class="keyword">ALTER TABLE</span> 表名 <span class="keyword">DROP</span> [<span class="keyword">COLUMN</span>] 列名;</span><br><span class="line"></span><br><span class="line"># <span class="number">4.</span> 修改字段类型或属性</span><br><span class="line"><span class="keyword">ALTER TABLE</span> 表名 MODIFY [<span class="keyword">COLUMN</span>] 列名 新数据类型 [新约束条件];</span><br><span class="line"></span><br><span class="line"># <span class="number">5.</span> 修改字段名和类型</span><br><span class="line"><span class="keyword">ALTER TABLE</span> 表名 CHANGE [<span class="keyword">COLUMN</span>] 旧列名 新列名 新数据类型 [新约束条件];</span><br><span class="line"></span><br><span class="line"># <span class="number">6.</span> 修改表的字符集</span><br><span class="line"><span class="keyword">ALTER TABLE</span> 表名 <span class="keyword">DEFAULT</span> <span class="keyword">CHARACTER SET</span> 字符集 <span class="keyword">COLLATE</span> 校验规则;</span><br><span class="line"><span class="keyword">ALTER TABLE</span> 表名 <span class="keyword">CONVERT</span> <span class="keyword">TO</span> <span class="keyword">CHARACTER SET</span> 字符集 <span class="keyword">COLLATE</span> 校验规则;</span><br></pre></td></tr></table></figure><h3 id="1-修改表名"><a href="#1-修改表名" class="headerlink" title="1. 修改表名"></a>1. 修改表名</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter table</span> students rename <span class="keyword">to</span> student;# 将表名 students 改为 student</span><br></pre></td></tr></table></figure><h3 id="2-新增字段"><a href="#2-新增字段" class="headerlink" title="2. 新增字段"></a>2. 新增字段</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter table</span> student <span class="keyword">add</span> <span class="keyword">column</span> address <span class="type">varchar</span>(<span class="number">20</span>);</span><br><span class="line"># 使用 <span class="keyword">add</span> <span class="keyword">column</span> 在表末尾新增字段，若要插入到指定位置，可加 AFTER 或 <span class="keyword">FIRST</span></span><br></pre></td></tr></table></figure><h3 id="3-删除字段"><a href="#3-删除字段" class="headerlink" title="3. 删除字段"></a>3. 删除字段</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter table</span> student <span class="keyword">drop</span> address;# 删除指定列</span><br><span class="line"><span class="keyword">alter table</span> student <span class="keyword">drop</span> [<span class="keyword">column</span>] address;</span><br></pre></td></tr></table></figure><h3 id="4-修改字段类型或属性"><a href="#4-修改字段类型或属性" class="headerlink" title="4. 修改字段类型或属性"></a>4. 修改字段类型或属性</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter table</span> student modify id <span class="type">bigint</span>;</span><br><span class="line"><span class="keyword">alter table</span> student modify [<span class="keyword">column</span>] id <span class="type">bigint</span>;</span><br><span class="line"><span class="keyword">alter table</span> student modify <span class="keyword">column</span> id <span class="type">bigint</span> <span class="keyword">default</span> <span class="number">18</span>;</span><br></pre></td></tr></table></figure><h3 id="5-修改字段名"><a href="#5-修改字段名" class="headerlink" title="5. 修改字段名"></a>5. 修改字段名</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter table</span> student change age student_age <span class="type">int</span>;</span><br><span class="line"><span class="keyword">alter table</span> student change <span class="keyword">column</span> student_age student_age <span class="type">bigint</span>;</span><br></pre></td></tr></table></figure><h3 id="6-修改表的字符集"><a href="#6-修改表的字符集" class="headerlink" title="6. 修改表的字符集"></a>6. 修改表的字符集</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter table</span> student <span class="keyword">default</span> <span class="keyword">character set</span> utf8mb4 <span class="keyword">collate</span> utf8mb4_general_ci;</span><br><span class="line"><span class="keyword">alter table</span> student <span class="keyword">convert</span> <span class="keyword">to</span> <span class="keyword">character set</span> utf8mb4 <span class="keyword">collate</span> utf8mb4_general_ci;</span><br></pre></td></tr></table></figure><blockquote><p>  <strong>说明：</strong></p><ul><li><code>ADD</code>：新增列。</li><li><code>DROP</code>：删除列。</li><li><code>MODIFY</code>：修改列属性或类型。</li><li><code>CHANGE</code>：修改列名和类型。</li><li><code>RENAME TO</code>：重命名表。</li><li><code>DEFAULT CHARACTER SET / CONVERT TO</code>：修改表字符集。</li></ul></blockquote><hr><h2 id="5-删除表"><a href="#5-删除表" class="headerlink" title="5. 删除表"></a>5. 删除表</h2><p><strong>语法格式：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> [IF <span class="keyword">EXISTS</span>] 表名;</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> students;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li><code>IF EXISTS</code> 避免表不存在时报错。</li><li>删除表会直接移除表结构和数据（对应 <code>.ibd</code> 文件会被删除）。</li><li>删除不可恢复，请谨慎执行。</li></ul><h2 id="6-小结"><a href="#6-小结" class="headerlink" title="6. 小结"></a>6. 小结</h2><blockquote><p><strong>ALTER 改形状，INSERT 改内容，SELECT 只读不动。</strong></p></blockquote><table><thead><tr><th>层级</th><th>操作目标</th><th>示例命令</th><th>修改对象</th><th>是否改变数据内容</th><th>是否改变表结构</th><th>说明</th></tr></thead><tbody><tr><td><strong>库级操作</strong></td><td>数据库本身</td><td><code>CREATE DATABASE db1;</code></td><td>数据库目录（文件夹）</td><td>❌ 否</td><td>✅ 是</td><td>创建&#x2F;删除&#x2F;修改数据库的元信息和配置</td></tr><tr><td></td><td></td><td><code>ALTER DATABASE db1 CHARACTER SET utf8mb4;</code></td><td>数据库默认字符集</td><td>❌</td><td>✅</td><td>仅影响默认字符集，不动数据</td></tr><tr><td></td><td></td><td><code>DROP DATABASE db1;</code></td><td>数据库及其所有表</td><td>✅（全删）</td><td>✅</td><td>删除整个数据库目录与数据文件</td></tr><tr><td><strong>表级操作</strong></td><td>表定义（结构）</td><td><code>CREATE TABLE students(...);</code></td><td>表结构定义（列信息）</td><td>❌</td><td>✅</td><td>新建表结构文件（如 .frm&#x2F;.ibd）</td></tr><tr><td></td><td></td><td><code>ALTER TABLE students ADD COLUMN address VARCHAR(200);</code></td><td>新增字段定义</td><td>✅（为每行增加 NULL 值）</td><td>✅</td><td>改表结构，所有行增加新列空间</td></tr><tr><td></td><td></td><td><code>ALTER TABLE students DROP COLUMN age;</code></td><td>删除字段定义</td><td>✅（清除该列数据）</td><td>✅</td><td>删列即删该列所有数据</td></tr><tr><td></td><td></td><td><code>ALTER TABLE students MODIFY COLUMN name VARCHAR(100);</code></td><td>修改字段属性</td><td>❌（仅调整结构）</td><td>✅</td><td>不动已有数据内容</td></tr><tr><td></td><td></td><td><code>ALTER TABLE students CHANGE COLUMN name username VARCHAR(100);</code></td><td>修改列名及类型</td><td>❌</td><td>✅</td><td>元数据变化，数据保留</td></tr><tr><td></td><td></td><td><code>ALTER TABLE students RENAME TO student_info;</code></td><td>修改表名</td><td>❌</td><td>✅</td><td>表文件名变化，数据不动</td></tr><tr><td></td><td></td><td><code>DROP TABLE students;</code></td><td>整个表</td><td>✅（全删）</td><td>✅</td><td>删除表结构与数据文件</td></tr><tr><td><strong>行级操作</strong></td><td>表中的记录（数据行）</td><td><code>INSERT INTO students VALUES(...);</code></td><td>新增数据行</td><td>✅</td><td>❌</td><td>向表中插入实际数据</td></tr><tr><td></td><td></td><td><code>UPDATE students SET age=20 WHERE id=1;</code></td><td>更新指定行字段值</td><td>✅</td><td>❌</td><td>修改已有数据内容</td></tr><tr><td></td><td></td><td><code>DELETE FROM students WHERE id=1;</code></td><td>删除行记录</td><td>✅</td><td>❌</td><td>删除指定数据行</td></tr><tr><td></td><td></td><td><code>SELECT * FROM students;</code></td><td>查询结果集</td><td>❌</td><td>❌</td><td>只读操作，不改变任何内容</td></tr></tbody></table>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;表的操作&quot;&gt;&lt;a href=&quot;#表的操作&quot; class=&quot;headerlink&quot; title=&quot;表的操作&quot;&gt;&lt;/a&gt;表的操作&lt;/h1&gt;&lt;h2 id=&quot;1-创建表&quot;&gt;&lt;a href=&quot;#1-创建表&quot; class=&quot;headerlink&quot; title=&quot;1.</summary>
        
      
    
    
    
    <category term="MySQL" scheme="https://www.minbit.top/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="https://www.minbit.top/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>03 库的操作</title>
    <link href="https://www.minbit.top/posts/19289.html"/>
    <id>https://www.minbit.top/posts/19289.html</id>
    <published>2025-10-10T16:00:00.000Z</published>
    <updated>2025-10-11T02:10:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="库的操作"><a href="#库的操作" class="headerlink" title="库的操作"></a>库的操作</h1><h2 id="1-创建数据库"><a href="#1-创建数据库" class="headerlink" title="1. 创建数据库"></a>1. 创建数据库</h2><h3 id="1-语法格式"><a href="#1-语法格式" class="headerlink" title="1. 语法格式"></a>1. 语法格式</h3><p><code>CREATE DATABASE</code> 用于在 MySQL 中创建新的数据库，可以同时指定字符集（编码格式）和校验规则。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE [IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] 数据库名 [<span class="keyword">DEFAULT</span> <span class="keyword">CHARACTER SET</span> 字符集名] [<span class="keyword">DEFAULT</span> <span class="keyword">COLLATE</span> 校验规则];</span><br><span class="line"><span class="keyword">CREATE</span> DATABASE [IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] 数据库名 [[<span class="keyword">DEFAULT</span>] CHARSET<span class="operator">=</span>字符集名] [[<span class="keyword">DEFAULT</span>] <span class="keyword">COLLATE</span><span class="operator">=</span>校验规则];</span><br></pre></td></tr></table></figure><blockquote><p><strong>其中带 <code>[]</code> 表示可选项，不写就会自动选择默认的配置。sql 语句也可以使用小写，会自动识别！在之后的讲解中，我会尽量使用多种写法来展示同一条 sql 语句的效果。</strong></p></blockquote><p><strong>参数详解：</strong></p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>IF NOT EXISTS</code></td><td>如果没有就创建，如果已有同名的则报错：提示无法创建，因为已存在</td></tr><tr><td><code>DEFAULT CHARACTER SET</code></td><td>指定数据库的默认字符集（如 utf8、utf8mb4 等）</td></tr><tr><td><code>DEFAULT COLLATE</code></td><td>指定校验规则，即字符串比较、排序方式</td></tr><tr><td><code>数据库名</code></td><td>自定义的新数据库名称</td></tr></tbody></table><blockquote><p>  注：字符集决定存储文字的编码方式；校验规则决定字符串的比较方式。例如 <code>utf8_general_ci</code> 表示 utf8 字符集下，比较时不区分大小写（ci &#x3D; case insensitive）。</p></blockquote><h3 id="2-采用默认编码格式和校验规则创建数据库"><a href="#2-采用默认编码格式和校验规则创建数据库" class="headerlink" title="2. 采用默认编码格式和校验规则创建数据库"></a>2. 采用默认编码格式和校验规则创建数据库</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE test;# 创建一个名为 test 的库，对应 <span class="operator">/</span>var<span class="operator">/</span>lib<span class="operator">/</span>mysql<span class="operator">/</span> 下的 test 文件夹 </span><br></pre></td></tr></table></figure><p>使用 MySQL 配置文件中默认的字符集与校验规则，根据我们的配置会自动选择 <code>utf8mb4</code> 和 <code>utf8mb4_general_ci</code>。</p><h3 id="3-指定-UTF-8-编码格式创建数据库"><a href="#3-指定-UTF-8-编码格式创建数据库" class="headerlink" title="3. 指定 UTF-8 编码格式创建数据库"></a>3. 指定 UTF-8 编码格式创建数据库</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE mydb_utf8 <span class="keyword">DEFAULT</span> <span class="keyword">CHARACTER SET</span> utf8;</span><br><span class="line"><span class="keyword">create</span> database mydb_utf8 charset<span class="operator">=</span>utf8;</span><br><span class="line"># 创建一个名为 mydb_utf8 的库，并设置默认字符集为 utf8，对应 <span class="operator">/</span>var<span class="operator">/</span>lib<span class="operator">/</span>mysql<span class="operator">/</span> 下的 mydb_utf8 文件夹</span><br></pre></td></tr></table></figure><p>仅指定字符集为 <code>utf8</code>，校验规则会自动采用该字符集的默认规则（即 <code>utf8_general_ci</code>）。</p><h3 id="4-指定-UTF-8-编码格式与校验规则创建数据库"><a href="#4-指定-UTF-8-编码格式与校验规则创建数据库" class="headerlink" title="4. 指定 UTF-8 编码格式与校验规则创建数据库"></a>4. 指定 UTF-8 编码格式与校验规则创建数据库</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE test1 <span class="keyword">DEFAULT</span> <span class="keyword">CHARACTER SET</span> utf8 <span class="keyword">DEFAULT</span> <span class="keyword">COLLATE</span> utf8_general_ci;</span><br><span class="line"><span class="keyword">create</span> database test1 charset<span class="operator">=</span>utf8 <span class="keyword">collate</span><span class="operator">=</span>utf8_general_ci;</span><br><span class="line"># 创建一个名为 test1 的库，设置默认字符集为 utf8，默认排序规则为 utf8_general_ci，对应 <span class="operator">/</span>var<span class="operator">/</span>lib<span class="operator">/</span>mysql<span class="operator">/</span> 下的 test1 文件夹</span><br></pre></td></tr></table></figure><p>同时指定字符集与校验规则，使字符串比较、排序时不区分大小写。</p><blockquote><p>数据库命名规范建议：数据库名只能包含字母、数字、下划线、不能以数字开头、建议使用小写字母、避免使用 MySQL 关键字（如 database、table 等）、如果必须使用关键字，需要用反引号 <code>`</code> 包裹：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> DATABASE `database`;</span><br></pre></td></tr></table></figure></blockquote><h2 id="2-字符集和校验规则"><a href="#2-字符集和校验规则" class="headerlink" title="2. 字符集和校验规则"></a>2. 字符集和校验规则</h2><h3 id="1-查看系统默认的字符集与校验规则"><a href="#1-查看系统默认的字符集与校验规则" class="headerlink" title="1. 查看系统默认的字符集与校验规则"></a>1. 查看系统默认的字符集与校验规则</h3><p>我们可以使用以下语句查看当前 MySQL 服务的 <strong>系统默认字符集</strong> 和 <strong>默认校验规则</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;character_set_database&#x27;</span>;# 查看当前 USE 的数据库的字符集</span><br><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;collation_database&#x27;</span>;# 查看当前 USE 的数据库的校验规则</span><br><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;character_set_server&#x27;</span>;# 查看服务器默认字符集</span><br><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;collation_server&#x27;</span>;# 查看服务器默认校验规则</span><br></pre></td></tr></table></figure><p>也可以一次性查看所有字符集相关配置：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;character_set_%&#x27;</span>;</span><br><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;collation%&#x27;</span>;</span><br></pre></td></tr></table></figure><blockquote><p>  <strong>说明：</strong></p><ul><li><code>character_set_server</code> 表示 MySQL 服务的全局默认字符集。</li><li><code>collation_server</code> 表示 MySQL 服务的全局默认校验规则。</li><li><code>character_set_database</code> 和 <code>collation_database</code> 表示当前已选中数据库的默认字符集与校验规则。</li><li>如果未执行 <code>USE</code>，它们会回退到 <code>character_set_server</code> 和 <code>collation_server</code> 的值，但语义上仍属于“当前数据库上下文”。</li></ul></blockquote><h3 id="2-查看-MySQL-支持的字符集"><a href="#2-查看-MySQL-支持的字符集" class="headerlink" title="2. 查看 MySQL 支持的字符集"></a>2. 查看 MySQL 支持的字符集</h3><p>MySQL 支持多种字符集，可用以下命令查看：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CHARACTER SET</span>;</span><br><span class="line"><span class="keyword">show</span> charset;</span><br></pre></td></tr></table></figure><p>输出结果示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">+</span><span class="comment">----------+---------------------------------+---------------------+--------+</span></span><br><span class="line"><span class="operator">|</span> Charset  <span class="operator">|</span> Description                     <span class="operator">|</span> <span class="keyword">Default</span> <span class="keyword">collation</span>   <span class="operator">|</span> Maxlen <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+---------------------------------+---------------------+--------+</span></span><br><span class="line"><span class="operator">|</span> armscii8 <span class="operator">|</span> ARMSCII<span class="number">-8</span> Armenian              <span class="operator">|</span> armscii8_general_ci <span class="operator">|</span>      <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> ascii    <span class="operator">|</span> US ASCII                        <span class="operator">|</span> ascii_general_ci    <span class="operator">|</span>      <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> big5     <span class="operator">|</span> Big5 Traditional Chinese        <span class="operator">|</span> big5_chinese_ci     <span class="operator">|</span>      <span class="number">2</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="type">binary</span>   <span class="operator">|</span> <span class="type">Binary</span> pseudo charset           <span class="operator">|</span> <span class="type">binary</span>              <span class="operator">|</span>      <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> cp1250   <span class="operator">|</span> Windows Central European        <span class="operator">|</span> cp1250_general_ci   <span class="operator">|</span>      <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> cp1251   <span class="operator">|</span> Windows Cyrillic                <span class="operator">|</span> cp1251_general_ci   <span class="operator">|</span>      <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> cp1256   <span class="operator">|</span> Windows Arabic                  <span class="operator">|</span> cp1256_general_ci   <span class="operator">|</span>      <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> cp1257   <span class="operator">|</span> Windows Baltic                  <span class="operator">|</span> cp1257_general_ci   <span class="operator">|</span>      <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> cp850    <span class="operator">|</span> DOS West European               <span class="operator">|</span> cp850_general_ci    <span class="operator">|</span>      <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> cp852    <span class="operator">|</span> DOS Central European            <span class="operator">|</span> cp852_general_ci    <span class="operator">|</span>      <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> cp866    <span class="operator">|</span> DOS Russian                     <span class="operator">|</span> cp866_general_ci    <span class="operator">|</span>      <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> cp932    <span class="operator">|</span> SJIS <span class="keyword">for</span> Windows Japanese       <span class="operator">|</span> cp932_japanese_ci   <span class="operator">|</span>      <span class="number">2</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> dec8     <span class="operator">|</span> <span class="type">DEC</span> West European               <span class="operator">|</span> dec8_swedish_ci     <span class="operator">|</span>      <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> eucjpms  <span class="operator">|</span> UJIS <span class="keyword">for</span> Windows Japanese       <span class="operator">|</span> eucjpms_japanese_ci <span class="operator">|</span>      <span class="number">3</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> euckr    <span class="operator">|</span> EUC<span class="operator">-</span>KR Korean                   <span class="operator">|</span> euckr_korean_ci     <span class="operator">|</span>      <span class="number">2</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> gb18030  <span class="operator">|</span> China <span class="type">National</span> Standard GB18030 <span class="operator">|</span> gb18030_chinese_ci  <span class="operator">|</span>      <span class="number">4</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> gb2312   <span class="operator">|</span> GB2312 Simplified Chinese       <span class="operator">|</span> gb2312_chinese_ci   <span class="operator">|</span>      <span class="number">2</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> gbk      <span class="operator">|</span> GBK Simplified Chinese          <span class="operator">|</span> gbk_chinese_ci      <span class="operator">|</span>      <span class="number">2</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> geostd8  <span class="operator">|</span> GEOSTD8 Georgian                <span class="operator">|</span> geostd8_general_ci  <span class="operator">|</span>      <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> greek    <span class="operator">|</span> ISO <span class="number">8859</span><span class="number">-7</span> Greek                <span class="operator">|</span> greek_general_ci    <span class="operator">|</span>      <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> hebrew   <span class="operator">|</span> ISO <span class="number">8859</span><span class="number">-8</span> Hebrew               <span class="operator">|</span> hebrew_general_ci   <span class="operator">|</span>      <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> hp8      <span class="operator">|</span> HP West European                <span class="operator">|</span> hp8_english_ci      <span class="operator">|</span>      <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> keybcs2  <span class="operator">|</span> DOS Kamenicky Czech<span class="operator">-</span>Slovak      <span class="operator">|</span> keybcs2_general_ci  <span class="operator">|</span>      <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> koi8r    <span class="operator">|</span> KOI8<span class="operator">-</span>R Relcom Russian           <span class="operator">|</span> koi8r_general_ci    <span class="operator">|</span>      <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> koi8u    <span class="operator">|</span> KOI8<span class="operator">-</span>U Ukrainian                <span class="operator">|</span> koi8u_general_ci    <span class="operator">|</span>      <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> latin1   <span class="operator">|</span> cp1252 West European            <span class="operator">|</span> latin1_swedish_ci   <span class="operator">|</span>      <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> latin2   <span class="operator">|</span> ISO <span class="number">8859</span><span class="number">-2</span> Central European     <span class="operator">|</span> latin2_general_ci   <span class="operator">|</span>      <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> latin5   <span class="operator">|</span> ISO <span class="number">8859</span><span class="number">-9</span> Turkish              <span class="operator">|</span> latin5_turkish_ci   <span class="operator">|</span>      <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> latin7   <span class="operator">|</span> ISO <span class="number">8859</span><span class="number">-13</span> Baltic              <span class="operator">|</span> latin7_general_ci   <span class="operator">|</span>      <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> macce    <span class="operator">|</span> Mac Central European            <span class="operator">|</span> macce_general_ci    <span class="operator">|</span>      <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> macroman <span class="operator">|</span> Mac West European               <span class="operator">|</span> macroman_general_ci <span class="operator">|</span>      <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> sjis     <span class="operator">|</span> Shift<span class="operator">-</span>JIS Japanese              <span class="operator">|</span> sjis_japanese_ci    <span class="operator">|</span>      <span class="number">2</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> swe7     <span class="operator">|</span> <span class="number">7</span>bit Swedish                    <span class="operator">|</span> swe7_swedish_ci     <span class="operator">|</span>      <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> tis620   <span class="operator">|</span> TIS620 Thai                     <span class="operator">|</span> tis620_thai_ci      <span class="operator">|</span>      <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> ucs2     <span class="operator">|</span> UCS<span class="number">-2</span> Unicode                   <span class="operator">|</span> ucs2_general_ci     <span class="operator">|</span>      <span class="number">2</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> ujis     <span class="operator">|</span> EUC<span class="operator">-</span>JP Japanese                 <span class="operator">|</span> ujis_japanese_ci    <span class="operator">|</span>      <span class="number">3</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> utf16    <span class="operator">|</span> UTF<span class="number">-16</span> Unicode                  <span class="operator">|</span> utf16_general_ci    <span class="operator">|</span>      <span class="number">4</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> utf16le  <span class="operator">|</span> UTF<span class="number">-16</span>LE Unicode                <span class="operator">|</span> utf16le_general_ci  <span class="operator">|</span>      <span class="number">4</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> utf32    <span class="operator">|</span> UTF<span class="number">-32</span> Unicode                  <span class="operator">|</span> utf32_general_ci    <span class="operator">|</span>      <span class="number">4</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> utf8mb3  <span class="operator">|</span> UTF<span class="number">-8</span> Unicode                   <span class="operator">|</span> utf8mb3_general_ci  <span class="operator">|</span>      <span class="number">3</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> utf8mb4  <span class="operator">|</span> UTF<span class="number">-8</span> Unicode                   <span class="operator">|</span> utf8mb4_0900_ai_ci  <span class="operator">|</span>      <span class="number">4</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+---------------------------------+---------------------+--------+</span></span><br><span class="line"><span class="number">41</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li><code>Charset</code>：字符集名称。</li><li><code>Description</code>：描述。</li><li><code>Default collation</code>：默认校验规则。</li><li><code>Maxlen</code>：每个字符所需最大字节数。</li></ul><h3 id="3-查看某个字符集支持的校验规则"><a href="#3-查看某个字符集支持的校验规则" class="headerlink" title="3. 查看某个字符集支持的校验规则"></a>3. 查看某个字符集支持的校验规则</h3><p>使用以下语句查看指定字符集的所有可用校验规则：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">COLLATION</span> <span class="keyword">WHERE</span> Charset<span class="operator">=</span><span class="string">&#x27;utf8&#x27;</span>;</span><br></pre></td></tr></table></figure><p>输出示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+--------------------+---------+----+---------+----------+---------+</span><br><span class="line">| Collation          | Charset | Id | Default | Compiled | Sortlen |</span><br><span class="line">+--------------------+---------+----+---------+----------+---------+</span><br><span class="line">| utf8_general_ci    | utf8    | 33 | Yes     | Yes      | 1       |</span><br><span class="line">| utf8_bin           | utf8    | 83 |         | Yes      | 1       |</span><br><span class="line">| utf8_unicode_ci    | utf8    | 192|         | Yes      | 8       |</span><br><span class="line">+--------------------+---------+----+---------+----------+---------+</span><br></pre></td></tr></table></figure><p><strong>常见校验规则说明：</strong></p><ul><li><code>utf8_general_ci</code>：不区分大小写的通用排序规则（ci &#x3D; case insensitive）。</li><li><code>utf8_bin</code>：区分大小写的二进制比较方式（bin &#x3D; binary）。</li><li><code>utf8_unicode_ci</code>：基于 Unicode 标准的更准确排序方式（不区分大小写，但性能略低）。</li></ul><h3 id="4-校验规则对数据库的影响"><a href="#4-校验规则对数据库的影响" class="headerlink" title="4. 校验规则对数据库的影响"></a>4. 校验规则对数据库的影响</h3><p>校验规则主要影响字符串的 <strong>比较</strong> 与 <strong>排序</strong>。不同的规则可能导致查询结果差异。</p><h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE test_ci <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_general_ci;</span><br><span class="line"><span class="keyword">CREATE</span> DATABASE test_bin <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin;</span><br><span class="line"></span><br><span class="line">USE test_ci;</span><br><span class="line"><span class="keyword">CREATE TABLE</span> t (name <span class="type">VARCHAR</span>(<span class="number">20</span>));</span><br><span class="line"><span class="keyword">INSERT INTO</span> t <span class="keyword">VALUES</span> (<span class="string">&#x27;abc&#x27;</span>), (<span class="string">&#x27;ABC&#x27;</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> name<span class="operator">=</span><span class="string">&#x27;abc&#x27;</span>;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">+</span><span class="comment">------+</span></span><br><span class="line"><span class="operator">|</span> name <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+</span></span><br><span class="line"><span class="operator">|</span> abc  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> ABC  <span class="operator">|</span>   ← 不区分大小写</span><br><span class="line"><span class="operator">+</span><span class="comment">------+</span></span><br></pre></td></tr></table></figure><p>而如果使用 <code>utf8_bin</code>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">USE test_bin;</span><br><span class="line"><span class="keyword">CREATE TABLE</span> t (name <span class="type">VARCHAR</span>(<span class="number">20</span>));</span><br><span class="line"><span class="keyword">INSERT INTO</span> t <span class="keyword">VALUES</span> (<span class="string">&#x27;abc&#x27;</span>), (<span class="string">&#x27;ABC&#x27;</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> name<span class="operator">=</span><span class="string">&#x27;abc&#x27;</span>;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">+</span><span class="comment">------+</span></span><br><span class="line"><span class="operator">|</span> name <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+</span></span><br><span class="line"><span class="operator">|</span> abc  <span class="operator">|</span>   ← 区分大小写</span><br><span class="line"><span class="operator">+</span><span class="comment">------+</span></span><br></pre></td></tr></table></figure><blockquote><p>  <strong>总结：</strong></p><ul><li><code>utf8_general_ci</code>：比较和排序不区分大小写。</li><li><code>utf8_bin</code>：比较和排序区分大小写。</li><li>校验规则不会改变数据存储内容，只影响字符串比较结果与排序方式。</li></ul></blockquote><h2 id="3-操作数据库"><a href="#3-操作数据库" class="headerlink" title="3. 操作数据库"></a>3. 操作数据库</h2><h3 id="1-查看数据库"><a href="#1-查看数据库" class="headerlink" title="1. 查看数据库"></a>1. 查看数据库</h3><h4 id="1-查看当前服务器中所有数据库"><a href="#1-查看当前服务器中所有数据库" class="headerlink" title="1. 查看当前服务器中所有数据库"></a>1. 查看当前服务器中所有数据库</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> DATABASES;# 注意不要丢了最后的 S ！</span><br><span class="line"><span class="keyword">show</span> databases;</span><br></pre></td></tr></table></figure><p><strong>说明：这会显示 MySQL 服务端当前存在的所有数据库。注意：<code>information_schema</code>、<code>mysql</code>、<code>performance_schema</code>、<code>sys</code> 是系统库，不要随意修改或删除。</strong></p><h4 id="2-查看当前正在使用的数据库"><a href="#2-查看当前正在使用的数据库" class="headerlink" title="2. 查看当前正在使用的数据库"></a>2. 查看当前正在使用的数据库</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> DATABASE();</span><br><span class="line"><span class="keyword">select</span> database();</span><br></pre></td></tr></table></figure><h3 id="2-显示数据库创建语句"><a href="#2-显示数据库创建语句" class="headerlink" title="2. 显示数据库创建语句"></a>2. 显示数据库创建语句</h3><p>要查看数据库的创建详情（字符集、校验规则等），可用：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> DATABASE 数据库名;</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> database 数据库名;</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> DATABASE test;# 示例</span><br></pre></td></tr></table></figure><p>输出示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+----------+--------------------------------------------------------------------------------------------------------------------------------+</span><br><span class="line">| Database | Create Database                                                                                                                |</span><br><span class="line">+----------+--------------------------------------------------------------------------------------------------------------------------------+</span><br><span class="line">| test     | CREATE DATABASE `test` /*!40100 DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci */ /*!80016 DEFAULT ENCRYPTION=&#x27;N&#x27; */ |</span><br><span class="line">+----------+--------------------------------------------------------------------------------------------------------------------------------+</span><br></pre></td></tr></table></figure><p>看着有点乱对吧，可以使用 <code>show create database test\G</code>，此时后面的 <code>;</code> 可有可无，<code>G</code> 选项的作用是将结果按行垂直排列，每个字段单独占一行，特别适合处理字段值较长的输出场景：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show create database <span class="built_in">test</span>\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">       Database: <span class="built_in">test</span></span><br><span class="line">Create Database: CREATE DATABASE `<span class="built_in">test</span>` /*!40100 DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci */ /*!80016 DEFAULT ENCRYPTION=<span class="string">&#x27;N&#x27;</span> */</span><br><span class="line">1 row <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br></pre></td></tr></table></figure><p><strong>说明：</strong> 语句会完整显示数据库的创建 SQL，包括字符集与校验规则，可用于迁移或备份时复制创建语句。<code>/*!40100 DEFAULT CHARACTER SET utf8 */</code> 不是注释，它表示当前 MySQL 版本如果大于 4.10，则执行后面的 SQL 语句，相当于 <code>if</code> 语句。</p><h3 id="3-修改数据库"><a href="#3-修改数据库" class="headerlink" title="3. 修改数据库"></a>3. 修改数据库</h3><p>可通过 <code>ALTER DATABASE</code> 修改数据库的默认字符集与校验规则，<strong>语法格式：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> DATABASE 数据库名 [<span class="keyword">DEFAULT</span> <span class="keyword">CHARACTER SET</span> 字符集名] [<span class="keyword">DEFAULT</span> <span class="keyword">COLLATE</span> 校验规则];</span><br><span class="line"><span class="keyword">ALTER</span> DATABASE 数据库名 [<span class="keyword">DEFAULT</span>] CHARSET<span class="operator">=</span>字符集名 [<span class="keyword">DEFAULT</span>] <span class="keyword">COLLATE</span><span class="operator">=</span>校验规则;</span><br><span class="line"><span class="keyword">alter</span> database 数据库名 charset<span class="operator">=</span>字符集名 <span class="keyword">collate</span><span class="operator">=</span>校验规则;</span><br></pre></td></tr></table></figure><h4 id="1-示例-1：修改字符集"><a href="#1-示例-1：修改字符集" class="headerlink" title="1. 示例 1：修改字符集"></a>1. 示例 1：修改字符集</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> DATABASE test <span class="keyword">DEFAULT</span> <span class="keyword">CHARACTER SET</span> utf8mb4;</span><br><span class="line"><span class="keyword">alter</span> database test <span class="keyword">default</span> charset<span class="operator">=</span>utfmb4;</span><br></pre></td></tr></table></figure><h4 id="2-示例-2：修改字符集和校验规则"><a href="#2-示例-2：修改字符集和校验规则" class="headerlink" title="2. 示例 2：修改字符集和校验规则"></a>2. 示例 2：修改字符集和校验规则</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> DATABASE test <span class="keyword">DEFAULT</span> <span class="keyword">CHARACTER SET</span> utf8mb4 <span class="keyword">DEFAULT</span> <span class="keyword">COLLATE</span> utf8mb4_general_ci;</span><br><span class="line"><span class="keyword">ALTER</span> DATABASE test <span class="keyword">CHARACTER SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_general_ci;</span><br><span class="line"></span><br><span class="line"># 分 <span class="number">2</span> 次修改：</span><br><span class="line"><span class="keyword">alter</span> database test <span class="keyword">character set</span> utf8mb4;</span><br><span class="line"><span class="keyword">alter</span> database test <span class="keyword">collate</span> utf8mb4_general_ci;</span><br></pre></td></tr></table></figure><blockquote><p>  <strong>说明：</strong> 只会改变“数据库默认字符集”，不会自动修改已存在表的字符集。如果要真正改变表内数据编码，还需针对表执行 <code>ALTER TABLE</code>。</p></blockquote><h3 id="4-删除数据库"><a href="#4-删除数据库" class="headerlink" title="4. 删除数据库"></a>4. 删除数据库</h3><p><strong>语法格式：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> DATABASE [IF <span class="keyword">EXISTS</span>] 数据库名;</span><br><span class="line"><span class="keyword">drop</span> database 数据库名;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> database test;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li><code>IF EXISTS</code> 表示若数据库不存在则不报错。</li><li>MySQL 不支持同时删除多个库的语法，一次只能删除一个数据库。如果要一次性删除多个库，需要写多条语句，或用脚本批量执行。</li><li>删除数据库会 <strong>直接删除对应目录及全部数据文件（库中的表也会一并删除）</strong>，例如 <code>/var/lib/mysql/test/</code>。</li><li><strong>删除操作不可恢复，务必谨慎执行。</strong></li></ul><p>前面提到，一个数据库的创建其实是在 <code>/var/lib/mysql/</code> 会创建对应的文件夹，那么删除一个库是不是可以直接使用 <code>rm</code> 进行删除呢？</p><table><thead><tr><th>操作方式</th><th>行为</th><th>风险</th></tr></thead><tbody><tr><td><code>DROP DATABASE</code></td><td>MySQL 内部安全删除：清理表空间、日志、数据字典记录、权限信息</td><td>推荐、安全</td></tr><tr><td>手动删除文件夹</td><td>只删掉物理文件，MySQL 内部元数据（如 <code>information_schema</code>、权限缓存）不会更新</td><td>不推荐、高风险</td></tr></tbody></table><blockquote><p>从 MySQL 8.0 开始，<strong>所有数据库元数据都存储在 InnoDB 的数据字典中</strong>，不再依赖文件系统目录是否存在。这意味着：删了 <code>/var/lib/mysql/test</code> 目录，表面上好像效果一样，但 <code>SHOW DATABASES;</code> <strong>可能仍然显示 <code>test</code></strong>，尝试 <code>USE mydb;</code> 会报错：<code>Unknown database &#39;test&#39;</code>，也 <strong>无法再创建同名数据库</strong>，因为元数据还存在！这会导致“幽灵数据库”问题：看不见、删不掉、建不了！ <strong>所以：推荐直接使用 MySQL 的命令，最好不要直接删除对应的文件夹！反过来也最好不要使用 <code>mkdir</code> 进行创建。</strong></p></blockquote><h2 id="4-备份和恢复"><a href="#4-备份和恢复" class="headerlink" title="4. 备份和恢复"></a>4. 备份和恢复</h2><h3 id="1-备份"><a href="#1-备份" class="headerlink" title="1. 备份"></a>1. 备份</h3><h4 id="1-基础备份"><a href="#1-基础备份" class="headerlink" title="1. 基础备份"></a>1. 基础备份</h4><blockquote><p><strong><code>mysqldump</code> 是一个命令行工具（不是 SQL 语句），不能在 MySQL 客户端（即 <code>mysql&gt;</code> 交互界面）中直接执行，需要先 <code>exit</code> 退出。</strong></p></blockquote><p><strong>语法格式：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -P端口号 -u 用户名 -p 密码 -B 数据库名 &gt; 数据库备份存储路径</span><br><span class="line"></span><br><span class="line">mysqldump -P3306 -u root -p123456 -B <span class="built_in">test</span> &gt; D:/test.sql<span class="comment"># 示例：将 mytest 库备份到 D: 盘</span></span><br><span class="line">mysqldump -P3306 -u root -p -B <span class="built_in">test</span> &gt; ~/temp/t.sql<span class="comment"># 或者执行完再输密码，注意：文件/目录不存在不会自动创建！</span></span><br></pre></td></tr></table></figure><p><strong>说明：</strong> 备份文件 <code>test.sql</code> 中包含整个数据库的创建语句、表结构、表数据，可以打开文件查看 SQL 内容。比如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">root<span class="variable">@hcss</span><span class="operator">-</span>ecs<span class="operator">-</span>be68:<span class="operator">~</span><span class="operator">/</span>temp# cat t.sql </span><br><span class="line"><span class="comment">-- MySQL dump 10.13  Distrib 8.0.43, for Linux (x86_64)</span></span><br><span class="line"><span class="comment">--</span></span><br><span class="line"><span class="comment">-- Host: localhost    Database: test</span></span><br><span class="line"><span class="comment">-- ------------------------------------------------------</span></span><br><span class="line"><span class="comment">-- Server version8.0.43-0ubuntu0.22.04.2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */</span>;</span><br><span class="line"><span class="comment">/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */</span>;</span><br><span class="line"><span class="comment">/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */</span>;</span><br><span class="line"><span class="comment">/*!50503 SET NAMES utf8mb4 */</span>;</span><br><span class="line"><span class="comment">/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */</span>;</span><br><span class="line"><span class="comment">/*!40103 SET TIME_ZONE=&#x27;+00:00&#x27; */</span>;</span><br><span class="line"><span class="comment">/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */</span>;</span><br><span class="line"><span class="comment">/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */</span>;</span><br><span class="line"><span class="comment">/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE=&#x27;NO_AUTO_VALUE_ON_ZERO&#x27; */</span>;</span><br><span class="line"><span class="comment">/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--</span></span><br><span class="line"><span class="comment">-- Current Database: `test`</span></span><br><span class="line"><span class="comment">--</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> DATABASE <span class="comment">/*!32312 IF NOT EXISTS*/</span> `test` <span class="comment">/*!40100 DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci */</span> <span class="comment">/*!80016 DEFAULT ENCRYPTION=&#x27;N&#x27; */</span>;</span><br><span class="line"></span><br><span class="line">USE `test`;</span><br><span class="line"></span><br><span class="line"><span class="comment">--</span></span><br><span class="line"><span class="comment">-- Table structure for table `students`</span></span><br><span class="line"><span class="comment">--</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `students`;</span><br><span class="line"><span class="comment">/*!40101 SET @saved_cs_client     = @@character_set_client */</span>;</span><br><span class="line"><span class="comment">/*!50503 SET character_set_client = utf8mb4 */</span>;</span><br><span class="line"><span class="keyword">CREATE TABLE</span> `students` (</span><br><span class="line">  `id` <span class="type">int</span> <span class="keyword">NOT NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">COLLATE</span> utf8mb4_general_ci <span class="keyword">NOT NULL</span>,</span><br><span class="line">  `age` <span class="type">int</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `grade` <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">COLLATE</span> utf8mb4_general_ci <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY KEY</span> (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">4</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8mb4_general_ci;</span><br><span class="line"><span class="comment">/*!40101 SET character_set_client = @saved_cs_client */</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--</span></span><br><span class="line"><span class="comment">-- Dumping data for table `students`</span></span><br><span class="line"><span class="comment">--</span></span><br><span class="line"></span><br><span class="line">LOCK TABLES `students` WRITE;</span><br><span class="line"><span class="comment">/*!40000 ALTER TABLE `students` DISABLE KEYS */</span>;</span><br><span class="line"><span class="keyword">INSERT INTO</span> `students` <span class="keyword">VALUES</span> (<span class="number">1</span>,<span class="string">&#x27;张三&#x27;</span>,<span class="number">18</span>,<span class="string">&#x27;高三&#x27;</span>),(<span class="number">2</span>,<span class="string">&#x27;李四&#x27;</span>,<span class="number">17</span>,<span class="string">&#x27;高二&#x27;</span>),(<span class="number">3</span>,<span class="string">&#x27;王五&#x27;</span>,<span class="number">19</span>,<span class="string">&#x27;大学一年级&#x27;</span>);</span><br><span class="line"><span class="comment">/*!40000 ALTER TABLE `students` ENABLE KEYS */</span>;</span><br><span class="line">UNLOCK TABLES;</span><br><span class="line"><span class="comment">/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*!40101 SET SQL_MODE=@OLD_SQL_MODE */</span>;</span><br><span class="line"><span class="comment">/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */</span>;</span><br><span class="line"><span class="comment">/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */</span>;</span><br><span class="line"><span class="comment">/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */</span>;</span><br><span class="line"><span class="comment">/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */</span>;</span><br><span class="line"><span class="comment">/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */</span>;</span><br><span class="line"><span class="comment">/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Dump completed on 2025-9-11 15:56:29</span></span><br></pre></td></tr></table></figure><h4 id="2-备份单张表"><a href="#2-备份单张表" class="headerlink" title="2. 备份单张表"></a>2. 备份单张表</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump <span class="operator">-</span>u root <span class="operator">-</span>p 数据库名 表名<span class="number">1</span> 表名<span class="number">2</span> <span class="operator">&gt;</span> D:<span class="operator">/</span>mytest.sql# 仅备份指定表，不会备份整个数据库。</span><br></pre></td></tr></table></figure><h4 id="3-同时备份多个数据库"><a href="#3-同时备份多个数据库" class="headerlink" title="3. 同时备份多个数据库"></a>3. 同时备份多个数据库</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -u root -p -B 数据库名1 数据库名2 ... &gt; D:/backup.sql</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 如果没有 <code>-B</code> 参数，备份单库时，需要先手动创建空数据库，然后再用 <code>source</code> 导入，<code>mysqldump</code> 会生成标准 SQL 文件，可跨服务器恢复。</p><hr><h3 id="2-恢复"><a href="#2-恢复" class="headerlink" title="2. 恢复"></a>2. 恢复</h3><p><strong>语法：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> source 数据库备份文件路径;</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> source D:<span class="operator">/</span><span class="keyword">new</span><span class="operator">/</span>test.sql;# 示例</span><br></pre></td></tr></table></figure><p><strong>说明：</strong> 恢复会执行 SQL 文件里的所有语句：创建数据库、建表、导入数据，如果备份文件没有 <code>CREATE DATABASE</code>，需要先手动创建空数据库再导入。<strong>注意事项：</strong></p><ul><li>备份不是整个数据库，而是单表时，需指定表名。</li><li>多库备份可通过 <code>-B 数据库名1 数据库名2</code> 实现。</li><li>恢复单库时，如果备份文件没有 <code>-B</code> 参数创建数据库，需要先创建空库。</li></ul><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> source <span class="operator">~</span><span class="operator">/</span>temp<span class="operator">/</span>t.sql;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">Database changed</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.02</span> sec)</span><br><span class="line"></span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.02</span> sec)</span><br><span class="line"></span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">Query OK, <span class="number">3</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line">Records: <span class="number">3</span>  Duplicates: <span class="number">0</span>  Warnings: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> </span><br></pre></td></tr></table></figure><h2 id="5-查看连接情况"><a href="#5-查看连接情况" class="headerlink" title="5. 查看连接情况"></a>5. 查看连接情况</h2><h3 id="1-语法格式-1"><a href="#1-语法格式-1" class="headerlink" title="1. 语法格式"></a>1. 语法格式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SHOW PROCESSLIST;</span><br><span class="line">show processlist;</span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> processlist;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-----------------+-----------+------+---------+------+------------------------+------------------+</span></span><br><span class="line"><span class="operator">|</span> Id <span class="operator">|</span> <span class="keyword">User</span>            <span class="operator">|</span> Host      <span class="operator">|</span> db   <span class="operator">|</span> Command <span class="operator">|</span> <span class="type">Time</span> <span class="operator">|</span> State                  <span class="operator">|</span> Info             <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-----------------+-----------+------+---------+------+------------------------+------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">5</span> <span class="operator">|</span> event_scheduler <span class="operator">|</span> localhost <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> Daemon  <span class="operator">|</span> <span class="number">8710</span> <span class="operator">|</span> Waiting <span class="keyword">on</span> <span class="keyword">empty</span> queue <span class="operator">|</span> <span class="keyword">NULL</span>             <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">15</span> <span class="operator">|</span> root            <span class="operator">|</span> localhost <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> Query   <span class="operator">|</span>    <span class="number">0</span> <span class="operator">|</span> init                   <span class="operator">|</span> <span class="keyword">show</span> processlist <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-----------------+-----------+------+---------+------+------------------------+------------------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> warning (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li><code>Id</code>：连接编号。</li><li><code>User</code>：用户名。</li><li><code>Host</code>：客户端主机。</li><li><code>db</code>：当前使用的数据库。</li><li><code>Command</code>：操作类型。</li><li><code>Time</code>：操作持续时间。</li><li><code>State</code>：操作状态。</li><li><code>Info</code>：执行的 SQL 语句。</li></ul><blockquote><p>  <strong>用途：</strong></p><ul><li>查看当前有哪些用户连接到 MySQL。</li><li>可判断是否有异常或未授权的连接。</li><li>当发现数据库操作缓慢或异常时，可用此命令排查连接。</li></ul></blockquote><h3 id="2-终止异常连接"><a href="#2-终止异常连接" class="headerlink" title="2. 终止异常连接"></a>2. 终止异常连接</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">KILL <span class="number">123</span>;  # 终止ID为<span class="number">123</span>的连接</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;库的操作&quot;&gt;&lt;a href=&quot;#库的操作&quot; class=&quot;headerlink&quot; title=&quot;库的操作&quot;&gt;&lt;/a&gt;库的操作&lt;/h1&gt;&lt;h2 id=&quot;1-创建数据库&quot;&gt;&lt;a href=&quot;#1-创建数据库&quot; class=&quot;headerlink&quot; title=&quot;1.</summary>
        
      
    
    
    
    <category term="MySQL" scheme="https://www.minbit.top/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="https://www.minbit.top/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>054 数据链路层</title>
    <link href="https://www.minbit.top/posts/55230.html"/>
    <id>https://www.minbit.top/posts/55230.html</id>
    <published>2025-10-09T04:00:00.000Z</published>
    <updated>2025-11-09T04:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h1><blockquote><p><a href="https://blog.csdn.net/chenlong_cxy/article/details/124788397">数据链路层协议 ——— 以太网协议 | CSDN</a></p><p><a href="https://blog.csdn.net/m0_64280701/article/details/134042240">「网络编程」数据链路层协议_ 以太网协议学习 | CSDN</a></p></blockquote><h2 id="1-对比理解-MAC-地址和-IP-地址"><a href="#1-对比理解-MAC-地址和-IP-地址" class="headerlink" title="1. 对比理解 MAC 地址和 IP 地址"></a>1. 对比理解 MAC 地址和 IP 地址</h2><h3 id="1-通俗类比：寄快递的两步走"><a href="#1-通俗类比：寄快递的两步走" class="headerlink" title="1. 通俗类比：寄快递的两步走"></a>1. 通俗类比：寄快递的两步走</h3><p>假设你要从北京家里寄一个文件到上海朋友家，整个过程对应两层的分工：</p><table><thead><tr><th>层级</th><th>类比角色</th><th>负责的环节</th></tr></thead><tbody><tr><td>数据链路层</td><td>你家楼下的快递员</td><td>只负责 “<strong>本地最后一公里</strong>”：从你手里接过文件（数据），封装成 “本地快递袋”（帧），送到小区门口的 “物流站点”（路由器）；不关心文件最终去哪，只认 “你家的门牌号”（MAC 地址）。</td></tr><tr><td>网络层</td><td>全国物流调度中心</td><td>负责 “<strong>跨区域全局路由</strong>”：从物流站点接过快递袋，拆开看 “目的地地址”（IP 地址），规划从北京到上海的路线（比如北京 → 济南 → 南京 → 上海），把快递转到下一个站点，直到送到上海的物流站点；不关心 “最后一公里怎么送”，只管 “跨区域怎么到目标城市”。</td></tr></tbody></table><p>简言之：</p><ul><li>数据链路层：<strong>管 “邻居间” 的本地传输</strong>（比如你家电脑 ↔ 路由器、路由器 ↔ 隔壁路由器）。</li><li>网络层：<strong>管 “跨网络” 的全局路由</strong>（比如北京内网 ↔ 上海内网、家里 WiFi↔ 百度服务器）。</li></ul><h3 id="2-关键对比"><a href="#2-关键对比" class="headerlink" title="2. 关键对比"></a>2. 关键对比</h3><table><thead><tr><th>对比维度</th><th>数据链路层</th><th>网络层</th></tr></thead><tbody><tr><td>1. 作用范围</td><td><strong>本地局域网（LAN）</strong>：仅覆盖 “直接相连的设备”（如同一 WiFi 下的电脑、手机），无法跨网络通信。</td><td><strong>跨网络（广域网 WAN &#x2F; 互联网）</strong>：覆盖多个局域网，实现 “异地设备” 通信（如北京电脑 ↔ 广州服务器）。</td></tr><tr><td>2. 核心任务</td><td>1. 把上层数据封装成 “帧”（Frame）<br>2. 用 <strong>MAC 地址</strong> 找到 “本地邻居”<br>3. 检测本地传输的错误（如帧损坏）。</td><td>1. 把上层数据封装成 “数据包”（Packet）<br>2. 用 <strong>IP 地址</strong> 找到 “目标网络”<br>3. 规划跨网路线（路由选择），转发数据包。</td></tr><tr><td>3. 数据单元</td><td><strong>帧（Frame）</strong>：是数据链路层的 “传输单位”，包含 “源 MAC 地址 + 目的 MAC 地址”。</td><td><strong>数据包（Packet）</strong>：是网络层的 “传输单位”，包含 “源 IP 地址 + 目的 IP 地址”。</td></tr><tr><td>4. 寻址方式</td><td><strong>MAC 地址</strong>（物理地址）：固定在网卡上，全球唯一，仅在本地局域网内有效，跨网无效。</td><td><strong>IP 地址</strong>（逻辑地址）：可动态分配（如家里 WiFi 的 IP），也可固定（如服务器 IP）。跨网唯一，用于定位 “目标网络”。</td></tr><tr><td>5. 关键协议</td><td>以太网（Ethernet）、WiFi（802.11）、PPP（拨号上网）、ARP（将 IP 转 MAC）</td><td>IP（IPv4&#x2F;IPv6）、ICMP（ping 命令用的协议）、路由协议（RIP&#x2F;OSPF）</td></tr><tr><td>6. 差错处理</td><td>仅 “<strong>本地差错检测</strong>”：发现帧损坏就丢弃，不负责修复或重传（重传交给上层如传输层）。</td><td>仅 “<strong>跨网差错报告</strong>”：用 ICMP 报告 “数据包丢了”“路由不可达”，不负责修复或重传。</td></tr></tbody></table><h3 id="3-一个实战案例：电脑-ping-百度的两层协作"><a href="#3-一个实战案例：电脑-ping-百度的两层协作" class="headerlink" title="3. 一个实战案例：电脑 ping 百度的两层协作"></a>3. 一个实战案例：电脑 ping 百度的两层协作</h3><p>当在电脑上输入 <code>ping www.baidu.com</code>，数据链路层和网络层的分工清晰可见：</p><ol><li><strong>网络层先干活</strong>：<ul><li>电脑先把 “ping 请求” 封装成 <strong>IP 数据包</strong>，目的 IP 是百度服务器的 IP（比如 <code>180.101.49.12</code>）。</li><li>电脑问本地路由器：“怎么把这个数据包送到百度？” 路由器用路由协议查 “路线表”，确定下一个转发节点（比如运营商的网关）。</li></ul></li><li><strong>数据链路层再封装</strong>：<ul><li>电脑把 “IP 数据包” 再封装成 <strong>以太网帧</strong>，目的 MAC 地址是 “本地路由器的 MAC 地址”（不是百度的 MAC！因为 MAC 只在本地有效）。</li><li>帧通过 WiFi &#x2F; 网线传到路由器，路由器拆开帧，取出里面的 IP 数据包，再给这个数据包套上 “新的帧”（目的 MAC 是下一个网关的 MAC），继续转发。</li></ul></li><li><strong>到百度服务器后反向操作</strong>：<ul><li>百度的路由器收到数据包，拆帧取包，再用 “百度服务器的 MAC” 封装成帧，送到百度服务器。</li><li>百度服务器返回 “ping 响应”，重复上述过程，最终回到你的电脑。</li></ul></li></ol><hr><h2 id="2-认识以太网"><a href="#2-认识以太网" class="headerlink" title="2. 认识以太网"></a>2. 认识以太网</h2><blockquote><ul><li><strong>IP 层</strong>：决定“送给谁”，类似“写信的收件人地址”；</li><li><strong>以太网层（链路层）</strong>：决定“信封怎么送到下一个邮局（下一跳）”；</li><li><strong>ARP 协议</strong>：负责查“邮递员的住址（MAC）”；</li><li><strong>路由器</strong>：相当于中转邮局，负责转运到不同地区。</li></ul></blockquote><h3 id="1-以太网是什么？"><a href="#1-以太网是什么？" class="headerlink" title="1. 以太网是什么？"></a>1. 以太网是什么？</h3><blockquote><p><strong>以太网的本质：局域网（LAN）的“物理 + 数据链路”实现。它只负责“一跳”通信 —— 即从当前主机到下一跳（通常是网关或目标主机），不关心跨网、路由、可靠性。</strong> </p></blockquote><p>以太网（Ethernet）是目前最常用的 <strong>局域网通信技术</strong>，它解决 <strong>同一局域网内</strong> 多台主机之间的 <strong>点对点或广播通信</strong>。它定义了：</p><ul><li><strong>物理层</strong>：用什么电缆&#x2F;光纤&#x2F;网卡等连接主机。</li><li><strong>数据链路层</strong>：如何封装、发送、识别、接收帧。</li><li><strong>寻址机制</strong>：用 <strong>MAC 地址</strong>（48 位，每个网卡的唯一标识）来区分不同主机。</li></ul><h3 id="2-以太网通信的核心原理"><a href="#2-以太网通信的核心原理" class="headerlink" title="2. 以太网通信的核心原理"></a>2. 以太网通信的核心原理</h3><p>以太网采用的基本通信方式是：<strong>广播 + 识别 + 过滤</strong>。</p><ol><li><p><strong>发送过程：</strong> 主机 A 想发数据给主机 B（同网段），A 封装以太网帧：目的 MAC &#x3D; B 的 MAC，源 MAC &#x3D; A 的 MAC，<strong>将帧广播到整个局域网</strong>（通过交换机或集线器）。</p></li><li><p>接收过程：局域网内 <strong>所有主机都收到该帧</strong>，每台主机检查目的 MAC：</p><ul><li><p><strong>匹配自己</strong> → 去掉以太网头，将 payload（如 IP 包）交给上层。</p></li><li><p><strong>不匹配</strong> → <strong>直接丢弃</strong>（不向上交付）。</p></li></ul></li></ol><p>这就是之前说的：在局域网中，<strong>每个主机都能看到所有帧</strong>，但只会“认领”发给自己的那部分。</p><blockquote><p><strong>交换机的作用：学习 MAC 地址表，只转发帧到目标端口（不是广播），减少冲突和带宽浪费。</strong></p></blockquote><h3 id="3-路由器在以太网通信中的作用"><a href="#3-路由器在以太网通信中的作用" class="headerlink" title="3. 路由器在以太网通信中的作用"></a>3. 路由器在以太网通信中的作用</h3><p>以太网通信范围是一个局域网（即一个广播域），<strong>不同网段之间</strong> 的通信必须经过路由器。当主机 A 发现目标 IP 不在本地网段时，它会：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">查路由表 → 发现下一跳是默认网关（路由器）→ 使用 ARP 找到网关的 MAC 地址 → 将帧发给网关 → 路由器接收后，剥去旧帧头，重新封装成新帧（目标是下一跳或目标主机）</span><br></pre></td></tr></table></figure><p>所以每跨一个路由器，就意味着一次“去掉旧帧头 + 加上新帧头”的过程。那么以太网又是如何与 IP 协作的呢？—— 封装与解封装：</p><ol><li><strong>发送端（主机 A）：</strong> 应用数据 → TCP&#x2F;UDP 封装（加端口号） → IP 封装（加源&#x2F;目的 IP） → <strong>以太网封装（加源&#x2F;目的 MAC）</strong> → 发送。</li><li><strong>转发中（路由器）：</strong> 收到帧 → 去掉以太网头 → 查 IP 目的地址 → 查路由表 → <strong>重新封装新以太网头</strong>（下一跳的 MAC） → 转发。</li></ol><p><strong>注意：IP 地址全程不变（端到端）、MAC 地址每跳都变（只用于本地链路）。</strong></p><h3 id="4-如何找到目标-MAC-——-ARP-协议（后文详解）"><a href="#4-如何找到目标-MAC-——-ARP-协议（后文详解）" class="headerlink" title="4. 如何找到目标 MAC —— ARP 协议（后文详解）"></a>4. 如何找到目标 MAC —— ARP 协议（后文详解）</h3><p>问题来了：主机 A 想发给主机 B，它只知道 B 的 <strong>IP 地址</strong>，却不知道 B 的 <strong>MAC 地址</strong>，怎么办？答案是 —— 使用 <strong>ARP 协议（Address Resolution Protocol）</strong>。</p><ul><li>A 先在局域网中广播一个 ARP 请求帧：“谁是 IP &#x3D; 192.168.1.10？请告诉我你的 MAC！”</li><li>B 收到后发现 IP 匹配，于是单播回应：“我的 MAC 地址是 xx:xx:xx:xx:xx: xx。”</li><li>A 收到后就缓存这个映射关系（写入 ARP 缓存表），之后发送数据帧时就不用再广播了。</li></ul><h2 id="3-以太网帧格式-结构"><a href="#3-以太网帧格式-结构" class="headerlink" title="3. 以太网帧格式&#x2F;结构"></a>3. 以太网帧格式&#x2F;结构</h2><h3 id="1-以太网帧格式"><a href="#1-以太网帧格式" class="headerlink" title="1. 以太网帧格式"></a>1. 以太网帧格式</h3><p>一个标准的以太网帧结构如下：</p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20251008204331593.png" alt="PixPin_2025-10-08_20-43-21"></p><table><thead><tr><th>字段</th><th>长度（字节）</th><th>作用</th></tr></thead><tbody><tr><td>目标 MAC 地址</td><td>6</td><td>标识接收方设备（帧要发给谁）</td></tr><tr><td>源 MAC 地址</td><td>6</td><td>标识发送方设备（谁发的）</td></tr><tr><td>类型字段</td><td>2</td><td>指明上层协议（如 <strong><span style="color:#FF0000;"><code>0x0800</code> &#x3D; IPv4，<code>0x86DD</code> &#x3D; IPv6，<code>0x0806</code> &#x3D; ARP</span></strong>，现已基本被 DHCP 取代，极少在现代网络中使用：<code>0x8035</code> &#x3D; RARP）</td></tr><tr><td>数据载荷</td><td>46~1500</td><td>实际承载的上层数据（通常是 IP 报文）</td></tr><tr><td>FCS（帧校验序列）</td><td>4</td><td>CRC32 校验，检查传输过程中是否出错</td></tr></tbody></table><p><strong>特点：</strong></p><ul><li><strong>帧头固定 14 字节（6 + 6 + 2）。</strong></li><li><strong>帧尾固定 4 字节（CRC）。</strong></li><li><strong>有效载荷部分可变，最小 46 字节，最大 1500 字节。</strong></li><li><strong>类型字段（Type） 是关键：用于区分上层协议。</strong></li></ul><blockquote><ul><li><strong>最小帧 64 字节</strong>（含头尾）→ 数据不足 46 字节时会填充。</li><li><strong>最大帧 1518 字节</strong> → 对应 IP 层 MTU &#x3D; 1500 。</li></ul><p>  注意：<strong>MAC 地址</strong> 是硬件层面的标识，和 IP 地址完全不同，工作范围只限于局域网。对比理解 MAC 地址和 IP 地址：</p><ul><li>IP 地址描述的是路途总体的起点和终点。</li><li>MAC 地址描述的是路途上的每一个区间的起点和终点。</li></ul></blockquote><h3 id="2-MAC-帧的分离原理（如何提取报头和有效载荷）"><a href="#2-MAC-帧的分离原理（如何提取报头和有效载荷）" class="headerlink" title="2. MAC 帧的分离原理（如何提取报头和有效载荷）"></a>2. MAC 帧的分离原理（如何提取报头和有效载荷）</h3><blockquote><p>MAC 帧的报头和帧尾长度是固定的，所以“定长分离”即可取出有效载荷。只要看类型字段，就能知道“有效载荷”该交给哪个上层协议。</p></blockquote><p>因为以太网帧的 <strong>帧头和帧尾长度固定</strong>，所以在接收端处理非常简单：</p><ol><li><strong>底层网卡驱动</strong> 收到原始比特流；</li><li>按帧结构解析出：前 14 字节 → 报头（含源 MAC、目的 MAC、类型字段），后 4 字节 → CRC 校验码，中间部分 → 有效载荷（上层协议的数据）。</li><li><strong>CRC 校验</strong>：验证数据是否出错，失败则丢弃，不交付上层。</li></ol><h3 id="3-流程示例（主机-A-→-主机-B）"><a href="#3-流程示例（主机-A-→-主机-B）" class="headerlink" title="3. 流程示例（主机 A → 主机 B）"></a>3. 流程示例（主机 A → 主机 B）</h3><p>假设主机 A 想把一个 IP 数据报发给同一局域网的主机 B。</p><h4 id="1-主机-A-封装帧"><a href="#1-主机-A-封装帧" class="headerlink" title="1. 主机 A 封装帧"></a>1. 主机 A 封装帧</h4><ul><li><strong>目的 MAC 地址</strong>：主机 B 的 MAC。</li><li><strong>源 MAC 地址</strong>：主机 A 的 MAC。</li><li><strong>类型字段</strong>：<code>0x0800</code>（表示上层协议是 IPv4）。</li><li><strong>有效载荷</strong>：要发送的 IP 数据报。</li><li><strong>CRC 校验码</strong>：通过多项式算法生成，用于校验错误。</li><li>封装完毕后发入局域网（广播介质）。</li></ul><h4 id="2-局域网中每台主机都能收到这个帧"><a href="#2-局域网中每台主机都能收到这个帧" class="headerlink" title="2. 局域网中每台主机都能收到这个帧"></a>2. 局域网中每台主机都能收到这个帧</h4><p>包括主机 A 自己、主机 B、以及其他主机，每台主机都会提取出 <strong>目的 MAC 地址</strong>，比对自己的 MAC 地址：</p><ul><li><strong>如果匹配：</strong> 说明是发给自己的，继续向上交付。</li><li><strong>如果不匹配：</strong> 说明不是给自己的，直接丢弃。</li></ul><h4 id="3-主机-B-处理-MAC-帧"><a href="#3-主机-B-处理-MAC-帧" class="headerlink" title="3. 主机 B 处理 MAC 帧"></a>3. 主机 B 处理 MAC 帧</h4><p>主机 B 收到后执行以下步骤：</p><ol><li><strong>CRC 校验通过</strong>。</li><li><strong>目的 MAC 地址匹配自己</strong>。</li><li>读取 <strong>类型字段（0x0800）</strong>，得知上层协议是 IP。</li><li>将“有效载荷部分”交给上层 <strong>IP 协议模块</strong>。</li><li>上层 IP 模块再进一步解析 IP 头、转发或交付给 TCP&#x2F;UDP。</li></ol><blockquote><p>MAC 帧是局域网的信封，IP 数据报是信件内容，信封上写了寄信人（源 MAC）、收信人（目的 MAC）和信件类型（Type），收到后，只要信封写的是你、信件没损坏，就会把信交给正确的部门（上层协议）。</p></blockquote><h2 id="4-认识-MTU"><a href="#4-认识-MTU" class="headerlink" title="4. 认识 MTU"></a>4. 认识 MTU</h2><h3 id="1-什么是-MTU？"><a href="#1-什么是-MTU？" class="headerlink" title="1. 什么是 MTU？"></a>1. 什么是 MTU？</h3><blockquote><p>  <strong>MTU（最大传输单元）：指数据链路层一次能够承载的最大数据负载长度（单位：字节），不包括以太网帧头与帧尾。</strong></p></blockquote><p>也就是说，<strong>MTU 限制了 IP 层单次发送的数据量上限</strong>，如果上层交给 IP 的数据长度超过 MTU，<strong>IP 层就必须分片</strong>。</p><h3 id="2-MTU-对-IP-协议的影响"><a href="#2-MTU-对-IP-协议的影响" class="headerlink" title="2. MTU 对 IP 协议的影响"></a>2. MTU 对 IP 协议的影响</h3><p>IP 层负责把上层传来的数据封装成 IP 数据报，如果要发送的数据 &gt; MTU，则需要 <strong>分片</strong>，分片机制：</p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20251008161058351.png"></p><p>示例：假设 MTU &#x3D; 1500，IP 头 &#x3D; 20 字节，则有效载荷最大 &#x3D; 1480。如果上层传 4000 字节，则会被拆分成：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[第1片] 1480字节（MF=1）</span><br><span class="line">[第2片] 1480字节（MF=1）</span><br><span class="line">[第3片] 1040字节（MF=0）</span><br></pre></td></tr></table></figure><p><strong>接收方 IP 层</strong> 根据“标识 + 偏移”重组原始数据报。如果任意一个分片丢失，整个 IP 数据报重组失败 → 上层必须重传。</p><hr><h3 id="3-MTU-对-UDP-协议的影响"><a href="#3-MTU-对-UDP-协议的影响" class="headerlink" title="3. MTU 对 UDP 协议的影响"></a>3. MTU 对 UDP 协议的影响</h3><p>UDP 没有重传机制，因此：若 UDP 报文长度 &gt; MTU → IP 分片，任意一个分片丢失 → 整体 UDP 报文丢失，UDP 没有超时重传机制，只能上层应用感知丢包。因此 <strong>UDP 应尽量避免触发 IP 分片</strong>，推荐单包负载 ≤ 1472 字节（&#x3D; 1500 − 20 − 8）。</p><h3 id="4-MTU-对-TCP-协议的影响"><a href="#4-MTU-对-TCP-协议的影响" class="headerlink" title="4. MTU 对 TCP 协议的影响"></a>4. MTU 对 TCP 协议的影响</h3><p><strong>TCP 有重传机制，但分片仍会带来性能损耗。</strong> 因此 TCP 使用 <strong>MSS（最大分段大小）</strong> 控制单次发送量。<strong>MSS 与 MTU 的关系：</strong></p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MSS = MTU - IP头长度 - TCP头长度</span><br><span class="line">例如：MSS = 1500 - 20 - 20 = 1460</span><br></pre></td></tr></table></figure><p>TCP 在三次握手阶段交换 MSS：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SYN 报文：</span><br><span class="line">  Kind=2（MSS选项）</span><br><span class="line">  Length=4</span><br><span class="line">  Value=1460</span><br></pre></td></tr></table></figure><p>双方协商后取较小值作为实际 MSS，这样 TCP 可以 <strong>避免触发 IP 分片</strong>，直接分段发送。</p><h3 id="5-Linux-中查看硬件地址与-MTU"><a href="#5-Linux-中查看硬件地址与-MTU" class="headerlink" title="5. Linux 中查看硬件地址与 MTU"></a>5. Linux 中查看硬件地址与 MTU</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ifconfig</span><br><span class="line">ip addr show<span class="comment"># 更现代</span></span><br></pre></td></tr></table></figure><p>输出示例：</p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250813132749254.png"></p><p>说明：</p><ul><li><code>mtu 1500</code> → 当前接口最大传输单元为 1500 字节。</li><li><code>link/ether</code> → 后面即是物理 MAC 地址。</li></ul><hr><h2 id="5-ARP-协议"><a href="#5-ARP-协议" class="headerlink" title="5. ARP 协议"></a>5. ARP 协议</h2><h3 id="1-ARP-协议的作用"><a href="#1-ARP-协议的作用" class="headerlink" title="1. ARP 协议的作用"></a>1. ARP 协议的作用</h3><h4 id="1-ARP-的使命"><a href="#1-ARP-的使命" class="headerlink" title="1. ARP 的使命"></a>1. ARP 的使命</h4><blockquote><p><strong>在同一个局域网内，通过目标 IP 地址，动态查询并获取其对应的 MAC 地址。</strong> </p></blockquote><p>在同一个局域网（LAN）中进行通信时：数据链路层负责 <strong>以太网帧</strong> 的传输，但以太网通信依赖的是 <strong>MAC 地址</strong>（硬件地址），而不是 IP 地址，实际上，我们在上层通信时通常只知道对方的 <strong>IP 地址</strong>（例如 <code>192.168.1.2</code>）。所以，问题来了：已知对方 IP 地址，如何得到对应的 MAC 地址？这正是 <strong>ARP（地址解析协议）</strong> 的核心作用。</p><h4 id="2-ARP-协议定位与特性"><a href="#2-ARP-协议定位与特性" class="headerlink" title="2. ARP 协议定位与特性"></a>2. ARP 协议定位与特性</h4><ul><li><strong>所在层次：</strong> TCP&#x2F;IP 四层模型的 <strong>数据链路层</strong>。</li><li><strong>与 MAC 帧关系：</strong> 属于 <strong>MAC 帧的上层协议</strong>（即 MAC 封装 ARP）。</li><li><strong>主要功能：</strong> 实现 IP 地址 → MAC 地址 的映射。</li><li><strong>仅限本地子网</strong>：不能跨路由器（ARP 请求不会被路由器转发）。</li><li><strong>无连接、无确认</strong>：广播请求 + 单播应答，不保证可靠（靠重试）。</li><li><strong>缓存机制</strong>：避免频繁广播（<code>arp -a</code> 可查看）。</li></ul><blockquote><p>  <strong>类比：</strong> IP 地址 &#x3D; 收件人姓名，MAC 地址 &#x3D; 收件人门牌号，ARP &#x3D; 在小区公告栏喊：“张三住哪栋哪户？”。</p></blockquote><hr><h3 id="2-ARP-报文格式（重点）"><a href="#2-ARP-报文格式（重点）" class="headerlink" title="2. ARP 报文格式（重点）"></a>2. ARP 报文格式（重点）</h3><p>ARP 报文并不是独立存在的，它是封装在以太网帧中的。下面是 <strong>ARP 数据包格式（共 28 字节）</strong>：</p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20251008224421005.png" alt="PixPin_2025-10-08_22-44-15"></p><table><thead><tr><th>字段名称</th><th>长度（字节）</th><th>含义说明</th></tr></thead><tbody><tr><td><strong>硬件类型（Hardware Type）</strong></td><td>2 字节</td><td>表示链路层类型。以太网为 <code>1</code></td></tr><tr><td><strong>协议类型（Protocol Type）</strong></td><td>2 字节</td><td>表示要解析的协议类型。IPv4 为 <code>0x0800</code></td></tr><tr><td><strong>硬件地址长度（HLEN）</strong></td><td>1 字节</td><td>MAC 地址长度（以太网中为 <code>6</code> 字节）</td></tr><tr><td><strong>协议地址长度（PLEN）</strong></td><td>1 字节</td><td>IP 地址长度（IPv4 中为 <code>4</code> 字节）</td></tr><tr><td><strong>操作码（Op Code）</strong></td><td>2 字节</td><td><code>1</code> &#x3D; 请求，<code>2</code> &#x3D; 应答</td></tr><tr><td><strong>发送端 MAC 地址</strong></td><td>6 字节</td><td>发起 ARP 的主机 MAC 地址</td></tr><tr><td><strong>发送端 IP 地址</strong></td><td>4 字节</td><td>发起 ARP 的主机 IP 地址</td></tr><tr><td><strong>目标 MAC 地址</strong></td><td>6 字节</td><td>目标主机的 MAC 地址（请求时未知，全 1）</td></tr><tr><td><strong>目标 IP 地址</strong></td><td>4 字节</td><td>目标主机的 IP 地址（要解析的 IP）</td></tr></tbody></table><p><strong>注意：帧类型：<code>0x0806</code>（在以太网头部指定），最小长度限制：ARP 报文只有 28 字节，不足以太网帧最小 46 字节，因此需要 补 18 字节填充位。这说明 ARP 是“位于 MAC 帧上层的链路层协议”，而不是网络层。</strong></p><h4 id="1-为什么-ARP-报头里还要-MAC-和-IP？"><a href="#1-为什么-ARP-报头里还要-MAC-和-IP？" class="headerlink" title="1. 为什么 ARP 报头里还要 MAC 和 IP？"></a>1. 为什么 ARP 报头里还要 MAC 和 IP？</h4><ul><li><strong>协议独立性</strong>：ARP 设计为通用协议，可支持非以太网。</li><li><strong>上下层解耦</strong>：MAC 帧只负责传输，ARP 负责逻辑解析，二者不共享字段。</li></ul><hr><h3 id="3-ARP-工作流程（核心机制）"><a href="#3-ARP-工作流程（核心机制）" class="headerlink" title="3. ARP 工作流程（核心机制）"></a>3. ARP 工作流程（核心机制）</h3><blockquote><p><strong>在 ARP 过程中，收到的任何 ARP 报文，都是先看操作码（Op Code）！！！</strong></p><ul><li>Op Code 值为 1 表示 ARP 请求（ARP Request）。</li><li>Op Code 值为 2 表示 ARP 应答（ARP Reply）。</li></ul><p>当主机收到一个 ARP 报文时，首先看这个字段，<strong>它决定了接下来主机要干什么：</strong></p><ul><li>如果是 <code>1（请求）</code>：说明对方在问「谁是这个 IP？」→ 如果该 IP 是我自己，就要 <strong>回一个应答包</strong> 告诉对方我的 MAC 地址。</li><li>如果是 <code>2（应答）</code>：说明对方在告诉我「这个 IP 的 MAC 是我」 → 我就要 <strong>更新或新增我的 ARP 缓存表</strong>。</li></ul><p>所以 Op Code 决定了这个包是请求还是应答，也决定了主机下一步行为。</p></blockquote><h4 id="1-ARP-请求（Request）"><a href="#1-ARP-请求（Request）" class="headerlink" title="1. ARP 请求（Request）"></a>1. ARP 请求（Request）</h4><p>主机 A 想知道主机 B 的 MAC 地址，但只知道其 IP 地址。这时需要构建 ARP 请求：</p><table><thead><tr><th>字段</th><th>内容</th></tr></thead><tbody><tr><td>硬件类型</td><td>1（以太网）</td></tr><tr><td>协议类型</td><td>0x0800（IPv4）</td></tr><tr><td>硬件地址长度</td><td>6</td></tr><tr><td>协议地址长度</td><td>4</td></tr><tr><td>操作码</td><td>1（ARP 请求）</td></tr><tr><td>发送端 MAC&#x2F;IP</td><td>路由器 D 的 MAC&#x2F;IP</td></tr><tr><td>目标 MAC</td><td>全 1（二进制，全 F）表示广播</td></tr><tr><td>目标 IP</td><td>主机 B 的 IP</td></tr></tbody></table><ol><li><strong>发送过程：</strong> ARP 请求封装进以太网帧：以太网 <strong>目的地址</strong>：<code>FF:FF:FF:FF:FF:FF</code>（广播），以太网 <strong>源地址</strong>：A 的 MAC 地址，帧类型：<code>0x0806</code>，然后广播发送到整个局域网。</li><li><strong>各主机的处理：</strong> 每台主机都能收到该广播帧，所有主机的 MAC 层识别帧类型为 <code>0x0806</code> → 上交给 <strong>ARP 层</strong>，各主机比对 <strong>目的 IP</strong> 是否与自己相符：<ul><li>若 <strong>不匹配</strong> → 在 ARP 层丢弃。</li><li>若 <strong>匹配</strong> → 生成 ARP 应答。</li></ul></li></ol><h4 id="2-ARP-应答（Reply）"><a href="#2-ARP-应答（Reply）" class="headerlink" title="2. ARP 应答（Reply）"></a>2. ARP 应答（Reply）</h4><p>主机 B 收到 ARP 请求，发现目的 IP 是自己的 IP，于是要回复，构建 ARP 应答：</p><table><thead><tr><th>字段</th><th>内容</th></tr></thead><tbody><tr><td>硬件类型</td><td>1</td></tr><tr><td>协议类型</td><td>0x0800</td></tr><tr><td>硬件地址长度</td><td>6</td></tr><tr><td>协议地址长度</td><td>4</td></tr><tr><td>操作码</td><td>2（ARP 应答）</td></tr><tr><td>发送端 MAC&#x2F;IP</td><td>主机 B 的 MAC&#x2F;IP</td></tr><tr><td>目标 MAC&#x2F;IP</td><td>路由器 D 的 MAC&#x2F;IP（请求中带有）</td></tr></tbody></table><ol><li><strong>发送过程：</strong> ARP 应答封装成以太网帧：以太网 <strong>目的地址</strong>：D 的 MAC 地址（单播），以太网 <strong>源地址</strong>：B 的 MAC 地址，帧类型：<code>0x0806</code></li><li><strong>接收与更新：</strong> A 收到该帧，交给 ARP 层，ARP 层识别为应答包（op &#x3D; 2），从中提取 B 的 MAC 地址，更新 <strong>ARP 缓存表</strong>（IP ↔ MAC 映射）。</li></ol><hr><h3 id="4-ARP-缓存表（ARP-Cache）"><a href="#4-ARP-缓存表（ARP-Cache）" class="headerlink" title="4. ARP 缓存表（ARP Cache）"></a>4. ARP 缓存表（ARP Cache）</h3><blockquote><p><strong>主机的 MAC 地址和 IP 地址，会被主机临时缓存起来，即在本地维护一张 ARP 表（ARP Cache），它的作用是：避免每次都广播请求，可以通过命令查看：<code>arp -a</code>。</strong></p></blockquote><ul><li><p><strong>ARP 只有在缓存失效的时候才会进行：</strong> ARP 缓存表中的每一条记录都有 <strong>生命周期（一般 60~120 秒）</strong>，在这段时间内主机会直接使用，不会重新发 ARP 请求。过期后再使用该 IP 通信时，才会重新广播询问。</p></li><li><p><strong>可以“扫描网段”来获取所有主机的 MAC 地址：</strong> 在同一个局域网内，我们知道：本机的 IP，例如 192.168.1.10，子网掩码：255.255.255.0 → 网络号：192.168.1.0&#x2F;24，那就可以从 192.168.1.1 到 192.168.1.254 依次 ping。每 ping 一个地址，系统都会自动触发一次 ARP 查询。 查询结果（IP-MAC 映射）就会缓存在本机 ARP 表中。工具命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">arp -n<span class="comment"># 查看本机 ARP 缓存</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者使用 nmap 自动扫描局域网主机</span></span><br><span class="line"><span class="built_in">sudo</span> apt install nmap</span><br><span class="line"><span class="built_in">sudo</span> apt install -y nmap</span><br><span class="line"><span class="built_in">sudo</span> nmap -sn 192.168.1.0/24</span><br></pre></td></tr></table></figure></li><li><p><strong>若收到多次同样的 ARP 应答，以最新为准：</strong> ARP 缓存表是动态维护的，<strong>新的应答会覆盖旧的记录</strong>，这正是 ARP 欺骗能攻击的原因之一！攻击者伪造应答包欺骗网关，篡改缓存表，从而劫持流量。</p></li></ul><h3 id="5-为什么不直接用广播通信？"><a href="#5-为什么不直接用广播通信？" class="headerlink" title="5. 为什么不直接用广播通信？"></a>5. 为什么不直接用广播通信？</h3><p>理论上确实可以直接广播发数据帧（IP 层再判断是否是给自己的），但这会带来：</p><ol><li>大量无关主机都要交给内核处理（浪费 CPU&#x2F;内存资源）。</li><li>破坏单播&#x2F;广播的语义。</li><li>极大降低局域网效率（广播风暴）。</li></ol><p>所以我们必须依赖 ARP，在底层就精确确定目标 MAC。</p><h3 id="6-ARP-欺骗"><a href="#6-ARP-欺骗" class="headerlink" title="6. ARP 欺骗"></a>6. ARP 欺骗</h3><blockquote><p>以下操作 <strong>仅限授权测试（如自己搭建的实验环境）</strong>，在他人网络中实施 ARP 欺骗属于 <strong>违法行为</strong>（违反《网络安全法》）。 </p></blockquote><h4 id="1-推荐工具：arpspoof（来自-dsniff-套件）"><a href="#1-推荐工具：arpspoof（来自-dsniff-套件）" class="headerlink" title="1. 推荐工具：arpspoof（来自 dsniff 套件）"></a>1. 推荐工具：<code>arpspoof</code>（来自 <code>dsniff</code> 套件）</h4><p>Centos 7.6 中安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> yum install -y epel-release<span class="comment"># 启用 EPEL 仓库（多数网络工具在 EPEL）</span></span><br><span class="line"><span class="built_in">sudo</span> yum makecache<span class="comment"># 更新缓存（可选）</span></span><br><span class="line"><span class="built_in">sudo</span> yum install -y nmap dsniff<span class="comment"># 安装 nmap 与 dsniff</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证安装</span></span><br><span class="line">nmap --version</span><br><span class="line"><span class="built_in">which</span> dsniff || rpm -qa | grep dsniff</span><br></pre></td></tr></table></figure><p>Ubuntu 22.04 中安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt update<span class="comment"># 更新包索引（可选但推荐）</span></span><br><span class="line"><span class="built_in">sudo</span> apt install -y nmap<span class="comment"># 安装 nmap（APT 版本）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者用 snap（若你偏好 snap 版本）</span></span><br><span class="line"><span class="comment"># sudo snap install nmap</span></span><br><span class="line"></span><br><span class="line">nmap --version<span class="comment"># 安装后验证</span></span><br></pre></td></tr></table></figure><hr><h4 id="2-arpspoof-命令参数含义（不是固定的，必须根据目标改！）"><a href="#2-arpspoof-命令参数含义（不是固定的，必须根据目标改！）" class="headerlink" title="2. arpspoof 命令参数含义（不是固定的，必须根据目标改！）"></a>2. <code>arpspoof</code> 命令参数含义（不是固定的，必须根据目标改！）</h4><p>命令格式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> arpspoof -i &lt;网卡名&gt; -t &lt;目标主机IP&gt; &lt;欺骗对象IP&gt;</span><br></pre></td></tr></table></figure><p><strong>各参数解释：</strong></p><table><thead><tr><th>参数</th><th>说明</th><th>必须改吗？</th></tr></thead><tbody><tr><td><code>-i eth0</code></td><td>你当前联网的网卡（可能是 <code>wlan0</code>、<code>ens33</code> 等）</td><td>必须改成你自己的网卡</td></tr><tr><td><code>-t 192.168.1.100</code></td><td><strong>你要欺骗的那台主机的 IP</strong>（受害者）</td><td>必须指定目标</td></tr><tr><td><code>192.168.1.1</code></td><td><strong>你冒充的对象的 IP</strong>（通常是网关）</td><td>必须指定冒充谁</td></tr></tbody></table><blockquote><p><strong>为什么需要两个 IP？</strong><br>因为 ARP 欺骗的本质是：<strong>“让 A 相信 B 的 MAC 地址是我（攻击者）的”</strong>，所以你需要告诉 <code>arpspoof</code>：</p><ul><li><strong>谁被骗？</strong> → <code>-t 192.168.1.100</code>（目标主机）。</li><li><strong>冒充谁？</strong> → <code>192.168.1.1</code>（通常是网关）。</li></ul></blockquote><h4 id="3-ARP-欺骗"><a href="#3-ARP-欺骗" class="headerlink" title="3. ARP 欺骗"></a>3. ARP 欺骗</h4><blockquote><p>[[网络科普] 一个视频看懂 ARP 与 ARP 攻击 | B 站](<a href="https://www.bilibili.com/video/BV1MSKfz1ExS/?share_source">https://www.bilibili.com/video/BV1MSKfz1ExS/?share_source</a> &#x3D; copy_web&amp;vd_source &#x3D; 872e5e3ccf44874c39edaf42e30ab0de)</p><p><a href="https://www.bilibili.com/video/BV1B3PxeKEsV/?share_source=copy_web&vd_source=872e5e3ccf44874c39edaf42e30ab0de">【城】网络高手让你断网的方法竟是…如何预防？(ARP 协议与攻击防护) | B 站</a></p></blockquote><blockquote><p><span style="color:#FF0000;"><strong>⚠️ 重要法律与道德声明 ⚠️</strong></span></p><p><span style="color:#FF0000;">本指南仅用于 <strong>网络安全学习、实验环境搭建及授权渗透测试</strong>。</span></p><p><span style="color:#FF0000;">在 <strong>未经授权</strong> 的情况下，对他人网络、设备或服务实施 ARP 欺骗、流量劫持、数据嗅探等行为，属于 <strong>严重违法行为</strong>，违反《中华人民共和国网络安全法》、《刑法》第 285 条（非法侵入计算机信息系统罪）及第 286 条（破坏计算机信息系统罪）。</span></p><p><span style="color:#FF0000;">请务必在以下场景中使用本指南：</span></p><ul><li><span style="color:#FF0000;">自己搭建的虚拟机环境（如 VirtualBox&#x2F;VMware）</span></li><li><span style="color:#FF0000;">经过明确书面授权的渗透测试项目</span></li><li><span style="color:#FF0000;">教学机构提供的实验平台</span></li></ul><p><span style="color:#FF0000;">禁止在公共网络、公司内网、云服务器或任何非授权环境中进行此类操作。</span></p><p><span style="color:#FF0000;">学习安全技术的目的是为了更好地保护网络，而非攻击。请遵守法律法规，做一名负责任的安全从业者。 </span></p></blockquote><p><strong>前提条件：设备需要处于同一个子网下，如：同一 WiFi、热点等。云服务器存在限制，大概率是不行的。效果：目标主机断网。</strong></p><ol><li>查自己的网卡名和网关（只需做一次）：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ip a                    <span class="comment"># 看网卡名（如 eth0、ens33、wlan0）</span></span><br><span class="line">ip route show default   <span class="comment"># 看网关 IP（如 192.31.0.1）</span></span><br></pre></td></tr></table></figure><ol start="2"><li>如果不知道目标 IP，就用 nmap 扫描同网段找活跃主机（可选）：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -sn 192.31.0.0/20   <span class="comment"># 把 192.31.0.0/20 换成你的真实子网，从结果里选一个目标 IP，不想计算可以直接选择 ip a 的结果，或者使用其他工具进行计算</span></span><br></pre></td></tr></table></figure><ol start="3"><li>开启 IP 转发（让流量经过你再转发出去）：</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="number">1</span> | sudo tee /proc/sys/net/ipv4/ip_forward</span><br></pre></td></tr></table></figure><ol start="4"><li>发起 ARP 欺骗：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> arpspoof -i 网卡名 -t 目标IP 网关IP</span><br></pre></td></tr></table></figure><ol start="5"><li>在目标机上进行验证：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arp -a | grep 网关IP</span><br></pre></td></tr></table></figure><ol start="6"><li>停止攻击并恢复网络：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 停止 arpspoof (按 Ctrl+C)</span></span><br><span class="line"><span class="comment"># 2. 关闭 IP 转发</span></span><br><span class="line"><span class="built_in">echo</span> 0 | <span class="built_in">sudo</span> <span class="built_in">tee</span> /proc/sys/net/ipv4/ip_forward</span><br></pre></td></tr></table></figure><blockquote><p>在 kali 中感觉会容易一点：注意虚拟机中要把网络适配器改成 <strong>NAT 模式</strong> 或者 <strong>桥接模式（勾选复制物理网络连接状态）</strong> 直连真实的物理网络。</p><ol><li>先切换到 root，执行：<code>ifconfig</code> 拿到 IP，用 <code>route -n</code> 拿到网关（”default” 或 “0.0.0.0” 行对应的就是默认网关，或者看 Flags 项：<code>UG</code> 标志中的 <code>G</code> 表示这是一个网关）。</li><li>用 <code>fping -g 自己的 IP</code> 或者 <code>nmap -sn 自己的IP</code> 找到当前局域网下所有活跃、活着的 IP（alive）。</li><li>开启 IP 转发（让流量能经 Kali 转发）：<code>echo 1 | sudo tee /proc/sys/net/ipv4/ip_forward</code>。</li><li>开始攻击：<code>arpspoof -i 网卡名 -t 目标IP 要冒充的IP/网关IP</code>，比如：<code>arpspoof -i eth0 -t 192.168.72.130 192.168.72.2</code>。</li><li>停止攻击：<code>echo 0 | sudo tee /proc/sys/net/ipv4/ip_forward</code>。</li></ol></blockquote>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;数据链路层&quot;&gt;&lt;a href=&quot;#数据链路层&quot; class=&quot;headerlink&quot; title=&quot;数据链路层&quot;&gt;&lt;/a&gt;数据链路层&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a</summary>
        
      
    
    
    
    <category term="Linux" scheme="https://www.minbit.top/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://www.minbit.top/tags/Linux/"/>
    
    <category term="网络" scheme="https://www.minbit.top/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>053 网络层 —— IP 协议</title>
    <link href="https://www.minbit.top/posts/60727.html"/>
    <id>https://www.minbit.top/posts/60727.html</id>
    <published>2025-10-08T04:00:00.000Z</published>
    <updated>2025-10-08T04:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="网络层-——-IP-协议"><a href="#网络层-——-IP-协议" class="headerlink" title="网络层 —— IP 协议"></a>网络层 —— IP 协议</h1><blockquote><p><a href="https://blog.csdn.net/chenlong_cxy/article/details/125837340">网络层协议 ——— IP 协议 | CSDN</a></p><p><a href="https://blog.csdn.net/m0_73281594/article/details/147008726">网络层 IP 协议 | CSDN</a></p><p><a href="https://www.bilibili.com/video/BV1HL41117tZ/?share_source=copy_web&vd_source=872e5e3ccf44874c39edaf42e30ab0de">为什么大家的 IP 都是 192.168 开头的？| B 站（荐）</a></p><p><a href="https://www.bilibili.com/video/BV1DD4y127r4/?share_source=copy_web&vd_source=872e5e3ccf44874c39edaf42e30ab0de">【硬核科普】IP 地址是什么东西？IPV6 和 IPV4 有什么区别？公网 IP 和私有 IP 又是什么？| B 站（荐）</a></p></blockquote><h2 id="1-IP-地址的本质：网络号-主机号"><a href="#1-IP-地址的本质：网络号-主机号" class="headerlink" title="1. IP 地址的本质：网络号 + 主机号"></a>1. IP 地址的本质：网络号 + 主机号</h2><p>IP 地址由两部分组成：</p><table><thead><tr><th>部分</th><th>作用</th><th>举例</th></tr></thead><tbody><tr><td><strong>网络号 (Network ID)</strong></td><td>表示属于哪个子网</td><td>192.168.10.<strong>0</strong></td></tr><tr><td><strong>主机号 (Host ID)</strong></td><td>表示子网内的哪台主机</td><td>192.168.10.<strong>15</strong></td></tr></tbody></table><p><strong>规律：</strong></p><ul><li><strong>同一子网内</strong>：网络号相同，主机号不同。</li><li><strong>不同子网</strong>：网络号不同，主机号可以重复。</li></ul><p><strong>举例：</strong></p><ul><li>子网 A：192.168.1.0&#x2F;24</li><li>子网 B：192.168.2.0&#x2F;24</li></ul><p>两个子网的主机号范围都可是 1–254，不冲突，因为网络号不同。</p><h2 id="2-IP-地址划分基础"><a href="#2-IP-地址划分基础" class="headerlink" title="2. IP 地址划分基础"></a>2. IP 地址划分基础</h2><h3 id="1-划分目的"><a href="#1-划分目的" class="headerlink" title="1. 划分目的"></a>1. 划分目的</h3><blockquote><p><strong>根本目的就是为了高效管理、节省地址、提升安全和性能。</strong></p></blockquote><p>最初，互联网只分为 <strong>A、B、C 类地址</strong>（分类地址），但从 1993 年起，RFC 1519 正式引入 CIDR，<strong>CIDR（无类别域间路由） + 子网掩码灵活划分</strong> 彻底取代了 A&#x2F;B&#x2F;C 类的刚性结构，于是就出现了现代 IP 地址分类图：</p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20251007173226991.png" alt="PixPin_2025-10-07_17-32-21"></p><table><thead><tr><th>类别</th><th>起始位</th><th>首字节范围</th><th>网络（号）位数</th><th>主机（号）位数</th><th>用途</th><th>典型示例</th></tr></thead><tbody><tr><td>A 类</td><td>0</td><td>0–127</td><td>8</td><td>24</td><td>特大型网络</td><td>10.0.0.0</td></tr><tr><td>B 类</td><td>10</td><td>128–191</td><td>16</td><td>16</td><td>中型网络</td><td>172.16.0.0</td></tr><tr><td>C 类</td><td>110</td><td>192–223</td><td>24</td><td>8</td><td>小型网络（家庭&#x2F;小公司）</td><td>192.168.0.0</td></tr><tr><td>D 类</td><td>1110</td><td>224–239</td><td>——</td><td>——</td><td>多播&#x2F;组播（Multicast）</td><td>224.0.0.1</td></tr><tr><td>E 类</td><td>11110</td><td>240–255</td><td>——</td><td>——</td><td>保留（实验&#x2F;未来）</td><td>240.0.0.0</td></tr></tbody></table><p><strong>问题</strong>：</p><ul><li>某公司有 1000 台主机，用 C 类不够（254），用 B 类又太多（浪费），IP 资源有限，这样分配太粗。</li><li>而且所有主机在一个广播域，广播风暴、安全隔离都成问题。</li></ul><p><strong>所以，必须打破 A&#x2F;B&#x2F;C 类的限制，按实际需求“切分”IP 地址块</strong> —— 这就是 <strong>子网划分</strong> 的核心目的，于是 <strong>子网划分</strong> 就此出现。</p><h3 id="2-CIDR-是什么？"><a href="#2-CIDR-是什么？" class="headerlink" title="2. CIDR 是什么？"></a>2. CIDR 是什么？</h3><p><strong>CIDR &#x3D; Classless Inter-Domain Routing（无类别域间路由），核心思想：不再看第一个字节的前几位来判断是 A&#x2F;B&#x2F;C，而是用“斜杠 + 数字”表示网络位长度。</strong> 例如：</p><ul><li><code>192.168.1.0/24</code> → 不管它是 C 类，我们说“前 24 位是网络号”</li><li><code>10.0.0.0/8</code> → 不管它是 A 类，我们说“前 8 位是网络号”</li><li><code>172.16.0.0/16</code> → 不管它是 B 类，我们说“前 16 位是网络号”</li></ul><p><strong>现在所有网络设备（路由器、交换机、Linux、Windows）都支持 CIDR！</strong> 而我们只需要记住：</p><ol><li><strong>私有 IP 地址范围（面试常问！）</strong><ul><li>A 类：<code>10.0.0.0/8</code> → 10.0.0.0 ~ 10.255.255.255。</li><li>B 类：<code>172.16.0.0/12</code> → 172.16.0.0 ~ 172.31.255.255。</li><li>C 类：<code>192.168.0.0/16</code> → 192.168.0.0 ~ 192.168.255.255。</li></ul></li><li><strong>公有 IP 地址</strong> → 由 ISP 分配，全球唯一，可用于互联网访问。</li><li><strong>子网划分完全基于 CIDR 和子网掩码，与 A&#x2F;B&#x2F;C 无关！</strong></li></ol><h3 id="3-什么是子网（Subnet）——-网络号相同的一组主机"><a href="#3-什么是子网（Subnet）——-网络号相同的一组主机" class="headerlink" title="3. 什么是子网（Subnet）—— 网络号相同的一组主机"></a>3. 什么是子网（Subnet）—— 网络号相同的一组主机</h3><blockquote><p><strong>同一子网：网络号相同的一组主机；不同子网：网络号不同的主机。后文会提到。</strong></p></blockquote><p><strong>子网</strong>：把原来的一个网络再细分成多个更小的网络（称为“子网”），每个子网都能独立使用。这样做有两个核心目的：</p><ol><li><strong>节约 IP 地址</strong> —— 合理利用地址空间。</li><li><strong>便于网络管理</strong> —— 不同部门、楼层或业务线用不同子网，方便隔离与路由。</li></ol><h3 id="4-子网掩码（Subnet-Mask）"><a href="#4-子网掩码（Subnet-Mask）" class="headerlink" title="4. 子网掩码（Subnet Mask）"></a>4. 子网掩码（Subnet Mask）</h3><p>子网划分的关键就是 <strong>子网掩码</strong>，它用来区分“网络号”和“主机号”。它和 IP 地址配合，告诉设备：“哪些位是网络部分，哪些是主机部分”。常见写法：</p><ul><li><code>255.255.255.0</code>（等价于 <code>/24</code>）。</li><li><code>255.255.0.0</code>（等价于 <code>/16</code>）。</li><li><code>255.255.255.128</code>（等价于 <code>/25</code>）。</li></ul><blockquote><p><strong>记住：&#x2F;后面的数字 &#x3D; 网络位的总位数（从左往右数 1 的个数）</strong></p></blockquote><h4 id="1-举个实际例子"><a href="#1-举个实际例子" class="headerlink" title="1. 举个实际例子"></a>1. 举个实际例子</h4><p>有一个 C 类地址：<code>192.168.1.0/24</code>，默认只能有 1 个网络，254 台主机（192.168.1.1 ~ 192.168.1.254）。但公司有 <strong>3 个部门</strong>，希望彼此隔离（财务、研发、销售），怎么办？</p><p><strong>划分子网！</strong> 把 <code>/24</code> 改成 <code>/26</code>：</p><ul><li>网络位从 24 位 → 26 位（多借 2 位）。</li><li>可用子网数：2² &#x3D; <strong>4 个子网</strong>。</li><li>每个子网主机数：2^(32-26) - 2 &#x3D; 64 - 2 &#x3D; <strong>62 台</strong>（减 2 是去掉网络地址和广播地址）。</li></ul><p>子网划分结果：</p><table><thead><tr><th>子网</th><th>网络地址</th><th>可用 IP 范围</th><th>广播地址</th></tr></thead><tbody><tr><td>1</td><td>192.168.1.0</td><td>192.168.1.1 ~ 192.168.1.62</td><td>192.168.1.63</td></tr><tr><td>2</td><td>192.168.1.64</td><td>192.168.1.65 ~ 192.168.1.126</td><td>192.168.1.127</td></tr><tr><td>3</td><td>192.168.1.128</td><td>…</td><td>192.168.1.191</td></tr><tr><td>4</td><td>192.168.1.192</td><td>…</td><td>192.168.1.255</td></tr></tbody></table><hr><h2 id="3-IP（IPv4）-协议报头解析"><a href="#3-IP（IPv4）-协议报头解析" class="headerlink" title="3. IP（IPv4） 协议报头解析"></a>3. IP（IPv4） 协议报头解析</h2><blockquote><p>IPv4 报头 20 字节起，包含版本、长度、TOS、总长、ID、标志、偏移、TTL、协议、校验和、源&#x2F;目的 IP。其中 TTL 用于防环，协议号决定上层协议，校验和只保护报头，分片靠 ID + 偏移 + 标志控制。现代网络主要用 CIDR 和 TTL&#x2F;Protocol，选项基本废弃。</p><ul><li><strong>IP 报头标准长度 &#x3D; 20 字节</strong>（无选项时）</li><li><strong>IP 报头最大长度 &#x3D; 60 字节</strong>（带选项时）</li><li><strong>本质是内核里的结构体</strong>：<code>struct iphdr</code>（Linux 中定义在 <code>&lt;linux/ip.h&gt;</code>）</li></ul></blockquote><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20251007174941328.png" alt="PixPin_2025-10-07_17-49-36"></p><table><thead><tr><th>字段名</th><th>位数</th><th>作用</th><th>说明</th></tr></thead><tbody><tr><td><strong>版本 (Version)</strong></td><td>4</td><td>指定 IP 协议版本</td><td>IPv4 为 4，IPv6 为 6</td></tr><tr><td><strong>首部长度 (IHL)</strong></td><td>4</td><td>表示报头长度（单位：4 字节）</td><td>常见值为 5 → 5×4 &#x3D; 20 字节；最大 15→60 字节</td></tr><tr><td><strong>服务类型 (TOS &#x2F; DSCP)</strong></td><td>8</td><td>指导路由器如何转发（QoS）</td><td>可指定最小延迟、最大吞吐、最高可靠、最低成本</td></tr><tr><td><strong>总长度 (Total Length)</strong></td><td>16</td><td>报文整体长度（头 + 数据）</td><td>最大 65535 字节</td></tr><tr><td><strong>标识 (Identification)</strong></td><td>16</td><td>数据分片标识</td><td>同一报文的所有分片使用相同 ID</td></tr><tr><td><strong>标志 (Flags)</strong></td><td>3</td><td>控制分片行为</td><td>含 DF（不分片）和 MF（后续有分片）</td></tr><tr><td><strong>片偏移 (Fragment Offset)</strong></td><td>13</td><td>当前分片在原报文中的偏移位置</td><td>单位为 8 字节</td></tr><tr><td><strong>生存时间 (TTL)</strong></td><td>8</td><td>报文能经过的最大路由跳数</td><td>每过一跳减 1，为 0 时丢弃，防止死循环</td></tr><tr><td><strong>协议 (Protocol)</strong></td><td>8</td><td>指明 IP 的有效载荷交付上层的协议类型</td><td>TCP &#x3D; 6，UDP &#x3D; 17，ICMP &#x3D; 1</td></tr><tr><td><strong>首部校验和 (Header Checksum)</strong></td><td>16</td><td>检查报头是否被破坏</td><td>每个路由器都要重新计算一次</td></tr><tr><td><strong>源 IP 地址 (Source Address)</strong></td><td>32</td><td>发送端地址</td><td>IPv4 地址</td></tr><tr><td><strong>目的 IP 地址 (Destination Address)</strong></td><td>32</td><td>接收端地址</td><td>IPv4 地址</td></tr><tr><td><strong>可选项 (Options)</strong></td><td>可变</td><td>一些特殊用途</td><td>如时间戳、安全、路由记录等</td></tr></tbody></table><hr><h2 id="4-路由器到底是什么？"><a href="#4-路由器到底是什么？" class="headerlink" title="4. 路由器到底是什么？"></a>4. 路由器到底是什么？</h2><blockquote><p><strong>路由器 &#x3D; 有多张网卡的特殊主机。</strong></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20251007183027623.png" alt="PixPin_2025-10-07_18-30-22"></p><h3 id="1-路由器本质是一台多网卡的专用主机"><a href="#1-路由器本质是一台多网卡的专用主机" class="headerlink" title="1. 路由器本质是一台多网卡的专用主机"></a>1. 路由器本质是一台多网卡的专用主机</h3><p>每个物理&#x2F;逻辑接口（网卡）连接一个子网，每个接口必须配置一个 <strong>属于该子网的 IP 地址</strong>，它在每个连接的子网中，都相当于一台普通主机。所以：<strong>路由器本身“属于”多个子网</strong>，但它 <strong>不是普通主机</strong>（不跑业务应用，只转发）。</p><h3 id="2-路由器必须至少连接两个子网"><a href="#2-路由器必须至少连接两个子网" class="headerlink" title="2. 路由器必须至少连接两个子网"></a>2. 路由器必须至少连接两个子网</h3><p>一张网卡对应一个子网，两张网卡以上才能“转发”不同子网的数据，所以路由器一定“同时属于多个子网”。否则就叫“单臂路由”或根本不是路由器（比如家用光猫只接一个 LAN，其实是桥接）。</p><table><thead><tr><th>接口</th><th>连接子网</th><th>配置 IP</th></tr></thead><tbody><tr><td>eth0</td><td>192.168.1.0&#x2F;24</td><td>192.168.1.1</td></tr><tr><td>eth1</td><td>192.168.2.0&#x2F;24</td><td>192.168.2.1</td></tr></tbody></table><p>这样它就能把 A 子网和 B 子网互联。</p><h3 id="3-路由器接口-IP-通常是-1，但不是强制规定！"><a href="#3-路由器接口-IP-通常是-1，但不是强制规定！" class="headerlink" title="3. 路由器接口 IP 通常是 .1，但不是强制规定！"></a>3. 路由器接口 IP 通常是 .1，但不是强制规定！</h3><p>一般路由器是子网中第一台设备（方便识别）。所以它的地址常为 <strong>“网络号 + .1”</strong>。例如：192.168.10.0&#x2F;24 → 路由器常用 IP：192.168.10.1，因为：</p><ul><li><p>网络地址（.0）不能用、广播地址（.255）不能用</p></li><li><p>.1 最顺手、易记（这不是硬性规定，而是一种行业约定，便于统一管理）。</p></li><li><p>但可以设成 .254、.100，只要在子网范围内就行！</p></li></ul><p><strong>关键</strong>：所有主机的“默认网关”要指向这个 IP。</p><h3 id="4-路由器的核心功能"><a href="#4-路由器的核心功能" class="headerlink" title="4. 路由器的核心功能"></a>4. 路由器的核心功能</h3><table><thead><tr><th>功能</th><th>说明</th></tr></thead><tbody><tr><td><strong>数据转发</strong></td><td>根据路由表选择下一跳，把 IP 报文送到目标子网</td></tr><tr><td><strong>子网构建</strong></td><td>可以划分并管理局域网（LAN）</td></tr><tr><td><strong>DHCP 分配</strong></td><td>自动给新主机分配 IP（DHCP 服务器功能）</td></tr><tr><td><strong>NAT 转换</strong></td><td>私网 IP ↔ 公网 IP 转换，实现上网访问</td></tr><tr><td><strong>防火墙 &#x2F; ACL</strong></td><td>过滤、限制特定流量</td></tr></tbody></table><blockquote><p><strong>路由器不“构建”子网，它“连接”子网！</strong> 子网是由 <strong>IP 地址 + 子网掩码</strong> 定义的逻辑网络，物理上靠交换机&#x2F;网线连接，逻辑上靠路由器互联。</p></blockquote><blockquote><p>“子网是由 IP 地址和子网掩码定义的逻辑网络，路由器通过多个接口连接不同子网，每个接口配置对应子网的 IP（通常为 .1），负责跨子网 IP 转发和广播隔离。子网划分基于 CIDR，DHCP 仅用于自动分配地址，非路由器核心功能。”</p></blockquote><hr><h2 id="5-特殊的-IP-地址"><a href="#5-特殊的-IP-地址" class="headerlink" title="5. 特殊的 IP 地址"></a>5. 特殊的 IP 地址</h2><p>我们把 IPv4 的 32 位地址分成两部分：<strong>网络号（Net ID）</strong> 和 <strong>主机号（Host ID）</strong>。根据主机号的取值（全 0、全 1、特殊段），出现了几种特殊地址：</p><table><thead><tr><th>类型</th><th>主机号情况</th><th>举例</th><th>含义</th><th>特点</th></tr></thead><tbody><tr><td><strong>网络地址</strong></td><td>主机号全为 0</td><td><code>xxx.xxx.xxx.0</code>（主机位全 0） 如 <code>192.168.1.0/24</code></td><td>表示整个子网</td><td>不能分配给具体主机</td></tr><tr><td><strong>广播地址</strong></td><td>主机号全为 1</td><td><code>xxx.xxx.xxx.255</code>（主机位全 1） 如&#96;&#96;192.168.1.255&#x2F;24&#96;</td><td>用于给子网内所有主机广播&#x2F;发包</td><td>局域网广播，不能分配给主机</td></tr><tr><td><strong>环回地址</strong></td><td><code>127.0.0.0/8</code> 段</td><td>常用 <code>127.0.0.1</code></td><td>回环测试（本机通信）</td><td>仅本机可用，不经过网卡</td></tr><tr><td><strong>私有地址</strong></td><td>特定保留段</td><td><code>10.0.0.0/8</code>&#x2F;<code>172.16.0.0/12</code>&#x2F;<code>192.168.0.0/16</code></td><td>局域网内部使用，即内网专用，不能上公网</td><td>可在局域网自由使用，不可直接访问公网</td></tr><tr><td><strong>公网地址</strong></td><td>非保留段</td><td>例：<code>8.8.8.8</code></td><td>由 ISP 分配，用于互联网通信</td><td>唯一、可路由</td></tr><tr><td><strong>0.0.0.0</strong></td><td>特殊源地址</td><td>具体含义需结合使用场景、上下文进行判断</td><td>不是真实地址，而是占位符。表示“任意地址”&#x2F;“本机未配置 IP”&#x2F;“默认路由” 等</td><td>不能配置给主机，路由表中表示默认网关</td></tr></tbody></table><blockquote><p>  提示：</p><ul><li>主机号全 0：代表“网络本身”。</li><li>主机号全 1：代表“该网络内的广播”。</li><li>“为什么不能 ping 通 192.168.1.0？” → 因为是网络地址，不是主机。</li></ul></blockquote><h2 id="6-IPv4-地址数量限制"><a href="#6-IPv4-地址数量限制" class="headerlink" title="6. IPv4 地址数量限制"></a>6. IPv4 地址数量限制</h2><h3 id="1-为什么“43-亿”-IP-地址不够用？"><a href="#1-为什么“43-亿”-IP-地址不够用？" class="headerlink" title="1. 为什么“43 亿” IP 地址不够用？"></a>1. 为什么“43 亿” IP 地址不够用？</h3><p><strong>IPv4 是 32 位二进制地址，理论总数：2³² &#x3D; 4,294,967,296（约 43 亿）。 实际可用远少于 43 亿：</strong></p><ul><li>有大量地址被保留（例如环回、私网、广播等）。</li><li>每个设备的 <strong>每张网卡</strong> 都要一个 IP（一台服务器常常有多个网卡，就要多个 IP）。</li><li>早期大公司（如 MIT、Ford）拿走了整段 A 类地址（1600 万个 IP），导致 <strong>地址分配不均</strong>，造成巨大浪费。</li><li>网络分段、地址浪费（如传统 A&#x2F;B&#x2F;C 类）。</li><li><strong>不能按主机数分配</strong>：即使一台电脑，也可能配多个 IP（虚拟主机、容器等）。</li></ul><h3 id="2-如何解决-IPv4-地址枯竭？"><a href="#2-如何解决-IPv4-地址枯竭？" class="headerlink" title="2. 如何解决 IPv4 地址枯竭？"></a>2. 如何解决 IPv4 地址枯竭？</h3><h4 id="1-动态分配-IP（DHCP）"><a href="#1-动态分配-IP（DHCP）" class="headerlink" title="1. 动态分配 IP（DHCP）"></a>1. 动态分配 IP（DHCP）</h4><p><strong>原理：IP 地址池共享，设备上线时分配，下线时回收。优点：提高利用率，局限：无法解决“同时在线设备数 &gt; 可用公网 IP”的问题。</strong> 场景：</p><ul><li>家庭&#x2F;公司路由器：100 台设备，但只有 50 人同时在线 → 只需 50 个 IP。</li><li>学校机房：500 台电脑，但分批使用 → IP 复用。</li></ul><h4 id="2-NAT（网络地址转换）——-最广泛应用！"><a href="#2-NAT（网络地址转换）——-最广泛应用！" class="headerlink" title="2. NAT（网络地址转换）—— 最广泛应用！"></a>2. NAT（网络地址转换）—— 最广泛应用！</h4><p><strong>原理：内网用私有 IP（如 192.168.x.x），出公网时由路由器将 私有 IP + 端口 映射为 一个公网 IP + 不同端口。</strong></p><ul><li><strong>效果：</strong> 成千上万台内网设备，<strong>共享 1 个公网 IP</strong> 上网，公网看不到内网结构，还提升了安全性。</li><li><strong>类型：</strong><ul><li><strong>SNAT（源 NAT）</strong>：内网 → 外网（最常见）。</li><li><strong>DNAT（目的 NAT）</strong>：外网 → 内网（如端口映射：公网 80 → 内网 192.168.1.100:80）。</li></ul></li><li><strong>Linux 实现</strong>：<code>iptables</code> &#x2F; <code>nftables</code> 的 <code>MASQUERADE</code> 或 <code>SNAT</code> 规则。</li></ul><blockquote><p>  NAT 是解决 IPv4 地址不足的核心技术，通过端口复用实现多对一映射。</p></blockquote><h4 id="3-IPv6-——-终极解决方案"><a href="#3-IPv6-——-终极解决方案" class="headerlink" title="3. IPv6 —— 终极解决方案"></a>3. IPv6 —— 终极解决方案</h4><p><strong>地址长度</strong>：128 位 → 地址数 &#x3D; 2¹²⁸ ≈ <strong>3.4×10³⁸</strong>（地球每平方米可分配 10²⁸ 个 IP！）。特点：</p><ul><li>无 NAT（理论上每个设备都有公网 IP）。</li><li>自动配置（SLAAC）。</li><li>报头更简洁，支持流标签、安全扩展。</li></ul><blockquote><p>  虽然 IPv6 是未来，但因历史包袱和成本，IPv4 + NAT 仍是当前主流。</p></blockquote><h3 id="3-杂谈"><a href="#3-杂谈" class="headerlink" title="3. 杂谈"></a>3. 杂谈</h3><blockquote><p>中国的 IPv6 技术目前遥遥领先！</p></blockquote><p>中国的互联网设备数量庞大——光是手机、电脑、物联网设备加起来，早已超过这个数十倍。所以必须找一个更大的地址空间方案，就是 IPv6。对中国来说，这意味着 <strong>从根本上解决地址短缺、NAT 层层嵌套等痛点问题。从国家战略层面来说：是为了实现自主可控 + 下一代网络主导权：</strong></p><ul><li>IPv6 是未来网络的核心基础，涉及骨干网、物联网、云计算、AI 等所有领域。</li><li>早早布局 IPv6，可以减少对旧技术的依赖，<strong>在全球网络标准中占据话语权</strong>。</li></ul><h4 id="1-为什么不能“一键切换”-IPv4-→-IPv6？"><a href="#1-为什么不能“一键切换”-IPv4-→-IPv6？" class="headerlink" title="1. 为什么不能“一键切换” IPv4 → IPv6？"></a>1. 为什么不能“一键切换” IPv4 → IPv6？</h4><p>这点很多人误解了。IPv6 并不是 IPv4 的“升级包”，而是一个 <strong>全新的协议体系</strong>。具体困难主要在三点：</p><ol><li><strong>不兼容设计：</strong> IPv4 和 IPv6 报头结构完全不同，IPv6 无法直接理解 IPv4 报文（例如校验和、地址长度都不同）。所以 IPv4 网络设备、路由器、应用软件都得重新支持 IPv6。</li><li><strong>全球网络规模太庞大：</strong> 互联网中有无数旧设备、老系统（银行、工厂、政府网络等）仍在用 IPv4，不可能让全球数十亿设备在同一时刻同时换协议。</li><li><strong>转换与过渡成本太高：</strong> 企业需要重新配置网络、防火墙、DNS、安全策略，用户端还要兼容双栈（IPv4 + IPv6）运行，否则很多旧网站上不了。<strong>所以现在全球都采用“双栈机制”：IPv4 和 IPv6 并行运行，慢慢过渡。</strong></li></ol><hr><h2 id="7-私网-IP-地址和公网-IP-地址"><a href="#7-私网-IP-地址和公网-IP-地址" class="headerlink" title="7. 私网 IP 地址和公网 IP 地址"></a>7. 私网 IP 地址和公网 IP 地址</h2><blockquote><p>私有 IP 用于内网通信，公网 IP 全球唯一；运营商通过光纤、基站和 IP 分配构建网络基础设施；全球互联网像大学层级体系，靠子网掩码和路由表实现高效寻址；NAT 技术将私有 IP 映射为公网 IP，使内网设备能访问互联网，是 IPv4 时代解决地址枯竭的核心机制。</p></blockquote><h3 id="1-私有-IP-与-公网-IP：谁负责“内部”，谁负责“对外”"><a href="#1-私有-IP-与-公网-IP：谁负责“内部”，谁负责“对外”" class="headerlink" title="1. 私有 IP 与 公网 IP：谁负责“内部”，谁负责“对外”"></a>1. 私有 IP 与 公网 IP：谁负责“内部”，谁负责“对外”</h3><table><thead><tr><th align="center">对比</th><th>私有 IP</th><th>公网 IP</th></tr></thead><tbody><tr><td align="center"><strong>定义</strong></td><td>仅在局域网内有效，<strong>不能在互联网上路由（不可直接上公网）</strong></td><td>全球唯一，<strong>可在互联网上直接通信</strong></td></tr><tr><td align="center"><strong>用途</strong></td><td>局域网内部设备通信（手机、电脑、摄像头）</td><td>全球互联网上通信（全球唯一）</td></tr><tr><td align="center"><strong>地址范围</strong></td><td>-<code>10.0.0.0/8</code>（10.x.x.x） -<code>172.16.0.0/12</code>（172.16~31.x.x） -<code>192.168.0.0/16</code>（192.168.x.x）</td><td>除私有地址、保留地址外的所有 IPv4 地址</td></tr><tr><td align="center"><strong>谁分配</strong></td><td>用户&#x2F;管理员自行规划（如家用路由器自动分配）</td><td>由 <strong>IANA → RIR（如 APNIC）→ ISP（运营商）</strong> 逐级分配</td></tr><tr><td align="center"><strong>能否重复</strong></td><td>可以（不同公司都用 192.168.1.0&#x2F;24）</td><td>不可重复</td></tr><tr><td align="center"><strong>举例</strong></td><td>家用 WiFi、公司内网</td><td>云服务器、网站 IP</td></tr></tbody></table><blockquote><p>  私有 IP 就像“宿舍楼房间号”，只有本楼人懂；公网 IP 是“身份证号”，全国唯一。 </p></blockquote><h3 id="2-运营商：互联网的“基建狂魔”"><a href="#2-运营商：互联网的“基建狂魔”" class="headerlink" title="2. 运营商：互联网的“基建狂魔”"></a>2. 运营商：互联网的“基建狂魔”</h3><p>运营商即互联网服务提供商，它们的作用可以分为两层：</p><ol><li><p><strong>基础设施建设：</strong> 铺设光纤、建基站、建骨干网、机房、IDC 等，就像大学建教学楼、宿舍楼、操场，提供“物理层”环境。</p></li><li><p><strong>提供网络接入：</strong></p><ul><li><p><strong>分配公网 IP</strong>：家庭宽带、移动数据、企业专线等。</p></li><li><p><strong>提供接入服务</strong>：光猫（调制解调器）把光纤信号转成电信号，路由器再分发给内网设备，路由器再给每台设备分配 <strong>私有 IP</strong>，并通过 NAT 技术“借用”一个 <strong>公网 IP</strong> 出门上网。</p></li><li><p><strong>维护骨干网</strong>：确保跨省、跨国流量高效转发。</p></li></ul></li></ol><hr><h3 id="3-全球互联网与网段划分-——-大学的“层级管理”"><a href="#3-全球互联网与网段划分-——-大学的“层级管理”" class="headerlink" title="3. 全球互联网与网段划分 —— 大学的“层级管理”"></a>3. 全球互联网与网段划分 —— 大学的“层级管理”</h3><p>互联网的 IP 地址分配体系非常像大学的组织结构：</p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20251008003448484.png" alt="PixPin_2025-10-08_00-34-43"></p><table><thead><tr><th>网络层级</th><th>对应</th><th>类比：大学体系</th></tr></thead><tbody><tr><td><strong>IANA</strong>（国际互联网数字分配&#x2F;管理机构）</td><td>全球 IP 地址总管家</td><td>教育部：统一分配全国高校编号</td></tr><tr><td><strong>RIR</strong>（区域互联网注册机构，如 APNIC、ARIN 等）</td><td>按大洲分配地址块</td><td>教育厅：给各省分配高校名额</td></tr><tr><td><strong>ISP</strong>（运营商，如中国电信、移动）</td><td>向用户&#x2F;企业提供公网 IP</td><td>省教育厅 → 给某大学分配学号段（如 20250001~20259999）</td></tr><tr><td><strong>企业&#x2F;家庭网络</strong></td><td>使用私有 IP 或少量公网 IP</td><td>大学内部：院系 → 年级 → 班级 → 学生</td></tr><tr><td><strong>子网掩码</strong></td><td>划分网络边界</td><td>学号结构：前 4 位 &#x3D; 院系，中间 2 位 &#x3D; 年级，后 4 位 &#x3D; 个人编号</td></tr><tr><td><strong>路由器</strong></td><td>跨子网转发</td><td>班主任、院办、校务处：负责信息在不同层级间传递</td></tr></tbody></table><p><strong>学号类比：</strong> 每个学生（设备）都有唯一“学号”（IP），通常学号前几位能看出学院、年级、专业（就像子网掩码划分出的网段），如果学生证（IP）丢了，被其他学院的人（另一个网络）捡到，也能通过学号前缀快速查出属于哪个学院（网段）——这就是 <strong>路由转发原理</strong>。</p><hr><h3 id="4-私有网络与公网的关系：靠-NAT-桥接"><a href="#4-私有网络与公网的关系：靠-NAT-桥接" class="headerlink" title="4. 私有网络与公网的关系：靠 NAT 桥接"></a>4. 私有网络与公网的关系：靠 NAT 桥接</h3><p><strong>问题：</strong> 私有 IP 不能上公网！因为公网路由器 <strong>不认识</strong> <code>192.168.1.100</code>，会直接丢弃，而且全球有无数个 <code>192.168.1.100</code>，无法区分。</p><p><strong>解决方案：NAT（网络地址转换）</strong>，工作过程：</p><ol><li>你（<code>192.168.1.100:50000</code>）访问 <code>www.baidu.com:80</code>。</li><li>路由器收到包，<strong>把源 IP 改成自己的公网 IP</strong>（如 <code>203.0.113.45</code>），端口映射为 <code>60000</code>。</li><li>发往公网：<code>源=203.0.113.45:60000</code>，目的 &#x3D; <code>110.242.68.4:80</code>。</li><li>百度回包给 <code>203.0.113.45:60000</code>。</li><li>路由器查 NAT 表，<strong>还原为 <code>192.168.1.100:50000</code></strong>，转发给你。</li></ol><p><strong>效果</strong>：成千上万台内网设备，<strong>共享 1 个公网 IP</strong>，外网无法主动访问内网（天然防火墙），节省公网 IP 资源（核心价值！）。</p><blockquote><p>  <strong>云服务器为什么需要公网 IP？</strong> 因为我们要主动访问它（如 SSH、Web 服务），它必须有一个 <strong>全球可达的地址</strong>，所以云厂商会分配公网 IP（或通过 EIP 弹性绑定）。 </p></blockquote><hr><h2 id="8-NAT-技术的核心作用：让有限的公网-IP-服务更多设备"><a href="#8-NAT-技术的核心作用：让有限的公网-IP-服务更多设备" class="headerlink" title="8. NAT 技术的核心作用：让有限的公网 IP 服务更多设备"></a>8. NAT 技术的核心作用：让有限的公网 IP 服务更多设备</h2><h3 id="1-NAT-是什么？"><a href="#1-NAT-是什么？" class="headerlink" title="1. NAT 是什么？"></a>1. NAT 是什么？</h3><p><strong>NAT（Network Address Translation）</strong> —— 网络地址转换。它的本质是：在数据包经过路由器时，<strong>动态修改 IP 地址（以及端口号）</strong>，以便多个内网设备共用一个公网 IP 上网。</p><h3 id="2-为什么需要-NAT？"><a href="#2-为什么需要-NAT？" class="headerlink" title="2. 为什么需要 NAT？"></a>2. 为什么需要 NAT？</h3><p>IPv4 只有约 43 亿个地址（2³² 个），但设备早就远超这个数量。于是：每个家庭、公司内部设备（电脑、手机、打印机…）都使用 <strong>私有 IP</strong>，路由器对外只暴露一个 <strong>公网 IP</strong>，NAT 技术负责在出入网时做“翻译”。</p><h3 id="3-NAT-的工作过程"><a href="#3-NAT-的工作过程" class="headerlink" title="3. NAT 的工作过程"></a>3. NAT 的工作过程</h3><p>假设：</p><ul><li>家庭内网：192.168.0.10（你的电脑）。</li><li>路由器公网 IP：42.101.8.5。</li></ul><p>你访问百度时：<code>源 IP = 192.168.0.10    →   目的 IP = 180.101.49.12（百度）</code>，在出网时，NAT 做了替换：<code>源 IP = 42.101.8.5:40001（公网IP+端口） → 目的 IP = 180.101.49.12</code>，路由器保存一条映射表：<code>42.101.8.5:40001 ↔ 192.168.0.10:12345</code>，当百度返回数据时：<code>目的 IP = 42.101.8.5:40001</code>。路由器查表，发现要转给内网的 192.168.0.10，于是数据成功回到你的电脑。</p><p><strong>好处：</strong> 成千上万设备共享一个公网 IP，屏蔽内网结构，提高安全性，有效缓解 IPv4 地址不足问题。</p><h3 id="4-NAT-的三种常见类型（按转换粒度区分）"><a href="#4-NAT-的三种常见类型（按转换粒度区分）" class="headerlink" title="4. NAT 的三种常见类型（按转换粒度区分）"></a>4. NAT 的三种常见类型（按转换粒度区分）</h3><table><thead><tr><th>类型</th><th>说明</th><th>典型场景</th></tr></thead><tbody><tr><td><strong>静态 NAT</strong></td><td>一对一映射</td><td>内网服务器要对外提供服务</td></tr><tr><td><strong>动态 NAT</strong></td><td>多对多临时映射</td><td>企业网络动态分配公网地址池</td></tr><tr><td><strong>端口复用 NAT（PAT）</strong></td><td>多对一，通过端口区分</td><td>家用路由器、校园网、公司常用</td></tr></tbody></table><p><strong>家用路由器几乎都是 PAT（端口复用型 NAT）</strong>。因为只有一个公网 IP，但要让几十台设备同时上网，必须通过不同端口区分。</p><blockquote><p><strong>大公司网络虽与家用网络共享 IP 路由原理，但采用精细 IP 规划、多层架构和有限 NAT 策略，对外服务通常直接使用公网 IP 以保障性能与可靠性，其高昂费用主要来自公网 IP、专线带宽和高可用基础设施。家庭路由器是 NAT 的小型实现，大公司机房是它的企业级放大版。运营商卖的不是“网速”，而是带宽 + 公网资源 + 可靠性。</strong></p></blockquote><hr><h2 id="9-路由转发原理：IP-报文如何找到“回家的路”"><a href="#9-路由转发原理：IP-报文如何找到“回家的路”" class="headerlink" title="9. 路由转发原理：IP 报文如何找到“回家的路”"></a>9. 路由转发原理：IP 报文如何找到“回家的路”</h2><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20251008161932828.png" alt="PixPin_2025-10-08_16-19-12"></p><h3 id="1-基本逻辑"><a href="#1-基本逻辑" class="headerlink" title="1. 基本逻辑"></a>1. 基本逻辑</h3><p>所有 IP 报文的转发都是根据 <strong>目的 IP 地址</strong> 来决定的，<strong>与源 IP 无关</strong>。无论是主机还是路由器，都维护着一张 <strong>路由表</strong>，都靠 <strong>本地路由表</strong> 决定“下一跳去哪”。路由表每一项通常包括：</p><table><thead><tr><th>项目</th><th>含义</th></tr></thead><tbody><tr><td>目的网络（Destination）</td><td>目标网段</td></tr><tr><td>子网掩码（Netmask）</td><td>区分网络号和主机号</td></tr><tr><td>下一跳（Next Hop）</td><td>报文应该转发给的下一个路由器地址</td></tr><tr><td>出口接口（Interface）</td><td>报文应从哪块网卡发出</td></tr></tbody></table><h3 id="2-查找路由表的过程"><a href="#2-查找路由表的过程" class="headerlink" title="2. 查找路由表的过程"></a>2. 查找路由表的过程</h3><p>当主机要发送数据时，它会：</p><ol><li><strong>先判断目标是否在同一网段</strong>：<ul><li>用自己的 IP 与目标 IP 分别和子网掩码做按位与；</li><li>若结果相同 → 同一网段，直接通过局域网（ARP 找 MAC）通信；</li><li>若不同 → 不同网段，交给默认网关（通常是路由器）。</li></ul></li><li><strong>路由器转发时</strong>：<ul><li>路由器查自己的路由表；</li><li>对每一条记录执行 <code>(目标IP &amp; 子网掩码)</code>；</li><li>找出最长匹配的网段（即 <strong>最长前缀匹配原则</strong>）；</li><li>按照该记录指示的接口或下一跳转发。</li></ul></li></ol><blockquote><p>  比喻理解：主机查路由表就像问路</p><ul><li>有人告诉你“到市中心走这条路”（有明确路）。</li><li>有人说“我不知道，但我知道到高速入口怎么走”（下一跳）。</li><li>若没人知道，就交给默认路由（缺省出口）。</li></ul></blockquote><h3 id="3-大概转发过程"><a href="#3-大概转发过程" class="headerlink" title="3. 大概转发过程"></a>3. 大概转发过程</h3><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[主机A] → [家用路由器] → [运营商路由器] → [目标网络路由器] → [主机B]</span><br></pre></td></tr></table></figure><p>每经过一个路由器：路由器查路由表，目的 IP <strong>不变</strong>，源 MAC、目的 MAC <strong>每跳都会变</strong>（数据链路层负责）。</p><blockquote><p>  <strong>关键点：网络层靠 IP 地址确定“去哪”，数据链路层靠 MAC 地址确定“怎么到下一跳”。</strong></p></blockquote><hr><h2 id="10-IP-分片机制：大报文如何被拆开传输？"><a href="#10-IP-分片机制：大报文如何被拆开传输？" class="headerlink" title="10. IP 分片机制：大报文如何被拆开传输？"></a>10. IP 分片机制：大报文如何被拆开传输？</h2><h3 id="1-为什么要分片？"><a href="#1-为什么要分片？" class="headerlink" title="1. 为什么要分片？"></a>1. 为什么要分片？</h3><p>因为不同链路的最大传输单元（MTU）不同。比如：以太网 MTU &#x3D; <strong>1500 字节</strong>，若 IP 报文超过 1500 字节，就必须拆分，否则底层帧发不出去。</p><h3 id="2-分片的字段结构"><a href="#2-分片的字段结构" class="headerlink" title="2. 分片的字段结构"></a>2. 分片的字段结构</h3><p>IP 报头里有三个关键字段：</p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20251008161058351.png" alt="PixPin_2025-10-08_16-10-46"></p><table><thead><tr><th>字段</th><th>作用</th></tr></thead><tbody><tr><td><strong>16 位标识（Identification）</strong></td><td>标识同一份数据（同一 IP 报文分片的共同编号）</td></tr><tr><td><strong>3 位标志（Flags）</strong></td><td>控制分片行为</td></tr><tr><td><strong>13 位片偏移（Fragment Offset）</strong></td><td>表示该分片在原报文中的偏移位置（单位 8 字节）</td></tr></tbody></table><p><strong>Flags 含义如下：</strong></p><ul><li>bit0：保留。</li><li>bit1：DF（Don’t Fragment）是否允许分片。</li><li>bit2：MF（More Fragment）是否还有后续分片。</li></ul><p>举例：<code>MF = 1</code> 表示后面还有分片，<code>MF = 0</code> 且 <code>Offset = 0</code> 表示仅此一个分片。</p><h3 id="3-分片与组装"><a href="#3-分片与组装" class="headerlink" title="3. 分片与组装"></a>3. 分片与组装</h3><p><strong>分片在发送端或中间路由器完成，组装必须在接收端完成。</strong> 如果一个分片丢了，即使其他分片都到了，整份报文也无法重组，只能重传，增加延迟和负担。因此：网络设计时会 <strong>尽量避免分片</strong>，TCP 会在三次握手阶段协商 MSS，控制单次传输不超过 MTU（常见 1460 字节）。</p><h3 id="4-为什么不建议分片？"><a href="#4-为什么不建议分片？" class="headerlink" title="4. 为什么不建议分片？"></a>4. 为什么不建议分片？</h3><ul><li>增加路由器 CPU 开销；</li><li>增加丢包概率；</li><li>丢一个片就得重传整个报文；</li><li>对实时性要求高的通信极其不利（如视频流）。</li></ul><p><strong>所以实际网络中：分片尽量只在端系统进行，路由器最好只转发，不分片。</strong></p><h2 id="11-数据链路层简述：局域网内的一跳通信"><a href="#11-数据链路层简述：局域网内的一跳通信" class="headerlink" title="11. 数据链路层简述：局域网内的一跳通信"></a>11. 数据链路层简述：局域网内的一跳通信</h2><blockquote><p>IP 报文转发靠查路由表，逐跳找到目标网络；若目标过大，IP 层会按 MTU 进行分片，接收端再组装；而每一跳之间的实际传输靠 MAC 帧完成，MAC 只在局域网内有效。</p></blockquote><p>虽然之后会细讲，但这里要先有个框架，可以先做一个简单了解。</p><h3 id="1-主要作用"><a href="#1-主要作用" class="headerlink" title="1. 主要作用"></a>1. 主要作用</h3><p>负责 <strong>点对点或点对多点的数据传输</strong>，以 <strong>MAC 帧（Frame）</strong> 为基本传输单位，通过 <strong>MAC 地址</strong> 标识网络设备。</p><h3 id="2-通信过程（以以太网为例）"><a href="#2-通信过程（以以太网为例）" class="headerlink" title="2. 通信过程（以以太网为例）"></a>2. 通信过程（以以太网为例）</h3><p>发送方将 IP 报文封装为 MAC 帧，MAC 帧头包含：目的 MAC、源 MAC、类型字段，所有主机都能收到这个帧，只有目的 MAC 匹配的主机才会上交给上层处理。这一层只在局域网中有效，数据一旦跨路由器转发，<strong>MAC 地址必然变化</strong>。</p><h3 id="3-数据帧长度与碰撞"><a href="#3-数据帧长度与碰撞" class="headerlink" title="3. 数据帧长度与碰撞"></a>3. 数据帧长度与碰撞</h3><p>有效载荷：46–1500 字节，过短帧会触发填充，过长则被丢弃，交换机通过分隔碰撞域减少冲突。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;网络层-——-IP-协议&quot;&gt;&lt;a href=&quot;#网络层-——-IP-协议&quot; class=&quot;headerlink&quot; title=&quot;网络层 —— IP 协议&quot;&gt;&lt;/a&gt;网络层 —— IP 协议&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a</summary>
        
      
    
    
    
    <category term="Linux" scheme="https://www.minbit.top/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://www.minbit.top/tags/Linux/"/>
    
    <category term="网络" scheme="https://www.minbit.top/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>052 传输层 —— TCP（下）</title>
    <link href="https://www.minbit.top/posts/23032.html"/>
    <id>https://www.minbit.top/posts/23032.html</id>
    <published>2025-10-05T04:00:00.000Z</published>
    <updated>2025-11-15T04:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="传输层-——-TCP（下）"><a href="#传输层-——-TCP（下）" class="headerlink" title="传输层 —— TCP（下）"></a>传输层 —— TCP（下）</h1><blockquote><p><a href="https://www.cnblogs.com/xiaolincoding/p/12732052.html">30 张图解： TCP 重传、滑动窗口、流量控制、拥塞控制 | 博客园</a></p></blockquote><h2 id="1-TCP-流量控制"><a href="#1-TCP-流量控制" class="headerlink" title="1. TCP 流量控制"></a>1. TCP 流量控制</h2><h3 id="1-什么是流量控制？"><a href="#1-什么是流量控制？" class="headerlink" title="1. 什么是流量控制？"></a>1. 什么是流量控制？</h3><p>先想一个比喻：你在和朋友聊天，对方打字太快，你还没看完一句他又发十条，你就“被淹没”了。TCP 里也一样，发送方（Sender）发数据太快，而接收方（Receiver）处理不过来，就会导致：</p><ul><li>接收缓冲区溢出（数据丢失）</li><li>重传、拥塞、效率下降</li></ul><p>所以 TCP 设计了 <strong>流量控制机制（Flow Control）</strong>，让接收方告诉发送方：“我现在只能接收这么多数据，请你慢一点。”它是一种防止发送方发送数据过快，导致接收方来不及处理而造成数据丢失的机制，其核心目标是 <strong>匹配发送速率与接收能力</strong>。</p><h3 id="2-实现方式：接收窗口"><a href="#2-实现方式：接收窗口" class="headerlink" title="2. 实现方式：接收窗口"></a>2. 实现方式：接收窗口</h3><p>TCP 报文头部包含一个 <strong>16 位的窗口字段（Window Size）</strong>，表示接收方当前还能接收多少字节的数据（即接收缓冲区剩余空间）。发送方根据这个窗口大小决定最多能发送多少未确认的数据。如果接收方缓冲区快满了，它会通告一个较小的窗口；如果缓冲区空了，就通告一个较大的窗口（甚至为 0）。</p><blockquote><p><a href="https://www.ietf.org/rfc/rfc1323.txt">高性能 TCP 扩展</a></p></blockquote><p>注意：窗口大小字段最大为 65535 字节（64 KB），这对早期的低速网络还行，但在高速宽带（比如千兆）环境下，<strong>64KB 窗口太小，会严重限制吞吐量</strong>。于是 RFC 1323 引入了“窗口缩放选项（Window Scale Option，<a href="https://www.ibm.com/docs/zh/aix/7.3.0?topic=tuning-rfc1323-tunable">RFC 1323</a>）”，根据原始 RFC 1323（后来更新到 RFC 7323）在 <strong>三次握手阶段</strong>，双方可以协商一个窗口缩放因子 <code>S</code>，范围是：[0,14]，也就是说，<strong>报文里的 16 位窗口字段只是一个“基值”，实际值还要乘上缩放因子。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">实际窗口大小 = 通告窗口大小 × (<span class="number">2</span>^S)</span><br><span class="line">最大窗口 = <span class="number">65535</span> × <span class="number">2</span>^<span class="number">14</span></span><br><span class="line">          = <span class="number">65535</span> × <span class="number">16384</span></span><br><span class="line">          = <span class="number">1</span>,<span class="number">073</span>,<span class="number">725</span>,<span class="number">440</span> 字节 ≈ <span class="number">1</span> GB</span><br></pre></td></tr></table></figure><p>所以 <strong>理论上最大窗口 ≈ 1GB</strong>，但这样一来，就与 IBM、Linux 内核文档说的不一样了，这其实就是进入“<strong>理论 vs 实际实现差异</strong>”的问题：不同操作系统、内核或 TCP 栈为了性能、内存安全、兼容性，会 <strong>人为限制最大窗口</strong>，不会真的给我们用到 1GB。比如：</p><table><thead><tr><th>系统</th><th>实际可配置的最大窗口</th></tr></thead><tbody><tr><td><strong>Linux (CentOS 7)</strong></td><td>通常 ≤ 16 MB（由 <code>/proc/sys/net/core/rmem_max</code> 限制）</td></tr><tr><td><strong>Windows</strong></td><td>一般上限在几 MB</td></tr><tr><td><strong>IBM AIX</strong></td><td>文档中说最大 1 MB（是默认配置限制，不是协议上限）</td></tr></tbody></table><p>所以：RFC 是协议标准，定义了“理论上能支持到 1GB”，系统实现（比如 AIX、Linux）出于稳定性或内存限制，只允许配置到几 MB。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看TCP窗口缩放功能是否启用，输出1表示启用TCP窗口缩放（RFC 1323定义的扩展）</span></span><br><span class="line"><span class="comment"># 允许TCP接收窗口大小超过65535字节，提升高带宽长距离网络的吞吐量</span></span><br><span class="line"><span class="built_in">cat</span> /proc/sys/net/ipv4/tcp_window_scaling</span><br><span class="line">1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看系统所有socket接收缓冲区的最大大小（全局上限），单位：字节，所有socket的接收缓冲区配置不能超过此值</span></span><br><span class="line"><span class="built_in">cat</span> /proc/sys/net/core/rmem_max</span><br><span class="line">212992<span class="comment"># 当前值为212992字节（208KB）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看系统所有socket发送缓冲区的最大大小（全局上限），单位：字节，所有socket的发送缓冲区配置不能超过此值</span></span><br><span class="line"><span class="built_in">cat</span> /proc/sys/net/core/wmem_max</span><br><span class="line">212992<span class="comment"># 当前值为212992字节（208KB）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看TCP协议接收缓冲区的配置（三个值分别为最小/默认/最大），单位：字节</span></span><br><span class="line"><span class="built_in">cat</span> /proc/sys/net/ipv4/tcp_rmem</span><br><span class="line">4096873806291456</span><br><span class="line"><span class="comment"># 4096：接收缓冲区最小值（即使内存紧张也不会小于此值）</span></span><br><span class="line"><span class="comment"># 87380：接收缓冲区默认值（新建连接时的初始大小）</span></span><br><span class="line"><span class="comment"># 6291456：接收缓冲区理论最大值（实际受rmem_max限制，当前实际最大为212992）</span></span><br><span class="line"><span class="comment"># TCP 接收缓冲区的实际最大值 = min(tcp_rmem[2], rmem_max)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看TCP协议发送缓冲区的配置（三个值分别为最小/默认/最大），单位：字节</span></span><br><span class="line"><span class="built_in">cat</span> /proc/sys/net/ipv4/tcp_wmem</span><br><span class="line">4096163844194304</span><br><span class="line"><span class="comment"># 4096：发送缓冲区最小值</span></span><br><span class="line"><span class="comment"># 16384：发送缓冲区默认值</span></span><br><span class="line"><span class="comment"># 4194304：发送缓冲区理论最大值（实际受wmem_max限制，当前实际最大为212992）</span></span><br></pre></td></tr></table></figure><h2 id="2-滑动窗口"><a href="#2-滑动窗口" class="headerlink" title="2. 滑动窗口"></a>2. 滑动窗口</h2><blockquote><p><a href="https://www.bilibili.com/video/BV1sQXDYREwP/?share_source=copy_web&vd_source=872e5e3ccf44874c39edaf42e30ab0de">神奇的滑动窗口 | TCP 流量控制 | B 站</a></p></blockquote><h3 id="1-什么是滑动窗口？"><a href="#1-什么是滑动窗口？" class="headerlink" title="1. 什么是滑动窗口？"></a>1. 什么是滑动窗口？</h3><blockquote><p>这里的滑动窗口和在算法中的滑动窗口算法可以认为是一致的，如果滑动窗口算法你有所了解，那么此处很容易理解，因为原理一致！</p><p><strong>TCP 滑动窗口 &#x3D; 流量控制的核心机制，用于让发送方根据接收方的处理能力动态调整发送速率，防止“发太快、收不动”。</strong></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20251006153117547.png" alt="PixPin_2025-10-06_15-31-06"></p><p>滑动窗口是 TCP 实现 <strong>流量控制 + 高效传输</strong> 的关键机制。它允许发送方在 <strong>未收到确认的情况下</strong> 连续发送多个数据段，而不是“发送一个、等待一个”。其本质是一个“动态的发送许可”。 </p><ul><li><strong>本质</strong>：就是 TCP 为了提高传输 <strong>效率</strong> 设计的一种机制。</li><li><strong>目的</strong>：不用每发一个包就等确认，而是允许「一批包」在途，从而实现一次可以发送大量 TCP 报文。</li></ul><p>可以理解为：“发送方最多能发多少还没被确认的数据（未 ACK 的数据）。”这个“能发的范围”由 <strong>接收方</strong> 决定， 接收方通过 <code>TCP Header</code> 里的 <strong>Window 字段（窗口大小）</strong> 通知发送方，举个直观例子（假设）：</p><ul><li>接收方当前窗口大小为 <code>4096 bytes</code>。</li><li>每个数据包 <code>1024 bytes</code>。</li></ul><p>发送方就能 <strong>连续发 4 个包</strong>（4096 bytes）后，必须停下来等 ACK。 等接收方确认了第 1 个包，它的窗口“右移”，发送方又能继续发新的一个。</p><h3 id="2-滑动窗口的组成（发送方视角）"><a href="#2-滑动窗口的组成（发送方视角）" class="headerlink" title="2. 滑动窗口的组成（发送方视角）"></a>2. 滑动窗口的组成（发送方视角）</h3><p>发送窗口通常分为四部分（按序列号顺序）：</p><table><thead><tr><th><strong>区域</strong></th><th><strong>说明</strong></th><th><strong>是否占用缓冲区</strong></th></tr></thead><tbody><tr><td><strong>已发送且已确认（收到 ACK）</strong></td><td><strong>可以丢弃，窗口向前滑动</strong></td><td><strong>不再占用（可释放）</strong></td></tr><tr><td><strong>已发送但未确认（未收到 ACK）</strong></td><td><strong>正在等待 ACK</strong></td><td><strong>占用</strong></td></tr><tr><td><strong>未发送但可发送</strong></td><td><strong>在窗口内，可立即发送</strong></td><td><strong>占用（待发）</strong></td></tr><tr><td>未发送且不可发送（存在感不高，可忽略，而且是窗口之外的空间，严格来说 <strong>不属于滑动窗口本身</strong>）</td><td>超出窗口，需等待窗口滑动</td><td>占用（但被“冻结”）</td></tr></tbody></table><p>发送方的 <strong>发送窗口</strong> 是一个区间，主要分为三块：</p><ol><li><strong>已发送且已确认的数据</strong>（窗口左边，已经安全了）</li><li><strong>已发送但未确认的数据</strong>（窗口中间，在途数据）</li><li><strong>允许发送但还没发送的数据</strong>（窗口右边，可以继续发）</li></ol><blockquote><p><strong>重点：<span style="color:#FF0000;">理论上的滑动窗口大小 &#x3D; min(接收方通告窗口，拥塞窗口，发送方缓存大小)</span>，这是操作系统实际可用的发送窗口上限，包含内核资源限制；而协议标准中通常只考虑发送方当前实际使用的滑动窗口大小，<span style="color:#FF0000;">实际窗口大小 &#x3D; min（接收窗口大小，拥塞窗口大小）即 min(cwnd, rwnd)</span>。</strong></p></blockquote><h3 id="3-确认序号（ACK）的含义是什么？"><a href="#3-确认序号（ACK）的含义是什么？" class="headerlink" title="3. 确认序号（ACK）的含义是什么？"></a>3. 确认序号（ACK）的含义是什么？</h3><p>TCP 的确认序号（Acknowledgment Number）表示：“<strong>我期望收到的下一个字节的序号是 x，也就是说，x 之前的所有字节我都成功收到了。</strong>” 例如：ACK &#x3D; 1001 → 表示序号 1~1000 的字节都收到了，这是 <strong>累计确认（Cumulative ACK）</strong> 机制。</p><p><strong>允许少量 ACK 丢失吗？</strong></p><blockquote><p><strong>TCP 是可靠传输协议，ACK 丢了，接收方下次再发 ACK（累积确认）依旧能覆盖。所以只要不是连续大量丢失，就不会有问题。</strong></p></blockquote><p><strong>允许！</strong> 因为 TCP 使用累计确认：</p><ul><li>即使某个 ACK 丢了，只要后续的 ACK 到达（比如 ACK &#x3D; 2001），就说明 1~2000 都收到了。</li><li>所以前面的 ACK 丢失不影响正确性（但可能影响性能，如触发重传）。</li><li><strong>普通数据 ACK 丢失通常无害，但携带窗口更新的 ACK 丢失可能影响性能。</strong></li></ul><h3 id="4-滑动窗口如何“向右移动”？移动时大小会变吗？"><a href="#4-滑动窗口如何“向右移动”？移动时大小会变吗？" class="headerlink" title="4. 滑动窗口如何“向右移动”？移动时大小会变吗？"></a>4. 滑动窗口如何“向右移动”？移动时大小会变吗？</h3><h4 id="1-向右移动："><a href="#1-向右移动：" class="headerlink" title="1. 向右移动："></a>1. 向右移动：</h4><ol><li>当收到 ACK（比如 ACK &#x3D; x），说明 x 之前的数据都确认了，窗口整体向右滑动。</li><li>发送窗口的 <strong>左边界</strong> 就移动到 x，释放已确认的数据空间，这意味着一些数据已经确认，不用再管了。</li><li>如果接收方缓冲区有空闲，还会在 ACK 中携带新的接收窗口大小，可能让 <strong>右边界也右移</strong>（窗口变大）。</li></ol><h4 id="2-窗口大小会变化吗？"><a href="#2-窗口大小会变化吗？" class="headerlink" title="2. 窗口大小会变化吗？"></a>2. 窗口大小会变化吗？</h4><p><strong>会！而且经常变！</strong></p><ul><li><strong>变大</strong>：接收方处理了数据，缓冲区空出 → 接收窗口大小增大 → 窗口右边界右移。</li><li><strong>变小</strong>：接收方缓冲区快满了 → 接收窗口大小减小 → 窗口右边界左移（但左边界不能左移！）。</li><li><strong>变为 0</strong>：接收方缓冲区完全满 → 接收窗口大小 &#x3D; 0 → 窗口大小为 0，发送方暂停发送（进入“零窗口探测”状态）。</li></ul><blockquote><p>  <strong>注意：窗口左边界只能右移或不动，不能左移（因为已确认的数据不能“反悔”）。</strong> </p></blockquote><h3 id="5-滑动窗口会“越界”发送缓冲区吗？"><a href="#5-滑动窗口会“越界”发送缓冲区吗？" class="headerlink" title="5. 滑动窗口会“越界”发送缓冲区吗？"></a>5. 滑动窗口会“越界”发送缓冲区吗？</h3><blockquote><p><strong>TCP 采用了类似环状算法，始终保证滑动窗口不会越界！</strong></p></blockquote><p><strong>不会。</strong></p><ul><li>滑动窗口的右边界（即“可发送的最大序号”）<strong>永远不会超过发送缓冲区的容量</strong>。</li><li>如果应用程序写入的数据太多，而窗口太小（比如接收窗口大小 &#x3D; 0），<code>send()</code> 系统调用会 <strong>阻塞</strong>（或返回 EAGAIN，如果是非阻塞 socket），直到窗口有空间。</li><li>因此，<strong>滑动窗口始终被限制在发送缓冲区内</strong>，不会越界。</li></ul><h3 id="6-流量控制是通过滑动窗口实现的吗？"><a href="#6-流量控制是通过滑动窗口实现的吗？" class="headerlink" title="6. 流量控制是通过滑动窗口实现的吗？"></a>6. 流量控制是通过滑动窗口实现的吗？</h3><p><strong>是的！流量控制的核心就是滑动窗口！</strong></p><p><strong>流量控制的本质</strong>：防止发送方发得太快，把接收方“撑爆”。<strong>实现方式</strong>：接收方通过 TCP 报文头中的 <strong>Window 字段（即接收窗口大小）</strong> 告诉发送方自己还能收多少。发送方据此 <strong>动态调整滑动窗口的大小</strong>。当 接收窗口大小 &#x3D; 0 时，发送方停止发送（除零窗口探测包外）。</p><blockquote><p>  <strong>滑动窗口是流量控制的执行机制，接收窗口大小是流量控制的控制信号。</strong> </p></blockquote><h3 id="7-如果发生丢包，滑动窗口怎么处理？"><a href="#7-如果发生丢包，滑动窗口怎么处理？" class="headerlink" title="7. 如果发生丢包，滑动窗口怎么处理？"></a>7. 如果发生丢包，滑动窗口怎么处理？</h3><p>丢包主要影响 <strong>拥塞控制</strong>，但也会间接影响滑动窗口：</p><ol><li><strong>发送方发现丢包</strong>（通过超时或重复 ACK）：<ul><li>会触发重传（重发未确认的数据）。</li><li>同时 <strong>减小拥塞窗口</strong>（比如减半）→ 导致滑动窗口变小。</li></ul></li><li><strong>滑动窗口本身不会“回退”</strong>：<ul><li>已确认的部分不会撤销。</li><li>未确认的部分继续等待 ACK 或重传。</li><li>窗口左边界不变，右边界可能因 <strong>拥塞窗口</strong> 减小而左移（窗口缩小）。</li></ul></li><li><strong>接收方视角</strong>：<ul><li>如果中间丢包，接收方会重复发送 <strong>最后一个正确 ACK</strong>（比如一直 ACK &#x3D; 1001）。</li><li>发送方收到 3 个重复 ACK 后，会快速重传序号 1001 开始的数据（快速重传机制）。</li></ul></li></ol><blockquote><p>  <strong>重点：滑动窗口只向前滑（左边界不回退），丢包通过重传 + 调整拥塞窗口大小来处理。</strong> </p></blockquote><h2 id="3-拥塞控制"><a href="#3-拥塞控制" class="headerlink" title="3. 拥塞控制"></a>3. 拥塞控制</h2><h3 id="1-什么是拥塞控制？"><a href="#1-什么是拥塞控制？" class="headerlink" title="1. 什么是拥塞控制？"></a>1. 什么是拥塞控制？</h3><p><strong>拥塞控制</strong> 是 TCP 协议中的一种 <strong>机制</strong>，用于 <strong>防止发送方因发送数据过快而导致网络过载（网络中的路由器或链路被过多数据淹没&#x2F;拥塞）</strong>，从而避免大量丢包、延迟剧增甚至网络崩溃。它的目标是：既要尽可能高效利用带宽，又要避免让网络“堵车”。</p><blockquote><p>关键点：  </p><ul><li>流量控制 → 保护 <strong>接收方</strong>（别发太快，我处理不过来），防止「<strong>发送方</strong>」把「<strong>接收方</strong>」撑爆。</li><li>拥塞控制 → 保护 <strong>整个网络</strong>（别发太多，网络会堵），防止「<strong>所有发送方</strong>」把「<strong>网络</strong>」堵死。</li></ul></blockquote><h3 id="2-为什么要有拥塞控制？"><a href="#2-为什么要有拥塞控制？" class="headerlink" title="2. 为什么要有拥塞控制？"></a>2. 为什么要有拥塞控制？</h3><blockquote><p><strong>如果所有主机都“无脑狂发数据”，网络会出现：路由器缓存溢出（包被丢弃）、延迟飙升、重传风暴（越丢越发），最终导致整个网络吞吐量下降，也就是所谓的“网络崩溃”。</strong></p></blockquote><ol><li><strong>网络资源有限</strong>：网络资源本质还是 <strong>共享资源</strong>，路由器缓存、带宽都是有限的。</li><li><strong>无控制的后果</strong>：<ul><li>多个发送方同时高速发包 → 路由器缓存溢出 → <strong>大量丢包</strong>。</li><li>丢包触发重传 → 更多数据进入网络 → <strong>恶性循环（拥塞崩溃）</strong>。</li></ul></li></ol><blockquote><p><strong>因此，TCP 必须“感知”网络状态，并 自适应调整发送速率。</strong></p></blockquote><h3 id="3-如何判断网络是否拥塞？"><a href="#3-如何判断网络是否拥塞？" class="headerlink" title="3. 如何判断网络是否拥塞？"></a>3. 如何判断网络是否拥塞？</h3><p>TCP <strong>无法直接看到网络状态</strong>，只能通过 <strong>间接信号</strong> 推断拥塞：</p><table><thead><tr><th>拥塞信号</th><th>说明</th></tr></thead><tbody><tr><td><strong>超时（Timeout）</strong></td><td>数据包长时间未收到 ACK → 很可能已丢弃（严重拥塞）</td></tr><tr><td><strong>重复 ACK</strong></td><td>接收方收到乱序包，反复确认最后一个正确序号（如连续 3 次 ACK &#x3D; 1001）→ 中间包可能丢失（轻度拥塞）</td></tr></tbody></table><blockquote><p>这两个事件是触发拥塞控制算法动作的关键“警报”。</p></blockquote><h3 id="4-拥塞控制的核心机制与关键概念"><a href="#4-拥塞控制的核心机制与关键概念" class="headerlink" title="4. 拥塞控制的核心机制与关键概念"></a>4. 拥塞控制的核心机制与关键概念</h3><blockquote><p>在热恋中，人总是“小心试探”——</p><ul><li>一开始不敢太快靠近（<strong>慢启动</strong>）。</li><li>发现对方反应良好，就逐步增加接触（<strong>拥塞避免&#x2F;快增长</strong>）。</li><li>如果对方突然冷淡（<strong>丢包&#x2F;超时</strong>），就立刻收敛，变得保守（<strong>快恢复&#x2F;慢启动重启</strong>）。</li></ul><p>TCP 也是这样：它“试探”网络承受能力，逐渐增加速度，一旦发现不对劲（丢包），马上退回去，避免网络“受伤”。</p></blockquote><p>TCP 拥塞控制通过一个 <strong>拥塞窗口</strong> 来限制发送速率。</p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20251006170038145.png" alt="PixPin_2025-10-06_17-00-35"></p><table><thead><tr><th>阶段&#x2F;策略</th><th>触发条件</th><th>cwnd 增长方式</th><th>说明</th></tr></thead><tbody><tr><td>慢启动</td><td>初始阶段或严重拥塞</td><td>每 ACK cwnd × 2</td><td>指数增长</td></tr><tr><td>拥塞避免</td><td>cwnd ≥ ssthresh</td><td>每 RTT cwnd + 1 MSS</td><td>线性增长</td></tr><tr><td>快重传</td><td>3 个重复 ACK</td><td>立即重传丢失包</td><td>不等超时</td></tr><tr><td>快恢复</td><td>轻微拥塞</td><td>cwnd &#x3D; ssthresh，然后线性增长</td><td>恢复阶段</td></tr></tbody></table><h4 id="1-慢启动"><a href="#1-慢启动" class="headerlink" title="1. 慢启动"></a>1. 慢启动</h4><blockquote><p>就像“刚恋爱，试探性地快快加深感情”。</p></blockquote><ul><li><strong>目的</strong>：连接刚建立时，不知道网络承载能力，先“试探性”发送。</li><li><strong>规则</strong>：<ul><li>传统初始拥塞窗口大小 &#x3D; 1 MSS（Maximum Segment Size，通常 1460 字节）。注：现代 TCP 实现（如 RFC 6928）的初始拥塞窗口更大，通常是 10 个 MSS。</li><li>在慢启动阶段，每经过一个 RTT，cwnd 大致翻倍（<strong>指数增长</strong>）。</li><li>一直到达到慢启动阈值（ssthresh）。</li></ul></li><li><strong>例子</strong>：<ul><li>第 1 轮：发 1 个包 → 收 1 个 ACK → cwnd &#x3D; 2</li><li>第 2 轮：发 2 个包 → 收 2 个 ACK → cwnd &#x3D; 4</li><li>第 3 轮：发 4 个包 → 收 4 个 ACK → cwnd &#x3D; 8</li><li>……</li></ul></li></ul><blockquote><p><strong>虽叫“慢启动”，但增长其实很快（指数级）！</strong> 小故事：一个农名欠地主粮食，于是地主给出 2 个选择，一个是慢慢还，一个是第一天还 1 粒米，第二天 2 粒，以此类推……农民毫不犹豫的选择了第 2 个选择，让他没想到的是最开始的日子还能还的上，后来指数级增长的粮食竟压得他叫苦不迭……</p></blockquote><h4 id="2-拥塞避免"><a href="#2-拥塞避免" class="headerlink" title="2. 拥塞避免"></a>2. 拥塞避免</h4><blockquote><p>稳定关系后，不再激进增加，逐渐探索极限。</p></blockquote><ul><li><strong>何时进入</strong>：当拥塞窗口大小大于等于慢启动阈值时（cwnd ≥ ssthresh）。</li><li><strong>规则</strong>：<ul><li>每收到一个 ACK，cwnd +&#x3D; 1&#x2F;cwnd → <strong>每轮 RTT，拥塞窗口只增加 1 MSS（线性增长）</strong></li></ul></li><li><strong>目的</strong>：避免指数增长导致突然拥塞。</li></ul><h4 id="3-快重传"><a href="#3-快重传" class="headerlink" title="3. 快重传"></a>3. 快重传</h4><ul><li><strong>触发条件</strong>：收到 <strong>3 个重复 ACK</strong>，就认为某个包丢了。</li><li><strong>动作</strong>：立即重传丢失的包，<strong>不等超时</strong>。</li><li><strong>优点</strong>：大幅减少重传延迟。</li></ul><h4 id="4-快恢复"><a href="#4-快恢复" class="headerlink" title="4. 快恢复"></a>4. 快恢复</h4><blockquote><p>恋爱里遇到小矛盾，退一步，再慢慢靠近。</p></blockquote><ul><li><strong>触发条件</strong>：快重传之后，当检测到轻微拥塞时，不用回到最初的慢启动。</li><li><strong>动作</strong>：将慢启动阈值设为当前拥塞窗口大小的一半（把 ssthresh 降到 cwnd&#x2F;2，然后线性增长）。</li><li><strong>目的</strong>：避免因单个丢包就“从头开始”，保持较高吞吐。</li></ul><h3 id="5-如何解决网络拥塞问题？"><a href="#5-如何解决网络拥塞问题？" class="headerlink" title="5. 如何解决网络拥塞问题？"></a>5. 如何解决网络拥塞问题？</h3><p>TCP 的解决思路就是「<strong>自我降速 + 逐步恢复</strong>」：</p><ol><li><strong>动态调整 cwnd（拥塞窗口）。</strong></li><li><strong>根据 ACK 反馈推断网络状态。</strong></li><li><strong>丢包时快速响应，防止恶化。</strong></li><li><strong>利用慢启动和线性增长实现自适应调节。</strong></li></ol><p>现代系统还在此基础上发展出了许多变种算法，如：</p><ul><li>Reno（经典）</li><li>NewReno（改进快恢复）</li><li>CUBIC（Linux 默认）</li><li>BBR（基于带宽估计，Google 提出）</li></ul><h2 id="4-流量控制-VS-拥塞窗口"><a href="#4-流量控制-VS-拥塞窗口" class="headerlink" title="4. 流量控制 VS 拥塞窗口"></a>4. 流量控制 VS 拥塞窗口</h2><table><thead><tr><th align="left">对比维度</th><th align="left">流量控制</th><th align="left">拥塞控制</th></tr></thead><tbody><tr><td align="left">控制目标</td><td align="left">防止 <strong>接收方</strong> 缓冲区溢出</td><td align="left">防止 <strong>网络</strong> 整体拥塞</td></tr><tr><td align="left">控制范围</td><td align="left">端到端（发送方与接收方之间）</td><td align="left">全局（整个网络路径）</td></tr><tr><td align="left">触发因素</td><td align="left">接收方缓冲区容量</td><td align="left">网络路由器队列溢出、分组丢失</td></tr><tr><td align="left">关键参数</td><td align="left">接收窗口 (rwnd)</td><td align="left">拥塞窗口 (cwnd)、阈值 (ssthresh)</td></tr><tr><td align="left">实现方式</td><td align="left">接收方反馈窗口大小</td><td align="left">发送方主动调整发送速率</td></tr><tr><td align="left">典型算法</td><td align="left">滑动窗口协议</td><td align="left">慢启动、拥塞避免、快重传、快恢复</td></tr><tr><td align="left">窗口增长</td><td align="left">根据接收方反馈动态调整</td><td align="left">指数增长 → 线性增长 → 快速下降</td></tr><tr><td align="left">检测机制</td><td align="left">零窗口检测</td><td align="left">超时重传、重复 ACK 检测</td></tr></tbody></table><hr><blockquote><p><strong>TCP 是全双工通信（双方都能同时发数据和 ACK）。但发送 ACK（确认号）本身也要占用网络资源，如果对方每发一个小包，我就立刻回一个 ACK，就会增加很多小包通信 → 影响效率。所以：TCP 引入了 延迟应答（Delayed ACK）和 捎带应答（Piggyback ACK）来优化。</strong></p></blockquote><h2 id="5-延迟应答"><a href="#5-延迟应答" class="headerlink" title="5. 延迟应答"></a>5. 延迟应答</h2><h3 id="1-类比场景"><a href="#1-类比场景" class="headerlink" title="1. 类比场景"></a>1. 类比场景</h3><ol><li>A：你吃饭了吗？（B 听到了，但暂时没回——他在想自己是不是也要说点别的）。</li><li>几秒后：B：吃了（这句话既是回答，也是“我听到你说话了”的信号）。</li><li>如果 B 想了半天没要说的，就会单独说一句：B：听到了！</li></ol><h3 id="2-对应-TCP-含义"><a href="#2-对应-TCP-含义" class="headerlink" title="2. 对应 TCP 含义"></a>2. 对应 TCP 含义</h3><ol><li>TCP 收到数据后，不急着立刻回 ACK，而是 <strong>稍微等一下</strong>，看看自己是否要发送数据回去。</li><li>如果这段时间内有要发的数据 → 就在数据包里“顺便带上 ACK”。</li><li>如果一直没有新数据 → 到了延迟时间（比如 40ms）再单独发 ACK。</li></ol><h3 id="3-作用"><a href="#3-作用" class="headerlink" title="3. 作用"></a>3. 作用</h3><ul><li>减少纯 ACK 包数量，降低网络负担；</li><li>提高吞吐率，让数据传输更高效。</li></ul><h2 id="6-捎带应答"><a href="#6-捎带应答" class="headerlink" title="6. 捎带应答"></a>6. 捎带应答</h2><h3 id="1-类比场景-1"><a href="#1-类比场景-1" class="headerlink" title="1. 类比场景"></a>1. 类比场景</h3><ol><li>A：吃饭了吗？</li><li>B：吃了。</li></ol><p>这里 B 没有说「听到你说话了」，但实际上他回答了问题，<strong>自然就说明他听到了</strong>。这就是「捎带」：在自己的内容里顺便带上确认。</p><h3 id="2-对应-TCP-含义-1"><a href="#2-对应-TCP-含义-1" class="headerlink" title="2. 对应 TCP 含义"></a>2. 对应 TCP 含义</h3><p>当 TCP 双方都在发数据时，接收方就 <strong>在自己的数据包中附上 ACK 确认号</strong>，告诉对方“上一个包我收到了”，不需要单独发一个 ACK 包。</p><h3 id="3-作用-1"><a href="#3-作用-1" class="headerlink" title="3. 作用"></a>3. 作用</h3><ul><li>减少包的数量（因为数据和确认合并成一个包）。</li><li>提高通信效率，尤其在双向传输时。</li></ul><h2 id="7-延迟应答-VS-捎带应答"><a href="#7-延迟应答-VS-捎带应答" class="headerlink" title="7. 延迟应答 VS 捎带应答"></a>7. 延迟应答 VS 捎带应答</h2><blockquote><ul><li>延迟应答：<strong>等一等再回，看看能不能顺便带上 ACK。</strong> </li><li>捎带应答：<strong>既然要说话，那就顺便说“我听到了”。</strong></li></ul></blockquote><table><thead><tr><th>项目</th><th>延迟应答</th><th>捎带应答</th></tr></thead><tbody><tr><td>类比</td><td>B 等一等，看要不要顺便回</td><td>B 在自己的回答中顺便确认</td></tr><tr><td>触发条件</td><td>收到数据，但无数据要发</td><td>收到数据且有数据要发</td></tr><tr><td>是否等</td><td>会延迟一小段时间</td><td>不延迟，直接发</td></tr><tr><td>是否双向通信</td><td>不一定</td><td>必须双向都有数据</td></tr><tr><td>目的</td><td>减少无意义的 ACK 包</td><td>合并数据和 ACK，节省一次发包</td></tr><tr><td>典型场景</td><td>单向传输（如文件下载）</td><td>双向交互（如 Telnet、HTTP）</td></tr></tbody></table><hr><h2 id="8-面向字节流"><a href="#8-面向字节流" class="headerlink" title="8. 面向字节流"></a>8. 面向字节流</h2><h3 id="1-面向字节流的本质"><a href="#1-面向字节流的本质" class="headerlink" title="1. 面向字节流的本质"></a>1. 面向字节流的本质</h3><p>TCP 是 <strong>「面向字节流」</strong> 的协议，这句话的意思是：<strong>TCP 只看连续的字节，不关心消息边界。</strong> 也就是说，TCP 眼中没有“包”或“消息”的概念，它只负责：把发送方写入的那一串字节完整、有序地交给接收方，确保不丢、不乱、不错。<strong>所以无论写几次、读几次，对 TCP 来说都没区别——它只是管「流动的字节」。</strong></p><h3 id="2-从发送到接收的完整过程"><a href="#2-从发送到接收的完整过程" class="headerlink" title="2. 从发送到接收的完整过程"></a>2. 从发送到接收的完整过程</h3><blockquote><p><strong>应用层调用 <code>write()</code> → 用户态数据拷贝到内核态的 TCP 发送缓冲区 → TCP 协议栈按当前网络状况和拥塞窗口决定什么时候、按多大尺寸分段发送 → 网络传输 → 对端的 TCP 收到后，先把数据放入内核态的 TCP 接收缓冲区 → 对端应用层调用 <code>read()</code> 从内核缓冲区中按需读取任意长度的字节数据 → 由应用层自己根据协议格式解析出完整消息边界。这就是 TCP 面向字节流的本质：提供可靠、有序的字节传输通道，但把“语义”交给上层。</strong></p></blockquote><p>我们用一个简化图来还原整个流程：</p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20251006221632301.png" alt="PixPin_2025-10-06_22-16-21"></p><p>现在来讲讲每一步背后的逻辑：</p><h4 id="1-应用层调用-write"><a href="#1-应用层调用-write" class="headerlink" title="1. 应用层调用 write()"></a>1. 应用层调用 <code>write()</code></h4><p>应用层产生数据转成字节拷贝进 <strong>内核的发送缓冲区</strong>。这时 <code>write()</code> 就可以返回了，<strong>并不意味着数据发出去了</strong>，只是进入了内核队列。</p><h4 id="2-TCP-自动分片与聚合"><a href="#2-TCP-自动分片与聚合" class="headerlink" title="2. TCP 自动分片与聚合"></a>2. TCP 自动分片与聚合</h4><p>发送缓冲区中的数据由 TCP 协议控制发送：</p><ul><li>如果太大，会拆成多个 TCP 段；</li><li>如果太小，TCP 可能暂时不发（比如启用了 Nagle 算法），等待更多数据合并成一个包再发。</li></ul><p>这一步是 <strong>TCP 的“面向字节流”特性在发送端的体现</strong>：它不管我们一次 write 写多少字节，只管按自己的节奏连续发字节。</p><h4 id="3-网络传输与确认"><a href="#3-网络传输与确认" class="headerlink" title="3. 网络传输与确认"></a>3. 网络传输与确认</h4><p>TCP 在传输过程中做三件事：</p><ol><li>维护序号（保证有序）。</li><li>超时重传（保证可靠）。</li><li>滑动窗口（控制流量）。</li></ol><p>丢了会重发，乱序会重排。</p><h4 id="4-接收方重组数据流"><a href="#4-接收方重组数据流" class="headerlink" title="4. 接收方重组数据流"></a>4. 接收方重组数据流</h4><p>数据到达接收方内核后，TCP 会根据序号：把乱序的包重新排序，确认收到的字节，把连续的字节流写入 <strong>接收缓冲区</strong>。</p><h4 id="5-应用层调用-read"><a href="#5-应用层调用-read" class="headerlink" title="5. 应用层调用 read()"></a>5. 应用层调用 <code>read()</code></h4><p>应用层从接收缓冲区中 <strong>按自己想要的长度</strong> 去读数据。读多少、读几次都行。TCP 不关心我们每次 read 的“分界”，它只负责保证我们收到的字节顺序正确。</p><h4 id="6-举个例子"><a href="#6-举个例子" class="headerlink" title="6. 举个例子"></a>6. 举个例子</h4><p>用 <code>write(fd, &quot;Hello&quot;, 5)</code> 写 5 次，每次 1 字节：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">write</span>(fd, <span class="string">&quot;H&quot;</span>, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">write</span>(fd, <span class="string">&quot;e&quot;</span>, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">write</span>(fd, <span class="string">&quot;l&quot;</span>, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">write</span>(fd, <span class="string">&quot;l&quot;</span>, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">write</span>(fd, <span class="string">&quot;o&quot;</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>和一次写 5 字节：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">write</span>(fd, <span class="string">&quot;Hello&quot;</span>, <span class="number">5</span>);</span><br></pre></td></tr></table></figure><p><strong>这对 TCP 来说完全一样</strong>！它只看到 5 个连续字节：<code>H e l l o</code>。</p><p>同样，接收方可以：</p><ul><li>一次 <code>read(buf, 5)</code> 读完；</li><li>或 5 次 <code>read(buf, 1)</code> 逐字节读；</li><li>甚至一次 <code>read(buf, 100)</code> 把这 5 字节和其他后续数据一起读进来。</li></ul><blockquote><p>  <strong>TCP 不保证“写多少次，就读多少次”；也不保证“每次写的边界 &#x3D; 每次读的边界”。 像水管输水，不管你倒一桶还是倒十桶，水流不断过去。水分段传输，但水的“总量”是靠序号控制的，不需要每次标记“这一桶多大”。</strong></p></blockquote><h2 id="9-粘包问题"><a href="#9-粘包问题" class="headerlink" title="9. 粘包问题"></a>9. 粘包问题</h2><h3 id="1-什么是粘包问题？"><a href="#1-什么是粘包问题？" class="headerlink" title="1. 什么是粘包问题？"></a>1. 什么是粘包问题？</h3><blockquote><p>这就好像小时候家里蒸包子，出现从蒸笼里拿一个包子，结果连带一个或者多个包子一并被拿起一样。</p></blockquote><p>TCP 粘包是因为 TCP 是面向字节流的协议，不保留消息边界，导致多个应用层消息被合并成一个 TCP 段传输。其根本就是 <strong>TCP 是面向字节流的协议</strong>，它只保证字节的顺序和可靠（不丢不重）传输，不关心一条消息从哪里开始、到哪里结束。举个例子：假设客户端连续发了两条消息：”hello”、”world”，底层 TCP 实际发送过程可能是：</p><ol><li>一起发出去 → 收方一次 read() 得到 “helloworld”</li><li>拆成两次发 → 收方第一次 read() 得到 “hell”，第二次得到 “oworld”</li></ol><p>无论哪种情况，对 TCP 来说都没错，它完成了“字节传输”。但对应用层来说，就糊涂了：到底哪 5 个字节是 “hello”，哪 5 个字节是 “world” 呢？这就是 <strong>粘包&#x2F;拆包问题</strong>。</p><blockquote><p>注意：严格来说，“粘包”是 <strong>应用层术语</strong>，TCP 本身没有“包”的概念（它是字节流），所以更准确的说法是 <strong>“消息边界丢失”</strong> 或 <strong>“应用层消息粘连”</strong>。 </p></blockquote><h3 id="2-为什么会发生粘包？"><a href="#2-为什么会发生粘包？" class="headerlink" title="2. 为什么会发生粘包？"></a>2. 为什么会发生粘包？</h3><p>主要有两个原因：</p><ol><li><strong>TCP 是流式协议</strong> —— 没有消息边界。</li><li><strong>发送端的优化机制</strong>：TCP 可能把多次 <code>write()</code> 的小数据包合并成一个更大的包再发送（比如受 <strong>Nagle 算法</strong> 影响）。</li></ol><blockquote><p>  比喻：连发两封信，TCP 相当于觉得信太小，顺手把它们塞进一个信封寄了出去。收信人收到一封信里两张纸，就要自己判断哪一张属于哪一封。</p></blockquote><h3 id="3-UDP-会不会有粘包问题？"><a href="#3-UDP-会不会有粘包问题？" class="headerlink" title="3. UDP 会不会有粘包问题？"></a>3. UDP 会不会有粘包问题？</h3><p><strong>不会。</strong> 因为：UDP 是 <strong>面向报文</strong> 的，每次 <code>sendto()</code> 发出的数据就是一个独立的报文，接收方 <code>recvfrom()</code> 一次只能收到一个完整的报文，如果太大，UDP 直接丢（不会拆分合并）。所以 UDP 可能会 <strong>丢包</strong>，但 <strong>不会粘包</strong>。</p><h3 id="4-解决粘包的四种典型方案（应用层协议）"><a href="#4-解决粘包的四种典型方案（应用层协议）" class="headerlink" title="4. 解决粘包的四种典型方案（应用层协议）"></a>4. 解决粘包的四种典型方案（应用层协议）</h3><table><thead><tr><th>方案类型</th><th>描述</th><th>优点</th><th>缺点</th><th>常见场景</th></tr></thead><tbody><tr><td><strong>1. 定长报文</strong></td><td>每个消息的长度是固定的，比如每条 128 字节。</td><td>实现最简单，无需解析。</td><td>浪费带宽，不适合变长内容。</td><td>心跳包、状态同步。</td></tr><tr><td><strong>2. 特殊字符分隔</strong></td><td>每条消息结尾加一个独特分隔符，比如 <code>\n</code>、<code>\r\n</code>、<code>#</code> 等。</td><td>简单直观，易调试。</td><td>若数据本身可能包含该字符，就要转义或转码。</td><td>文本协议：HTTP（<code>\r\n\r\n</code>）、Redis（<code>\r\n</code>）、FTP。</td></tr><tr><td><strong>3. 定长报头 + 描述字段（自描述长度）</strong></td><td>报头中包含“消息体长度”，先读报头，再按长度读消息体。</td><td>高通用性，可支持任意变长数据。</td><td>需要两阶段解析（读头再读体）。</td><td>二进制协议、RPC 通信、游戏服务器。</td></tr><tr><td><strong>4. 自描述字段 + 特殊字符</strong></td><td>报头带长度字段，报尾再加结束符；双重保险。</td><td>边界更安全、健壮。</td><td>报文略复杂。</td><td>通信要求高可靠性时（如金融系统）。</td></tr></tbody></table><p>举个例子（第 3 种最常用），比如我们定义协议格式：<code>| 报头：4字节消息体长度 | 报体：消息数据 |</code>，假设发两条消息：”0005hello” 和 “0005world”，接收方解析逻辑：</p><ol><li>先读 4 字节（0005） → 得知消息长度为 5。</li><li>再读 5 字节 → “hello”。</li><li>重复上述步骤 → “world”。</li></ol><p>这样即使 TCP 把两条粘一起了，也能正确拆包。</p><h3 id="5-小结（可直接答面试）"><a href="#5-小结（可直接答面试）" class="headerlink" title="5. 小结（可直接答面试）"></a>5. 小结（可直接答面试）</h3><blockquote><p>  粘包是因为 TCP 是字节流，没有边界概念，所以我们要在 <strong>用户层定义应用协议</strong> 划分消息。常见方案包括：</p><ol><li>固定长度；</li><li>特殊分隔符；</li><li>定长报头 + 长度字段（最通用）；</li><li>长度字段 + 分隔符（更健壮）。</li></ol><p>  UDP 不会粘包，因为它是面向报文的。</p></blockquote><h2 id="10-TCP-异常情况"><a href="#10-TCP-异常情况" class="headerlink" title="10. TCP 异常情况"></a>10. TCP 异常情况</h2><h3 id="1-进程终止（正常退出或被-kill）"><a href="#1-进程终止（正常退出或被-kill）" class="headerlink" title="1. 进程终止（正常退出或被 kill）"></a>1. 进程终止（正常退出或被 kill）</h3><p><strong><span style="color:#FF0000;">TCP 连接会正常断开（四次挥手）</span></strong>，原理：当进程调用 <code>exit()</code>、<code>_exit()</code> 或被 <code>kill -9</code> 终止时，<strong>内核会自动关闭该进程打开的所有文件描述符</strong>，包括 socket，关闭 socket 时，内核 TCP 协议栈会：</p><ol><li>发送 <strong>FIN</strong> 报文（表示“我不会再发数据了”）。</li><li>进入 <strong>FIN-WAIT-1</strong> 状态。</li><li>后续完成标准的 <strong>四次挥手</strong> 流程。</li></ol><blockquote><p>即使进程是被 <code>kill -9</code> 强制杀死，<strong>内核仍会清理其资源并发送 FIN</strong>（因为 socket 是内核对象，进程只是持有 fd）。</p></blockquote><p>对方表现：对端收到 FIN 后，<code>read()</code> 返回 0（表示对方关闭连接），应用可正常感知连接关闭，做清理工作。注意：</p><ul><li>如果进程退出前有未发送完的数据，内核会尝试发送（取决于 SO_LINGER 设置）。</li><li>默认情况下，内核会尽力完成挥手，<strong>连接是“优雅关闭”的</strong>。</li></ul><h3 id="2-机器重启（操作系统重启）"><a href="#2-机器重启（操作系统重启）" class="headerlink" title="2. 机器重启（操作系统重启）"></a>2. 机器重启（操作系统重启）</h3><p><strong><span style="color:#FF0000;">所有 TCP 连接会被强制中断，但过程分两步</span></strong>，原理：</p><ol><li><p><strong>关机阶段</strong>：</p><ul><li>系统 shutdown 时，会向所有进程发送 SIGTERM，然后 SIGKILL。</li><li>内核会尝试关闭所有 socket，<strong>理想情况下会发送 FIN</strong>。</li><li>但如果关机太快，可能来不及发 FIN。</li></ul></li><li><p><strong>重启后</strong>：</p><ul><li>所有旧连接的 socket 已被销毁。</li><li>本机 TCP 状态机重置。</li><li><strong>对端仍认为连接存在</strong>（因为没收到 FIN 或 RST）。</li></ul></li></ol><p>关键问题：<strong>对端无法立即感知连接已断！</strong></p><ul><li>对端继续发数据 → 本机收到后，发现无对应连接 → 回 <strong>RST（复位）</strong>。</li><li>对端收到 RST → 知道连接已失效，<code>write()</code> 会触发 <strong>SIGPIPE</strong> 或返回 <strong>ECONNRESET</strong>。</li></ul><blockquote><p><a href="https://zhuanlan.zhihu.com/p/670726420">TCP 保活机制详解（KeepAlive）| 知乎</a></p><p>但如果对端不发数据，它可能 <strong>长时间不知道连接已断</strong>（直到保活探测或应用超时）。</p></blockquote><p>解决方案建议：</p><ul><li>应用层实现 <strong>心跳机制</strong>（定期 ping&#x2F;pong）。</li><li>启用 <strong><a href="https://tldp.org/HOWTO/TCP-Keepalive-HOWTO/overview.html">TCP Keep-Alive</a></strong>。</li></ul><blockquote><p><a href="https://blog.csdn.net/pmt123456/article/details/58233999">TCP 长连接与短连接、心跳机制 | CSDN</a></p><p><a href="https://www.bilibili.com/video/BV1uF411V7WH/?share_source=copy_web&vd_source=872e5e3ccf44874c39edaf42e30ab0de">0407.TCP 长连接心跳机制的实现 | B 站</a></p></blockquote><h3 id="3-机器掉电-网线断开（非正常断连）"><a href="#3-机器掉电-网线断开（非正常断连）" class="headerlink" title="3. 机器掉电 &#x2F; 网线断开（非正常断连）"></a>3. 机器掉电 &#x2F; 网线断开（非正常断连）</h3><p><strong><span style="color:#FF0000;">连接“静默失效”——双方都无法立即感知！</span></strong>，原理：本机突然断电或网线拔掉 → <strong>无法发送任何 TCP 报文（包括 FIN、RST）</strong>，对端：仍认为连接正常，若继续发数据 → 数据包到达对方（但对方已关机）→ <strong>无 ACK 返回</strong>，经过多次重传超时后 → <code>write()</code> 返回 <strong>ETIMEDOUT</strong>，若一直不发数据 → <strong>永远不知道连接已断！</strong></p><blockquote><p>这就是所谓的 <strong>“半开连接”</strong> —— 一方已断，另一方不知情。</p></blockquote><p><strong>默认超时时间有多长？</strong> Linux 默认 TCP 重传约 <strong>15 次</strong>，总超时可达 <strong>9~13 分钟</strong>！在此期间，连接“看似正常”，实则已失效。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看重传次数和间隔（单位：秒）</span></span><br><span class="line"><span class="built_in">cat</span> /proc/sys/net/ipv4/tcp_retries2    <span class="comment"># 通常为 15</span></span><br></pre></td></tr></table></figure><h3 id="4-小结"><a href="#4-小结" class="headerlink" title="4. 小结"></a>4. 小结</h3><table><thead><tr><th>异常场景</th><th>本机能否发 FIN&#x2F;RST？</th><th>对端能否立即感知？</th><th>是否会自动断开</th><th>连接如何关闭</th><th>建议应对措施</th></tr></thead><tbody><tr><td><strong>进程终止</strong></td><td>✅ 能（发 FIN）</td><td>✅ 能（收到 FIN）</td><td>✅ 正常断开</td><td>正常四次挥手</td><td>无需特殊处理</td></tr><tr><td><strong>机器重启</strong></td><td>⚠️ 可能来不及发</td><td>❌ 不能（除非对端发数据）</td><td>❌ 不一定</td><td>对端收到 RST</td><td>启用 Keep-Alive 或心跳</td></tr><tr><td><strong>掉电&#x2F;断网</strong></td><td>❌ 完全不能</td><td>❌ 不能（静默失效）</td><td>❌ 不自动断开</td><td>超时或 Keep-Alive 探测失败</td><td><strong>必须用心跳或调短 Keep-Alive</strong></td></tr></tbody></table><blockquote><ol><li><strong>只有进程终止能保证优雅关闭；</strong></li><li><strong>系统级异常（重启、断电）会导致连接“假死”；</strong></li><li><strong>TCP 本身无法快速检测物理层断连；</strong></li><li><strong>生产环境必须依赖：</strong><ul><li><strong>应用层心跳（推荐）</strong></li><li><strong>或 调优 TCP Keep-Alive</strong></li></ul></li></ol><p><strong>记住：“TCP 可靠，但不万能；异常检测，靠心跳保命。”</strong></p></blockquote><h2 id="11-TCP-小结"><a href="#11-TCP-小结" class="headerlink" title="11. TCP 小结"></a>11. TCP 小结</h2><p>TCP 协议这么复杂就是因为 TCP 既要保证可靠性，同时又尽可能的提高性能。</p><p><strong>可靠性：</strong></p><ul><li><p><strong>检验和：</strong> 检测数据传输中的错误。</p></li><li><p><strong>序列号：</strong> 确保数据按序到达，解决重复和乱序问题。</p></li><li><p><strong>确认应答：</strong> 接收方确认收到数据，形成闭环（核心）。</p></li><li><p><strong>超时重传：</strong> 发送方未及时收到确认则重发数据。</p></li><li><p><strong>连接管理：</strong> 三次握手建立连接，四次挥手释放连接。</p></li><li><p><strong>流量控制：</strong> 通过滑动窗口机制控制发送速率，避免接收方过载（也属于提高性能）。</p></li><li><p><strong>拥塞控制：</strong> 检测网络拥塞并调整发送速率（也属于提高性能）。</p></li></ul><p><strong>提高性能：</strong></p><ul><li><p><strong>滑动窗口：</strong> 允许发送方连续发送多个数据包。</p></li><li><p><strong>快速重传：</strong> 基于重复确认快速检测丢包并重传。</p></li><li><p><strong>延迟应答：</strong> 合并多个确认，减少网络开销。</p></li><li><p><strong>捎带应答：</strong> 在数据报文段中携带确认信息。</p></li></ul><p>其他：TCP 定时器：</p><ul><li>重传定时器：为了控制丢失的报文段或丢弃的报文段，也就是对报文段确认的等待时间。</li><li>坚持定时器：专门为对方零窗口通知而设立的，也就是向对方发送窗口探测的时间间隔。</li><li>保活定时器：为了检查空闲连接的存在状态，也就是向对方发送探查报文的时间间隔。</li><li>TIME_WAIT 定时器：双方在四次挥手后，主动断开连接的一方需要等待的时长。</li></ul><h2 id="12-基于-TCP-的应用层协议"><a href="#12-基于-TCP-的应用层协议" class="headerlink" title="12. 基于 TCP 的应用层协议"></a>12. 基于 TCP 的应用层协议</h2><p>常见的基于 TCP 的应用层协议如下：</p><ul><li>HTTP（超文本传输协议）。 </li><li>HTTPS（安全数据传输协议）。</li><li>SSH（安全外壳协议）。 </li><li>Telnet（远程终端协议）。 </li><li>FTP（文件传输协议）。 </li><li>SMTP（电子邮件传输协议）。</li></ul><p>当然，也包括自己写 TCP 程序时自定义的应用层协议。</p><h2 id="13-UDP-实现可靠传输的思路-——-具体场景具体分析，往-TCP-靠"><a href="#13-UDP-实现可靠传输的思路-——-具体场景具体分析，往-TCP-靠" class="headerlink" title="13. UDP 实现可靠传输的思路 —— 具体场景具体分析，往 TCP 靠"></a>13. UDP 实现可靠传输的思路 —— 具体场景具体分析，往 TCP 靠</h2><p>虽然 UDP 本身是不可靠的，但可以在应用层实现类似 TCP 的可靠性机制：</p><ol><li><strong>引入序列号</strong>：为每个数据包分配唯一序号，确保数据有序。</li><li><strong>确认应答机制</strong>：接收方收到数据后发送确认信息。</li><li><strong>超时重传</strong>：设置合理的超时时间，未收到确认则重传。</li><li><strong>滑动窗口</strong>：控制发送窗口大小，实现流量控制。</li><li><strong>拥塞控制</strong>：根据网络状况动态调整发送速率。</li></ol><h2 id="14-补充：listen-第二个参数（backlog）的准确理解"><a href="#14-补充：listen-第二个参数（backlog）的准确理解" class="headerlink" title="14. 补充：listen 第二个参数（backlog）的准确理解"></a>14. 补充：<code>listen</code> 第二个参数（<code>backlog</code>）的准确理解</h2><h3 id="1-函数原型"><a href="#1-函数原型" class="headerlink" title="1. 函数原型"></a>1. 函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">listen</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> backlog)</span>;</span><br></pre></td></tr></table></figure><p>官方定义：<code>backlog</code> 参数指定了 <strong>内核为该套接字维护的等待接受的连接队列的最大长度</strong>。</p><h3 id="2-实际含义"><a href="#2-实际含义" class="headerlink" title="2. 实际含义"></a>2. 实际含义</h3><p>在现代 Linux 系统中，这个参数控制的是 <strong>全连接队列（accept queue）</strong> 的大小，即：</p><ul><li>已经完成三次握手的连接。</li><li>等待应用层调用 <code>accept()</code> 函数取走的连接。</li></ul><h3 id="3-关键要点（重要）"><a href="#3-关键要点（重要）" class="headerlink" title="3. 关键要点（重要）"></a>3. 关键要点（重要）</h3><h4 id="1-队列机制"><a href="#1-队列机制" class="headerlink" title="1. 队列机制"></a>1. 队列机制</h4><p>TCP 连接建立过程中涉及两个队列：</p><ul><li><strong>半连接队列（SYN queue）</strong>：处理三次握手过程中的连接（SYN_RECV 状态）。</li><li><strong>全连接队列（accept queue）</strong>：已完成握手等待应用处理的连接（ESTABLISHED 状态）。</li></ul><p><code>backlog</code> 参数主要影响的是 <strong>全连接队列</strong> 的大小。</p><h4 id="2-实际队列长度"><a href="#2-实际队列长度" class="headerlink" title="2. 实际队列长度"></a>2. 实际队列长度</h4><p>在 Linux 内核中，实际的全连接队列长度通常是 <code>backlog + 1</code>。这是因为：队列维护时会包含当前正在被 <code>accept()</code> 处理的连接，所以设置 <code>backlog = 5</code> 时，实际可容纳 6 个等待连接。</p><h4 id="3-连接拒绝机制"><a href="#3-连接拒绝机制" class="headerlink" title="3. 连接拒绝机制"></a>3. 连接拒绝机制</h4><p>当全连接队列满时：新的连接请求会被内核拒绝，客户端可能会收到 <code>ECONNREFUSED</code> 错误，或者内核会静默丢弃连接请求（取决于具体配置）。</p><h3 id="4-历史演变"><a href="#4-历史演变" class="headerlink" title="4. 历史演变"></a>4. 历史演变</h3><ul><li><strong>早期实现</strong>：<code>backlog</code> 表示半连接队列和全连接队列的总和。</li><li><strong>现代实现</strong>：<code>backlog</code> 主要控制全连接队列，半连接队列由其他内核参数控制。</li></ul><h3 id="5-实际应用"><a href="#5-实际应用" class="headerlink" title="5. 实际应用"></a>5. 实际应用</h3><ul><li><strong>Web 服务器</strong>：通常设置为 128、256 或 512。</li><li><strong>高并发服务</strong>：可以适当增大，如 1024 或更高。</li><li><strong>考虑系统限制</strong>：受 <code>/proc/sys/net/core/somaxconn</code> 内核参数限制。</li><li><strong>监控队列状态</strong>：通过 <code>ss -tlnp</code> 等命令查看队列使用情况。</li></ul><p>简单来说，<code>backlog</code> 参数决定了服务器能够同时 “挂起” 多少个已经建立但尚未被应用程序处理的 TCP 连接。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;传输层-——-TCP（下）&quot;&gt;&lt;a href=&quot;#传输层-——-TCP（下）&quot; class=&quot;headerlink&quot; title=&quot;传输层 —— TCP（下）&quot;&gt;&lt;/a&gt;传输层 —— TCP（下）&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a</summary>
        
      
    
    
    
    <category term="Linux" scheme="https://www.minbit.top/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://www.minbit.top/tags/Linux/"/>
    
    <category term="网络" scheme="https://www.minbit.top/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>058 从 Centos 切换到 Ubuntu</title>
    <link href="https://www.minbit.top/posts/38169.html"/>
    <id>https://www.minbit.top/posts/38169.html</id>
    <published>2025-10-05T04:00:00.000Z</published>
    <updated>2025-10-12T04:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="从-Centos-切换到-Ubuntu"><a href="#从-Centos-切换到-Ubuntu" class="headerlink" title="从 Centos 切换到 Ubuntu"></a>从 Centos 切换到 Ubuntu</h1><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>Centos 是一个不错的发行版，但是它的各个版本都已经停止维护了。CentOS 7 于 2024 年 6 月 30 日正式停止支持，CentOS 8 更是早在 2021 年 12 月 31 日就停止维护了。而且后续学习中不支持部分软件版本，从长远使用、学习、生态等多方面考虑，将其切换到 Ubuntu 是不错之举。</p><p>其实从一开始就直接接触 Ubuntu 也是不错的选择，但这些都是后话了，各有优劣吧。从 Centos 切换到 Ubuntu 的朋友可以体验到不同系统的优劣，直接使用 Ubuntu 倒是可以省去一些小麻烦，但归根结底，二者基本可以做到无缝互通，命令大差不差，遇到不一样的简单查一下就行了。下面开始教学如何从 Centos 切换到 Ubuntu，基本上比较简单，少部分涉及 Centos 的一点基础。</p><h2 id="2-系统切换"><a href="#2-系统切换" class="headerlink" title="2. 系统切换"></a>2. 系统切换</h2><p>到自己的云服务器厂商后台找到切换镜像，选择 Ubuntu 22.04 版本进行安装，几分钟后就会完成，注意完成后要重新设置密码！</p><p><strong>重要提醒：切换系统前一定要备份好重要数据，系统切换会清空所有数据！</strong></p><h2 id="3-使用-Xshell-进行连接"><a href="#3-使用-Xshell-进行连接" class="headerlink" title="3. 使用 Xshell 进行连接"></a>3. 使用 Xshell 进行连接</h2><p><strong>这里的操作和连接 Centos 一模一样，直接输入公网 IP 和对应的账密就能进行登录。</strong></p><h3 id="1-创建普通账户"><a href="#1-创建普通账户" class="headerlink" title="1. 创建普通账户"></a>1. 创建普通账户</h3><p>同样的，我们还是创建一个普通账户：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adduser 用户名</span><br></pre></td></tr></table></figure><p>紧接着会让我们设置和确认密码，正常输入就行。完了后就会发现和 Centos 的区别：它会让我们设置该账户的信息，比如全名、房间号码、工作电话、家庭电话等。<strong>为了方便可以一路回车表示默认，个人使用会比较方便快捷</strong>，当然，如果你想要进行设置也行。</p><h3 id="2-赋予-sudo-权限"><a href="#2-赋予-sudo-权限" class="headerlink" title="2. 赋予 sudo 权限"></a>2. 赋予 sudo 权限</h3><p><strong>关键步骤</strong>：创建用户后需要赋予 sudo 权限，否则无法执行管理员命令，这里有两个方法：</p><p><strong>方法一：</strong> 和 Centos 一样，使用 <code>root</code> 账户执行命令：<code>vim /etc/sudoers</code>，按下 <code>i</code> 键进入插入模式，找到大约第 100 行左右的位置（附近会有 <code>root ALL=(ALL) ALL</code> 的字眼），在其下方添加以下内容：<code>username    ALL=(ALL)    ALL</code>。</p><ul><li><code>username</code>：替换为你要授权的账户名。</li><li><code>ALL=(ALL)</code>：允许用户以任何用户身份执行命令。</li><li><code>ALL</code>：允许执行所有命令。</li></ul><p>按 <code>Esc</code> 键返回到默认模式，然后输入 <code>:wq!</code> 强制保存并退出。然后就可以验证 <code>sudo</code> 权限了。</p><p><strong>方法二（更推荐）：</strong> 先切换到 root 账号，在 Ubuntu 里，加入 <code>sudo</code> 组就是最安全的方式，把某用户加入 sudo 组执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">usermod -aG <span class="built_in">sudo</span> 用户名</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可选验证：</span></span><br><span class="line"><span class="built_in">groups</span> 用户名</span><br><span class="line"><span class="comment"># 示例输出</span></span><br><span class="line">用户名 : 用户名 <span class="built_in">sudo</span></span><br></pre></td></tr></table></figure><p>这样新用户就可以使用 sudo 命令来执行需要管理员权限的操作了。</p><h2 id="4-软件包管理器详解"><a href="#4-软件包管理器详解" class="headerlink" title="4. 软件包管理器详解"></a>4. 软件包管理器详解</h2><p>在 <strong>Ubuntu 22.04</strong> 中已经没有 <code>yum</code>，它属于 RHEL&#x2F;CentOS 系列。Ubuntu 默认的软件包管理器是 <strong>APT (Advanced Package Tool)</strong>。等价关系大概是：</p><ul><li>CentOS&#x2F;RHEL: <code>yum</code> &#x2F; <code>dnf</code></li><li>Ubuntu&#x2F;Debian: <code>apt</code> &#x2F; <code>apt-get</code></li></ul><h3 id="1-等价命令对比"><a href="#1-等价命令对比" class="headerlink" title="1. 等价命令对比"></a>1. 等价命令对比</h3><table><thead><tr><th>CentOS&#x2F;RHEL (yum&#x2F;dnf)</th><th>Ubuntu&#x2F;Debian (apt)</th><th>说明</th></tr></thead><tbody><tr><td>yum update</td><td>apt update</td><td>更新软件包列表</td></tr><tr><td>yum upgrade</td><td>apt upgrade</td><td>升级已安装的软件</td></tr><tr><td>yum install 包名</td><td>apt install 包名</td><td>安装软件包</td></tr><tr><td>yum remove 包名</td><td>apt remove 包名</td><td>卸载软件包</td></tr><tr><td>yum search 关键词</td><td>apt search 关键词</td><td>搜索软件包</td></tr><tr><td>yum info 包名</td><td>apt show 包名</td><td>显示软件包详细信息</td></tr></tbody></table><h3 id="2-常用-APT-命令"><a href="#2-常用-APT-命令" class="headerlink" title="2. 常用 APT 命令"></a>2. 常用 APT 命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt update<span class="comment"># 更新软件包列表</span></span><br><span class="line"><span class="built_in">sudo</span> apt upgrade -y<span class="comment"># 升级已安装的软件</span></span><br><span class="line"><span class="built_in">sudo</span> apt install 软件包名称 -y<span class="comment"># 安装软件包</span></span><br><span class="line"><span class="built_in">sudo</span> apt remove 软件包名称 -y<span class="comment"># 卸载软件包</span></span><br><span class="line"><span class="built_in">sudo</span> apt purge 软件包名称 -y<span class="comment"># 彻底卸载（包括配置文件）</span></span><br><span class="line">apt search 关键词<span class="comment"># 搜索软件包</span></span><br><span class="line"><span class="built_in">sudo</span> apt clean<span class="comment"># 清理缓存</span></span><br></pre></td></tr></table></figure><h3 id="3-更新升级"><a href="#3-更新升级" class="headerlink" title="3. 更新升级"></a>3. 更新升级</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt update        <span class="comment"># 更新软件包列表</span></span><br><span class="line"><span class="built_in">sudo</span> apt upgrade -y    <span class="comment"># 升级已安装的软件</span></span><br></pre></td></tr></table></figure><p>这个过程可能在 10 多分钟作用，耐心等待……可能会出现下面的情况：</p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20251005182822895.png" alt="PixPin_2025-10-05_18-28-09"></p><p>这是 <strong>Ubuntu 在升级 <code>openssh-server</code> 包时的提示</strong>，意思是：之前修改过 <code>/etc/ssh/sshd_config</code> 配置文件（比如改过端口、sudo 权限等），而现在升级的软件包带来了一份新的默认配置。系统不知道该用哪个，所以给出选择，选项含义：</p><ol><li><strong>install the package maintainer’s version</strong> → 用新版本覆盖掉你现在的配置（会丢失你自己改的设置）。</li><li><strong>keep the local version currently installed</strong> → 保留你现在的配置（推荐，大部分情况下选这个）。</li><li><strong>show the differences…</strong> → 查看差异，方便你决定。</li><li><strong>do a 3-way merge…</strong> → 尝试三方合并。</li><li><strong>start a new shell…</strong> → 打开一个 shell 手动处理。</li></ol><p>按照自己情况来，如果选择覆盖，之前的解放的 sudo 要重新配置。</p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20251005183306585.png" alt="PixPin_2025-10-05_18-32-57"></p><p><strong>直接 ok 就行。</strong> 这是 Ubuntu 系统提示有内核更新待处理的界面。系统当前运行的内核版本是 <code>5.15.0 - 138 - generic</code>，而有更新的内核版本 <code>5.15.0 - 157 - generic</code> 可用。提示说明系统不会自动重启来加载新内核，建议你考虑手动重启系统，这样新的内核就能被加载运行，可能会带来性能优化、 bug 修复等好处。</p><p><img src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20251005183326565.png" alt="PixPin_2025-10-05_18-33-15"></p><p><strong>直接保持默认选中的状态，然后选择 <code>&lt;Ok&gt;</code> 即可。</strong> 当你看到这个界面时，是系统在询问哪些服务需要重启，因为有一些守护进程使用了过时的库，（前面带 <code>[*]</code>）通常是系统推荐需要重启的关键服务，更新后需要重启相关服务来应用更改。这些服务依赖的库更新后，重启它们能确保服务使用新库正常运行。</p><p><strong>为了让新的内核和系统更新完全生效，建议你重启系统：<code>sudo reboot</code> 或云服务器厂商后台重启。</strong></p><h2 id="5-安装和配置-GCC-编译器"><a href="#5-安装和配置-GCC-编译器" class="headerlink" title="5. 安装和配置 GCC 编译器"></a>5. 安装和配置 GCC 编译器</h2><h3 id="1-安装较新的-GCC-和-G-（推荐版本-9-12）"><a href="#1-安装较新的-GCC-和-G-（推荐版本-9-12）" class="headerlink" title="1. 安装较新的 GCC 和 G++（推荐版本 9-12）"></a>1. 安装较新的 GCC 和 G++（推荐版本 9-12）</h3><p>Ubuntu 22.04 默认自带的 GCC 版本是 <strong>11.x</strong>。如果你需要更高版本（例如 GCC 12 或 13），可以通过官方 <code>ppa:ubuntu-toolchain-r/test</code> 获得，这里我们选择默认的就行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 PPA 源</span></span><br><span class="line"><span class="built_in">sudo</span> add-apt-repository ppa:ubuntu-toolchain-r/test -y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可选</span></span><br><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt install gcc-13 g++-13 -y</span><br></pre></td></tr></table></figure><p>安装完成后可以用以下命令查看版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">gcc --version</span><br><span class="line">g++ --version</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例输出：</span></span><br><span class="line">gcc (Ubuntu 11.4.0-1ubuntu1~22.04.2) 11.4.0</span><br><span class="line">Copyright (C) 2021 Free Software Foundation, Inc.</span><br><span class="line">This is free software; see the <span class="built_in">source</span> <span class="keyword">for</span> copying conditions.  There is NO</span><br><span class="line">warranty; not even <span class="keyword">for</span> MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</span><br><span class="line"></span><br><span class="line">g++ (Ubuntu 11.4.0-1ubuntu1~22.04.2) 11.4.0</span><br><span class="line">Copyright (C) 2021 Free Software Foundation, Inc.</span><br><span class="line">This is free software; see the <span class="built_in">source</span> <span class="keyword">for</span> copying conditions.  There is NO</span><br><span class="line">warranty; not even <span class="keyword">for</span> MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</span><br></pre></td></tr></table></figure><h3 id="2-安装指定版本的-GCC（可选）"><a href="#2-安装指定版本的-GCC（可选）" class="headerlink" title="2. 安装指定版本的 GCC（可选）"></a>2. 安装指定版本的 GCC（可选）</h3><p>如果你需要安装 GCC 12 或 13：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 GCC 12</span></span><br><span class="line"><span class="built_in">sudo</span> apt install gcc-12 g++-12 -y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 GCC 13（需要添加 PPA 源）</span></span><br><span class="line"><span class="built_in">sudo</span> add-apt-repository ppa:ubuntu-toolchain-r/test -y</span><br><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt install gcc-13 g++-13 -y</span><br></pre></td></tr></table></figure><h3 id="3-配置-GCC-版本切换（可选）"><a href="#3-配置-GCC-版本切换（可选）" class="headerlink" title="3. 配置 GCC 版本切换（可选）"></a>3. 配置 GCC 版本切换（可选）</h3><p>如果系统中安装了多个版本的 GCC，可以使用 update-alternatives 来管理：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置 GCC 12 为默认版本</span></span><br><span class="line"><span class="built_in">sudo</span> update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-12 100 \</span><br><span class="line">                         --slave /usr/bin/g++ g++ /usr/bin/g++-12 \</span><br><span class="line">                         --slave /usr/bin/gcov gcov /usr/bin/gcov-12</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置 GCC 11 为备选版本</span></span><br><span class="line"><span class="built_in">sudo</span> update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-11 80 \</span><br><span class="line">                         --slave /usr/bin/g++ g++ /usr/bin/g++-11 \</span><br><span class="line">                         --slave /usr/bin/gcov gcov /usr/bin/gcov-11</span><br></pre></td></tr></table></figure><p><strong>切换 GCC 版本</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> update-alternatives --config gcc</span><br></pre></td></tr></table></figure><p>输入对应的编号即可切换到相应的 GCC 版本。</p><h2 id="6-其他工具的安装"><a href="#6-其他工具的安装" class="headerlink" title="6. 其他工具的安装"></a>6. 其他工具的安装</h2><blockquote><p>在 CentOS 中，使用 <code>yum install</code> 或 <code>dnf install</code> 安装软件时，<strong>最后会显示一行醒目的：<code>Complete!</code></strong>，这行文字就像一个“成功印章”，告诉你：“安装顺利完成，一切 OK！”<strong>Ubuntu 不会显示 <code>Complete!</code>，在 Ubuntu 的世界里，安静，就是最好的赞美！没有报错（Error）就是成功！</strong></p></blockquote><h3 id="1-安装-tree-命令"><a href="#1-安装-tree-命令" class="headerlink" title="1. 安装 tree 命令"></a>1. 安装 <code>tree</code> 命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install tree -y</span><br></pre></td></tr></table></figure><p>安装完成后测试：<code>tree --version</code>。</p><h3 id="2-安装-Git"><a href="#2-安装-Git" class="headerlink" title="2. 安装 Git"></a>2. 安装 Git</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install git -y <span class="comment"># 通常是 2.34.x（Ubuntu 22.04 默认）</span></span><br><span class="line">git --version  <span class="comment"># 版本验证，可能是 2.40+ 或更高</span></span><br></pre></td></tr></table></figure><h3 id="3-安装-lrzsz-工具"><a href="#3-安装-lrzsz-工具" class="headerlink" title="3. 安装 lrzsz 工具"></a>3. 安装 lrzsz 工具</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install lrzsz -y</span><br></pre></td></tr></table></figure><p>安装后即可使用：</p><ul><li><code>rz</code>：从本地上传文件到服务器。</li><li><code>sz 文件名</code>：从服务器下载文件到本地。</li></ul><h3 id="4-安装-htop-命令"><a href="#4-安装-htop-命令" class="headerlink" title="4. 安装 htop 命令"></a>4. 安装 <code>htop</code> 命令</h3><p><code>htop</code> 是交互式的进程监控工具，比 <code>top</code> 更直观，支持上下滚动查看进程树，命令：<code>htop</code>，和 top 差不多，也是按 q 退出。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install htop -y</span><br></pre></td></tr></table></figure><h3 id="5-安装-Core-Dump-调试支持（debuginfo-替代）"><a href="#5-安装-Core-Dump-调试支持（debuginfo-替代）" class="headerlink" title="5. 安装 Core Dump 调试支持（debuginfo 替代）"></a>5. 安装 Core Dump 调试支持（<code>debuginfo</code> 替代）</h3><p>在 Ubuntu 中 <strong>没有 <code>debuginfo-install</code></strong> 命令，对应的是 <strong><code>-dbg</code> 或 <code>-dbgsym</code></strong> 包。Ubuntu 的 <code>libc6-dbg</code> 是 glibc 的调试信息包，<code>libgcc-11-dev</code> 对应 GCC 的调试支持（你可以根据 GCC 版本调整，如 <code>libgcc-12-dev</code>）。用于调试程序 Core Dump 时提供符号信息，让 gdb 能正确显示函数调用栈。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install libc6-dbg libgcc-11-dev -y</span><br><span class="line">dpkg -l | grep libc6-dbg<span class="comment"># 验证：若出现 libc6-dbg，说明安装成功。</span></span><br></pre></td></tr></table></figure><h3 id="6-安装-JsonCpp"><a href="#6-安装-JsonCpp" class="headerlink" title="6. 安装 JsonCpp"></a>6. 安装 <code>JsonCpp</code></h3><p><code>JsonCpp</code> 是 C++ 的 JSON 解析与序列化库，常用于网络通信、配置文件解析。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install libjsoncpp-dev -y</span><br><span class="line">dpkg -l | grep jsoncpp<span class="comment"># 验证：若显示 libjsoncpp-dev，说明安装成功。</span></span><br></pre></td></tr></table></figure><h3 id="7-安装-telnet"><a href="#7-安装-telnet" class="headerlink" title="7. 安装 telnet"></a>7. 安装 <code>telnet</code></h3><p><code>telnet</code> 用于测试网络连通性与端口开放状态（TCP 连接测试），可快速验证远程主机端口是否可访问。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install telnet -y</span><br></pre></td></tr></table></figure><p>基本语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># telnet [主机名或IP地址] [端口号]，比如：</span></span><br><span class="line">telnet baidu.com 80</span><br><span class="line"><span class="comment"># 连通后的示例输出：</span></span><br><span class="line">Trying 220.181.7.203...</span><br><span class="line">Connected to baidu.com.</span><br><span class="line">Escape character is <span class="string">&#x27;^]&#x27;</span>.</span><br></pre></td></tr></table></figure><p><strong>注意：如果省略端口号，默认连接远程主机的 23 端口（Telnet 服务默认端口）。退出 Telnet 连接： Telnet 交互界面中，按 Ctrl + ] 进入命令模式，然后输入 quit 退出。</strong></p><h3 id="8-安装-iostat（sysstat-工具包）"><a href="#8-安装-iostat（sysstat-工具包）" class="headerlink" title="8. 安装 iostat（sysstat 工具包）"></a>8. 安装 <code>iostat</code>（sysstat 工具包）</h3><p><code>iostat</code> 用于监控 <strong>CPU 使用率</strong> 和 <strong>磁盘 I&#x2F;O 性能</strong>，常用于性能分析。用命令 <code>iostat</code> 验证，如果输出 CPU 与磁盘统计信息，即表示安装成功。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install sysstat -y</span><br></pre></td></tr></table></figure><h3 id="9-使用-ifconfig-命令"><a href="#9-使用-ifconfig-命令" class="headerlink" title="9. 使用 ifconfig 命令"></a>9. 使用 <code>ifconfig</code> 命令</h3><p>从 Ubuntu 18.04 开始，<code>ifconfig</code> 已经不再默认安装，取而代之的是更强大的 <strong>ip 命令</strong>。如果更习惯 <code>ifconfig</code>，可以安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install net-tools</span><br></pre></td></tr></table></figure><p>安装完成后即可使用：<code>ifconfig</code>。</p><h2 id="7-使用-VS-Code-连接主机开始开发"><a href="#7-使用-VS-Code-连接主机开始开发" class="headerlink" title="7. 使用 VS Code 连接主机开始开发"></a>7. 使用 VS Code 连接主机开始开发</h2><p>这里的操作和之前的一模一样，但是会存在一个问题：换了系统后，公网 IP 和配置没变，典型的效果是远程资源管理器中还显示旧的记录，新的连接一直失败。</p><p><strong>解决方法：此时需要做一个操作：在 Windows 中来到 <code>C:\Users\xxxxxxxx\.ssh</code> 这个目录下，将最后 <code>known_hosts</code> 和 <code>known_hosts.old</code> 这 2 个文件删除，重新连接即可，等待 1-2 分钟，VS Code Server 就会完成，该目录下会自动生成新的密钥，我们又可以进行愉快的开发啦~</strong></p><blockquote><p>如果你使用的还是 <strong>1.85.1 版本的 VS Code</strong> 那就是照旧，但如果你使用的是 <strong>2025 年 9 月（版本 1.105）</strong>，你就会惊奇的发现也可以正常连接！这对于我们老 CentOS 用户来说真是太妙啦！如今的 Ubuntu 不管是这个用户体验还是生态来说都要优于 CentOS，真体验到了什么叫 <strong>对开发者真友好</strong>……</p></blockquote>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;从-Centos-切换到-Ubuntu&quot;&gt;&lt;a href=&quot;#从-Centos-切换到-Ubuntu&quot; class=&quot;headerlink&quot; title=&quot;从 Centos 切换到 Ubuntu&quot;&gt;&lt;/a&gt;从 Centos 切换到 Ubuntu&lt;/h1&gt;&lt;h2</summary>
        
      
    
    
    
    <category term="Linux" scheme="https://www.minbit.top/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://www.minbit.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>00 在 CentOS 7 上安装 Redis</title>
    <link href="https://www.minbit.top/posts/7665.html"/>
    <id>https://www.minbit.top/posts/7665.html</id>
    <published>2025-10-04T16:00:00.000Z</published>
    <updated>2025-10-05T02:10:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CentOS-7-安装-Redis-5-碰壁记录：从-yum-源配置到软件安装的踩坑之旅"><a href="#CentOS-7-安装-Redis-5-碰壁记录：从-yum-源配置到软件安装的踩坑之旅" class="headerlink" title="CentOS 7 安装 Redis 5 碰壁记录：从 yum 源配置到软件安装的踩坑之旅"></a>CentOS 7 安装 Redis 5 碰壁记录：从 yum 源配置到软件安装的踩坑之旅</h1><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>我尝试在 CentOS 7 服务器上尝试安装 Redis 5，原本以为是个简单的 <code>yum install redis</code> 就能搞定的事情，结果却遇到了一系列问题。原本用下面的步骤就能完成，但是很不巧，这个迭代和维护等种种原因很不巧的出现在一起……所以这下面的 6 条命令仅适合有缘人。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 先把原有的 repo 文件备份，避免冲突或损坏</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">mv</span> /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.bak</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 使用阿里云的 CentOS7 源替换官方源</span></span><br><span class="line"><span class="comment">#   - 这里直接下载阿里云维护的 CentOS-7.repo 文件到 /etc/yum.repos.d/ 目录</span></span><br><span class="line"><span class="built_in">sudo</span> curl -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 清理旧的 yum 缓存</span></span><br><span class="line"><span class="built_in">sudo</span> yum clean all</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 重新生成 yum 缓存，确保源可以正常使用</span></span><br><span class="line"><span class="built_in">sudo</span> yum makecache</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 安装 gcc</span></span><br><span class="line"><span class="comment">#   - 如果系统已经有 gcc，则会提示已安装并是最新版本</span></span><br><span class="line"><span class="built_in">sudo</span> yum install -y gcc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 6. 安装常用开发工具（可选，推荐一次性安装好）</span></span><br><span class="line"><span class="comment">#   - 包括 gcc-c++（C++编译器）、make（编译工具）、wget（下载工具）、epel-release（扩展源）</span></span><br><span class="line"><span class="built_in">sudo</span> yum install -y gcc gcc-c++ make wget epel-release</span><br></pre></td></tr></table></figure><p>从最初的 yum 源无法解析，到更换阿里云源，再到 Redis 版本不符预期，整个过程真是惹人心烦。<strong>本文将详细记录我的操作过程、遇到的问题，最终我还是没能成功安装，但是可以安装 Redis 7.2.5 这个版本，希望能为遇到类似问题的朋友提供参考。</strong></p><h2 id="2-问题起源：yum-源无法解析"><a href="#2-问题起源：yum-源无法解析" class="headerlink" title="2. 问题起源：yum 源无法解析"></a>2. 问题起源：yum 源无法解析</h2><h3 id="1-初始尝试"><a href="#1-初始尝试" class="headerlink" title="1. 初始尝试"></a>1. 初始尝试</h3><p>我首先尝试安装基础的开发工具：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> yum install -y gcc gcc-c++ make wget epel-release</span><br></pre></td></tr></table></figure><p>结果立即遇到了问题：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Could not retrieve mirrorlist http://mirrorlist.centos.org?<span class="built_in">arch</span>=x86\_64\&amp;release=7\&amp;repo=sclo-rh error was</span><br><span class="line"></span><br><span class="line">14: curl#6 - <span class="string">&quot;Could not resolve host: mirrorlist.centos.org; Unknown error&quot;</span></span><br></pre></td></tr></table></figure><p>这个错误很明显是由于无法解析官方的 <a href="https://mirrorlist.centos.org/">mirrorlist.centos.org</a> 域名导致的。这可能是由于网络问题，或者是 CentOS 7 官方源在国内访问不稳定造成的。</p><h2 id="3-解决方案一：更换阿里云-yum-源"><a href="#3-解决方案一：更换阿里云-yum-源" class="headerlink" title="3. 解决方案一：更换阿里云 yum 源"></a>3. 解决方案一：更换阿里云 yum 源</h2><p>既然官方源有问题，我决定更换为国内的阿里云源。</p><h3 id="1-备份原有源配置"><a href="#1-备份原有源配置" class="headerlink" title="1. 备份原有源配置"></a>1. 备份原有源配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">mv</span> /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.bak</span><br></pre></td></tr></table></figure><h3 id="2-下载阿里云源配置"><a href="#2-下载阿里云源配置" class="headerlink" title="2. 下载阿里云源配置"></a>2. 下载阿里云源配置</h3><p>我首先尝试从 <a href="https://vault.centos.org/">vault.centos.org</a> 下载：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> curl -o /etc/yum.repos.d/CentOS-Base.repo http://vault.centos.org/7.9.2009/os/x86\_64/CentOS-Base.repo</span><br></pre></td></tr></table></figure><p>但下载下来的文件似乎有问题，执行 <code>yum clean all</code> 时出现：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">File contains no section headers.</span><br><span class="line"></span><br><span class="line">file: file:///etc/yum.repos.d/CentOS-Base.repo, line: 1</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;\&lt;html&gt;\r\n&#x27;</span></span><br></pre></td></tr></table></figure><p>看来直接从 vault 下载的文件不是正确的 repo 配置文件。</p><h3 id="3-正确的阿里云源配置"><a href="#3-正确的阿里云源配置" class="headerlink" title="3. 正确的阿里云源配置"></a>3. 正确的阿里云源配置</h3><p>我重新尝试直接从阿里云下载 repo 文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">rm</span> -f /etc/yum.repos.d/CentOS-Base.repo</span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> curl -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo</span><br></pre></td></tr></table></figure><p>这次下载成功了。接下来清理缓存并重新生成：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> yum clean all</span><br><span class="line"><span class="built_in">sudo</span> yum makecache</span><br></pre></td></tr></table></figure><p>在 <code>yum makecache</code> 过程中，虽然出现了一些连接超时的警告：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http://mirrors.cloud.aliyuncs.com/centos/7/os/x86\_64/repodata/6d0c3a488c282fe537794b5946b01e28c7f44db79097bb06826e1c0c88bad5ef-primary.sqlite.bz2: \[Errno 14] curl#6 - <span class="string">&quot;Could not resolve host: mirrors.cloud.aliyuncs.com; Unknown error&quot;</span></span><br><span class="line"></span><br><span class="line">Trying other mirror.</span><br></pre></td></tr></table></figure><p>但最终还是成功生成了缓存：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Metadata Cache Created</span><br></pre></td></tr></table></figure><h2 id="4-验证基础工具安装"><a href="#4-验证基础工具安装" class="headerlink" title="4. 验证基础工具安装"></a>4. 验证基础工具安装</h2><p>更换源后，我再次检查基础开发工具是否已安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gcc -v</span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> yum install -y gcc-c++</span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> yum install -y make wget epel-release</span><br></pre></td></tr></table></figure><p>结果显示这些工具都已经安装并且是最新版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Package gcc-4.8.5-44.el7.x86\_64 already installed and latest version</span><br><span class="line"></span><br><span class="line">Package gcc-c++-4.8.5-44.el7.x86\_64 already installed and latest version</span><br><span class="line"></span><br><span class="line">Package 1:make-3.82-24.el7.x86\_64 already installed and latest version</span><br><span class="line"></span><br><span class="line">Package wget-1.14-18.el7\_6.1.x86\_64 already installed and latest version</span><br><span class="line"></span><br><span class="line">Package epel-release-7-14.noarch already installed and latest version</span><br></pre></td></tr></table></figure><p>看来基础环境已经准备好了。</p><h2 id="5-安装-Redis-的尝试"><a href="#5-安装-Redis-的尝试" class="headerlink" title="5. 安装 Redis 的尝试"></a>5. 安装 Redis 的尝试</h2><h3 id="1-安装-yum-utils"><a href="#1-安装-yum-utils" class="headerlink" title="1. 安装 yum-utils"></a>1. 安装 yum-utils</h3><p>为了更好地管理 yum 源，我先安装了 yum-utils：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> yum install -y yum-utils</span><br></pre></td></tr></table></figure><p>这个安装过程很顺利，成功安装了 yum-utils 及其依赖包。</p><h3 id="2-尝试通过-remi-源安装-Redis"><a href="#2-尝试通过-remi-源安装-Redis" class="headerlink" title="2. 尝试通过 remi 源安装 Redis"></a>2. 尝试通过 remi 源安装 Redis</h3><p>我知道 remi 源提供了较新版本的 Redis，所以尝试使用 remi 源：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum --enablerepo=remi list redis</span><br></pre></td></tr></table></figure><p>显示可以安装 Redis 7.2.5：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Available Packages</span><br><span class="line"></span><br><span class="line">redis.x86\_64                                                7.2.5-1.el7.remi                                                remi</span><br></pre></td></tr></table></figure><p>我启用了 remi 源并安装 Redis：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> yum-config-manager --<span class="built_in">enable</span> remi</span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> yum install -y redis</span><br></pre></td></tr></table></figure><p>安装成功后，验证版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis-server -v</span><br><span class="line"></span><br><span class="line">Redis server v=7.2.5 sha=00000000:0 malloc=jemalloc-5.3.0 bits=64 build=2dd7a20ee3c6d015</span><br></pre></td></tr></table></figure><p>虽然安装成功了，但这是 Redis 7.2.5，而不是我需要的 Redis 5。</p><h3 id="3-尝试安装-Redis-5"><a href="#3-尝试安装-Redis-5" class="headerlink" title="3. 尝试安装 Redis 5"></a>3. 尝试安装 Redis 5</h3><p>我卸载了 Redis 7.2.5，并尝试安装 Redis 5：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> yum remove -y redis</span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> yum-config-manager --<span class="built_in">disable</span> remi</span><br></pre></td></tr></table></figure><p>我听说 remi 源有专门的 redis50 仓库，所以尝试启用它：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> yum-config-manager --<span class="built_in">enable</span> remi-redis50</span><br></pre></td></tr></table></figure><p>但这个命令执行后没有任何输出，可能 remi-redis50 源在我的系统中不存在。然后我尝试直接安装 Redis：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> yum install -y redis</span><br></pre></td></tr></table></figure><p>这次安装的是来自 epel 源的 Redis 3.2.12：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Package redis.x86\_64 0:3.2.12-2.el7 will be installed</span><br></pre></td></tr></table></figure><p>验证版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis-server -v</span><br><span class="line"></span><br><span class="line">Redis server v=3.2.12 sha=00000000:0 malloc=jemalloc-3.6.0 bits=64 build=7897e7d0e13773f</span><br></pre></td></tr></table></figure><p>这仍然不是我需要的 Redis 5。</p><h2 id="6-问题总结与分析"><a href="#6-问题总结与分析" class="headerlink" title="6. 问题总结与分析"></a>6. 问题总结与分析</h2><h3 id="1-成功的操作"><a href="#1-成功的操作" class="headerlink" title="1. 成功的操作"></a>1. 成功的操作</h3><ol><li><p><strong>更换阿里云 yum 源</strong>：成功解决了官方源无法解析的问题</p></li><li><p><strong>安装基础开发工具</strong>：确认 gcc、gcc-c++、make、wget 等工具已正确安装</p></li><li><p><strong>安装 yum-utils</strong>：成功安装了 yum 源管理工具</p></li><li><p><strong>通过 remi 源安装 Redis 7</strong>：成功安装了 Redis 7.2.5</p></li></ol><h3 id="2-未解决的问题"><a href="#2-未解决的问题" class="headerlink" title="2. 未解决的问题"></a>2. 未解决的问题</h3><ol><li><p><strong>无法通过 yum 源安装 Redis 5</strong>：虽然尝试了多种方法，但最终只能安装到 Redis 3.2.12 或 Redis 7.2.5</p></li><li><p><strong>remi-redis50 源配置问题</strong>：可能需要手动配置 remi-redis50 源才能安装 Redis 5</p></li></ol><h2 id="7-参考资料"><a href="#7-参考资料" class="headerlink" title="7. 参考资料"></a>7. 参考资料</h2><ol><li><p>CentOS 官方文档。</p></li><li><p>阿里云开源镜像站文档。</p></li><li><p>Redis 官方安装指南。</p></li><li><p>各大技术社区的相关讨论和解决方案。</p></li></ol>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;CentOS-7-安装-Redis-5-碰壁记录：从-yum-源配置到软件安装的踩坑之旅&quot;&gt;&lt;a href=&quot;#CentOS-7-安装-Redis-5-碰壁记录：从-yum-源配置到软件安装的踩坑之旅&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    <category term="Redis" scheme="https://www.minbit.top/categories/Redis/"/>
    
    
    <category term="Redis" scheme="https://www.minbit.top/tags/Redis/"/>
    
  </entry>
  
</feed>
