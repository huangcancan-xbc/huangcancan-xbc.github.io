<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>040 线程控制 | 小米里的大麦</title><meta name="keywords" content="Linux,线程"><meta name="author" content="小米里的大麦"><meta name="copyright" content="小米里的大麦"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="040 线程控制"><meta name="application-name" content="040 线程控制"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="040 线程控制"><meta property="og:url" content="https://www.minbit.top/posts/21804.html"><meta property="og:site_name" content="小米里的大麦"><meta property="og:description" content="线程控制1. POSIX 线程库1. 什么是 POSIX 线程库（pthread）POSIX（Portable Operating System Interface）线程库，又称（简称） pthread（POSIX Threads），是 Unix 系统下的标准化多线程编程接口（IEEE POSIX"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://zycs-img-8kd.pages.dev/v2/0k1JltC.jpeg?_r_=94c0b562-a46b-881d-a1b9-9cfa65326bf6"><meta property="article:author" content="小米里的大麦"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://zycs-img-8kd.pages.dev/v2/0k1JltC.jpeg?_r_=94c0b562-a46b-881d-a1b9-9cfa65326bf6"><meta name="description" content="线程控制1. POSIX 线程库1. 什么是 POSIX 线程库（pthread）POSIX（Portable Operating System Interface）线程库，又称（简称） pthread（POSIX Threads），是 Unix 系统下的标准化多线程编程接口（IEEE POSIX"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="https://www.minbit.top/posts/21804.html"><link rel="preconnect" href="//cdn.cbd.int"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="Cd-RTVhRO2mndEhicN2cvLXbsNxPqFC6fSn6ql80eVg"/><meta name="baidu-site-verification" content="codeva-ZG3S9QTvGO"/><meta name="msvalidate.01" content="6DF744D82FE6D1FD11CE18658760B59D"/><meta name="baidu-site-verification" content="codeva-gIjOMzUuhV"/><link rel="manifest" href="/manifest.json"/><meta name="msapplication-TileColor" content="var(--anzhiyu-main)"/><link rel="mask-icon" href="/img/siteicon/apple-icon-180.png" color="#5bbad5"/><link rel="apple-touch-icon" sizes="180x180" href="/img/siteicon/apple-icon-180.png"/><link rel="apple-touch-icon-precomposed" sizes="180x180" href="/img/siteicon/apple-icon-180.png"/><link rel="icon" type="image/png" sizes="32x32" href="/img/siteicon/32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/img/siteicon/16.png"/><link rel="bookmark" href="/img/siteicon/apple-icon-180.png"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2048-2732.jpg" media="(device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2732-2048.jpg" media="(device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1668-2388.jpg" media="(device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2388-1668.jpg" media="(device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1536-2048.jpg" media="(device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2048-1536.jpg" media="(device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1668-2224.jpg" media="(device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2224-1668.jpg" media="(device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1620-2160.jpg" media="(device-width: 810px) and (device-height: 1080px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2160-1620.jpg" media="(device-width: 810px) and (device-height: 1080px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1290-2796.jpg" media="(device-width: 430px) and (device-height: 932px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2796-1290.jpg" media="(device-width: 430px) and (device-height: 932px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1179-2556.jpg" media="(device-width: 393px) and (device-height: 852px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2556-1179.jpg" media="(device-width: 393px) and (device-height: 852px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1284-2778.jpg" media="(device-width: 428px) and (device-height: 926px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2778-1284.jpg" media="(device-width: 428px) and (device-height: 926px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1170-2532.jpg" media="(device-width: 390px) and (device-height: 844px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2532-1170.jpg" media="(device-width: 390px) and (device-height: 844px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1125-2436.jpg" media="(device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2436-1125.jpg" media="(device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1242-2688.jpg" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2688-1242.jpg" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-828-1792.jpg" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1792-828.jpg" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1242-2208.jpg" media="(device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2208-1242.jpg" media="(device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-750-1334.jpg" media="(device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1334-750.jpg" media="(device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-640-1136.jpg" media="(device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1136-640.jpg" media="(device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/swiper/swiper.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: {"enable":true,"title":"友链 + 外链 + 无限进步！欢迎欣赏和贡献！","addFriendPlaceholder":"昵称（请勿包含博客等字样）：\n网站地址（要求博客地址，请勿提交个人主页）：\n头像图片url（请提供尽可能清晰的图片，我会上传到我自己的图床）：\n描述：\n站点截图（可选）：\n"},
  peoplecanvas: undefined,
  postHeadAiDescription: {"enable":true,"gptName":"小米里的大麦","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":4,"basicWordCount":1999,"key":"93d1622eadde491eb0594b68ade51723.kaEiDD6A3KPzb7xv","Referer":"https://www.minbit.top/"},
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: {"enable":true,"ck":"Jp8wwGQpp21utaFQ","LingQueMonitorID":"Jp8ztDRrxmTf7LDj"},
  greetingBox: {"enable":true,"default":"晚上好👋","list":[{"greeting":"晚安😴","startTime":0,"endTime":5},{"greeting":"早上好鸭👋, 祝你一天好心情！","startTime":6,"endTime":9},{"greeting":"上午好👋, 状态很好，鼓励一下～","startTime":10,"endTime":10},{"greeting":"11点多啦, 在坚持一下就吃饭啦～","startTime":11,"endTime":11},{"greeting":"午安👋, 宝贝","startTime":12,"endTime":14},{"greeting":"🌈充实的一天辛苦啦！","startTime":14,"endTime":18},{"greeting":"19点喽, 奖励一顿丰盛的大餐吧🍔。","startTime":19,"endTime":19},{"greeting":"晚上好👋, 在属于自己的时间好好放松😌~","startTime":20,"endTime":24}]},
  twikooEnvId: 'https://twikoo-olive-one.vercel.app/',
  commentBarrageConfig:{"enable":true,"maxBarrage":10,"barrageTime":5000,"accessToken":"25c96851dd8a790c4819ad4bfbaf153c","mailMd5":"7b12ebc2be80f9159099f6ab0e16573c"},
  music_page_default: "nav_music",
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: {"mode":"both","api":"https://img2color-go.vercel.app/api?img=","cover_change":true},
  authorStatus: {"skills":["🧐 准备中，就快好了，真的！😭","📚 正在学习中，加油！","🎵 喜欢听音乐，喜欢看动漫"]},
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: 小米里的大麦","link":"链接: ","source":"来源: 小米里的大麦","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-right"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: '小米里的大麦',
  title: '040 线程控制',
  postAI: '这篇文章讲述了POSIX线程库（pthread）在Unix系统下的多线程编程接口，它提供了一组函数用于创建、管理和同步多个线程，实现并发和并行处理。pthread线程库是应用层的原生线程库，与操作系统紧密集成，性能开销小，接口统一，可移植性好。它支持线程同步、线程属性设置等丰富功能，线程共享同一进程的内存空间，线程间通信更高效，适用于需要高并发的场景。pthread_t是pthread库定义的线程标识类型，类似于进程中的PID，每个创建的线程都会分配一个唯一的pthread_t值。pthread_create函数用于创建一个新线程，并让它去执行用户定义的函数，其返回值用于判断创建是否成功。线程调度单位是LWP（轻量级进程），而不是进程本身，每个pthread线程对应一个LWP。pthread_self函数用于获取当前线程自身的线程ID。线程等待是通过pthread_join函数实现的，它阻塞当前线程，直到指定的线程结束，并可获取该线程的返回值。线程终止有四种方式：线程函数运行完毕后自动返回、在函数中调用pthread_exit主动退出、其他线程调用pthread_cancel强制取消线程、整个进程退出时所有线程终止。pthread_exit函数用于主动退出当前线程，并返回一个退出值给等待该线程的其他线程。',
  pageFillDescription: '线程控制, 1. POSIX 线程库, 1. 什么是 POSIX 线程库（pthread）, 2. 特点, 3. pthread_t, 1. 功能, 2. 本质, 4. pthread_create —— 创建新线程, 1. 功能, 2. 函数原型, 3. 参数详解, 4. 返回值, 5. 代码示例, 6. 线程监控与查看, 1. ps axj | head -1 amp ps axj | grep pthread_create | grep -v grep, 2. ps -aL | head -1 amp ps -aL | grep pthread_create | grep -v grep, 3. ldd pthread_create, 2. 线程的调度, 1. 线程调度单位到底是谁？, 2. 什么是 LWP（Light Weight Process）？, 3. Linux 中 pthread 与 LWP 的关系？, 4. 为什么说 我们以前接触到的都是单线程进程PID 和 LWP 相等？, 5. pthread_self —— 获取线程 ID, 1. 功能, 2. 函数原型, 3. 返回值, 4. 代码示例, 3. 线程等待, 1. 线程等待是什么？, 2. pthread_join —— 阻塞线程, 1. 功能, 2. 函数原型, 3. 参数详解, 4. 返回值, 5. 代码示例, 3. 线程退出值 x3D 退出码（为啥只能拿这个）？, 1. 为什么线程退出时只能返回一个退出码？, 2. 为什么不是像 fork() 那样返回整型或 exit code？, 4. 线程终止, 1. 线程终止的 4 种方式（核心）, 2. pthread_exit —— 主动退出当前线程, 1. 功能, 2. 函数原型, 3. 参数详解, 4. 返回值, 5. 代码示例, 3. pthread_cancel —— 发送请求, 1. 功能, 2. 函数原型, 3. 参数详解, 4. 返回值, 5. 注意事项, 6. 代码示例, 4. 小结, 5. 线程分离, 1. 线程分离是什么有什么用？, 2. pthread_detach 函数, 1. 功能, 2. 函数原型, 3. 参数说明, 4. 返回值, 5. 代码示例, 3. 线程分离的本质是什么？, 4. 小结, 6. C++ 语言层面上的多线程支持（C++11 起了解）, 1. pthread VS std thread, 2. stdthread vs pthread 对照表, 3. 代码示例, 1. 创建线程, 2. 等待线程结束：join(), 3. 分离线程：detach(), 4. 获取线程 ID, 5. 支持 lambda（超方便！）, 6. 支持类成员函数, 7. 可重入与线程安全, 1. 代码示例：一个不可重入的函数, 2. 可重入函数应该是什么样？, 3. 小结, 8. 代码实战, 1. 多种终止方式, 2. 多线程的协同, 3. 多线程特性综合演示线程控制线程库什么是线程库线程库又称简称是系统下的标准化多线程编程接口标准定义的线程接口它提供了一组函数用于在同一进程内创建管理和同步多个线程实现并发和并行处理线程库是应用层的原生线程库应用层指的是这个线程库并不是系统接口直接提供的而是由第三方帮我们提供的大部分系统都会默认带上该线程库原生的与线程有关的函数构成了一个完整的系列绝大多数函数的名字都是以打头的要使用这些函数库要通过引入头文件链接这些线程函数库时要使用编译器命令的选项特点与操作系统紧密集成性能开销小接口统一可移植性好支持线程同步互斥锁条件变量线程属性设置等丰富功能线程共享同一进程的内存空间代码段堆全局变量等线程间通信更高效直接访问共享数据适用于需要高并发的场景如服务器实时处理功能是库定义的线程标识类型类似于进程中的每个创建的线程都会分配一个唯一的值用来引用和管理该线程本质下通常以整数或指针的形式存在与实现有关我们只需将其当作黑盒标识符配合其他函数即可声明类型声明一个线程标识符创建后中存储的是新线程的创建新线程功能创建一个新线程并让它去执行用户定义的函数函数原型输出参数返回新线程类型线程属性表示默认线程入口函数即线程启动后要执行的函数必须接受参数并返回传给入口函数的参数即线程要执行函数的参数参数详解指向的指针函数返回后通过它获取新线程的线程属性指针可设置线程栈大小分离状态等通常传线程函数指针必须形如传给线程函数的单个参数可是任意指针如结构体基本类型地址需要在函数内强转回原类型返回值线程函数在出错时不设置全局而是直接通过返回值返回错误码成功为失败为非值这与传统系统调用如不同传统调用通常返回并设置这样做是为了避免多线程环境下对全局的竞争提升性能和可移植性尽管每个线程有独立的以兼容其他使用它的代码但建议始终检查函数的返回值来判断错误而不是依赖返回创建成功返回非错误码表示创建失败如资源不足权限问题等代码示例我是子线程是我是主线程编译编译命令链接库必须加在源文件或对象文件之后文件运行结果示例原子性指一个操作要么完全执行成功要么完全没执行在执行过程中不会被中断或分割原子性不可分割性一个操作如果是原子的就不会被其他线程或中断打断外界看起来就像瞬间完成线程监控与查看查看进程和线程列出所有线程输出中列就是线程查看可执行文件依赖列出可执行文件所依赖的共享库可以确认是否已正确链接结合或在中按可切换到线程视图便于实时监控各线程的内存占用情况以下是命令的逐步解析是系统中用于查看进程状态的命令显示所有终端上的进程包括其他用户的进程显示没有控制终端的进程以长格式显示线程信息包括线程进程组会话等只取第一行通常是表头信息过滤出包含字符串的行这些行通常与使用了函数创建的线程相关排除包含自身的行避免干扰显示所有终端上的进程显示线程信息类似于但格式稍有不同显示指定可执行文件或共享库所依赖的动态链接库是提供的底层系统调用用于创建子进程或线程是和的核心实现基础之一相比它更灵活可以通过传入不同的标志位来控制父子进程或线程之间是否共享地址空间文件描述符信号处理等资源从而实现线程效果因为使用较复杂需要手动分配栈空间等只做了解不推荐直接使用头文件函数原型线程的调度线程调度单位到底是谁应用层的线程与内核的是一一对应的调度的是而非在中调度单位是轻量级进程而不是进程本身可以理解为概念含义应用层线程即创建的线程内核每个线程在内核中的调度实体与主线程的与相等子线程的不等于调度单位中调度的是每个线程不是进程整体什么是是内核中的最小调度单位本质上就是一个执行上下文包括程序计数器栈寄存器调度信息等每个都有自己的即在中看到的它们共享所属进程的虚拟内存空间打开的文件信号处理器等资源中与的关系在上每个线程一个创建的每一个线程都会在内核中映射成一个所以是通过调度多个来实现多线程程序并发运行先描述再组织为什么说我们以前接触到的都是单线程进程和相等单线程程序只有一个主线程所以它只有一个而这个的刚好等于进程在主线程中成立但如果在程序中创建了多个线程用就会发现获取进程在每个线程中都一样获取线程每个线程都不同或会列出多个线程每个线程一个内核调度单位系统调度的是线程不是进程这就是为什么多线程程序中真正被调度运行的是每个线程哪些线程先运行哪些后运行完全由调度器决定不是你代码里的顺序每个都可能在不同的核心上并发运行多核获取线程功能获取当前线程自身的线程库中的类型用于线程内部识别自身或与其他线程进行比较函数原型无参数不需要传入任何值它自动返回当前线程对应的返回值类型是表示当前线程的返回值返回当前线程的类型为可以用这个打印出来查看当前线程是谁与其他对比判断是不是同一个线程注意是个不透明类型比较是否相等应使用函数在调试或日志记录中标识线程身份代码示例获取当前线程子线程这是子线程变量的地址主线程自身主线程这是主线程变量的地址运行结果示例子线程这是子线程变量的地址主线程这是主线程变量的地址主线程和子线程的返回值不同说明它们是两个独立的线程两个变量虽然名字类似但位于不同线程的栈上多线程环境下函数的局部变量是线程安全的自动隔离线程等待线程等待是什么在多线程程序中主线程或其他线程可能需要等待某个线程执行完毕后再继续执行这个等待的过程叫做线程等待类似于进程中的系统调用阻塞线程功能阻塞当前线程直到指定的线程结束并可获取该线程的返回值退出码常用于主线程等待子线程完成任务可以在子线程中或使用返回一个结果主线程通过把这个返回值拿到函数原型参数详解参数名类型说明要等待的线程一般是时返回的二级指针接收线程退出时的退出码信息可以为的注意若不关心线程返回什么可以传若关心则要定义传线程退出时返回值会保存在中返回值成功返回失败返回非即错误码如无效的线程线程不存在等代码示例获取线程编号模拟不同耗时所有线程都要分配内存让他们分别乘以子线程完成任务返回结果返回退出码指针线程数组用于传参的线程编号数组创建多个子线程编号从开始主线程等待所有子线程完成阻塞等待子线程退出转换返回值主线程获取到线程的返回结果释放返回结果的内存所有线程任务已完成主线程退出运行结果示例子线程完成任务返回结果主线程获取到线程的返回结果子线程完成任务返回结果主线程获取到线程的返回结果子线程完成任务返回结果主线程获取到线程的返回结果子线程完成任务返回结果主线程获取到线程的返回结果子线程完成任务返回结果主线程获取到线程的返回结果所有线程任务已完成主线程退出线程退出值退出码为啥只能拿这个是主线程阻塞等待子线程完成并获取子线程返回值退出码的唯一方式而这个退出码只能是类型因为模型就规定线程函数只能返回一个指针为什么线程退出时只能返回一个退出码因为线程函数的原型是它只能有一个返回值类型是这是标准设计决定的无法直接返回多个值也不能返回栈上对象因为线程函数退出后栈就销毁了所以如果需要返回复杂数据必须动态申请内存如并指针主线程通过接收并自行释放为什么不是像那样返回整型或是进程级别操作系统可以记录或是线程级别线程之间共享地址空间退出值不需要写入操作系统状态只关心线程退出时返回的那块用户级别的数据指针而不是操作系统的退出码线程终止线程终止的种方式核心在中线程的终止方式主要有以下几种线程函数运行完毕后自动返回这是最自然的退出方式函数体执行到最后线程就自动退出在函数中调用主动退出这种方式适用于希望中途退出线程但又希望返回一个退出值的情况可随时退出线程能设置退出码等效于其他线程调用强制取消线程一种异步控制方式线程不一定立即退出需要处于可取消点如等线程退出码为注意如果线程没有设置为可取消状态无效整个进程退出时所有线程终止当主线程调用或主线程崩溃导致整个进程终止时所有线程也会强制结束粗暴退出会导致线程无法清理资源常见于崩溃或异常退出终止方式触发者是否能传退出码是否立即退出是否安全本线程自己是是推荐本线程自己是是推荐其他线程默认为依赖可取消点谨慎使用崩溃任意线程无法获取是不推荐主动退出当前线程功能主动退出当前线程并返回一个退出值给等待该线程的其他线程比更灵活可在任何地方终止线程适用于线程需要在函数中间提前退出想设置返回值供获取函数原型参数详解线程的退出码可传任意指针或整型强转是返回给的退出值如果线程已分离该值会被忽略返回值无返回值调用后线程立即退出后面的代码不会执行代码示例子线程正在运行主动退出返回值是子线程退出已经退出了并且这一句话不会被执行获取子线程返回值子线程退出码注意在位的中指针是字节所以转成如果转成会报错运行结果示例子线程正在运行子线程退出码发送请求功能向指定线程发送取消请求尝试强制终止它但不一定立即终止适用于主动终止长时间运行或卡死的线程线程之间的控制与协作场景函数原型参数详解目标线程的线程返回值返回值含义成功发送取消请求注意不是线程已退出没有找到指定的线程线程不存在少见线程无效某些实现中使用注意事项不是立即强制终止线程被取消线程必须处于可取消状态且处于取消点常见取消点有等线程取消成功后其退出值为用来判断线程是否被取消如何查一个函数是不是取消点查阅官方文档使用命令在手册中输入搜索会列出所有标准取消点函数是线程库中一个宏常量它用于判断标识线程是否是被强制取消退出的而不是正常执行完毕返回的可以在后检查返回值是否等于它来确认线程状态其本质是个宏它是一个类型的宏常量实际上是特殊指针用作标记不能拿它当做真实的返回值内容使用只能判断它是不是等于某线程的退出码子线程运行中让子线程跑一会儿取消子线程等待子线程结束检查返回值是否为被取消子线程被成功取消返回值子线程正常退出返回值子线程运行中子线程运行中子线程被成功取消返回值代码示例子线程工作中是一个可取消点手动设置一个取消点注意如果使用在这个程序中会无限打印子线程工作中在秒后会自动退出和一样的效果虽然看起来像是死循环但实际上是可以取消的让子线程运行一会发送取消请求等待子线程结束并获取退出码收到取消请求子线程被取消了输出子线程工作中子线程工作中子线程工作中收到取消请求子线程被取消了小结函数主体是谁调用用于哪个线程是否立即终止是否能设置退出码当前线程自己立即是外部线程目标线程非立即返回值为宏线程分离是多线程线程编程中的一个重要概念下面我们从概念入手逐步深入函数及其背后机制讲清楚线程分离的本质线程分离线程分离是什么有什么用在默认情况下模式线程执行完后不会立即释放资源需要其他线程调用与之回收才能释放其占用的资源如线程栈结构等线程分离就是让线程在执行完毕后自动释放自己的资源不再需要其他线程去它防止资源泄漏注意线程一旦结束系统自动回收资源不能再被函数功能将一个线程设置为分离状态使其结束时资源自动释放函数原型参数说明需要设置为分离状态的线程类型返回值成功线程不是或状态无效指定的线程不存在代码示例子线程开始执行子线程执行完毕自动释放资源创建线程默认是状态线程创建失败设置线程为分离状态线程分离失败主线程不等待子线程直接结束运行结果示例主线程不等待子线程直接结束子线程开始执行子线程执行完毕自动释放资源线程分离的本质是什么线程分离的本质就是线程的一个属性叫作默认分离这个属性决定了线程的生命周期如何管理资源状态线程执行完还要别人回收资源状态线程执行完直接自己清理干净别人不能它一旦线程设置为分离状态无法再对它调用否则会导致未定义行为分离线程是否继续执行不取决于主线程是否退出而取决于进程是否还活着分离线程自动回收非分离线程手动回收小结如果创建的线程是短生命周期且不需要结果回传的如后台异步日志写入建议使用或属性设置为分离如果需要线程返回值如子线程计算结果后回传主线程则必须使用并调用线程分离后即使主线程退出分离线程也不一定会结束只有当进程退出才会影响千万不要创建完线程后忘记或否则会发生资源泄漏尤其在线程频繁创建时语言层面上的多线程支持起了解是语言的线程库第三方可在中直接使用但并非语言原生支持从起在语言层面提供了作为标准多线程支持具有更好的类型安全和跨平台性底层在上通常基于实现但对用户透明概念说明是标准定义的语言线程不是的一部分在上通过提供是标准引入的原生线程类属于标准库头文件对比风格起标准库来源非标准标准库起头文件依赖系统原生不支持跨平台编译器支持即可语言风格风格函数指针参数风格支持成员函数函数对象模板类型安全传参易出错模板自动推导类型安全封装性纯函数式调用无类封装是类支持移动语义适合谁系统编程嵌入式高性能定制底层原理应用开发跨平台项目现代开发退出机制析构时自动检查可移植性仅限系统只要编译器支持就可移植底层实现直接调用内核轻量级进程在上通常基于封装但对用户透明编译选项自动链接对照表函数写法说明创建线程等待线程结束线程函数返回即退出获取当前线程睡眠秒代码示例创建线程函数名参数参数会自动拷贝如果是对象想传引用用变量包一层传引用输出等待线程结束必须调用否则程序会崩溃类比一个对象只能一次分离线程不等它让它后台运行获取线程当前线程的线程支持超方便线程运行支持类成员函数工作是对象地址普通函数主线程成员函数子线程我是普通函数线程普通函数线程成员函数线程线程线程中专门处理时间的库工作中睡秒子线程创建线程主线程也干点事主线程主线程工作等待子线程结束类比所有线程结束运行结果示例主线程主线程工作子线程工作中主线程主线程工作子线程工作中子线程工作中所有线程结束可重入与线程安全可重入指的是一个函数可以被多个线程同时调用并且不会互相影响不会出现混乱或崩溃代码示例一个不可重入的函数全局变量所有线程都会调用这个函数每个线程都对同一个加线程最终这个函数是不是可重入的并且运行输出是错乱的因为是全局变量多个线程同时改它结果错乱也是共享资源多个线程同时输出可能出现换行错乱可重入函数应该是什么样完全不使用全局变量只用局部变量每个线程有自己的变量线程这个就是可重入的函数每个线程都自己玩自己的变量互不干扰小结现在用线程只需要记住可重入函数不使用全局变量也不操作共享资源就不会线程混乱目前只需要做到尽量只用局部变量一个线程干自己的事不要访问别人家的变量就能避免的线程问题要注意的点是否说明可重入建议做法用全局变量否每个线程用自己的局部变量打印输出否少用或后续使用加锁保护输出多个线程同时调函数是放心大胆用无影响这些函数本身是线程安全的代码实战多种终止方式线程正常退出方法函数自然返回返回退出值线程使用主动退出方法显式调用返回退出值线程进入无限循环等待被取消方法无限循环等待可取消点方法使用退出注意此会导致整个进程退出不推荐线程调用了整个进程都会终止会结束整个程序不推荐在线程中用创建四个线程等待线程退出正常主线程线程退出退出值返回等待线程退出主线程线程退出退出值返回取消线程等它跑一下主线程线程被取消主线程线程退出值等它跑一下等待线程退出会导致其他线程无法正常退出整个进程终止主线程线程退出退出值终止多线程的协同枚举线程运行状态正常异常构造函数传入线程名字起始数结束数线程编号析构函数线程的实际任务函数计算指定区间的和线程运行完毕计算结束线程结束时返回一个指针被主线程获取线程名称区间起点区间终点线程编号计算结果线程状态线程入口函数全局函数静态函数是的类型转换运算符用于在编译时进行类型安全的指针转换执行实际任务内部调用退出线程实际不会执行到这里因为中直接退出了线程总线程数量线程数组每个线程绑定一个任务对象每个线程负责计算个数的和区间起始点创建线程创建一个任务对象创建线程执行函数参数传入任务对象指针保证顺序输出演示效果等待线程结束收集结果等待线程退出并获取其返回值计算结果执行失败释放任务对象资源所有线程协作完成多线程特性综合演示是提供的线程局部存储关键字用于声明在函数内的变量每个线程都有自己的副本互不干扰每个线程独有每个线程独有线程数据结构线程名称线程编号将转换为十六进制字符串便于显示使用格式化初始化线程数据设置线程名称设置线程线程执行函数所有线程都执行这个函数但每个线程的数据是独立的立即将当前线程设置为分离状态这样线程结束后会自动释放资源无需主线程获取当前线程和进程当前线程的进程所有线程共享初始化线程局部变量每个线程有不同的值每个线程都有自己的副本启动线程进程线程局部变量减少循环次数便于观察展示线程的关键特性同一进程内的所有线程共享进程每个线程有自己的线程每个线程有自己的线程局部存储变量第次执行线程进程局部局部休眠秒修改线程局部变量只影响当前线程执行完毕清理分配的内存返回表示线程正常结束主线程进程存储所有线程的容器开始创建个线程创建多个线程线程变量为每个线程分配独立的数据初始化线程数据创建线程失败创建失败时释放内存成功创建线程保存线程延时秒确保线程正确启动所有线程创建完成主线程等待给线程一些执行时间尝试对分离线程进行操作尝试对分离线程进行操作这会失败对线程执行的结果由于线程已被分离这里会返回无效参数线程共享进程资源如进程文件描述符等每个线程有自己的线程和栈空间关键字创建线程局部存储变量分离线程结束后自动释放资源分离线程不能被回收线程执行是并发的输出顺序不同主线程继续执行中主线程执行完毕程序退出',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-07-23 12:00:00',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 10 || hour >= 20
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css"><link rel="stylesheet" href="/custom/css/font.css"><link rel="stylesheet" href="/custom/css/bilibili.css"><meta name="generator" content="Hexo 7.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://zycs-img-8kd.pages.dev/v2/bFRjgdX.jpeg"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><div class="back-home-button"><i class="anzhiyufont anzhiyu-icon-grip-vertical"></i><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">社交</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://github.com/huangcancan-xbc" title="GitHub"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="GitHub"/><span class="back-menu-item-text">GitHub</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://space.bilibili.com/1918272544" title="哔哩哔哩"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="哔哩哔哩"/><span class="back-menu-item-text">哔哩哔哩</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://gitee.com/huang-cancan-xbc" title="Gitee"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="Gitee"/><span class="back-menu-item-text">Gitee</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">博客</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://blog.csdn.net/Huangcancan666?type=blog" title="CSDN"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="CSDN"/><span class="back-menu-item-text">CSDN</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://juejin.cn/user/3230789931118109" title="稀土掘金"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="稀土掘金"/><span class="back-menu-item-text">稀土掘金</span></a></div></div></div></div><a id="site-name" href="/" accesskey="h"><div class="title">小米里的大麦</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/charts/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 统计</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 外链</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/music/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li></ul></div></div></div><div id="nav-right"><div id="nav-naoDark"><div class="container"><div class="components"><div class="main-button"><div class="moon"></div><div class="moon"></div><div class="moon"></div></div><div class="daytime-backgrond"></div><div class="daytime-backgrond"></div><div class="daytime-backgrond"></div><div class="cloud"><div class="cloud-son"></div><div class="cloud-son"></div><div class="cloud-son"></div><div class="cloud-son"></div><div class="cloud-son"></div><div class="cloud-son"></div></div><div class="cloud-light"><div class="cloud-son"></div><div class="cloud-son"></div><div class="cloud-son"></div><div class="cloud-son"></div><div class="cloud-son"></div><div class="cloud-son"></div></div><div class="stars"><div class="star big"><div class="star-son"></div><div class="star-son"></div><div class="star-son"></div><div class="star-son"></div></div><div class="star big"><div class="star-son"></div><div class="star-son"></div><div class="star-son"></div><div class="star-son"></div></div><div class="star medium"><div class="star-son"></div><div class="star-son"></div><div class="star-son"></div><div class="star-son"></div></div><div class="star medium"><div class="star-son"></div><div class="star-son"></div><div class="star-son"></div><div class="star-son"></div></div><div class="star small"><div class="star-son"></div><div class="star-son"></div><div class="star-son"></div><div class="star-son"></div></div><div class="star small"><div class="star-son"></div><div class="star-son"></div><div class="star-son"></div><div class="star-son"></div></div></div></div></div></div><div class="nav-button only-home" id="travellings_button" title="随机前往一个开往项目网站"><a class="site-page" onclick="anzhiyu.totraveling()" title="随机前往一个开往项目网站" href="javascript:void(0);" rel="external nofollow" data-pjax-state="external"><i class="anzhiyufont anzhiyu-icon-train"></i></a></div><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><div class="nav-button" id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" title="搜索🔍" accesskey="s"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span> 搜索</span></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://zycs-img-8kd.pages.dev/v2/REbVGGL.png" target="_blank"><img class="post-qr-code-img" alt="微信" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://zycs-img-8kd.pages.dev/v2/REbVGGL.png"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://zycs-img-8kd.pages.dev/v2/1UUolM0.png" target="_blank"><img class="post-qr-code-img" alt="支付宝" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://zycs-img-8kd.pages.dev/v2/1UUolM0.png"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/C/" style="font-size: 1.05rem;">C++<sup>8</sup></a><a href="/tags/Git/" style="font-size: 1.05rem;">Git<sup>3</sup></a><a href="/tags/IO/" style="font-size: 1.05rem;">IO<sup>3</sup></a><a href="/tags/Linux/" style="font-size: 1.05rem;">Linux<sup>50</sup></a><a href="/tags/Obsidian/" style="font-size: 1.05rem;">Obsidian<sup>1</sup></a><a href="/tags/STL/" style="font-size: 1.05rem;">STL<sup>2</sup></a><a href="/tags/VS-Code/" style="font-size: 1.05rem;">VS Code<sup>1</sup></a><a href="/tags/%E4%BF%A1%E5%8F%B7/" style="font-size: 1.05rem;">信号<sup>3</sup></a><a href="/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" style="font-size: 1.05rem;">内存管理<sup>1</sup></a><a href="/tags/%E5%8E%86%E7%A8%8B/" style="font-size: 1.05rem;">历程<sup>1</sup></a><a href="/tags/%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/" style="font-size: 1.05rem;">地址空间<sup>6</sup></a><a href="/tags/%E6%95%B0%E5%AD%A6/" style="font-size: 1.05rem;">数学<sup>1</sup></a><a href="/tags/%E6%A8%A1%E6%9D%BF/" style="font-size: 1.05rem;">模板<sup>1</sup></a><a href="/tags/%E7%AE%A1%E9%81%93/" style="font-size: 1.05rem;">管道<sup>2</sup></a><a href="/tags/%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/" style="font-size: 1.05rem;">类与对象<sup>3</sup></a><a href="/tags/%E7%BA%BF%E7%A8%8B/" style="font-size: 1.05rem;">线程<sup>4</sup></a><a href="/tags/%E7%BD%91%E7%AB%99/" style="font-size: 1.05rem;">网站<sup>2</sup></a><a href="/tags/%E7%BD%91%E7%BB%9C/" style="font-size: 1.05rem;">网络<sup>6</sup></a><a href="/tags/%E8%BF%9B%E7%A8%8B/" style="font-size: 1.05rem;">进程<sup>15</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span><a class="card-more-btn" href="/archives/" title="查看更多">
    <i class="anzhiyufont anzhiyu-icon-angle-right"></i></a></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/09/"><span class="card-archive-list-date">九月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/08/"><span class="card-archive-list-date">八月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">8</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/07/"><span class="card-archive-list-date">七月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">9</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/06/"><span class="card-archive-list-date">六月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">6</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/05/"><span class="card-archive-list-date">五月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">9</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/04/"><span class="card-archive-list-date">四月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">8</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/03/"><span class="card-archive-list-date">三月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">10</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/02/"><span class="card-archive-list-date">二月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">9</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item on" id="consoleCommentBarrage" onclick="anzhiyu.switchCommentBarrage()" title="热评开关"><a class="commentBarrage"><i class="anzhiyufont anzhiyu-icon-message"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div><div id="console-naoDark"><div class="container"><div class="components"><div class="main-button"><div class="moon"></div><div class="moon"></div><div class="moon"></div></div><div class="daytime-backgrond"></div><div class="daytime-backgrond"></div><div class="daytime-backgrond"></div><div class="cloud"><div class="cloud-son"></div><div class="cloud-son"></div><div class="cloud-son"></div><div class="cloud-son"></div><div class="cloud-son"></div><div class="cloud-son"></div></div><div class="cloud-light"><div class="cloud-son"></div><div class="cloud-son"></div><div class="cloud-son"></div><div class="cloud-son"></div><div class="cloud-son"></div><div class="cloud-son"></div></div><div class="stars"><div class="star big"><div class="star-son"></div><div class="star-son"></div><div class="star-son"></div><div class="star-son"></div></div><div class="star big"><div class="star-son"></div><div class="star-son"></div><div class="star-son"></div><div class="star-son"></div></div><div class="star medium"><div class="star-son"></div><div class="star-son"></div><div class="star-son"></div><div class="star-son"></div></div><div class="star medium"><div class="star-son"></div><div class="star-son"></div><div class="star-son"></div><div class="star-son"></div></div><div class="star small"><div class="star-son"></div><div class="star-son"></div><div class="star-son"></div><div class="star-son"></div></div><div class="star small"><div class="star-son"></div><div class="star-son"></div><div class="star-son"></div><div class="star-son"></div></div></div></div></div></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/Linux/" itemprop="url">Linux</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/Linux/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>Linux</span></a><a class="article-meta__tags" href="/tags/%E7%BA%BF%E7%A8%8B/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>线程</span></a></span></div></div><h1 class="post-title" itemprop="name headline">040 线程控制</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2025-07-23T04:00:00.000Z" title="发表于 2025-07-23 12:00:00">2025-07-23</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2025-07-23T04:00:00.000Z" title="更新于 2025-07-23 12:00:00">2025-07-23</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="post-meta-wordcount"><i class="anzhiyufont anzhiyu-icon-file-word post-meta-icon" title="文章字数"></i><span class="post-meta-label" title="文章字数">字数总计:</span><span class="word-count" title="文章字数">10k</span><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-clock post-meta-icon" title="阅读时长"></i><span class="post-meta-label" title="阅读时长">阅读时长:</span><span>38分钟</span></span><span class="post-meta-separator"></span><span class="post-meta-pv-cv" id="" data-flag-title="040 线程控制"><i class="anzhiyufont anzhiyu-icon-fw-eye post-meta-icon"></i><span class="post-meta-label" title="阅读量">阅读量:</span><span id="busuanzi_value_page_pv"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></span><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为西安"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>西安</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="https://zycs-img-8kd.pages.dev/v2/0k1JltC.jpeg?_r_=94c0b562-a46b-881d-a1b9-9cfa65326bf6"></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><div class="post-ai-description"><div class="ai-title"><i class="anzhiyufont anzhiyu-icon-bilibili"></i><div class="ai-title-text">AI-摘要</div><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right"></i><i class="anzhiyufont anzhiyu-icon-circle-dot" title="朗读摘要"></i><div id="ai-tag">小米里的大麦 GPT</div></div><div class="ai-explanation">AI初始化中...</div><div class="ai-btn-box"><div class="ai-btn-item">介绍自己 🙈</div><div class="ai-btn-item">生成本文简介 👋</div><div class="ai-btn-item">推荐相关文章 📖</div><div class="ai-btn-item">前往主页 🏠</div><div class="ai-btn-item" id="go-tianli-blog">前往爱发电购买</div></div><script data-pjax src="/js/anzhiyu/ai_abstract.js"></script></div><article class="post-content" id="article-container" itemscope itemtype="https://www.minbit.top/posts/21804.html"><header><a class="post-meta-categories" href="/categories/Linux/" itemprop="url">Linux</a><a href="/tags/Linux/" tabindex="-1" itemprop="url">Linux</a><a href="/tags/%E7%BA%BF%E7%A8%8B/" tabindex="-1" itemprop="url">线程</a><h1 id="CrawlerTitle" itemprop="name headline">040 线程控制</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">小米里的大麦</span><time itemprop="dateCreated datePublished" datetime="2025-07-23T04:00:00.000Z" title="发表于 2025-07-23 12:00:00">2025-07-23</time><time itemprop="dateCreated datePublished" datetime="2025-07-23T04:00:00.000Z" title="更新于 2025-07-23 12:00:00">2025-07-23</time></header><h1 id="线程控制"><a href="#线程控制" class="headerlink" title="线程控制"></a>线程控制</h1><h2 id="1-POSIX-线程库"><a href="#1-POSIX-线程库" class="headerlink" title="1. POSIX 线程库"></a>1. POSIX 线程库</h2><h3 id="1-什么是-POSIX-线程库（pthread）"><a href="#1-什么是-POSIX-线程库（pthread）" class="headerlink" title="1. 什么是 POSIX 线程库（pthread）"></a>1. 什么是 POSIX 线程库（pthread）</h3><p>POSIX（Portable Operating System Interface）线程库，又称（简称） pthread（POSIX Threads），是 Unix 系统下的标准化多线程编程接口（IEEE POSIX 标准（IEEE 1003.1c）定义的线程接口）。它提供了一组函数，用于在同一进程内创建、管理和同步多个线程，实现并发和并行处理。</p>
<p><strong>pthread 线程库是应用层的原生线程库： 应用层指的是这个线程库并不是系统接口直接提供的，而是由第三方帮我们提供的。大部分 Linux 系统都会默认带上该线程库（原生的）。与线程有关的函数构成了一个完整的系列，绝大多数函数的名字都是以 <code>pthread_</code> 打头的。要使用这些函数库，要通过引入头文件 <code>&lt;pthreaad.h&gt;</code>，链接这些线程函数库时，要使用编译器命令的 <code>-lpthread</code> 选项。</strong></p>
<h3 id="2-特点"><a href="#2-特点" class="headerlink" title="2. 特点"></a>2. 特点</h3><ol>
<li>与操作系统紧密集成，性能开销小。</li>
<li>接口统一，可移植性好。</li>
<li>支持线程同步（互斥锁、条件变量）、线程属性设置等丰富功能。</li>
<li>线程共享同一进程的内存空间（代码段、堆、全局变量等）。</li>
<li>线程间通信更高效（直接访问共享数据）。</li>
<li>适用于需要高并发的场景（如服务器、实时处理）。</li>
</ol>
<hr>
<h3 id="3-pthread-t"><a href="#3-pthread-t" class="headerlink" title="3. pthread_t"></a>3. pthread_t</h3><h4 id="1-功能"><a href="#1-功能" class="headerlink" title="1. 功能"></a>1. 功能</h4><p><code>pthread_t</code> 是 pthread 库定义的线程标识类型，类似于进程中的 PID。每个创建的线程都会分配一个唯一的 <code>pthread_t</code> 值，用来引用和管理该线程。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250723152545138.png" alt="image-20250723152544973"></p>
<h4 id="2-本质"><a href="#2-本质" class="headerlink" title="2. 本质"></a>2. 本质</h4><p>Linux 下，<code>pthread_t</code> 通常以整数或指针的形式存在（与 glibc 实现有关），我们只需将其当作“黑盒”标识符，配合其他 pthread 函数即可。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span>      <span class="comment">// 声明 pthread_t 类型</span></span></span><br><span class="line"><span class="type">pthread_t</span> tid;            <span class="comment">// 声明一个线程标识符，创建后，tid 中存储的是新线程的 ID</span></span><br></pre></td></tr></table></figure>

<h3 id="4-pthread-create-——-创建新线程"><a href="#4-pthread-create-——-创建新线程" class="headerlink" title="4. pthread_create —— 创建新线程"></a>4. pthread_create —— 创建新线程</h3><h4 id="1-功能-1"><a href="#1-功能-1" class="headerlink" title="1. 功能"></a>1. 功能</h4><p>创建一个新线程，并让它去执行用户定义的函数。</p>
<h4 id="2-函数原型"><a href="#2-函数原型" class="headerlink" title="2. 函数原型"></a>2. 函数原型</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_create</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">pthread_t</span> *thread,                  <span class="comment">// 输出参数：返回新线程 ID（pthread_t类型）</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> <span class="type">pthread_attr_t</span> *attr,         <span class="comment">// 线程属性，NULL 表示默认</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">void</span> *(*start_routine)(<span class="type">void</span> *),     <span class="comment">// 线程入口函数，即线程启动后要执行的函数（必须接受void*参数并返回void*）</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">void</span> *arg                           <span class="comment">// 传给入口函数 start_routine 的参数，即线程（要执行）函数的参数</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="3-参数详解"><a href="#3-参数详解" class="headerlink" title="3. 参数详解"></a>3. 参数详解</h4><ul>
<li><code>thread</code>：指向 <code>pthread_t</code> 的指针，函数返回后通过它获取新线程的 ID；</li>
<li><code>attr</code>：线程属性指针，可设置线程栈大小、分离状态等，<strong>通常传 <code>NULL</code>&#x2F;<code>nullptr</code></strong>；</li>
<li><code>start_routine</code>：线程函数指针，必须形如 <code>void* func(void*)</code>；</li>
<li><code>arg</code>：传给线程函数的单个参数，可是任意指针（如结构体、基本类型地址），需要在函数内强转回原类型。</li>
</ul>
<h4 id="4-返回值"><a href="#4-返回值" class="headerlink" title="4. 返回值"></a>4. 返回值</h4><p>POSIX 线程（pthreads）函数在出错时 <strong>不设置全局 errno</strong> ，而是 <strong>直接通过返回值返回错误码</strong> （成功为 0，失败为非 0 值）。这与传统系统调用（如 open、read）不同，传统调用通常返回-1 并设置 errno。pthreads 这样做是为了避免多线程环境下对全局 errno 的竞争，提升性能和可移植性。尽管每个线程有独立的 errno 以兼容其他使用它的代码，但 <strong>建议始终检查 pthreads 函数的返回值来判断错误</strong> ，而不是依赖 errno。</p>
<ul>
<li>返回 <code>0</code>：创建成功；</li>
<li>返回非 <code>0</code>：错误码，表示创建失败（如资源不足、权限问题等）。</li>
</ul>
<h4 id="5-代码示例"><a href="#5-代码示例" class="headerlink" title="5. 代码示例"></a>5. 代码示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">func</span><span class="params">(<span class="type">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span>* str = (<span class="type">char</span>*)arg;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;tid, <span class="literal">nullptr</span>, func, (<span class="type">void</span>*)<span class="string">&quot;我是子线程，ID是：123456&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;我是主线程!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>编译（-lpthread）：</strong></p>
<ol>
<li><p><strong>编译命令</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -o pthread_create pthread_create.cc -lpthread</span><br></pre></td></tr></table></figure>

<p><code>-lpthread</code>：链接 pthread 库，必须加在源文件或对象文件之后。</p>
</li>
<li><p>makefile 文件：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">pthread_create:pthread_create.cc</span></span><br><span class="line">	g++ -o <span class="variable">$@</span> <span class="variable">$^</span> -std=c++11 -lpthread</span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -f pthread_create</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>运行结果示例：</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250722153957144.png" alt="image-20250722153949184"></p>
<blockquote>
<p><strong>原子性</strong> 指一个操作要么 <strong>完全执行成功</strong> ，要么 <strong>完全没执行</strong> ，在执行过程中 <strong>不会被中断或分割</strong> 。<strong>原子性 &#x3D; 不可分割性</strong>，一个操作如果是原子的，就 <strong>不会被其他线程或中断打断</strong> ，外界看起来就像“瞬间完成”。</p>
</blockquote>
<h4 id="6-线程监控与查看"><a href="#6-线程监控与查看" class="headerlink" title="6. 线程监控与查看"></a>6. 线程监控与查看</h4><ol>
<li><p><strong>查看进程和线程</strong></p>
<ul>
<li><p><code>ps -AL</code>：列出所有线程（Lightweight Process，LWP）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -AL | grep pthread_create		<span class="comment"># 输出中，LWP 列就是线程 ID</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>查看可执行文件依赖</strong></p>
<ul>
<li><p><code>ldd</code>：列出可执行文件所依赖的共享库</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ldd pthread_create			<span class="comment"># 可以确认是否已正确链接 libpthread.so</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>结合 top 或 htop</strong></p>
<ul>
<li>在 <code>top</code> 中，按 <code>H</code> 可切换到线程视图；</li>
<li>便于实时监控各线程的 CPU&#x2F;内存占用情况。</li>
</ul>
</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Linux/20250722161316776.png" alt="image-20250722161316674"></p>
<blockquote>
<p>以下是命令的逐步解析：</p>
<h5 id="1-ps-axj-head-1-ps-axj-grep-pthread-create-grep-v-grep"><a href="#1-ps-axj-head-1-ps-axj-grep-pthread-create-grep-v-grep" class="headerlink" title="1. ps axj | head -1 &amp; ps axj | grep pthread_create | grep -v grep"></a>1. <code>ps axj | head -1 &amp; ps axj | grep pthread_create | grep -v grep</code></h5><ul>
<li><strong><code>ps axj</code></strong> :</li>
<li><code>ps</code> 是 Linux 系统中用于查看进程状态的命令。</li>
<li><code>-a</code>：显示所有终端上的进程，包括其他用户的进程。</li>
<li><code>-x</code>：显示没有控制终端的进程。</li>
<li><code>-j</code>：以长格式显示线程信息，包括线程 ID、进程组 ID、会话 ID 等。</li>
<li><strong><code>head -1</code></strong>：只取第一行，通常是表头信息。</li>
<li><strong><code>grep pthread_create</code></strong>：过滤出包含字符串 <code>pthread_create</code> 的行，这些行通常与使用了 <code>pthread_create</code> 函数创建的线程相关。</li>
<li><strong><code>grep -v grep</code></strong>：排除包含 <code>grep</code> 自身的行，避免干扰。</li>
</ul>
<h5 id="2-ps-aL-head-1-ps-aL-grep-pthread-create-grep-v-grep"><a href="#2-ps-aL-head-1-ps-aL-grep-pthread-create-grep-v-grep" class="headerlink" title="2. ps -aL | head -1 &amp; ps -aL | grep pthread_create | grep -v grep"></a>2. <code>ps -aL | head -1 &amp; ps -aL | grep pthread_create | grep -v grep</code></h5><ul>
<li><code>ps -aL</code>：</li>
<li><code>-a</code>：显示所有终端上的进程。</li>
<li><code>-L</code>：显示线程信息，类似于 <code>-j</code>，但格式稍有不同。</li>
</ul>
<h5 id="3-ldd-pthread-create"><a href="#3-ldd-pthread-create" class="headerlink" title="3. ldd pthread_create"></a>3. <code>ldd pthread_create</code></h5><ul>
<li><code>ldd</code>：显示指定可执行文件或共享库所依赖的动态链接库。</li>
</ul>
</blockquote>
<blockquote>
<p><code>clone()</code> 是 Linux 提供的底层系统调用，用于创建子进程或线程，是 <code>fork()</code> 和 <code>pthread_create()</code> 的核心实现基础之一。相比 <code>fork()</code>，它更灵活，可以通过传入不同的标志位来控制父子进程（或线程）之间是否共享地址空间、文件描述符、信号处理等资源，从而实现“线程”效果。因为使用较复杂（需要手动分配栈空间等），只做了解，不推荐直接使用。<strong>头文件：</strong> <code>&lt;sched.h&gt;</code>，<strong>函数原型：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="function"><span class="type">int</span> <span class="title">clone</span><span class="params">(<span class="type">int</span> (*fn)(<span class="type">void</span> *), <span class="type">void</span> *child_stack, <span class="type">int</span> flags, <span class="type">void</span> *arg, ...)</span></span>;</span><br></pre></td></tr></table></figure></blockquote>
<h2 id="2-线程的调度"><a href="#2-线程的调度" class="headerlink" title="2. 线程的调度"></a>2. 线程的调度</h2><h3 id="1-线程调度单位到底是谁？"><a href="#1-线程调度单位到底是谁？" class="headerlink" title="1. 线程调度单位到底是谁？"></a>1. 线程调度单位到底是谁？</h3><blockquote>
<p><strong>“应用层的线程与内核的 LWP 是一一对应的，调度的是 LWP 而非 PID。”在 Linux 中：调度单位是 LWP（轻量级进程），而不是进程本身（PID）。</strong></p>
</blockquote>
<p>可以理解为：</p>
<table>
<thead>
<tr>
<th>概念</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>应用层线程</td>
<td>即 <code>pthread_create</code> 创建的线程</td>
</tr>
<tr>
<td>内核 LWP</td>
<td>每个线程在内核中的调度实体</td>
</tr>
<tr>
<td>PID 与 LWP</td>
<td>主线程的 LWP ID 与 PID 相等，子线程的 LWP ID 不等于 PID</td>
</tr>
<tr>
<td>调度单位</td>
<td>Linux 中调度的是每个线程（LWP），不是进程整体</td>
</tr>
</tbody></table>
<h3 id="2-什么是-LWP（Light-Weight-Process）？"><a href="#2-什么是-LWP（Light-Weight-Process）？" class="headerlink" title="2. 什么是 LWP（Light Weight Process）？"></a>2. 什么是 LWP（Light Weight Process）？</h3><p>LWP 是 Linux 内核中的 <strong>最小调度单位</strong>，本质上就是一个“执行上下文”：包括程序计数器、栈、寄存器、调度信息等。每个 LWP 都有自己的 ID，即在 <code>ps -AL</code> 中看到的 <strong>LWP（Thread ID）</strong>。它们共享 <strong>所属进程的虚拟内存空间</strong>、打开的文件、信号处理器等资源。</p>
<h3 id="3-Linux-中-pthread-与-LWP-的关系？"><a href="#3-Linux-中-pthread-与-LWP-的关系？" class="headerlink" title="3. Linux 中 pthread 与 LWP 的关系？"></a>3. Linux 中 pthread 与 LWP 的关系？</h3><p>在 Linux 上，<strong>每个 pthread 线程 &#x3D; 一个 LWP</strong>。</p>
<ul>
<li><code>pthread_create()</code> 创建的每一个线程，都会在内核中映射成一个 LWP；</li>
<li>所以 Linux 是通过调度多个 LWP 来实现多线程程序并发运行（先描述再组织）。</li>
</ul>
<h3 id="4-为什么说-“我们以前接触到的都是单线程进程，PID-和-LWP-相等”？"><a href="#4-为什么说-“我们以前接触到的都是单线程进程，PID-和-LWP-相等”？" class="headerlink" title="4. 为什么说 “我们以前接触到的都是单线程进程，PID 和 LWP 相等”？"></a>4. 为什么说 “我们以前接触到的都是单线程进程，PID 和 LWP 相等”？</h3><p>单线程程序只有一个主线程，所以它只有一个 LWP。而这个 LWP 的 ID（TID）刚好等于进程 ID（PID），<code>getpid() == gettid()</code>（在主线程中成立）。但如果在程序中创建了多个线程（用 pthread），就会发现：</p>
<ul>
<li><code>getpid()</code>（获取进程 ID）在每个线程中都一样；</li>
<li><code>gettid()</code>（获取线程 ID）每个线程都不同；</li>
<li><code>ps -AL</code> 或 <code>top -H</code> 会列出多个线程，每个线程一个 TID（内核调度单位）；</li>
</ul>
<p><strong>系统调度的是 LWP（线程），不是进程（PID）</strong>，这就是为什么：</p>
<ul>
<li><strong>多线程程序中，真正被调度运行的是每个线程（LWP）</strong>。</li>
<li>哪些线程先运行，哪些后运行，完全由调度器决定（不是你代码里的顺序）。</li>
<li>每个 LWP 都可能在不同的 CPU 核心上并发运行（多核 CPU）。</li>
</ul>
<h3 id="5-pthread-self-——-获取线程-ID"><a href="#5-pthread-self-——-获取线程-ID" class="headerlink" title="5. pthread_self —— 获取线程 ID"></a>5. pthread_self —— 获取线程 ID</h3><h4 id="1-功能-2"><a href="#1-功能-2" class="headerlink" title="1. 功能"></a>1. 功能</h4><p>获取 <strong>当前线程自身的线程 ID</strong>（pthread 库中的 ID 类型 <code>pthread_t</code>），用于线程内部识别自身，或与其他线程 ID 进行比较。</p>
<h4 id="2-函数原型-1"><a href="#2-函数原型-1" class="headerlink" title="2. 函数原型"></a>2. 函数原型</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">pthread_t</span> <span class="title">pthread_self</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>无参数，不需要传入任何值，它自动返回当前线程对应的 <code>pthread_t</code>。</li>
<li>返回值类型是 <code>pthread_t</code>，表示当前线程的 ID。</li>
</ul>
<h4 id="3-返回值"><a href="#3-返回值" class="headerlink" title="3. 返回值"></a>3. 返回值</h4><p>返回 <strong>当前线程的 ID</strong>（类型为 <code>pthread_t</code>），可以用这个 ID：</p>
<ul>
<li>打印出来查看当前线程是谁；</li>
<li>与其他 <code>pthread_t</code> 对比，判断是不是同一个线程；注意：<code>pthread_t</code> 是个不透明类型，比较是否相等，应使用 <code>pthread_equal()</code> 函数。</li>
<li>在调试或日志记录中标识线程身份。</li>
</ul>
<h4 id="4-代码示例"><a href="#4-代码示例" class="headerlink" title="4. 代码示例"></a>4. 代码示例</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">func</span><span class="params">(<span class="type">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid = <span class="built_in">pthread_self</span>();         <span class="comment">// 获取当前线程 ID</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;子线程 pthread_self() = &quot;</span> &lt;&lt; tid &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;这是子线程 pthread_t 变量的地址 %p\n&quot;</span>, &amp;tid);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;tid, <span class="literal">nullptr</span>, func, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">pthread_t</span> main_tid = <span class="built_in">pthread_self</span>();    <span class="comment">// 主线程自身 ID</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;主线程 pthread_self() = &quot;</span> &lt;&lt; main_tid &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;这是主线程 pthread_t 变量的地址 %p\n&quot;</span>, &amp;main_tid);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[hcc@hcss-ecs-be68 Threads]$ ./pthread_self </span><br><span class="line">子线程 pthread_self() = 140119442462464</span><br><span class="line">这是子线程 pthread_t 变量的地址 0x7f7019980ef8</span><br><span class="line">主线程 pthread_self() = 140119459862336</span><br><span class="line">这是主线程 pthread_t 变量的地址 0x7ffebae7f9e0</span><br></pre></td></tr></table></figure>

<p>主线程和子线程的 <code>pthread_self()</code> 返回值不同，说明它们是两个独立的线程。两个 <code>tid</code> 变量虽然名字类似，但位于不同线程的栈上。<strong>多线程环境下，函数的局部变量是线程安全的（自动隔离）</strong>。</p>
<hr>
<h2 id="3-线程等待"><a href="#3-线程等待" class="headerlink" title="3. 线程等待"></a>3. 线程等待</h2><h3 id="1-线程等待是什么？"><a href="#1-线程等待是什么？" class="headerlink" title="1. 线程等待是什么？"></a>1. 线程等待是什么？</h3><p>在多线程程序中，主线程或其他线程可能需要等待某个线程执行完毕后再继续执行。这个等待的过程叫做 <strong>线程等待</strong> 。类似于进程中的 <code>wait()</code> 系统调用。 </p>
<h3 id="2-pthread-join-——-阻塞线程"><a href="#2-pthread-join-——-阻塞线程" class="headerlink" title="2. pthread_join —— 阻塞线程"></a>2. pthread_join —— 阻塞线程</h3><h4 id="1-功能-3"><a href="#1-功能-3" class="headerlink" title="1. 功能"></a>1. 功能</h4><p><strong>阻塞当前线程</strong>，直到指定的线程结束，并可 <strong>获取该线程的返回值（退出码）</strong>。</p>
<ul>
<li>常用于 <strong>主线程等待子线程完成任务</strong>；</li>
<li>可以在子线程中 <code>return</code> 或使用 <code>pthread_exit()</code> 返回一个结果；</li>
<li>主线程通过 <code>pthread_join()</code> 把这个返回值拿到。</li>
</ul>
<h4 id="2-函数原型-2"><a href="#2-函数原型-2" class="headerlink" title="2. 函数原型"></a>2. 函数原型</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_join</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="type">void</span> **retval)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="3-参数详解-1"><a href="#3-参数详解-1" class="headerlink" title="3. 参数详解"></a>3. 参数详解</h4><table>
<thead>
<tr>
<th>参数名</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>thread</code></td>
<td><code>pthread_t</code></td>
<td>要等待的线程 ID，一般是 <code>pthread_create</code> 时返回的</td>
</tr>
<tr>
<td><code>retval</code></td>
<td><code>void**</code></td>
<td>二级指针，接收线程退出时的退出码信息（可以为 <code>NULL</code>）</td>
</tr>
</tbody></table>
<p>retval 的注意：</p>
<ul>
<li>若不关心线程返回什么，可以传 <code>NULL</code>&#x2F;<code>nullptr</code>；</li>
<li>若关心，则要定义 <code>void* result</code>，传 <code>&amp;result</code>，线程退出时返回值会保存在 <code>result</code> 中。</li>
</ul>
<h4 id="4-返回值-1"><a href="#4-返回值-1" class="headerlink" title="4. 返回值"></a>4. 返回值</h4><ul>
<li>成功：返回 0。</li>
<li>失败：返回非 0，即错误码（如无效的线程 ID、线程不存在等）。</li>
</ul>
<h4 id="5-代码示例-1"><a href="#5-代码示例-1" class="headerlink" title="5. 代码示例"></a>5. 代码示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">func</span><span class="params">(<span class="type">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> id = *(<span class="type">int</span>*)arg;                    <span class="comment">// 获取线程编号</span></span><br><span class="line">    <span class="built_in">sleep</span>(id);                              <span class="comment">// 模拟不同耗时</span></span><br><span class="line">    <span class="type">int</span>* result = <span class="keyword">new</span> <span class="built_in">int</span>(id * <span class="number">10</span>);         <span class="comment">// 所有线程都要分配内存，让他们分别乘以 10</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;子线程 &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; 完成任务，返回结果 = &quot;</span> &lt;&lt; *result &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>*)result;                   <span class="comment">// 返回退出码（指针）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tids[<span class="number">5</span>];                      <span class="comment">// 线程 ID 数组</span></span><br><span class="line">    <span class="type">int</span> ids[<span class="number">5</span>];                             <span class="comment">// 用于传参的线程编号数组</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)             <span class="comment">// 创建多个子线程</span></span><br><span class="line">    &#123;</span><br><span class="line">        ids[i] = i + <span class="number">1</span>;                     <span class="comment">// 编号从 1 开始</span></span><br><span class="line">        <span class="built_in">pthread_create</span>(&amp;tids[i], <span class="literal">nullptr</span>, func, &amp;ids[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)             <span class="comment">// 主线程等待所有子线程完成</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">void</span>* retval = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="built_in">pthread_join</span>(tids[i], &amp;retval);     <span class="comment">// 阻塞等待子线程退出</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>* res = (<span class="type">int</span>*)retval;            <span class="comment">// 转换返回值</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;主线程获取到线程 &quot;</span> &lt;&lt; (i + <span class="number">1</span>) &lt;&lt; <span class="string">&quot; 的返回结果 = &quot;</span> &lt;&lt; *res &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">delete</span> res;                         <span class="comment">// 释放返回结果的内存</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;所有线程任务已完成，主线程退出。&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[hcc@hcss-ecs-be68 pthread_join]$ ./pthread_join </span><br><span class="line">子线程 1 完成任务，返回结果 = 10</span><br><span class="line">主线程获取到线程 1 的返回结果 = 10</span><br><span class="line">子线程 2 完成任务，返回结果 = 20</span><br><span class="line">主线程获取到线程 2 的返回结果 = 20</span><br><span class="line">子线程 3 完成任务，返回结果 = 30</span><br><span class="line">主线程获取到线程 3 的返回结果 = 30</span><br><span class="line">子线程 4 完成任务，返回结果 = 40</span><br><span class="line">主线程获取到线程 4 的返回结果 = 40</span><br><span class="line">子线程 5 完成任务，返回结果 = 50</span><br><span class="line">主线程获取到线程 5 的返回结果 = 50</span><br><span class="line">所有线程任务已完成，主线程退出。</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-线程退出值-退出码（为啥只能拿这个）？"><a href="#3-线程退出值-退出码（为啥只能拿这个）？" class="headerlink" title="3. 线程退出值 &#x3D; 退出码（为啥只能拿这个）？"></a>3. 线程退出值 &#x3D; 退出码（为啥只能拿这个）？</h3><blockquote>
<p><code>pthread_join()</code> 是主线程 <strong>阻塞等待</strong> 子线程完成，并 <strong>获取子线程返回值（退出码）</strong> 的唯一方式，而这个退出码只能是 <code>void*</code> 类型，因为 POSIX pthread 模型就规定线程函数只能返回一个 <code>void*</code> 指针。</p>
</blockquote>
<h4 id="1-为什么线程退出时只能“返回一个退出码”？"><a href="#1-为什么线程退出时只能“返回一个退出码”？" class="headerlink" title="1. 为什么线程退出时只能“返回一个退出码”？"></a>1. 为什么线程退出时只能“返回一个退出码”？</h4><p>因为线程函数的原型是：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* (*start_routine)(<span class="type">void</span>*)</span><br></pre></td></tr></table></figure>

<ul>
<li>它只能有一个返回值，类型是 <code>void*</code>，这是 POSIX 标准设计决定的；</li>
<li>无法直接返回多个值，也不能返回栈上对象（因为线程函数退出后栈就销毁了）；</li>
<li>所以如果需要返回复杂数据，必须 <strong>动态申请内存（如 <code>new</code>）并 return 指针</strong>，主线程通过 <code>pthread_join()</code> 接收并自行释放。</li>
</ul>
<h4 id="2-为什么不是像-fork-那样返回整型或-exit-code？"><a href="#2-为什么不是像-fork-那样返回整型或-exit-code？" class="headerlink" title="2. 为什么不是像 fork() 那样返回整型或 exit code？"></a>2. 为什么不是像 <code>fork()</code> 那样返回整型或 exit code？</h4><ul>
<li><code>fork()</code> 是 <strong>进程级别</strong>，操作系统可以记录 exit status；</li>
<li><code>pthread_exit()</code> 或 <code>return</code> 是线程级别，线程之间共享地址空间，退出值不需要写入操作系统状态；</li>
<li><code>pthread_join()</code> 只关心线程退出时返回的那块 <strong>用户级别的数据指针（void*）</strong>，而不是操作系统的退出码。</li>
</ul>
<hr>
<h2 id="4-线程终止"><a href="#4-线程终止" class="headerlink" title="4. 线程终止"></a>4. 线程终止</h2><h3 id="1-线程终止的-4-种方式（核心）"><a href="#1-线程终止的-4-种方式（核心）" class="headerlink" title="1. 线程终止的 4 种方式（核心）"></a>1. 线程终止的 4 种方式（核心）</h3><p>在 POSIX <code>pthread</code> 中，<strong>线程的终止方式主要有以下几种</strong>：</p>
<ol>
<li><p><strong>线程函数运行完毕后自动返回：</strong> 这是最自然的退出方式，函数体执行到最后，线程就自动退出。</p>
</li>
<li><p><strong>在函数中调用 <code>pthread_exit()</code> 主动退出：</strong> 这种方式适用于希望 <strong>中途退出线程</strong>，但又希望返回一个退出值的情况。可随时退出线程、能设置退出码、等效于 <code>return</code>。</p>
</li>
<li><p><strong>其他线程调用 <code>pthread_cancel()</code> 强制取消线程：</strong> 一种 <strong>异步控制</strong> 方式。线程不一定立即退出，需要处于“<strong>可取消点</strong>”（如 sleep、read 等），线程退出码为 <code>PTHREAD_CANCELED ((void*)-1)</code>。<strong>注意：如果线程没有设置为可取消状态，<code>pthread_cancel()</code> 无效。</strong></p>
</li>
<li><p><strong>整个进程退出时，所有线程终止：</strong> 当 <strong>主线程调用 <code>exit()</code>、<code>_exit()</code> 或主线程崩溃</strong> 导致整个进程终止时，所有线程也会强制结束。粗暴退出会导致线程无法清理资源，常见于崩溃或异常退出。</p>
</li>
</ol>
<table>
<thead>
<tr>
<th>终止方式</th>
<th>触发者</th>
<th>是否能传退出码</th>
<th>是否立即退出</th>
<th>是否安全</th>
</tr>
</thead>
<tbody><tr>
<td><code>return</code></td>
<td>本线程自己</td>
<td>✅ 是</td>
<td>✅ 是</td>
<td>✅ 推荐</td>
</tr>
<tr>
<td><code>pthread_exit()</code></td>
<td>本线程自己</td>
<td>✅ 是</td>
<td>✅ 是</td>
<td>✅ 推荐</td>
</tr>
<tr>
<td><code>pthread_cancel()</code></td>
<td>其他线程</td>
<td>✅（默认为 <code>PTHREAD_CANCELED</code>）</td>
<td>❌ 依赖可取消点</td>
<td>⚠️ 谨慎使用</td>
</tr>
<tr>
<td><code>exit()</code> &#x2F; 崩溃</td>
<td>任意线程</td>
<td>❌ 无法获取</td>
<td>✅ 是</td>
<td>❌ 不推荐</td>
</tr>
</tbody></table>
<hr>
<h3 id="2-pthread-exit-——-主动退出当前线程"><a href="#2-pthread-exit-——-主动退出当前线程" class="headerlink" title="2. pthread_exit —— 主动退出当前线程"></a>2. <code>pthread_exit</code> —— 主动退出当前线程</h3><h4 id="1-功能-4"><a href="#1-功能-4" class="headerlink" title="1. 功能"></a>1. 功能</h4><p>主动退出当前线程，并返回一个退出值（给等待该线程的其他线程）。比 <code>return</code> 更灵活，可在任何地方终止线程。</p>
<p>适用于：</p>
<ul>
<li>线程需要在函数中间提前退出；</li>
<li>想设置返回值供 <code>pthread_join</code> 获取；</li>
</ul>
<h4 id="2-函数原型-3"><a href="#2-函数原型-3" class="headerlink" title="2. 函数原型"></a>2. 函数原型</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pthread_exit</span><span class="params">(<span class="type">void</span>* retval)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="3-参数详解-2"><a href="#3-参数详解-2" class="headerlink" title="3. 参数详解"></a>3. 参数详解</h4><p><strong><code>void* retval</code>：</strong> 线程的退出码，可传任意指针或整型强转。是 <strong>返回给 pthread_join 的退出值</strong>，如果线程已分离，该值会被忽略。</p>
<h4 id="4-返回值-2"><a href="#4-返回值-2" class="headerlink" title="4. 返回值"></a>4. 返回值</h4><p><strong>无返回值</strong>，调用后线程立即退出，后面的代码不会执行。</p>
<h4 id="5-代码示例-2"><a href="#5-代码示例-2" class="headerlink" title="5. 代码示例"></a>5. 代码示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">myThread</span><span class="params">(<span class="type">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;子线程正在运行...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">pthread_exit</span>((<span class="type">void</span>*)<span class="number">1234</span>);  <span class="comment">// 主动退出，返回值是1234</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;子线程退出已经退出了，并且这一句话不会被执行！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    <span class="type">void</span>* retval;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;tid, <span class="literal">nullptr</span>, myThread, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">pthread_join</span>(tid, &amp;retval);  <span class="comment">// 获取子线程返回值</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;子线程退出码：&quot;</span> &lt;&lt; (<span class="type">long</span> <span class="type">long</span>)retval &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 注意：在64位的Linux中，void*（指针）是 8 字节，所以转成 long long，如果转成 int 会报错！</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果示例：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[hcc@hcss-ecs-be68 pthread_exit]$ ./pthread_exit </span><br><span class="line">子线程正在运行...</span><br><span class="line">子线程退出码：1234</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-pthread-cancel-——-发送请求"><a href="#3-pthread-cancel-——-发送请求" class="headerlink" title="3. pthread_cancel —— 发送请求"></a>3. <code>pthread_cancel</code> —— 发送请求</h3><h4 id="1-功能-5"><a href="#1-功能-5" class="headerlink" title="1. 功能"></a>1. 功能</h4><p><strong>向指定线程发送“取消请求”，尝试强制终止它（但不一定立即终止）。</strong></p>
<p>适用于：</p>
<ul>
<li>主动终止长时间运行或卡死的线程；</li>
<li>线程之间的控制与协作场景。</li>
</ul>
<h4 id="2-函数原型-4"><a href="#2-函数原型-4" class="headerlink" title="2. 函数原型"></a>2. 函数原型</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_cancel</span><span class="params">(<span class="type">pthread_t</span> thread)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="3-参数详解-3"><a href="#3-参数详解-3" class="headerlink" title="3. 参数详解"></a>3. 参数详解</h4><p><strong><code>pthread_t thread</code>：</strong> 目标线程的线程 ID。</p>
<h4 id="4-返回值-3"><a href="#4-返回值-3" class="headerlink" title="4. 返回值"></a>4. 返回值</h4><table>
<thead>
<tr>
<th>返回值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><strong><code>0</code></strong></td>
<td>成功发送取消请求（<strong>注意：不是线程已退出！</strong>）</td>
</tr>
<tr>
<td><code>ESRCH</code></td>
<td>没有找到指定的线程 ID（线程不存在）</td>
</tr>
<tr>
<td><code>EINVAL</code>（少见）</td>
<td>线程 ID 无效（某些实现中使用）</td>
</tr>
</tbody></table>
<h4 id="5-注意事项"><a href="#5-注意事项" class="headerlink" title="5. 注意事项"></a>5. 注意事项</h4><ol>
<li><strong>不是立即强制终止线程！</strong><ul>
<li>被取消线程 <strong>必须处于可取消状态</strong>，且处于 <strong>取消点</strong>；</li>
<li>常见取消点有 <code>sleep</code>、<code>read</code>、<code>pthread_join</code> 等。</li>
</ul>
</li>
<li><strong>线程取消成功后</strong>，其退出值为 <code>(void*)PTHREAD_CANCELED</code>，用来判断线程是否被取消。</li>
<li><strong>如何查一个函数是不是取消点？</strong><ul>
<li>查阅 <a target="_blank" rel="noopener" href="https://pubs.opengroup.org/onlinepubs/9699919799/?spm=a2ty_o01.29997173.0.0.1fff235egGhhMb">POSIX 官方文档</a></li>
<li>使用命令：<code>man 7 pthreads</code>，在 Linux 手册中输入 <code>/</code> 搜索 “Cancellation points”，会列出所有标准取消点函数。</li>
</ul>
</li>
</ol>
<blockquote>
<p><code>PTHREAD_CANCELED</code> 是 POSIX 线程库（pthread）中一个 <strong>宏常量</strong>，它 <strong>用于判断&#x2F;标识线程是否是被 <code>pthread_cancel()</code> 强制取消退出的</strong>，而不是正常执行完毕返回的，可以在 <code>pthread_join()</code> 后检查返回值是否等于它，来确认线程状态。其本质是个 <code>#define</code>（宏）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="meta">#<span class="keyword">define</span> PTHREAD_CANCELED ((void *) -1)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>它是一个 <code>void*</code> 类型的宏常量；</li>
<li>实际上是 <code>(void*)-1</code>，特殊指针，用作标记；</li>
<li>不能拿它当做真实的返回值内容使用，只能 <strong>判断它是不是等于某线程的退出码</strong>。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">&gt;<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line">&gt;<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line">&gt;<span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">&gt;<span class="function"><span class="type">void</span>* <span class="title">func</span><span class="params">(<span class="type">void</span>* arg)</span></span></span><br><span class="line"><span class="function">&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;子线程运行中...&quot;</span> &lt;&lt; endl;</span><br><span class="line">      <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">&gt;</span>&#123;</span><br><span class="line">  <span class="type">pthread_t</span> tid;</span><br><span class="line">  <span class="built_in">pthread_create</span>(&amp;tid, <span class="literal">nullptr</span>, func, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">sleep</span>(<span class="number">2</span>);                            <span class="comment">// 让子线程跑一会儿</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">pthread_cancel</span>(tid);                 <span class="comment">// 取消子线程</span></span><br><span class="line"></span><br><span class="line">  <span class="type">void</span>* retval;</span><br><span class="line">  <span class="built_in">pthread_join</span>(tid, &amp;retval);          <span class="comment">// 等待子线程结束</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 检查返回值是否为被取消</span></span><br><span class="line">  <span class="keyword">if</span> (retval == PTHREAD_CANCELED)</span><br><span class="line">  &#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;子线程被成功取消，返回值 = PTHREAD_CANCELED&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;子线程正常退出，返回值 = &quot;</span> &lt;&lt; retval &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;[hcc@hcss-ecs-be68 pthread_cancel]$ g++ -o PTHREAD_CANCELED PTHREAD_CANCELED.cc -std=c++11 -lpthread</span><br><span class="line">&gt;[hcc@hcss-ecs-be68 pthread_cancel]$ ./PTHREAD_CANCELED </span><br><span class="line">&gt;子线程运行中...</span><br><span class="line">&gt;子线程运行中...</span><br><span class="line">&gt;子线程被成功取消，返回值 = PTHREAD_CANCELED</span><br></pre></td></tr></table></figure></blockquote>
<h4 id="6-代码示例"><a href="#6-代码示例" class="headerlink" title="6. 代码示例"></a>6. 代码示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">func</span><span class="params">(<span class="type">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;子线程工作中...&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);                   <span class="comment">// sleep 是一个可取消点</span></span><br><span class="line">        <span class="comment">// pthread_testcancel();       // 手动设置一个取消点</span></span><br><span class="line">        <span class="comment">// 注意：如果使用 pthread_testcancel()，在这个程序中会无限打印 &quot;子线程工作中...&quot;，在3秒后会自动退出，</span></span><br><span class="line">        <span class="comment">// 和sleep(1)一样的效果。虽然看起来像是死循环，但实际上是可以取消的！</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    <span class="type">void</span>* retval;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;tid, <span class="literal">nullptr</span>, func, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">3</span>);                       <span class="comment">// 让子线程运行一会</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_cancel</span>(tid);            <span class="comment">// 发送取消请求</span></span><br><span class="line">    <span class="built_in">pthread_join</span>(tid, &amp;retval);     <span class="comment">// 等待子线程结束并获取退出码</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (retval == PTHREAD_CANCELED)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;收到取消请求，子线程被取消了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[hcc@hcss-ecs-be68 pthread_cancel]$ ./pthread_cancel </span><br><span class="line">子线程工作中...</span><br><span class="line">子线程工作中...</span><br><span class="line">子线程工作中...</span><br><span class="line">收到取消请求，子线程被取消了！</span><br></pre></td></tr></table></figure>

<h3 id="4-小结"><a href="#4-小结" class="headerlink" title="4. 小结"></a>4. 小结</h3><table>
<thead>
<tr>
<th>函数</th>
<th>主体是谁调用</th>
<th>用于哪个线程</th>
<th>是否立即终止</th>
<th>是否能设置退出码</th>
</tr>
</thead>
<tbody><tr>
<td><code>pthread_exit</code></td>
<td>当前线程</td>
<td>自己</td>
<td>立即</td>
<td>是</td>
</tr>
<tr>
<td><code>pthread_cancel</code></td>
<td>外部线程</td>
<td>目标线程</td>
<td>非立即</td>
<td>返回值为宏</td>
</tr>
</tbody></table>
<hr>
<p>线程分离（<strong>Detached Thread</strong>）是 Linux 多线程（POSIX 线程 <code>pthread</code>）编程中的一个重要概念。下面我们从概念入手，逐步深入 <code>pthread_detach</code> 函数及其背后机制，讲清楚线程分离的本质。</p>
<hr>
<h2 id="5-线程分离"><a href="#5-线程分离" class="headerlink" title="5. 线程分离"></a>5. 线程分离</h2><h3 id="1-线程分离是什么，有什么用？"><a href="#1-线程分离是什么，有什么用？" class="headerlink" title="1. 线程分离是什么，有什么用？"></a>1. 线程分离是什么，有什么用？</h3><p>在默认情况下（<strong>joinable</strong> 模式），线程执行完后不会立即释放资源，需要其他线程调用 <code>pthread_join()</code> 与之回收，才能释放其占用的资源（如线程栈、PCB 结构等）。</p>
<p><strong>线程分离（detached） 就是让线程在执行完毕后自动释放自己的资源，不再需要其他线程去 <code>pthread_join()</code> 它，防止资源泄漏。注意：线程一旦结束，系统自动回收资源，不能再被 <code>pthread_join</code>！</strong></p>
<h3 id="2-pthread-detach-函数"><a href="#2-pthread-detach-函数" class="headerlink" title="2. pthread_detach 函数"></a>2. <code>pthread_detach</code> 函数</h3><h4 id="1-功能-6"><a href="#1-功能-6" class="headerlink" title="1. 功能"></a>1. 功能</h4><p>将一个线程设置为 <strong>分离状态</strong>，使其结束时资源自动释放。</p>
<h4 id="2-函数原型-5"><a href="#2-函数原型-5" class="headerlink" title="2. 函数原型"></a>2. 函数原型</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_detach</span><span class="params">(<span class="type">pthread_t</span> thread)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="3-参数说明"><a href="#3-参数说明" class="headerlink" title="3. 参数说明"></a>3. 参数说明</h4><p><code>thread</code>：需要设置为分离状态的线程 ID（<code>pthread_t</code> 类型）。</p>
<h4 id="4-返回值-4"><a href="#4-返回值-4" class="headerlink" title="4. 返回值"></a>4. 返回值</h4><ul>
<li><code>0</code>：成功。</li>
<li><code>EINVAL</code>：线程不是 joinable 或状态无效。</li>
<li><code>ESRCH</code>：指定的线程 ID 不存在。</li>
</ul>
<h4 id="5-代码示例-3"><a href="#5-代码示例-3" class="headerlink" title="5. 代码示例"></a>5. 代码示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">func</span><span class="params">(<span class="type">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;子线程开始执行...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;子线程执行完毕，自动释放资源。&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">pthread_exit</span>(<span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建线程（默认是 joinable 状态）</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">pthread_create</span>(&amp;tid, <span class="literal">nullptr</span>, func, <span class="literal">nullptr</span>) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;线程创建失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置线程为分离状态</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">pthread_detach</span>(tid) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;线程分离失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;主线程不等待子线程，直接结束。&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[hcc@hcss-ecs-be68 pthread_detach]$ ./pthread_detach </span><br><span class="line">主线程不等待子线程，直接结束。</span><br><span class="line">子线程开始执行...</span><br><span class="line">子线程执行完毕，自动释放资源。</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-线程分离的本质是什么？"><a href="#3-线程分离的本质是什么？" class="headerlink" title="3. 线程分离的本质是什么？"></a>3. 线程分离的本质是什么？</h3><p><strong>线程分离的本质就是线程的一个属性</strong>，叫作：</p>
<ul>
<li>PTHREAD_CREATE_JOINABLE（默认）</li>
<li>PTHREAD_CREATE_DETACHED（分离）</li>
</ul>
<p>这个属性决定了线程的生命周期如何管理资源：</p>
<ul>
<li><strong>JOINABLE 状态</strong>：线程执行完还要别人 <code>join()</code> 回收资源；</li>
<li><strong>DETACHED 状态</strong>：线程执行完直接自己清理干净，别人不能 <code>join()</code> 它。</li>
</ul>
<p><strong>一旦线程设置为分离状态，无法再对它调用 <code>pthread_join()</code>，否则会导致未定义行为，分离线程是否继续执行不取决于主线程是否退出，而取决于进程是否还活着。（分离线程 &#x3D; 自动回收，非分离线程 &#x3D; 手动回收）。</strong></p>
<hr>
<h3 id="4-小结-1"><a href="#4-小结-1" class="headerlink" title="4. 小结"></a>4. 小结</h3><ul>
<li>如果创建的线程是 <strong>短生命周期</strong>、且不需要结果回传的（如后台异步日志写入），建议使用 <code>pthread_detach()</code> 或属性设置为分离。</li>
<li>如果需要线程返回值（如子线程计算结果后回传主线程），则必须使用 <code>joinable</code> 并调用 <code>pthread_join()</code>。</li>
<li>线程分离后，即使主线程退出，分离线程也不一定会结束，只有当进程退出才会影响！</li>
<li><strong>千万不要创建完线程后忘记 <code>join()</code> 或 <code>detach()</code></strong>，否则会发生资源泄漏，尤其在线程频繁创建时。</li>
</ul>
<hr>
<h2 id="6-C-语言层面上的多线程支持（C-11-起，了解）"><a href="#6-C-语言层面上的多线程支持（C-11-起，了解）" class="headerlink" title="6. C++ 语言层面上的多线程支持（C++11 起，了解）"></a>6. C++ 语言层面上的多线程支持（C++11 起，了解）</h2><p><code>pthread</code> 是 C 语言的 POSIX 线程库（第三方），可在 C++ 中直接使用，但并非 C++ 语言原生支持；从 C++11 起，C++ 在语言层面提供了 <code>std::thread</code> 作为标准多线程支持，具有更好的类型安全和跨平台性，底层在 Linux 上通常基于 <code>pthread</code> 实现，但对用户透明。</p>
<h3 id="1-pthread-VS-std-thread"><a href="#1-pthread-VS-std-thread" class="headerlink" title="1. pthread VS std:: thread"></a>1. pthread VS std:: thread</h3><table>
<thead>
<tr>
<th>概念</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>pthread</code></td>
<td>是 <strong>POSIX 标准定义的 C 语言线程 API</strong>，不是 C++ 的一部分。在 Linux 上通过 <code>&lt;pthread.h&gt;</code> 提供。</td>
</tr>
<tr>
<td><code>std::thread</code></td>
<td>是 <strong>C++11 标准引入的 C++ 原生线程类</strong>，属于 C++ 标准库，头文件 <code>&lt;thread&gt;</code>。</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>对比</th>
<th><code>pthread</code>（C 风格）</th>
<th><code>std::thread</code>（C++11 起标准库）</th>
</tr>
</thead>
<tbody><tr>
<td><strong>来源</strong></td>
<td>POSIX API（非 C++ 标准）</td>
<td>C++ 标准库（C++11 起）</td>
</tr>
<tr>
<td><strong>头文件</strong></td>
<td><code>&lt;pthread.h&gt;</code></td>
<td><code>&lt;thread&gt;</code></td>
</tr>
<tr>
<td><strong>依赖</strong></td>
<td>POSIX 系统（Linux&#x2F;Unix），Windows 原生不支持</td>
<td>跨平台：Windows &#x2F; Linux &#x2F; macOS（编译器支持即可）</td>
</tr>
<tr>
<td><strong>语言风格</strong></td>
<td>C 风格：函数指针 + <code>void*</code> 参数</td>
<td>C++ 风格：支持 lambda、成员函数、函数对象、模板</td>
</tr>
<tr>
<td><strong>类型安全</strong></td>
<td><code>void*</code> 传参，易出错</td>
<td>模板自动推导，类型安全</td>
</tr>
<tr>
<td><strong>封装性</strong></td>
<td>纯函数式调用，无类封装</td>
<td><code>std::thread</code> 是类，支持 RAII、移动语义</td>
</tr>
<tr>
<td><strong>适合谁</strong></td>
<td>系统编程、嵌入式、高性能定制、底层原理</td>
<td>应用开发、跨平台项目、现代 C++ 开发</td>
</tr>
<tr>
<td><strong>退出机制</strong></td>
<td><code>pthread_exit()</code>、<code>pthread_join()</code></td>
<td><code>t.join()</code>、<code>t.detach()</code>，析构时自动检查</td>
</tr>
<tr>
<td><strong>可移植性</strong></td>
<td>仅限 POSIX 系统</td>
<td>只要编译器支持 C++11 就可移植</td>
</tr>
<tr>
<td><strong>底层实现</strong></td>
<td>直接调用内核 LWP（轻量级进程）</td>
<td>在 Linux 上通常基于 <code>pthread</code> 封装（但对用户透明）</td>
</tr>
<tr>
<td><strong>编译选项</strong></td>
<td><code>g++ -o app app.cpp -lpthread</code></td>
<td><code>g++ -o app app.cpp -std=c++11</code>（自动链接）</td>
</tr>
</tbody></table>
<hr>
<h3 id="2-std-thread-vs-pthread-对照表"><a href="#2-std-thread-vs-pthread-对照表" class="headerlink" title="2. std::thread vs pthread 对照表"></a>2. <code>std::thread</code> vs <code>pthread</code> 对照表</h3><table>
<thead>
<tr>
<th><code>pthread</code> 函数</th>
<th><code>std::thread</code> 写法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>pthread_create(&amp;tid, nullptr, func, arg)</code></td>
<td><code>std::thread t(func, arg);</code></td>
<td>创建线程</td>
</tr>
<tr>
<td><code>pthread_join(tid, &amp;ret)</code></td>
<td><code>t.join();</code></td>
<td>等待线程结束</td>
</tr>
<tr>
<td><code>pthread_exit()</code></td>
<td><code>return;</code></td>
<td>线程函数返回即退出</td>
</tr>
<tr>
<td><code>pthread_self()</code></td>
<td><code>std::this_thread::get_id()</code></td>
<td>获取当前线程 ID</td>
</tr>
<tr>
<td><code>sleep(1)</code></td>
<td><code>std::this_thread::sleep_for(1s);</code></td>
<td>睡眠 1 秒</td>
</tr>
</tbody></table>
<h3 id="3-代码示例"><a href="#3-代码示例" class="headerlink" title="3. 代码示例"></a>3. 代码示例</h3><h4 id="1-创建线程"><a href="#1-创建线程" class="headerlink" title="1. 创建线程"></a>1. 创建线程</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">thread <span class="title">t</span><span class="params">(函数名, 参数...)</span></span>;</span><br></pre></td></tr></table></figure>

<p>参数会自动拷贝（如果是对象）想传引用？用 <code>std::ref(变量)</code> 包一层。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span>&amp; x)</span> </span>&#123; x = <span class="number">100</span>; &#125;</span><br><span class="line"><span class="type">int</span> val = <span class="number">0</span>;</span><br><span class="line"><span class="function">thread <span class="title">t</span><span class="params">(func, ref(val))</span></span>;  <span class="comment">// 传引用</span></span><br><span class="line">t.<span class="built_in">join</span>();</span><br><span class="line">cout &lt;&lt; val;  <span class="comment">// 输出 100</span></span><br></pre></td></tr></table></figure>

<h4 id="2-等待线程结束：join"><a href="#2-等待线程结束：join" class="headerlink" title="2. 等待线程结束：join()"></a>2. 等待线程结束：<code>join()</code></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t.<span class="built_in">join</span>();  <span class="comment">// 必须调用，否则程序会崩溃！</span></span><br></pre></td></tr></table></figure>

<p>类比 <code>pthread_join</code>，一个 <code>thread</code> 对象只能 <code>join()</code> 一次。</p>
<h4 id="3-分离线程：detach"><a href="#3-分离线程：detach" class="headerlink" title="3. 分离线程：detach()"></a>3. 分离线程：<code>detach()</code></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t.<span class="built_in">detach</span>();  <span class="comment">// 不等它，让它后台运行</span></span><br></pre></td></tr></table></figure>

<h4 id="4-获取线程-ID"><a href="#4-获取线程-ID" class="headerlink" title="4. 获取线程 ID"></a>4. 获取线程 ID</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">&quot;当前线程ID: &quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;t的线程ID: &quot;</span> &lt;&lt; t.<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<h4 id="5-支持-lambda（超方便！）"><a href="#5-支持-lambda（超方便！）" class="headerlink" title="5. 支持 lambda（超方便！）"></a>5. 支持 lambda（超方便！）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">thread <span class="title">t</span><span class="params">([]&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    cout &lt;&lt; <span class="string">&quot;Lambda 线程运行！&quot;</span> &lt;&lt; endl;</span></span></span><br><span class="line"><span class="params"><span class="function">    this_thread::sleep_for(<span class="number">1</span>s);</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;)</span></span>;</span><br><span class="line">t.<span class="built_in">join</span>();</span><br></pre></td></tr></table></figure>

<h4 id="6-支持类成员函数"><a href="#6-支持类成员函数" class="headerlink" title="6. 支持类成员函数"></a>6. 支持类成员函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Worker</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Worker 工作 &quot;</span> &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Worker w;</span><br><span class="line"><span class="function">thread <span class="title">t</span><span class="params">(&amp;Worker::work, &amp;w, <span class="number">100</span>)</span></span>;  <span class="comment">// &amp;w 是对象地址</span></span><br><span class="line">t.<span class="built_in">join</span>();</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(string msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;主线程: &quot;</span> &lt;&lt; msg &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 成员函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">work</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;子线程: &quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(func, <span class="string">&quot;我是普通函数线程&quot;</span>)</span></span>;         <span class="comment">// 1. 普通函数线程</span></span><br><span class="line">    work w;</span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(&amp;work::run, &amp;w, <span class="number">42</span>)</span></span>;              <span class="comment">// 2. 成员函数线程</span></span><br><span class="line">    <span class="function">thread <span class="title">t3</span><span class="params">([]() &#123;                            <span class="comment">// 3. lambda线程</span></span></span></span><br><span class="line"><span class="params"><span class="function">        cout &lt;&lt; <span class="string">&quot;lambda线程: &quot;</span> &lt;&lt; endl;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">3.</span><span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span>       <span class="comment">// C++ 中专门处理时间的库</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> chrono;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadFunc</span><span class="params">(<span class="type">const</span> string&amp; name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; name &lt;&lt; <span class="string">&quot;: 工作中 &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">        this_thread::<span class="built_in">sleep_for</span>(<span class="number">1</span>s);        <span class="comment">// 睡1秒</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">(threadFunc, <span class="string">&quot;子线程&quot;</span>)</span></span>;        <span class="comment">// 创建线程（pthread_create）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i)           <span class="comment">// 主线程也干点事</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;主线程: 主线程工作 &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">        this_thread::<span class="built_in">sleep_for</span>(<span class="number">500</span>ms);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    t.<span class="built_in">join</span>();                             <span class="comment">// 等待子线程结束（类比 pthread_join）</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;所有线程结束！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//运行结果示例：</span></span><br><span class="line"><span class="comment">//主线程:主线程工作 0</span></span><br><span class="line"><span class="comment">//子线程:工作中 0</span></span><br><span class="line"><span class="comment">//主线程:主线程工作 1</span></span><br><span class="line"><span class="comment">//子线程:工作中 1</span></span><br><span class="line"><span class="comment">//子线程:工作中 2</span></span><br><span class="line"><span class="comment">//所有线程结束！！</span></span><br></pre></td></tr></table></figure>

<h2 id="7-可重入与线程安全"><a href="#7-可重入与线程安全" class="headerlink" title="7. 可重入与线程安全"></a>7. 可重入与线程安全</h2><blockquote>
<p>  <strong>“可重入”指的是一个函数可以被多个线程同时调用，并且不会互相影响，不会出现混乱或崩溃。</strong></p>
</blockquote>
<h3 id="1-代码示例：一个不可重入的函数"><a href="#1-代码示例：一个不可重入的函数" class="headerlink" title="1. 代码示例：一个不可重入的函数"></a>1. 代码示例：一个不可重入的函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> counter = <span class="number">0</span>;                        <span class="comment">// 全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">task</span><span class="params">(<span class="type">void</span>* arg)</span>                   <span class="comment">// 所有线程都会调用这个函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 每个线程都对同一个 counter 加 1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        ++counter;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;线程 &quot;</span> &lt;&lt; <span class="built_in">pthread_self</span>() &lt;&lt; <span class="string">&quot; counter = &quot;</span> &lt;&lt; counter &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_exit</span>(<span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> t1, t2;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;t1, <span class="literal">nullptr</span>, task, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;t2, <span class="literal">nullptr</span>, task, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_join</span>(t1, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">pthread_join</span>(t2, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;最终counter = &quot;</span> &lt;&lt; counter &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数是 <strong>不是可重入的</strong>，并且运行输出是错乱的，因为 <code>counter</code> 是 <strong>全局变量</strong>，多个线程同时改它，结果错乱。<code>cout</code> 也是 <strong>共享资源</strong>，多个线程同时输出可能出现换行错乱。</p>
<h3 id="2-可重入函数应该是什么样？"><a href="#2-可重入函数应该是什么样？" class="headerlink" title="2. 可重入函数应该是什么样？"></a>2. 可重入函数应该是什么样？</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 完全不使用全局变量，只用局部变量</span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">safe_task</span><span class="params">(<span class="type">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> local_counter = <span class="number">0</span>;   <span class="comment">// 每个线程有自己的变量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        ++local_counter;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;线程 &quot;</span> &lt;&lt; <span class="built_in">pthread_self</span>() &lt;&lt; <span class="string">&quot; local_counter = &quot;</span> &lt;&lt; local_counter &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_exit</span>(<span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个 <code>safe_task()</code> 就是 <strong>可重入的函数</strong>，每个线程都自己玩自己的变量，互不干扰。</p>
<hr>
<h3 id="3-小结"><a href="#3-小结" class="headerlink" title="3. 小结"></a>3. 小结</h3><p><strong>现在用线程，只需要记住：可重入函数不使用全局变量，也不操作共享资源，就不会线程混乱。目前只需要做到：尽量只用局部变量，一个线程干自己的事，不要访问别人家的变量，就能避免 90% 的线程问题！</strong></p>
<table>
<thead>
<tr>
<th>要注意的点</th>
<th>是否说明可重入</th>
<th>建议做法</th>
</tr>
</thead>
<tbody><tr>
<td>用全局变量</td>
<td>❌ 否</td>
<td>每个线程用自己的局部变量</td>
</tr>
<tr>
<td>打印输出 cout&#x2F;printf</td>
<td>❌ 否</td>
<td>少用或后续使用加锁保护输出</td>
</tr>
<tr>
<td>多个线程同时调函数</td>
<td>✅ 是</td>
<td>放心大胆用</td>
</tr>
<tr>
<td>pthread API</td>
<td>✅ 无影响</td>
<td>这些 pthread 函数本身是线程安全的</td>
</tr>
</tbody></table>
<hr>
<h2 id="8-代码实战"><a href="#8-代码实战" class="headerlink" title="8. 代码实战"></a>8. 代码实战</h2><h3 id="1-多种终止方式"><a href="#1-多种终止方式" class="headerlink" title="1. 多种终止方式"></a>1. 多种终止方式</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">thread1</span><span class="params">(<span class="type">void</span>*)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;[线程1] 正常 return 退出&quot;</span> &lt;&lt; endl;               <span class="comment">// 方法1：函数 return 自然返回</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>*)<span class="number">1</span>;                                         <span class="comment">// 返回退出值 1</span></span><br><span class="line">    <span class="comment">// return nullptr;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">thread2</span><span class="params">(<span class="type">void</span>*)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;[线程2] 使用 pthread_exit 主动退出&quot;</span> &lt;&lt; endl;     <span class="comment">// 方法2：显式调用 pthread_exit</span></span><br><span class="line">    <span class="built_in">pthread_exit</span>((<span class="type">void</span>*)<span class="number">2</span>);                                  <span class="comment">// 返回退出值 2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">thread3</span><span class="params">(<span class="type">void</span>*)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;[线程3] 进入无限循环，等待被取消...&quot;</span> &lt;&lt; endl;     <span class="comment">// 方法3：无限循环，等待 cancel</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);                                            <span class="comment">// 可取消点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">thread4</span><span class="params">(<span class="type">void</span>*)</span>                                         <span class="comment">// 方法4：使用 exit 退出（注意：此会导致整个进程退出！不推荐！）</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;[线程4] 调用了 exit(3)，整个进程都会终止！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">3</span>);                                                 <span class="comment">// 会结束整个程序（不推荐在线程中用）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> t1, t2, t3, t4;</span><br><span class="line">    <span class="type">void</span>* ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建四个线程</span></span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;t1, <span class="literal">nullptr</span>, thread1, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;t2, <span class="literal">nullptr</span>, thread2, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;t3, <span class="literal">nullptr</span>, thread3, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="comment">// pthread_create(&amp;t4, nullptr, thread4, nullptr);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待线程1退出（正常 return）</span></span><br><span class="line">    <span class="built_in">pthread_join</span>(t1, &amp;ret);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;[主线程] 线程1退出，退出值 = &quot;</span> &lt;&lt; (<span class="type">long</span> <span class="type">long</span>)ret &lt;&lt; <span class="string">&quot;（return 返回）&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待线程2退出（pthread_exit）</span></span><br><span class="line">    <span class="built_in">pthread_join</span>(t2, &amp;ret);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;[主线程] 线程2退出，退出值 = &quot;</span> &lt;&lt; (<span class="type">long</span> <span class="type">long</span>)ret &lt;&lt; <span class="string">&quot;（pthread_exit 返回）&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取消线程3</span></span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">2</span>);                       <span class="comment">// 等它跑一下</span></span><br><span class="line">    <span class="built_in">pthread_cancel</span>(t3);</span><br><span class="line">    <span class="built_in">pthread_join</span>(t3, &amp;ret);</span><br><span class="line">    <span class="keyword">if</span> (ret == PTHREAD_CANCELED)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;[主线程] 线程3被取消（pthread_cancel）&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;[主线程] 线程3退出值 = &quot;</span> &lt;&lt; (<span class="type">long</span> <span class="type">long</span>)ret &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">2</span>);                       <span class="comment">// 等它跑一下</span></span><br><span class="line">    <span class="comment">// 等待线程4退出（exit）=&gt; 会导致其他线程无法正常退出，整个进程终止！</span></span><br><span class="line">    <span class="comment">// pthread_join(t4, &amp;ret);</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; &quot;[主线程] 线程4退出，退出值 = &quot; &lt;&lt; (long long)ret &lt;&lt; &quot;（exit 终止）&quot; &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-多线程的协同"><a href="#2-多线程的协同" class="headerlink" title="2. 多线程的协同"></a>2. 多线程的协同</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 枚举线程运行状态</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Status</span></span><br><span class="line">&#123;</span><br><span class="line">    OK = <span class="number">0</span>,             <span class="comment">// 正常</span></span><br><span class="line">    ERROR               <span class="comment">// 异常</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadTask</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数：传入线程名字、起始数、结束数、线程编号</span></span><br><span class="line">    <span class="built_in">ThreadTask</span>(<span class="type">const</span> string&amp; name, <span class="type">int</span> begin, <span class="type">int</span> end, <span class="type">int</span> id)</span><br><span class="line">        : _name(name), _begin(begin), _end(end), _id(id),</span><br><span class="line">          _result(<span class="number">0</span>), _status(Status::OK)</span><br><span class="line">    &#123;&#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">ThreadTask</span>() &#123;&#125;    <span class="comment">// 析构函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程的实际任务函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = _begin; i &lt;= _end; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            _result += i;           <span class="comment">// 计算指定区间的和</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;线程[%s]运行完毕，计算[%d~%d]结束\n&quot;</span>, _name.<span class="built_in">c_str</span>(), _begin, _end);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// pthread_exit：线程结束时返回一个指针（被主线程pthread_join获取）</span></span><br><span class="line">        <span class="built_in">pthread_exit</span>(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string _name;           <span class="comment">// 线程名称</span></span><br><span class="line">    <span class="type">int</span> _begin;             <span class="comment">// 区间起点</span></span><br><span class="line">    <span class="type">int</span> _end;               <span class="comment">// 区间终点</span></span><br><span class="line">    <span class="type">int</span> _id;                <span class="comment">// 线程编号</span></span><br><span class="line">    <span class="type">int</span> _result;            <span class="comment">// 计算结果</span></span><br><span class="line">    Status _status;         <span class="comment">// 线程状态</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程入口函数（全局函数 / 静态函数）</span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">threadEntry</span><span class="params">(<span class="type">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// static_cast&lt;T*&gt; 是 C++ 的类型转换运算符：用于在编译时进行类型安全的指针转换</span></span><br><span class="line">    ThreadTask* task = <span class="built_in">static_cast</span>&lt;ThreadTask*&gt;(arg);</span><br><span class="line"></span><br><span class="line">    task-&gt;<span class="built_in">run</span>();                                <span class="comment">// 执行实际任务（内部调用 pthread_exit 退出线程）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;                             <span class="comment">// 实际不会执行到这里，因为 run() 中直接退出了线程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> THREAD_NUM = <span class="number">4</span>;                   <span class="comment">// 总线程数量</span></span><br><span class="line">    <span class="type">pthread_t</span> tids[THREAD_NUM];                 <span class="comment">// 线程ID数组</span></span><br><span class="line">    ThreadTask* tasks[THREAD_NUM];              <span class="comment">// 每个线程绑定一个任务对象</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> range = <span class="number">100</span>;                            <span class="comment">// 每个线程负责计算100个数的和</span></span><br><span class="line">    <span class="type">int</span> start = <span class="number">1</span>;                              <span class="comment">// 区间起始点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; THREAD_NUM; ++i)        <span class="comment">// 创建线程</span></span><br><span class="line">    &#123;</span><br><span class="line">        string name = <span class="string">&quot;Thread-&quot;</span> + <span class="built_in">to_string</span>(i + <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> end = start + range - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        tasks[i] = <span class="keyword">new</span> <span class="built_in">ThreadTask</span>(name, start, end, i + <span class="number">1</span>);     <span class="comment">// 创建一个任务对象</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建线程，执行 threadEntry 函数，参数传入任务对象指针</span></span><br><span class="line">        <span class="built_in">pthread_create</span>(&amp;tids[i], <span class="literal">nullptr</span>, threadEntry, tasks[i]);</span><br><span class="line"></span><br><span class="line">        start = end + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);                                <span class="comment">// 保证顺序输出（演示效果）</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; THREAD_NUM; ++i)         <span class="comment">// 等待线程结束 + 收集结果</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">void</span>* ret = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">pthread_join</span>(tids[i], &amp;ret);             <span class="comment">// pthread_join 等待线程退出，并获取其返回值</span></span><br><span class="line"></span><br><span class="line">        ThreadTask* task = <span class="built_in">static_cast</span>&lt;ThreadTask*&gt;(ret);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (task-&gt;_status == Status::OK)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s计算[%d~%d]结果: %d\n&quot;</span>, task-&gt;_name.<span class="built_in">c_str</span>(), task-&gt;_begin, task-&gt;_end, task-&gt;_result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s执行失败！\n&quot;</span>, task-&gt;_name.<span class="built_in">c_str</span>());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">delete</span> task;                            <span class="comment">// 释放任务对象资源</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;所有线程协作完成！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-多线程特性综合演示"><a href="#3-多线程特性综合演示" class="headerlink" title="3. 多线程特性综合演示"></a>3. 多线程特性综合演示</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NUM 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// __thread 是 GCC 提供的线程局部存储关键字，用于声明在函数内的变量，每个线程都有自己的副本，互不干扰。</span></span><br><span class="line">__thread <span class="type">unsigned</span> <span class="type">int</span> thread_local_number = <span class="number">0</span>;     <span class="comment">// 每个线程独有</span></span><br><span class="line">__thread <span class="type">int</span> thread_local_pid = <span class="number">0</span>;                 <span class="comment">// 每个线程独有</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">threadData</span>                                  <span class="comment">// 线程数据结构</span></span><br><span class="line">&#123;</span><br><span class="line">    string threadname;                             <span class="comment">// 线程名称</span></span><br><span class="line">    <span class="type">int</span> thread_id;                                 <span class="comment">// 线程编号</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">toHex</span><span class="params">(<span class="type">pthread_t</span> tid)</span>                        <span class="comment">// 将pthread_t转换为十六进制字符串（便于显示）</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">128</span>];</span><br><span class="line">    <span class="built_in">snprintf</span>(buffer, <span class="built_in">sizeof</span>(buffer), <span class="string">&quot;0x%lx&quot;</span>, tid);<span class="comment">// 使用%lx格式化pthread_t</span></span><br><span class="line">    <span class="keyword">return</span> buffer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitThreadData</span><span class="params">(threadData* td, <span class="type">int</span> number)</span>    <span class="comment">// 初始化线程数据</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    td-&gt;threadname = <span class="string">&quot;thread-&quot;</span> + <span class="built_in">to_string</span>(number);<span class="comment">// 设置线程名称</span></span><br><span class="line">    td-&gt;thread_id = number;                        <span class="comment">// 设置线程ID</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">threadRoutine</span><span class="params">(<span class="type">void</span>* args)</span>                    <span class="comment">// 线程执行函数 - 所有线程都执行这个函数，但每个线程的数据是独立的</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">pthread_detach</span>(<span class="built_in">pthread_self</span>());                <span class="comment">// 立即将当前线程设置为分离状态，这样线程结束后会自动释放资源，无需主线程join</span></span><br><span class="line"></span><br><span class="line">    threadData* td = <span class="built_in">static_cast</span>&lt;threadData*&gt;(args);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前线程ID和进程ID</span></span><br><span class="line">    string tid_str = <span class="built_in">toHex</span>(<span class="built_in">pthread_self</span>());        <span class="comment">// 当前线程的ID</span></span><br><span class="line">    <span class="type">int</span> process_pid = <span class="built_in">getpid</span>();                    <span class="comment">// 进程ID（所有线程共享）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化线程局部变量</span></span><br><span class="line">    thread_local_number = td-&gt;thread_id * <span class="number">100</span>;     <span class="comment">// 每个线程有不同的值</span></span><br><span class="line">    thread_local_pid = process_pid;                <span class="comment">// 每个线程都有自己的副本</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;[&quot;</span> &lt;&lt; td-&gt;threadname &lt;&lt; <span class="string">&quot;] 启动！&quot;</span></span><br><span class="line">        &lt;&lt; <span class="string">&quot;线程ID: &quot;</span> &lt;&lt; tid_str</span><br><span class="line">        &lt;&lt; <span class="string">&quot;, 进程ID: &quot;</span> &lt;&lt; process_pid</span><br><span class="line">        &lt;&lt; <span class="string">&quot;, 线程局部变量 number: &quot;</span> &lt;&lt; thread_local_number &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)                    <span class="comment">// 减少循环次数便于观察</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 展示线程的关键特性：</span></span><br><span class="line">        <span class="comment">// 1. 同一进程内的所有线程共享进程ID</span></span><br><span class="line">        <span class="comment">// 2. 每个线程有自己的线程ID</span></span><br><span class="line">        <span class="comment">// 3. 每个线程有自己的线程局部存储变量</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;[&quot;</span> &lt;&lt; td-&gt;threadname &lt;&lt; <span class="string">&quot;] &quot;</span> &lt;&lt; <span class="string">&quot;第&quot;</span> &lt;&lt; (i + <span class="number">1</span>) &lt;&lt; <span class="string">&quot;次执行：&quot;</span></span><br><span class="line">            &lt;&lt; <span class="string">&quot;线程ID: &quot;</span> &lt;&lt; tid_str</span><br><span class="line">            &lt;&lt; <span class="string">&quot;, 进程ID: &quot;</span> &lt;&lt; process_pid</span><br><span class="line">            &lt;&lt; <span class="string">&quot;, 局部number: &quot;</span> &lt;&lt; thread_local_number</span><br><span class="line">            &lt;&lt; <span class="string">&quot;, 局部pid: &quot;</span> &lt;&lt; thread_local_pid &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);                                   <span class="comment">// 休眠1秒</span></span><br><span class="line">        thread_local_number++;                      <span class="comment">// 修改线程局部变量（只影响当前线程）</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;[&quot;</span> &lt;&lt; td-&gt;threadname &lt;&lt; <span class="string">&quot;] 执行完毕!&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> td;                                      <span class="comment">// 清理分配的内存</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;                                 <span class="comment">// 返回nullptr表示线程正常结束</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;主线程ID: &quot;</span> &lt;&lt; <span class="built_in">toHex</span>(<span class="built_in">pthread_self</span>()) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;进程ID: &quot;</span> &lt;&lt; <span class="built_in">getpid</span>() &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">pthread_t</span>&gt; tids;                         <span class="comment">// 存储所有线程ID的容器</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;开始创建 &quot;</span> &lt;&lt; NUM &lt;&lt; <span class="string">&quot; 个线程...&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM; i++)                   <span class="comment">// 创建多个线程</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">pthread_t</span> tid;                              <span class="comment">// 线程ID变量</span></span><br><span class="line">        threadData* td = <span class="keyword">new</span> threadData;            <span class="comment">// 为每个线程分配独立的数据</span></span><br><span class="line">        <span class="built_in">InitThreadData</span>(td, i);                      <span class="comment">// 初始化线程数据</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ret = <span class="built_in">pthread_create</span>(&amp;tid, <span class="literal">nullptr</span>, threadRoutine, td);</span><br><span class="line">        <span class="keyword">if</span> (ret != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cerr &lt;&lt; <span class="string">&quot;创建线程失败: &quot;</span> &lt;&lt; <span class="built_in">strerror</span>(ret) &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">delete</span> td;                              <span class="comment">// 创建失败时释放内存</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;成功创建线程 &quot;</span> &lt;&lt; td-&gt;threadname &lt;&lt; <span class="string">&quot; (ID: &quot;</span> &lt;&lt; <span class="built_in">toHex</span>(tid) &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        tids.<span class="built_in">push_back</span>(tid);                        <span class="comment">// 保存线程ID</span></span><br><span class="line">        <span class="built_in">usleep</span>(<span class="number">100000</span>);                             <span class="comment">// 延时0.1秒，确保线程正确启动</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n所有线程创建完成，主线程等待...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">2</span>);                                       <span class="comment">// 给线程一些执行时间</span></span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n=== 尝试对分离线程进行join操作 ===&quot;</span> &lt;&lt; endl;     <span class="comment">// 尝试对分离线程进行join操作（这会失败）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; tids.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> result = <span class="built_in">pthread_join</span>(tids[i], <span class="literal">nullptr</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;对线程 0x%lx 执行join的结果: %d (%s)\n&quot;</span>, tids[i], result, <span class="built_in">strerror</span>(result));</span><br><span class="line">        <span class="comment">// 由于线程已被分离，这里会返回EINVAL（无效参数）</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;1. 线程共享进程资源（如进程ID、文件描述符等）&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;2. 每个线程有自己的线程ID和栈空间&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;3. __thread关键字创建线程局部存储变量&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;4. 分离线程结束后自动释放资源&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;5. 分离线程不能被pthread_join回收&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;6. 线程执行是并发的，输出顺序不同&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n主线程继续执行中...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;主线程执行完毕，程序退出！&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://zycs-img-8kd.pages.dev/v2/bFRjgdX.jpeg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://zycs-img-8kd.pages.dev/v2/bFRjgdX.jpeg" title="头像" alt="头像"></a><div class="post-copyright__author_name">小米里的大麦</div><div class="post-copyright__author_desc"></div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="https://www.minbit.top/posts/21804.html">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('https://www.minbit.top/posts/21804.html')">040 线程控制</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="赞赏作者"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><div class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a href="https://zycs-img-8kd.pages.dev/v2/REbVGGL.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://zycs-img-8kd.pages.dev/v2/REbVGGL.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://zycs-img-8kd.pages.dev/v2/1UUolM0.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://zycs-img-8kd.pages.dev/v2/1UUolM0.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul><a class="reward-main-btn" href="/about/#about-reward" target="_blank"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display: none"></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="https://www.minbit.top/posts/21804.html"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=040 线程控制&amp;url=https://www.minbit.top/posts/21804.html&amp;pic=https://zycs-img-8kd.pages.dev/v2/0k1JltC.jpeg?_r_=94c0b562-a46b-881d-a1b9-9cfa65326bf6" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">知识共享署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0)</a> 许可协议。转载请注明来自 <a href="https://www.minbit.top" target="_blank">小米里的大麦</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/Linux/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>Linux<span class="tagsPageCount">50</span></a><a class="post-meta__box__tags" href="/tags/%E7%BA%BF%E7%A8%8B/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>线程<span class="tagsPageCount">4</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="https://zycs-img-8kd.pages.dev/v2/fETMVUS.jpeg?_r_=c529c723-4b01-5bf8-fe19-d1438fd9563d" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/25951.html"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://zycs-img-8kd.pages.dev/v2/0k1JltC.jpeg?_r_=6ba43f2a-6c98-76c5-b13a-49a46893b1c7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">039 线程概念</div></div></a></div><div class="next-post pull-right"><a href="/posts/17300.html"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://zycs-img-8kd.pages.dev/v2/IB9fMsM.png?_r_=8f2f6f58-571b-5f25-02e2-fe0e67979487" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">041 深入理解线程间同步与互斥</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size: 1.5rem; margin-right: 4px"></i><span>喜欢这篇文章的人也看了</span></div><div class="relatedPosts-list"><div><a href="/posts/25951.html" title="039 线程概念"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://zycs-img-8kd.pages.dev/v2/0k1JltC.jpeg?_r_=6ba43f2a-6c98-76c5-b13a-49a46893b1c7" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-07-21</div><div class="title">039 线程概念</div></div></a></div><div><a href="/posts/64232.html" title="043 线程池与线程封装"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://zycs-img-8kd.pages.dev/v2/Jci6x23.png?_r_=55d544d8-5969-b8d7-8729-8965f7370eb5" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-08-05</div><div class="title">043 线程池与线程封装</div></div></a></div><div><a href="/posts/57900.html" title="044 深入线程安全：单例、智能指针与同步原语"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://zycs-img-8kd.pages.dev/v2/0k1JltC.jpeg?_r_=152968fc-09ad-ce7a-8ad1-9e55d921d98d" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-08-09</div><div class="title">044 深入线程安全：单例、智能指针与同步原语</div></div></a></div><div><a href="/posts/55415.html" title="002 创建普通账户（为朋友创建、删除账户）"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://zycs-img-8kd.pages.dev/v2/Jci6x23.png?_r_=96df3973-47d1-d764-f493-e7589af64c82" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-02-17</div><div class="title">002 创建普通账户（为朋友创建、删除账户）</div></div></a></div><div><a href="/posts/49772.html" title="001 环境搭建"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://zycs-img-8kd.pages.dev/v2/IB9fMsM.png?_r_=e06a5eef-c6b3-2c11-e883-ee0213e3d2d7" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-02-11</div><div class="title">001 环境搭建</div></div></a></div><div><a href="/posts/42463.html" title="003 系统和入门指令"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://zycs-img-8kd.pages.dev/v2/fETMVUS.jpeg?_r_=38b1527b-64da-b942-1238-8ff0e9421b3d" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-02-22</div><div class="title">003 系统和入门指令</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="anzhiyufont anzhiyu-icon-comments"></i><span> 评论</span></div><div class="comment-randomInfo"><a onclick="anzhiyu.addRandomCommentInfo()" href="javascript:void(0)">匿名评论</a><a href="/privacy" style="margin-left: 4px">隐私政策</a></div><div class="comment-tips" id="comment-tips"><span>✅ 你无需删除空行，直接评论以获取最佳展示效果</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div><div class="comment-barrage"></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info__sayhi" id="author-info__sayhi" onclick="anzhiyu.changeSayHelloText()"></div><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://zycs-img-8kd.pages.dev/v2/bFRjgdX.jpeg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-status"><img class="g-status" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/08/24/64e6ce9c507bb.png" alt="status"/></div></div><div class="author-info__description">时间好像总会留下点什么,或许是一个人,或许是一个梦,或许……是一段有意义的经历~</div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/"><h1 class="author-info__name">小米里的大麦</h1><div class="author-info__desc"></div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/huangcancan-xbc" target="_blank" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a></div></div></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bullhorn anzhiyu-shake"></i><span>公告</span></div><div class="announcement_content"><span>👋🏻 Hi，我是 <a target="_blank" href="https://huangcancan-xbc.github.io" rel="external nofollow noreferrer noopener" style="font-weight:bold; font-size:1.1em; color:#5166f0;">小米里的大麦</a>，欢迎来看我的博客鸭！</span><br>
<span>👉 建议优先查看置顶的 <a target="_blank" href="https://huangcancan-xbc.github.io/posts/17934.html" rel="external nofollow noreferrer noopener" style="font-weight:bold; font-size:1.1em; color:#5166f0;">网站说明</a>，如有问题欢迎评论区交流！</span><br>
<span>😫 页面异常？尝试<kbd>Ctrl</kbd>+<kbd>F5</kbd></span><br>
<span>📩 联系我：<a href="mailto:hc1960074081@qq.com" rel="external nofollow noreferrer"><b>给我发送邮件🚀</b></a></span>  
</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-number">1.</span> <span class="toc-text">线程控制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-POSIX-%E7%BA%BF%E7%A8%8B%E5%BA%93"><span class="toc-number">1.1.</span> <span class="toc-text">1. POSIX 线程库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF-POSIX-%E7%BA%BF%E7%A8%8B%E5%BA%93%EF%BC%88pthread%EF%BC%89"><span class="toc-number">1.1.1.</span> <span class="toc-text">1. 什么是 POSIX 线程库（pthread）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%89%B9%E7%82%B9"><span class="toc-number">1.1.2.</span> <span class="toc-text">2. 特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-pthread-t"><span class="toc-number">1.1.3.</span> <span class="toc-text">3. pthread_t</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%8A%9F%E8%83%BD"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">1. 功能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%9C%AC%E8%B4%A8"><span class="toc-number">1.1.3.2.</span> <span class="toc-text">2. 本质</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-pthread-create-%E2%80%94%E2%80%94-%E5%88%9B%E5%BB%BA%E6%96%B0%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.1.4.</span> <span class="toc-text">4. pthread_create —— 创建新线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%8A%9F%E8%83%BD-1"><span class="toc-number">1.1.4.1.</span> <span class="toc-text">1. 功能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B"><span class="toc-number">1.1.4.2.</span> <span class="toc-text">2. 函数原型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%8F%82%E6%95%B0%E8%AF%A6%E8%A7%A3"><span class="toc-number">1.1.4.3.</span> <span class="toc-text">3. 参数详解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">1.1.4.4.</span> <span class="toc-text">4. 返回值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.1.4.5.</span> <span class="toc-text">5. 代码示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E7%BA%BF%E7%A8%8B%E7%9B%91%E6%8E%A7%E4%B8%8E%E6%9F%A5%E7%9C%8B"><span class="toc-number">1.1.4.6.</span> <span class="toc-text">6. 线程监控与查看</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-ps-axj-head-1-ps-axj-grep-pthread-create-grep-v-grep"><span class="toc-number">1.1.4.6.1.</span> <span class="toc-text">1. ps axj | head -1 &amp; ps axj | grep pthread_create | grep -v grep</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-ps-aL-head-1-ps-aL-grep-pthread-create-grep-v-grep"><span class="toc-number">1.1.4.6.2.</span> <span class="toc-text">2. ps -aL | head -1 &amp; ps -aL | grep pthread_create | grep -v grep</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-ldd-pthread-create"><span class="toc-number">1.1.4.6.3.</span> <span class="toc-text">3. ldd pthread_create</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%BA%BF%E7%A8%8B%E7%9A%84%E8%B0%83%E5%BA%A6"><span class="toc-number">1.2.</span> <span class="toc-text">2. 线程的调度</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%8D%95%E4%BD%8D%E5%88%B0%E5%BA%95%E6%98%AF%E8%B0%81%EF%BC%9F"><span class="toc-number">1.2.1.</span> <span class="toc-text">1. 线程调度单位到底是谁？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BB%80%E4%B9%88%E6%98%AF-LWP%EF%BC%88Light-Weight-Process%EF%BC%89%EF%BC%9F"><span class="toc-number">1.2.2.</span> <span class="toc-text">2. 什么是 LWP（Light Weight Process）？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Linux-%E4%B8%AD-pthread-%E4%B8%8E-LWP-%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%9F"><span class="toc-number">1.2.3.</span> <span class="toc-text">3. Linux 中 pthread 与 LWP 的关系？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4-%E2%80%9C%E6%88%91%E4%BB%AC%E4%BB%A5%E5%89%8D%E6%8E%A5%E8%A7%A6%E5%88%B0%E7%9A%84%E9%83%BD%E6%98%AF%E5%8D%95%E7%BA%BF%E7%A8%8B%E8%BF%9B%E7%A8%8B%EF%BC%8CPID-%E5%92%8C-LWP-%E7%9B%B8%E7%AD%89%E2%80%9D%EF%BC%9F"><span class="toc-number">1.2.4.</span> <span class="toc-text">4. 为什么说 “我们以前接触到的都是单线程进程，PID 和 LWP 相等”？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-pthread-self-%E2%80%94%E2%80%94-%E8%8E%B7%E5%8F%96%E7%BA%BF%E7%A8%8B-ID"><span class="toc-number">1.2.5.</span> <span class="toc-text">5. pthread_self —— 获取线程 ID</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%8A%9F%E8%83%BD-2"><span class="toc-number">1.2.5.1.</span> <span class="toc-text">1. 功能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B-1"><span class="toc-number">1.2.5.2.</span> <span class="toc-text">2. 函数原型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">1.2.5.3.</span> <span class="toc-text">3. 返回值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.2.5.4.</span> <span class="toc-text">4. 代码示例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E7%BA%BF%E7%A8%8B%E7%AD%89%E5%BE%85"><span class="toc-number">1.3.</span> <span class="toc-text">3. 线程等待</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%BA%BF%E7%A8%8B%E7%AD%89%E5%BE%85%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.3.1.</span> <span class="toc-text">1. 线程等待是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-pthread-join-%E2%80%94%E2%80%94-%E9%98%BB%E5%A1%9E%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.3.2.</span> <span class="toc-text">2. pthread_join —— 阻塞线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%8A%9F%E8%83%BD-3"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">1. 功能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B-2"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">2. 函数原型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%8F%82%E6%95%B0%E8%AF%A6%E8%A7%A3-1"><span class="toc-number">1.3.2.3.</span> <span class="toc-text">3. 参数详解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E8%BF%94%E5%9B%9E%E5%80%BC-1"><span class="toc-number">1.3.2.4.</span> <span class="toc-text">4. 返回值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B-1"><span class="toc-number">1.3.2.5.</span> <span class="toc-text">5. 代码示例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%BA%BF%E7%A8%8B%E9%80%80%E5%87%BA%E5%80%BC-%E9%80%80%E5%87%BA%E7%A0%81%EF%BC%88%E4%B8%BA%E5%95%A5%E5%8F%AA%E8%83%BD%E6%8B%BF%E8%BF%99%E4%B8%AA%EF%BC%89%EF%BC%9F"><span class="toc-number">1.3.3.</span> <span class="toc-text">3. 线程退出值 &#x3D; 退出码（为啥只能拿这个）？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%B8%BA%E4%BB%80%E4%B9%88%E7%BA%BF%E7%A8%8B%E9%80%80%E5%87%BA%E6%97%B6%E5%8F%AA%E8%83%BD%E2%80%9C%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AA%E9%80%80%E5%87%BA%E7%A0%81%E2%80%9D%EF%BC%9F"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">1. 为什么线程退出时只能“返回一个退出码”？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%98%AF%E5%83%8F-fork-%E9%82%A3%E6%A0%B7%E8%BF%94%E5%9B%9E%E6%95%B4%E5%9E%8B%E6%88%96-exit-code%EF%BC%9F"><span class="toc-number">1.3.3.2.</span> <span class="toc-text">2. 为什么不是像 fork() 那样返回整型或 exit code？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E7%BA%BF%E7%A8%8B%E7%BB%88%E6%AD%A2"><span class="toc-number">1.4.</span> <span class="toc-text">4. 线程终止</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%BA%BF%E7%A8%8B%E7%BB%88%E6%AD%A2%E7%9A%84-4-%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%88%E6%A0%B8%E5%BF%83%EF%BC%89"><span class="toc-number">1.4.1.</span> <span class="toc-text">1. 线程终止的 4 种方式（核心）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-pthread-exit-%E2%80%94%E2%80%94-%E4%B8%BB%E5%8A%A8%E9%80%80%E5%87%BA%E5%BD%93%E5%89%8D%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.4.2.</span> <span class="toc-text">2. pthread_exit —— 主动退出当前线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%8A%9F%E8%83%BD-4"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">1. 功能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B-3"><span class="toc-number">1.4.2.2.</span> <span class="toc-text">2. 函数原型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%8F%82%E6%95%B0%E8%AF%A6%E8%A7%A3-2"><span class="toc-number">1.4.2.3.</span> <span class="toc-text">3. 参数详解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E8%BF%94%E5%9B%9E%E5%80%BC-2"><span class="toc-number">1.4.2.4.</span> <span class="toc-text">4. 返回值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B-2"><span class="toc-number">1.4.2.5.</span> <span class="toc-text">5. 代码示例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-pthread-cancel-%E2%80%94%E2%80%94-%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82"><span class="toc-number">1.4.3.</span> <span class="toc-text">3. pthread_cancel —— 发送请求</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%8A%9F%E8%83%BD-5"><span class="toc-number">1.4.3.1.</span> <span class="toc-text">1. 功能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B-4"><span class="toc-number">1.4.3.2.</span> <span class="toc-text">2. 函数原型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%8F%82%E6%95%B0%E8%AF%A6%E8%A7%A3-3"><span class="toc-number">1.4.3.3.</span> <span class="toc-text">3. 参数详解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E8%BF%94%E5%9B%9E%E5%80%BC-3"><span class="toc-number">1.4.3.4.</span> <span class="toc-text">4. 返回值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">1.4.3.5.</span> <span class="toc-text">5. 注意事项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.4.3.6.</span> <span class="toc-text">6. 代码示例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%B0%8F%E7%BB%93"><span class="toc-number">1.4.4.</span> <span class="toc-text">4. 小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E7%BA%BF%E7%A8%8B%E5%88%86%E7%A6%BB"><span class="toc-number">1.5.</span> <span class="toc-text">5. 线程分离</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%BA%BF%E7%A8%8B%E5%88%86%E7%A6%BB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F"><span class="toc-number">1.5.1.</span> <span class="toc-text">1. 线程分离是什么，有什么用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-pthread-detach-%E5%87%BD%E6%95%B0"><span class="toc-number">1.5.2.</span> <span class="toc-text">2. pthread_detach 函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%8A%9F%E8%83%BD-6"><span class="toc-number">1.5.2.1.</span> <span class="toc-text">1. 功能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B-5"><span class="toc-number">1.5.2.2.</span> <span class="toc-text">2. 函数原型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E"><span class="toc-number">1.5.2.3.</span> <span class="toc-text">3. 参数说明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E8%BF%94%E5%9B%9E%E5%80%BC-4"><span class="toc-number">1.5.2.4.</span> <span class="toc-text">4. 返回值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B-3"><span class="toc-number">1.5.2.5.</span> <span class="toc-text">5. 代码示例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%BA%BF%E7%A8%8B%E5%88%86%E7%A6%BB%E7%9A%84%E6%9C%AC%E8%B4%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.5.3.</span> <span class="toc-text">3. 线程分离的本质是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%B0%8F%E7%BB%93-1"><span class="toc-number">1.5.4.</span> <span class="toc-text">4. 小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-C-%E8%AF%AD%E8%A8%80%E5%B1%82%E9%9D%A2%E4%B8%8A%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%94%AF%E6%8C%81%EF%BC%88C-11-%E8%B5%B7%EF%BC%8C%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="toc-number">1.6.</span> <span class="toc-text">6. C++ 语言层面上的多线程支持（C++11 起，了解）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-pthread-VS-std-thread"><span class="toc-number">1.6.1.</span> <span class="toc-text">1. pthread VS std:: thread</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-std-thread-vs-pthread-%E5%AF%B9%E7%85%A7%E8%A1%A8"><span class="toc-number">1.6.2.</span> <span class="toc-text">2. std::thread vs pthread 对照表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.6.3.</span> <span class="toc-text">3. 代码示例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.6.3.1.</span> <span class="toc-text">1. 创建线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%AD%89%E5%BE%85%E7%BA%BF%E7%A8%8B%E7%BB%93%E6%9D%9F%EF%BC%9Ajoin"><span class="toc-number">1.6.3.2.</span> <span class="toc-text">2. 等待线程结束：join()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%88%86%E7%A6%BB%E7%BA%BF%E7%A8%8B%EF%BC%9Adetach"><span class="toc-number">1.6.3.3.</span> <span class="toc-text">3. 分离线程：detach()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E8%8E%B7%E5%8F%96%E7%BA%BF%E7%A8%8B-ID"><span class="toc-number">1.6.3.4.</span> <span class="toc-text">4. 获取线程 ID</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E6%94%AF%E6%8C%81-lambda%EF%BC%88%E8%B6%85%E6%96%B9%E4%BE%BF%EF%BC%81%EF%BC%89"><span class="toc-number">1.6.3.5.</span> <span class="toc-text">5. 支持 lambda（超方便！）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E6%94%AF%E6%8C%81%E7%B1%BB%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">1.6.3.6.</span> <span class="toc-text">6. 支持类成员函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E5%8F%AF%E9%87%8D%E5%85%A5%E4%B8%8E%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="toc-number">1.7.</span> <span class="toc-text">7. 可重入与线程安全</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%EF%BC%9A%E4%B8%80%E4%B8%AA%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%85%A5%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">1.7.1.</span> <span class="toc-text">1. 代码示例：一个不可重入的函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%8F%AF%E9%87%8D%E5%85%A5%E5%87%BD%E6%95%B0%E5%BA%94%E8%AF%A5%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%EF%BC%9F"><span class="toc-number">1.7.2.</span> <span class="toc-text">2. 可重入函数应该是什么样？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%B0%8F%E7%BB%93"><span class="toc-number">1.7.3.</span> <span class="toc-text">3. 小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E4%BB%A3%E7%A0%81%E5%AE%9E%E6%88%98"><span class="toc-number">1.8.</span> <span class="toc-text">8. 代码实战</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%A4%9A%E7%A7%8D%E7%BB%88%E6%AD%A2%E6%96%B9%E5%BC%8F"><span class="toc-number">1.8.1.</span> <span class="toc-text">1. 多种终止方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8D%8F%E5%90%8C"><span class="toc-number">1.8.2.</span> <span class="toc-text">2. 多线程的协同</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%89%B9%E6%80%A7%E7%BB%BC%E5%90%88%E6%BC%94%E7%A4%BA"><span class="toc-number">1.8.3.</span> <span class="toc-text">3. 多线程特性综合演示</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/62772.html" title="050 传输层 —— UDP"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://zycs-img-8kd.pages.dev/v2/0k1JltC.jpeg?_r_=2f802891-8784-4ddb-e5bd-9d61b1397323" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="050 传输层 —— UDP"/></a><div class="content"><a class="title" href="/posts/62772.html" title="050 传输层 —— UDP">050 传输层 —— UDP</a><time datetime="2025-09-12T04:00:00.000Z" title="发表于 2025-09-12 12:00:00">2025-09-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/34998.html" title="049 HTTPS 协议原理"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://zycs-img-8kd.pages.dev/v2/fETMVUS.jpeg?_r_=c529c723-4b01-5bf8-fe19-d1438fd9563d" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="049 HTTPS 协议原理"/></a><div class="content"><a class="title" href="/posts/34998.html" title="049 HTTPS 协议原理">049 HTTPS 协议原理</a><time datetime="2025-08-28T04:00:00.000Z" title="发表于 2025-08-28 12:00:00">2025-08-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/63840.html" title="048 HTTP 协议"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://zycs-img-8kd.pages.dev/v2/aKlysyx.png?_r_=6011401b-b224-1423-1a89-ceeead1936d4" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="048 HTTP 协议"/></a><div class="content"><a class="title" href="/posts/63840.html" title="048 HTTP 协议">048 HTTP 协议</a><time datetime="2025-08-25T04:00:00.000Z" title="发表于 2025-08-25 12:00:00">2025-08-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/38905.html" title="047 网络传输基础：TCP 连接建立与数据序列化"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://zycs-img-8kd.pages.dev/v2/Jci6x23.png?_r_=c7a9f229-9f6b-3f2e-87d5-e6ca5316f5f5" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="047 网络传输基础：TCP 连接建立与数据序列化"/></a><div class="content"><a class="title" href="/posts/38905.html" title="047 网络传输基础：TCP 连接建立与数据序列化">047 网络传输基础：TCP 连接建立与数据序列化</a><time datetime="2025-08-22T04:00:00.000Z" title="发表于 2025-08-22 12:00:00">2025-08-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/40348.html" title="046 网络编程套接字"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://zycs-img-8kd.pages.dev/v2/fETMVUS.jpeg?_r_=c35415b9-7cc5-c591-5bcd-f604827a0a65" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="046 网络编程套接字"/></a><div class="content"><a class="title" href="/posts/40348.html" title="046 网络编程套接字">046 网络编程套接字</a><time datetime="2025-08-15T04:00:00.000Z" title="发表于 2025-08-15 12:00:00">2025-08-15</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div id="footer_deal"><a class="deal_link" href="mailto:hc1960074081@qq.com" title="email"><i class="anzhiyufont anzhiyu-icon-envelope"></i></a><a class="deal_link" target="_blank" rel="noopener" href="https://weibo.com/u/7913790969" title="微博"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a><img class="footer_mini_logo" title="返回顶部" alt="返回顶部" onclick="anzhiyu.scrollToDest(0, 500)" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://zycs-img-8kd.pages.dev/v2/bFRjgdX.jpeg" size="50px"/><a class="deal_link" target="_blank" rel="noopener" href="https://github.com/huangcancan-xbc" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a><a class="deal_link" target="_blank" rel="noopener" href="https://space.bilibili.com/1918272544" title="Bilibili"><i class="anzhiyufont anzhiyu-icon-bilibili"></i></a></div></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2025 By <a class="footer-bar-link" href="/" title="小米里的大麦" target="_blank">小米里的大麦</a></div></div><div id="footer-type-tips"></div><div class="js-pjax"><script>function subtitleType () {
  fetch('https://v1.hitokoto.cn')
    .then(response => response.json())
    .then(data => {
      if (true) {
        const from = '出自 ' + data.from
        const sub = ["《左传》载曰：“太上有立德，其次有立功，其次有立言，虽久不废，此之谓不朽。”","纸上得来终觉浅，绝知此事要躬行！","你太专注于未来，却没有意识到，今天正是你多年前祈求的模样，因为你眺望远方视而不见。","梦想是不会发光的，发光的是追梦的你！","答案在风中飘扬"]
        sub.unshift(data.hitokoto, from)
        window.typed = new Typed('#footer-type-tips', {
          strings: sub,
          startDelay: 300,
          typeSpeed: 150,
          loop: true,
          backSpeed: 50,
        })
      } else {
        document.getElementById('footer-type-tips').innerHTML = data.hitokoto
      }
    })
}

if (true) {
  if (typeof Typed === 'function') {
    subtitleType()
  } else {
    getScript('https://cdn.cbd.int/typed.js@2.1.0/dist/typed.umd.js').then(subtitleType)
  }
} else {
  subtitleType()
}
</script></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/huangcancan-xbc" title="GitHub主页">GitHub主页</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">64</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">19</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">6</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">社交</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://github.com/huangcancan-xbc" title="GitHub"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="GitHub"/><span class="back-menu-item-text">GitHub</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://space.bilibili.com/1918272544" title="哔哩哔哩"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="哔哩哔哩"/><span class="back-menu-item-text">哔哩哔哩</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://gitee.com/huang-cancan-xbc" title="Gitee"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="Gitee"/><span class="back-menu-item-text">Gitee</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">博客</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://blog.csdn.net/Huangcancan666?type=blog" title="CSDN"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="CSDN"/><span class="back-menu-item-text">CSDN</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://juejin.cn/user/3230789931118109" title="稀土掘金"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="稀土掘金"/><span class="back-menu-item-text">稀土掘金</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/charts/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 统计</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 外链</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/music/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/C/" style="font-size: 0.88rem;">C++<sup>8</sup></a><a href="/tags/Git/" style="font-size: 0.88rem;">Git<sup>3</sup></a><a href="/tags/IO/" style="font-size: 0.88rem;">IO<sup>3</sup></a><a href="/tags/Linux/" style="font-size: 0.88rem;">Linux<sup>50</sup></a><a href="/tags/Obsidian/" style="font-size: 0.88rem;">Obsidian<sup>1</sup></a><a href="/tags/STL/" style="font-size: 0.88rem;">STL<sup>2</sup></a><a href="/tags/VS-Code/" style="font-size: 0.88rem;">VS Code<sup>1</sup></a><a href="/tags/%E4%BF%A1%E5%8F%B7/" style="font-size: 0.88rem;">信号<sup>3</sup></a><a href="/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" style="font-size: 0.88rem;">内存管理<sup>1</sup></a><a href="/tags/%E5%8E%86%E7%A8%8B/" style="font-size: 0.88rem;">历程<sup>1</sup></a><a href="/tags/%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/" style="font-size: 0.88rem;">地址空间<sup>6</sup></a><a href="/tags/%E6%95%B0%E5%AD%A6/" style="font-size: 0.88rem;">数学<sup>1</sup></a><a href="/tags/%E6%A8%A1%E6%9D%BF/" style="font-size: 0.88rem;">模板<sup>1</sup></a><a href="/tags/%E7%AE%A1%E9%81%93/" style="font-size: 0.88rem;">管道<sup>2</sup></a><a href="/tags/%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/" style="font-size: 0.88rem;">类与对象<sup>3</sup></a><a href="/tags/%E7%BA%BF%E7%A8%8B/" style="font-size: 0.88rem;">线程<sup>4</sup></a><a href="/tags/%E7%BD%91%E7%AB%99/" style="font-size: 0.88rem;">网站<sup>2</sup></a><a href="/tags/%E7%BD%91%E7%BB%9C/" style="font-size: 0.88rem;">网络<sup>6</sup></a><a href="/tags/%E8%BF%9B%E7%A8%8B/" style="font-size: 0.88rem;">进程<sup>15</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="anzhiyufont anzhiyu-icon-comments"></i></a><a id="switch-commentBarrage" href="javascript:anzhiyu.switchCommentBarrage();" title="开关弹幕"><i class="anzhiyufont anzhiyu-icon-danmu"></i></a><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button><button id="go-down" type="button" title="直达底部" onclick="anzhiyu.scrollToDest(document.body.scrollHeight, 500)"><i class="anzhiyufont anzhiyu-icon-arrow-down"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="anzhiyufont anzhiyu-icon-xmark"></i></button></nav><div class="is-center" id="loading-database"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-pulse-icon"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("01/01/2025 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `这里是 小米里的大麦`,
    `芝兰生于深谷，不以无人而不芳。`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2025 By 安知鱼 V1.6.14",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 小米里的大麦 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>(() => {
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://twikoo-olive-one.vercel.app/',
      // 自己额外添加的：
      path: location.pathname.replace(/index\.html$/, ''),
      
      region: 'ap-shanghai',
      onCommentLoaded: () => {
        anzhiyu.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') setTimeout(runFn,0)
    else getScript('https://cdn.cbd.int/twikoo@1.6.44/dist/twikoo.all.min.js').then(runFn)
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://twikoo-olive-one.vercel.app/',
      region: 'ap-shanghai',
      urls: [window.location.pathname],
      includeReply: false
    }).then(res => {
      countELement.textContent = res[0].count
    }).catch(err => {
      console.error(err)
    })
  }

  const runFn = () => {
    init();
    GLOBAL_CONFIG_SITE.isPost && getCount()
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) anzhiyu.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else {
      loadTwikoo()
    }
  } else {
    window.loadOtherComment = loadTwikoo
  }
})()</script><input type="hidden" name="page-type" id="page-type" value="post"><script async src="/js/anzhiyu/comment_barrage.js"></script></div><script>window.addEventListener('load', () => {
  const changeContent = (content) => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const getComment = () => {
    const runTwikoo = () => {
      twikoo.getRecentComments({
        envId: 'https://twikoo-olive-one.vercel.app/',
        region: 'ap-shanghai',
        pageSize: 6,
        includeReply: true
      }).then(function (res) {
        const twikooArray = res.map(e => {
          return {
            'content': changeContent(e.comment),
            'avatar': e.avatar,
            'nick': e.nick,
            'url': e.url + '#' + e.id,
            'date': new Date(e.created).toISOString()
          }
        })

        saveToLocal.set('twikoo-newest-comments', JSON.stringify(twikooArray), 10/(60*24))
        generateHtml(twikooArray)
      }).catch(function (err) {
        const $dom = document.querySelector('#card-newest-comments .aside-list')
        $dom.textContent= "无法获取评论，请确认相关配置是否正确"
      })
    }

    if (typeof twikoo === 'object') {
      runTwikoo()
    } else {
      getScript('https://cdn.cbd.int/twikoo@1.6.44/dist/twikoo.all.min.js').then(runTwikoo)
    }
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'data-lazy-src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'><div class='name'><span>${array[i].nick} </span></div></a>`
        }
        
        result += `<div class='content'>
        <a class='comment' href='${array[i].url}' title='${array[i].content}'>${array[i].content}</a>
        <time datetime="${array[i].date}">${anzhiyu.diffDate(array[i].date, true)}</time></div>
        </div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom && ($dom.innerHTML= result)
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('twikoo-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><script async data-pjax src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.1/bubble/bubble.js"></script><script>var visitorMail = "xiaomilidedamai@minbit.top";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://cdn.cbd.int/qrcodejs@1.0.0/qrcode.min.js"></script><script src="/js/anzhiyu/right_click_menu.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><script src="https://cdn.bootcdn.net/ajax/libs/echarts/4.9.0-rc.1/echarts.min.js"></script><script src="/js/footer-animal.js" defer></script><script id="click-show-text" src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/dist/click-show-text.min.js" data-mobile="false" data-text="offer,暴富,健康,offer,喜乐,成功,offer,好运,自由,offer,坚持,上岸" data-fontsize="20px" data-random="true" async="async"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["meta[property=\"og:image\"]","meta[property=\"og:title\"]","meta[property=\"og:url\"]","meta[property=\"og:type\"]","meta[property=\"og:site_name\"]","meta[property=\"og:description\"]","head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"]):not([href="/music/"]):not([href="/no-pjax/"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script><script>//- 留言板页面弹幕
window.addEventListener('load', () => {
  const getnaokuo_danmu = () => {
    if (!window.location.pathname.startsWith('/comments/')) return; //- 判断是否是留言板页面
    const naokuo_danmu = async () => {
      const Danmaku = new EasyDanmaku({
        page: '/comments/', //- 即留言板地址
        el: '#danmu-wrap', //- 弹幕挂载节点
        line: 5, //- 弹幕行数
        speed: 20, //- 弹幕播放速度
        hover: true, //- 鼠标hover时是否暂停播放弹幕
        loop: false, //- 开启循环播放
        colourful: true, //- 开启彩色弹幕
        coefficient: 1.38, //- 弹幕密度系数
        runtime: 10, //- 循环弹幕播放时长
      });
      try {
        let danmuStore = saveToLocal.get('twikoo-danmu');
        if (!danmuStore) {
          const options = {
            method: "POST",
            body: JSON.stringify({
              "event": "GET_RECENT_COMMENTS",
              "includeReply": false,
              "pageSize": 100
            }),
            headers: { 'Content-Type': 'application/json' }
          }
          danmuStore = [];
          const response = await fetch(`https://twikoo-olive-one.vercel.app/`, options);
          if (response.ok) {
            const { data } = await response.json();
            //- console.info(data);
            data.forEach(i => {
              if (i.avatar == undefined) i.avatar = 'https://cravatar.cn/avatar/d615d5793929e8c7d70eab5f00f7f5f1?d=mp'
              danmuStore.push({ avatar: i.avatar, content: i.nick + '：' + formatDanmaku(i.comment), url: i.url + '#' + i.id })
            });
            Danmaku.batchSend(danmuStore, true);
            saveToLocal.set('twikoo-danmu', danmuStore, 0.5)
          }
          //- 格式化评论
          function formatDanmaku(str) {
            str = str.replace(/<\/*br>|[\s\uFEFF\xA0]+/g, '');
            str = str.replace(/<img.*?>/g, '[图片]');
            str = str.replace(/<a.*?>.*?<\/a>/g, '[链接]');
            str = str.replace(/<pre.*?>.*?<\/pre>/g, '[代码块]');
            str = str.replace(/<.*?>/g, '');
            return str
          }
        } else {
          Danmaku.batchSend(danmuStore, true);
        }
      } catch (err) {
        console.error("Error fetching data:", err);
      }

      document.getElementById('danmu-Btn') && (document.getElementById('danmu-Btn').innerHTML = `<button class="hide-Btn" onclick="document.getElementById('danmu-wrap').classList.remove('hide-danmu')">显示弹幕</button> <button class="hide-Btn" onclick="document.getElementById('danmu-wrap').classList.add('hide-danmu')">隐藏弹幕</button>`)
    }
    (async () => {
      if (typeof EasyDanmaku === 'function') {
        await naokuo_danmu();
      } else {
        const easyDanmakuScript = await getScript('https://npm.onmicrosoft.cn/naokuo-blog@1.2.12/js/easy-Danmaku.js');
        if (typeof EasyDanmaku === 'function') {
          await naokuo_danmu();
        } else {
          console.error('EasyDanmaku function not found even after loading the script.');
        }
      }
    })();
  }
  getnaokuo_danmu()
  document.addEventListener('pjax:complete', getnaokuo_danmu)
})</script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>