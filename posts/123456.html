<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>C++ STL —— 基于算法竞赛 | 小米里的大麦</title><meta name="keywords" content="C++,STL"><meta name="author" content="小米里的大麦"><meta name="copyright" content="小米里的大麦"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="C++ STL —— 基于算法竞赛"><meta name="application-name" content="C++ STL —— 基于算法竞赛"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="C++ STL —— 基于算法竞赛"><meta property="og:url" content="https://www.minbit.top/posts/123456.html"><meta property="og:site_name" content="小米里的大麦"><meta property="og:description" content="原作者在这里！本文是基于行码棋的文章进行的翻改！   [!NOTE]   相关好文推荐，这篇 STL 我也觉得非常不错！分享给你！   简单分享一下：起初入门 C++，我特别幸运地找到了这篇超级适合 STL 入门和竞赛的文章！一开始只是随便翻了翻，没想到 内容不仅全面详细，而且非常实用，只记得那天下"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Blog/20250314131841400.png?_r_=54019171-75ec-fa78-24a5-3398f8f320b1"><meta property="article:author" content="小米里的大麦"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Blog/20250314131841400.png?_r_=54019171-75ec-fa78-24a5-3398f8f320b1"><meta name="description" content="原作者在这里！本文是基于行码棋的文章进行的翻改！   [!NOTE]   相关好文推荐，这篇 STL 我也觉得非常不错！分享给你！   简单分享一下：起初入门 C++，我特别幸运地找到了这篇超级适合 STL 入门和竞赛的文章！一开始只是随便翻了翻，没想到 内容不仅全面详细，而且非常实用，只记得那天下"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="https://www.minbit.top/posts/123456.html"><link rel="preconnect" href="//cdn.cbd.int"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="manifest" href="/manifest.json"/><meta name="msapplication-TileColor" content="var(--anzhiyu-main)"/><link rel="mask-icon" href="/img/siteicon/apple-icon-180.png" color="#5bbad5"/><link rel="apple-touch-icon" sizes="180x180" href="/img/siteicon/apple-icon-180.png"/><link rel="apple-touch-icon-precomposed" sizes="180x180" href="/img/siteicon/apple-icon-180.png"/><link rel="icon" type="image/png" sizes="32x32" href="/img/siteicon/32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/img/siteicon/16.png"/><link rel="bookmark" href="/img/siteicon/apple-icon-180.png"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2048-2732.jpg" media="(device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2732-2048.jpg" media="(device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1668-2388.jpg" media="(device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2388-1668.jpg" media="(device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1536-2048.jpg" media="(device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2048-1536.jpg" media="(device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1668-2224.jpg" media="(device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2224-1668.jpg" media="(device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1620-2160.jpg" media="(device-width: 810px) and (device-height: 1080px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2160-1620.jpg" media="(device-width: 810px) and (device-height: 1080px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1290-2796.jpg" media="(device-width: 430px) and (device-height: 932px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2796-1290.jpg" media="(device-width: 430px) and (device-height: 932px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1179-2556.jpg" media="(device-width: 393px) and (device-height: 852px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2556-1179.jpg" media="(device-width: 393px) and (device-height: 852px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1284-2778.jpg" media="(device-width: 428px) and (device-height: 926px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2778-1284.jpg" media="(device-width: 428px) and (device-height: 926px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1170-2532.jpg" media="(device-width: 390px) and (device-height: 844px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2532-1170.jpg" media="(device-width: 390px) and (device-height: 844px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1125-2436.jpg" media="(device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2436-1125.jpg" media="(device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1242-2688.jpg" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2688-1242.jpg" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-828-1792.jpg" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1792-828.jpg" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1242-2208.jpg" media="(device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2208-1242.jpg" media="(device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-750-1334.jpg" media="(device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1334-750.jpg" media="(device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-640-1136.jpg" media="(device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1136-640.jpg" media="(device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/swiper/swiper.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: {"enable":true,"title":"友链 + 外链 + 无限进步！欢迎欣赏和贡献！","addFriendPlaceholder":"昵称（请勿包含博客等字样）：\n网站地址（要求博客地址，请勿提交个人主页）：\n头像图片url（请提供尽可能清晰的图片，我会上传到我自己的图床）：\n描述：\n站点截图（可选）：\n"},
  peoplecanvas: undefined,
  postHeadAiDescription: {"enable":true,"gptName":"小米里的大麦","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":4,"basicWordCount":1999,"key":"93d1622eadde491eb0594b68ade51723.kaEiDD6A3KPzb7xv","Referer":"https://www.minbit.top/"},
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: {"enable":true,"ck":"Jp8wwGQpp21utaFQ","LingQueMonitorID":"Jp8ztDRrxmTf7LDj"},
  greetingBox: {"enable":true,"default":"晚上好👋","list":[{"greeting":"晚安😴","startTime":0,"endTime":5},{"greeting":"早上好鸭👋, 祝你一天好心情！","startTime":6,"endTime":9},{"greeting":"上午好👋, 状态很好，鼓励一下～","startTime":10,"endTime":10},{"greeting":"11点多啦, 在坚持一下就吃饭啦～","startTime":11,"endTime":11},{"greeting":"午安👋, 宝贝","startTime":12,"endTime":14},{"greeting":"🌈充实的一天辛苦啦！","startTime":14,"endTime":18},{"greeting":"19点喽, 奖励一顿丰盛的大餐吧🍔。","startTime":19,"endTime":19},{"greeting":"晚上好👋, 在属于自己的时间好好放松😌~","startTime":20,"endTime":24}]},
  twikooEnvId: 'https://twikoo-olive-one.vercel.app/',
  commentBarrageConfig:{"enable":true,"maxBarrage":10,"barrageTime":5000,"accessToken":"25c96851dd8a790c4819ad4bfbaf153c","mailMd5":"7b12ebc2be80f9159099f6ab0e16573c"},
  music_page_default: "nav_music",
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: {"mode":"both","api":"https://img2color-go.vercel.app/api?img=","cover_change":true},
  authorStatus: {"skills":["🧐 准备中，就快好了，真的！😭","📚 正在学习中，加油！","🎵 喜欢听音乐，喜欢看动漫"]},
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: 小米里的大麦","link":"链接: ","source":"来源: 小米里的大麦","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-right"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: '小米里的大麦',
  title: 'C++ STL —— 基于算法竞赛',
  postAI: '这篇文章讲述了C++ STL中基于算法竞赛的内容，重点介绍了vector、stack、queue、deque和priority_queue等容器以及map。文章详细解释了这些容器的初始化方法、方法函数、元素访问方式以及如何使用迭代器进行遍历。对于vector，文章强调了其在局部区域中的存储位置和初始化方式，包括一维和二维数组的初始化。对于stack和queue，文章介绍了它们的初始化方法和如何使用数组模拟这些数据结构进行遍历。deque和priority_queue的部分则讲解了它们的特性和如何设置优先级，包括基础数据类型和高级数据类型（结构体）的优先级设置。最后，文章介绍了map的特性和初始化方法，以及如何使用迭代器进行正反向遍历。整体而言，这篇文章为算法竞赛提供了实用的STL使用指南，帮助读者更好地理解和应用这些容器。',
  pageFillDescription: ', 1 vector, 1.1 介绍, 1.1.1 简介, 1.1.2 初始化, 1.2 方法函数, 1.2.1 函数总结, 1.2.2 注意情况, 1.3 元素访问, 1.3.1 下标访问, 1.3.2 迭代器访问, 1.3.3 智能指针, 2 stack, 2.1 介绍, 2.2 方法函数, 2.3 栈元素访问, 2.3.1 栈遍历, 2.3.2 数组模拟栈进行遍历, 3 queue, 3.1 介绍, 3.2 方法函数, 3.3 队列模拟, 4 deque, 4.1 介绍, 4.2 方法函数, 4.3 注意点, 5 priority_queue, 5.1 介绍, 5.2 函数方法, 5.3 设置优先级, 5.3.1 基本数据类型的优先级, 5.3.2 高级数据类型(结构体)优先级, 5.4 存储特殊类型的优先级, 5.4.1 存储 pair 类型, 6 map, 6.1 介绍, 6.1.1 简介, 6.1.2 初始化, 6.2 函数方法, 6.2.1 函数方法, 6.2.2 注意情况, 6.2.3 迭代器进行正反向遍历, 6.2.4 二分查找, 6.3 添加元素, 6.4 访问元素, 6.4.1 下标访问, 6.4.2 遍历访问, 6.5 与 unordered_map 的比较, 6.5.1 内部实现原理, 6.5.2 效率比较, 6.5.3 自定义 hash 函数, 7 set, 7.1 介绍, 7.2 函数方法, 7.3 元素访问, 7.4 重载 lt 运算符, 7.5 multiset, 8 pair, 8.1 介绍, 8.2 访问, 9 string, 9.1 介绍, 9.2 初始化及定义, 9.3 string 特性, 9.4 读入详解, 9.5 函数方法, 10 bitset, 10.1 介绍, 10.2 初始化定义, 10.3 特性, 10.4 方法函数, 10.5 bitset 优化, 11 array, 11.1 介绍, 11.2 声明与初始化, 11.3 存取元素, 11.4 成员函数, 11.5 部分用法示例, 12 tuple, 12.1 介绍, 12.2 声明初始化, 12.3 元素操作, 12.4 函数操作, STL 函数, sort —— 排序, stable_sort, is_sorted, iota, partial_sort, max + min —— 找最值, max_element+min_element, nth_element —— 寻找第 n 小的值, minmax, minmax_element, to_string —— 将数字转化成字符串, lower_bound + upper_bound —— 二分查找, atoi —— 将字符串转整型, stoi x2F stoll x2F stod x2F … —— 将字符串转整型（更常用）, reverse —— 翻转, getline + istringstream —— 读取一行x2F对字符串流进行分割, set_union set_intersection set_difference —— 交并差集, back_inserter, isdigit、isalpha —— 判断是否是数字x2F字符, gcd —— 最大公约数lcm —— 最小公倍数, __gcd —— 最大公约数, __lg, accumulate —— 序列求和, ceil —— 向上取整, fill, next_permutation, random_shuffle, transform, unique, __builtin_ 内置位运算函数, C++20 ranges原作者在这里本文是基于行码棋的文章进行的翻改相关好文推荐这篇我也觉得非常不错分享给你简单分享一下起初入门我特别幸运地找到了这篇超级适合入门和竞赛的文章一开始只是随便翻了翻没想到内容不仅全面详细而且非常实用只记得那天下午用了两个小时从头到尾仔细的看了一遍结果越看越上头不靠视频也能高效快速的学习对当时完全没阅读习惯的我来说简直是个奇迹后来的几天时间也是断断续续的在看一周时间就可以快速上手了相信屏幕前的你比我更快这篇文章最大的优点就是实用不是那种光讲理论没法落地的内容在后来的刷题和深入学习的过程中每次遇到不会的地方我也时不时的会翻出来查就像一本随身的字典某些地方反复看了很多遍每次都会有新的收获随着不断实践回顾相关知识越来越清晰使用起来也越来越顺手简直就像高中查笔记一样真的让我受益匪浅希望也能帮到你实践才是检验真理的唯一标准介绍简介为可变长数组动态数组定义的数组可以随时添加数值和删除元素注意在局部区域中比如局部函数里面开数组是在堆空间里面开的在局部区域开数组是在栈空间开的而栈空间比较小如果开了非常长的数组就会发生爆栈故局部区域不可以开大长度数组但是可以开大长度包含头文件初始化一维初始化定义了一个名为的一维数组数组存储类型数据定义了一个名为的一维数组数组存储类型数据定义了一个名为的一维数组数组存储结构体类型数据是结构体类型指定长度和初始值的初始化定义一个长度为的数组初始值默认为下标范围到所有的元素初始值均为注意指定数组长度之后指定长度后的数组就相当于正常的数组了初始化中有多个元素数组中有五个元素数组长度就为拷贝初始化两个数组中的类型必须相同和都是长度为初始值都为的数组也是拷贝初始化和是完全一样的数组二维初始化定义第一维固定长度为第二维可变化的二维数组定义可变长二维数组注意行不可变只有行而列可变可以在指定行添加元素第一维固定长度为第二维长度可以改变可以这样理解长度为的数组数组中存储的是数据类型而该类型就是数组形式故为二维数组其中每个数组元素均为空因为没有指定长度所以第二维可变长可以进行下述操作行列均可变初始化二维均可变长数组定义一个行和列均可变的二维数组应用可以在数组里面装多个数组可以作为的初始化相当于一个无名行列长度均固定行列初始值为及以上支持的形式定义模板类的对象时可以不指定模板参数但必须要在构造函数中能推导出模板参数声明一个类型动态数组初识元素自己指定方法函数函数总结注指定为数组名称代码算法复杂度返回值类型含义引用返回容器中的第一个数据引用返回容器中的最后一个数据引用返回会进行边界检查如果越界会报错比直接使用更好一些常在项目中使用返回实际数据个数类型迭代器返回首元素的迭代器通俗来说就是地址迭代器返回最后一个元素后一个位置的迭代器地址判断是否为空为空返回真反之返回假为数组提前分配的内存大小即改变了的大小主要是为了防止在过程中多次的内存拷贝将另外一个容器里的内容拷贝到中将个值拷贝到数组中这会清除掉容器中以前的内容数组的将变为不会改变删除最后一个数据在尾部加一个数据在数组中加入一个数据和功能基本一样在某些情况下比它效率更高支持传入多个构造参数清除容器中的所有元素改变数组大小为个空间数值赋为如果没有默认赋值为向任意迭代器插入一个元素例将插入的位置删除的所有元素注意情况返回的是最后一个元素的后一个位置的地址不是最后一个元素的地址所有容器均是如此使用函数时若之前指定过大小为即数组大小变小了数组会保存前个元素前个元素值为原来的值不是都为即数组大小变大了数组会在后面插入个值为的元素也就是说这个初始值只对新插入的元素生效使用排序要为函数请参考本文最后面函数系列对所有元素进行排序如果要对指定区间进行排序可以对里面的参数进行加减改动对区间进行从小到大排序元素访问共三种方法下标法和普通数组一样注意一维数组的下标是从到访问之外的数会出现越界错误迭代器法类似指针一样的访问首先需要声明迭代器变量和声明指针变量一样可以根据代码进行理解附有注释定义一个数组声明一个迭代器指向的初始位置使用非常简便但是会访问数组的所有元素特别注意位置元素也会访问到下标访问直接和普通数组一样进行访问即可添加元素下标访问迭代器访问类似指针迭代器就是充当指针的作用迭代器访问相当于声明了一个迭代器类型的变量通俗来说就是声明了一个指针变量方式一方式二指向尾元素地址的下一个地址或者智能指针只能遍历完数组如果要指定的内容进行遍历需要另选方法能够自动识别并获取类型输入可以进行输入注意加引用输出注意和等价与指针类似和的容器支持的元素访问其它容器可能也可以支持这种方式访问但用的不多可自行尝试介绍栈为数据结构的一种是中实现的一个先进后出后进先出的容器包含头文件初始化是结构体类型方法函数代码含义元素入栈增加元素移除栈顶元素取得栈顶元素但不删除检测栈内是否为空空为真返回栈内元素的个数栈元素访问栈遍历栈只能对栈顶元素进行操作如果想要进行遍历只能将栈中元素一个个取出来存在数组中栈顶元素数组模拟栈进行遍历通过一个数组对栈进行模拟一个存放下标的变量模拟指向栈顶的指针一般来说单调栈和单调队列写法均可使用额外变量或来进行模拟特点比的速度更快遍历元素方便栈从左至右为栈底到栈顶代表栈顶指针初始栈内无元素为入栈出栈入栈操作示意出栈后示意介绍队列是一种先进先出的数据结构包含头文件初始化方法函数代码含义返回队首元素返回队尾元素尾部添加一个元素进队删除第一个元素出队返回队列中元素个数返回值类型判断是否为空队列为空返回队列模拟使用数组模拟队列表示队首元素的下标初始值为表示队尾元素的下标初始值为表示刚开始队列为空一般来说单调栈和单调队列写法均可使用额外变量或来进行模拟入队将所有元素出队介绍首尾都可插入和删除的队列为双端队列添加头文件初始化定义方法函数注意双端队列的常数比较大代码含义把插入队尾后队首返回队尾队首元素删除队尾队首元素删除双端队列中的某一个元素删除双端队列中中的元素判断是否空返回的元素数量清空注意点可以进行排序双端队列排序一般不用感觉毫无用处使用其他依然可以实现相同功能从小到大从大到小排序里面的类型需要是型高版本才可以用介绍优先队列是在正常队列的基础上加了优先级保证每次的队首元素都是优先级最大的可以实现每次从优先队列中取出的元素都是队列中优先级最大的一个它的底层是通过堆来实现的头文件初始化定义函数方法代码含义访问队首元素入队堆顶队首元素出队队列元素个数是否为空注意没有不提供该方法优先队列只能通过访问队首元素优先级最高的元素设置优先级基本数据类型的优先级默认大根堆即每次取出的元素是队列中的最大值小根堆每次取出的元素是队列中的最小值参数解释第一个参数就是优先队列中存储的数据类型第二个参数是用来承载底层数据结构堆的容器若优先队列中存放的是型数据就要填总之存的是什么类型的数据就相应的填写对应类型同时也要改动第三个参数里面的对应类型第三个参数表示数字大的优先级大堆顶为最大的数字表示数字小的优先级大堆顶为最小的数字代表的是数据类型也要填优先队列中存储的数据类型下面介绍基础数据类型优先级设置的写法基础写法非常常用默认大根堆即每次取出的元素是队列中的最大值大根堆每次取出的元素是队列中的最大值同第一行小根堆每次取出的元素是队列中的最小值自定义排序不常见主要是写着麻烦下面的代码比较长基础类型优先级写着太麻烦用第一种即可小根堆大根堆高级数据类型结构体优先级即优先队列中存储结构体类型必须要设置优先级即结构体的比较运算因为优先队列的堆中要比较大小才能将对应最大或者最小元素移到堆顶优先级设置可以定义在结构体内进行小于号重载也可以定义在结构体外要排序的结构体存储在优先队列里面的版本一自定义全局比较规则定义的比较结构体注意是个结构体自定义堆的排序规则初始化定义大的在堆顶版本二直接在结构体里面写因为是在结构体内部自定义的规则一旦需要比较结构体自动调用结构体内部重载运算符规则结构体内部有两种方式方式一为两个结构体参数结构体调用一定要写上按从小到大排大的在堆顶方式二推荐此种直接传入一个参数不必要写按升序排列大的在堆顶优先队列的定义注意优先队列自定义排序规则和函数定义函数很相似但是最后返回的情况是相反的即相同的符号最后定义的排列顺序是完全相反的所以只需要记住的排序规则和优先队列的排序规则是相反的就可以了当理解了堆的原理就会发现堆调整时比较顺序是孩子和父亲节点进行比较如果是那么孩子节点要大于父亲节点堆顶自然是最小值存储特殊类型的优先级存储类型默认排序规则降序排序先按降序排列大的排在前面如果相等再按降序排列也是大的排在前面头文件使用使用使用结果介绍简介映射类似于函数的对应关系每个对应一个而是每个键对应一个值这和的字典类型非常相似容器中的每个存储对为一个键值对包含两个元素键和值初始化初始化定义是结构体类型特性会按照键的顺序从小到大自动排序键的类型必须可以比较大小函数方法函数方法代码含义复杂度返回键为的映射的迭代器注意用函数来定位数据出现位置它返回一个迭代器当数据存在时返回数据所在位置的迭代器数据不存在时返回删除迭代器对应的键和值根据映射的键删除键和值删除左闭右开区间迭代器对应的键和值返回映射的对数清空中的所有元素插入元素插入时要构造键值对如果为空返回否则返回返回指向第一个元素的迭代器地址返回指向尾部的迭代器最后一个元素的下一个地址返回指向最后一个元素的迭代器地址返回指向第一个元素前面上一个的逆向迭代器地址查看元素是否存在因为中键是唯一的所以存在返回不存在返回返回一个迭代器指向键值的第一个元素返回一个迭代器指向键值的第一个元素注意情况下面说明部分函数方法的注意点查找元素是否存在时可以使用但是第三种情况如果不存在对应的时会自动创建一个键值对产生一个额外的键值对空间所以为了不增加额外的空间负担最好使用前两种方法迭代器进行正反向遍历和用法用于正向遍历示例结果和用于逆向遍历示例结果二分查找二分查找和的二分查找以第一个元素即键为准对键进行二分查找返回值为迭代器类型有序添加元素先声明方式一学习看书玩耍打游戏方式二插入元素构造键值对蔬菜方式三水果方式四访问元素下标访问大部分情况用于访问单个元素菜哇菜强哇强菜哇菜只是简写的一个例子程序并不完整遍历访问方式一迭代器访问键值是结构体指针访问所以要用访问是结构体变量访问要用访问方式二智能指针访问键值方式三对指定单个元素访问方式四特性才具有对应键和值与的比较这里就不单开一个大目录讲了直接在里面讲了内部实现原理内部用红黑树实现具有自动排序按键从小到大功能内部用哈希表实现内部元素无序杂乱效率比较优点内部用红黑树实现内部元素具有有序性查询删除等操作复杂度为缺点占用空间红黑树里每个节点需要保存父子节点和红黑性质等信息空间占用较大优点内部用哈希表实现查找速度非常快适用于大量的查询操作缺点建立哈希表比较耗时两者方法函数基本一样差别不大但是需要注意随着内部元素越来越多两种容器的插入删除查询操作的时间都会逐渐变大效率逐渐变低使用查找元素时如果元素不存在两种容器都是创建一个空的元素如果存在会正常索引对应的值所以如果查询过多的不存在的元素值容器内部会创建大量的空的键值对后续查询创建删除效率会大大降低查询容器内部元素的最优方法是先判断存在与否再索引对应值适用于这两种容器以为例此处判断是否存在这个键只有存在才会索引对应的值避免不存在时多余空元素的创建另外还有一种映射键可以重复即一个键对应多个值如要了解可以自行搜索自定义函数由于中的元素需要具备特性如果语言没有自带特性的话需要我们自定义函数以下举一个的函数定义的例子函数看自己怎么定义了只要能实现功能就行使用表达式来定义哈希函数使用表达式作为哈希函数定义为桶的数量调用输出介绍容器中的元素不会重复当插入集合中已有的元素时并不会插入进去而且容器里的元素自动从小到大排序即里面的元素不重复且有序头文件初始化定义函数方法代码复杂度含义返回容器的第一个元素的地址迭代器返回容器的最后一个元素的下一个地址迭代器返回逆序迭代器指向容器元素最后一个位置返回逆序迭代器指向容器第一个元素前面的位置删除容器中的所有的元素无返回值判断容器是否为空插入一个元素返回当前容器中的元素个数删除定位器指向的值删除定位器和之间的值删除键值的值查找查找中的某一元素有则返回该元素对应的迭代器无则返回结束迭代器查找中的元素出现的个数由于中元素唯一此函数相当于查询是否出现返回大于等于的第一个元素的迭代器返回大于的第一个元素的迭代器元素访问迭代器访问智能指针访问最后一个元素第一种第二种打印第三种重载运算符基础数据类型方式一改变排序规则中默认使用比较器即从小到大排序常用默认从小到大排序从大到小排序方式二重载运算符很麻烦不太常用没必要重载运算符返回条件方式三初始化时使用匿名函数定义比较规则从大到小高级数据类型结构体直接重载结构体运算符即可让结构体可以比较按照点的横坐标从小到大排序如果横坐标相同纵坐标从小到大输入输出元素可以重复且元素有序默认升序注意点一方法函数基本和一样参考即可注意点二进行删除操作时要明确删除目标下面为声明的变量名删除多个元素由于元素可以重复注意使用方法时会删除掉所有与相等的元素删除一个元素需要删除一个元素时需要使用操作先找到一个与相等的元素迭代器专门删除这个元素注意点三头文件操作为元素无序且只能出现一次元素无序可以出现多次操作示例说明插入元素删除单个元素只删一个只删一个删除所有某值元素删除所有等于的元素计数某值出现次数返回值为查找元素返回迭代器找不到返回最小值第一个元素最大值最后一个元素反向迭代器判断是否为空是否无元素获取元素个数总元素数含重复包含所在头文件声明一个默认升序的声明一个降序重复插入也是允许的遍历输出一个升序的可以实现一个降序的可以实现介绍只含有两个元素可以看作是只有两个元素的结构体应用代替二元结构体作为键值对进行插入代码如下定义所在的头文件头文件初始化定义带初始值的不带初始值的赋值访问定义结构体数组和结构体类似代表第一个元素代表第二个元素介绍是一个字符串类和型字符串类似可以把理解为一个字符串类型像一样可以定义需要注意的是类型结尾不包含初始化及定义头文件生成空字符串生成的复制品结果为从位置开始长度为结果为长度为结果为构造个字符连接而成的字符串结果为截取第三个元素对应第三位到最后简单使用访问单个字符数组使用结果特性支持比较运算符字符串支持常见的比较操作符支持与的比较如在使用这些操作符的时候是根据当前字符特性将字符按字典顺序进行逐一的比较字典排序靠前的字符小比较的顺序是从前向后比较遇到不相等的字符就按这个位置上的两个字符的比较结果确定两个字符串的大小前面减后面同时支持运算符代表拼接字符串字符串可以拼接通过运算符进行拼接读入详解读入字符串遇空格回车结束读入一行字符串包括空格遇回车结束注意会获取前一个输入的换行符需要在前面添加读取换行符的语句如或错误读取此时读取相当于读取了前一个回车字符正确读取可正确读入下一行的输入与混用输入完后回车遇到回车结束输入但回车还在输入流中并不会清除导致读取回车结束需要在后面加主动删除输入流中的换行符不常用和解锁关闭同步流代码写在函数开头为什么要进行和的解锁原因是在一些题目中读入的数据量很大往往超过了的数据量而和的读入输出的速度很慢是因为和为了兼容语言的读入输出在性能上做了妥协远不如和的速度具体原因可以搜索相关的博客进行了解所以对和进行解锁使和的速度几乎接近和避免输入输出超时注意解锁使用时不能与混用一定要注意会出错与语言字符串的区别是的一个类专门实现字符串的相关操作具有丰富的操作方法数据类型为字符串结尾没有字符语言中的字符串用数组实现类型为字符串结尾以结尾一般来说向数组转换会出现一些问题所以为了能够实现转换有一个方法实现向数组的转换这个在项目中还算比较常用函数方法获取字符串长度代码含义和返回对象的字符个数他们执行效果相同返回对象最多包含的字符数超出会抛出异常重新分配内存之前对象能包含的最大字符数插入代码含义在末尾插入例末尾插入一个字符在位置插入例在第一个位置插入字符在字符串结尾添加字符串例在字符串末尾添加字符串删除代码含义删除字符串中所指的字符删除字符串中迭代器区间上所有字符删除字符串中从索引位置开始的个字符删除字符串中所有字符字符替换代码含义把当前字符串从索引开始的个字符替换为把当前字符串从索引开始的个字符替换为个字符把当前字符串区间替换为为迭代器哦大小写转换法一代码含义转换为小写转换为大写法二通过的算法配合和实现有个参数前个指定要转换的容器的起止范围第个参数是结果存放容器的起始位置第个参数是一元运算转换小写转换大写分割代码含义截取从索引开始的个字符查找代码含义在当前字符串的索引位置默认为开始查找子串返回找到的位置索引表示查找不到子串在当前字符串的索引位置默认为开始查找字符返回找到的位置索引表示查找不到字符在当前字符串的索引位置开始反向查找子串返回找到的位置索引表示查找不到子串在当前字符串的索引位置开始反向查找字符返回找到的位置索引表示查找不到字符在当前字符串的索引位置默认为开始查找子串的字符返回找到的位置索引表示查找不到字符在当前字符串的索引位置默认为开始查找第一个不位于子串的字符返回找到的位置索引表示查找不到字符在当前字符串的索引位置开始查找最后一个位于子串的字符返回找到的位置索引表示查找不到字符在当前字符串的索引位置开始查找最后一个不位于子串的字符返回找到的位置索引表示查找不到子串字符串查找找到后返回首字母在字符串中的下标查找一个字符串结果是从下标为开始找字符返回找到的第一个的下标结果是从字符串的末尾开始查找字符串返回的还是首字母在字符串中的下标结果是从字符串的末尾开始查找字符结果是因为是从末尾开始查找所以返回第一次找到的字符在该字符串中查找第一个属于字符串的字符结果是在该字符串中查找第一个不属于字符串的字符先匹配然后匹配不到所以打印结果是结果是在该字符串最后中查找第一个属于字符串的字符结果是在该字符串最后中查找第一个不属于字符串的字符先匹配然后空格匹配不到所以打印结果是排序按码排序介绍在头文件中它类似数组并且每一个元素只能是或每个元素只用空间头文件初始化定义初始化方法代码含义有位每位都为是型的一个副本是对象中含有的位串的副本是中从位置开始的个位的副本注意必须为常量表达式演示代码无参构造长度为默认每一位为长度为二进制保存前面用补充长度为前面用补充长度为前面用补充特性可以进行位操作对按位异或后赋值给按位与后赋值给按位或后赋值给左移位低位补有自身赋值右移位高位补有自身赋值按位取反左移不赋值右移不赋值为为按位与不赋值按位或不赋值按位异或不赋值访问可以通过访问元素类似数组注意最低位下标为类似于数的二进制表示如下输出方法函数代码含义中是否存在置为的二进制位有返回中是否没有没有返回中为的个数中二进制位的个数测试在位置是否为是返回返回在处的二进制位把中所有位都置为把中位置置为把中所有位都置为把中位置置为把中所有二进制位取反把中位置取反用中同样的二进制位返回一个值优化一般会使用来优化时间复杂度大概时间复杂度会除或例如没有优化的时间复杂度为使用优化后复杂度可能就为或者还有开动态空间的技巧常用在背包优化等算法中动态长度实现开空间的上限一般为数据范围附近的值即为想要开的大小具体算法的实现介绍头文件是新增的容器效率与普通数据相差无几比效率要高自身添加了一些成员函数和其它容器不同容器的大小是固定的无法动态的扩展或收缩只允许访问或者替换存储的元素注意的使用要在命名空间里声明与初始化基础数据类型声明一个大小为的型数组元素的值不确定声明一个大小为的型数组初始值均为初始值与默认元素类型等效声明一个大小为的型数组初始化部分值其余全部为或者可以用等号高级数据类型不同于数组的是对元素类型不做要求可以套结构体存取元素修改元素访问元素下标访问利用访问迭代器访问函数访问下标为的元素加上下标为的元素答案为方法访问将数组下标为位置处的值改为注意获取的下标只能写数字不能填变量成员函数成员函数功能返回容器中第一个元素的访问迭代器地址返回容器最后一个元素之后一个位置的访问迭代器地址返回最后一个元素的访问迭代器地址返回第一个元素之前一个位置的访问迭代器地址返回容器中元素的数量其值等于初始化类的第二个模板参数返回容器可容纳元素的最大数量其值始终等于初始化类的第二个模板参数判断容器是否为空返回容器中位置处元素的引用函数会自动检查是否在有效的范围内如果不是则抛出异常返回容器中第一个元素的直接引用函数不适用于空的容器返回容器中最后一个元素的直接引用函数不适用于空的容器返回一个指向容器首个元素的指针利用该指针可实现复制容器中所有元素等类似功能将这个值赋值给容器中的每个元素相当于初始化交换和容器中的所有元素但前提是它们具有相同的长度和类型部分用法示例指向底层元素存储的指针对于非空容器返回的指针与首元素地址比较相等下标为的元素加上下标为的元素答案为的函数将数组全部元素值变为另外还有其它的函数将数组全部值变为方法获取元素值将数组下标为位置处的值改为注意获取的下标只能写数字不能填变量排序介绍模板是的泛化可以封装不同类型任意数量的对象可以把理解为的扩展可以声明二元组也可以声明三元组可以等价为结构体使用头文件声明初始化声明一个空的三元组赋值创建的同时初始化可以使用对象构造对象但对象必须是两个元素将对象赋给对象元素操作获取对象的第一个元素修改对象的第一个元素函数操作获取元素个数获取对应元素的值通过方法获取必须为数字不能是变量通过解包获取元素值可以让变量中的三个值依次赋到中的三个变量中函数排序时间复杂度作用对一个序列进行排序原型几种排序的常见操作操作一对数组正常升序排序普通数组定义对数组的位置进行从小到大排序数组定义操作二使用第三个参数进行降序排序对数组的位置从大到小排序对数组的位置从小到大排序升序降序操作三另外一种降序排序方法针对使用反向迭代器进行降序排序操作四自定义排序规则使用函数自定义排序定义比较函数按结构体里面的值降序排列只能接受以函数为形式的自定义排序规则无法接受以结构体为形式的自定义排序规则或者使用匿名函数自定义排序规则复杂度功能和基本一样区别在于能够保证相等元素的相对位置排序时不会改变相等元素的相对位置使用用法和一样见上复杂度判断序列是否有序升序返回值如果序列有序输出让序列递增赋值时间复杂度大概其中为距离部分排序排序个元素为要排序区间元素的尾后的一个位置从到前的元素都排好序对数组前个元素排序按从小到大排序前五个元素都有序也可以添加自定义排序规则对的前五个元素都是降序排列前五个元素降序有序找最值时间复杂度找多个元素的最大值和最小值找的最大值和最小值找到的最大值和最小值复杂度找最大最小值函数都是返回地址需要加解引用取值寻找第小的值复杂度平均寻找第序列第小的值为一个迭代器指向序列中的一个元素第小的值恰好在位置上执行之后序列中的元素会围绕进行划分之前的元素都小于等于它而之后的元素都大于等于它实例求序列中的第小的元素复杂度返回一个类型第一个元素是第二个元素是复杂度返回序列中的最小和最大值组成的对应的地址返回类型为返回的是最小值和最大值对应的地址输出对应最小最大值时需要使用指针将数字转化成字符串将数字转化为字符串支持小数二分查找复杂度作用二分查找注意用解引用之后是取出来的是值减去得到的是下标三个参数起始位置结束位置目标值范围左闭右开返回值成功返回有效迭代器指针失败返回前提数据必须有序如果未找到返回尾地址的下一个位置的地址起始迭代器指针结束迭代器指针目标值起始迭代器指针结束迭代器指针目标值在数组中查找第一个大于等于的元素返回该元素的地址在数组中查找第一个大于的元素返回该元素的地址包含和示例使用查找第一个的元素计算下标第一个大于等于的元素是第一个大于等于的元素是没有找到大于等于的元素示例使用查找第一个的元素第一个大于的元素是第一个大于的元素是没有找到大于的元素示例查找不存在的元素第一个大于等于的元素是第一个大于等于的元素是没有找到大于等于的元素示例统计某个值出现的次数出现的次数出现的次数示例在中使用中第一个大于等于的元素是中第一个大于等于的元素是将字符串转整型将字符串转换为类型注意参数为型数组如果需要将类型转换为类型可以使用函数参考下文或者将类型转换为类型关于输出数字的范围不做范围检查如果超出上界输出上界超出下界输出下界会做范围检查默认必须在范围内如果超出范围会出现错误或者将字符串转整型更常用将对应类型字符串转换为数字型记忆分别对应两个数据类型的某个字母注意参数为字符串类型如果要转换为其他类型的数字可使用转换为转换为转换为等函数关于输出数字的范围会做范围检查默认必须在范围内如果超出范围会出现错误不做范围检查如果超出上界输出上界超出下界输出下界翻转时间复杂度对序列进行前后翻转包含在头文件中函数在解决回文串相关问题格外好用对进行翻转对数组进行翻转读取一行对字符串流进行分割时间复杂度头文件读取一行包括空格搭配实现分割处理输入流变量读取整行字符串变量把字符串当作输入流字符串流变量分隔符按分隔符拆分数据字符串流变量按空格拆分数据用于把字符串当作输入流用于按分隔符拆分数据循环用于按空格拆分数据快速记忆字符串流变量分隔符用于读取一整行包括空格默认指定分割符直到遇到换行符换行符会被丢弃不存入变量才结束如果指定了分隔符则会读取到分隔符为止即分隔符的前一个位置分隔符也会被丢弃不存入变量读取的部分会被存储在指定的变量中而分隔符本身不会被包含在结果中然后剩余的部分分隔符后的字符会留在输入流中为下一次读取做准备下一次调用会继续从流中读取直到遇到下一个分隔符或者行结束为止这个过程会一直继续直到所有需要的数据都被提取出来不能读取换行回车所以如果在之前使用了混合输入那么实际读取到的是换行回车就无法正确读入数据很多时候就是因为这个原因导致程序出错常用解决方法当使用了这样的混合输入必须要在和之间写上或者来清除输入缓冲区中的换行符例子清除输入缓冲区中的换行符任选其一包含包含示例输入输出读取到第一个为止继续读取到下一个读取剩余部分默认到行尾示例按空格拆分将字符串转为流按空格提取输出示例按逗号拆分数据输出示例逐行处理输入如文件或控制台每次读取一行按空格拆分每行交并差集复杂度求两个集合的并集交集差集手动实现双指针就可以搞定嫌麻烦可以使用该函数函数作用说明并集两个集合所有元素去重交集两个集合共同的元素差集第一个集合有而第二个集合没有的元素注意必须有序但不强制升序或降序只要两个输入区间是按照相同的排序规则比如都是升序或者都是降序排好的就可以正常使用两个集合必须为有序集合所以下面演示代码使用了排序容器可以替换成容器因为自动会对元素进行排序函数的参数有五个前两个为第一个容器的首尾迭代器第三四个为第二个容器的首尾迭代器最后一个为插入位置即将结果插入到哪个地址之后头文件起始迭代器结束迭代器起始迭代器结束迭代器输出迭代器起始迭代器结束迭代器起始迭代器结束迭代器输出迭代器起始迭代器结束迭代器起始迭代器结束迭代器输出迭代器并交差包含交集预留足够空间并集预留足够空间差集预留足够空间求交集调整交集实际大小求并集调整并集实际大小求差集调整差集实际大小输出交集输出交集元素输出并集输出并集元素输出差集输出差集元素容器名是一个生成输出迭代器的小工具帮你自动在容器尾部插入元素平常如果不用你需要预先分配好大空间还要很麻烦而用就可以不需要提前开空间自动加元素传统写法需要开大空间必须提前开好足够空间最后再调整大小使用最推荐不需要开空间空的就行不需要直接用即可看到了吗自动帮你扩容代码更简洁安全强烈推荐使用判断是否是数字字符处于标准库函数头文件正常来说下面前个是较为常用的记不住也没关系大多数情况也还是手动实现的函数名作用示例输入示例输出判断是否为数字判断是否为字母或判断是否为小写字母判断是否为大写字母判断是否为字母或数字判断是否为空白字符空格判断是否为十六进制数字判断是否为可打印字符判断是否为标点符号是否为可见字符不含空格判断是否为数字字符判断是否为字母大写或小写判断是否为小写字母判断是否为大写字母最大公约数最小公倍数名称所属是否标准头文件支持类型特点说明标准库是等整数类型安全支持推荐使用于现代标准库是等整数求最小公倍数现代推荐方式扩展否原始定义只明确支持类型后续做了处理可以接受等整型参数但仍有部分编译器不支持特有非标准函数竞赛中常用引入头文件输出输出如果环境不支持可以手动实现其两者功能最大公约数求和的最大公约数使用时要包含头文件准确的来说它是一个扩展不属于求一个数二进制下最高位位于第几位从第位开始或二进制数下有几位相当于返回复杂度序列求和复杂度作用对一个序列的元素求和为对序列元素求和的初始值返回值类型与相同基础累加求和对区间求和初始值为结果为对区间求和初始值为结果为自定义二元对象求和使用表达式返回值类型与一致同时注意参数类型也要一样初始值为累加向上取整头文件函数的功能是返回不小于给定参数的最小整数也就是我们所说的向上取整中新增的重载版本中新增的重载版本包含了函数的头文件输出输出输出输出复杂度对一个序列进行初始化赋值对数组的所有元素赋注意区分需要填充内存的指针填充的值字节数是按字节进行赋值对于初始化赋或有比较好的效果如果赋某个特定的数会出错赋值特定的数建议使用时间复杂度求序列的下一个排列下一个排列是字典序大一号的排列返回或如果是最后一个排列返回否则求出下一个序列后返回对序列进行重排应用求所有的排列输出的所有排列数组不一定是最小字典序序列一定注意将它排序求出前一个排列如果序列为最小的排列将其重排为最大的排列返回复杂度随机打乱序列的顺序在中被弃用在中被废除之后应尽量使用来代替序列递增赋值对数组随机重排之后尽量使用复杂度作用使用给定操作将结果写到中原型一般不怎么使用徒增记忆负担不如手动实现将序列开始地址到结束地址大小写转换把结果存到起始地址为的序列中复杂度消除重复元素返回消除完重复元素的下一个位置的地址如之后数组为前面为无重复元素的数组后面则是重复元素移到后面返回位置的地址不重复元素的尾后地址消除重复元素一般需要原序列是有序序列应用离散化方法一利用数组离散化将数组复制到数组排序后对数组排序消除重复元素返回的地址为最后一个元素的地址消除的重复元素并获取长度因为有序查找到的下标就是对应的相对大小离散化后的值在数组中二分查找第一个大于等于的下标离散化赋值方法二利用进行离散化离散后的数据从开始内置位运算函数需要注意内置函数有相应的和版本只需要在函数名后面加上就可以了比如默认是位很多题目和数据类型有关如有需要注意添加二进制中对应最后一位的位数比如会返回中的个数末尾的个数前导的个数因为共有位默认数据范围为位中的个数的奇偶性奇数输出偶数输出主要用来简化迭代器操作可以少写很多迭代器操作相关的代码集成了很多函数可参考链接语法糖',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-05-22 00:00:00',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 10 || hour >= 20
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://github.com/huangcancan-xbc/Drawing-bed/blob/master/Blog/20250307201719879.png?raw=true"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><div class="back-home-button"><i class="anzhiyufont anzhiyu-icon-grip-vertical"></i><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">社交</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://github.com/huangcancan-xbc" title="GitHub"><img class="back-menu-item-icon" src="/img/favicon.ico" alt="GitHub"/><span class="back-menu-item-text">GitHub</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://gitee.com/huang-cancan-xbc" title="Gitee"><img class="back-menu-item-icon" src="/img/favicon.ico" alt="Gitee"/><span class="back-menu-item-text">Gitee</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://space.bilibili.com/1918272544" title="哔哩哔哩"><img class="back-menu-item-icon" src="/img/favicon.ico" alt="哔哩哔哩"/><span class="back-menu-item-text">哔哩哔哩</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">博客</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://blog.csdn.net/Huangcancan666?type=blog" title="CSDN"><img class="back-menu-item-icon" src="/img/favicon.ico" alt="CSDN"/><span class="back-menu-item-text">CSDN</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://juejin.cn/user/3230789931118109" title="稀土掘金"><img class="back-menu-item-icon" src="/img/favicon.ico" alt="稀土掘金"/><span class="back-menu-item-text">稀土掘金</span></a></div></div></div></div><a id="site-name" href="/" accesskey="h"><div class="title">小米里的大麦</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/charts/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 统计</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 外链</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/music/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li></ul></div></div></div><div id="nav-right"><div id="nav-naoDark"><div class="container"><div class="components"><div class="main-button"><div class="moon"></div><div class="moon"></div><div class="moon"></div></div><div class="daytime-backgrond"></div><div class="daytime-backgrond"></div><div class="daytime-backgrond"></div><div class="cloud"><div class="cloud-son"></div><div class="cloud-son"></div><div class="cloud-son"></div><div class="cloud-son"></div><div class="cloud-son"></div><div class="cloud-son"></div></div><div class="cloud-light"><div class="cloud-son"></div><div class="cloud-son"></div><div class="cloud-son"></div><div class="cloud-son"></div><div class="cloud-son"></div><div class="cloud-son"></div></div><div class="stars"><div class="star big"><div class="star-son"></div><div class="star-son"></div><div class="star-son"></div><div class="star-son"></div></div><div class="star big"><div class="star-son"></div><div class="star-son"></div><div class="star-son"></div><div class="star-son"></div></div><div class="star medium"><div class="star-son"></div><div class="star-son"></div><div class="star-son"></div><div class="star-son"></div></div><div class="star medium"><div class="star-son"></div><div class="star-son"></div><div class="star-son"></div><div class="star-son"></div></div><div class="star small"><div class="star-son"></div><div class="star-son"></div><div class="star-son"></div><div class="star-son"></div></div><div class="star small"><div class="star-son"></div><div class="star-son"></div><div class="star-son"></div><div class="star-son"></div></div></div></div></div></div><div class="nav-button only-home" id="travellings_button" title="随机前往一个开往项目网站"><a class="site-page" onclick="anzhiyu.totraveling()" title="随机前往一个开往项目网站" href="javascript:void(0);" rel="external nofollow" data-pjax-state="external"><i class="anzhiyufont anzhiyu-icon-train"></i></a></div><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><div class="nav-button" id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" title="搜索🔍" accesskey="s"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span> 搜索</span></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Blog/20250403212543768.png" target="_blank"><img class="post-qr-code-img" alt="微信" src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Blog/20250403212543768.png"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Blog/20250403212622868.png" target="_blank"><img class="post-qr-code-img" alt="支付宝" src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Blog/20250403212622868.png"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/C/" style="font-size: 1.05rem;">C++<sup>6</sup></a><a href="/tags/Git/" style="font-size: 1.05rem;">Git<sup>3</sup></a><a href="/tags/IO/" style="font-size: 1.05rem;">IO<sup>3</sup></a><a href="/tags/Linux/" style="font-size: 1.05rem;">Linux<sup>28</sup></a><a href="/tags/OS%E5%9F%BA%E7%A1%80/" style="font-size: 1.05rem;">OS基础<sup>1</sup></a><a href="/tags/Obsidian/" style="font-size: 1.05rem;">Obsidian<sup>1</sup></a><a href="/tags/STL/" style="font-size: 1.05rem;">STL<sup>1</sup></a><a href="/tags/Shell/" style="font-size: 1.05rem;">Shell<sup>1</sup></a><a href="/tags/make-file/" style="font-size: 1.05rem;">make file<sup>1</sup></a><a href="/tags/yum/" style="font-size: 1.05rem;">yum<sup>1</sup></a><a href="/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" style="font-size: 1.05rem;">内存管理<sup>1</sup></a><a href="/tags/%E5%8E%86%E7%A8%8B/" style="font-size: 1.05rem;">历程<sup>1</sup></a><a href="/tags/%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/" style="font-size: 1.05rem;">地址空间<sup>1</sup></a><a href="/tags/%E6%9D%83%E9%99%90/" style="font-size: 1.05rem;">权限<sup>1</sup></a><a href="/tags/%E6%A8%A1%E6%9D%BF/" style="font-size: 1.05rem;">模板<sup>1</sup></a><a href="/tags/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/" style="font-size: 1.05rem;">环境变量<sup>1</sup></a><a href="/tags/%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/" style="font-size: 1.05rem;">类与对象<sup>3</sup></a><a href="/tags/%E7%BD%91%E7%AB%99/" style="font-size: 1.05rem;">网站<sup>2</sup></a><a href="/tags/%E8%BF%9B%E5%BA%A6%E6%9D%A1/" style="font-size: 1.05rem;">进度条<sup>1</sup></a><a href="/tags/%E8%BF%9B%E7%A8%8B/" style="font-size: 1.05rem;">进程<sup>6</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/06/"><span class="card-archive-list-date">六月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/05/"><span class="card-archive-list-date">五月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">11</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/04/"><span class="card-archive-list-date">四月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">8</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/03/"><span class="card-archive-list-date">三月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">9</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/02/"><span class="card-archive-list-date">二月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">9</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/01/"><span class="card-archive-list-date">一月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item on" id="consoleCommentBarrage" onclick="anzhiyu.switchCommentBarrage()" title="热评开关"><a class="commentBarrage"><i class="anzhiyufont anzhiyu-icon-message"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div><div id="console-naoDark"><div class="container"><div class="components"><div class="main-button"><div class="moon"></div><div class="moon"></div><div class="moon"></div></div><div class="daytime-backgrond"></div><div class="daytime-backgrond"></div><div class="daytime-backgrond"></div><div class="cloud"><div class="cloud-son"></div><div class="cloud-son"></div><div class="cloud-son"></div><div class="cloud-son"></div><div class="cloud-son"></div><div class="cloud-son"></div></div><div class="cloud-light"><div class="cloud-son"></div><div class="cloud-son"></div><div class="cloud-son"></div><div class="cloud-son"></div><div class="cloud-son"></div><div class="cloud-son"></div></div><div class="stars"><div class="star big"><div class="star-son"></div><div class="star-son"></div><div class="star-son"></div><div class="star-son"></div></div><div class="star big"><div class="star-son"></div><div class="star-son"></div><div class="star-son"></div><div class="star-son"></div></div><div class="star medium"><div class="star-son"></div><div class="star-son"></div><div class="star-son"></div><div class="star-son"></div></div><div class="star medium"><div class="star-son"></div><div class="star-son"></div><div class="star-son"></div><div class="star-son"></div></div><div class="star small"><div class="star-son"></div><div class="star-son"></div><div class="star-son"></div><div class="star-son"></div></div><div class="star small"><div class="star-son"></div><div class="star-son"></div><div class="star-son"></div><div class="star-son"></div></div></div></div></div></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/C/" itemprop="url">C++</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/C/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>C++</span></a><a class="article-meta__tags" href="/tags/STL/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>STL</span></a></span></div></div><h1 class="post-title" itemprop="name headline">C++ STL —— 基于算法竞赛</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2025-05-21T16:00:00.000Z" title="发表于 2025-05-22 00:00:00">2025-05-22</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2025-05-21T16:00:00.000Z" title="更新于 2025-05-22 00:00:00">2025-05-22</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="post-meta-wordcount"><i class="anzhiyufont anzhiyu-icon-file-word post-meta-icon" title="文章字数"></i><span class="post-meta-label" title="文章字数">字数总计:</span><span class="word-count" title="文章字数">19.7k</span><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-clock post-meta-icon" title="阅读时长"></i><span class="post-meta-label" title="阅读时长">阅读时长:</span><span>80分钟</span></span><span class="post-meta-separator"></span><span class="post-meta-pv-cv" id="" data-flag-title="C++ STL —— 基于算法竞赛"><i class="anzhiyufont anzhiyu-icon-fw-eye post-meta-icon"></i><span class="post-meta-label" title="阅读量">阅读量:</span><span id="busuanzi_value_page_pv"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></span><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为西安"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>西安</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Blog/20250314131841400.png?_r_=54019171-75ec-fa78-24a5-3398f8f320b1"></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><div class="post-ai-description"><div class="ai-title"><i class="anzhiyufont anzhiyu-icon-bilibili"></i><div class="ai-title-text">AI-摘要</div><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right"></i><i class="anzhiyufont anzhiyu-icon-circle-dot" title="朗读摘要"></i><div id="ai-tag">小米里的大麦 GPT</div></div><div class="ai-explanation">AI初始化中...</div><div class="ai-btn-box"><div class="ai-btn-item">介绍自己 🙈</div><div class="ai-btn-item">生成本文简介 👋</div><div class="ai-btn-item">推荐相关文章 📖</div><div class="ai-btn-item">前往主页 🏠</div><div class="ai-btn-item" id="go-tianli-blog">前往爱发电购买</div></div><script data-pjax src="/js/anzhiyu/ai_abstract.js"></script></div><article class="post-content" id="article-container" itemscope itemtype="https://www.minbit.top/posts/123456.html"><header><a class="post-meta-categories" href="/categories/C/" itemprop="url">C++</a><a href="/tags/C/" tabindex="-1" itemprop="url">C++</a><a href="/tags/STL/" tabindex="-1" itemprop="url">STL</a><h1 id="CrawlerTitle" itemprop="name headline">C++ STL —— 基于算法竞赛</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">小米里的大麦</span><time itemprop="dateCreated datePublished" datetime="2025-05-21T16:00:00.000Z" title="发表于 2025-05-22 00:00:00">2025-05-22</time><time itemprop="dateCreated datePublished" datetime="2025-05-21T16:00:00.000Z" title="更新于 2025-05-22 00:00:00">2025-05-22</time></header><h1 id="原作者在这里！本文是基于行码棋的文章进行的翻改！"><a href="#原作者在这里！本文是基于行码棋的文章进行的翻改！" class="headerlink" title="原作者在这里！本文是基于行码棋的文章进行的翻改！"></a><a target="_blank" rel="noopener" href="https://wyqz.top/p/870124582.html">原作者在这里！本文是基于行码棋的文章进行的翻改！</a></h1><blockquote>
<p>  [!NOTE]</p>
<p>  <a target="_blank" rel="noopener" href="https://io.zouht.com/154.html">相关好文推荐，这篇 STL 我也觉得非常不错！分享给你！</a></p>
<p>  简单分享一下：起初入门 C++，我特别幸运地找到了这篇超级适合 <code>STL</code> 入门和竞赛的文章！一开始只是随便翻了翻，没想到 <strong>内容不仅全面详细，而且非常实用</strong>，只记得那天下午用了两个小时，从头到尾仔细的看了一遍，结果越看越上头，不靠视频也能高效、快速的学习（对当时完全没阅读习惯的我来说，简直是个奇迹）。后来的几天时间也是断断续续的在看，一周时间就可以 <strong>快速上手 <code>STL</code></strong> 了。相信屏幕前的你比我更快！</p>
<p>  这篇文章最大的优点就是 <strong>实用</strong>，不是那种光讲理论、没法落地的内容。在后来的刷题和深入学习的过程中，每次遇到不会的地方，我也时不时的会翻出来查，就像一本随身的 <strong><code>STL</code> 字典</strong>。某些地方反复看了很多遍，每次都会有新的收获。随着不断 <strong>实践 + 回顾</strong>，相关知识越来越清晰，使用起来也越来越顺手，简直就像高中查笔记一样，真的让我受益匪浅！希望也能帮到你~</p>
</blockquote>
<blockquote>
<p>  [!TIP]</p>
<p>  <strong>实践才是检验真理的唯一标准！</strong></p>
</blockquote>
<h2 id="1-vector"><a href="#1-vector" class="headerlink" title="1 vector"></a>1 vector</h2><h2 id="1-1-介绍"><a href="#1-1-介绍" class="headerlink" title="1.1 介绍"></a>1.1 介绍</h2><h3 id="1-1-1-简介"><a href="#1-1-1-简介" class="headerlink" title="1.1.1 简介"></a>1.1.1 简介</h3><p><code>vector</code> 为可变长数组（动态数组），定义的 <code>vector</code> 数组可以随时添加数值和删除元素。</p>
<blockquote>
<p>注意：<strong>在局部区域中（比如局部函数里面）开 vector 数组，是在堆空间里面开的。</strong></p>
<p>在局部区域开数组是在栈空间开的，而栈空间比较小，如果开了非常长的数组就会发生爆栈。</p>
<p>故局部区域 <strong>不可以</strong> 开大长度数组，但是可以开大长度 <code>vector</code>。</p>
</blockquote>
<p>包含头文件：</p>
<h3 id="1-1-2-初始化"><a href="#1-1-2-初始化" class="headerlink" title="1.1.2 初始化"></a>1.1.2 初始化</h3><ul>
<li><p><strong>一维初始化：</strong></p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; a; 				<span class="comment">//定义了一个名为 a 的一维数组, 数组存储 int 类型数据</span></span><br><span class="line">vector&lt;<span class="type">double</span>&gt; b; 			<span class="comment">//定义了一个名为 b 的一维数组，数组存储 double 类型数据</span></span><br><span class="line">vector&lt;node&gt; c; 			<span class="comment">//定义了一个名为 c 的一维数组，数组存储结构体类型数据，node 是结构体类型</span></span><br></pre></td></tr></table></figure>
<p>  指定 <strong>长度</strong> 和 <strong>初始值</strong> 的初始化</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(n)</span></span>; 			<span class="comment">// 定义一个长度为 n 的数组，初始值默认为 0，下标范围 [0, n - 1]</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(n, <span class="number">1</span>)</span></span>; 		<span class="comment">// v [0] 到 v [n - 1] 所有的元素初始值均为 1</span></span><br><span class="line"><span class="comment">//注意：指定数组长度之后（指定长度后的数组就相当于正常的数组了）</span></span><br></pre></td></tr></table></figure>
<p>  初始化中有多个元素</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; a&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;		<span class="comment">//数组 a 中有五个元素，数组长度就为 5</span></span><br></pre></td></tr></table></figure>
<p>  拷贝初始化</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">b</span><span class="params">(a)</span></span>;               <span class="comment">// 两个数组中的类型必须相同, a 和 b 都是长度为 n+1，初始值都为 0 的数组</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; c = a;              <span class="comment">// 也是拷贝初始化, c 和 a 是完全一样的数组</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>二维初始化：</strong><br>  定义第一维固定长度为 <code>5</code>，第二维可变化的二维数组</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v[<span class="number">5</span>];           <span class="comment">//定义可变长二维数组</span></span><br><span class="line"><span class="comment">//注意：行不可变（只有 5 行）, 而列可变, 可以在指定行添加元素</span></span><br><span class="line"><span class="comment">//第一维固定长度为 5，第二维长度可以改变</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>vector&lt;int&gt; v[5]</code> 可以这样理解：长度为 5 的 v 数组，数组中存储的是 <code>vector&lt;int&gt;</code> 数据类型，而该类型就是数组形式，故 <code>v</code> 为二维数组。其中每个数组元素均为空，因为没有指定长度，所以第二维可变长。可以进行下述操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">v[<span class="number">1</span>].<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">v[<span class="number">2</span>].<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>
</blockquote>
<p>  行列均可变</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化二维均可变长数组</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; v;			<span class="comment">//定义一个行和列均可变的二维数组</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>应用：可以在 <code>v</code> 数组里面装多个数组</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; t1&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; t2&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">v.<span class="built_in">push_back</span>(t1);</span><br><span class="line">v.<span class="built_in">push_back</span>(t2);</span><br><span class="line">v.<span class="built_in">push_back</span>(&#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;) 		<span class="comment">// &#123;3, 4, 5, 6&#125;可以作为 vector 的初始化, 相当于一个无名 vector</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>  行列长度均固定 <code>n + 1</code> 行 <code>m + 1</code> 列初始值为 0</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">a</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m + <span class="number">1</span>, <span class="number">0</span>));</span><br></pre></td></tr></table></figure>
<p>  c++17 及以上支持的形式（定义模板类的对象时，可以不指定模板参数，但必须要在构造函数中能推导出模板参数）</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector a&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;; 			<span class="comment">// 声明一个 int 类型动态数组，初识元素自己指定</span></span><br><span class="line"><span class="function">vector <span class="title">b</span><span class="params">(n + <span class="number">1</span>, vector(m + <span class="number">1</span>, <span class="number">0</span>))</span></span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="1-2-方法函数"><a href="#1-2-方法函数" class="headerlink" title="1.2 方法函数"></a>1.2 方法函数</h2><h3 id="1-2-1-函数总结"><a href="#1-2-1-函数总结" class="headerlink" title="1.2.1 函数总结"></a>1.2.1 函数总结</h3><p>注：c 指定为数组名称</p>
<table>
<thead>
<tr>
<th>代码</th>
<th>算法复杂度</th>
<th>返回值类型</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>c.front()</code></td>
<td>O(1)</td>
<td>引用</td>
<td>返回容器中的第一个数据</td>
</tr>
<tr>
<td><code>c.back()</code></td>
<td>O(1)</td>
<td>引用</td>
<td>返回容器中的最后一个数据</td>
</tr>
<tr>
<td><code>c.at(idx)</code></td>
<td></td>
<td>引用</td>
<td>返回 <code>c[idx]</code> ，会进行边界检查，如果越界会报错，比直接使用 <code>[]</code> 更好一些，常在项目中使用</td>
</tr>
<tr>
<td><code>c.size()</code></td>
<td>O(1)</td>
<td></td>
<td>返回实际数据个数（unsigned 类型）</td>
</tr>
<tr>
<td><code>c.begin()</code></td>
<td>O(1)</td>
<td>迭代器</td>
<td>返回首元素的迭代器（通俗来说就是地址）</td>
</tr>
<tr>
<td><code>c.end()</code></td>
<td>O(1)</td>
<td>迭代器</td>
<td>返回最后一个元素后一个位置的迭代器（地址）</td>
</tr>
<tr>
<td><code>c.empty()</code></td>
<td>O(1)</td>
<td>bool</td>
<td>判断是否为空，为空返回真，反之返回假</td>
</tr>
<tr>
<td><code>c.reserve(sz)</code></td>
<td></td>
<td></td>
<td>为数组提前分配 <code>sz</code> 的内存大小，即改变了 <code>capacity</code> 的大小，主要是为了防止在 <code>push_back</code> 过程中多次的内存拷贝</td>
</tr>
<tr>
<td><code>c.assign(beg, end)</code></td>
<td></td>
<td></td>
<td>将另外一个容器 <code>[x.begin(), x.end())</code> 里的内容拷贝到 <code>c</code> 中</td>
</tr>
<tr>
<td><code>c.assign(n, val)</code></td>
<td></td>
<td></td>
<td>将 <code>n</code> 个 <code>val</code> 值拷贝到 <code>c</code> 数组中，这会清除掉容器中以前的内容，<code>c</code> 数组的 <code>size</code> 将变为 <code>n</code>，<code>capacity</code> 不会改变</td>
</tr>
<tr>
<td><code>c.pop_back()</code></td>
<td>O(1)</td>
<td></td>
<td>删除最后一个数据</td>
</tr>
<tr>
<td><code>c.push_back(element)</code></td>
<td>O(1)</td>
<td></td>
<td>在尾部加一个数据</td>
</tr>
<tr>
<td><code>c.emplace_back(ele)</code></td>
<td>O(1)</td>
<td></td>
<td>在数组中加入一个数据，和 <code>push_back</code> 功能基本一样，在某些情况下比它效率更高，支持传入多个构造参数</td>
</tr>
<tr>
<td><code>c.clear()</code></td>
<td>O(N)</td>
<td></td>
<td>清除容器中的所有元素</td>
</tr>
<tr>
<td><code>c.resize(n, v)</code></td>
<td></td>
<td></td>
<td>改变数组大小为 <code>n</code>, <code>n</code> 个空间数值赋为 <code>v</code>，如果没有默认赋值为 <code>0</code></td>
</tr>
<tr>
<td><code>c.insert(pos, x)</code></td>
<td>O(N)</td>
<td></td>
<td>向任意迭代器 <code>pos</code> 插入一个元素 <code>x</code></td>
</tr>
<tr>
<td>例：<code>c.insert(c.begin() + 2, -1)</code></td>
<td></td>
<td></td>
<td>将 <code>-1</code> 插入 <code>c[2]</code> 的位置</td>
</tr>
<tr>
<td><code>c.erase(first, last)</code></td>
<td>O(N)</td>
<td></td>
<td>删除 <code>[first, last)</code> 的所有元素</td>
</tr>
</tbody></table>
<h3 id="1-2-2-注意情况"><a href="#1-2-2-注意情况" class="headerlink" title="1.2.2 注意情况"></a>1.2.2 注意情况</h3><ul>
<li><p><code>end()</code> 返回的是最后一个元素的后一个位置的地址，不是最后一个元素的地址，<strong>所有 STL 容器均是如此</strong></p>
</li>
<li><p>使用 <code>vi.resize(n, v)</code> 函数时，若 <code>vi</code> 之前指定过大小为 <code>pre</code></p>
<ul>
<li><code>pre &gt; n</code> ：即数组大小变小了，数组会保存前 <code>n</code> 个元素，前 <code>n</code> 个元素值为原来的值，不是都为 <code>v</code></li>
<li><code>pre &lt; n</code> ：即数组大小变大了，数组会在后面插入 <code>n - pre</code> 个值为 <code>v</code> 的元素</li>
</ul>
<p>  也就是说，这个初始值 <code>v</code> 只对新插入的元素生效。</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">out</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x: a) cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>; cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">5</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="built_in">out</span>(a); <span class="comment">// 1 1 1 1 1</span></span><br><span class="line">	a.<span class="built_in">resize</span>(<span class="number">10</span>, <span class="number">2</span>);</span><br><span class="line">	<span class="built_in">out</span>(a); <span class="comment">// 1 1 1 1 1 2 2 2 2 2</span></span><br><span class="line">	a.<span class="built_in">resize</span>(<span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line">	<span class="built_in">out</span>(a); <span class="comment">// 1 1 1</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 <code>sort</code> 排序要: <code>sort(c.begin(), c.end());</code></p>
</li>
</ul>
<blockquote>
<p><code>sort()</code> 为 STL 函数，请参考本文最后面 STL 函数系列。</p>
</blockquote>
<p>对所有元素进行排序，如果要对指定区间进行排序，可以对 <code>sort()</code> 里面的参数进行加减改动。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="built_in">sort</span>(a.<span class="built_in">begin</span>() + <span class="number">1</span>, a.<span class="built_in">end</span>()); 	<span class="comment">// 对 [1, n] 区间进行从小到大排序</span></span><br></pre></td></tr></table></figure>

<h2 id="1-3-元素访问"><a href="#1-3-元素访问" class="headerlink" title="1.3 元素访问"></a>1.3 元素访问</h2><p>共三种方法：</p>
<ol>
<li><p><strong>下标法：</strong> 和普通数组一样。注意：一维数组的下标是从 <code>0</code> 到 <code>v.size() - 1</code> ，访问之外的数会出现越界错误！</p>
</li>
<li><p><strong>迭代器法：</strong> 类似指针一样的访问 ，首先需要声明迭代器变量，和声明指针变量一样，可以根据代码进行理解（附有注释）。</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; vi; 							<span class="comment">//定义一个 vi 数组</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it = vi.<span class="built_in">begin</span>();		  <span class="comment">//声明一个迭代器指向 vi 的初始位置</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>使用 auto：</strong> 非常简便，但是会访问数组的所有元素（特别注意 0 位置元素也会访问到）。</li>
</ol>
<h3 id="1-3-1-下标访问"><a href="#1-3-1-下标访问" class="headerlink" title="1.3.1 下标访问"></a>1.3.1 下标访问</h3><p>直接和普通数组一样进行访问即可。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加元素</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">	vi.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//下标访问 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; vi[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="1-3-2-迭代器访问"><a href="#1-3-2-迭代器访问" class="headerlink" title="1.3.2 迭代器访问"></a>1.3.2 迭代器访问</h3><p>类似指针，迭代器就是充当指针的作用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; vi&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="comment">//迭代器访问</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it;   </span><br><span class="line"><span class="comment">// 相当于声明了一个迭代器类型的变量 it</span></span><br><span class="line"><span class="comment">// 通俗来说就是声明了一个指针变量</span></span><br></pre></td></tr></table></figure>

<ul>
<li>方式一：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it = vi.<span class="built_in">begin</span>(); </span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; *(it + i) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>方式二：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it;</span><br><span class="line"><span class="keyword">for</span>(it = vi.<span class="built_in">begin</span>(); it != vi.<span class="built_in">end</span>();it ++)</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//vi.end()指向尾元素地址的下一个地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">auto</span> it = vi.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span> (it != vi.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    it++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-3-3-智能指针"><a href="#1-3-3-智能指针" class="headerlink" title="1.3.3 智能指针"></a>1.3.3 智能指针</h3><p><strong>只能遍历完数组</strong>，如果要指定的内容进行遍历，需要另选方法。<code>auto</code> 能够自动识别并获取类型。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 输入</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x: a)</span><br><span class="line">&#123;</span><br><span class="line">    cin &gt;&gt; x; <span class="comment">// 可以进行输入，注意加引用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 输出</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">12</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">241</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> val : v)</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 12 241</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>vector</code> 注意：</p>
<ul>
<li><p><code>vi[i]</code> 和 <code>*(vi.begin() + i)</code> 等价，与指针类似。</p>
</li>
<li><p><code>vector</code> 和 <code>string</code> 的 <code>STL</code> 容器支持 <code>*(it + i)</code> 的元素访问，其它容器可能也可以支持这种方式访问，但用的不多，可自行尝试。</p>
</li>
</ul>
</blockquote>
<h2 id="2-stack"><a href="#2-stack" class="headerlink" title="2 stack"></a>2 stack</h2><h2 id="2-1-介绍"><a href="#2-1-介绍" class="headerlink" title="2.1 介绍"></a>2.1 介绍</h2><p>栈为数据结构的一种，是 STL 中实现的一个先进后出，后进先出的容器。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 包含头文件：</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化：</span></span><br><span class="line">stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">stack&lt;string&gt; s;</span><br><span class="line">stack&lt;node&gt; s;<span class="comment">//node 是结构体类型</span></span><br></pre></td></tr></table></figure>

<h2 id="2-2-方法函数"><a href="#2-2-方法函数" class="headerlink" title="2.2 方法函数"></a>2.2 方法函数</h2><table>
<thead>
<tr>
<th>代码</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>s.push(ele)</code></td>
<td>元素 <code>ele</code> 入栈，增加元素 O(1)</td>
</tr>
<tr>
<td><code>s.pop()</code></td>
<td>移除栈顶元素 O(1)</td>
</tr>
<tr>
<td><code>s.top()</code></td>
<td>取得栈顶元素（但不删除）O(1)</td>
</tr>
<tr>
<td><code>s.empty()</code></td>
<td>检测栈内是否为空，空为真 O(1)</td>
</tr>
<tr>
<td><code>s.size()</code></td>
<td>返回栈内元素的个数 O(1)</td>
</tr>
</tbody></table>
<h2 id="2-3-栈元素访问"><a href="#2-3-栈元素访问" class="headerlink" title="2.3 栈元素访问"></a>2.3 栈元素访问</h2><h3 id="2-3-1-栈遍历"><a href="#2-3-1-栈遍历" class="headerlink" title="2.3.1 栈遍历"></a>2.3.1 栈遍历</h3><p>栈只能对栈顶元素进行操作，如果想要进行遍历，只能将栈中元素一个个取出来存在数组中。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line">	st.<span class="built_in">push</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!st.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> tp = st.<span class="built_in">top</span>(); <span class="comment">// 栈顶元素</span></span><br><span class="line">    st.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-2-数组模拟栈进行遍历"><a href="#2-3-2-数组模拟栈进行遍历" class="headerlink" title="2.3.2 数组模拟栈进行遍历"></a>2.3.2 数组模拟栈进行遍历</h3><p>通过一个 <strong>数组</strong> 对栈进行模拟，一个存放下标的变量 <code>top</code> 模拟指向栈顶的指针。</p>
<blockquote>
<p>一般来说单调栈和单调队列写法均可使用额外变量 <code>tt</code> 或 <code>hh</code> 来进行模拟</p>
</blockquote>
<p><strong>特点：</strong> 比 <code>STL</code> 的 <code>stack</code> 速度更快，遍历元素方便。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> s[<span class="number">100</span>]; <span class="comment">// 栈 从左至右为栈底到栈顶</span></span><br><span class="line"><span class="type">int</span> tt = <span class="number">-1</span>; <span class="comment">// tt 代表栈顶指针, 初始栈内无元素，tt 为-1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">5</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//入栈 </span></span><br><span class="line">	s[++tt] = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出栈</span></span><br><span class="line"><span class="type">int</span> top_element = s[tt--]; </span><br><span class="line"></span><br><span class="line"><span class="comment">//入栈操作示意</span></span><br><span class="line"><span class="comment">//  0  1  2  3  4  5  </span></span><br><span class="line"><span class="comment">//                tt</span></span><br><span class="line"><span class="comment">//出栈后示意</span></span><br><span class="line"><span class="comment">//  0  1  2  3  4 </span></span><br><span class="line"><span class="comment">//              tt</span></span><br></pre></td></tr></table></figure>

<h2 id="3-queue"><a href="#3-queue" class="headerlink" title="3 queue"></a>3 queue</h2><h2 id="3-1-介绍"><a href="#3-1-介绍" class="headerlink" title="3.1 介绍"></a>3.1 介绍</h2><p>队列是一种先进先出的数据结构。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 包含头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br></pre></td></tr></table></figure>

<h2 id="3-2-方法函数"><a href="#3-2-方法函数" class="headerlink" title="3.2 方法函数"></a>3.2 方法函数</h2><table>
<thead>
<tr>
<th>代码</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>q.front()</code></td>
<td>返回队首元素 O(1)</td>
</tr>
<tr>
<td><code>q.back()</code></td>
<td>返回队尾元素 O(1)</td>
</tr>
<tr>
<td><code>q.push(element)</code></td>
<td>尾部添加一个元素 <code>element</code> 进队 O(1)</td>
</tr>
<tr>
<td><code>q.pop()</code></td>
<td>删除第一个元素 出队 O(1)</td>
</tr>
<tr>
<td><code>q.size()</code></td>
<td>返回队列中元素个数，返回值类型 <code>unsigned int</code> O(1)</td>
</tr>
<tr>
<td><code>q.empty()</code></td>
<td>判断是否为空，队列为空，返回 <code>true</code> O(1)</td>
</tr>
</tbody></table>
<h2 id="3-3-队列模拟"><a href="#3-3-队列模拟" class="headerlink" title="3.3 队列模拟"></a>3.3 队列模拟</h2><p>使用 <code>q[]</code> 数组模拟队列：</p>
<ul>
<li><code>hh</code> 表示队首元素的下标，初始值为 <code>0</code>。</li>
<li><code>tt</code> 表示队尾元素的下标，初始值为 <code>-1</code>，表示刚 <strong>开始队列为空</strong>。</li>
</ul>
<blockquote>
<p>一般来说单调栈和单调队列写法均可使用额外变量 <code>tt</code> 或 <code>hh</code> 来进行模拟。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> hh = <span class="number">0</span>,tt = <span class="number">-1</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//	入队 </span></span><br><span class="line">	q[++tt] = <span class="number">1</span>;</span><br><span class="line">	q[++tt] = <span class="number">2</span>; </span><br><span class="line">    </span><br><span class="line">	<span class="comment">//	将所有元素出队 </span></span><br><span class="line">	<span class="keyword">while</span>(hh &lt;= tt)</span><br><span class="line">    &#123;</span><br><span class="line">		<span class="type">int</span> t = q[hh++];</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,t);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure>

<h2 id="4-deque"><a href="#4-deque" class="headerlink" title="4 deque"></a>4 deque</h2><h2 id="4-1-介绍"><a href="#4-1-介绍" class="headerlink" title="4.1 介绍"></a>4.1 介绍</h2><p>首尾都可插入和删除的队列为双端队列。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="comment">//初始化定义</span></span><br><span class="line">deque&lt;<span class="type">int</span>&gt; dq;</span><br></pre></td></tr></table></figure>

<h2 id="4-2-方法函数"><a href="#4-2-方法函数" class="headerlink" title="4.2 方法函数"></a>4.2 方法函数</h2><blockquote>
<p>注意双端队列的常数比较大。</p>
</blockquote>
<table>
<thead>
<tr>
<th>代码</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>push_back(x)/push_front(x)</code></td>
<td>把 <code>x</code> 插入队尾后 &#x2F; 队首 O(1)</td>
</tr>
<tr>
<td><code>back()/front()</code></td>
<td>返回队尾 &#x2F; 队首元素 O(1)</td>
</tr>
<tr>
<td><code>pop_back() / pop_front()</code></td>
<td>删除队尾 &#x2F; 队首元素 O(1)</td>
</tr>
<tr>
<td><code>erase(iterator it)</code></td>
<td>删除双端队列中的某一个元素</td>
</tr>
<tr>
<td><code>erase(iterator first,iterator last)</code></td>
<td>删除双端队列中 <code>[first,last)</code> 中的元素</td>
</tr>
<tr>
<td><code>empty()</code></td>
<td>判断 deque 是否空 O(1)</td>
</tr>
<tr>
<td><code>size()</code></td>
<td>返回 deque 的元素数量 O(1)</td>
</tr>
<tr>
<td><code>clear()</code></td>
<td>清空 deque</td>
</tr>
</tbody></table>
<h2 id="4-3-注意点"><a href="#4-3-注意点" class="headerlink" title="4.3 注意点"></a>4.3 注意点</h2><p>deque 可以进行排序！</p>
<blockquote>
<p>双端队列排序一般不用，感觉毫无用处，使用其他 STL 依然可以实现相同功能。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从小到大</span></span><br><span class="line"><span class="built_in">sort</span>(q.<span class="built_in">begin</span>(), q.<span class="built_in">end</span>())</span><br><span class="line"><span class="comment">//从大到小排序</span></span><br><span class="line"><span class="built_in">sort</span>(q.<span class="built_in">begin</span>(), q.<span class="built_in">end</span>(), <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());<span class="comment">//deque 里面的类型需要是 int 型</span></span><br><span class="line"><span class="built_in">sort</span>(q.<span class="built_in">begin</span>(), q.<span class="built_in">end</span>(), <span class="built_in">greater</span>());<span class="comment">//高版本 C++才可以用</span></span><br></pre></td></tr></table></figure>

<h2 id="5-priority-queue"><a href="#5-priority-queue" class="headerlink" title="5 priority_queue"></a>5 priority_queue</h2><h2 id="5-1-介绍"><a href="#5-1-介绍" class="headerlink" title="5.1 介绍"></a>5.1 介绍</h2><p>优先队列是在正常队列的基础上加了优先级，保证每次的队首元素都是优先级最大的。可以实现每次从优先队列中取出的元素都是队列中 <strong>优先级最大</strong> 的一个。它的底层是通过 <strong>堆</strong> 来实现的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span>		        <span class="comment">//头文件</span></span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>&gt; q;	        <span class="comment">//初始化定义</span></span><br></pre></td></tr></table></figure>

<h2 id="5-2-函数方法"><a href="#5-2-函数方法" class="headerlink" title="5.2 函数方法"></a>5.2 函数方法</h2><table>
<thead>
<tr>
<th>代码</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>q.top()</code></td>
<td>访问队首元素 O(1)</td>
</tr>
<tr>
<td><code>q.push()</code></td>
<td>入队 O(logN)</td>
</tr>
<tr>
<td><code>q.pop()</code></td>
<td>堆顶（队首）元素出队 O(logN)</td>
</tr>
<tr>
<td><code>q.size()</code></td>
<td>队列元素个数 O(1)</td>
</tr>
<tr>
<td><code>q.empty()</code></td>
<td>是否为空 O(1)</td>
</tr>
<tr>
<td><strong>注意 没有 <code>clear()</code>！</strong></td>
<td>不提供该方法</td>
</tr>
<tr>
<td>优先队列只能通过 <code>top()</code> 访问队首元素（优先级最高的元素）</td>
<td></td>
</tr>
</tbody></table>
<h2 id="5-3-设置优先级"><a href="#5-3-设置优先级" class="headerlink" title="5.3 设置优先级"></a>5.3 设置优先级</h2><h3 id="5-3-1-基本数据类型的优先级"><a href="#5-3-1-基本数据类型的优先级" class="headerlink" title="5.3.1 基本数据类型的优先级"></a>5.3.1 基本数据类型的优先级</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;<span class="type">int</span>&gt; pq;                                 <span class="comment">// 默认大根堆, 即每次取出的元素是队列中的最大值</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; q;       <span class="comment">// 小根堆, 每次取出的元素是队列中的最小值</span></span><br></pre></td></tr></table></figure>

<p>参数解释：</p>
<ul>
<li><p>第一个参数：就是优先队列中存储的数据类型</p>
</li>
<li><p>第二个参数：<code>vector&lt;int&gt;</code> 是用来承载底层数据结构堆的容器，若优先队列中存放的是 <code>double</code> 型数据，就要填 <code>vector&lt;double&gt;</code> <strong>总之存的是什么类型的数据，就相应的填写对应类型。同时也要改动第三个参数里面的对应类型。</strong></p>
</li>
<li><p>第三个参数：<code>less&lt;int&gt;</code> 表示数字大的优先级大，堆顶为最大的数字 <code>greater&lt;int&gt;</code> 表示数字小的优先级大，堆顶为最小的数字 <strong>int 代表的是数据类型，也要填优先队列中存储的数据类型。</strong></p>
</li>
</ul>
<hr>
<p>下面介绍基础数据类型优先级设置的写法：</p>
<ol>
<li>基础写法（非常常用）：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;<span class="type">int</span>&gt; q1;                                 <span class="comment">// 默认大根堆, 即每次取出的元素是队列中的最大值</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, less&lt;<span class="type">int</span>&gt;&gt; q2;         <span class="comment">// 大根堆, 每次取出的元素是队列中的最大值，同第一行</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; q3;      <span class="comment">// 小根堆, 每次取出的元素是队列中的最小值</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>自定义排序（不常见，主要是写着麻烦）：</li>
</ol>
<p>下面的代码比较长，基础类型优先级写着太麻烦，用第一种即可。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">cmp1</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> x &gt; y;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cmp2</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> <span class="type">int</span> x, <span class="type">const</span> <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> x &lt; y;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, cmp1&gt; q1; 		<span class="comment">// 小根堆</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, cmp2&gt; q2; 		<span class="comment">// 大根堆</span></span><br></pre></td></tr></table></figure>

<h3 id="5-3-2-高级数据类型-结构体-优先级"><a href="#5-3-2-高级数据类型-结构体-优先级" class="headerlink" title="5.3.2 高级数据类型(结构体)优先级"></a>5.3.2 高级数据类型(结构体)优先级</h3><blockquote>
<p>即优先队列中存储结构体类型，必须要设置优先级，即结构体的比较运算（因为优先队列的堆中要比较大小，才能将对应最大或者最小元素移到堆顶）。</p>
</blockquote>
<p>优先级设置可以定义在 <strong>结构体内</strong> 进行小于号重载，也可以定义在 <strong>结构体外</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//要排序的结构体（存储在优先队列里面的）</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> x, y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>版本一：自定义全局比较规则</strong></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义的比较结构体</span></span><br><span class="line"><span class="comment">//注意：cmp 是个结构体 </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cmp</span>				<span class="comment">//自定义堆的排序规则 		</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Point&amp; a,<span class="type">const</span> Point&amp; b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> a.x &lt; b.x;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化定义， </span></span><br><span class="line">priority_queue&lt;Point, vector&lt;Point&gt;, cmp&gt; q; 	<span class="comment">// x 大的在堆顶</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>版本二：直接在结构体里面写</strong></li>
</ul>
<blockquote>
<p>因为是在结构体内部自定义的规则，一旦需要比较结构体，自动调用结构体内部重载运算符规则。</p>
</blockquote>
<p>结构体内部有两种方式：</p>
<p><strong>方式一</strong> ：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> x, y;</span><br><span class="line">	<span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span> &lt; (Point a, Point b)				<span class="comment">//为两个结构体参数，结构体调用一定要写上 friend</span></span><br><span class="line">    &#123;</span><br><span class="line">		<span class="keyword">return</span> a.x &lt; b.x;								  <span class="comment">//按 x 从小到大排，x 大的在堆顶</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>方式二</strong> ：（推荐此种）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> Point &amp;a) <span class="type">const</span>					<span class="comment">//直接传入一个参数，不必要写 friend</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> x &lt; a.x;									  <span class="comment">//按 x 升序排列，x 大的在堆顶</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>优先队列的定义</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;Point&gt; q;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong> 优先队列自定义排序规则和 <code>sort()</code> 函数定义 <code>cmp</code> 函数很相似，但是最后返回的情况是 <strong>相反</strong> 的。即相同的符号，最后定义的排列顺序是完全相反的。<strong>所以只需要记住 <code>sort</code> 的排序规则和优先队列的排序规则是相反的就可以了。</strong></p>
<blockquote>
<p>当理解了堆的原理就会发现，堆调整时比较顺序是孩子和父亲节点进行比较，如果是 <code>&gt;</code> ，那么孩子节点要大于父亲节点，堆顶自然是最小值。</p>
</blockquote>
<h2 id="5-4-存储特殊类型的优先级"><a href="#5-4-存储特殊类型的优先级" class="headerlink" title="5.4 存储特殊类型的优先级"></a>5.4 存储特殊类型的优先级</h2><h3 id="5-4-1-存储-pair-类型"><a href="#5-4-1-存储-pair-类型" class="headerlink" title="5.4.1 存储 pair 类型"></a>5.4.1 存储 pair 类型</h3><p>默认排序规则（<strong>降序排序：first ↓，second ↓</strong>）：</p>
<ol>
<li><strong>先按 <code>first</code> 降序排列</strong>（大的排在前面）；</li>
<li><strong>如果 <code>first</code> 相等，再按 <code>second</code> 降序排列</strong>（也是大的排在前面）。</li>
</ol>
<blockquote>
<p>头文件 <code> #include &lt;utility&gt;</code>  &#x2F;&#x2F; 使用 std:: pair</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span>  <span class="comment">// 使用 std:: pair</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span>    <span class="comment">// 使用 std:: priority_queue</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &gt;q;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123; <span class="number">7</span>, <span class="number">8</span> &#125;);</span><br><span class="line">    q.<span class="built_in">push</span>(&#123; <span class="number">7</span>, <span class="number">9</span> &#125;);</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(<span class="number">8</span>, <span class="number">7</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; q.<span class="built_in">top</span>().first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; q.<span class="built_in">top</span>().second &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>结果：<br>8 7<br>7 9<br>7 8</p>
</blockquote>
<h2 id="6-map"><a href="#6-map" class="headerlink" title="6 map"></a>6 map</h2><h2 id="6-1-介绍"><a href="#6-1-介绍" class="headerlink" title="6.1 介绍"></a>6.1 介绍</h2><h3 id="6-1-1-简介"><a href="#6-1-1-简介" class="headerlink" title="6.1.1 简介"></a>6.1.1 简介</h3><p>映射类似于函数的对应关系，每个 <code>x</code> 对应一个 <code>y</code>，而 <code>map</code> 是每个键对应一个值。这和 python 的字典类型非常相似。容器中的每个存储对为一个键值对，包含两个元素（键和值）。</p>
<h3 id="6-1-2-初始化"><a href="#6-1-2-初始化" class="headerlink" title="6.1.2 初始化"></a>6.1.2 初始化</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化定义</span></span><br><span class="line">map&lt;string, string&gt; mp;</span><br><span class="line">map&lt;string, <span class="type">int</span>&gt; mp;</span><br><span class="line">map&lt;<span class="type">int</span>, node&gt; mp;			<span class="comment">//node 是结构体类型</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>map 特性：map 会按照键的顺序从小到大自动排序，键的类型必须可以比较大小。</p>
</blockquote>
<h2 id="6-2-函数方法"><a href="#6-2-函数方法" class="headerlink" title="6.2 函数方法"></a>6.2 函数方法</h2><h3 id="6-2-1-函数方法"><a href="#6-2-1-函数方法" class="headerlink" title="6.2.1 函数方法"></a>6.2.1 函数方法</h3><table>
<thead>
<tr>
<th>代码</th>
<th>含义</th>
<th>复杂度</th>
</tr>
</thead>
<tbody><tr>
<td><code>mp.find(key)</code></td>
<td>返回键为 key 的映射的迭代器 注意：用 find 函数来定位数据出现位置，它返回一个迭代器。当数据存在时，返回数据所在位置的迭代器，数据不存在时，返回 mp.end()mp.end()</td>
<td>O(logN)</td>
</tr>
<tr>
<td><code>mp.erase(it)</code></td>
<td>删除迭代器对应的键和值</td>
<td>O(logN)</td>
</tr>
<tr>
<td><code>mp.erase(key)</code></td>
<td>根据映射的键删除键和值</td>
<td>O(logN)</td>
</tr>
<tr>
<td><code>mp.erase(first,last)</code></td>
<td>删除左闭右开区间迭代器对应的键和值</td>
<td>O(last-first)</td>
</tr>
<tr>
<td><code>mp.size()</code></td>
<td>返回映射的对数</td>
<td>O(1)</td>
</tr>
<tr>
<td><code>mp.clear()</code></td>
<td>清空 map 中的所有元素</td>
<td>O(N)</td>
</tr>
<tr>
<td><code>mp.insert()</code></td>
<td>插入元素，插入时要构造键值对</td>
<td>O(N)</td>
</tr>
<tr>
<td><code>mp.empty()</code></td>
<td>如果 map 为空，返回 true，否则返回 false</td>
<td>O(1)</td>
</tr>
<tr>
<td><code>mp.begin()</code></td>
<td>返回指向 map 第一个元素的迭代器（地址）</td>
<td>O(1)</td>
</tr>
<tr>
<td><code>mp.end()</code></td>
<td>返回指向 map 尾部的迭代器（最后一个元素的 <strong>下一个</strong> 地址）</td>
<td>O(1)</td>
</tr>
<tr>
<td><code>mp.rbegin()</code></td>
<td>返回指向 map 最后一个元素的迭代器（地址）</td>
<td>O(1)</td>
</tr>
<tr>
<td><code>mp.rend()</code></td>
<td>返回指向 map 第一个元素前面(上一个）的逆向迭代器（地址）</td>
<td>O(1)</td>
</tr>
<tr>
<td><code>mp.count(key)</code></td>
<td>查看元素是否存在，因为 map 中键是唯一的，所以存在返回 1，不存在返回 0</td>
<td>O(logN)</td>
</tr>
<tr>
<td><code>mp.lower_bound()</code></td>
<td>返回一个迭代器，指向键值 &gt;&#x3D; <strong>key</strong> 的第一个元素</td>
<td></td>
</tr>
<tr>
<td><code>mp.upper_bound()</code></td>
<td>返回一个迭代器，指向键值 &gt; key 的第一个元素</td>
<td></td>
</tr>
</tbody></table>
<h3 id="6-2-2-注意情况"><a href="#6-2-2-注意情况" class="headerlink" title="6.2.2 注意情况"></a>6.2.2 注意情况</h3><p><strong>下面说明部分函数方法的注意点</strong></p>
<p>查找元素是否存在时，可以使用 ① <code>mp.find()</code> ② <code>mp.count()</code> ③ <code>mp[key]</code>，但是第三种情况，如果不存在对应的 <code>key</code> 时，会自动创建一个键值对（产生一个额外的键值对空间），所以为了不增加额外的空间负担，最好使用前两种方法。</p>
<h3 id="6-2-3-迭代器进行正反向遍历"><a href="#6-2-3-迭代器进行正反向遍历" class="headerlink" title="6.2.3 迭代器进行正反向遍历"></a>6.2.3 迭代器进行正反向遍历</h3><ul>
<li><code>mp.begin()</code> 和 <code>mp.end()</code> 用法：</li>
</ul>
<p><strong>用于正向遍历 map</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; mp;</span><br><span class="line">mp[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">mp[<span class="number">2</span>] = <span class="number">3</span>;</span><br><span class="line">mp[<span class="number">3</span>] = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">auto</span> it = mp.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span>(it != mp.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">	it ++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>示例结果：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>mp.rbegin()</code> 和 <code>mp.rend()</code></li>
</ul>
<p><strong>用于逆向遍历 map</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; mp;</span><br><span class="line">mp[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">mp[<span class="number">2</span>] = <span class="number">3</span>;</span><br><span class="line">mp[<span class="number">3</span>] = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">auto</span> it = mp.<span class="built_in">rbegin</span>();</span><br><span class="line"><span class="keyword">while</span>(it != mp.<span class="built_in">rend</span>())</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">	it ++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>示例结果：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>

<h3 id="6-2-4-二分查找"><a href="#6-2-4-二分查找" class="headerlink" title="6.2.4 二分查找"></a>6.2.4 二分查找</h3><p>二分查找 <code>lower_bound()</code> 和 <code>upper_bound()</code>。</p>
<blockquote>
<p>map 的二分查找以第一个元素（即键为准），对 <strong>键</strong> 进行二分查找，返回值为 map 迭代器类型。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; m&#123;&#123;<span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">2</span>, <span class="number">2</span>&#125;, &#123;<span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">8</span>, <span class="number">2</span>&#125;, &#123;<span class="number">6</span>, <span class="number">2</span>&#125;&#125;;<span class="comment">//有序</span></span><br><span class="line">	map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::iterator it1 = m.<span class="built_in">lower_bound</span>(<span class="number">2</span>);</span><br><span class="line">	cout &lt;&lt; it1-&gt;first &lt;&lt; <span class="string">&quot;\n&quot;</span>;<span class="comment">//it1-&gt; first = 2</span></span><br><span class="line">	</span><br><span class="line">	map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::iterator it2 = m.<span class="built_in">upper_bound</span>(<span class="number">2</span>);</span><br><span class="line">	cout &lt;&lt; it2-&gt;first &lt;&lt; <span class="string">&quot;\n&quot;</span>;<span class="comment">//it2-&gt; first = 6</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-3-添加元素"><a href="#6-3-添加元素" class="headerlink" title="6.3 添加元素"></a>6.3 添加元素</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先声明</span></span><br><span class="line">map&lt;string, string&gt; mp;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>方式一：</strong></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mp[<span class="string">&quot;学习&quot;</span>] = <span class="string">&quot;看书&quot;</span>;</span><br><span class="line">mp[<span class="string">&quot;玩耍&quot;</span>] = <span class="string">&quot;打游戏&quot;</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>方式二：插入元素构造键值对</strong></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mp.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="string">&quot;vegetable&quot;</span>, <span class="string">&quot;蔬菜&quot;</span>));</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>方式三：</strong></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mp.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;string,string&gt;(<span class="string">&quot;fruit&quot;</span>,<span class="string">&quot;水果&quot;</span>));</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>方式四:</strong></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mp.<span class="built_in">insert</span>(&#123;<span class="string">&quot;hahaha&quot;</span>,<span class="string">&quot;wawawa&quot;</span>&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="6-4-访问元素"><a href="#6-4-访问元素" class="headerlink" title="6.4 访问元素"></a>6.4 访问元素</h2><h3 id="6-4-1-下标访问"><a href="#6-4-1-下标访问" class="headerlink" title="6.4.1 下标访问"></a>6.4.1 下标访问</h3><p>(大部分情况用于访问单个元素)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mp[<span class="string">&quot;菜哇菜&quot;</span>] = <span class="string">&quot;强哇强&quot;</span>;</span><br><span class="line">cout &lt;&lt; mp[<span class="string">&quot;菜哇菜&quot;</span>] &lt;&lt; <span class="string">&quot;\n&quot;</span>;		<span class="comment">//只是简写的一个例子，程序并不完整</span></span><br></pre></td></tr></table></figure>

<h3 id="6-4-2-遍历访问"><a href="#6-4-2-遍历访问" class="headerlink" title="6.4.2 遍历访问"></a>6.4.2 遍历访问</h3><ul>
<li>方式一：迭代器访问</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string,string&gt;::iterator it;</span><br><span class="line"><span class="keyword">for</span>(it = mp.<span class="built_in">begin</span>(); it != mp.<span class="built_in">end</span>(); it++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//      键                 值 </span></span><br><span class="line">	<span class="comment">// it 是结构体指针访问所以要用 -&gt; 访问</span></span><br><span class="line">	cout &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//*it 是结构体变量 访问要用 . 访问</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt;(*it).first &lt;&lt; &quot; &quot; &lt;&lt;(* it).second;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>方式二：智能指针访问</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i : mp)</span><br><span class="line">cout &lt;&lt; i.first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; i.second &lt;&lt; endl;		<span class="comment">//键，值</span></span><br></pre></td></tr></table></figure>

<ul>
<li>方式三：对指定单个元素访问</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="type">char</span>,<span class="type">int</span>&gt;::iterator it = mp.<span class="built_in">find</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">cout &lt;&lt; it -&gt; first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt;  it-&gt;second &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>方式四：c++17 特性才具有</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> [x, y] : mp)</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//x, y 对应键和值</span></span><br></pre></td></tr></table></figure>

<h2 id="6-5-与-unordered-map-的比较"><a href="#6-5-与-unordered-map-的比较" class="headerlink" title="6.5 与 unordered_map 的比较"></a>6.5 与 unordered_map 的比较</h2><p>这里就不单开一个大目录讲 unordered_map 了，直接在 map 里面讲了。</p>
<h3 id="6-5-1-内部实现原理"><a href="#6-5-1-内部实现原理" class="headerlink" title="6.5.1 内部实现原理"></a>6.5.1 内部实现原理</h3><ul>
<li><strong>map</strong>：内部用 <strong>红黑树</strong> 实现，具有 <strong>自动排序</strong>（按键从小到大）功能。</li>
<li><strong>unordered_map</strong>：内部用 <strong>哈希表</strong> 实现，内部元素无序杂乱。</li>
</ul>
<h3 id="6-5-2-效率比较"><a href="#6-5-2-效率比较" class="headerlink" title="6.5.2 效率比较"></a>6.5.2 效率比较</h3><ol>
<li><p><strong>map</strong>：</p>
<ul>
<li><p>优点：内部用红黑树实现，内部元素具有有序性，查询删除等操作复杂度为 O(logN)</p>
</li>
<li><p>缺点：占用空间，红黑树里每个节点需要保存父子节点和红黑性质等信息，空间占用较大。</p>
</li>
</ul>
</li>
<li><p><strong>unordered_map</strong>：</p>
<ul>
<li><p>优点：内部用哈希表实现，查找速度非常快（适用于大量的查询操作）。</p>
</li>
<li><p>缺点：建立哈希表比较耗时。</p>
</li>
</ul>
</li>
</ol>
<blockquote>
<p>两者方法函数基本一样，差别不大。但是需要注意：</p>
<ul>
<li><p>随着内部元素越来越多，两种容器的插入删除查询操作的时间都会逐渐变大，效率逐渐变低。</p>
</li>
<li><p>使用 <code>[]</code> 查找元素时，如果元素不存在，两种容器 <strong>都是</strong> 创建一个空的元素；如果存在，会正常索引对应的值。所以如果查询过多的不存在的元素值，容器内部会创建大量的空的键值对，后续查询创建删除效率会 <strong>大大降低</strong>。</p>
</li>
<li><p>查询容器内部元素的最优方法是：先判断存在与否，再索引对应值（适用于这两种容器）</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以 map 为例</span></span><br><span class="line"> map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line"> <span class="type">int</span> x = <span class="number">999999999</span>;</span><br><span class="line"> <span class="keyword">if</span>(mp.<span class="built_in">count</span>(x)) 			<span class="comment">// 此处判断是否存在 x 这个键</span></span><br><span class="line"> &#123;</span><br><span class="line"> 	cout &lt;&lt; mp[x] &lt;&lt; <span class="string">&quot;\n&quot;</span>;   <span class="comment">// 只有存在才会索引对应的值，避免不存在 x 时多余空元素的创建</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</blockquote>
<p>另外：</p>
<blockquote>
<p>还有一种映射：<code>multimap</code></p>
<p>键可以重复，即一个键对应多个值，如要了解，可以自行搜索。</p>
</blockquote>
<h2 id="6-5-3-自定义-hash-函数"><a href="#6-5-3-自定义-hash-函数" class="headerlink" title="6.5.3 自定义 hash 函数"></a>6.5.3 自定义 hash 函数</h2><p>由于 unordered_map 中的元素需要具备 hash 特性，如果语言没有自带 hash 特性的话，需要我们自定义 hash 函数，以下举一个 <code>pair&lt;int, int&gt;</code> 的 hash 函数定义的例子，hash 函数看自己怎么定义了（只要能实现 hash 功能就行）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 lambda 表达式来定义哈希函数</span></span><br><span class="line"><span class="keyword">auto</span> hash_pair = [](<span class="type">const</span> std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; p) -&gt; std::<span class="type">size_t</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> hash&lt;<span class="type">long</span> <span class="type">long</span>&gt; hash_ll;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">hash_ll</span>(p.first + (<span class="built_in">static_cast</span>&lt;<span class="type">long</span> <span class="type">long</span>&gt;(p.second) &lt;&lt; <span class="number">32</span>));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 lambda 表达式作为哈希函数定义 unordered_map, 10 为桶的数量</span></span><br><span class="line">std::unordered_map&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, <span class="type">int</span>, <span class="keyword">decltype</span>(hash_pair)&gt; <span class="built_in">my_map</span>(<span class="number">10</span>, hash_pair);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用：</span></span><br><span class="line">my_map[&#123;<span class="number">3</span>, <span class="number">5</span>&#125;] = <span class="number">100</span>;</span><br><span class="line">cout &lt;&lt; my_map[&#123;<span class="number">3</span>, <span class="number">5</span>&#125;] &lt;&lt; endl;  <span class="comment">// 输出 100</span></span><br></pre></td></tr></table></figure>

<h2 id="7-set"><a href="#7-set" class="headerlink" title="7 set"></a>7 set</h2><h2 id="7-1-介绍"><a href="#7-1-介绍" class="headerlink" title="7.1 介绍"></a>7.1 介绍</h2><p>set 容器中的元素不会重复，当插入集合中已有的元素时，并不会插入进去，而且 set 容器里的元素 <strong>自动从小到大排序</strong>。<strong>即：set 里面的元素 不重复且有序。</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="comment">//初始化定义</span></span><br><span class="line">set&lt;<span class="type">int</span>&gt; s;</span><br></pre></td></tr></table></figure>

<h2 id="7-2-函数方法"><a href="#7-2-函数方法" class="headerlink" title="7.2 函数方法"></a>7.2 函数方法</h2><table>
<thead>
<tr>
<th>代码</th>
<th>复杂度</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>s.begin()</code></td>
<td>O(1)</td>
<td>返回 set 容器的第一个元素的地址（迭代器）</td>
</tr>
<tr>
<td><code>s.end()</code></td>
<td>O(1)</td>
<td>返回 set 容器的最后一个元素的下一个地址（迭代器）</td>
</tr>
<tr>
<td><code>s.rbegin()</code></td>
<td>O(1)</td>
<td>返回逆序迭代器，指向容器元素最后一个位置</td>
</tr>
<tr>
<td><code>s.rend()</code></td>
<td>O(1)</td>
<td>返回逆序迭代器，指向容器第一个元素前面的位置</td>
</tr>
<tr>
<td><code>s.clear()</code></td>
<td>O(N)</td>
<td>删除 set 容器中的所有的元素, 无返回值</td>
</tr>
<tr>
<td><code>s.empty()</code></td>
<td>O(1)</td>
<td>判断 set 容器是否为空</td>
</tr>
<tr>
<td><code>s.insert(element)</code></td>
<td>O(logN)</td>
<td>插入一个元素</td>
</tr>
<tr>
<td><code>s.size()</code></td>
<td>O(1)</td>
<td>返回当前 set 容器中的元素个数</td>
</tr>
<tr>
<td><code>erase(iterator)</code></td>
<td>O(logN)</td>
<td>删除定位器 iterator 指向的值</td>
</tr>
<tr>
<td><code>erase(first, second）</code></td>
<td></td>
<td>删除定位器 first 和 second 之间的值</td>
</tr>
<tr>
<td><code>erase(key_value)</code></td>
<td>O(logN)</td>
<td>删除键值 key_value 的值</td>
</tr>
<tr>
<td>查找</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>s.find(element)</code></td>
<td></td>
<td>查找 set 中的某一元素，有则返回该元素对应的迭代器，无则返回结束迭代器</td>
</tr>
<tr>
<td><code>s.count(element)</code></td>
<td></td>
<td>查找 set 中的元素出现的个数，由于 set 中元素唯一，此函数相当于查询 element 是否出现</td>
</tr>
<tr>
<td><code>s.lower_bound(k)</code></td>
<td>O(logN)</td>
<td>返回大于等于 k 的第一个元素的迭代器</td>
</tr>
<tr>
<td><code>s.upper_bound(k)</code></td>
<td>O(logN)</td>
<td>返回大于 k 的第一个元素的迭代器</td>
</tr>
</tbody></table>
<h2 id="7-3-元素访问"><a href="#7-3-元素访问" class="headerlink" title="7.3 元素访问"></a>7.3 元素访问</h2><ul>
<li><strong>迭代器访问</strong></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(set&lt;<span class="type">int</span>&gt;::iterator it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); it++)</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>智能指针</strong></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i : s)</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>访问最后一个元素</strong></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一种</span></span><br><span class="line">cout &lt;&lt; *s.<span class="built_in">rbegin</span>() &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//第二种</span></span><br><span class="line">set&lt;<span class="type">int</span>&gt;::iterator iter = s.<span class="built_in">end</span>();</span><br><span class="line">iter--;</span><br><span class="line">cout &lt;&lt; (*iter) &lt;&lt; endl; 		<span class="comment">//打印 2;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第三种</span></span><br><span class="line">cout &lt;&lt; *(--s.<span class="built_in">end</span>()) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<h2 id="7-4-重载-运算符"><a href="#7-4-重载-运算符" class="headerlink" title="7.4 重载 &lt; 运算符"></a>7.4 重载 &lt; 运算符</h2><ul>
<li><strong>基础数据类型</strong></li>
</ul>
<p>方式一：改变 set 排序规则，set 中默认使用 less 比较器，即从小到大排序。（常用）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set&lt;<span class="type">int</span>&gt; s1; 						<span class="comment">// 默认从小到大排序</span></span><br><span class="line">set&lt;<span class="type">int</span>, greater&lt;<span class="type">int</span>&gt; &gt; s2; 		 <span class="comment">// 从大到小排序</span></span><br></pre></td></tr></table></figure>

<p>方式二：重载运算符。（很麻烦，不太常用，没必要）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//重载 &lt; 运算符</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cmp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span> <span class="params">()</span> <span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; u, <span class="type">const</span> <span class="type">int</span>&amp; v)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">       <span class="comment">// return + 返回条件</span></span><br><span class="line">       <span class="keyword">return</span> u &gt; v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">set&lt;<span class="type">int</span>, cmp&gt; s; </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">	s.<span class="built_in">insert</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i : s)</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 10 9 8 7 6 5 4 3 2 1</span></span><br></pre></td></tr></table></figure>

<p>方式三：初始化时使用匿名函数定义比较规则</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">set&lt;<span class="type">int</span>, function&lt;<span class="type">bool</span>(<span class="type">int</span>, <span class="type">int</span>)&gt;&gt; <span class="built_in">s</span>([&amp;](<span class="type">int</span> i, <span class="type">int</span> j)&#123;</span><br><span class="line">    <span class="keyword">return</span> i &gt; j; <span class="comment">// 从大到小</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">	s.<span class="built_in">insert</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> x : s)</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>高级数据类型（结构体）</strong></li>
</ul>
<p>直接重载结构体运算符即可，让结构体可以比较。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> x, y;</span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> Point &amp;p) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">		<span class="comment">// 按照点的横坐标从小到大排序, 如果横坐标相同, 纵坐标从小到大</span></span><br><span class="line">		<span class="keyword">if</span>(x == p.x)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> y &lt; p.y;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> x &lt; p.x;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">set&lt;Point&gt; s;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    s.<span class="built_in">insert</span>(&#123;x, y&#125;);</span><br><span class="line">&#125;	</span><br><span class="line"><span class="comment">/* 输入</span></span><br><span class="line"><span class="comment">5 4</span></span><br><span class="line"><span class="comment">5 2</span></span><br><span class="line"><span class="comment">3 7</span></span><br><span class="line"><span class="comment">3 5</span></span><br><span class="line"><span class="comment">4 8</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i : s)</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; i.x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; i.y &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 输出</span></span><br><span class="line"><span class="comment">3 5</span></span><br><span class="line"><span class="comment">3 7</span></span><br><span class="line"><span class="comment">4 8</span></span><br><span class="line"><span class="comment">5 2</span></span><br><span class="line"><span class="comment">5 4</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="7-5-multiset"><a href="#7-5-multiset" class="headerlink" title="7.5 multiset"></a>7.5 multiset</h2><p><strong><code>multiset</code> ：元素可以重复，且元素有序（默认升序）。</strong></p>
<ul>
<li>注意点一：方法函数基本和 <code>set</code> 一样，参考 set 即可。</li>
<li>注意点二：进行删除操作时，要明确删除目标。（ 下面 <code>s</code> 为声明的 multiset 变量名）。<ul>
<li>删除多个元素：由于元素可以重复，注意使用 <code>s.erase(val)</code> 方法时，会删除掉所有与 <code>val</code> 相等的元素。</li>
<li>删除一个元素：需要删除一个元素时，需要使用 <code>s.erase(s.find(val))</code> 操作，先找到一个与 <code>val</code> 相等的元素迭代器，专门删除这个元素。</li>
</ul>
</li>
<li>注意点三：头文件操作为 <code>#include&lt;set&gt;</code>。</li>
</ul>
<ol>
<li><strong><code>unordered_set</code> ：元素无序且只能出现一次。</strong></li>
<li><strong><code>unordered_multiset</code> ：元素无序可以出现多次。</strong></li>
</ol>
<table>
<thead>
<tr>
<th>操作</th>
<th>示例</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>插入元素</td>
<td><code>ms.insert(5);</code></td>
<td>O(log n)</td>
</tr>
<tr>
<td>删除单个元素（只删一个）</td>
<td><code>ms.erase(ms.find(5));</code></td>
<td>只删一个 5</td>
</tr>
<tr>
<td>删除所有某值元素</td>
<td><code>ms.erase(5);</code></td>
<td>删除所有等于 5 的元素</td>
</tr>
<tr>
<td>计数某值出现次数</td>
<td><code>ms.count(5);</code></td>
<td>返回值为 <code>size_t</code></td>
</tr>
<tr>
<td>查找元素</td>
<td><code>ms.find(5);</code></td>
<td>返回迭代器，找不到返回 <code>ms.end()</code></td>
</tr>
<tr>
<td>最小值</td>
<td><code>*ms.begin()</code></td>
<td>第一个元素</td>
</tr>
<tr>
<td>最大值</td>
<td><code>*ms.rbegin()</code></td>
<td>最后一个元素（反向迭代器）</td>
</tr>
<tr>
<td>判断是否为空</td>
<td><code>ms.empty()</code></td>
<td>是否无元素</td>
</tr>
<tr>
<td>获取元素个数</td>
<td><code>ms.size()</code></td>
<td>总元素数（含重复）</td>
</tr>
</tbody></table>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span>                  <span class="comment">// 包含 multiset 所在头文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    multiset&lt;<span class="type">int</span>&gt; ms;           <span class="comment">// 声明一个默认升序的 multiset &lt;int&gt;</span></span><br><span class="line">    <span class="comment">// multiset &lt;int, greater&lt;int&gt; &gt; ms;  	// 声明一个降序 multiset</span></span><br><span class="line">    ms.<span class="built_in">insert</span>(<span class="number">5</span>);</span><br><span class="line">    ms.<span class="built_in">insert</span>(<span class="number">3</span>);</span><br><span class="line">    ms.<span class="built_in">insert</span>(<span class="number">7</span>);</span><br><span class="line">    ms.<span class="built_in">insert</span>(<span class="number">5</span>);               <span class="comment">// 重复插入也是允许的</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : ms)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;       <span class="comment">// 遍历输出：3 5 5 7</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">一个升序的 multiset 可以实现: <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">3</span> <span class="number">5</span></span><br><span class="line">一个降序的 multiset 可以实现: <span class="number">5</span> <span class="number">3</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h2 id="8-pair"><a href="#8-pair" class="headerlink" title="8 pair"></a>8 pair</h2><h2 id="8-1-介绍"><a href="#8-1-介绍" class="headerlink" title="8.1 介绍"></a>8.1 介绍</h2><p>pair 只含有两个元素，可以看作是只有两个元素的结构体。</p>
<p><strong>应用：</strong></p>
<ul>
<li>代替二元结构体</li>
<li>作为 map 键值对进行插入（代码如下）</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span>  <span class="comment">// 定义 std:: pair 所在的头文件</span></span></span><br><span class="line">map&lt;string, <span class="type">int</span>&gt;mp;</span><br><span class="line">mp.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;string, <span class="type">int</span>&gt;(<span class="string">&quot;xingmaqi&quot;</span>, <span class="number">1</span>));</span><br><span class="line"><span class="comment">// mp.insert(make_pair(&quot;xingmaqi&quot;, 1));</span></span><br><span class="line"><span class="comment">// mp.insert(&#123;&quot;xingmaqi&quot;, 1&#125;);</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.初始化定义</span></span><br><span class="line"><span class="function">pair&lt;string, <span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="string">&quot;wangyaqi&quot;</span>, <span class="number">1</span>)</span></span>;				  <span class="comment">//带初始值的</span></span><br><span class="line">pair&lt;string, <span class="type">int</span>&gt; p;							<span class="comment">//不带初始值的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.赋值</span></span><br><span class="line">p = &#123;<span class="string">&quot;wang&quot;</span>, <span class="number">18</span>&#125;;</span><br><span class="line">p = <span class="built_in">make_pair</span>(<span class="string">&quot;wang&quot;</span>, <span class="number">18</span>);</span><br><span class="line">p = <span class="built_in">pair</span>&lt;string, <span class="type">int</span>&gt;(<span class="string">&quot;wang&quot;</span>, <span class="number">18</span>);</span><br></pre></td></tr></table></figure>

<h2 id="8-2-访问"><a href="#8-2-访问" class="headerlink" title="8.2 访问"></a>8.2 访问</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义结构体数组</span></span><br><span class="line">pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; p[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//和结构体类似，first 代表第一个元素，second 代表第二个元素</span></span><br><span class="line">	cout &lt;&lt; p[i].first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; p[i].second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-string"><a href="#9-string" class="headerlink" title="9 string"></a>9 string</h2><h2 id="9-1-介绍"><a href="#9-1-介绍" class="headerlink" title="9.1 介绍"></a>9.1 介绍</h2><p>string 是一个字符串类，和 <code>char</code> 型字符串类似。可以把 string 理解为一个字符串类型，像 int 一样可以定义。需要注意的是 string 类型结尾不包含 <code>/0</code>！</p>
<h2 id="9-2-初始化及定义"><a href="#9-2-初始化及定义" class="headerlink" title="9.2 初始化及定义"></a>9.2 初始化及定义</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.</span></span><br><span class="line">string str1; 		                <span class="comment">//生成空字符串</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.</span></span><br><span class="line"><span class="function">string <span class="title">str2</span><span class="params">(<span class="string">&quot;123456789&quot;</span>)</span></span>;           <span class="comment">//生成 &quot;1234456789&quot; 的复制品 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3.</span></span><br><span class="line"><span class="function">string <span class="title">str3</span><span class="params">(<span class="string">&quot;12345&quot;</span>, <span class="number">0</span>, <span class="number">3</span>)</span></span>;         <span class="comment">//结果为 &quot;123&quot; ，从 0 位置开始，长度为 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//4.</span></span><br><span class="line"><span class="function">string <span class="title">str4</span><span class="params">(<span class="string">&quot;123456&quot;</span>, <span class="number">5</span>)</span></span>;           <span class="comment">//结果为 &quot;12345&quot; ，长度为 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//5.</span></span><br><span class="line"><span class="function">string <span class="title">str5</span><span class="params">(<span class="number">5</span>, <span class="string">&#x27;2&#x27;</span>)</span></span>;                <span class="comment">//结果为 &quot;22222&quot; , 构造 5 个字符&#x27;2&#x27;连接而成的字符串</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//6.</span></span><br><span class="line"><span class="function">string <span class="title">str6</span><span class="params">(str2, <span class="number">2</span>)</span></span>;               <span class="comment">//结果为 &quot;3456789&quot;，截取第三个元素（2 对应第三位）到最后</span></span><br></pre></td></tr></table></figure>

<p><strong>简单使用</strong></p>
<ul>
<li>访问单个字符：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string s = <span class="string">&quot;xing ma qi!!!&quot;</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; s[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>string</code> 数组使用：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string s[<span class="number">10</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">		s[i] = <span class="string">&quot;loading...  &quot;</span> ;</span><br><span class="line">		cout &lt;&lt; s[i] &lt;&lt; i &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">loading...  <span class="number">1</span></span><br><span class="line">loading...  <span class="number">2</span></span><br><span class="line">loading...  <span class="number">3</span></span><br><span class="line">loading...  <span class="number">4</span></span><br><span class="line">loading...  <span class="number">5</span></span><br><span class="line">loading...  <span class="number">6</span></span><br><span class="line">loading...  <span class="number">7</span></span><br><span class="line">loading...  <span class="number">8</span></span><br><span class="line">loading...  <span class="number">9</span></span><br></pre></td></tr></table></figure>

<h2 id="9-3-string-特性"><a href="#9-3-string-特性" class="headerlink" title="9.3 string 特性"></a>9.3 string 特性</h2><ul>
<li><p>支持 <strong>比较</strong> 运算符<br>  string 字符串支持常见的比较操作符 <code>（&gt;,&gt;=,&lt;,&lt;=,==,!=）</code>，支持 <code>string</code> 与 <code>C-string</code> 的比较（如 <code>str &lt; &quot;hello&quot;</code>）。在使用 <code>&gt;,&gt;=,&lt;,&lt;=</code> 这些操作符的时候是根据“当前字符特性”将字符按 <code>字典顺序</code> 进行逐一的比较。字典排序靠前的字符小， 比较的顺序是从前向后比较，遇到不相等的字符就按这个位置上的两个字符的比较结果确定两个字符串的大小（前面减后面）。同时，<code>string (&quot;aaaa&quot;) &lt;string(aaaaa)</code>。</p>
</li>
<li><p>支持 <code>+</code> <strong>运算</strong> 符，代表拼接字符串，string 字符串可以拼接，通过 “+” 运算符进行拼接。</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string s1 = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">string s2 = <span class="string">&quot;456&quot;</span>;</span><br><span class="line">string s = s1 + s2;</span><br><span class="line">cout &lt;&lt; s;   		<span class="comment">//123456</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="9-4-读入详解"><a href="#9-4-读入详解" class="headerlink" title="9.4 读入详解"></a>9.4 读入详解</h2><p><strong>读入字符串，遇空格，回车结束</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string s;</span><br><span class="line">cin &gt;&gt; s;</span><br></pre></td></tr></table></figure>

<p><strong>读入一行字符串（包括空格），遇回车结束</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string s;</span><br><span class="line"><span class="built_in">getline</span>(cin, s);</span><br></pre></td></tr></table></figure>

<p>注意: <code>getline(cin, s)</code> 会获取前一个输入的换行符，需要在前面添加读取换行符的语句。如：<code>getchar()</code> 或 <code>cin.get()</code></p>
<p>错误读取：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;</span><br><span class="line">string s;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="built_in">getline</span>(cin, s); 		<span class="comment">//此时读取相当于读取了前一个回车字符</span></span><br></pre></td></tr></table></figure>

<p>正确读取：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;</span><br><span class="line">string s;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="built_in">getchar</span>(); 				<span class="comment">//cin.get()</span></span><br><span class="line"><span class="built_in">getline</span>(cin, s);		<span class="comment">//可正确读入下一行的输入</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>cin</code> 与 <code>cin.getline()</code> 混用</p>
<p>cin 输入完后，回车，cin 遇到回车结束输入，但回车还在输入流中，cin 并不会清除，导致 <code>getline()</code> 读取回车，结束。<br>需要在 cin 后面加 <code>cin.ignore()</code>；主动删除输入流中的换行符。（不常用）</p>
</blockquote>
<p><strong>cin 和 cout 解锁（关闭同步流）</strong></p>
<p>代码（写在 main 函数开头）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="number">0</span>),cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>为什么要进行 <code>cin</code> 和 <code>cout</code> 的解锁，原因是：</p>
<p>在一些题目中，读入的 <strong>数据量很大</strong>，往往超过了 1e5（105）的数据量, 而 <code>cin</code> 和 <code>cout</code> 的读入输出的速度 <strong>很慢</strong>（是因为 <code>cin</code> 和 <code>cout</code> 为了兼容 C 语言的读入输出在性能上做了妥协），远不如 <code>scanf</code> 和 <code>printf</code> 的速度，具体原因可以搜索相关的博客进行了解。</p>
<p><strong>所以</strong> 对 <code>cin</code> 和 <code>cout</code> 进行解锁使 <code>cin</code> 和 <code>cout</code> 的速度几乎接近 <code>scanf</code> 和 <code>printf</code>，避免输入输出超时。</p>
</blockquote>
<p><strong>注意</strong>：<code>cin cout</code> 解锁使用时，不能与 <code>scanf,getchar, printf,cin.getline()</code> 混用，一定要注意，会出错。</p>
<blockquote>
<p><strong>string 与 C 语言字符串（C-string）的区别</strong></p>
<ul>
<li>string：是 C++的一个类，专门实现字符串的相关操作。具有丰富的操作方法，数据类型为 <code>string</code>，字符串结尾没有 <code>\0</code> 字符。</li>
<li>C-string：C 语言中的字符串，用 char 数组实现，类型为 <code>const char *</code>, 字符串结尾以 <code>\0</code> 结尾。</li>
</ul>
</blockquote>
<p><strong>一般来说 string 向 char 数组转换会出现一些问题，所以为了能够实现转换，string 有一个方法 <code>c_str()</code> 实现 string 向 char 数组的转换。这个在项目中还算比较常用。</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string s = <span class="string">&quot;xing ma qi&quot;</span>;</span><br><span class="line"><span class="type">char</span> s2[] = s.<span class="built_in">c_str</span>();</span><br></pre></td></tr></table></figure>

<h2 id="9-5-函数方法"><a href="#9-5-函数方法" class="headerlink" title="9.5 函数方法"></a>9.5 函数方法</h2><ul>
<li><strong>获取字符串长度</strong></li>
</ul>
<table>
<thead>
<tr>
<th>代码</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>s.size()</code> 和 <code>s.length()</code></td>
<td>返回 string 对象的字符个数，他们执行效果相同。</td>
</tr>
<tr>
<td><code>s.max_size()</code></td>
<td>返回 string 对象最多包含的字符数，超出会抛出 length_error 异常</td>
</tr>
<tr>
<td><code>s.capacity()</code></td>
<td>重新分配内存之前，string 对象能包含的最大字符数</td>
</tr>
</tbody></table>
<ul>
<li><strong>插入</strong></li>
</ul>
<table>
<thead>
<tr>
<th>代码</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>s.push_back()</code></td>
<td>在末尾插入</td>
</tr>
<tr>
<td>例：<code>s.push_back(&#39;a&#39;)</code></td>
<td>末尾插入一个字符 a</td>
</tr>
<tr>
<td><code>s.insert(pos,element)</code></td>
<td>在 pos 位置插入 element</td>
</tr>
<tr>
<td>例：<code>s.insert(s.begin(),&#39;1&#39;)</code></td>
<td>在第一个位置插入 1 字符</td>
</tr>
<tr>
<td><code>s.append(str)</code></td>
<td>在 s 字符串结尾添加 str 字符串</td>
</tr>
<tr>
<td>例：<code>s.append(&quot;abc&quot;)</code></td>
<td>在 s 字符串末尾添加字符串“abc”</td>
</tr>
</tbody></table>
<ul>
<li><strong>删除</strong></li>
</ul>
<table>
<thead>
<tr>
<th>代码</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>erase(iterator p)</code></td>
<td>删除字符串中 p 所指的字符</td>
</tr>
<tr>
<td><code>erase(iterator first, iterator last)</code></td>
<td>删除字符串中迭代器区间 <code>[first,last)</code> 上所有字符</td>
</tr>
<tr>
<td><code>erase(pos, len)</code></td>
<td>删除字符串中从索引位置 pos 开始的 len 个字符</td>
</tr>
<tr>
<td><code>clear()</code></td>
<td>删除字符串中所有字符</td>
</tr>
</tbody></table>
<ul>
<li><strong>字符替换</strong></li>
</ul>
<table>
<thead>
<tr>
<th>代码</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>s.replace(pos,n,str)</code></td>
<td>把当前字符串从索引 pos 开始的 n 个字符替换为 str</td>
</tr>
<tr>
<td><code>s.replace(pos,n,n1,c)</code></td>
<td>把当前字符串从索引 pos 开始的 n 个字符替换为 n1 个字符 c</td>
</tr>
<tr>
<td><code>s.replace(it1,it2,str)</code></td>
<td>把当前字符串 <code>[it1,it2)</code> 区间替换为 str <strong>it1 , it2 为迭代器哦</strong></td>
</tr>
</tbody></table>
<ul>
<li><strong>大小写转换</strong></li>
</ul>
<p>法一：</p>
<table>
<thead>
<tr>
<th>代码</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>tolower(s[i])</code></td>
<td>转换为小写</td>
</tr>
<tr>
<td><code>toupper(s[i])</code></td>
<td>转换为大写</td>
</tr>
</tbody></table>
<p>法二：</p>
<p>通过 stl 的 <code>transform</code> 算法配合 <code>tolower</code> 和 <code>toupper</code> 实现。<br>有 4 个参数，前 2 个指定要转换的容器的起止范围，第 3 个参数是结果存放容器的起始位置，第 4 个参数是一元运算。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string s;</span><br><span class="line"><span class="built_in">transform</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>(),s.<span class="built_in">begin</span>(),::tolower);	<span class="comment">//转换小写</span></span><br><span class="line"><span class="built_in">transform</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>(),s.<span class="built_in">begin</span>(),::toupper);	<span class="comment">//转换大写</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>分割</strong></li>
</ul>
<table>
<thead>
<tr>
<th>代码</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>s.substr(pos,n)</code></td>
<td>截取从 pos 索引开始的 n 个字符</td>
</tr>
</tbody></table>
<ul>
<li><strong>查找</strong></li>
</ul>
<table>
<thead>
<tr>
<th>代码</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>s.find (str, pos)</code></td>
<td>在当前字符串的 pos 索引位置（默认为 0）开始，查找子串 str，返回找到的位置索引，-1 表示查找不到子串</td>
</tr>
<tr>
<td><code>s.find (c, pos)</code></td>
<td>在当前字符串的 pos 索引位置（默认为 0）开始，查找字符 c，返回找到的位置索引，-1 表示查找不到字符</td>
</tr>
<tr>
<td><code>s.rfind (str, pos)</code></td>
<td>在当前字符串的 pos 索引位置开始，反向查找子串 s，返回找到的位置索引，-1 表示查找不到子串</td>
</tr>
<tr>
<td><code>s.rfind (c,pos)</code></td>
<td>在当前字符串的 pos 索引位置开始，反向查找字符 c，返回找到的位置索引，-1 表示查找不到字符</td>
</tr>
<tr>
<td><code>s.find_first_of (str, pos)</code></td>
<td>在当前字符串的 pos 索引位置（默认为 0）开始，查找子串 s 的字符，返回找到的位置索引，-1 表示查找不到字符</td>
</tr>
<tr>
<td><code>s.find_first_not_of (str,pos)</code></td>
<td>在当前字符串的 pos 索引位置（默认为 0）开始，查找第一个不位于子串 s 的字符，返回找到的位置索引，-1 表示查找不到字符</td>
</tr>
<tr>
<td><code>s.find_last_of(str, pos)</code></td>
<td>在当前字符串的 pos 索引位置开始，查找最后一个位于子串 s 的字符，返回找到的位置索引，-1 表示查找不到字符</td>
</tr>
<tr>
<td><code>s.find_last_not_of ( str, pos)</code></td>
<td>在当前字符串的 pos 索引位置开始，查找最后一个不位于子串 s 的字符，返回找到的位置索引，-1 表示查找不到子串</td>
</tr>
</tbody></table>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">string <span class="title">s</span><span class="params">(<span class="string">&quot;dog bird chicken bird cat&quot;</span>)</span></span>;</span><br><span class="line">    <span class="comment">//字符串查找-----找到后返回首字母在字符串中的下标</span></span><br><span class="line">    <span class="comment">// 1. 查找一个字符串</span></span><br><span class="line">    cout &lt;&lt; s.<span class="built_in">find</span>(<span class="string">&quot;chicken&quot;</span>) &lt;&lt; endl;              <span class="comment">// 结果是：9</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 从下标为 6 开始找字符&#x27;i&#x27;，返回找到的第一个 i 的下标</span></span><br><span class="line">    cout &lt;&lt; s.<span class="built_in">find</span>(<span class="string">&#x27;i&#x27;</span>, <span class="number">6</span>) &lt;&lt; endl;                 <span class="comment">// 结果是：11</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 从字符串的末尾开始查找字符串，返回的还是首字母在字符串中的下标</span></span><br><span class="line">    cout &lt;&lt; s.<span class="built_in">rfind</span>(<span class="string">&quot;chicken&quot;</span>) &lt;&lt; endl;             <span class="comment">// 结果是：9</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 从字符串的末尾开始查找字符</span></span><br><span class="line">    cout &lt;&lt; s.<span class="built_in">rfind</span>(<span class="string">&#x27;i&#x27;</span>) &lt;&lt; endl;                   <span class="comment">// 结果是：18 因为是从末尾开始查找，所以返回第一次找到的字符</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 在该字符串中查找第一个属于字符串 s 的字符</span></span><br><span class="line">    cout &lt;&lt; s.<span class="built_in">find_first_of</span>(<span class="string">&quot;13br98&quot;</span>) &lt;&lt; endl;      <span class="comment">// 结果是：4---b</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 在该字符串中查找第一个不属于字符串 s 的字符------先匹配 dog，然后 bird 匹配不到，所以打印 4</span></span><br><span class="line">    cout &lt;&lt; s.<span class="built_in">find_first_not_of</span>(<span class="string">&quot;hello dog 2006&quot;</span>) &lt;&lt; endl;      <span class="comment">// 结果是：4</span></span><br><span class="line">    cout &lt;&lt; s.<span class="built_in">find_first_not_of</span>(<span class="string">&quot;dog bird 2006&quot;</span>) &lt;&lt; endl;       <span class="comment">// 结果是：9</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7. 在该字符串最后中查找第一个属于字符串 s 的字符</span></span><br><span class="line">    cout &lt;&lt; s.<span class="built_in">find_last_of</span>(<span class="string">&quot;13r98&quot;</span>) &lt;&lt; endl;        <span class="comment">// 结果是：19</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 8. 在该字符串最后中查找第一个不属于字符串 s 的字符------先匹配 t--a---c，然后空格匹配不到，所以打印 21</span></span><br><span class="line">    cout &lt;&lt; s.<span class="built_in">find_last_not_of</span>(<span class="string">&quot;teac&quot;</span>) &lt;&lt; endl;     <span class="comment">// 结果是：21</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>排序</strong></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sort</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>());  	<span class="comment">//按 ASCII 码排序</span></span><br></pre></td></tr></table></figure>

<h2 id="10-bitset"><a href="#10-bitset" class="headerlink" title="10 bitset"></a>10 bitset</h2><h2 id="10-1-介绍"><a href="#10-1-介绍" class="headerlink" title="10.1 介绍"></a>10.1 介绍</h2><p>bitset 在 bitset 头文件中，它类似数组，并且每一个元素只能是 ０ 或 １，每个元素只用 １bit 空间。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span></span></span><br></pre></td></tr></table></figure>

<h2 id="10-2-初始化定义"><a href="#10-2-初始化定义" class="headerlink" title="10.2 初始化定义"></a>10.2 初始化定义</h2><p>初始化方法：</p>
<table>
<thead>
<tr>
<th>代码</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>bitset&lt;n&gt; a</code></td>
<td>a 有 n 位，每位都为 0</td>
</tr>
<tr>
<td><code>bitset&lt;n&gt; a(b)</code></td>
<td>a 是 unsigned long 型 u 的一个副本</td>
</tr>
<tr>
<td><code>bitset&lt;n&gt; a(s)</code></td>
<td>a 是 string 对象 s 中含有的位串的副本</td>
</tr>
<tr>
<td><code>bitset&lt;n&gt; a(s, pos, n)</code></td>
<td>a 是 s 中从位置 pos 开始的 n 个位的副本</td>
</tr>
</tbody></table>
<blockquote>
<p>注意：<code>n</code> 必须为常量表达式！</p>
</blockquote>
<p>演示代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bitset&lt;4&gt; bitset1;　　        <span class="comment">//无参构造，长度为 ４，默认每一位为 0</span></span><br><span class="line"></span><br><span class="line">    <span class="function">bitset&lt;9&gt; <span class="title">bitset2</span><span class="params">(<span class="number">12</span>)</span></span>;　      <span class="comment">//长度为 9，二进制保存，前面用 0 补充</span></span><br><span class="line"></span><br><span class="line">    string s = <span class="string">&quot;100101&quot;</span>;</span><br><span class="line">    <span class="function">bitset&lt;10&gt; <span class="title">bitset3</span><span class="params">(s)</span></span>;　　    <span class="comment">//长度为 10，前面用 0 补充</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> s2[] = <span class="string">&quot;10101&quot;</span>;</span><br><span class="line">    <span class="function">bitset&lt;13&gt; <span class="title">bitset4</span><span class="params">(s2)</span></span>;　　   <span class="comment">//长度为 13，前面用 0 补充</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; bitset1 &lt;&lt; endl;　　  <span class="comment">//0000</span></span><br><span class="line">    cout &lt;&lt; bitset2 &lt;&lt; endl;　　  <span class="comment">//000001100</span></span><br><span class="line">    cout &lt;&lt; bitset3 &lt;&lt; endl;　　  <span class="comment">//0000100101</span></span><br><span class="line">    cout &lt;&lt; bitset4 &lt;&lt; endl;　    <span class="comment">//0000000010101</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="10-3-特性"><a href="#10-3-特性" class="headerlink" title="10.3 特性"></a>10.3 特性</h2><p><code>bitset</code> 可以进行 <strong>位操作</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">bitset&lt;4&gt; <span class="title">foo</span><span class="params">(string(<span class="string">&quot;1001&quot;</span>))</span></span>;</span><br><span class="line"><span class="function">bitset&lt;4&gt; <span class="title">bar</span><span class="params">(string(<span class="string">&quot;0011&quot;</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; (foo ^= bar) &lt;&lt; endl;       <span class="comment">// 1010 (foo 对 bar 按位异或后赋值给 foo)</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; (foo &amp;= bar) &lt;&lt; endl;       <span class="comment">// 0001 (按位与后赋值给 foo)</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; (foo |= bar) &lt;&lt; endl;       <span class="comment">// 1011 (按位或后赋值给 foo)</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; (foo &lt;&lt;= <span class="number">2</span>) &lt;&lt; endl;        <span class="comment">// 0100 (左移 2 位，低位补 0，有自身赋值)</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; (foo &gt;&gt;= <span class="number">1</span>) &lt;&lt; endl;        <span class="comment">// 0100 (右移 1 位，高位补 0，有自身赋值)</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; (~bar) &lt;&lt; endl;             <span class="comment">// 1100 (按位取反)</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; (bar &lt;&lt; <span class="number">1</span>) &lt;&lt; endl;         <span class="comment">// 0110 (左移，不赋值)</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; (bar &gt;&gt; <span class="number">1</span>) &lt;&lt; endl;         <span class="comment">// 0001 (右移，不赋值)</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; (foo == bar) &lt;&lt; endl;       <span class="comment">// false (1001 == 0011 为 false)</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; (foo != bar) &lt;&lt; endl;       <span class="comment">// true  (1001!= 0011 为 true)</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; (foo &amp; bar) &lt;&lt; endl;        <span class="comment">// 0001 (按位与，不赋值)</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; (foo | bar) &lt;&lt; endl;        <span class="comment">// 1011 (按位或，不赋值)</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; (foo ^ bar) &lt;&lt; endl;        <span class="comment">// 1010 (按位异或，不赋值)</span></span><br></pre></td></tr></table></figure>

<p><strong>访问：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可以通过 [] 访问元素(类似数组)，注意最低位下标为 0，类似于数的二进制表示，如下：</span></span><br><span class="line"><span class="function">bitset&lt;4&gt; <span class="title">f</span><span class="params">(<span class="string">&quot;1011&quot;</span>)</span></span>; </span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; f[i];		<span class="comment">// 输出 1101</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="10-4-方法函数"><a href="#10-4-方法函数" class="headerlink" title="10.4 方法函数"></a>10.4 方法函数</h2><table>
<thead>
<tr>
<th>代码</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>b.any()</code></td>
<td>b 中是否存在置为 1 的二进制位，有 返回 true</td>
</tr>
<tr>
<td><code>b.none()</code></td>
<td>b 中是否没有 1，没有 返回 true</td>
</tr>
<tr>
<td><code>b.count()</code></td>
<td>b 中为 1 的个数</td>
</tr>
<tr>
<td><code>b.size()</code></td>
<td>b 中二进制位的个数</td>
</tr>
<tr>
<td><code>b.test(pos)</code></td>
<td>测试 b 在 pos 位置是否为 1，是 返回 true</td>
</tr>
<tr>
<td><code>b[pos]</code></td>
<td>返回 b 在 pos 处的二进制位</td>
</tr>
<tr>
<td><code>b.set()</code></td>
<td>把 b 中所有位都置为 1</td>
</tr>
<tr>
<td><code>b.set(pos)</code></td>
<td>把 b 中 pos 位置置为 1</td>
</tr>
<tr>
<td><code>b.reset()</code></td>
<td>把 b 中所有位都置为 0</td>
</tr>
<tr>
<td><code>b.reset(pos)</code></td>
<td>把 b 中 pos 位置置为 0</td>
</tr>
<tr>
<td><code>b.flip()</code></td>
<td>把 b 中所有二进制位取反</td>
</tr>
<tr>
<td><code>b.flip(pos)</code></td>
<td>把 b 中 pos 位置取反</td>
</tr>
<tr>
<td><code>b.to_ulong()</code></td>
<td>用 b 中同样的二进制位返回一个 unsigned long 值</td>
</tr>
</tbody></table>
<h2 id="10-5-bitset-优化"><a href="#10-5-bitset-优化" class="headerlink" title="10.5 bitset 优化"></a>10.5 bitset 优化</h2><p>一般会使用 bitset 来优化时间复杂度，大概时间复杂度会除 64 或 32，例如没有优化的时间复杂度为 O(NM) ，使用 bitset 优化后复杂度可能就为 O(NM&#x2F;64)或者 $O\left(\frac{NM}{64}\right)$。</p>
<p>bitset 还有开动态空间的技巧，bitset 常用在 <code>01 背包</code> 优化等算法中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态长度 bitset 实现</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;              <span class="comment">// 开空间的上限，一般为数据范围附近的值</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> len = <span class="number">1</span>&gt;</span><br><span class="line"><span class="type">void</span> <span class="built_in">bitset_</span>(<span class="type">int</span> sz)			    <span class="comment">// sz 即为想要开的大小</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (len &lt; sz)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">bitset_</span>&lt;<span class="built_in">min</span>(len * <span class="number">2</span>, N)&gt;(sz); <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bitset&lt;len + 1&gt; dp;</span><br><span class="line">    <span class="comment">// 具体算法的实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="11-array"><a href="#11-array" class="headerlink" title="11 array"></a>11 array</h2><h2 id="11-1-介绍"><a href="#11-1-介绍" class="headerlink" title="11.1 介绍"></a>11.1 介绍</h2><p>头文件 <code>#include &lt;array&gt;</code>。<code>array</code> 是 C++11 新增的容器，效率与普通数据相差无几，比 <code>vector</code> 效率要高，自身添加了一些成员函数。和其它容器不同，array 容器的大小是 <strong>固定</strong> 的，无法动态的扩展或收缩，<strong>只允许访问或者替换存储的元素。</strong></p>
<p><strong>注意：</strong> <code>array</code> 的使用要在 <code>std</code> 命名空间里。</p>
<h2 id="11-2-声明与初始化"><a href="#11-2-声明与初始化" class="headerlink" title="11.2 声明与初始化"></a>11.2 声明与初始化</h2><p><strong>基础数据类型</strong></p>
<p>声明一个大小为 100 的 <code>int</code> 型数组，元素的值不确定：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array&lt;<span class="type">int</span>, 100&gt; a;</span><br></pre></td></tr></table></figure>

<p>声明一个大小为 100 的 <code>int</code> 型数组，初始值均为 <code>0</code>(初始值与默认元素类型等效)：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array&lt;<span class="type">int</span>, 100&gt; a&#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>声明一个大小为 100 的 <code>int</code> 型数组，初始化部分值，其余全部为 <code>0</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array&lt;<span class="type">int</span>, 100&gt; a&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>或者可以用等号</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array&lt;<span class="type">int</span>, 100&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>高级数据类型</strong></p>
<p>不同于数组的是对元素类型不做要求，可以套结构体：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array&lt;string, 2&gt; s = &#123;<span class="string">&quot;ha&quot;</span>, <span class="built_in">string</span>(<span class="string">&quot;haha&quot;</span>)&#125;;</span><br><span class="line">array&lt;node, 2&gt; a;</span><br></pre></td></tr></table></figure>

<h2 id="11-3-存取元素"><a href="#11-3-存取元素" class="headerlink" title="11.3 存取元素"></a>11.3 存取元素</h2><ul>
<li>修改元素</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array&lt;<span class="type">int</span>, 4&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">a[<span class="number">0</span>] = <span class="number">4</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>访问元素</li>
</ul>
<p><strong>下标访问：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">array&lt;<span class="type">int</span>, 4&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) </span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; \n&quot;</span>[i == <span class="number">3</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>利用 <code>auto</code> 访问：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i : a)</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>迭代器访问：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> it = a.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">for</span>(; it != a.<span class="built_in">end</span>(); it++) </span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>at()</code> 函数访问：</strong> 下标为 <code>1</code> 的元素加上下标为 <code>2</code> 的元素，答案为 <code>5</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array&lt;<span class="type">int</span>, 4&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="type">int</span> res = a.<span class="built_in">at</span>(<span class="number">1</span>) + a.<span class="built_in">at</span>(<span class="number">2</span>);</span><br><span class="line">cout &lt;&lt; res &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br></pre></td></tr></table></figure>

<p><strong><code>get</code> 方法访问：</strong> 将 <code>a</code> 数组下标为 <code>1</code> 位置处的值改为 <code>x</code>。注意：获取的下标只能写数字，不能填变量！</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(a) = x;</span><br></pre></td></tr></table></figure>

<h2 id="11-4-成员函数"><a href="#11-4-成员函数" class="headerlink" title="11.4 成员函数"></a>11.4 成员函数</h2><table>
<thead>
<tr>
<th>成员函数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><code>begin()</code></td>
<td>返回容器中第一个元素的访问迭代器（地址）</td>
</tr>
<tr>
<td><code>end()</code></td>
<td>返回容器最后一个元素之后一个位置的访问迭代器（地址）</td>
</tr>
<tr>
<td><code>rbegin()</code></td>
<td>返回最后一个元素的访问迭代器（地址）</td>
</tr>
<tr>
<td><code>rend()</code></td>
<td>返回第一个元素之前一个位置的访问迭代器（地址）</td>
</tr>
<tr>
<td><code>size()</code></td>
<td>返回容器中元素的数量，其值等于初始化 array 类的第二个模板参数 <code>N</code></td>
</tr>
<tr>
<td><code>max_size()</code></td>
<td>返回容器可容纳元素的最大数量，其值始终等于初始化 array 类的第二个模板参数 N</td>
</tr>
<tr>
<td><code>empty()</code></td>
<td>判断容器是否为空</td>
</tr>
<tr>
<td><code>at(n)</code></td>
<td>返回容器中 n 位置处元素的引用，函数会自动检查 n 是否在有效的范围内，如果不是则抛出 out_of_range 异常</td>
</tr>
<tr>
<td><code>front()</code></td>
<td>返回容器中第一个元素的直接引用，函数不适用于空的 array 容器</td>
</tr>
<tr>
<td><code>back()</code></td>
<td>返回容器中最后一个元素的直接引用，函数不适用于空的 array 容器。</td>
</tr>
<tr>
<td><code>data()</code></td>
<td>返回一个指向容器首个元素的指针。利用该指针，可实现复制容器中所有元素等类似功能</td>
</tr>
<tr>
<td><code>fill(x)</code></td>
<td>将 <code>x</code> 这个值赋值给容器中的每个元素, 相当于初始化</td>
</tr>
<tr>
<td><code>array1.swap(array2)</code></td>
<td>交换 array1 和 array2 容器中的所有元素，但前提是它们具有相同的长度和类型</td>
</tr>
</tbody></table>
<h2 id="11-5-部分用法示例"><a href="#11-5-部分用法示例" class="headerlink" title="11.5 部分用法示例"></a>11.5 部分用法示例</h2><p><code>data()</code>：指向底层元素存储的指针。对于非空容器，返回的指针与首元素地址比较相等。</p>
<p><code>at()</code></p>
<p>下标为 <code>1</code> 的元素加上下标为 <code>2</code> 的元素，答案为 <code>5</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array&lt;<span class="type">int</span>, 4&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="type">int</span> res = a.<span class="built_in">at</span>(<span class="number">1</span>) + a.<span class="built_in">at</span>(<span class="number">2</span>);</span><br><span class="line">cout &lt;&lt; res &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br></pre></td></tr></table></figure>

<p><code>fill()</code></p>
<p>array 的 <code>fill()</code> 函数，将 <code>a</code> 数组全部元素值变为 <code>x</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.<span class="built_in">fill</span>(x);</span><br></pre></td></tr></table></figure>

<p>另外还有其它的 <code>fill()</code> 函数: 将 <code>a</code> 数组 [begin, end) 全部值变为 <code>x</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fill</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), x);</span><br></pre></td></tr></table></figure>

<p><strong>get 方法获取元素值</strong></p>
<p>将 <code>a</code> 数组下标为 <code>1</code> 位置处的值改为 <code>x</code>，注意: 获取的下标只能写数字，不能填变量</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(a) = x;</span><br></pre></td></tr></table></figure>

<p><strong>排序</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sort</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure>

<h2 id="12-tuple"><a href="#12-tuple" class="headerlink" title="12 tuple"></a>12 tuple</h2><h2 id="12-1-介绍"><a href="#12-1-介绍" class="headerlink" title="12.1 介绍"></a>12.1 介绍</h2><p>tuple 模板是 pair 的泛化，可以封装不同类型任意数量的对象。可以把 tuple 理解为 pair 的扩展，tuple 可以声明二元组，也可以声明三元组。tuple 可以等价为 <strong>结构体</strong> 使用。</p>
<p><strong>头文件</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span></span></span><br></pre></td></tr></table></figure>

<h2 id="12-2-声明初始化"><a href="#12-2-声明初始化" class="headerlink" title="12.2 声明初始化"></a>12.2 声明初始化</h2><p>声明一个空的 <code>tuple</code> 三元组：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tuple&lt;<span class="type">int</span>, <span class="type">int</span>, string&gt; t1;</span><br></pre></td></tr></table></figure>

<p>赋值：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t1 = <span class="built_in">make_tuple</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="string">&quot;hahaha&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>创建的同时初始化：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">tuple&lt;<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">t2</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>可以使用 pair 对象构造 tuple 对象，但 tuple 对象必须是两个元素：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> p = <span class="built_in">make_pair</span>(<span class="string">&quot;wang&quot;</span>, <span class="number">1</span>);</span><br><span class="line">tuple&lt;string, <span class="type">int</span>&gt; t3 &#123;p&#125;; 		<span class="comment">//将 pair 对象赋给 tuple 对象</span></span><br></pre></td></tr></table></figure>

<h2 id="12-3-元素操作"><a href="#12-3-元素操作" class="headerlink" title="12.3 元素操作"></a>12.3 元素操作</h2><p>获取 tuple 对象 <code>t</code> 的第一个元素：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> first = <span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(t);</span><br></pre></td></tr></table></figure>

<p>修改 tuple 对象 <code>t</code> 的第一个元素：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(t) = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<h2 id="12-4-函数操作"><a href="#12-4-函数操作" class="headerlink" title="12.4 函数操作"></a>12.4 函数操作</h2><ul>
<li>获取元素个数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">tuple&lt;<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">t</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; tuple_size&lt;<span class="keyword">decltype</span>(t)&gt;::value &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<ul>
<li>获取对应元素的值</li>
</ul>
<p>通过 <code>get&lt;n&gt;(obj)</code> 方法获取, <code>n</code> 必须为数字不能是变量</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">tuple&lt;<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">t</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; <span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(t) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="comment">// 1</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(t) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="comment">// 2</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(t) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<ul>
<li>通过 <code>tie</code> 解包 获取元素值</li>
</ul>
<p><code>tie</code> 可以让 tuple 变量中的三个值依次赋到 tie 中的三个变量中</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> one, three;</span><br><span class="line">string two; </span><br><span class="line"><span class="function">tuple&lt;<span class="type">int</span>, string, <span class="type">int</span>&gt; <span class="title">t</span><span class="params">(<span class="number">1</span>, <span class="string">&quot;hahaha&quot;</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line"><span class="built_in">tie</span>(one, two, three) = t;</span><br><span class="line">cout &lt;&lt; one &lt;&lt; two &lt;&lt; three &lt;&lt; <span class="string">&quot;\n&quot;</span>; 		<span class="comment">// 1hahaha3</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="STL-函数"><a href="#STL-函数" class="headerlink" title="STL 函数"></a>STL 函数</h2><h2 id="sort-——-排序"><a href="#sort-——-排序" class="headerlink" title="sort —— 排序"></a>sort —— 排序</h2><p><strong>时间复杂度：</strong> O(N logN)</p>
<blockquote>
<p>作用：对一个序列进行排序</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原型：</span></span><br><span class="line"><span class="built_in">sort</span>(beg, end);</span><br><span class="line"><span class="built_in">sort</span>(beg, end, cmp);</span><br></pre></td></tr></table></figure>

<p>几种排序的常见操作：</p>
<ul>
<li>操作一：对数组正常升序排序</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[N]; <span class="comment">// 普通数组定义</span></span><br><span class="line"><span class="comment">// 对 a 数组的 [1, n] 位置进行从小到大排序</span></span><br><span class="line"><span class="built_in">sort</span>(a + <span class="number">1</span>, a + <span class="number">1</span> + n);</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">b</span><span class="params">(n + <span class="number">1</span>)</span></span>; <span class="comment">// vector 数组定义</span></span><br><span class="line"><span class="built_in">sort</span>(b.<span class="built_in">begin</span>() + <span class="number">1</span>, b.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure>

<ul>
<li>操作二：使用第三个参数，进行降序排序</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对 a 数组的 [0, n-1] 位置从大到小排序</span></span><br><span class="line"><span class="built_in">sort</span>(a, a + n, <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line"><span class="comment">//对 a 数组的 [0, n-1] 位置从小到大排序</span></span><br><span class="line"><span class="built_in">sort</span>(a, a + n, <span class="built_in">less</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">b</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="built_in">sort</span>(b.<span class="built_in">begin</span>() + <span class="number">1</span>, b.<span class="built_in">end</span>()); <span class="comment">// 升序</span></span><br><span class="line"><span class="built_in">sort</span>(b.<span class="built_in">begin</span>() + <span class="number">1</span>, b.<span class="built_in">end</span>(), <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;()); <span class="comment">// 降序</span></span><br></pre></td></tr></table></figure>

<ul>
<li>操作三：另外一种降序排序方法，针对 <code>vector</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line"><span class="built_in">sort</span>(a.<span class="built_in">rbegin</span>(), a.<span class="built_in">rend</span>()); <span class="comment">// 使用反向迭代器进行降序排序</span></span><br></pre></td></tr></table></figure>

<ul>
<li>操作四：自定义排序规则</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 使用函数自定义排序，定义比较函数</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(node a, node b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//按结构体里面的 x 值降序排列</span></span><br><span class="line">    <span class="keyword">return</span> a.x &gt; b.x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(node, node + n, cmp); 	<span class="comment">// 只能接受以函数为形式的自定义排序规则，无法接受以结构体为形式的自定义排序规则</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 或者使用匿名函数自定义排序规则</span></span><br><span class="line"><span class="built_in">sort</span>(node, node + n, [](node a, node b) &#123;</span><br><span class="line">    <span class="keyword">return</span> a.x &gt; b.x;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="stable-sort"><a href="#stable-sort" class="headerlink" title="stable_sort"></a>stable_sort</h3><p><strong>复杂度：</strong> O(N logN)</p>
<blockquote>
<p>功能和 <code>sort()</code> 基本一样，区别在于 <code>stable_sort()</code> 能够保证相等元素的相对位置，排序时不会改变相等元素的相对位置。</p>
</blockquote>
<p>使用用法和 <code>sort()</code> 一样，见上。</p>
<h3 id="is-sorted"><a href="#is-sorted" class="headerlink" title="is_sorted"></a>is_sorted</h3><p><strong>复杂度：</strong> O(N)</p>
<blockquote>
<p>判断序列是否有序（升序），返回 <code>bool</code> 值</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果序列有序，输出 YES</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">is_sorted</span>(a, a + n))</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;YES\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="iota"><a href="#iota" class="headerlink" title="iota"></a>iota</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">iota</span>(beg, end, start)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>让序列递增赋值</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="built_in">iota</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i : a)</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0 1 2 3 4 5 6 7 8 9</span></span><br></pre></td></tr></table></figure>

<h3 id="partial-sort"><a href="#partial-sort" class="headerlink" title="partial_sort"></a>partial_sort</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">partial_sort</span>(beg, mid, end)</span><br></pre></td></tr></table></figure>

<p><strong>时间复杂度：</strong> 大概 O(N logM) ，其中 <code>M</code> 为距离</p>
<blockquote>
<p>部分排序, 排序 mid-beg 个元素，mid 为要排序区间元素的尾后的一个位置</p>
<p>从 beg 到 mid <strong>前</strong> 的元素都排好序</p>
</blockquote>
<p>对 a 数组前 5 个元素排序按从小到大排序</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">6</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="built_in">partial_sort</span>(a, a + <span class="number">5</span>, a + <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; a[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1 2 3 4 5 9 8 10 7 6</span></span><br><span class="line"><span class="comment">//前五个元素都有序</span></span><br></pre></td></tr></table></figure>

<p>也可以添加自定义排序规则：</p>
<p><code>partial_sort(beg,mid,end,cmp)</code></p>
<p>对 a 的前五个元素都是降序排列</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">6</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="built_in">partial_sort</span>(a, a + <span class="number">5</span>, a + <span class="number">10</span>, <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) </span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; a[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//10 9 8 7 6 1 2 4 5 3</span></span><br><span class="line"><span class="comment">//前五个元素降序有序</span></span><br></pre></td></tr></table></figure>

<h2 id="max-min-——-找最值"><a href="#max-min-——-找最值" class="headerlink" title="max + min —— 找最值"></a>max + min —— 找最值</h2><p><strong>时间复杂度：</strong> O(1)</p>
<blockquote>
<p>找多个元素的最大值和最小值</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//找 a，b 的最大值和最小值</span></span><br><span class="line">mx = <span class="built_in">max</span>(a, b);</span><br><span class="line">mn = <span class="built_in">min</span>(a, b);</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//找到 a, b, c, d 的最大值和最小值</span></span><br><span class="line">mx = <span class="built_in">max</span>(&#123;a, b, c, d&#125;);</span><br><span class="line">mn = <span class="built_in">min</span>(&#123;a, b, c, d&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="max-element-min-element"><a href="#max-element-min-element" class="headerlink" title="max_element+min_element"></a>max_element+min_element</h3><p><strong>复杂度：</strong> O(N)</p>
<blockquote>
<p>找最大最小值</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数都是返回地址，需要加*解引用取值</span></span><br><span class="line"><span class="type">int</span> mx = *<span class="built_in">max_element</span>(a, a + n);</span><br><span class="line"><span class="type">int</span> mn = *<span class="built_in">min_element</span>(a, a + n);</span><br></pre></td></tr></table></figure>

<h3 id="nth-element-——-寻找第-n-小的值"><a href="#nth-element-——-寻找第-n-小的值" class="headerlink" title="nth_element —— 寻找第 n 小的值"></a>nth_element —— 寻找第 n 小的值</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">nth_element</span>(beg, nth, end)</span><br></pre></td></tr></table></figure>

<p><strong>复杂度：</strong> 平均 O(N)</p>
<blockquote>
<p>寻找第序列第 n 小的值</p>
</blockquote>
<p><code>nth</code> 为一个迭代器，指向序列中的一个元素。第 n 小的值恰好在 <code>nth</code> 位置上。</p>
<p>执行 <code>nth_element()</code> 之后，序列中的元素会围绕 nth 进行划分：<strong>nth 之前的元素都小于等于它，而之后的元素都大于等于它</strong></p>
<p><strong>实例：求序列中的第 3 小的元素</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">nth_element</span>(a, a + <span class="number">2</span>, a + n);</span><br><span class="line">cout &lt;&lt; a[<span class="number">2</span>] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="minmax"><a href="#minmax" class="headerlink" title="minmax"></a>minmax</h3><p><strong>复杂度：</strong> O(1)</p>
<blockquote>
<p>返回一个 <code>pair</code> 类型，第一个元素是 <code>min(a, b)</code>， 第二个元素是 <code>max(a, b)</code></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; t = <span class="built_in">minmax</span>(<span class="number">4</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">// t.first = 2, t.second = 4</span></span><br></pre></td></tr></table></figure>

<h3 id="minmax-element"><a href="#minmax-element" class="headerlink" title="minmax_element"></a>minmax_element</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">minmax_element</span>(beg, end)</span><br></pre></td></tr></table></figure>

<p><strong>复杂度：</strong> O(N)</p>
<blockquote>
<p>返回序列中的最小和最大值组成 pair 的对应的地址，返回类型为 <code>pair&lt;vector&lt;int&gt;::iterator, vector&lt;int&gt;::iterator&gt;</code></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n = <span class="number">10</span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line"><span class="built_in">iota</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), <span class="number">1</span>);</span><br><span class="line"><span class="keyword">auto</span> t = <span class="built_in">minmax_element</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>()); <span class="comment">// 返回的是最小值和最大值对应的地址</span></span><br><span class="line"><span class="comment">// *t.first = 1, * t.second = 10 输出对应最小最大值时需要使用指针</span></span><br></pre></td></tr></table></figure>

<h2 id="to-string-——-将数字转化成字符串"><a href="#to-string-——-将数字转化成字符串" class="headerlink" title="to_string —— 将数字转化成字符串"></a>to_string —— 将数字转化成字符串</h2><blockquote>
<p>将数字转化为字符串，支持小数（double）</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">12345678</span>;</span><br><span class="line">cout &lt;&lt; <span class="built_in">to_string</span>(a) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h2 id="lower-bound-upper-bound-——-二分查找"><a href="#lower-bound-upper-bound-——-二分查找" class="headerlink" title="lower_bound + upper_bound —— 二分查找"></a>lower_bound + upper_bound —— 二分查找</h2><p><strong>复杂度：</strong> O(logN)</p>
<blockquote>
<p>作用：二分查找</p>
<p><strong>注意：用 * 解引用之后是取出来的是值，减去 <code>begin()</code> 得到的是下标！</strong></p>
<ul>
<li><strong>三个参数</strong>：<code>(起始位置, 结束位置, 目标值)</code>。</li>
<li><strong>范围</strong>：左闭右开 <code>[start, end)</code>。</li>
<li><strong>返回值</strong>：成功返回有效迭代器&#x2F;指针，失败返回 <code>end</code>。</li>
<li><strong>前提</strong>：数据必须有序！</li>
</ul>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果未找到，返回尾地址的下一个位置的地址</span></span><br><span class="line"><span class="built_in">lower_bound</span>(起始迭代器 / 指针, 结束迭代器 / 指针, 目标值);</span><br><span class="line"><span class="built_in">upper_bound</span>(起始迭代器 / 指针, 结束迭代器 / 指针, 目标值);</span><br><span class="line"><span class="built_in">lower_bound</span>(a, a + n, x);        <span class="comment">//在 a 数组中查找第一个大于等于 x 的元素，返回该元素的地址</span></span><br><span class="line"><span class="built_in">upper_bound</span>(a, a + n, x);        <span class="comment">//在 a 数组中查找第一个大于 x 的元素，返回该元素的地址</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span>             <span class="comment">// 包含 lower_bound 和 upper_bound</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a[] = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">9</span>, <span class="number">9</span>, <span class="number">11</span> &#125;;</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">sizeof</span>(a) / <span class="built_in">sizeof</span>(a[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 示例 1：使用 lower_bound 查找第一个 &gt;= 3 的元素</span></span><br><span class="line">    <span class="type">int</span> x = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">auto</span> it1 = <span class="built_in">lower_bound</span>(a, a + n, x);</span><br><span class="line">    <span class="keyword">if</span> (it1 != a + n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> index = it1 - a;        <span class="comment">// 计算下标</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;第一个大于等于 &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; 的元素是 a[&quot;</span> &lt;&lt; index &lt;&lt; <span class="string">&quot;] = &quot;</span> &lt;&lt; *it1 &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 第一个大于等于 3 的元素是 a [1] = 3</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;没有找到大于等于 &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; 的元素&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 示例 2：使用 upper_bound 查找第一个 &gt; 3 的元素</span></span><br><span class="line">    <span class="keyword">auto</span> it2 = <span class="built_in">upper_bound</span>(a, a + n, x);</span><br><span class="line">    <span class="keyword">if</span> (it2 != a + n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> index = it2 - a;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;第一个大于 &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; 的元素是 a[&quot;</span> &lt;&lt; index &lt;&lt; <span class="string">&quot;] = &quot;</span> &lt;&lt; *it2 &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 第一个大于 3 的元素是 a [3] = 5</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;没有找到大于 &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; 的元素&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 示例 3：查找不存在的元素</span></span><br><span class="line">    x = <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">auto</span> it3 = <span class="built_in">lower_bound</span>(a, a + n, x);</span><br><span class="line">    <span class="keyword">if</span> (it3 != a + n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> index = it3 - a;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;第一个大于等于 &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; 的元素是 a[&quot;</span> &lt;&lt; index &lt;&lt; <span class="string">&quot;] = &quot;</span> &lt;&lt; *it3 &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 第一个大于等于 8 的元素是 a [5] = 9</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;没有找到大于等于 &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; 的元素&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 示例 4：统计某个值出现的次数</span></span><br><span class="line">    x = <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">auto</span> left = <span class="built_in">lower_bound</span>(a, a + n, x);</span><br><span class="line">    <span class="keyword">auto</span> right = <span class="built_in">upper_bound</span>(a, a + n, x);</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; <span class="string">&quot; 出现的次数: &quot;</span> &lt;&lt; right - left &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 9 出现的次数: 3</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 示例 5：在 vector 中使用</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v = &#123; <span class="number">2</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span> &#125;;</span><br><span class="line">    <span class="keyword">auto</span> itv = <span class="built_in">lower_bound</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">if</span> (itv != v.<span class="built_in">end</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> index = itv - v.<span class="built_in">begin</span>();</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;vector 中第一个大于等于 5 的元素是 v[&quot;</span> &lt;&lt; index &lt;&lt; <span class="string">&quot;] = &quot;</span> &lt;&lt; *itv &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// vector 中第一个大于等于 5 的元素是 v [3] = 6</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="atoi-——-将字符串转整型"><a href="#atoi-——-将字符串转整型" class="headerlink" title="atoi —— 将字符串转整型"></a>atoi —— 将字符串转整型</h2><blockquote>
<p>将字符串转换为 <code>int</code> 类型</p>
</blockquote>
<p>注意参数为 <code>char</code> 型数组，如果需要将 string 类型转换为 int 类型，可以使用 <code>stoi</code> 函数（参考下文），或者将 <code>string</code> 类型转换为 <code>const char *</code> 类型。</p>
<p>关于输出数字的范围：</p>
<ul>
<li><code>atoi</code> <strong>不做</strong> 范围检查，如果超出上界，输出上界，超出下界，输出下界。</li>
<li><code>stoi</code> <strong>会做</strong> 范围检查，默认必须在 <code>int</code> 范围内，如果超出范围，会出现 RE（Runtime Error）错误。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string s = <span class="string">&quot;1234&quot;</span>;</span><br><span class="line"><span class="type">int</span> a = <span class="built_in">atoi</span>(s.<span class="built_in">c_str</span>());</span><br><span class="line">cout &lt;&lt; a &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">// 1234</span></span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> s[] = <span class="string">&quot;1234&quot;</span>;</span><br><span class="line"><span class="type">int</span> a = <span class="built_in">atoi</span>(s);</span><br><span class="line">cout &lt;&lt; a &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br></pre></td></tr></table></figure>

<h2 id="stoi-stoll-stod-…-——-将字符串转整型（更常用）"><a href="#stoi-stoll-stod-…-——-将字符串转整型（更常用）" class="headerlink" title="stoi &#x2F; stoll &#x2F; stod &#x2F; … —— 将字符串转整型（更常用）"></a>stoi &#x2F; stoll &#x2F; stod &#x2F; … —— 将字符串转整型（更常用）</h2><blockquote>
<p>将对应 string 类型字符串转换为数字（<code>int</code> 型），记忆：<code>s -&gt; t 分别对应两个数据类型的某个字母</code></p>
</blockquote>
<p>注意参数为 <code>string</code> 字符串类型。</p>
<p><strong>如果要转换为其他类型的数字可使用 <code>stoll（转换为 long long）</code> ， <code>stoull（转换为 unsigned long long）</code>，<code>stod（转换为 double）</code> 等函数。</strong></p>
<p>关于输出数字的范围：</p>
<ul>
<li><p><code>stoi</code> <strong>会做</strong> 范围检查，默认必须在 <code>int</code> 范围内，如果超出范围，会出现 RE（Runtime Error）错误。</p>
</li>
<li><p><code>atoi</code> <strong>不做</strong> 范围检查，如果超出上界，输出上界，超出下界，输出下界。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string s = <span class="string">&quot;1234&quot;</span>;</span><br><span class="line"><span class="type">int</span> a = <span class="built_in">stoi</span>(s);</span><br><span class="line">cout &lt;&lt; a &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">// 1234</span></span><br></pre></td></tr></table></figure>

<h2 id="reverse-——-翻转"><a href="#reverse-——-翻转" class="headerlink" title="reverse —— 翻转"></a>reverse —— 翻转</h2><p><strong>时间复杂度：</strong> O(N)</p>
<blockquote>
<p><strong>对序列进行前后翻转，包含在头文件 <code>#include &lt;algorithm&gt;</code> 中！</strong></p>
</blockquote>
<blockquote>
<p>  [!NOTE]</p>
<p>  <strong><code>reverse</code> 函数在解决回文串相关问题格外好用</strong></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">string s = <span class="string">&quot;abcde&quot;</span>;</span><br><span class="line"><span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());<span class="comment">//对 s 进行翻转</span></span><br><span class="line">cout &lt;&lt; s &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;<span class="comment">//edcba</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对 a 数组进行翻转</span></span><br><span class="line"><span class="type">int</span> a[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="built_in">reverse</span>(a, a + <span class="number">4</span>);</span><br><span class="line">cout &lt;&lt; a[<span class="number">0</span>] &lt;&lt; a[<span class="number">1</span>] &lt;&lt; a[<span class="number">2</span>] &lt;&lt; a[<span class="number">3</span>];<span class="comment">//4321</span></span><br></pre></td></tr></table></figure>

<h2 id="getline-istringstream-——-读取一行-对字符串流进行分割"><a href="#getline-istringstream-——-读取一行-对字符串流进行分割" class="headerlink" title="getline + istringstream —— 读取一行&#x2F;对字符串流进行分割"></a>getline + istringstream —— 读取一行&#x2F;对字符串流进行分割</h2><blockquote>
<p><strong>时间复杂度： O(n)，头文件：<code>&lt;string&gt;</code> (getline)，<code>&lt;sstream&gt;</code>（istringstream）</strong></p>
</blockquote>
<blockquote>
<p>读取一行（包括空格），搭配 <code>istringstream </code> 实现分割处理</p>
<ul>
<li><code>getline</code>(输入流, 变量); → 读取整行</li>
<li><code>istringstream</code>(字符串变量); → 把字符串当作输入流</li>
<li><code>getline</code>(字符串流, 变量, 分隔符); → 按分隔符拆分数据</li>
<li><code>while </code>(字符串流 &gt;&gt; 变量) → 按空格拆分数据</li>
</ul>
<p><code>istringstream </code> 用于把字符串当作输入流；<code>getline </code> 用于按分隔符拆分数据；<code>while </code> 循环用于按空格拆分数据。</p>
<p>快速记忆：<code>getline</code>(字符串流, 变量, 分隔符); → <code>getline</code> 用于读取一整行包括空格，默认（指定分割符）直到遇到换行符（换行符会被丢弃，不存入变量）才结束。如果指定了分隔符，则会读取到 分隔符 为止（即分隔符的前一个位置，分隔符也会被丢弃，不存入变量），读取的部分会被存储在指定的变量中，而分隔符本身不会被包含在结果中。然后，剩余的部分（分隔符后的字符）会留在输入流中，为下一次读取做准备。下一次调用 <code>getline</code> 会继续从流中读取，直到遇到下一个分隔符或者行结束为止。这个过程会一直继续，直到所有需要的数据都被提取出来。</p>
</blockquote>
<blockquote>
<p>  [!IMPORTANT]</p>
<p>  <code>cin</code> 不能读取换行&#x2F;回车，所以如果在 <code>getline</code> 之前使用了 <code>cin</code>（ 混合输入），那么 <code>getline</code> 实际读取到的是换行&#x2F;回车，就无法正确读入数据，很多时候就是因为这个原因导致程序出错！常用解决方法：当使用了这样的混合输入必须要在 <code>cin</code> 和 <code>getline</code> 之间写上 <strong><code>getchar();</code> 或者 <code>cin.ignore();</code> 来清除输入缓冲区中的换行符！</strong> 例子：</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="comment">// 清除输入缓冲区中的换行符（任选其一）</span></span><br><span class="line"><span class="comment">// getchar();</span></span><br><span class="line">cin.<span class="built_in">ignore</span>();</span><br><span class="line"></span><br><span class="line">string s;</span><br><span class="line"><span class="built_in">getline</span>(cin, s);</span><br></pre></td></tr></table></figure></blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span>                   <span class="comment">// 包含 getline</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span>                  <span class="comment">// 包含 stringstream</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 示例 1：输入 &quot;YYYY-MM-DD&quot;，输出 &quot;YYYY/MM/DD&quot;</span></span><br><span class="line">    string year, month, day;</span><br><span class="line">    <span class="built_in">getline</span>(cin, year, <span class="string">&#x27;-&#x27;</span>);        <span class="comment">// 读取到第一个 &#x27;-&#x27; 为止</span></span><br><span class="line">    <span class="built_in">getline</span>(cin, month, <span class="string">&#x27;-&#x27;</span>);       <span class="comment">// 继续读取到下一个 &#x27;-&#x27;</span></span><br><span class="line">    <span class="built_in">getline</span>(cin, day);              <span class="comment">// 读取剩余部分（默认到行尾）</span></span><br><span class="line">    cout &lt;&lt; year &lt;&lt; <span class="string">&quot;/&quot;</span> &lt;&lt; month &lt;&lt; <span class="string">&quot;/&quot;</span> &lt;&lt; day &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 示例 2：按空格拆分 &quot;42 3.14 hello&quot;</span></span><br><span class="line">    string data = <span class="string">&quot;42 3.14 hello&quot;</span>;</span><br><span class="line">    <span class="function">istringstream <span class="title">iss</span><span class="params">(data)</span></span>;        <span class="comment">// 将字符串转为流</span></span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="type">double</span> pi;</span><br><span class="line">    string word;</span><br><span class="line">    iss &gt;&gt; num &gt;&gt; pi &gt;&gt; word;       <span class="comment">// 按空格提取</span></span><br><span class="line">    cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; pi &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; word &lt;&lt; endl;    <span class="comment">// 输出: 42 3.14 hello</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 示例 3：按逗号拆分 CSV 数据 &quot;apple, orange, banana&quot;</span></span><br><span class="line">    string csv = <span class="string">&quot;apple,orange,banana&quot;</span>;</span><br><span class="line">    <span class="function">istringstream <span class="title">iss_csv</span><span class="params">(csv)</span></span>;</span><br><span class="line">    string fruit;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">getline</span>(iss_csv, fruit, <span class="string">&#x27;,&#x27;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; fruit &lt;&lt; <span class="string">&quot; &quot;</span>;       <span class="comment">// 输出: apple orange banana</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 示例 4：逐行处理输入（如文件或控制台）</span></span><br><span class="line">    string line;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">getline</span>(cin, line))      <span class="comment">// 每次读取一行</span></span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="function">istringstream <span class="title">ss</span><span class="params">(line)</span></span>;</span><br><span class="line">        string token;</span><br><span class="line">        <span class="keyword">while</span> (ss &gt;&gt; token)</span><br><span class="line">        &#123;     </span><br><span class="line">            cout &lt;&lt; token &lt;&lt; <span class="string">&quot; &quot;</span>;   <span class="comment">// 按空格拆分每行</span></span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="set-union-set-intersection-set-difference-——-交并差集"><a href="#set-union-set-intersection-set-difference-——-交并差集" class="headerlink" title="set_union, set_intersection, set_difference —— 交并差集"></a>set_union, set_intersection, set_difference —— 交并差集</h2><p>复杂度： O(N+M)</p>
<blockquote>
<p><strong>求两个集合的并集，交集，差集</strong>。手动实现双指针就可以搞定，嫌麻烦可以使用该函数</p>
</blockquote>
<table>
<thead>
<tr>
<th>函数</th>
<th>作用</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>set_union</code></td>
<td>并集</td>
<td>两个集合所有元素（去重）</td>
</tr>
<tr>
<td><code>set_intersection</code></td>
<td>交集</td>
<td>两个集合共同的元素</td>
</tr>
<tr>
<td><code>set_difference</code></td>
<td>差集</td>
<td>第一个集合有而第二个集合没有的元素</td>
</tr>
</tbody></table>
<p><strong>注意：</strong></p>
<ul>
<li><strong>必须有序（sorted），但不强制升序或降序。</strong></li>
<li><strong>只要两个输入区间是按照相同的排序规则（比如都是升序、或者都是降序）排好的，就可以正常使用。</strong></li>
</ul>
<p>两个集合 <strong>必须为有序集合</strong>，所以下面演示代码使用了排序。<code>vector</code> 容器可以替换成 <code>set</code> 容器，因为 <code>set</code> 自动会对元素进行排序。函数的参数有五个，前两个为第一个容器的首尾迭代器，第三四个为第二个容器的首尾迭代器，最后一个为插入位置，即将结果插入到哪个地址之后。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span>		<span class="comment">// 头文件</span></span></span><br><span class="line"><span class="built_in">set_union</span>(起始迭代器<span class="number">1</span>, 结束迭代器<span class="number">1</span>, 起始迭代器<span class="number">2</span>, 结束迭代器<span class="number">2</span>, 输出迭代器);</span><br><span class="line"><span class="built_in">set_intersection</span>(起始迭代器<span class="number">1</span>, 结束迭代器<span class="number">1</span>, 起始迭代器<span class="number">2</span>, 结束迭代器<span class="number">2</span>, 输出迭代器);</span><br><span class="line"><span class="built_in">set_difference</span>(起始迭代器<span class="number">1</span>, 结束迭代器<span class="number">1</span>, 起始迭代器<span class="number">2</span>, 结束迭代器<span class="number">2</span>, 输出迭代器);</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">8</span>&#125;, b = &#123;<span class="number">5</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="built_in">sort</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>()); <span class="comment">// 1 2 4 5 8</span></span><br><span class="line"><span class="built_in">sort</span>(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>()); <span class="comment">// 2 3 5 8 9</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; c, d, e;</span><br><span class="line"><span class="comment">// a 并 b：1 2 3 4 5 8 9</span></span><br><span class="line"><span class="built_in">set_union</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>(), <span class="built_in">inserter</span>(c, c.<span class="built_in">begin</span>()));</span><br><span class="line"><span class="comment">// a 交 b：2 5 8</span></span><br><span class="line"><span class="built_in">set_intersection</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>(), <span class="built_in">inserter</span>(d, d.<span class="built_in">begin</span>()));</span><br><span class="line"><span class="comment">// a 差 b： 1 4</span></span><br><span class="line"><span class="built_in">set_difference</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>(), <span class="built_in">inserter</span>(e, e.<span class="built_in">begin</span>()));</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span>                    <span class="comment">// 包含 set_union、set_intersection、set_difference</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span> &#125;;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; b = &#123; <span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span> &#125;;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">Intersection</span><span class="params">(<span class="number">10</span>)</span></span>;       <span class="comment">// 交集，预留足够空间</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">Union</span><span class="params">(<span class="number">10</span>)</span></span>;              <span class="comment">// 并集，预留足够空间</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">Difference</span><span class="params">(<span class="number">10</span>)</span></span>;         <span class="comment">// 差集，预留足够空间</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 求交集</span></span><br><span class="line">    <span class="keyword">auto</span> it1 = <span class="built_in">set_intersection</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>(), Intersection.<span class="built_in">begin</span>());</span><br><span class="line">    Intersection.<span class="built_in">resize</span>(it1 - Intersection.<span class="built_in">begin</span>());    <span class="comment">// 调整交集实际大小</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 求并集</span></span><br><span class="line">    <span class="keyword">auto</span> it2 = <span class="built_in">set_union</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>(), Union.<span class="built_in">begin</span>());</span><br><span class="line">    Union.<span class="built_in">resize</span>(it2 - Union.<span class="built_in">begin</span>());                  <span class="comment">// 调整并集实际大小</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 求差集</span></span><br><span class="line">    <span class="keyword">auto</span> it3 = <span class="built_in">set_difference</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>(), Difference.<span class="built_in">begin</span>());</span><br><span class="line">    Difference.<span class="built_in">resize</span>(it3 - Difference.<span class="built_in">begin</span>());        <span class="comment">// 调整差集实际大小</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出交集</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : Intersection)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">// 输出交集元素 3</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出并集</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : Union)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">// 输出并集元素 1 2 3 5 6</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出差集</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : Difference)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">// 输出差集元素 1 5</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="back-inserter"><a href="#back-inserter" class="headerlink" title="back_inserter"></a>back_inserter</h4><p><code>back_inserter(容器名)</code> 是一个 <strong>生成输出迭代器的小工具</strong>，帮你 <strong>自动在容器尾部插入元素</strong>。<strong>平常如果不用 back_inserter，你需要预先分配好大空间，还要 resize，很麻烦。</strong> 而用 <code>back_inserter</code> 就可以：</p>
<ul>
<li>不需要提前开空间！</li>
<li>自动 <code>push_back</code> 加元素！</li>
</ul>
<p><strong>1. 传统写法（需要开大空间）</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">result</span><span class="params">(<span class="number">100</span>)</span></span>;  <span class="comment">// 必须提前开好足够空间</span></span><br><span class="line"><span class="keyword">auto</span> it = <span class="built_in">set_union</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>(), result.<span class="built_in">begin</span>());</span><br><span class="line">result.<span class="built_in">resize</span>(it - result.<span class="built_in">begin</span>());  <span class="comment">// 最后再调整大小</span></span><br></pre></td></tr></table></figure>

<p><strong>2. 使用 back_inserter（最推荐）</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; result;  <span class="comment">// 不需要开空间，空的就行</span></span><br><span class="line"><span class="built_in">set_union</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>(), <span class="built_in">back_inserter</span>(result));</span><br><span class="line"><span class="comment">// 不需要 resize，直接用 result 即可</span></span><br></pre></td></tr></table></figure>

<p>看到了吗？<code>back_inserter</code> 自动帮你扩容，<strong>代码更简洁、安全，强烈推荐使用！</strong></p>
<h2 id="isdigit、isalpha-——-判断是否是数字-字符"><a href="#isdigit、isalpha-——-判断是否是数字-字符" class="headerlink" title="isdigit、isalpha —— 判断是否是数字&#x2F;字符"></a>isdigit、isalpha —— 判断是否是数字&#x2F;字符</h2><blockquote>
<p>处于标准库函数（头文件 <code>&lt;cctype&gt;</code>）。正常来说下面前 4 个是较为常用的，记不住也没关系，大多数情况也还是手动实现的</p>
</blockquote>
<table>
<thead>
<tr>
<th>函数名</th>
<th>作用</th>
<th>示例输入</th>
<th>示例输出</th>
</tr>
</thead>
<tbody><tr>
<td><strong><code>isdigit(c)</code></strong></td>
<td><strong>判断是否为数字（0~9）</strong></td>
<td><code>&#39;5&#39;</code></td>
<td><code>true</code></td>
</tr>
<tr>
<td><strong><code>isalpha(c)</code></strong></td>
<td><strong>判断是否为字母（A-Z 或 a-z）</strong></td>
<td><code>&#39;a&#39;</code> &#x2F; <code>&#39;Z&#39;</code></td>
<td><code>true</code></td>
</tr>
<tr>
<td><strong><code>islower(c)</code></strong></td>
<td><strong>判断是否为小写字母</strong></td>
<td><code>&#39;g&#39;</code></td>
<td><code>true</code></td>
</tr>
<tr>
<td><strong><code>isupper(c)</code></strong></td>
<td><strong>判断是否为大写字母</strong></td>
<td><code>&#39;G&#39;</code></td>
<td><code>true</code></td>
</tr>
<tr>
<td><code>isalnum(c)</code></td>
<td>判断是否为字母或数字</td>
<td><code>&#39;a&#39;</code>, <code>&#39;9&#39;</code></td>
<td><code>true</code></td>
</tr>
<tr>
<td><code>isspace(c)</code></td>
<td>判断是否为空白字符（空格、\t、\n）</td>
<td><code>&#39; &#39;</code></td>
<td><code>true</code></td>
</tr>
<tr>
<td><code>isxdigit(c)</code></td>
<td>判断是否为十六进制数字（0 <del>9, A</del> F, a~f）</td>
<td><code>&#39;F&#39;</code></td>
<td><code>true</code></td>
</tr>
<tr>
<td><code>isprint(c)</code></td>
<td>判断是否为可打印字符</td>
<td><code>&#39;!&#39;</code></td>
<td><code>true</code></td>
</tr>
<tr>
<td><code>ispunct(c)</code></td>
<td>判断是否为标点符号</td>
<td><code>&#39;!&#39;</code>, <code>&#39;,&#39;</code></td>
<td><code>true</code></td>
</tr>
<tr>
<td><code>isgraph(c)</code></td>
<td>是否为可见字符（不含空格）</td>
<td><code>&#39;A&#39;</code>, <code>&#39;%&#39;</code></td>
<td><code>true</code></td>
</tr>
</tbody></table>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">my_isdigit</span><span class="params">(<span class="type">char</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>;            <span class="comment">// 判断是否为数字字符（ASCII: 48~57）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">my_isalpha</span><span class="params">(<span class="type">char</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (c &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;z&#x27;</span>) || (c &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;Z&#x27;</span>);    <span class="comment">// 判断是否为字母（大写或小写，ASCII: a~z: 97~122, A~Z: 65~90）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">my_islower</span><span class="params">(<span class="type">char</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;z&#x27;</span>;            <span class="comment">// 判断是否为小写字母</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">my_isupper</span><span class="params">(<span class="type">char</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;Z&#x27;</span>;            <span class="comment">// 判断是否为大写字母</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="gcd-——-最大公约数，lcm-——-最小公倍数"><a href="#gcd-——-最大公约数，lcm-——-最小公倍数" class="headerlink" title="gcd —— 最大公约数，lcm —— 最小公倍数"></a>gcd —— 最大公约数，lcm —— 最小公倍数</h2><table>
<thead>
<tr>
<th>名称</th>
<th>所属</th>
<th>是否标准</th>
<th>头文件</th>
<th>支持类型</th>
<th>特点说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>std::gcd</code></td>
<td>C++17 标准库</td>
<td>✅ 是</td>
<td><code>&lt;numeric&gt;</code></td>
<td><code>int</code>、<code>long long</code> 等整数</td>
<td>类型安全，支持 <code>constexpr</code>，推荐使用于现代 C++</td>
</tr>
<tr>
<td><code>std::lcm</code></td>
<td>C++17 标准库</td>
<td>✅ 是</td>
<td><code>&lt;numeric&gt;</code></td>
<td><code>int</code>、<code>long long</code> 等整数</td>
<td>求最小公倍数，现代推荐方式</td>
</tr>
<tr>
<td><code>__gcd</code></td>
<td>GNU 扩展</td>
<td>❌ 否</td>
<td><code>&lt;algorithm&gt;</code></td>
<td>原始定义只明确支持 <code>int</code> 类型，后续做了处理，可以接受 <code>long</code>、<code>long long</code> 等整型参数，但仍有部分编译器不支持！</td>
<td>GCC 特有，非标准函数，竞赛中常用</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>C++17 引入，头文件：<code>#include &lt;numeric&gt; </code></strong></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">24</span>, b = <span class="number">12</span>;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">gcd</span>(a, b) &lt;&lt; endl;		<span class="comment">// 输出 12</span></span><br><span class="line">	cout &lt;&lt; <span class="built_in">lcm</span>(a, b) &lt;&lt; endl;		<span class="comment">// 输出 24</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">如果环境不支持，可以手动实现其两者功能：</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b == <span class="number">0</span> ? a : <span class="built_in">gcd</span>(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lcm</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a * b) / <span class="built_in">gcd</span>(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="gcd-——-最大公约数"><a href="#gcd-——-最大公约数" class="headerlink" title="__gcd —— 最大公约数"></a>__gcd —— 最大公约数</h3><blockquote>
<p>求 a 和 b 的最大公约数，使用时要包含 <code>&lt;algorithm&gt;</code> 头文件。准确的来说它是一个 <code>GNU</code> 扩展，不属于 <code>STL</code>。</p>
</blockquote>
<p><code>__gcd(12,15) = 3</code></p>
<p><code>__gcd(21,0) = 21</code></p>
<h2 id="lg"><a href="#lg" class="headerlink" title="__lg"></a>__lg</h2><blockquote>
<ol>
<li>求一个数二进制下最高位位于第几位（从 <strong>第 0 位</strong> 开始）（或二进制数下有几位）</li>
<li><code>__lg(x)</code> 相当于返回 $log_2 x$</li>
<li>复杂度 O(1)</li>
</ol>
</blockquote>
<p><code>__lg(8) = 3</code></p>
<p><code>__lg(15) = 3</code></p>
<h2 id="accumulate-——-序列求和"><a href="#accumulate-——-序列求和" class="headerlink" title="accumulate —— 序列求和"></a>accumulate —— 序列求和</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">accumulate</span>(beg, end, init)</span><br></pre></td></tr></table></figure>

<p><strong>复杂度：</strong> O(N)</p>
<blockquote>
<p>作用：对一个序列的元素求和</p>
</blockquote>
<p><code>init</code> 为对序列元素求和的 <strong>初始值</strong></p>
<p>返回值类型：与 <code>init</code> 相同</p>
<ul>
<li><strong>基础累加求和：</strong></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[]=&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">10</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对 [0,2] 区间求和，初始值为 0，结果为 0 + 1 + 3 + 5 = 9</span></span><br><span class="line"><span class="type">int</span> res1 = <span class="built_in">accumulate</span>(a, a + <span class="number">3</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//对 [0,3] 区间求和，初始值为 5，结果为 5 + 1 + 3 + 5 + 9 = 23</span></span><br><span class="line"><span class="type">int</span> res2 = <span class="built_in">accumulate</span>(a, a + <span class="number">4</span>, <span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>自定义二元对象求和：</strong></li>
</ul>
<p>使用 <code>lambda</code> 表达式</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    ll num;</span><br><span class="line">&#125; st[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">	st[i].num = i + <span class="number">10000000000</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回值类型与 init 一致，同时注意参数类型（a）也要一样</span></span><br><span class="line"><span class="comment">//初始值为 1，累加 1+10000000001+10000000002+10000000003 = 30000000007</span></span><br><span class="line">ll res = <span class="built_in">accumulate</span>(st + <span class="number">1</span>, st + <span class="number">4</span>, <span class="number">1ll</span>, [](ll a,node b) &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b.num;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="ceil-——-向上取整"><a href="#ceil-——-向上取整" class="headerlink" title="ceil —— 向上取整"></a><code>ceil</code> —— 向上取整</h2><blockquote>
<p>头文件：<code>&lt;cmath&gt;</code>&#x2F;<code>&lt;math.h&gt;</code>。</p>
<p><code>ceil</code> 函数的功能是返回不小于给定参数 <code>x</code> 的最小整数，也就是我们所说的 <strong>向上取整</strong>。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">ceil</span><span class="params">(<span class="type">double</span> x)</span></span>;</span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">ceil</span><span class="params">(<span class="type">float</span> x)</span></span>;                    <span class="comment">// C++ 中新增的重载版本</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">double</span> <span class="title">ceil</span><span class="params">(<span class="type">long</span> <span class="type">double</span> x)</span></span>;        <span class="comment">// C++ 中新增的重载版本</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span>                        <span class="comment">// 包含了 ceil 函数的头文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">ceil</span>(a) &lt;&lt; endl;            <span class="comment">// 输出 1</span></span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> b = <span class="number">2.5</span>;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">ceil</span>(b) &lt;&lt; endl;            <span class="comment">// 输出 3</span></span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> c = <span class="number">-2.4</span>;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">ceil</span>(c) &lt;&lt; endl;            <span class="comment">// 输出 -2</span></span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="type">double</span> d = <span class="number">3.1415926</span>;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">ceil</span>(d) &lt;&lt; endl;            <span class="comment">// 输出 4</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="fill"><a href="#fill" class="headerlink" title="fill"></a>fill</h2><p><strong>复杂度：</strong> O(N)</p>
<blockquote>
<p>对一个序列进行初始化赋值</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对 a 数组的所有元素赋 1</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">5</span>];</span><br><span class="line"><span class="built_in">fill</span>(a, a + <span class="number">5</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1 1 1 1 1</span></span><br></pre></td></tr></table></figure>

<p><strong>注意区分 memset：<code>void *memset(需要填充内存的指针，填充的值，字节数);</code></strong>，<code>memset()</code> 是按 <strong>字节</strong> 进行赋值，对于初始化赋 <code>0</code> 或 <code>-1</code> 有比较好的效果。</p>
<p>如果赋某个特定的数会 <strong>出错</strong>，赋值特定的数建议使用 <code>fill()</code>。</p>
<h2 id="next-permutation"><a href="#next-permutation" class="headerlink" title="next_permutation"></a>next_permutation</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">next_permutation</span>(beg, end)</span><br></pre></td></tr></table></figure>

<p><strong>时间复杂度：</strong> O(N)</p>
<blockquote>
<p>求序列的下一个排列，下一个排列是字典序大一号的排列</p>
</blockquote>
<p>返回 <code>true</code> 或 <code>false</code></p>
<ul>
<li><p><code>next_permutation(beg, end)</code></p>
<p>  如果是最后一个排列，返回 <code>false</code>, 否则求出下一个序列后，返回 <code>true</code></p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对 a 序列进行重排</span></span><br><span class="line"><span class="built_in">next_permutation</span>(a, a + n);</span><br></pre></td></tr></table></figure>

<p><strong>应用：求所有的排列</strong></p>
<p>输出 <code>a</code> 的所有排列</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组 a 不一定是最小字典序序列，一定注意将它排序</span></span><br><span class="line"><span class="built_in">sort</span>(a, a + n);</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line"> 	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"> 	&#123;</span><br><span class="line"> 		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i]);</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="built_in">next_permutation</span>(a, a + n));</span><br></pre></td></tr></table></figure>

<ul>
<li><code>prev_permutation(beg, end)</code></li>
</ul>
<blockquote>
<p>求出前一个排列，如果序列为最小的排列，将其重排为最大的排列，返回 false。</p>
</blockquote>
<h2 id="random-shuffle"><a href="#random-shuffle" class="headerlink" title="random_shuffle"></a>random_shuffle</h2><p><strong>复杂度：</strong> O(N)</p>
<blockquote>
<ol>
<li>随机打乱序列的顺序</li>
<li><code>random_shuffle</code> 在 <code>C++14</code> 中被弃用，在 <code>C++17</code> 中被废除，C++11 之后应尽量使用 <code>shuffle</code> 来代替。</li>
</ol>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">b</span><span class="params">(n)</span></span>;</span><br><span class="line"><span class="built_in">iota</span>(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>(), <span class="number">1</span>);<span class="comment">// 序列 b 递增赋值 1, 2, 3, 4,...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对 a 数组随机重排</span></span><br><span class="line"><span class="built_in">random_shuffle</span>(a, a + n);</span><br><span class="line"></span><br><span class="line"><span class="comment">// C++11 之后尽量使用 shuffle</span></span><br><span class="line"><span class="built_in">shuffle</span>(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure>

<h2 id="transform"><a href="#transform" class="headerlink" title="transform"></a>transform</h2><p><strong>复杂度：</strong> O(N)</p>
<blockquote>
<p>作用：使用给定操作，将结果写到 dest 中</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原型：</span></span><br><span class="line"><span class="built_in">transform</span>(beg, end, dest, unaryOp);</span><br></pre></td></tr></table></figure>

<p>一般不怎么使用，徒增记忆负担，不如手动实现。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将序列开始地址 beg 到结束地址 end 大小写转换，把结果存到起始地址为 dest 的序列中</span></span><br><span class="line"><span class="built_in">transform</span>(beg, end, dest, ::tolower);</span><br><span class="line"><span class="built_in">transform</span>(beg, end, dest, ::toupper);</span><br></pre></td></tr></table></figure>

<h2 id="unique"><a href="#unique" class="headerlink" title="unique"></a>unique</h2><p><strong>复杂度：</strong> O(N)</p>
<blockquote>
<p>消除重复元素，返回消除完重复元素的下一个位置的地址</p>
<p>如：<code>a[] = &#123;1, 3, 2, 3, 6&#125;</code>;</p>
<p><code>unique</code> 之后 <code>a</code> 数组为 <code>&#123;1, 2, 3, 6, 3&#125;</code> 前面为无重复元素的数组，后面则是重复元素移到后面，返回 <code>a[4]</code> 位置的地址（不重复元素的尾后地址）</p>
</blockquote>
<p>消除重复元素一般需要原序列是 <strong>有序序列</strong></p>
<p><strong>应用：离散化</strong></p>
<ul>
<li>方法一：利用数组离散化</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    cin &gt;&gt; a[i];</span><br><span class="line">    b[i] = a[i];                    <span class="comment">//将 a 数组复制到 b 数组</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 排序后 b：&#123;1, 2, 3, 3, 6&#125;</span></span><br><span class="line"><span class="built_in">sort</span>(b, b + n);                     <span class="comment">//对 b 数组排序</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 消除重复元素 b：&#123;1, 2, 3, 6, 3&#125; 返回的地址为最后一个元素 3 的地址 </span></span><br><span class="line"><span class="type">int</span> len = <span class="built_in">unique</span>(b, b + n) - b;     <span class="comment">//消除 b 的重复元素，并获取长度</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//因为 b 有序，查找到的下标就是对应的 相对大小（离散化后的值）</span></span><br><span class="line">    <span class="type">int</span> pos = <span class="built_in">lower_bound</span>(b, b + len, a[i]) - b;        <span class="comment">//在 b 数组中二分查找第一个大于等于 a [i] 的下标</span></span><br><span class="line">    a[i] = pos;                     <span class="comment">// 离散化赋值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>方法二：利用 <code>vector</code> 进行离散化</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    cin &gt;&gt; a[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; b = a;</span><br><span class="line"><span class="built_in">sort</span>(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>());</span><br><span class="line">b.<span class="built_in">erase</span>(<span class="built_in">unique</span>(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>()), b.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">	a[i] = <span class="built_in">lower_bound</span>(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>(), a[i]) - b.<span class="built_in">begin</span>() + <span class="number">1</span>; 	<span class="comment">// 离散后的数据从 1 开始   </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="builtin-内置位运算函数"><a href="#builtin-内置位运算函数" class="headerlink" title="__builtin_ 内置位运算函数"></a><code>__builtin_</code> 内置位运算函数</h2><blockquote>
<p>需要注意：内置函数有相应的 <code>unsigned lnt</code> 和 <code>unsigned long long</code> 版本，<code>unsigned long long</code> 只需要在函数名后面加上 <code>ll</code> 就可以了，比如 <code>__builtin_clzll(x)</code> ，默认是 32 位 <code>unsigned int</code></p>
<p>很多题目和 <code>long long</code> 数据类型有关，如有需要注意添加 <code>ll</code></p>
</blockquote>
<ul>
<li><code>__builtin_ffs</code></li>
</ul>
<blockquote>
<p>二进制中对应最后一位 <code>1</code> 的位数，比如 <code>4</code> 会返回 <code>3</code>（100）</p>
</blockquote>
<ul>
<li><code>__builtin_popcount</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__builtin_popcount(x)</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>x</code> 中 <code>1</code> 的个数</p>
</blockquote>
<ul>
<li><code>__builtin_ctz</code></li>
</ul>
<blockquote>
<p><code>x</code> 末尾 <code>0</code> 的个数（<code>count tail zero</code>）</p>
</blockquote>
<ul>
<li><code>__builtin_clz</code></li>
</ul>
<blockquote>
<p><code>x</code> 前导 <code>0</code> 的个数（<code>count leading zero</code>）</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; __builtin_clz(<span class="number">32</span>); <span class="comment">// 26</span></span><br><span class="line"><span class="comment">//因为共有 6 位, 默认数据范围为 32 位，32 - 6 = 26</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>__builtin_parity</code></li>
</ul>
<blockquote>
<p><code>x</code> 中 1 的个数的奇偶性， 奇数输出 <code>1</code>，偶数输出 <code>0</code></p>
</blockquote>
<h2 id="C-20-ranges"><a href="#C-20-ranges" class="headerlink" title="C++20 ranges"></a>C++20 ranges</h2><p>ranges 主要用来简化迭代器操作，可以少写很多迭代器操作相关的代码。<br>ranges 集成了很多 STL 函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ranges::<span class="built_in">sort</span>(a); 						<span class="comment">// sort(a.begin(), a.end());</span></span><br><span class="line">ranges::<span class="built_in">sort</span>(a, <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;()); 		 <span class="comment">// sort(a.begin(), a.end(), greater &lt;int&gt;());</span></span><br><span class="line"><span class="type">int</span> mx = *ranges::<span class="built_in">max_element</span>(a);</span><br><span class="line"><span class="type">int</span> mn = *ranges::<span class="built_in">min_element</span>(a);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可参考链接：</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/blog/AccRobin/grammar-candies">C++语法糖</a> <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/blog/AccRobin/grammar-candies">https://www.luogu.com.cn/blog/AccRobin/grammar-candies</a></li>
</ol>
</blockquote>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://github.com/huangcancan-xbc/Drawing-bed/blob/master/Blog/20250307201719879.png?raw=true" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://github.com/huangcancan-xbc/Drawing-bed/blob/master/Blog/20250307201719879.png?raw=true" title="头像" alt="头像"></a><div class="post-copyright__author_name">小米里的大麦</div><div class="post-copyright__author_desc"></div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="https://www.minbit.top/posts/123456.html">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('https://www.minbit.top/posts/123456.html')">C++ STL —— 基于算法竞赛</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="赞赏作者"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><div class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Blog/20250403212543768.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Blog/20250403212543768.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Blog/20250403212622868.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Blog/20250403212622868.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul><a class="reward-main-btn" href="/about/#about-reward" target="_blank"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display: none"></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="https://www.minbit.top/posts/123456.html"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=C++ STL —— 基于算法竞赛&amp;url=https://www.minbit.top/posts/123456.html&amp;pic=https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Blog/20250314131841400.png?_r_=54019171-75ec-fa78-24a5-3398f8f320b1" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">MIT</a> 许可协议。转载请注明来自 <a href="https://www.minbit.top" target="_blank">小米里的大麦</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/C/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>C++<span class="tagsPageCount">6</span></a><a class="post-meta__box__tags" href="/tags/STL/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>STL<span class="tagsPageCount">1</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Blog/20250314130519403.jpg?_r_=dd1b4545-db9e-3f4d-206c-e61824f0120e" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/55028.html"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Blog/20250817000335747.png?_r_=a4dfe937-45e0-d528-1326-482f90dc6e07" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">网站搭建</div></div></a></div><div class="next-post pull-right"><a href="/posts/57061.html"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Blog/20250817000335747.png?_r_=ff721f3c-5222-5373-39cf-521cad107344" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">“一周年”，我的成长蜕变与收获</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size: 1.5rem; margin-right: 4px"></i><span>喜欢这篇文章的人也看了</span></div><div class="relatedPosts-list"><div><a href="/posts/24103.html" title="02 类与对象（上）"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Blog/20250314141714221.png?_r_=7c4938b3-e451-22ac-a01c-9836565ea937" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-02-01</div><div class="title">02 类与对象（上）</div></div></a></div><div><a href="/posts/38295.html" title="05 C&#x2F;C++内存管理"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Blog/20250314125923408.png?_r_=9251e47f-0f82-6013-b086-266efbf2d438" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-02-22</div><div class="title">05 C&#x2F;C++内存管理</div></div></a></div><div><a href="/posts/30432.html" title="03 类与对象（中）"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Blog/20250314140243649.png?_r_=bef22af1-a068-445b-72f1-1dccd007eed3" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-02-02</div><div class="title">03 类与对象（中）</div></div></a></div><div><a href="/posts/10381.html" title="04 类与对象（下）"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Blog/20250314125732989.png?_r_=2c418a91-bc52-ae82-9c00-37a566f54e1b" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-02-03</div><div class="title">04 类与对象（下）</div></div></a></div><div><a href="/posts/53002.html" title="06 模板初阶"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Blog/20250314141714221.png?_r_=19b11c0c-ea21-c227-7d95-2af400b06626" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-02-25</div><div class="title">06 模板初阶</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="anzhiyufont anzhiyu-icon-comments"></i><span> 评论</span></div><div class="comment-randomInfo"><a onclick="anzhiyu.addRandomCommentInfo()" href="javascript:void(0)">匿名评论</a><a href="/privacy" style="margin-left: 4px">隐私政策</a></div><div class="comment-tips" id="comment-tips"><span>✅ 你无需删除空行，直接评论以获取最佳展示效果</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div><div class="comment-barrage"></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info__sayhi" id="author-info__sayhi" onclick="anzhiyu.changeSayHelloText()"></div><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://github.com/huangcancan-xbc/Drawing-bed/blob/master/Blog/20250307201719879.png?raw=true" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-status"><img class="g-status" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/08/24/64e6ce9c507bb.png" alt="status"/></div></div><div class="author-info__description">时间好像总会留下点什么,或许是一个人,或许是一个梦,或许……是一段有意义的经历~</div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/"><h1 class="author-info__name">小米里的大麦</h1><div class="author-info__desc"></div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/huangcancan-xbc" target="_blank" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a></div></div></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bullhorn anzhiyu-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来看我的博客鸭~<br></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8E%9F%E4%BD%9C%E8%80%85%E5%9C%A8%E8%BF%99%E9%87%8C%EF%BC%81%E6%9C%AC%E6%96%87%E6%98%AF%E5%9F%BA%E4%BA%8E%E8%A1%8C%E7%A0%81%E6%A3%8B%E7%9A%84%E6%96%87%E7%AB%A0%E8%BF%9B%E8%A1%8C%E7%9A%84%E7%BF%BB%E6%94%B9%EF%BC%81"><span class="toc-number">1.</span> <span class="toc-text">原作者在这里！本文是基于行码棋的文章进行的翻改！</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-vector"><span class="toc-number">1.1.</span> <span class="toc-text">1 vector</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.2.</span> <span class="toc-text">1.1 介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-1-%E7%AE%80%E4%BB%8B"><span class="toc-number">1.2.1.</span> <span class="toc-text">1.1.1 简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-2-%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.2.2.</span> <span class="toc-text">1.1.2 初始化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E6%96%B9%E6%B3%95%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.</span> <span class="toc-text">1.2 方法函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-1-%E5%87%BD%E6%95%B0%E6%80%BB%E7%BB%93"><span class="toc-number">1.3.1.</span> <span class="toc-text">1.2.1 函数总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-2-%E6%B3%A8%E6%84%8F%E6%83%85%E5%86%B5"><span class="toc-number">1.3.2.</span> <span class="toc-text">1.2.2 注意情况</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-%E5%85%83%E7%B4%A0%E8%AE%BF%E9%97%AE"><span class="toc-number">1.4.</span> <span class="toc-text">1.3 元素访问</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-1-%E4%B8%8B%E6%A0%87%E8%AE%BF%E9%97%AE"><span class="toc-number">1.4.1.</span> <span class="toc-text">1.3.1 下标访问</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-2-%E8%BF%AD%E4%BB%A3%E5%99%A8%E8%AE%BF%E9%97%AE"><span class="toc-number">1.4.2.</span> <span class="toc-text">1.3.2 迭代器访问</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-3-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-number">1.4.3.</span> <span class="toc-text">1.3.3 智能指针</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-stack"><span class="toc-number">1.5.</span> <span class="toc-text">2 stack</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.6.</span> <span class="toc-text">2.1 介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E6%96%B9%E6%B3%95%E5%87%BD%E6%95%B0"><span class="toc-number">1.7.</span> <span class="toc-text">2.2 方法函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E6%A0%88%E5%85%83%E7%B4%A0%E8%AE%BF%E9%97%AE"><span class="toc-number">1.8.</span> <span class="toc-text">2.3 栈元素访问</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-1-%E6%A0%88%E9%81%8D%E5%8E%86"><span class="toc-number">1.8.1.</span> <span class="toc-text">2.3.1 栈遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-2-%E6%95%B0%E7%BB%84%E6%A8%A1%E6%8B%9F%E6%A0%88%E8%BF%9B%E8%A1%8C%E9%81%8D%E5%8E%86"><span class="toc-number">1.8.2.</span> <span class="toc-text">2.3.2 数组模拟栈进行遍历</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-queue"><span class="toc-number">1.9.</span> <span class="toc-text">3 queue</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.10.</span> <span class="toc-text">3.1 介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E6%96%B9%E6%B3%95%E5%87%BD%E6%95%B0"><span class="toc-number">1.11.</span> <span class="toc-text">3.2 方法函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-%E9%98%9F%E5%88%97%E6%A8%A1%E6%8B%9F"><span class="toc-number">1.12.</span> <span class="toc-text">3.3 队列模拟</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-deque"><span class="toc-number">1.13.</span> <span class="toc-text">4 deque</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.14.</span> <span class="toc-text">4.1 介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-%E6%96%B9%E6%B3%95%E5%87%BD%E6%95%B0"><span class="toc-number">1.15.</span> <span class="toc-text">4.2 方法函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-%E6%B3%A8%E6%84%8F%E7%82%B9"><span class="toc-number">1.16.</span> <span class="toc-text">4.3 注意点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-priority-queue"><span class="toc-number">1.17.</span> <span class="toc-text">5 priority_queue</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.18.</span> <span class="toc-text">5.1 介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-%E5%87%BD%E6%95%B0%E6%96%B9%E6%B3%95"><span class="toc-number">1.19.</span> <span class="toc-text">5.2 函数方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-%E8%AE%BE%E7%BD%AE%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">1.20.</span> <span class="toc-text">5.3 设置优先级</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-1-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">1.20.1.</span> <span class="toc-text">5.3.1 基本数据类型的优先级</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-2-%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E7%BB%93%E6%9E%84%E4%BD%93-%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">1.20.2.</span> <span class="toc-text">5.3.2 高级数据类型(结构体)优先级</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4-%E5%AD%98%E5%82%A8%E7%89%B9%E6%AE%8A%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">1.21.</span> <span class="toc-text">5.4 存储特殊类型的优先级</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-1-%E5%AD%98%E5%82%A8-pair-%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.21.1.</span> <span class="toc-text">5.4.1 存储 pair 类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-map"><span class="toc-number">1.22.</span> <span class="toc-text">6 map</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.23.</span> <span class="toc-text">6.1 介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-1-%E7%AE%80%E4%BB%8B"><span class="toc-number">1.23.1.</span> <span class="toc-text">6.1.1 简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-2-%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.23.2.</span> <span class="toc-text">6.1.2 初始化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-%E5%87%BD%E6%95%B0%E6%96%B9%E6%B3%95"><span class="toc-number">1.24.</span> <span class="toc-text">6.2 函数方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-1-%E5%87%BD%E6%95%B0%E6%96%B9%E6%B3%95"><span class="toc-number">1.24.1.</span> <span class="toc-text">6.2.1 函数方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-2-%E6%B3%A8%E6%84%8F%E6%83%85%E5%86%B5"><span class="toc-number">1.24.2.</span> <span class="toc-text">6.2.2 注意情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-3-%E8%BF%AD%E4%BB%A3%E5%99%A8%E8%BF%9B%E8%A1%8C%E6%AD%A3%E5%8F%8D%E5%90%91%E9%81%8D%E5%8E%86"><span class="toc-number">1.24.3.</span> <span class="toc-text">6.2.3 迭代器进行正反向遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-4-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="toc-number">1.24.4.</span> <span class="toc-text">6.2.4 二分查找</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3-%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0"><span class="toc-number">1.25.</span> <span class="toc-text">6.3 添加元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-4-%E8%AE%BF%E9%97%AE%E5%85%83%E7%B4%A0"><span class="toc-number">1.26.</span> <span class="toc-text">6.4 访问元素</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-1-%E4%B8%8B%E6%A0%87%E8%AE%BF%E9%97%AE"><span class="toc-number">1.26.1.</span> <span class="toc-text">6.4.1 下标访问</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-2-%E9%81%8D%E5%8E%86%E8%AE%BF%E9%97%AE"><span class="toc-number">1.26.2.</span> <span class="toc-text">6.4.2 遍历访问</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-5-%E4%B8%8E-unordered-map-%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">1.27.</span> <span class="toc-text">6.5 与 unordered_map 的比较</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5-1-%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">1.27.1.</span> <span class="toc-text">6.5.1 内部实现原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5-2-%E6%95%88%E7%8E%87%E6%AF%94%E8%BE%83"><span class="toc-number">1.27.2.</span> <span class="toc-text">6.5.2 效率比较</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-5-3-%E8%87%AA%E5%AE%9A%E4%B9%89-hash-%E5%87%BD%E6%95%B0"><span class="toc-number">1.28.</span> <span class="toc-text">6.5.3 自定义 hash 函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-set"><span class="toc-number">1.29.</span> <span class="toc-text">7 set</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1-%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.30.</span> <span class="toc-text">7.1 介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2-%E5%87%BD%E6%95%B0%E6%96%B9%E6%B3%95"><span class="toc-number">1.31.</span> <span class="toc-text">7.2 函数方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-3-%E5%85%83%E7%B4%A0%E8%AE%BF%E9%97%AE"><span class="toc-number">1.32.</span> <span class="toc-text">7.3 元素访问</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-4-%E9%87%8D%E8%BD%BD-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.33.</span> <span class="toc-text">7.4 重载 &lt; 运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-5-multiset"><span class="toc-number">1.34.</span> <span class="toc-text">7.5 multiset</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-pair"><span class="toc-number">1.35.</span> <span class="toc-text">8 pair</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-1-%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.36.</span> <span class="toc-text">8.1 介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-2-%E8%AE%BF%E9%97%AE"><span class="toc-number">1.37.</span> <span class="toc-text">8.2 访问</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-string"><span class="toc-number">1.38.</span> <span class="toc-text">9 string</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-1-%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.39.</span> <span class="toc-text">9.1 介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-2-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8F%8A%E5%AE%9A%E4%B9%89"><span class="toc-number">1.40.</span> <span class="toc-text">9.2 初始化及定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-3-string-%E7%89%B9%E6%80%A7"><span class="toc-number">1.41.</span> <span class="toc-text">9.3 string 特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-4-%E8%AF%BB%E5%85%A5%E8%AF%A6%E8%A7%A3"><span class="toc-number">1.42.</span> <span class="toc-text">9.4 读入详解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-5-%E5%87%BD%E6%95%B0%E6%96%B9%E6%B3%95"><span class="toc-number">1.43.</span> <span class="toc-text">9.5 函数方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-bitset"><span class="toc-number">1.44.</span> <span class="toc-text">10 bitset</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-1-%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.45.</span> <span class="toc-text">10.1 介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-2-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%AE%9A%E4%B9%89"><span class="toc-number">1.46.</span> <span class="toc-text">10.2 初始化定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-3-%E7%89%B9%E6%80%A7"><span class="toc-number">1.47.</span> <span class="toc-text">10.3 特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-4-%E6%96%B9%E6%B3%95%E5%87%BD%E6%95%B0"><span class="toc-number">1.48.</span> <span class="toc-text">10.4 方法函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-5-bitset-%E4%BC%98%E5%8C%96"><span class="toc-number">1.49.</span> <span class="toc-text">10.5 bitset 优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-array"><span class="toc-number">1.50.</span> <span class="toc-text">11 array</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-1-%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.51.</span> <span class="toc-text">11.1 介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-2-%E5%A3%B0%E6%98%8E%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.52.</span> <span class="toc-text">11.2 声明与初始化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-3-%E5%AD%98%E5%8F%96%E5%85%83%E7%B4%A0"><span class="toc-number">1.53.</span> <span class="toc-text">11.3 存取元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-4-%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">1.54.</span> <span class="toc-text">11.4 成员函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-5-%E9%83%A8%E5%88%86%E7%94%A8%E6%B3%95%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.55.</span> <span class="toc-text">11.5 部分用法示例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-tuple"><span class="toc-number">1.56.</span> <span class="toc-text">12 tuple</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-1-%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.57.</span> <span class="toc-text">12.1 介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-2-%E5%A3%B0%E6%98%8E%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.58.</span> <span class="toc-text">12.2 声明初始化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-3-%E5%85%83%E7%B4%A0%E6%93%8D%E4%BD%9C"><span class="toc-number">1.59.</span> <span class="toc-text">12.3 元素操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-4-%E5%87%BD%E6%95%B0%E6%93%8D%E4%BD%9C"><span class="toc-number">1.60.</span> <span class="toc-text">12.4 函数操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#STL-%E5%87%BD%E6%95%B0"><span class="toc-number">1.61.</span> <span class="toc-text">STL 函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sort-%E2%80%94%E2%80%94-%E6%8E%92%E5%BA%8F"><span class="toc-number">1.62.</span> <span class="toc-text">sort —— 排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#stable-sort"><span class="toc-number">1.62.1.</span> <span class="toc-text">stable_sort</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#is-sorted"><span class="toc-number">1.62.2.</span> <span class="toc-text">is_sorted</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#iota"><span class="toc-number">1.62.3.</span> <span class="toc-text">iota</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#partial-sort"><span class="toc-number">1.62.4.</span> <span class="toc-text">partial_sort</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#max-min-%E2%80%94%E2%80%94-%E6%89%BE%E6%9C%80%E5%80%BC"><span class="toc-number">1.63.</span> <span class="toc-text">max + min —— 找最值</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#max-element-min-element"><span class="toc-number">1.63.1.</span> <span class="toc-text">max_element+min_element</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#nth-element-%E2%80%94%E2%80%94-%E5%AF%BB%E6%89%BE%E7%AC%AC-n-%E5%B0%8F%E7%9A%84%E5%80%BC"><span class="toc-number">1.63.2.</span> <span class="toc-text">nth_element —— 寻找第 n 小的值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#minmax"><span class="toc-number">1.63.3.</span> <span class="toc-text">minmax</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#minmax-element"><span class="toc-number">1.63.4.</span> <span class="toc-text">minmax_element</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#to-string-%E2%80%94%E2%80%94-%E5%B0%86%E6%95%B0%E5%AD%97%E8%BD%AC%E5%8C%96%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.64.</span> <span class="toc-text">to_string —— 将数字转化成字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lower-bound-upper-bound-%E2%80%94%E2%80%94-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="toc-number">1.65.</span> <span class="toc-text">lower_bound + upper_bound —— 二分查找</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#atoi-%E2%80%94%E2%80%94-%E5%B0%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%95%B4%E5%9E%8B"><span class="toc-number">1.66.</span> <span class="toc-text">atoi —— 将字符串转整型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#stoi-stoll-stod-%E2%80%A6-%E2%80%94%E2%80%94-%E5%B0%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%95%B4%E5%9E%8B%EF%BC%88%E6%9B%B4%E5%B8%B8%E7%94%A8%EF%BC%89"><span class="toc-number">1.67.</span> <span class="toc-text">stoi &#x2F; stoll &#x2F; stod &#x2F; … —— 将字符串转整型（更常用）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#reverse-%E2%80%94%E2%80%94-%E7%BF%BB%E8%BD%AC"><span class="toc-number">1.68.</span> <span class="toc-text">reverse —— 翻转</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#getline-istringstream-%E2%80%94%E2%80%94-%E8%AF%BB%E5%8F%96%E4%B8%80%E8%A1%8C-%E5%AF%B9%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%B5%81%E8%BF%9B%E8%A1%8C%E5%88%86%E5%89%B2"><span class="toc-number">1.69.</span> <span class="toc-text">getline + istringstream —— 读取一行&#x2F;对字符串流进行分割</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#set-union-set-intersection-set-difference-%E2%80%94%E2%80%94-%E4%BA%A4%E5%B9%B6%E5%B7%AE%E9%9B%86"><span class="toc-number">1.70.</span> <span class="toc-text">set_union, set_intersection, set_difference —— 交并差集</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#back-inserter"><span class="toc-number">1.70.0.1.</span> <span class="toc-text">back_inserter</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#isdigit%E3%80%81isalpha-%E2%80%94%E2%80%94-%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E6%98%AF%E6%95%B0%E5%AD%97-%E5%AD%97%E7%AC%A6"><span class="toc-number">1.71.</span> <span class="toc-text">isdigit、isalpha —— 判断是否是数字&#x2F;字符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#gcd-%E2%80%94%E2%80%94-%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0%EF%BC%8Clcm-%E2%80%94%E2%80%94-%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0"><span class="toc-number">1.72.</span> <span class="toc-text">gcd —— 最大公约数，lcm —— 最小公倍数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#gcd-%E2%80%94%E2%80%94-%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0"><span class="toc-number">1.72.1.</span> <span class="toc-text">__gcd —— 最大公约数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lg"><span class="toc-number">1.73.</span> <span class="toc-text">__lg</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#accumulate-%E2%80%94%E2%80%94-%E5%BA%8F%E5%88%97%E6%B1%82%E5%92%8C"><span class="toc-number">1.74.</span> <span class="toc-text">accumulate —— 序列求和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ceil-%E2%80%94%E2%80%94-%E5%90%91%E4%B8%8A%E5%8F%96%E6%95%B4"><span class="toc-number">1.75.</span> <span class="toc-text">ceil —— 向上取整</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#fill"><span class="toc-number">1.76.</span> <span class="toc-text">fill</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#next-permutation"><span class="toc-number">1.77.</span> <span class="toc-text">next_permutation</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#random-shuffle"><span class="toc-number">1.78.</span> <span class="toc-text">random_shuffle</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#transform"><span class="toc-number">1.79.</span> <span class="toc-text">transform</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#unique"><span class="toc-number">1.80.</span> <span class="toc-text">unique</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#builtin-%E5%86%85%E7%BD%AE%E4%BD%8D%E8%BF%90%E7%AE%97%E5%87%BD%E6%95%B0"><span class="toc-number">1.81.</span> <span class="toc-text">__builtin_ 内置位运算函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-20-ranges"><span class="toc-number">1.82.</span> <span class="toc-text">C++20 ranges</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/3572.html" title="Git 的使用"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Blog/20250314130519403.jpg?_r_=dd1b4545-db9e-3f4d-206c-e61824f0120e" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Git 的使用"/></a><div class="content"><a class="title" href="/posts/3572.html" title="Git 的使用">Git 的使用</a><time datetime="2025-06-11T07:50:00.000Z" title="发表于 2025-06-11 15:50:00">2025-06-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/14104.html" title="028 动静态库 —— 动态库"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.pixabay.com/photo/2016/01/19/15/05/computer-1149148_1280.jpg?_r_=a5760881-c229-716c-34db-7959b7573818" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="028 动静态库 —— 动态库"/></a><div class="content"><a class="title" href="/posts/14104.html" title="028 动静态库 —— 动态库">028 动静态库 —— 动态库</a><time datetime="2025-05-25T04:10:00.000Z" title="发表于 2025-05-25 12:10:00">2025-05-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/57061.html" title="“一周年”，我的成长蜕变与收获"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Blog/20250817000335747.png?_r_=ff721f3c-5222-5373-39cf-521cad107344" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="“一周年”，我的成长蜕变与收获"/></a><div class="content"><a class="title" href="/posts/57061.html" title="“一周年”，我的成长蜕变与收获">“一周年”，我的成长蜕变与收获</a><time datetime="2025-05-21T16:00:00.000Z" title="发表于 2025-05-22 00:00:00">2025-05-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/123456.html" title="C++ STL —— 基于算法竞赛"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Blog/20250314131841400.png?_r_=54019171-75ec-fa78-24a5-3398f8f320b1" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C++ STL —— 基于算法竞赛"/></a><div class="content"><a class="title" href="/posts/123456.html" title="C++ STL —— 基于算法竞赛">C++ STL —— 基于算法竞赛</a><time datetime="2025-05-21T16:00:00.000Z" title="发表于 2025-05-22 00:00:00">2025-05-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/55028.html" title="网站搭建"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Blog/20250817000335747.png?_r_=a4dfe937-45e0-d528-1326-482f90dc6e07" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="网站搭建"/></a><div class="content"><a class="title" href="/posts/55028.html" title="网站搭建">网站搭建</a><time datetime="2025-05-21T16:00:00.000Z" title="发表于 2025-05-22 00:00:00">2025-05-22</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div id="footer_deal"><a class="deal_link" href="mailto:hc1960074081@qq.com" title="email"><i class="anzhiyufont anzhiyu-icon-envelope"></i></a><a class="deal_link" target="_blank" rel="noopener" href="https://weibo.com/u/7913790969" title="微博"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a><img class="footer_mini_logo" title="返回顶部" alt="返回顶部" onclick="anzhiyu.scrollToDest(0, 500)" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://github.com/huangcancan-xbc/Drawing-bed/blob/master/Blog/20250307201719879.png?raw=true" size="50px"/><a class="deal_link" target="_blank" rel="noopener" href="https://github.com/huangcancan-xbc" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a><a class="deal_link" target="_blank" rel="noopener" href="https://space.bilibili.com/1918272544" title="Bilibili"><i class="anzhiyufont anzhiyu-icon-bilibili"></i></a></div></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2025 By <a class="footer-bar-link" href="/" title="小米里的大麦" target="_blank">小米里的大麦</a></div></div><div id="footer-type-tips"></div><div class="js-pjax"><script>function subtitleType () {
  fetch('https://v1.hitokoto.cn')
    .then(response => response.json())
    .then(data => {
      if (true) {
        const from = '出自 ' + data.from
        const sub = ["《左传》载曰：“太上有立德，其次有立功，其次有立言，虽久不废，此之谓不朽。”","纸上得来终觉浅，绝知此事要躬行！"]
        sub.unshift(data.hitokoto, from)
        window.typed = new Typed('#footer-type-tips', {
          strings: sub,
          startDelay: 300,
          typeSpeed: 150,
          loop: true,
          backSpeed: 50,
        })
      } else {
        document.getElementById('footer-type-tips').innerHTML = data.hitokoto
      }
    })
}

if (true) {
  if (typeof Typed === 'function') {
    subtitleType()
  } else {
    getScript('https://cdn.cbd.int/typed.js@2.1.0/dist/typed.umd.js').then(subtitleType)
  }
} else {
  subtitleType()
}
</script></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/huangcancan-xbc" title="GitHub主页">GitHub主页</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">40</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">20</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">6</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">社交</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://github.com/huangcancan-xbc" title="GitHub"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="GitHub"/><span class="back-menu-item-text">GitHub</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://gitee.com/huang-cancan-xbc" title="Gitee"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="Gitee"/><span class="back-menu-item-text">Gitee</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://space.bilibili.com/1918272544" title="哔哩哔哩"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="哔哩哔哩"/><span class="back-menu-item-text">哔哩哔哩</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">博客</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://blog.csdn.net/Huangcancan666?type=blog" title="CSDN"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="CSDN"/><span class="back-menu-item-text">CSDN</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://juejin.cn/user/3230789931118109" title="稀土掘金"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="稀土掘金"/><span class="back-menu-item-text">稀土掘金</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/charts/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 统计</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 外链</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/music/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/C/" style="font-size: 0.88rem;">C++<sup>6</sup></a><a href="/tags/Git/" style="font-size: 0.88rem;">Git<sup>3</sup></a><a href="/tags/IO/" style="font-size: 0.88rem;">IO<sup>3</sup></a><a href="/tags/Linux/" style="font-size: 0.88rem;">Linux<sup>28</sup></a><a href="/tags/OS%E5%9F%BA%E7%A1%80/" style="font-size: 0.88rem;">OS基础<sup>1</sup></a><a href="/tags/Obsidian/" style="font-size: 0.88rem;">Obsidian<sup>1</sup></a><a href="/tags/STL/" style="font-size: 0.88rem;">STL<sup>1</sup></a><a href="/tags/Shell/" style="font-size: 0.88rem;">Shell<sup>1</sup></a><a href="/tags/make-file/" style="font-size: 0.88rem;">make file<sup>1</sup></a><a href="/tags/yum/" style="font-size: 0.88rem;">yum<sup>1</sup></a><a href="/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" style="font-size: 0.88rem;">内存管理<sup>1</sup></a><a href="/tags/%E5%8E%86%E7%A8%8B/" style="font-size: 0.88rem;">历程<sup>1</sup></a><a href="/tags/%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/" style="font-size: 0.88rem;">地址空间<sup>1</sup></a><a href="/tags/%E6%9D%83%E9%99%90/" style="font-size: 0.88rem;">权限<sup>1</sup></a><a href="/tags/%E6%A8%A1%E6%9D%BF/" style="font-size: 0.88rem;">模板<sup>1</sup></a><a href="/tags/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/" style="font-size: 0.88rem;">环境变量<sup>1</sup></a><a href="/tags/%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/" style="font-size: 0.88rem;">类与对象<sup>3</sup></a><a href="/tags/%E7%BD%91%E7%AB%99/" style="font-size: 0.88rem;">网站<sup>2</sup></a><a href="/tags/%E8%BF%9B%E5%BA%A6%E6%9D%A1/" style="font-size: 0.88rem;">进度条<sup>1</sup></a><a href="/tags/%E8%BF%9B%E7%A8%8B/" style="font-size: 0.88rem;">进程<sup>6</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="anzhiyufont anzhiyu-icon-comments"></i></a><a id="switch-commentBarrage" href="javascript:anzhiyu.switchCommentBarrage();" title="开关弹幕"><i class="anzhiyufont anzhiyu-icon-danmu"></i></a><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="anzhiyufont anzhiyu-icon-xmark"></i></button></nav><div class="is-center" id="loading-database"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-pulse-icon"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("01/01/2025 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2025 By 安知鱼 V1.6.14",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 小米里的大麦 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>(() => {
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://twikoo-olive-one.vercel.app/',
      // 自己额外添加的：
      path: location.pathname.replace(/index\.html$/, ''),
      
      region: 'ap-shanghai',
      onCommentLoaded: () => {
        anzhiyu.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') setTimeout(runFn,0)
    else getScript('https://cdn.cbd.int/twikoo@1.6.44/dist/twikoo.all.min.js').then(runFn)
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://twikoo-olive-one.vercel.app/',
      region: 'ap-shanghai',
      urls: [window.location.pathname],
      includeReply: false
    }).then(res => {
      countELement.textContent = res[0].count
    }).catch(err => {
      console.error(err)
    })
  }

  const runFn = () => {
    init();
    GLOBAL_CONFIG_SITE.isPost && getCount()
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) anzhiyu.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else {
      loadTwikoo()
    }
  } else {
    window.loadOtherComment = loadTwikoo
  }
})()</script><input type="hidden" name="page-type" id="page-type" value="post"><script async src="/js/anzhiyu/comment_barrage.js"></script></div><script>window.addEventListener('load', () => {
  const changeContent = (content) => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const getComment = () => {
    const runTwikoo = () => {
      twikoo.getRecentComments({
        envId: 'https://twikoo-olive-one.vercel.app/',
        region: 'ap-shanghai',
        pageSize: 6,
        includeReply: true
      }).then(function (res) {
        const twikooArray = res.map(e => {
          return {
            'content': changeContent(e.comment),
            'avatar': e.avatar,
            'nick': e.nick,
            'url': e.url + '#' + e.id,
            'date': new Date(e.created).toISOString()
          }
        })

        saveToLocal.set('twikoo-newest-comments', JSON.stringify(twikooArray), 10/(60*24))
        generateHtml(twikooArray)
      }).catch(function (err) {
        const $dom = document.querySelector('#card-newest-comments .aside-list')
        $dom.textContent= "无法获取评论，请确认相关配置是否正确"
      })
    }

    if (typeof twikoo === 'object') {
      runTwikoo()
    } else {
      getScript('https://cdn.cbd.int/twikoo@1.6.44/dist/twikoo.all.min.js').then(runTwikoo)
    }
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'data-lazy-src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'><div class='name'><span>${array[i].nick} </span></div></a>`
        }
        
        result += `<div class='content'>
        <a class='comment' href='${array[i].url}' title='${array[i].content}'>${array[i].content}</a>
        <time datetime="${array[i].date}">${anzhiyu.diffDate(array[i].date, true)}</time></div>
        </div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom && ($dom.innerHTML= result)
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('twikoo-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><script async data-pjax src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.1/bubble/bubble.js"></script><script>var visitorMail = "xiaomilidedamai@minbit.top";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><script src="/js/anzhiyu/right_click_menu.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><script src="https://cdn.bootcdn.net/ajax/libs/echarts/4.9.0-rc.1/echarts.min.js"></script><script src="/js/footer-animal.js" defer></script><script id="click-show-text" src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/dist/click-show-text.min.js" data-mobile="false" data-text="offer,暴富,健康,offer,喜乐,成功,offer,好运,自由,offer,坚持,上岸" data-fontsize="20px" data-random="true" async="async"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["meta[property=\"og:image\"]","meta[property=\"og:title\"]","meta[property=\"og:url\"]","meta[property=\"og:type\"]","meta[property=\"og:site_name\"]","meta[property=\"og:description\"]","head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"]):not([href="/music/"]):not([href="/no-pjax/"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script><script>//- 留言板页面弹幕
window.addEventListener('load', () => {
  const getnaokuo_danmu = () => {
    if (!window.location.pathname.startsWith('/comments/')) return; //- 判断是否是留言板页面
    const naokuo_danmu = async () => {
      const Danmaku = new EasyDanmaku({
        page: '/comments/', //- 即留言板地址
        el: '#danmu-wrap', //- 弹幕挂载节点
        line: 5, //- 弹幕行数
        speed: 20, //- 弹幕播放速度
        hover: true, //- 鼠标hover时是否暂停播放弹幕
        loop: false, //- 开启循环播放
        colourful: true, //- 开启彩色弹幕
        coefficient: 1.38, //- 弹幕密度系数
        runtime: 10, //- 循环弹幕播放时长
      });
      try {
        let danmuStore = saveToLocal.get('twikoo-danmu');
        if (!danmuStore) {
          const options = {
            method: "POST",
            body: JSON.stringify({
              "event": "GET_RECENT_COMMENTS",
              "includeReply": false,
              "pageSize": 100
            }),
            headers: { 'Content-Type': 'application/json' }
          }
          danmuStore = [];
          const response = await fetch(`https://twikoo-olive-one.vercel.app/`, options);
          if (response.ok) {
            const { data } = await response.json();
            //- console.info(data);
            data.forEach(i => {
              if (i.avatar == undefined) i.avatar = 'https://cravatar.cn/avatar/d615d5793929e8c7d70eab5f00f7f5f1?d=mp'
              danmuStore.push({ avatar: i.avatar, content: i.nick + '：' + formatDanmaku(i.comment), url: i.url + '#' + i.id })
            });
            Danmaku.batchSend(danmuStore, true);
            saveToLocal.set('twikoo-danmu', danmuStore, 0.5)
          }
          //- 格式化评论
          function formatDanmaku(str) {
            str = str.replace(/<\/*br>|[\s\uFEFF\xA0]+/g, '');
            str = str.replace(/<img.*?>/g, '[图片]');
            str = str.replace(/<a.*?>.*?<\/a>/g, '[链接]');
            str = str.replace(/<pre.*?>.*?<\/pre>/g, '[代码块]');
            str = str.replace(/<.*?>/g, '');
            return str
          }
        } else {
          Danmaku.batchSend(danmuStore, true);
        }
      } catch (err) {
        console.error("Error fetching data:", err);
      }

      document.getElementById('danmu-Btn') && (document.getElementById('danmu-Btn').innerHTML = `<button class="hide-Btn" onclick="document.getElementById('danmu-wrap').classList.remove('hide-danmu')">显示弹幕</button> <button class="hide-Btn" onclick="document.getElementById('danmu-wrap').classList.add('hide-danmu')">隐藏弹幕</button>`)
    }
    (async () => {
      if (typeof EasyDanmaku === 'function') {
        await naokuo_danmu();
      } else {
        const easyDanmakuScript = await getScript('https://npm.onmicrosoft.cn/naokuo-blog@1.2.12/js/easy-Danmaku.js');
        if (typeof EasyDanmaku === 'function') {
          await naokuo_danmu();
        } else {
          console.error('EasyDanmaku function not found even after loading the script.');
        }
      }
    })();
  }
  getnaokuo_danmu()
  document.addEventListener('pjax:complete', getnaokuo_danmu)
})</script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>