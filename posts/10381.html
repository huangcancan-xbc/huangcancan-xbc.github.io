<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>04 类与对象（下） | 小米里的大麦</title><meta name="keywords" content="C++"><meta name="author" content="小米里的大麦"><meta name="copyright" content="小米里的大麦"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="04 类与对象（下）"><meta name="application-name" content="04 类与对象（下）"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="04 类与对象（下）"><meta property="og:url" content="https://www.minbit.top/posts/10381.html"><meta property="og:site_name" content="小米里的大麦"><meta property="og:description" content="1. 再谈构造函数在面向对象编程中，构造函数 是一种特殊的成员函数，它在对象创建时自动调用，负责初始化对象的成员变量（创建对象时赋初值），确保对象在创建时有一个有效的状态。接下来，我们将详细讲解关于构造函数的几个重要概念。 1.1 构造函数体赋值当我们创建一个对象时，构造函数会被自动调用，用来给对象"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Blog/20250314141714221.png?_r_=14a60b29-df3d-47d7-98e4-22c40b7edea8"><meta property="article:author" content="小米里的大麦"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Blog/20250314141714221.png?_r_=14a60b29-df3d-47d7-98e4-22c40b7edea8"><meta name="description" content="1. 再谈构造函数在面向对象编程中，构造函数 是一种特殊的成员函数，它在对象创建时自动调用，负责初始化对象的成员变量（创建对象时赋初值），确保对象在创建时有一个有效的状态。接下来，我们将详细讲解关于构造函数的几个重要概念。 1.1 构造函数体赋值当我们创建一个对象时，构造函数会被自动调用，用来给对象"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="https://www.minbit.top/posts/10381.html"><link rel="preconnect" href="//cdn.cbd.int"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="manifest" href="/manifest.json"/><meta name="msapplication-TileColor" content="var(--anzhiyu-main)"/><link rel="mask-icon" href="/img/siteicon/apple-icon-180.png" color="#5bbad5"/><link rel="apple-touch-icon" sizes="180x180" href="/img/siteicon/apple-icon-180.png"/><link rel="apple-touch-icon-precomposed" sizes="180x180" href="/img/siteicon/apple-icon-180.png"/><link rel="icon" type="image/png" sizes="32x32" href="/img/siteicon/32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/img/siteicon/16.png"/><link rel="bookmark" href="/img/siteicon/apple-icon-180.png"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2048-2732.jpg" media="(device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2732-2048.jpg" media="(device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1668-2388.jpg" media="(device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2388-1668.jpg" media="(device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1536-2048.jpg" media="(device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2048-1536.jpg" media="(device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1668-2224.jpg" media="(device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2224-1668.jpg" media="(device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1620-2160.jpg" media="(device-width: 810px) and (device-height: 1080px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2160-1620.jpg" media="(device-width: 810px) and (device-height: 1080px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1290-2796.jpg" media="(device-width: 430px) and (device-height: 932px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2796-1290.jpg" media="(device-width: 430px) and (device-height: 932px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1179-2556.jpg" media="(device-width: 393px) and (device-height: 852px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2556-1179.jpg" media="(device-width: 393px) and (device-height: 852px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1284-2778.jpg" media="(device-width: 428px) and (device-height: 926px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2778-1284.jpg" media="(device-width: 428px) and (device-height: 926px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1170-2532.jpg" media="(device-width: 390px) and (device-height: 844px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2532-1170.jpg" media="(device-width: 390px) and (device-height: 844px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1125-2436.jpg" media="(device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2436-1125.jpg" media="(device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1242-2688.jpg" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2688-1242.jpg" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-828-1792.jpg" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1792-828.jpg" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1242-2208.jpg" media="(device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2208-1242.jpg" media="(device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-750-1334.jpg" media="(device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1334-750.jpg" media="(device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-640-1136.jpg" media="(device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1136-640.jpg" media="(device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/swiper/swiper.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: undefined,
  postHeadAiDescription: {"enable":true,"gptName":"小米里的大麦","mode":"tianli","switchBtn":true,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":4,"basicWordCount":1999,"key":"93d1622eadde491eb0594b68ade51723.kaEiDD6A3KPzb7xv","Referer":"https://www.minbit.top/"},
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: {"enable":true,"ck":"Jp8wwGQpp21utaFQ","LingQueMonitorID":"3LnA8U5uaxPrnwv5"},
  greetingBox: {"enable":true,"default":"晚上好👋","list":[{"greeting":"晚安😴","startTime":0,"endTime":5},{"greeting":"早上好鸭👋, 祝你一天好心情！","startTime":6,"endTime":9},{"greeting":"上午好👋, 状态很好，鼓励一下～","startTime":10,"endTime":10},{"greeting":"11点多啦, 在坚持一下就吃饭啦～","startTime":11,"endTime":11},{"greeting":"午安👋, 宝贝","startTime":12,"endTime":14},{"greeting":"🌈充实的一天辛苦啦！","startTime":14,"endTime":18},{"greeting":"19点喽, 奖励一顿丰盛的大餐吧🍔。","startTime":19,"endTime":19},{"greeting":"晚上好👋, 在属于自己的时间好好放松😌~","startTime":20,"endTime":24}]},
  twikooEnvId: 'https://twikoo-olive-one.vercel.app/',
  commentBarrageConfig:{"enable":true,"maxBarrage":1,"barrageTime":5000,"accessToken":"25c96851dd8a790c4819ad4bfbaf153c","mailMd5":"7b12ebc2be80f9159099f6ab0e16573c"},
  music_page_default: "nav_music",
  root: '/',
  preloader: {"source":3},
  friends_vue_info: {"apiurl":null},
  navMusic: true,
  mainTone: undefined,
  authorStatus: {"skills":["🧐 准备中，就快好了，真的！😭","📚 正在学习中，加油！","🎵 喜欢听音乐，喜欢看动漫"]},
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: 小米里的大麦","link":"链接: ","source":"来源: 小米里的大麦","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-right"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: '小米里的大麦',
  title: '04 类与对象（下）',
  postAI: 'true',
  pageFillDescription: '1. 再谈构造函数, 1.1 构造函数体赋值, 1.2 初始化列表, 1.3 explicit 关键字, 2. static 成员, 2.1 概念, 2.2 特性, 例子：, 传道解惑：, Q1：静态成员函数可以调用非静态成员函数吗？, Q2 非静态成员函数可以调用类的静态成员函数吗？, 3. 友元（Friend）, 3.1 友元函数, 传道解惑, Q1：为什么使用友元函数？, 示例：重载 operatorltlt（输出流）为友元函数, 3.2 友元类, 友元类的特性：, 示例：友元类, SO：, 4. 内部类（Nested Class）, 4.1 概念：, 关键点：, 4.2 内部类的特性, 4.3 内部类的分类, 示例：内部类的使用, 1. 普通的内部类, 2. 静态内部类, 3. 普通内部类和静态内部类的区别：, SO, 5. 匿名对象（Anonymous Object）, 5.1 匿名对象的定义和创建, 5.2 匿名对象的生命周期, 5.3 匿名对象的使用示例, 示例 1：作为函数返回值的匿名对象, 示例 2：作为临时对象, 示例 3：通过类型转换创建匿名对象, 5.4 匿名对象的应用场景, 5.5 注意事项, 传道解惑, Q1：为什么匿名对象加 const 可以延长生命周期?, 具体解释：, 例子：匿名对象与 const 引用, 重要说明：, Q2：匿名对象 VS 有名对象, 总结, 6. 再次理解类和对象, 1. 类是对事物的抽象, 2. 对象是类的实例化, 3. 通过类创建对象, 4. 类和对象的关系, 5. 现实中的例子：洗衣机类, SO再谈构造函数在面向对象编程中构造函数是一种特殊的成员函数它在对象创建时自动调用负责初始化对象的成员变量创建对象时赋初值确保对象在创建时有一个有效的状态接下来我们将详细讲解关于构造函数的几个重要概念构造函数体赋值当我们创建一个对象时构造函数会被自动调用用来给对象的各个成员变量提供一个初始值例如这里是构造函数体中的赋值操作在这个例子中构造函数的作用是将赋值为然而这里要注意构造函数体中的赋值操作和初始化是有区别的构造函数体中对成员变量的赋值只能算是给成员变量赋初值而不是初始化因为初始化是指给成员变量设置一个初始值而且初始化只能发生一次而赋值操作可以发生多次再例如赋值操作在此之前已经默认初始化如果有的话然后被赋值为上述代码中是赋值而非初始化因为初始化只能通过构造函数外部的初始化列表来完成在构造函数体中对成员变量的赋值操作实际上是先通过默认初始化如果有的话然后通过赋值操作覆盖初始值这与初始化列表直接初始化成员变量有本质区别换句话说初始化只能在构造函数中通过初始化列表来进行一次而构造函数体中的赋值可以反复进行所以赋值与初始化的区别在于初始化是在对象创建时为成员变量设置初始值的过程每个成员变量只能被初始化一次通常在构造函数的初始化列表中进行只能进行一次赋值是在对象创建后对成员变量进行值的修改可以发生多次可以在构造函数体中也可以在对象的生命周期中的任何时候进行可以重复进行初始化列表初始化列表是构造函数中的一种写法直接初始化类的成员变量的一种方式允许我们在构造函数调用之前就给成员变量提供初始值语法是在构造函数的括号后加冒号和成员变量列表其基本格式是构造函数体这里的就是初始化列表它会在构造函数体执行之前初始化成员变量为再或者初始化列表注意事项每个成员变量在初始化列表中只能出现一次初始化列表的目的是对成员进行一次初始化对于某些特殊类型的成员变量必须使用初始化列表来进行初始化例如引用成员变量引用一旦初始化就不可更改只能在初始化列表中赋值成员变量常量变量变量在对象创建时必须初始化且不可更改必须在声明时初始化不能通过构造函数体赋值自定义类型成员没有默认构造函数的自定义类型自定义类型变量如果没有默认构造函数只能通过初始化列表初始化尽量使用初始化列表初始化因为不管你是否使用初始化列表对于自定义类型成员变量一定会先使用初始化列表初始化初始化列表的顺序初始化列表中的成员变量的初始化顺序和它们在类中声明的顺序一致而不是按照初始化列表中出现的顺序编译器会按照成员变量在类中声明的顺序进行内存布局因此初始化顺序也必须与之匹配推荐使用初始化列表的原因对于自定义类型编译器会自动调用其构造函数完成初始化不使用初始化列表而采用先默认构造再赋值可能导致性能浪费类的成员变量初始化顺序取决于成员变量的声明顺序而不是初始化列表的顺序此处先声明再声明初始化列表在之前初始化就会导致一些奇怪的错误未定义行为在之后声明所以会先被初始化才会初始化如果的初始化依赖就会导致意外的错误或输出关键字如果构造函数接收单一参数它可能会被编译器用于隐式类型转换而关键字则用来标记构造函数防止它参与隐式类型转换隐式类型转换可能导致临时对象的创建和销毁增加不必要的性能开销或者在代码中引入难以察觉的错误在中构造函数不仅可以用来构造和初始化对象还可以在特定条件下用作类型转换的隐式转换构造函数例如构造函数编译器会用构造函数将转换为对象在上述代码中构造函数是一个单参构造函数可以将类型的隐式转换为类型的对象为防止这种类型转换我们可以在构造函数前加上关键字这样就禁止了隐式转换构造函数错误不能隐式转换单参构造函数隐式调用构造函数的作用使用关键字禁止隐式类型转换错误禁止隐式转换正确隐式类型转换错误禁止隐式类型转换显式类型转换编译错误使用关键字后只有明确调用构造函数时才能进行类型转换不能再进行隐式转换所以构造函数不仅仅负责创建对象它还通过初始化列表给对象成员变量赋初值通过关键字我们可以禁止单参构造函数的隐式类型转换确保代码的类型安全成员概念在中类成员可以被声明为这样的成员称为静态成员静态成员包括静态成员变量和静态成员函数静态成员变量使用修饰的类成员变量所有对象共享这个变量不属于某个特定的对象静态成员变量必须在类外进行初始化被修饰的变量属于类本身而不是某个对象静态成员函数使用修饰的成员函数它是属于类的而不是类的某个对象修饰的函数属于类本身可以直接通过类名调用特性静态成员的共享性静态成员变量为所有对象共享修改其中一个对象的静态成员变量值会影响其他对象静态成员变量和静态成员函数是属于类本身的而不是类的某个特定对象所有类对象共享静态成员这意味着静态成员的值对所有对象是相同的静态成员并不存储在每个对象中而是存放在一个全局的静态区例如静态变量必须在类外定义初始化输出静态成员变量的初始化静态成员变量在类外进行定义和初始化而在类内部仅声明例如静态成员变量声明静态成员变量初始化访问静态成员可以通过类名直接访问静态成员类名静态成员也可以通过对象访问静态成员对象静态成员但是通常推荐通过类名来访问保持代码的清晰和一致性静态成员函数没有指针静态成员函数与类的对象无关静态成员函数属于类本身而不是某个对象因此它没有隐藏的指针由于没有指针静态成员函数无法访问类的非静态成员变量或非静态成员函数只能访问静态变量不能访问非静态成员非静态成员属于对象而静态成员函数与对象无关因此无法通过指针访问非静态成员访问权限静态成员仍然受类的访问控制的限制例子假设我们要实现一个类统计类的对象创建次数静态成员变量属于类本身每创建一个对象静态变量加静态成员函数返回静态变量的值类外初始化静态成员变量创建的对象数输出创建的对象数静态成员函数和非静态成员函数的区别函数非静态编译错误非静态函数静态静态函数调用非静态函数调用传道解惑静态成员函数可以调用非静态成员函数吗不可以静态成员函数没有指针它与对象无关因此它无法访问类的非静态成员变量和非静态成员函数如果静态成员函数试图访问非静态成员函数或成员变量会导致编译错误例如这是一个非静态函数不能访问非静态成员函数错误静态成员函数不能访问非静态成员函数非静态成员函数可以调用类的静态成员函数吗可以非静态成员函数属于某个对象可以访问类的静态成员变量和静态成员函数非静态成员函数是通过对象的指针来访问类的成员的所以它可以直接访问静态成员例如可以访问静态成员函数静态变量这是一个静态函数调用非静态成员函数内部可以访问静态成员函数输出这是一个静态函数静态变量友元友元是一种打破封装的方式它允许特定的函数或类访问类的私有成员和保护成员通常情况下类的私有成员是只能通过类的成员函数来访问的但友元提供了一个特例使得外部函数或类可以访问这些私有成员尽管友元能提供便利但它也会增加类之间的耦合度破坏封装性因此在设计时应当小心使用友元可以分为两种类型友元函数和友元类友元函数友元函数的定义友元函数是定义在类外的普通函数但可以访问类的私有成员和保护成员它并不是类的成员函数因此没有指针虽然它是类外的函数但为了让它可以访问类的私有成员必须在类内声明为友元函数使用关键字友元函数的特性声明位置可以在类定义的任何地方声明只要在类内部用关键字访问权限友元函数可以访问类的私有和保护成员但它并不属于类的成员函数不属于类的成员函数友元函数的调用和普通函数一样不通过对象调用没有指针不能用修饰友元函数不能被声明为因为它可能会修改类的私有成员例如前向声明类友元类类可以访问的私有成员友元函数声明友元类可以访问的私有成员访问的私有成员访问的私有成员调用友元函数调用友元类中的成员函数友元函数的使用场景当需要定义一个全局函数并且需要访问类的私有数据时常用于重载操作符和传道解惑为什么使用友元函数友元函数常用于那些不能作为成员函数实现的操作例如重载输入输出运算符和时和对象是流对象需要通过全局函数进行操作而不能作为类的成员函数示例重载输出流为友元函数假设我们有一个类想要重载运算符来输出的内容需要是左操作数因此不能作为成员函数声明友元函数友元函数的定义箱长使用重载的输出箱长在这个例子中是一个友元函数它被声明为类的友元因此它可以访问类的私有成员友元类友元类是指一个类的所有成员函数都可以成为另一个类的友元函数因此友元类的所有成员函数都可以访问当前类的私有成员和保护成员友元类的特性单向关系如果类声明类为友元类那么类的成员函数可以访问类的私有成员但类的成员函数不能访问类的私有成员友元关系是单向的声明友元类后能访问但不能访问不能继承友元关系不能被继承如果类是类的友元类那么类的派生类不会自动成为类的友元类关系不可传递如果是的友元是的友元那么并不是的友元示例友元类声明为友元类访问的私有成员再假设我们有类和类并希望类可以访问类的私有成员我们可以在类中声明为友元类前向声明声明函数访问类的私有成员声明类为友元类输出在这个例子中类声明了类为友元类这样类的成员函数就能够访问类的私有成员如和友元函数允许非成员函数访问类的私有和保护成员它不是类的成员函数通常用于操作符重载等场景友元类允许一个类的所有成员函数访问另一个类的私有和保护成员它们的关系是单向的使用场景友元可以提高代码的灵活性和可操作性但过多使用会增加类之间的耦合度破坏封装因此要谨慎使用内部类概念内部类是定义在另一个类内部的类它是一个独立的类和外部类没有直接的归属关系即它并不属于外部类的对象外部类不能直接访问内部类的成员反之内部类可以访问外部类的成员特别是当外部类的成员是时内部类天然是外部类的友元可以访问外部类的私有成员内部类有时也被称为嵌套类通常用于将一个类作为一个辅助工具类嵌套在另一个类中通常与外部类的功能紧密相关例如直接访问静态成员输出关键点独立性内部类是一个完全独立的类它不属于外部类的对象因此外部类不能通过自身的对象直接访问内部类的成员友元关系虽然外部类不能直接访问内部类的成员但内部类可以通过外部类的对象访问外部类的所有成员包括私有成员从这个角度来看内部类可以看作外部类的友元类内部类天然具有可以访问外部类的私有成员这种访问权限而不是因为它是友元类内部类的特性访问权限内部类可以定义在外部类的等任何区域和外部类的访问权限相同但外部类不能直接访问内部类的成员除非通过内部类的对象来访问内部类可以访问外部类的非静态成员但需要通过外部类的对象来访问访问外部类的静态成员内部类可以直接访问外部类中的成员无需外部类的对象或类名这是因为静态成员是属于类本身的而不是某个特定对象的外部类和内部类外部类和内部类是两个独立的实体它们占用不同的内存空间通过计算外部类的大小时和内部类没有直接关系内部类的分类静态内部类内部类是静态的意味着它不需要外部类的实例就可以访问静态内部类不能访问外部类的实例成员但可以访问外部类的静态成员非静态内部类普通内部类需要通过外部类的实例来创建实例且能够访问外部类的所有成员包括非静态成员示例内部类的使用下面我们通过一个例子详细讲解内部类的使用普通的内部类内部类可以访问外部类的私有成员访问外部类成员创建内部类对象通过内部类访问外部类的成员输出访问外部类成员在这个例子中是类的内部类类可以访问类的私有成员并且我们通过类的对象来访问外部类的成员静态内部类静态成员静态内部类可以访问外部类的静态成员访问外部类成员类外初始化静态成员变量创建静态内部类对象静态内部类访问外部类的静态成员输出访问外部类成员在这个例子中是类的静态内部类静态内部类可以直接访问类的静态成员不需要外部类的对象普通内部类和静态内部类的区别非静态内部类内部类编译错误非静态内部类访问外部类成员编译错误内部类是定义在另一个类内部的类它是独立的类外部类不能直接访问内部类的成员内部类可以通过外部类的对象访问外部类的所有成员友元关系从某种角度看内部类可以访问外部类的私有成员所以可以视作外部类的友元类内部类可以是静态的也可以是非静态的它们的访问权限和行为有所不同内部类通常用于处理一些与外部类紧密相关的功能帮助将代码组织得更好匿名对象在中匿名对象指的是没有明确名称的对象它通常用于函数返回临时数据传递类型转换等场景它们的生命周期仅限于它们所在的表达式或者函数调用执行完毕后即被销毁通过合理使用匿名对象可以简化代码减少不必要的对象创建提高程序的效率下面我将详细讲解匿名对象的相关知识点及其使用匿名对象的定义和创建匿名对象是没有名字的临时对象在中匿名对象通常出现在以下场景作为函数返回值当函数返回一个对象时会创建一个匿名对象来接收返回值临时对象用作表达式的操作数时编译器会创建一个临时对象类型转换在类型转换过程中会临时创建匿名对象匿名对象的生命周期匿名对象的生命周期非常短通常只在一个表达式或者函数调用期间有效它们会在表达式结束后立即销毁这是因为它们没有名字无法直接引用它们匿名对象的使用示例示例作为函数返回值的匿名对象构造函数析构函数函数返回匿名对象返回一个匿名对象创建一个匿名对象并调用它的方法解释在函数中创建了一个匿名对象并返回在函数中调用时匿名对象在函数返回时创建并且调用方法程序运行时首先会打印构造函数的消息接着打印的消息然后销毁匿名对象打印析构函数的消息示例作为临时对象构造函数析构函数这里是一个匿名对象调用方法解释在函数中创建了一个匿名对象并调用了方法这个匿名对象仅在该行代码执行时有效执行完后立即销毁示例通过类型转换创建匿名对象构造函数析构函数创建一个匿名对象并传递给构造函数解释创建了一个匿名对象并且传递了参数给构造函数这个匿名对象在创建后立即销毁生命周期仅限于该行代码匿名对象的应用场景匿名对象有很多实际应用下面列出一些常见的场景临时数据传递在函数调用时传递临时对象避免了不必要的对象复制例如处理传入的对象创建一个匿名对象并传递简化代码当不需要重复使用对象时可以通过匿名对象来简化代码避免创建多余的变量链式调用匿名对象可以用于链式调用多个函数例如链式调用匿名对象的方法注意事项内存管理匿名对象通常是自动管理的会在它们超出作用域后自动销毁这意味着开发者不需要手动释放内存但如果匿名对象涉及到动态内存分配如则需要特别注意内存管理避免悬挂引用由于匿名对象的生命周期很短必须避免在它销毁后访问它传道解惑为什么匿名对象加可以延长生命周期将匿名对象加上修饰符可以延长其生命周期但这种延长的生命周期并不是无条件的它的背后有一些特定的规则和原理在中匿名对象的生命周期是由它们的作用域决定的通常在一个表达式或函数调用结束时匿名对象会被销毁但是如果将匿名对象声明为类型它将与一个引用绑定从而延长其生命周期这是因为引用允许我们在对象生命周期结束后依然通过引用来使用它具体解释匿名对象与临时对象的生命周期默认情况下匿名对象临时对象的生命周期通常非常短仅限于它的表达式或语句的结束例如匿名对象在执行完后销毁使用引用延长生命周期当匿名对象绑定到一个引用时会保证匿名对象的生命周期至少延长到该引用的生命周期结束也就是说这个引用会延迟对象销毁的时机直到引用被销毁关键点引用可以延长临时对象的生命周期使其存在于引用的作用域中直到引用超出作用域示例是对匿名对象的引用匿名对象绑定到引用匿名对象在返回时才销毁在这个例子中创建了一个匿名对象这个匿名对象会被传递给函数并绑定到上匿名对象的生命周期被延长直到超出作用域也就是函数结束临时对象的绑定规则当临时对象匿名对象被绑定到一个引用时会延长临时对象的生命周期直到引用超出作用域这样做的目的是为了避免因临时对象提前销毁而导致引用悬挂问题即引用一个已销毁的临时对象例子匿名对象与引用构造函数析构函数做点什么这里是对匿名对象的引用匿名对象绑定到引用匿名对象的生命周期会被延长直到返回输出构造函数做点什么析构函数解释在函数中创建了一个匿名对象它被传递并绑定到由于是引用匿名对象的生命周期被延长直到函数返回匿名对象的析构函数只会在函数结束后调用重要说明引用延长生命周期的作用范围引用的作用是延长临时对象的生命周期直到引用超出作用域这意味着匿名对象在引用的作用域内存在引用超出作用域后匿名对象才会销毁而这样做是为了避免临时对象在使用时被提前销毁确保引用对象的有效性这种机制是中的一种特性它通过引用的生命周期来保证匿名对象在函数作用域内的安全访问非引用不允许绑定临时对象如果你尝试用一个非引用绑定临时对象编译器会报错因为非引用无法延长临时对象的生命周期匿名对象有名对象匿名对象和有名对象在中的最大区别在于命名生命周期以及访问方式匿名对象通常用于临时需要的场合生命周期短而有名对象则用于需要在多个地方访问和操作的情形生命周期较长下面我将详细解释命名匿名对象顾名思义它没有明确的名称通常是临时创建的对象不会绑定到变量上例如在这里创建了一个匿名对象它没有名称仅用于调用方法有名对象有明确的名称可以通过变量名访问例如是有名对象生命周期匿名对象生命周期非常短暂仅存在于当前表达式或者语句中一旦使用完毕匿名对象会被销毁例如中匿名对象会在调用后立刻销毁有名对象生命周期通常由它的作用域决定对象在创建时分配内存并在其作用域结束时被销毁如果对象在栈上创建它会在离开作用域时销毁如果在堆上创建则需要手动释放内存例如在离开作用域时销毁访问方式匿名对象不能通过变量名访问因为它没有名称只能在它创建的上下文中直接使用它例如中没有对象的名称无法在之后访问它有名对象可以通过对象的名称来引用和访问对象的成员例如中是有名对象可以在之后的代码中多次使用内存管理匿名对象由于没有名称它通常是栈上分配的编译器在合适的时候自动管理内存对于返回值优化等编译器会优化创建匿名对象的内存管理避免不必要的拷贝有名对象有名称可以显式创建在栈上或堆上栈上的对象在作用域结束时自动销毁而堆上的对象则需要手动应用场景匿名对象适用于临时使用例如一次性计算或者在函数调用中使用临时对象常见于函数返回值类型转换临时数据传递等场景示例匿名对象作为参数传递有名对象适用于需要多次访问的场景或者需要在多个地方使用该对象典型用法是作为类的实例创建时需要明确的对象名来进行后续操作示例有名对象可以在后续访问该对象返回值优化匿名对象在函数返回值时编译器会尽可能优化避免多余的拷贝操作这被称为返回值优化或者命名返回值优化这意味着返回匿名对象时编译器会直接在调用位置构造返回对象而不会创建临时对象例如匿名对象直接返回有名对象没有这样的优化问题通常会被拷贝或者移动到调用处特别是在涉及对象返回时性能差异匿名对象由于其生命周期非常短编译器有时能够优化它们的创建和销毁过程避免不必要的复制在某些场景中匿名对象能避免额外的内存分配和释放开销提升性能有名对象虽然生命周期较长但如果不合理使用有时会增加额外的开销尤其是在传递大对象时可能会发生不必要的拷贝操作总结特性匿名对象有名对象命名没有名称仅为临时对象有名称可以通过变量名访问生命周期短暂仅在表达式或函数调用期间存在生命周期由作用域决定作用域结束时销毁访问方式不能直接访问通常仅在当前表达式中使用可以通过名称多次访问内存管理编译器自动管理内存通常是栈上分配可以是栈上或堆上需要显式管理堆对象的内存应用场景临时数据传递返回值一次性计算等需要多次使用存储数据或状态等性能差异编译器优化可能避免不必要的复制如果不小心使用可能有不必要的拷贝操作总结再次理解类和对象理解类和对象的概念能帮助我们更好地理解面向对象编程的核心思想为了更通俗地讲解这个内容我们可以通过一个现实中的例子来帮助理解类是对事物的抽象类就像是对某种事物例如洗衣机的抽象描述它是对现实中事物的建模在程序中描述这个事物的属性和行为属性就是这个事物的特征比如洗衣机的品牌颜色容量等行为就是这个事物可以做的事情比如洗衣机可以启动停止洗衣服等举个例子洗衣机这个事物可以用类来描述洗衣机的品牌洗衣机的颜色洗衣机的容量比如启动洗衣机停止洗衣机在这个例子中类描述了一个洗衣机的属性和行为这个类的作用就是抽象化洗衣机将它的特征和行为描述给计算机对象是类的实例化类是对现实事物的抽象描述但计算机无法直接认识类必须通过实例化类来创建对象而对象才是计算机可以操作的具体实体实例化就是通过类创建具体的对象的过程对象是类的具体实例表示现实世界中的某个具体的事物比如你可以通过类创建多个洗衣机对象每个对象代表一个具体的洗衣机例子继续假设我们现在创建了一个洗衣机对象洗衣机的品牌洗衣机的颜色洗衣机的容量单位小米白色启动洗衣机洗衣服停止洗衣机格力黑色在这个例子中和是类的两个对象它们分别代表两个不同的洗衣机每个对象的属性可以有不同的值通过这些对象我们可以模拟现实中的多个洗衣机通过类创建对象从以上的例子可以看出类只是描述了洗衣机的属性和行为而对象才是具体的实例你可以通过类创建出多个对象每个对象都代表一个具体的事物类就像是一个模板或蓝图具体的对象是根据这个模板生成的类和对象的关系类是对事物的一种描述它定义了这个事物的属性和行为对象是类的实例是计算机可以直接操作的具体实体通过类可以创建多个对象每个对象都有不同的属性值和方法总结一下类和对象的关系可以类比为类就像是一本描述洗衣机的说明书它告诉我们洗衣机有哪些属性品牌颜色容量和行为启动停止对象就像是根据这本说明书实际生产出来的具体洗衣机每一台洗衣机都有自己的品牌颜色容量等信息并可以执行启动停止等操作现实中的例子洗衣机类让我们通过现实中的洗衣机来进一步理解抽象洗衣机当我们想到洗衣机时我们并不会想到具体某一台洗衣机而是先想到了洗衣机这个概念它有品牌颜色容量这些特征并且有启动停止这些操作这就是类的作用把这些共性的特征和行为总结出来创建洗衣机对象当你去买洗衣机时你选择了一个品牌颜色容量等具体参数的洗衣机每一台洗衣机就是一个对象它是类的实例化操作洗衣机当你开始使用这台洗衣机时你可以通过按按钮来启动和停止这就是对象通过类提供的操作方法来实现的行为类是对现实世界中事物的抽象描述它总结了事物的属性和行为对象是类的具体实例是计算机能够识别和操作的实体类是对事物的抽象描述而对象是根据类创建的具体实例通过类我们可以创建多个不同的对象每个对象具有类中定义的属性和行为通过理解类和对象的关系你将能够更好地理解面向对象编程的核心思想这对于学习和使用等面向对象语言非常重要',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-02-03 00:00:00',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 10 || hour >= 20
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://github.com/huangcancan-xbc/Drawing-bed/blob/master/Blog/20250307201719879.png?raw=true"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><div class="back-home-button"><i class="anzhiyufont anzhiyu-icon-grip-vertical"></i><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">社交</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://github.com/huangcancan-xbc" title="GitHub"><img class="back-menu-item-icon" src="/img/favicon.ico" alt="GitHub"/><span class="back-menu-item-text">GitHub</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://gitee.com/huang-cancan-xbc" title="gitee"><img class="back-menu-item-icon" src="/img/favicon.ico" alt="gitee"/><span class="back-menu-item-text">gitee</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">博客</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://blog.csdn.net/Huangcancan666?type=blog" title="CSDN"><img class="back-menu-item-icon" src="/img/favicon.ico" alt="CSDN"/><span class="back-menu-item-text">CSDN</span></a></div></div></div></div><a id="site-name" href="/" accesskey="h"><div class="title">小米里的大麦</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button only-home" id="travellings_button" title="随机前往一个开往项目网站"><a class="site-page" onclick="anzhiyu.totraveling()" title="随机前往一个开往项目网站" href="javascript:void(0);" rel="external nofollow" data-pjax-state="external"><i class="anzhiyufont anzhiyu-icon-train"></i></a></div><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><div class="nav-button" id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" title="搜索🔍" accesskey="s"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span> 搜索</span></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Blog/20250403212543768.png" target="_blank"><img class="post-qr-code-img" alt="微信" src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Blog/20250403212543768.png"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Blog/20250403212622868.png" target="_blank"><img class="post-qr-code-img" alt="支付宝" src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Blog/20250403212622868.png"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/C/" style="font-size: 1.05rem;">C++<sup>4</sup></a><a href="/tags/Linux/" style="font-size: 1.05rem;">Linux<sup>7</sup></a><a href="/tags/Obsidian/" style="font-size: 1.05rem;">Obsidian<sup>1</sup></a><a href="/tags/%E5%AD%A6%E4%B9%A0%E5%8E%86%E7%A8%8B/" style="font-size: 1.05rem;">学习历程<sup>1</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/05/"><span class="card-archive-list-date">五月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/03/"><span class="card-archive-list-date">三月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">7</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/02/"><span class="card-archive-list-date">二月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">3</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/01/"><span class="card-archive-list-date">一月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item on" id="consoleCommentBarrage" onclick="anzhiyu.switchCommentBarrage()" title="热评开关"><a class="commentBarrage"><i class="anzhiyufont anzhiyu-icon-message"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/C/" itemprop="url">C++</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/C/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>C++</span></a></span></div></div><h1 class="post-title" itemprop="name headline">04 类与对象（下）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2025-02-02T16:00:00.000Z" title="发表于 2025-02-03 00:00:00">2025-02-03</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2025-02-02T16:00:00.000Z" title="更新于 2025-02-03 00:00:00">2025-02-03</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="post-meta-wordcount"><i class="anzhiyufont anzhiyu-icon-file-word post-meta-icon" title="文章字数"></i><span class="post-meta-label" title="文章字数">字数总计:</span><span class="word-count" title="文章字数">11k</span><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-clock post-meta-icon" title="阅读时长"></i><span class="post-meta-label" title="阅读时长">阅读时长:</span><span>37分钟</span></span><span class="post-meta-separator"></span><span class="post-meta-pv-cv" id="" data-flag-title="04 类与对象（下）"><i class="anzhiyufont anzhiyu-icon-fw-eye post-meta-icon"></i><span class="post-meta-label" title="阅读量">阅读量:</span><span id="busuanzi_value_page_pv"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></span><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为西安"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>西安</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Blog/20250314141714221.png?_r_=14a60b29-df3d-47d7-98e4-22c40b7edea8"></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><div class="post-ai-description"><div class="ai-title"><i class="anzhiyufont anzhiyu-icon-bilibili"></i><div class="ai-title-text">AI-摘要</div><div id="ai-Toggle">切换</div><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right"></i><i class="anzhiyufont anzhiyu-icon-circle-dot" title="朗读摘要"></i><div id="ai-tag">Tianli GPT</div></div><div class="ai-explanation">AI初始化中...</div><div class="ai-btn-box"><div class="ai-btn-item">介绍自己 🙈</div><div class="ai-btn-item">生成本文简介 👋</div><div class="ai-btn-item">推荐相关文章 📖</div><div class="ai-btn-item">前往主页 🏠</div><div class="ai-btn-item" id="go-tianli-blog">前往爱发电购买</div></div><script data-pjax src="/js/anzhiyu/ai_abstract.js"></script></div><article class="post-content" id="article-container" itemscope itemtype="https://www.minbit.top/posts/10381.html"><header><a class="post-meta-categories" href="/categories/C/" itemprop="url">C++</a><a href="/tags/C/" tabindex="-1" itemprop="url">C++</a><h1 id="CrawlerTitle" itemprop="name headline">04 类与对象（下）</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">小米里的大麦</span><time itemprop="dateCreated datePublished" datetime="2025-02-02T16:00:00.000Z" title="发表于 2025-02-03 00:00:00">2025-02-03</time><time itemprop="dateCreated datePublished" datetime="2025-02-02T16:00:00.000Z" title="更新于 2025-02-03 00:00:00">2025-02-03</time></header><h2 id="1-再谈构造函数"><a href="#1-再谈构造函数" class="headerlink" title="1. 再谈构造函数"></a>1. 再谈构造函数</h2><p>在面向对象编程中，<strong>构造函数</strong> 是一种特殊的成员函数，它在对象创建时自动调用，负责初始化对象的成员变量（创建对象时赋初值），确保对象在创建时有一个有效的状态。接下来，我们将详细讲解关于构造函数的几个重要概念。</p>
<h3 id="1-1-构造函数体赋值"><a href="#1-1-构造函数体赋值" class="headerlink" title="1.1 构造函数体赋值"></a>1.1 构造函数体赋值</h3><p>当我们创建一个对象时，构造函数会被自动调用，用来给对象的各个成员变量提供一个初始值。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="built_in">MyClass</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        a = <span class="number">10</span>;  <span class="comment">// 这里是构造函数体中的赋值操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，构造函数的作用是将 <code>a</code> 赋值为 10。然而，这里要注意，<strong>构造函数体中的赋值操作和初始化是有区别的</strong>。构造函数体中对成员变量的赋值只能算是给成员变量“赋初值”，而不是“初始化”。因为初始化是指给成员变量设置一个初始值，而且初始化只能发生一次，而赋值操作可以发生多次。</p>
<p>再例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> _x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> x)</span><br><span class="line">    &#123;</span><br><span class="line">        _x = x; <span class="comment">// 赋值操作：_x 在此之前已经默认初始化（如果有的话），然后被赋值为 x。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">上述代码中，`_x = x;`是赋值，而非初始化，因为初始化只能通过构造函数外部的初始化列表来完成。</span><br><span class="line"></span><br><span class="line">在构造函数体中对成员变量的赋值操作，实际上是先通过默认初始化（如果有的话），然后通过赋值操作覆盖初始值。这与初始化列表直接初始化成员变量有本质区别。</span><br></pre></td></tr></table></figure>

<p>换句话说，<strong>初始化只能在构造函数中通过初始化列表来进行一次，而构造函数体中的赋值可以反复进行</strong>。</p>
<p>所以，<strong>赋值与初始化的区别</strong> 在于：</p>
<ul>
<li><strong>初始化</strong>：是在对象创建时为成员变量设置初始值的过程，每个成员变量只能被初始化一次，通常在构造函数的初始化列表中进行（只能进行一次）。</li>
<li><strong>赋值</strong>：是在对象创建后对成员变量进行值的修改，可以发生多次，可以在构造函数体中，也可以在对象的生命周期中的任何时候进行（可以重复进行）。</li>
</ul>
<hr>
<h3 id="1-2-初始化列表"><a href="#1-2-初始化列表" class="headerlink" title="1.2 初始化列表"></a>1.2 初始化列表</h3><p>初始化列表是构造函数中的一种写法（直接初始化类的成员变量的一种方式），允许我们在构造函数调用之前就给成员变量提供初始值。语法是在构造函数的括号后加冒号和成员变量列表，其基本格式是：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">MyClass</span>() : <span class="built_in">a</span>(<span class="number">10</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 构造函数体</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">这里的:`<span class="built_in">a</span>(<span class="number">10</span>)`就是初始化列表，它会在构造函数体执行之前初始化成员变量`a`为<span class="number">10</span>。</span><br></pre></td></tr></table></figure>

<p>再或者：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> _x;</span><br><span class="line">    <span class="type">int</span> _y;</span><br><span class="line">    <span class="type">int</span> _val;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> x)</span><br><span class="line">        : _x(x), </span><br><span class="line">          _y(<span class="number">0</span>), </span><br><span class="line">          _val(<span class="number">0</span>)</span><br><span class="line">    &#123;&#125; <span class="comment">// 初始化列表</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>注意事项</strong>：</p>
<ol>
<li>每个成员变量在初始化列表中只能出现一次。初始化列表的目的是对成员进行一次初始化。</li>
<li>对于某些特殊类型的成员变量，必须使用初始化列表来进行初始化。例如：<ul>
<li><strong>引用成员变量</strong>：引用一旦初始化就不可更改，只能在初始化列表中赋值。</li>
<li><strong>const 成员变量</strong>：常量变量（const 变量）在对象创建时必须初始化，且不可更改；必须在声明时初始化，不能通过构造函数体赋值。</li>
<li><strong>自定义类型成员</strong>&#x2F;<strong>没有默认构造函数的自定义类型</strong>：自定义类型变量如果没有默认构造函数，只能通过初始化列表初始化。</li>
</ul>
</li>
<li>尽量使用初始化列表初始化，因为不管你是否使用初始化列表，对于自定义类型成员变量，一定会先使用初始化列表初始化。</li>
<li><strong>初始化列表的顺序</strong>：初始化列表中的成员变量的初始化顺序 <strong>和它们在类中声明的顺序一致</strong>，而不是按照初始化列表中出现的顺序（编译器会按照成员变量在类中声明的顺序进行内存布局，因此初始化顺序也必须与之匹配）。</li>
</ol>
<p><strong>推荐使用初始化列表的原因</strong>： 对于自定义类型，编译器会自动调用其构造函数完成初始化，不使用初始化列表而采用先默认构造再赋值可能导致性能浪费。</p>
<p><strong>类的成员变量初始化顺序</strong> 取决于 <strong>成员变量的声明顺序</strong>，而不是初始化列表的顺序：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 此处先声明 a, 再声明 b</span></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> b;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> x) : <span class="built_in">b</span>(<span class="number">20</span>), <span class="built_in">a</span>(x) <span class="comment">// 初始化列表：b 在 a 之前初始化（就会导致一些奇怪的错误：未定义行为（UB））</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// b 在 a 之后声明，所以 a 会先被初始化，b 才会初始化！</span></span><br><span class="line">		<span class="comment">// 如果 b 的初始化依赖 a，就会导致意外的错误或 UB！</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;, b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">MyClass <span class="title">obj</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">// 输出：a = 10, b = 20</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="1-3-explicit-关键字"><a href="#1-3-explicit-关键字" class="headerlink" title="1.3 explicit 关键字"></a>1.3 explicit 关键字</h3><p>如果构造函数接收单一参数，它可能会被编译器用于隐式类型转换。而 <code>explicit</code> 关键字则用来标记构造函数，防止它参与隐式类型转换。 隐式类型转换可能导致临时对象的创建和销毁，增加不必要的性能开销，或者在代码中引入难以察觉的错误。</p>
<p>在 C++中，构造函数不仅可以用来构造和初始化对象，还可以在特定条件下用作类型转换的“隐式转换构造函数”。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 构造函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// error: conversion from &#x27;int&#x27; to non-scalar type &#x27;MyClass&#x27; requested</span></span><br><span class="line">MyClass obj = <span class="number">10</span>;  <span class="comment">// 编译器会用构造函数将10转换为MyClass对象</span></span><br><span class="line"></span><br><span class="line">在上述代码中，`<span class="built_in">MyClass</span>(<span class="type">int</span> x)`构造函数是一个单参构造函数，可以将`<span class="type">int</span>`类型的<span class="number">10</span>隐式转换为`MyClass`类型的对象。</span><br><span class="line">为防止这种类型转换，我们可以在构造函数前加上`<span class="keyword">explicit</span>`关键字，这样就禁止了隐式转换：</span><br><span class="line">    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MyClass</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 构造函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MyClass obj = <span class="number">10</span>;  <span class="comment">// 错误：不能隐式转换</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> x) &#123;&#125; <span class="comment">// 单参构造函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A obj = <span class="number">10</span>; <span class="comment">// 隐式调用构造函数</span></span><br><span class="line"></span><br><span class="line">**<span class="keyword">explicit</span>的作用**： 使用`<span class="keyword">explicit</span>`关键字禁止隐式类型转换：</span><br><span class="line">    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">A</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A obj = <span class="number">10</span>; <span class="comment">// 错误，禁止隐式转换</span></span><br><span class="line"><span class="function">A <span class="title">obj2</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> x) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyExplicitClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MyExplicitClass</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MyClass obj1 = <span class="number">10</span>;  <span class="comment">// 隐式类型转换</span></span><br><span class="line">    MyExplicitClass obj2 = <span class="number">10</span>;  <span class="comment">// 错误：禁止隐式类型转换</span></span><br><span class="line">    <span class="function">MyExplicitClass <span class="title">obj3</span><span class="params">(<span class="number">10</span>)</span></span>;  <span class="comment">// 显式类型转换</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;obj1 created successfully.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; &quot;obj2 created successfully.&quot; &lt;&lt; endl;  // 编译错误</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;obj3 created successfully.&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 <code>explicit</code> 关键字后，只有明确调用构造函数时才能进行类型转换，不能再进行隐式转换。所以，构造函数不仅仅负责创建对象，它还通过初始化列表给对象成员变量赋初值。通过 <code>explicit</code> 关键字，我们可以禁止单参构造函数的隐式类型转换，确保代码的类型安全。</p>
<hr>
<h2 id="2-static-成员"><a href="#2-static-成员" class="headerlink" title="2. static 成员"></a>2. static 成员</h2><h3 id="2-1-概念"><a href="#2-1-概念" class="headerlink" title="2.1 概念"></a>2.1 概念</h3><p>在 C++中，类成员可以被声明为 <code>static</code>，这样的成员称为 <strong>静态成员</strong>。静态成员包括静态成员变量和静态成员函数。</p>
<ul>
<li><strong>静态成员变量</strong>：使用 <code>static</code> 修饰的类成员变量，所有对象共享这个变量，不属于某个特定的对象。静态成员变量必须在类外进行初始化（被修饰的变量属于类本身，而不是某个对象）。</li>
<li><strong>静态成员函数</strong>：使用 <code>static</code> 修饰的成员函数，它是属于类的，而不是类的某个对象（修饰的函数属于类本身，可以直接通过类名调用）。</li>
</ul>
<h4 id="2-2-特性"><a href="#2-2-特性" class="headerlink" title="2.2 特性"></a>2.2 特性</h4><ol>
<li><p><strong>静态成员的共享性</strong>： 静态成员变量为所有对象共享，修改其中一个对象的静态成员变量值，会影响其他对象。</p>
<ul>
<li>静态成员变量和静态成员函数是属于类本身的，而不是类的某个特定对象。</li>
<li>所有类对象共享静态成员，这意味着静态成员的值对所有对象是相同的。</li>
<li>静态成员并不存储在每个对象中，而是存放在一个全局的静态区。</li>
</ul>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> _count;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Increment</span><span class="params">()</span> </span>&#123; _count++; &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">GetCount</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _count; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> A::_count = <span class="number">0</span>;<span class="comment">//  静态变量必须在类外定义/初始化</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A::<span class="built_in">Increment</span>();</span><br><span class="line">    cout &lt;&lt; A::<span class="built_in">GetCount</span>() &lt;&lt; endl; <span class="comment">// 输出1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>静态成员变量的初始化</strong>：</p>
<ul>
<li><p>静态成员变量在类外进行定义和初始化，而在类内部仅声明。</p>
</li>
<li><p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> count;  <span class="comment">// 静态成员变量声明</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> MyClass::count = <span class="number">0</span>;  <span class="comment">// 静态成员变量初始化</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>访问静态成员</strong>：</p>
<ul>
<li>可以通过类名直接访问静态成员：<code>类名::静态成员</code>。</li>
<li>也可以通过对象访问静态成员：<code>对象.静态成员</code>。但是，通常推荐通过类名来访问，保持代码的清晰和一致性。</li>
</ul>
</li>
<li><p><strong>静态成员函数没有 <code>this</code> 指针</strong>：</p>
<ul>
<li>静态成员函数与类的对象无关，静态成员函数属于类本身，而不是某个对象，因此它没有隐藏的 <code>this</code> 指针。</li>
<li>由于没有 <code>this</code> 指针，静态成员函数无法访问类的非静态成员变量或非静态成员函数（只能访问静态变量，不能访问非静态成员）。</li>
<li>非静态成员属于对象，而静态成员函数与对象无关，因此无法通过 <code>this</code> 指针访问非静态成员。</li>
</ul>
</li>
<li><p><strong>访问权限</strong>：</p>
<ul>
<li>静态成员仍然受类的访问控制（<code>public</code>、<code>protected</code>、<code>private</code>）的限制。</li>
</ul>
</li>
</ol>
<h3 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h3><p>假设我们要实现一个类，统计类的对象创建次数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> count; 		<span class="comment">// 静态成员变量，属于类本身</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">MyClass</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        count++; 			<span class="comment">// 每创建一个对象，静态变量 count 加 1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">getCount</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count; 		<span class="comment">// 静态成员函数，返回静态变量的值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> MyClass::count = <span class="number">0</span>; 	<span class="comment">// 类外初始化静态成员变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MyClass obj1, obj2, obj3;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;创建的对象数：&quot;</span> &lt;&lt; MyClass::<span class="built_in">getCount</span>() &lt;&lt; endl; <span class="comment">// 输出：创建的对象数：3</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>静态成员函数和非静态成员函数的区别：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> staticVar;</span><br><span class="line">    <span class="type">int</span> nonStaticVar;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">staticFunction</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;static 函数，staticVar =&quot;</span> &lt;&lt; staticVar &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; &quot;非静态 var =&quot; &lt;&lt; nonStaticVar &lt;&lt; endl;  // 编译错误</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">nonStaticFunction</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;非静态函数，nonStaticVar =&quot;</span> &lt;&lt; nonStaticVar &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;静态 var =&quot;</span> &lt;&lt; staticVar &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> MyClass::staticVar = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MyClass::<span class="built_in">staticFunction</span>();  <span class="comment">// 静态函数调用</span></span><br><span class="line">    MyClass obj;</span><br><span class="line">    obj.<span class="built_in">nonStaticFunction</span>();  <span class="comment">// 非静态函数调用</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<h3 id="传道解惑："><a href="#传道解惑：" class="headerlink" title="传道解惑："></a>传道解惑：</h3><h4 id="Q1：静态成员函数可以调用非静态成员函数吗？"><a href="#Q1：静态成员函数可以调用非静态成员函数吗？" class="headerlink" title="Q1：静态成员函数可以调用非静态成员函数吗？"></a>Q1：静态成员函数可以调用非静态成员函数吗？</h4><p><strong>不可以</strong>。静态成员函数没有 <code>this</code> 指针，它与对象无关。因此，它无法访问类的非静态成员变量和非静态成员函数。如果静态成员函数试图访问非静态成员函数或成员变量，会导致编译错误。</p>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&gt;&#123;</span><br><span class="line">&gt;<span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">nonStaticFunction</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      	cout &lt;&lt; <span class="string">&quot;这是一个非静态函数。&quot;</span> &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">staticFunction</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">          <span class="comment">// 不能访问非静态成员函数</span></span><br><span class="line">          <span class="comment">// nonStaticFunction();  // 错误：静态成员函数不能访问非静态成员函数</span></span><br><span class="line">   &#125;</span><br><span class="line">&gt;&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="Q2-非静态成员函数可以调用类的静态成员函数吗？"><a href="#Q2-非静态成员函数可以调用类的静态成员函数吗？" class="headerlink" title="Q2: 非静态成员函数可以调用类的静态成员函数吗？"></a>Q2: 非静态成员函数可以调用类的静态成员函数吗？</h4><p><strong>可以</strong>。非静态成员函数属于某个对象，可以访问类的静态成员变量和静态成员函数。非静态成员函数是通过对象的 <code>this</code> 指针来访问类的成员的，所以它可以直接访问静态成员。</p>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&gt;&#123;</span><br><span class="line">&gt;<span class="keyword">public</span>:</span><br><span class="line">   <span class="type">static</span> <span class="type">int</span> staticVar;</span><br><span class="line">   <span class="type">int</span> nonStaticVar;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">nonStaticFunction</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">          <span class="comment">// 可以访问静态成员函数</span></span><br><span class="line">          <span class="built_in">staticFunction</span>();</span><br><span class="line">          cout &lt;&lt; <span class="string">&quot;静态变量：&quot;</span> &lt;&lt; staticVar &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">staticFunction</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      	cout &lt;&lt; <span class="string">&quot;这是一个静态函数。&quot;</span> &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="type">int</span> MyClass::staticVar = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">&gt;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">&gt;</span>&#123;</span><br><span class="line">   MyClass obj;</span><br><span class="line">   obj.<span class="built_in">nonStaticFunction</span>();  <span class="comment">// 调用非静态成员函数，内部可以访问静态成员函数</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;这是一个静态函数。</span><br><span class="line">&gt;静态变量：10</span><br></pre></td></tr></table></figure>
</blockquote>
<hr>
<h2 id="3-友元（Friend）"><a href="#3-友元（Friend）" class="headerlink" title="3. 友元（Friend）"></a>3. 友元（Friend）</h2><p><strong>友元</strong> 是一种打破封装的方式，它允许特定的函数或类访问类的私有成员和保护成员。通常情况下，类的私有成员是只能通过类的成员函数来访问的，但友元提供了一个特例，使得外部函数或类可以访问这些私有成员。尽管友元能提供便利，但它也会增加类之间的耦合度，破坏封装性，因此在设计时应当小心使用。</p>
<p>友元可以分为两种类型：<strong>友元函数</strong> 和 <strong>友元类</strong>。</p>
<h3 id="3-1-友元函数"><a href="#3-1-友元函数" class="headerlink" title="3.1 友元函数"></a>3.1 友元函数</h3><ul>
<li><p><strong>友元函数的定义</strong>： 友元函数是定义在类外的普通函数，但可以访问类的私有成员和保护成员。它并不是类的成员函数，因此没有 <code>this</code> 指针。虽然它是类外的函数，但为了让它可以访问类的私有成员，必须在类内声明为友元函数，使用 <code>friend</code> 关键字。</p>
</li>
<li><p><strong>友元函数的特性：</strong></p>
<ul>
<li><strong>声明位置</strong>：可以在类定义的任何地方声明，只要在类内部用 <code>friend</code> 关键字。</li>
<li><strong>访问权限</strong>：友元函数可以访问类的私有和保护成员，但它并不属于类的成员函数。</li>
<li><strong>不属于类的成员函数</strong>：友元函数的调用和普通函数一样，不通过对象调用，没有 <code>this</code> 指针。</li>
<li><strong>不能用 <code>const</code> 修饰</strong>：友元函数不能被声明为 <code>const</code>，因为它可能会修改类的私有成员。</li>
</ul>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>;  <span class="comment">// 前向声明类 A</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> _y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>(<span class="type">int</span> y) : _y(y) &#123;&#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">A</span>;  <span class="comment">// 友元类：A 类可以访问 B 的私有成员</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> _x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> x) : _x(x) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">Print</span><span class="params">(<span class="type">const</span> A&amp; a)</span></span>;  <span class="comment">// 友元函数声明</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 友元类 A 可以访问 B 的私有成员</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(<span class="type">const</span> B&amp; b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Friend class: &quot;</span> &lt;&lt; b._y &lt;&lt; endl;  <span class="comment">// 访问 B 的私有成员</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(<span class="type">const</span> A&amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Friend function: &quot;</span> &lt;&lt; a._x &lt;&lt; endl;  <span class="comment">// 访问 A 的私有成员</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="built_in">Print</span>(a);  <span class="comment">// 调用友元函数</span></span><br><span class="line"></span><br><span class="line">    <span class="function">B <span class="title">b</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line">    a.<span class="built_in">Print</span>(b);  <span class="comment">// 调用友元类中的成员函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>友元函数的使用场景</strong>：</p>
<ul>
<li>当需要定义一个全局函数，并且需要访问类的私有数据时。</li>
<li>常用于重载操作符 <code>&lt;&lt;</code> 和 <code>&gt;&gt;</code>。</li>
</ul>
</li>
</ul>
<blockquote>
<h3 id="传道解惑"><a href="#传道解惑" class="headerlink" title="传道解惑"></a>传道解惑</h3><h4 id="Q1：为什么使用友元函数？"><a href="#Q1：为什么使用友元函数？" class="headerlink" title="Q1：为什么使用友元函数？"></a>Q1：为什么使用友元函数？</h4><p>友元函数常用于那些不能作为成员函数实现的操作。例如，重载输入输出运算符 <code>&lt;&lt;</code> 和 <code>&gt;&gt;</code> 时，<code>cout</code> 和 <code>cin</code> 对象是流对象，需要通过全局函数进行操作，而不能作为类的成员函数。</p>
<h5 id="示例：重载-operator"><a href="#示例：重载-operator" class="headerlink" title="示例：重载 operator&lt;&lt;（输出流）为友元函数"></a>示例：重载 <code>operator&lt;&lt;</code>（输出流）为友元函数</h5><p>假设我们有一个 <code>Box</code> 类，想要重载 <code>&lt;&lt;</code> 运算符来输出 <code>Box</code> 的内容，<code>cout</code> 需要是左操作数，因此 <code>&lt;&lt;</code> 不能作为成员函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">&gt;<span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">Box</span></span><br><span class="line">&gt;&#123;</span><br><span class="line">&gt;<span class="keyword">private</span>:</span><br><span class="line">       <span class="type">int</span> length;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">       <span class="built_in">Box</span>(<span class="type">int</span> l) : <span class="built_in">length</span>(l) &#123;&#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 声明友元函数</span></span><br><span class="line">       <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os, <span class="type">const</span> Box&amp; box);</span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 友元函数的定义</span></span><br><span class="line">&gt;ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os, <span class="type">const</span> Box&amp; box)</span><br><span class="line">&gt;&#123;</span><br><span class="line">       os &lt;&lt; <span class="string">&quot;箱长：&quot;</span> &lt;&lt; box.length;</span><br><span class="line">       <span class="keyword">return</span> os;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">&gt;</span>&#123;</span><br><span class="line">       <span class="function">Box <span class="title">box</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">       cout &lt;&lt; box &lt;&lt; endl;  <span class="comment">// 使用重载的operator&lt;&lt;</span></span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;箱长：10</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>operator&lt;&lt;</code> 是一个友元函数，它被声明为 <code>Box</code> 类的友元，因此它可以访问 <code>Box</code> 类的私有成员 <code>length</code>。</p>
</blockquote>
<hr>
<h3 id="3-2-友元类"><a href="#3-2-友元类" class="headerlink" title="3.2 友元类"></a>3.2 友元类</h3><p><strong>友元类</strong> 是指一个类的所有成员函数都可以成为另一个类的友元函数，因此友元类的所有成员函数都可以访问当前类的私有成员和保护成员。</p>
<h4 id="友元类的特性："><a href="#友元类的特性：" class="headerlink" title="友元类的特性："></a>友元类的特性：</h4><ul>
<li><strong>单向关系</strong>：如果类 A 声明类 B 为友元类，那么类 B 的成员函数可以访问类 A 的私有成员，但类 A 的成员函数不能访问类 B 的私有成员。友元关系是单向的（声明友元类 B 后，B 能访问 A，但 A 不能访问 B）。</li>
<li><strong>不能继承</strong>：友元关系不能被继承，如果类 A 是类 B 的友元类，那么类 B 的派生类不会自动成为类 A 的友元类。</li>
<li><strong>关系不可传递</strong>：如果 B 是 A 的友元，C 是 B 的友元，那么 C 并不是 A 的友元。</li>
</ul>
<h4 id="示例：友元类"><a href="#示例：友元类" class="headerlink" title="示例：友元类"></a>示例：友元类</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> _x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> x) : _x(x) &#123;&#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">B</span>; 			<span class="comment">// 声明B为友元类</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AccessA</span><span class="params">(<span class="type">const</span> A&amp; a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; a._x &lt;&lt; endl; 	<span class="comment">// 访问A的私有成员</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>再假设我们有 <code>Time</code> 类和 <code>Date</code> 类，并希望 <code>Time</code> 类可以访问 <code>Date</code> 类的私有成员。我们可以在 <code>Time</code> 类中声明 <code>Date</code> 为友元类。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Time</span>; <span class="comment">// 前向声明</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printTime</span><span class="params">(<span class="type">const</span> Time&amp; t)</span></span>; <span class="comment">// 声明函数，访问 Time 类的私有成员</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Time</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> hour;</span><br><span class="line">    <span class="type">int</span> minute;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Time</span>(<span class="type">int</span> h, <span class="type">int</span> m) : <span class="built_in">hour</span>(h), <span class="built_in">minute</span>(m) &#123;&#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Date</span>; <span class="comment">// 声明 Date 类为友元类</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Date::printTime</span><span class="params">(<span class="type">const</span> Time&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Time: &quot;</span> &lt;&lt; t.hour &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; t.minute &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Time <span class="title">t</span><span class="params">(<span class="number">10</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">    Date d;</span><br><span class="line">    d.<span class="built_in">printTime</span>(t); <span class="comment">// 输出：Time: 10:30</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>Time</code> 类声明了 <code>Date</code> 类为友元类，这样 <code>Date</code> 类的成员函数 <code>printTime</code> 就能够访问 <code>Time</code> 类的私有成员（如 <code>hour</code> 和 <code>minute</code>）。</p>
<h3 id="SO："><a href="#SO：" class="headerlink" title="SO："></a>SO：</h3><ul>
<li><strong>友元函数</strong>：允许非成员函数访问类的私有和保护成员。它不是类的成员函数，通常用于操作符重载等场景。</li>
<li><strong>友元类</strong>：允许一个类的所有成员函数访问另一个类的私有和保护成员。它们的关系是单向的。</li>
<li><strong>使用场景</strong>：友元可以提高代码的灵活性和可操作性，但过多使用会增加类之间的耦合度，破坏封装，因此要谨慎使用。</li>
</ul>
<hr>
<h2 id="4-内部类（Nested-Class）"><a href="#4-内部类（Nested-Class）" class="headerlink" title="4. 内部类（Nested Class）"></a>4. 内部类（Nested Class）</h2><h3 id="4-1-概念："><a href="#4-1-概念：" class="headerlink" title="4.1 概念："></a>4.1 概念：</h3><p><strong>内部类</strong> 是定义在另一个类内部的类。它是一个独立的类，和外部类没有直接的归属关系，即它并不属于外部类的对象。外部类不能直接访问内部类的成员，反之，内部类可以访问外部类的成员，特别是当外部类的成员是 <code>static</code> 时（内部类天然是外部类的友元，可以访问外部类的私有成员）。</p>
<p><strong>内部类</strong> 有时也被称为 <strong>嵌套类</strong>，通常用于将一个类作为一个辅助工具类嵌套在另一个类中，通常与外部类的功能紧密相关。</p>
<p><strong>例如：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> _count;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">ShowCount</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            cout &lt;&lt; _count &lt;&lt; endl; <span class="comment">// 直接访问静态成员</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> A::_count = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A::B b;</span><br><span class="line">    b.<span class="built_in">ShowCount</span>(); <span class="comment">// 输出10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="关键点："><a href="#关键点：" class="headerlink" title="关键点："></a>关键点：</h4><ol>
<li><strong>独立性</strong>：内部类是一个完全独立的类，它不属于外部类的对象。因此，外部类不能通过自身的对象直接访问内部类的成员。</li>
<li><strong>友元关系</strong>：虽然外部类不能直接访问内部类的成员，但内部类可以通过外部类的对象访问外部类的所有成员（包括私有成员）。从这个角度来看，内部类可以看作外部类的友元类（<strong>内部类天然具有可以访问外部类的私有成员这种访问权限，而不是因为它是友元类</strong>）。</li>
</ol>
<h3 id="4-2-内部类的特性"><a href="#4-2-内部类的特性" class="headerlink" title="4.2 内部类的特性"></a>4.2 内部类的特性</h3><ol>
<li><strong>访问权限</strong>：<ul>
<li>内部类可以定义在外部类的 <code>public</code>、<code>protected</code>、<code>private</code> 等任何区域，和外部类的访问权限相同。</li>
<li>但外部类不能直接访问内部类的成员，除非通过内部类的对象来访问。</li>
<li>内部类可以访问外部类的非静态成员，但需要通过外部类的对象来访问。</li>
</ul>
</li>
<li><strong>访问外部类的静态成员</strong>：<ul>
<li>内部类可以直接访问外部类中的 <code>static</code> 成员，无需外部类的对象或类名。这是因为静态成员是属于类本身的，而不是某个特定对象的。</li>
</ul>
</li>
<li><strong><code>sizeof</code> 外部类和内部类</strong>：<ul>
<li>外部类和内部类是两个独立的实体，它们占用不同的内存空间。通过 <code>sizeof</code> 计算外部类的大小时，和内部类没有直接关系。</li>
</ul>
</li>
</ol>
<h3 id="4-3-内部类的分类"><a href="#4-3-内部类的分类" class="headerlink" title="4.3 内部类的分类"></a>4.3 内部类的分类</h3><ul>
<li><strong>静态内部类</strong>（<code>static</code> nested class）：内部类是静态的，意味着它不需要外部类的实例就可以访问。静态内部类不能访问外部类的实例成员，但可以访问外部类的静态成员。</li>
<li><strong>非静态内部类</strong>（普通内部类）：需要通过外部类的实例来创建实例，且能够访问外部类的所有成员（包括非静态成员）。</li>
</ul>
<h3 id="示例：内部类的使用"><a href="#示例：内部类的使用" class="headerlink" title="示例：内部类的使用"></a>示例：内部类的使用</h3><p>下面我们通过一个例子，详细讲解内部类的使用。</p>
<h4 id="1-普通的内部类"><a href="#1-普通的内部类" class="headerlink" title="1. 普通的内部类"></a>1. 普通的内部类</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> outerVar = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Inner</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">accessOuter</span><span class="params">(Outer&amp; outer)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="comment">// 内部类可以访问外部类的私有成员</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;访问外部类 private 成员：&quot;</span> &lt;&lt; outer.outerVar &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Outer outer;</span><br><span class="line">    Outer::Inner inner;  			<span class="comment">// 创建内部类对象</span></span><br><span class="line">    inner.<span class="built_in">accessOuter</span>(outer);  		<span class="comment">// 通过内部类访问外部类的成员</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">访问外部类 private 成员：10</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>Inner</code> 是 <code>Outer</code> 类的内部类。<code>Inner</code> 类可以访问 <code>Outer</code> 类的私有成员 <code>outerVar</code>，并且我们通过 <code>Outer</code> 类的对象来访问外部类的成员。</p>
<h4 id="2-静态内部类"><a href="#2-静态内部类" class="headerlink" title="2. 静态内部类"></a>2. 静态内部类</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> staticVar;  		<span class="comment">// 静态成员</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="keyword">class</span> <span class="title class_">Inner</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">accessOuter</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="comment">// 静态内部类可以访问外部类的静态成员</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;访问外部类 static 成员：&quot;</span> &lt;&lt; staticVar &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Outer::staticVar = <span class="number">20</span>;		<span class="comment">// 类外初始化静态成员变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Outer::Inner inner;  		<span class="comment">// 创建静态内部类对象</span></span><br><span class="line">    inner.<span class="built_in">accessOuter</span>();  		<span class="comment">// 静态内部类访问外部类的静态成员</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">访问外部类 static 成员：20</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>Inner</code> 是 <code>Outer</code> 类的静态内部类。静态内部类可以直接访问 <code>Outer</code> 类的静态成员 <code>staticVar</code>，不需要外部类的对象。</p>
<h4 id="3-普通内部类和静态内部类的区别："><a href="#3-普通内部类和静态内部类的区别：" class="headerlink" title="3. 普通内部类和静态内部类的区别："></a>3. 普通内部类和静态内部类的区别：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> outerVar = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Inner</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">accessOuter</span><span class="params">(Outer&amp; outer)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;非静态内部类：&quot;</span> &lt;&lt; outer.outerVar &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="keyword">class</span> <span class="title class_">StaticInner</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">accessOuter</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;static 内部类：&quot;</span> &lt;&lt; outerVar &lt;&lt; endl;  <span class="comment">// 编译错误</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Outer outer;</span><br><span class="line">    Outer::Inner inner;</span><br><span class="line">    inner.<span class="built_in">accessOuter</span>(outer);  <span class="comment">// 非静态内部类访问外部类成员</span></span><br><span class="line"></span><br><span class="line">    Outer::StaticInner staticInner;</span><br><span class="line">    <span class="comment">// staticInner.accessOuter();  // 编译错误</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="SO"><a href="#SO" class="headerlink" title="SO:"></a>SO:</h3><ul>
<li><strong>内部类</strong> 是定义在另一个类内部的类。它是独立的类，外部类不能直接访问内部类的成员，内部类可以通过外部类的对象访问外部类的所有成员。</li>
<li><strong>友元关系</strong>：从某种角度看，内部类可以访问外部类的私有成员，所以可以视作外部类的友元类。</li>
<li>内部类可以是 <strong>静态的</strong>（<code>static</code>），也可以是 <strong>非静态的</strong>，它们的访问权限和行为有所不同。</li>
</ul>
<p>内部类通常用于处理一些与外部类紧密相关的功能，帮助将代码组织得更好。</p>
<hr>
<h2 id="5-匿名对象（Anonymous-Object）"><a href="#5-匿名对象（Anonymous-Object）" class="headerlink" title="5. 匿名对象（Anonymous Object）"></a>5. 匿名对象（Anonymous Object）</h2><p>在 C++中，匿名对象指的是没有明确名称的对象。它通常用于函数返回、临时数据传递、类型转换等场景，它们的生命周期仅限于它们所在的表达式或者函数调用，执行完毕后即被销毁。通过合理使用匿名对象，可以简化代码、减少不必要的对象创建，提高程序的效率。下面我将详细讲解匿名对象的相关知识点及其使用。</p>
<h3 id="5-1-匿名对象的定义和创建"><a href="#5-1-匿名对象的定义和创建" class="headerlink" title="5.1 匿名对象的定义和创建"></a>5.1 匿名对象的定义和创建</h3><p>匿名对象是没有名字的临时对象。在 C++中，匿名对象通常出现在以下场景：</p>
<ul>
<li><strong>作为函数返回值：</strong> 当函数返回一个对象时，C++会创建一个匿名对象来接收返回值。</li>
<li><strong>临时对象：</strong> 用作表达式的操作数时，编译器会创建一个临时对象。</li>
<li><strong>类型转换：</strong> 在类型转换过程中，C++会临时创建匿名对象。</li>
</ul>
<h3 id="5-2-匿名对象的生命周期"><a href="#5-2-匿名对象的生命周期" class="headerlink" title="5.2 匿名对象的生命周期"></a>5.2 匿名对象的生命周期</h3><p>匿名对象的生命周期非常短，通常只在一个表达式或者函数调用期间有效。它们会在表达式结束后立即销毁。这是因为它们没有名字，无法直接引用它们。</p>
<h3 id="5-3-匿名对象的使用示例"><a href="#5-3-匿名对象的使用示例" class="headerlink" title="5.3 匿名对象的使用示例"></a>5.3 匿名对象的使用示例</h3><h4 id="示例-1：作为函数返回值的匿名对象"><a href="#示例-1：作为函数返回值的匿名对象" class="headerlink" title="示例 1：作为函数返回值的匿名对象"></a>示例 1：作为函数返回值的匿名对象</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;MyClass 构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">MyClass</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;MyClass 析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sayHello</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Hello from MyClass!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数返回匿名对象</span></span><br><span class="line"><span class="function">MyClass <span class="title">createObject</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">MyClass</span>();  <span class="comment">// 返回一个匿名对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">createObject</span>().<span class="built_in">sayHello</span>();  <span class="comment">// 创建一个匿名对象并调用它的方法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li>在 <code>createObject</code> 函数中，<code>return MyClass();</code> 创建了一个匿名对象并返回。</li>
<li>在 <code>main</code> 函数中，调用 <code>createObject().sayHello()</code> 时，匿名对象在 <code>createObject</code> 函数返回时创建，并且调用 <code>sayHello()</code> 方法。</li>
<li>程序运行时，首先会打印构造函数的消息，接着打印 <code>sayHello()</code> 的消息，然后销毁匿名对象，打印析构函数的消息。</li>
</ul>
<h4 id="示例-2：作为临时对象"><a href="#示例-2：作为临时对象" class="headerlink" title="示例 2：作为临时对象"></a>示例 2：作为临时对象</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;MyClass 构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">MyClass</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;MyClass 析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sayHello</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Hello from MyClass!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MyClass obj;</span><br><span class="line">    obj.<span class="built_in">sayHello</span>();</span><br><span class="line">    <span class="built_in">MyClass</span>().<span class="built_in">sayHello</span>();  <span class="comment">// 这里是一个匿名对象调用方法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li>在 <code>main</code> 函数中，<code>MyClass().sayHello();</code> 创建了一个匿名对象并调用了 <code>sayHello</code> 方法。</li>
<li>这个匿名对象仅在该行代码执行时有效，执行完后立即销毁。</li>
</ul>
<h4 id="示例-3：通过类型转换创建匿名对象"><a href="#示例-3：通过类型转换创建匿名对象" class="headerlink" title="示例 3：通过类型转换创建匿名对象"></a>示例 3：通过类型转换创建匿名对象</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> value) : <span class="built_in">m_value</span>(value)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;MyClass 构造函数：&quot;</span> &lt;&lt; m_value &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">MyClass</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;MyClass 析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="number">10</span>);  <span class="comment">// 创建一个匿名对象并传递给构造函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li><code>MyClass(10);</code> 创建了一个匿名对象，并且传递了参数 <code>10</code> 给构造函数。</li>
<li>这个匿名对象在创建后立即销毁，生命周期仅限于该行代码。</li>
</ul>
<h3 id="5-4-匿名对象的应用场景"><a href="#5-4-匿名对象的应用场景" class="headerlink" title="5.4 匿名对象的应用场景"></a>5.4 匿名对象的应用场景</h3><p>匿名对象有很多实际应用，下面列出一些常见的场景：</p>
<ol>
<li><p><strong>临时数据传递：</strong> 在函数调用时传递临时对象，避免了不必要的对象复制。</p>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">processObject</span><span class="params">(<span class="type">const</span> MyClass&amp; obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 处理传入的对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">processObject</span>(<span class="built_in">MyClass</span>(<span class="number">5</span>));  <span class="comment">// 创建一个匿名对象并传递</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>简化代码：</strong> 当不需要重复使用对象时，可以通过匿名对象来简化代码，避免创建多余的变量。</p>
</li>
<li><p><strong>链式调用：</strong> 匿名对象可以用于链式调用多个函数。</p>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">MyClass</span>().<span class="built_in">sayHello</span>().<span class="built_in">anotherFunction</span>();  <span class="comment">// 链式调用匿名对象的方法</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="5-5-注意事项"><a href="#5-5-注意事项" class="headerlink" title="5.5 注意事项"></a>5.5 注意事项</h3><ul>
<li><strong>内存管理：</strong> 匿名对象通常是自动管理的，C++会在它们超出作用域后自动销毁。这意味着开发者不需要手动释放内存，但如果匿名对象涉及到动态内存分配（如 <code>new</code>），则需要特别注意内存管理。</li>
<li><strong>避免悬挂引用：</strong> 由于匿名对象的生命周期很短，必须避免在它销毁后访问它。</li>
</ul>
<blockquote>
<h2 id="传道解惑-1"><a href="#传道解惑-1" class="headerlink" title="传道解惑"></a>传道解惑</h2><h3 id="Q1：为什么匿名对象加-const-可以延长生命周期"><a href="#Q1：为什么匿名对象加-const-可以延长生命周期" class="headerlink" title="Q1：为什么匿名对象加 const 可以延长生命周期?"></a>Q1：为什么匿名对象加 <code>const</code> 可以延长生命周期?</h3><p>将匿名对象加上 <code>const</code> 修饰符，<strong>可以延长其生命周期</strong>。但这种延长的生命周期并不是无条件的，它的背后有一些特定的规则和原理。</p>
<p>在 C++中，匿名对象的生命周期是由它们的 <strong>作用域</strong> 决定的，通常在一个表达式或函数调用结束时，匿名对象会被销毁。但是，如果将匿名对象声明为 <code>const</code> 类型，它将与一个 <strong>引用</strong> 绑定，从而延长其生命周期。这是因为 <code>const</code> 引用允许我们在对象生命周期结束后，依然通过引用来使用它。</p>
<h4 id="具体解释："><a href="#具体解释：" class="headerlink" title="具体解释："></a>具体解释：</h4><ol>
<li><strong>匿名对象与临时对象的生命周期：</strong></li>
</ol>
<ul>
<li><p>默认情况下，匿名对象（临时对象）的生命周期通常非常短，仅限于它的表达式或语句的结束。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">MyClass</span>().<span class="built_in">doSomething</span>();  <span class="comment">// 匿名对象在 doSomething() 执行完后销毁</span></span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="2">
<li><strong>使用 <code>const</code> 引用延长生命周期：</strong></li>
</ol>
<ul>
<li>当匿名对象绑定到一个 <code>const</code> 引用时，C++会保证匿名对象的生命周期至少延长到该引用的生命周期结束。也就是说，这个引用会“延迟”对象销毁的时机，直到引用被销毁。</li>
<li><strong>关键点：</strong> <code>const</code> 引用可以延长临时对象的生命周期，使其存在于引用的作用域中，直到引用超出作用域。</li>
</ul>
<p>  示例：</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">const</span> MyClass&amp; obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    obj.<span class="built_in">doSomething</span>();  <span class="comment">// obj 是对匿名对象的引用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">foo</span>(<span class="built_in">MyClass</span>());  <span class="comment">// 匿名对象绑定到 const 引用 obj</span></span><br><span class="line">    <span class="comment">// 匿名对象在 foo() 返回时才销毁</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  在这个例子中：</p>
<ul>
<li><code>MyClass()</code> 创建了一个匿名对象。</li>
<li>这个匿名对象会被传递给 <code>foo()</code> 函数，并绑定到 <code>const MyClass&amp; obj</code> 上。</li>
<li>匿名对象的生命周期被延长，直到 <code>obj</code> 超出作用域，也就是 <code>foo()</code> 函数结束。</li>
</ul>
<p><strong>临时对象的绑定规则：</strong></p>
<ul>
<li>当临时对象（匿名对象）被绑定到一个 <code>const</code> 引用时，C++会延长临时对象的生命周期，直到引用超出作用域。</li>
<li>这样做的目的是为了避免因临时对象提前销毁而导致引用悬挂问题（即引用一个已销毁的临时对象）。</li>
</ul>
<h3 id="例子：匿名对象与-const-引用"><a href="#例子：匿名对象与-const-引用" class="headerlink" title="例子：匿名对象与 const 引用"></a>例子：匿名对象与 <code>const</code> 引用</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">&gt;<span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&gt;&#123;</span><br><span class="line">&gt;<span class="keyword">public</span>:</span><br><span class="line">   <span class="built_in">MyClass</span>()</span><br><span class="line">   &#123;</span><br><span class="line">       cout &lt;&lt; <span class="string">&quot;MyClass 构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   ~<span class="built_in">MyClass</span>()</span><br><span class="line">   &#123;</span><br><span class="line">       cout &lt;&lt; <span class="string">&quot;MyClass 析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">doSomething</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       cout &lt;&lt; <span class="string">&quot;做点什么！&quot;</span> &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="function"><span class="type">void</span> <span class="title">processObject</span><span class="params">(<span class="type">const</span> MyClass&amp; obj)</span></span></span><br><span class="line"><span class="function">&gt;</span>&#123;</span><br><span class="line">   obj.<span class="built_in">doSomething</span>();  <span class="comment">// 这里 obj 是对匿名对象的引用</span></span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">&gt;</span>&#123;</span><br><span class="line">   <span class="built_in">processObject</span>(<span class="built_in">MyClass</span>());  <span class="comment">// 匿名对象绑定到 const 引用 obj</span></span><br><span class="line">   <span class="comment">// 匿名对象的生命周期会被延长，直到 processObject 返回</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;MyClass 构造函数</span><br><span class="line">&gt;做点什么！</span><br><span class="line">&gt;MyClass 析构函数</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li>在 <code>processObject</code> 函数中，<code>MyClass()</code> 创建了一个匿名对象，它被传递并绑定到 <code>const MyClass&amp; obj</code>。</li>
<li>由于 <code>obj</code> 是 <code>const</code> 引用，匿名对象的生命周期被延长，直到 <code>processObject</code> 函数返回。</li>
<li>匿名对象的析构函数只会在 <code>processObject</code> 函数结束后调用。</li>
</ul>
<h3 id="重要说明："><a href="#重要说明：" class="headerlink" title="重要说明："></a>重要说明：</h3><ul>
<li><strong><code>const</code> 引用延长生命周期的作用范围：</strong> <code>const</code> 引用的作用是延长临时对象的生命周期，<strong>直到引用超出作用域</strong>。这意味着匿名对象在引用的作用域内存在，引用超出作用域后，匿名对象才会销毁。而这样做是为了避免临时对象在使用时被提前销毁，确保引用对象的有效性。这种机制是 C++中的一种特性，它通过引用的生命周期来保证匿名对象在函数作用域内的安全访问。</li>
<li><strong>非 <code>const</code> 引用不允许绑定临时对象：</strong> 如果你尝试用一个非 <code>const</code> 引用绑定临时对象，C++ 编译器会报错，因为非 <code>const</code> 引用无法延长临时对象的生命周期。</li>
</ul>
<hr>
<h3 id="Q2：匿名对象-VS-有名对象"><a href="#Q2：匿名对象-VS-有名对象" class="headerlink" title="Q2：匿名对象 VS 有名对象"></a>Q2：匿名对象 VS 有名对象</h3><p><strong>匿名对象</strong> 和 <strong>有名对象</strong> 在 C++中的最大区别在于命名、生命周期以及访问方式。匿名对象通常用于临时需要的场合，生命周期短，而有名对象则用于需要在多个地方访问和操作的情形，生命周期较长。下面我将详细解释：</p>
<p><strong>命名</strong></p>
<ul>
<li><p>匿名对象（Anonymous Object）：顾名思义，它没有明确的名称，通常是临时创建的对象，不会绑定到变量上。</p>
</li>
<li><p>例如：<code>MyClass().doSomething();</code>，在这里 <code>MyClass()</code> 创建了一个匿名对象，它没有名称，仅用于调用 <code>doSomething()</code> 方法。</p>
</li>
<li><p>有名对象（Named Object）：有明确的名称，可以通过变量名访问。</p>
</li>
<li><p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyClass obj;  <span class="comment">// obj 是有名对象</span></span><br><span class="line">obj.<span class="built_in">doSomething</span>();</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>生命周期</strong></p>
<ul>
<li>匿名对象：生命周期非常短暂，仅存在于当前表达式或者语句中，一旦使用完毕，匿名对象会被销毁。</li>
<li>例如：<code>MyClass().doSomething();</code> 中，匿名对象会在调用 <code>doSomething()</code> 后立刻销毁。</li>
<li>有名对象：生命周期通常由它的作用域决定。对象在创建时分配内存，并在其作用域结束时被销毁。如果对象在栈上创建，它会在离开作用域时销毁；如果在堆上创建，则需要手动释放内存。</li>
<li>例如：<code>MyClass obj;</code> 在 <code>obj</code> 离开作用域时销毁。</li>
</ul>
<p><strong>访问方式</strong></p>
<ul>
<li><strong>匿名对象</strong>：不能通过变量名访问，因为它没有名称。只能在它创建的上下文中直接使用它。</li>
<li>例如：<code>MyClass().doSomething();</code> 中没有 <code>MyClass</code> 对象的名称，无法在之后访问它。</li>
<li><strong>有名对象</strong>：可以通过对象的名称来引用和访问对象的成员。</li>
<li>例如：<code>obj.doSomething();</code> 中，<code>obj</code> 是有名对象，可以在之后的代码中多次使用。</li>
</ul>
<p><strong>内存管理</strong></p>
<ul>
<li><strong>匿名对象</strong>：由于没有名称，它通常是栈上分配的，编译器在合适的时候自动管理内存。对于返回值优化（RVO&#x2F;NRVO）等，编译器会优化创建匿名对象的内存管理，避免不必要的拷贝。</li>
<li><strong>有名对象</strong>：有名称，可以显式创建在栈上或堆上。栈上的对象在作用域结束时自动销毁，而堆上的对象则需要手动 <code>delete</code>。</li>
</ul>
<p><strong>应用场景</strong></p>
<p><strong>匿名对象</strong>：</p>
<ul>
<li><p>适用于 <strong>临时使用</strong>，例如一次性计算或者在函数调用中使用临时对象。</p>
</li>
<li><p>常见于函数返回值、类型转换、临时数据传递等场景。</p>
</li>
<li><p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">processObject</span><span class="params">(MyClass obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    obj.<span class="built_in">doSomething</span>();</span><br><span class="line">&#125;</span><br><span class="line">                     </span><br><span class="line"><span class="built_in">processObject</span>(<span class="built_in">MyClass</span>());  <span class="comment">// 匿名对象作为参数传递</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>有名对象</strong>：</p>
<ul>
<li><p>适用于 <strong>需要多次访问</strong> 的场景，或者需要在多个地方使用该对象。</p>
</li>
<li><p>典型用法是作为类的实例，创建时需要明确的对象名来进行后续操作。</p>
</li>
<li><p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyClass obj;  <span class="comment">// 有名对象</span></span><br><span class="line">obj.<span class="built_in">doSomething</span>();  <span class="comment">// 可以在后续访问该对象</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>返回值优化（RVO&#x2F;NRVO）</strong></p>
<ul>
<li><p><strong>匿名对象</strong> 在函数返回值时，编译器会尽可能优化，避免多余的拷贝操作，这被称为 <strong>返回值优化</strong>（RVO）或者 <strong>命名返回值优化</strong>（NRVO）。这意味着，返回匿名对象时，编译器会直接在调用位置构造返回对象，而不会创建临时对象。</p>
</li>
<li><p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MyClass <span class="title">createObject</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">MyClass</span>();  <span class="comment">// 匿名对象直接返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>有名对象</strong> 没有这样的优化问题，通常会被拷贝或者移动到调用处，特别是在涉及对象返回时。</p>
</li>
</ul>
<p><strong>性能差异</strong></p>
<ul>
<li>匿名对象：由于其生命周期非常短，编译器有时能够优化它们的创建和销毁过程，避免不必要的复制。</li>
<li>在某些场景中，匿名对象能避免额外的内存分配和释放开销，提升性能。</li>
<li><strong>有名对象</strong>：虽然生命周期较长，但如果不合理使用，有时会增加额外的开销，尤其是在传递大对象时，可能会发生不必要的拷贝操作。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><table>
<thead>
<tr>
<th>特性</th>
<th>匿名对象</th>
<th>有名对象</th>
</tr>
</thead>
<tbody><tr>
<td><strong>命名</strong></td>
<td>没有名称，仅为临时对象</td>
<td>有名称，可以通过变量名访问</td>
</tr>
<tr>
<td><strong>生命周期</strong></td>
<td>短暂，仅在表达式或函数调用期间存在</td>
<td>生命周期由作用域决定，作用域结束时销毁</td>
</tr>
<tr>
<td><strong>访问方式</strong></td>
<td>不能直接访问，通常仅在当前表达式中使用</td>
<td>可以通过名称多次访问</td>
</tr>
<tr>
<td><strong>内存管理</strong></td>
<td>编译器自动管理内存，通常是栈上分配</td>
<td>可以是栈上或堆上，需要显式管理堆对象的内存</td>
</tr>
<tr>
<td><strong>应用场景</strong></td>
<td>临时数据传递、返回值、一次性计算等</td>
<td>需要多次使用、存储数据或状态等</td>
</tr>
<tr>
<td><strong>性能差异</strong></td>
<td>编译器优化可能避免不必要的复制</td>
<td>如果不小心使用，可能有不必要的拷贝操作### 总结</td>
</tr>
</tbody></table>
</blockquote>
<hr>
<h2 id="6-再次理解类和对象"><a href="#6-再次理解类和对象" class="headerlink" title="6. 再次理解类和对象"></a>6. 再次理解类和对象</h2><p>理解 <strong>类</strong> 和 <strong>对象</strong> 的概念，能帮助我们更好地理解面向对象编程（OOP）的核心思想。为了更通俗地讲解这个内容，我们可以通过一个现实中的例子来帮助理解。</p>
<h3 id="1-类是对事物的抽象"><a href="#1-类是对事物的抽象" class="headerlink" title="1. 类是对事物的抽象"></a>1. 类是对事物的抽象</h3><p>类就像是对某种 <strong>事物</strong>（例如洗衣机）的 <strong>抽象描述</strong>。它是 <strong>对现实中事物的建模</strong>，在程序中描述这个事物的 <strong>属性</strong> 和 <strong>行为</strong>。</p>
<ul>
<li><strong>属性</strong>：就是这个事物的特征，比如洗衣机的品牌、颜色、容量等。</li>
<li><strong>行为</strong>：就是这个事物可以做的事情，比如洗衣机可以“启动”、“停止”、“洗衣服”等。</li>
</ul>
<p>举个例子，洗衣机这个事物可以用类来描述：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WashingMachine</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string brand;      <span class="comment">// 洗衣机的品牌</span></span><br><span class="line">    string color;      <span class="comment">// 洗衣机的颜色</span></span><br><span class="line">    <span class="type">int</span> capacity;      <span class="comment">// 洗衣机的容量（比如5kg、10kg）</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Washing machine started.&quot;</span> &lt;&lt; endl;   	 <span class="comment">// 启动洗衣机</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">stop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Washing machine stopped.&quot;</span> &lt;&lt; endl;      <span class="comment">// 停止洗衣机</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>WashingMachine</code> 类描述了一个洗衣机的 <strong>属性</strong>（<code>brand</code>, <code>color</code>, <code>capacity</code>）和 <strong>行为</strong>（<code>start()</code>，<code>stop()</code>）。这个类的作用就是 <strong>抽象化</strong> 洗衣机，将它的特征和行为描述给计算机。</p>
<h3 id="2-对象是类的实例化"><a href="#2-对象是类的实例化" class="headerlink" title="2. 对象是类的实例化"></a>2. 对象是类的实例化</h3><p>类是对现实事物的抽象描述，但计算机无法直接“认识”类，必须通过 <strong>实例化</strong> 类来创建 <strong>对象</strong>，而对象才是计算机可以操作的具体实体。</p>
<ul>
<li><strong>实例化</strong>：就是通过类创建具体的对象的过程。</li>
<li><strong>对象</strong>：是类的具体实例，表示现实世界中的某个具体的事物。比如，你可以通过 <code>WashingMachine</code> 类创建多个洗衣机对象，每个对象代表一个具体的洗衣机。</li>
</ul>
<p>例子继续，假设我们现在创建了一个洗衣机对象：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WashingMachine</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string brand;      <span class="comment">// 洗衣机的品牌</span></span><br><span class="line">    string color;      <span class="comment">// 洗衣机的颜色</span></span><br><span class="line">    <span class="type">int</span> capacity;      <span class="comment">// 洗衣机的容量（单位：kg）</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Washing machine started.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">stop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Washing machine stopped.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">wash</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Washing clothes...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    WashingMachine wm1;</span><br><span class="line">    wm<span class="number">1.</span>brand = <span class="string">&quot;小米&quot;</span>;</span><br><span class="line">    wm<span class="number">1.</span>color = <span class="string">&quot;白色&quot;</span>;</span><br><span class="line">    wm<span class="number">1.</span>capacity = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    wm<span class="number">1.</span><span class="built_in">start</span>();  <span class="comment">// 启动洗衣机</span></span><br><span class="line">    wm<span class="number">1.</span><span class="built_in">wash</span>();   <span class="comment">// 洗衣服</span></span><br><span class="line">    wm<span class="number">1.</span><span class="built_in">stop</span>();   <span class="comment">// 停止洗衣机</span></span><br><span class="line"></span><br><span class="line">    WashingMachine wm2;</span><br><span class="line">    wm<span class="number">2.</span>brand = <span class="string">&quot;格力&quot;</span>;</span><br><span class="line">    wm<span class="number">2.</span>color = <span class="string">&quot;黑色&quot;</span>;</span><br><span class="line">    wm<span class="number">2.</span>capacity = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    wm<span class="number">2.</span><span class="built_in">start</span>();</span><br><span class="line">    wm<span class="number">2.</span><span class="built_in">wash</span>();</span><br><span class="line">    wm<span class="number">2.</span><span class="built_in">stop</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>wm1</code> 和 <code>wm2</code> 是 <code>WashingMachine</code> 类的两个 <strong>对象</strong>。它们分别代表两个不同的洗衣机，每个对象的属性（<code>brand</code>, <code>color</code>, <code>capacity</code>）可以有不同的值。通过这些对象，我们可以模拟现实中的多个洗衣机。</p>
<h3 id="3-通过类创建对象"><a href="#3-通过类创建对象" class="headerlink" title="3. 通过类创建对象"></a>3. 通过类创建对象</h3><p>从以上的例子可以看出，类只是描述了洗衣机的属性和行为，而对象才是 <strong>具体的实例</strong>。你可以通过类创建出多个对象，每个对象都代表一个具体的事物。类就像是一个模板或蓝图，具体的对象是根据这个模板生成的。</p>
<h3 id="4-类和对象的关系"><a href="#4-类和对象的关系" class="headerlink" title="4. 类和对象的关系"></a>4. 类和对象的关系</h3><ul>
<li><strong>类</strong> 是对 <strong>事物</strong> 的一种描述，它定义了这个事物的 <strong>属性</strong> 和 <strong>行为</strong>。</li>
<li><strong>对象</strong> 是类的 <strong>实例</strong>，是计算机可以直接操作的具体实体。通过类可以创建多个对象，每个对象都有不同的属性值和方法。</li>
</ul>
<p>总结一下，类和对象的关系可以类比为：</p>
<ul>
<li><strong>类</strong>：就像是一本 <strong>描述洗衣机的说明书</strong>，它告诉我们洗衣机有哪些属性（品牌、颜色、容量）和行为（启动、停止）。</li>
<li><strong>对象</strong>：就像是根据这本说明书实际生产出来的 <strong>具体洗衣机</strong>。每一台洗衣机都有自己的品牌、颜色、容量等信息，并可以执行启动、停止等操作。</li>
</ul>
<h3 id="5-现实中的例子：洗衣机类"><a href="#5-现实中的例子：洗衣机类" class="headerlink" title="5. 现实中的例子：洗衣机类"></a>5. 现实中的例子：洗衣机类</h3><p>让我们通过现实中的洗衣机来进一步理解。</p>
<ol>
<li><strong>抽象洗衣机</strong>：当我们想到洗衣机时，我们并不会想到具体某一台洗衣机，而是先想到了“洗衣机”这个概念。它有品牌、颜色、容量这些特征，并且有启动、停止这些操作。这就是 <strong>类</strong> 的作用：把这些共性的特征和行为总结出来。</li>
<li><strong>创建洗衣机对象</strong>：当你去买洗衣机时，你选择了一个品牌、颜色、容量等具体参数的洗衣机。每一台洗衣机就是一个 <strong>对象</strong>，它是类的实例化。</li>
<li><strong>操作洗衣机</strong>：当你开始使用这台洗衣机时，你可以通过按按钮来“启动”和“停止”，这就是对象通过类提供的操作（方法）来实现的行为。</li>
</ol>
<hr>
<h3 id="SO-1"><a href="#SO-1" class="headerlink" title="SO:"></a>SO:</h3><ul>
<li><strong>类</strong> 是对现实世界中事物的抽象描述，它总结了事物的 <strong>属性</strong> 和 <strong>行为</strong>。</li>
<li><strong>对象</strong> 是类的具体实例，是计算机能够识别和操作的实体。</li>
<li><strong>类</strong> 是对事物的抽象描述，而 <strong>对象</strong> 是根据类创建的具体实例。</li>
<li>通过 <strong>类</strong>，我们可以创建多个不同的 <strong>对象</strong>，每个对象具有类中定义的属性和行为。</li>
</ul>
<p>通过理解类和对象的关系，你将能够更好地理解面向对象编程（OOP）的核心思想，这对于学习和使用 C++、Java 等面向对象语言非常重要。</p>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://github.com/huangcancan-xbc/Drawing-bed/blob/master/Blog/20250307201719879.png?raw=true" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://github.com/huangcancan-xbc/Drawing-bed/blob/master/Blog/20250307201719879.png?raw=true" title="头像" alt="头像"></a><div class="post-copyright__author_name">小米里的大麦</div><div class="post-copyright__author_desc"></div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="https://www.minbit.top/posts/10381.html">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('https://www.minbit.top/posts/10381.html')">04 类与对象（下）</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="赞赏作者"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><div class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Blog/20250403212543768.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Blog/20250403212543768.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Blog/20250403212622868.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Blog/20250403212622868.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul><a class="reward-main-btn" href="/about/#about-reward" target="_blank"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display: none"></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="https://www.minbit.top/posts/10381.html"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=04 类与对象（下）&amp;url=https://www.minbit.top/posts/10381.html&amp;pic=https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Blog/20250314141714221.png?_r_=14a60b29-df3d-47d7-98e4-22c40b7edea8" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">MIT</a> 许可协议。转载请注明来自 <a href="https://www.minbit.top" target="_blank">小米里的大麦</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/C/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>C++<span class="tagsPageCount">4</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Blog/20250314131841400.png?_r_=a8024908-eada-40a5-0198-4cfc0af93261" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/30432.html"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Blog/20250314140243649.png?_r_=751f1c3c-4ab3-37cf-3a3b-ed11c33fb49a" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">03 类与对象（中）</div></div></a></div><div class="next-post pull-right"><a href="/posts/62462.html"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Blog/20250314125923408.png?_r_=f679b352-3683-790a-8a32-e0caffcfc601" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">007 Linux 开发工具（上）—— vim、解放sudo、gc+</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size: 1.5rem; margin-right: 4px"></i><span>喜欢这篇文章的人也看了</span></div><div class="relatedPosts-list"><div><a href="/posts/24103.html" title="02 类与对象（上）"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Blog/20250314140243649.png?_r_=acac619a-6a2b-e238-b152-f98637125ed2" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-02-01</div><div class="title">02 类与对象（上）</div></div></a></div><div><a href="/posts/30432.html" title="03 类与对象（中）"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Blog/20250314140243649.png?_r_=751f1c3c-4ab3-37cf-3a3b-ed11c33fb49a" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-02-02</div><div class="title">03 类与对象（中）</div></div></a></div><div><a href="/posts/47059.html" title="C++ STL —— 基于算法竞赛"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Blog/20250314140243649.png?_r_=e231be7a-879d-447e-ecd5-4fa5947f342a" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-05-22</div><div class="title">C++ STL —— 基于算法竞赛</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="anzhiyufont anzhiyu-icon-comments"></i><span> 评论</span></div><div class="comment-randomInfo"><a onclick="anzhiyu.addRandomCommentInfo()" href="javascript:void(0)" style="display: none">匿名评论</a><a href="/privacy" style="margin-left: 4px">隐私政策</a></div><div class="comment-tips" id="comment-tips"><span>✅ 你无需删除空行，直接评论以获取最佳展示效果</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div><div class="comment-barrage"></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info__sayhi" id="author-info__sayhi" onclick="anzhiyu.changeSayHelloText()"></div><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://github.com/huangcancan-xbc/Drawing-bed/blob/master/Blog/20250307201719879.png?raw=true" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-status"><img class="g-status" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/08/24/64e6ce9c507bb.png" alt="status"/></div></div><div class="author-info__description">时间好像总会留下点什么,或许是一个人,或许是一个梦,或许……是一段有意义的经历~</div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/"><h1 class="author-info__name">小米里的大麦</h1><div class="author-info__desc"></div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/huangcancan-xbc" target="_blank" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a></div></div></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bullhorn anzhiyu-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来看我的博客鸭~<br>如果存在显示问题，那么你可能需要一点特殊的网络环境哦~<br><br>你现在可以通过 minbit.top 或者<br>huangcancan-xbc.github.io<br>访问到我的博客。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%86%8D%E8%B0%88%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">1.</span> <span class="toc-text">1. 再谈构造函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%BD%93%E8%B5%8B%E5%80%BC"><span class="toc-number">1.1.</span> <span class="toc-text">1.1 构造函数体赋值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8"><span class="toc-number">1.2.</span> <span class="toc-text">1.2 初始化列表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-explicit-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.3.</span> <span class="toc-text">1.3 explicit 关键字</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-static-%E6%88%90%E5%91%98"><span class="toc-number">2.</span> <span class="toc-text">2. static 成员</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E6%A6%82%E5%BF%B5"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E7%89%B9%E6%80%A7"><span class="toc-number">2.1.1.</span> <span class="toc-text">2.2 特性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90%EF%BC%9A"><span class="toc-number">2.2.</span> <span class="toc-text">例子：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E9%81%93%E8%A7%A3%E6%83%91%EF%BC%9A"><span class="toc-number">2.3.</span> <span class="toc-text">传道解惑：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Q1%EF%BC%9A%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%8F%AF%E4%BB%A5%E8%B0%83%E7%94%A8%E9%9D%9E%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%90%97%EF%BC%9F"><span class="toc-number">2.3.1.</span> <span class="toc-text">Q1：静态成员函数可以调用非静态成员函数吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q2-%E9%9D%9E%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%8F%AF%E4%BB%A5%E8%B0%83%E7%94%A8%E7%B1%BB%E7%9A%84%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%90%97%EF%BC%9F"><span class="toc-number">2.3.2.</span> <span class="toc-text">Q2: 非静态成员函数可以调用类的静态成员函数吗？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%8F%8B%E5%85%83%EF%BC%88Friend%EF%BC%89"><span class="toc-number">3.</span> <span class="toc-text">3. 友元（Friend）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0"><span class="toc-number">3.1.</span> <span class="toc-text">3.1 友元函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E9%81%93%E8%A7%A3%E6%83%91"><span class="toc-number">3.2.</span> <span class="toc-text">传道解惑</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Q1%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="toc-number">3.2.1.</span> <span class="toc-text">Q1：为什么使用友元函数？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E9%87%8D%E8%BD%BD-operator"><span class="toc-number">3.2.1.1.</span> <span class="toc-text">示例：重载 operator&lt;&lt;（输出流）为友元函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E5%8F%8B%E5%85%83%E7%B1%BB"><span class="toc-number">3.3.</span> <span class="toc-text">3.2 友元类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8B%E5%85%83%E7%B1%BB%E7%9A%84%E7%89%B9%E6%80%A7%EF%BC%9A"><span class="toc-number">3.3.1.</span> <span class="toc-text">友元类的特性：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E5%8F%8B%E5%85%83%E7%B1%BB"><span class="toc-number">3.3.2.</span> <span class="toc-text">示例：友元类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SO%EF%BC%9A"><span class="toc-number">3.4.</span> <span class="toc-text">SO：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%88Nested-Class%EF%BC%89"><span class="toc-number">4.</span> <span class="toc-text">4. 内部类（Nested Class）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E6%A6%82%E5%BF%B5%EF%BC%9A"><span class="toc-number">4.1.</span> <span class="toc-text">4.1 概念：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E7%82%B9%EF%BC%9A"><span class="toc-number">4.1.1.</span> <span class="toc-text">关键点：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E7%89%B9%E6%80%A7"><span class="toc-number">4.2.</span> <span class="toc-text">4.2 内部类的特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">4.3.</span> <span class="toc-text">4.3 内部类的分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">4.4.</span> <span class="toc-text">示例：内部类的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%99%AE%E9%80%9A%E7%9A%84%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">4.4.1.</span> <span class="toc-text">1. 普通的内部类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">4.4.2.</span> <span class="toc-text">2. 静态内部类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%99%AE%E9%80%9A%E5%86%85%E9%83%A8%E7%B1%BB%E5%92%8C%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="toc-number">4.4.3.</span> <span class="toc-text">3. 普通内部类和静态内部类的区别：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SO"><span class="toc-number">4.5.</span> <span class="toc-text">SO:</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1%EF%BC%88Anonymous-Object%EF%BC%89"><span class="toc-number">5.</span> <span class="toc-text">5. 匿名对象（Anonymous Object）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E5%88%9B%E5%BB%BA"><span class="toc-number">5.1.</span> <span class="toc-text">5.1 匿名对象的定义和创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">5.2.</span> <span class="toc-text">5.2 匿名对象的生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="toc-number">5.3.</span> <span class="toc-text">5.3 匿名对象的使用示例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-1%EF%BC%9A%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1"><span class="toc-number">5.3.1.</span> <span class="toc-text">示例 1：作为函数返回值的匿名对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-2%EF%BC%9A%E4%BD%9C%E4%B8%BA%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1"><span class="toc-number">5.3.2.</span> <span class="toc-text">示例 2：作为临时对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-3%EF%BC%9A%E9%80%9A%E8%BF%87%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%88%9B%E5%BB%BA%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1"><span class="toc-number">5.3.3.</span> <span class="toc-text">示例 3：通过类型转换创建匿名对象</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">5.4.</span> <span class="toc-text">5.4 匿名对象的应用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">5.5.</span> <span class="toc-text">5.5 注意事项</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%A0%E9%81%93%E8%A7%A3%E6%83%91-1"><span class="toc-number">6.</span> <span class="toc-text">传道解惑</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Q1%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1%E5%8A%A0-const-%E5%8F%AF%E4%BB%A5%E5%BB%B6%E9%95%BF%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">6.1.</span> <span class="toc-text">Q1：为什么匿名对象加 const 可以延长生命周期?</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E8%A7%A3%E9%87%8A%EF%BC%9A"><span class="toc-number">6.1.1.</span> <span class="toc-text">具体解释：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90%EF%BC%9A%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1%E4%B8%8E-const-%E5%BC%95%E7%94%A8"><span class="toc-number">6.2.</span> <span class="toc-text">例子：匿名对象与 const 引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E8%A6%81%E8%AF%B4%E6%98%8E%EF%BC%9A"><span class="toc-number">6.3.</span> <span class="toc-text">重要说明：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q2%EF%BC%9A%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1-VS-%E6%9C%89%E5%90%8D%E5%AF%B9%E8%B1%A1"><span class="toc-number">6.4.</span> <span class="toc-text">Q2：匿名对象 VS 有名对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">6.5.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E5%86%8D%E6%AC%A1%E7%90%86%E8%A7%A3%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1"><span class="toc-number">7.</span> <span class="toc-text">6. 再次理解类和对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%B1%BB%E6%98%AF%E5%AF%B9%E4%BA%8B%E7%89%A9%E7%9A%84%E6%8A%BD%E8%B1%A1"><span class="toc-number">7.1.</span> <span class="toc-text">1. 类是对事物的抽象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%AF%B9%E8%B1%A1%E6%98%AF%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="toc-number">7.2.</span> <span class="toc-text">2. 对象是类的实例化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E9%80%9A%E8%BF%87%E7%B1%BB%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1"><span class="toc-number">7.3.</span> <span class="toc-text">3. 通过类创建对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">7.4.</span> <span class="toc-text">4. 类和对象的关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E7%8E%B0%E5%AE%9E%E4%B8%AD%E7%9A%84%E4%BE%8B%E5%AD%90%EF%BC%9A%E6%B4%97%E8%A1%A3%E6%9C%BA%E7%B1%BB"><span class="toc-number">7.5.</span> <span class="toc-text">5. 现实中的例子：洗衣机类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SO-1"><span class="toc-number">7.6.</span> <span class="toc-text">SO:</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/57061.html" title="“一周年”，我的成长蜕变与收获"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Blog/20250314131841400.png?_r_=a8024908-eada-40a5-0198-4cfc0af93261" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="“一周年”，我的成长蜕变与收获"/></a><div class="content"><a class="title" href="/posts/57061.html" title="“一周年”，我的成长蜕变与收获">“一周年”，我的成长蜕变与收获</a><time datetime="2025-05-21T16:00:00.000Z" title="发表于 2025-05-22 00:00:00">2025-05-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/47059.html" title="C++ STL —— 基于算法竞赛"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Blog/20250314140243649.png?_r_=e231be7a-879d-447e-ecd5-4fa5947f342a" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C++ STL —— 基于算法竞赛"/></a><div class="content"><a class="title" href="/posts/47059.html" title="C++ STL —— 基于算法竞赛">C++ STL —— 基于算法竞赛</a><time datetime="2025-05-21T16:00:00.000Z" title="发表于 2025-05-22 00:00:00">2025-05-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/49772.html" title="001 环境搭建"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Blog/20250314125828384.png?_r_=23523d16-fba0-b2e7-d1e3-a8c113f332ab" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="001 环境搭建"/></a><div class="content"><a class="title" href="/posts/49772.html" title="001 环境搭建">001 环境搭建</a><time datetime="2025-03-16T16:00:00.000Z" title="发表于 2025-03-17 00:00:00">2025-03-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/42463.html" title="003 系统和入门指令"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Blog/20250314141714221.png?_r_=2c63be5f-7f52-9907-b2e0-67724791758e" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="003 系统和入门指令"/></a><div class="content"><a class="title" href="/posts/42463.html" title="003 系统和入门指令">003 系统和入门指令</a><time datetime="2025-03-16T16:00:00.000Z" title="发表于 2025-03-17 00:00:00">2025-03-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/55415.html" title="002 创建普通账户（为朋友创建、删除账户）"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Blog/20250314125828384.png?_r_=b262c24f-4d19-050a-a0be-28f9f8fd8ef9" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="002 创建普通账户（为朋友创建、删除账户）"/></a><div class="content"><a class="title" href="/posts/55415.html" title="002 创建普通账户（为朋友创建、删除账户）">002 创建普通账户（为朋友创建、删除账户）</a><time datetime="2025-03-16T16:00:00.000Z" title="发表于 2025-03-17 00:00:00">2025-03-17</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2025 By <a class="footer-bar-link" href="/" title="小米里的大麦" target="_blank">小米里的大麦</a></div></div><div id="footer-type-tips"></div><div class="js-pjax"><script>function subtitleType () {
  fetch('https://v1.hitokoto.cn')
    .then(response => response.json())
    .then(data => {
      if (true) {
        const from = '出自 ' + data.from
        const sub = ["《左传》载曰：“太上有立德，其次有立功，其次有立言，虽久不废，此之谓不朽。”","纸上得来终觉浅，绝知此事要躬行！"]
        sub.unshift(data.hitokoto, from)
        window.typed = new Typed('#footer-type-tips', {
          strings: sub,
          startDelay: 300,
          typeSpeed: 150,
          loop: true,
          backSpeed: 50,
        })
      } else {
        document.getElementById('footer-type-tips').innerHTML = data.hitokoto
      }
    })
}

if (true) {
  if (typeof Typed === 'function') {
    subtitleType()
  } else {
    getScript('https://cdn.cbd.int/typed.js@2.1.0/dist/typed.umd.js').then(subtitleType)
  }
} else {
  subtitleType()
}
</script></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/huangcancan-xbc" title="GitHub主页">GitHub主页</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">13</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">4</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">4</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">社交</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://github.com/huangcancan-xbc" title="GitHub"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="GitHub"/><span class="back-menu-item-text">GitHub</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://gitee.com/huang-cancan-xbc" title="gitee"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="gitee"/><span class="back-menu-item-text">gitee</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">博客</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://blog.csdn.net/Huangcancan666?type=blog" title="CSDN"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="CSDN"/><span class="back-menu-item-text">CSDN</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/C/" style="font-size: 0.88rem;">C++<sup>4</sup></a><a href="/tags/Linux/" style="font-size: 0.88rem;">Linux<sup>7</sup></a><a href="/tags/Obsidian/" style="font-size: 0.88rem;">Obsidian<sup>1</sup></a><a href="/tags/%E5%AD%A6%E4%B9%A0%E5%8E%86%E7%A8%8B/" style="font-size: 0.88rem;">学习历程<sup>1</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="anzhiyufont anzhiyu-icon-comments"></i></a><a id="switch-commentBarrage" href="javascript:anzhiyu.switchCommentBarrage();" title="开关弹幕"><i class="anzhiyufont anzhiyu-icon-danmu"></i></a><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="anzhiyufont anzhiyu-icon-xmark"></i></button></nav><div class="is-center" id="loading-database"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-pulse-icon"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("01/01/2025 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2025 By 安知鱼 V1.6.14",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 小米里的大麦 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>(() => {
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://twikoo-olive-one.vercel.app/',
      region: 'ap-shanghai',
      onCommentLoaded: () => {
        anzhiyu.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') setTimeout(runFn,0)
    else getScript('https://cdn.cbd.int/twikoo@1.6.39/dist/twikoo.all.min.js').then(runFn)
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://twikoo-olive-one.vercel.app/',
      region: 'ap-shanghai',
      urls: [window.location.pathname],
      includeReply: false
    }).then(res => {
      countELement.textContent = res[0].count
    }).catch(err => {
      console.error(err)
    })
  }

  const runFn = () => {
    init();
    
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) anzhiyu.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else {
      loadTwikoo()
    }
  } else {
    window.loadOtherComment = loadTwikoo
  }
})()</script><input type="hidden" name="page-type" id="page-type" value="post"><script async src="/js/anzhiyu/comment_barrage.js"></script></div><script>window.addEventListener('load', () => {
  const changeContent = (content) => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const getComment = () => {
    const runTwikoo = () => {
      twikoo.getRecentComments({
        envId: 'https://twikoo-olive-one.vercel.app/',
        region: 'ap-shanghai',
        pageSize: 6,
        includeReply: true
      }).then(function (res) {
        const twikooArray = res.map(e => {
          return {
            'content': changeContent(e.comment),
            'avatar': e.avatar,
            'nick': e.nick,
            'url': e.url + '#' + e.id,
            'date': new Date(e.created).toISOString()
          }
        })

        saveToLocal.set('twikoo-newest-comments', JSON.stringify(twikooArray), 10/(60*24))
        generateHtml(twikooArray)
      }).catch(function (err) {
        const $dom = document.querySelector('#card-newest-comments .aside-list')
        $dom.textContent= "无法获取评论，请确认相关配置是否正确"
      })
    }

    if (typeof twikoo === 'object') {
      runTwikoo()
    } else {
      getScript('https://cdn.cbd.int/twikoo@1.6.39/dist/twikoo.all.min.js').then(runTwikoo)
    }
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'data-lazy-src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'><div class='name'><span>${array[i].nick} </span></div></a>`
        }
        
        result += `<div class='content'>
        <a class='comment' href='${array[i].url}' title='${array[i].content}'>${array[i].content}</a>
        <time datetime="${array[i].date}">${anzhiyu.diffDate(array[i].date, true)}</time></div>
        </div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom && ($dom.innerHTML= result)
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('twikoo-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><script async data-pjax src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.1/bubble/bubble.js"></script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><script src="/js/anzhiyu/right_click_menu.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><script id="click-show-text" src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/dist/click-show-text.min.js" data-mobile="false" data-text="offer,get rich quick,offer,healthy,offer,happy,successes,liberty" data-fontsize="18px" data-random="true" async="async"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["meta[property=\"og:image\"]","meta[property=\"og:title\"]","meta[property=\"og:url\"]","meta[property=\"og:type\"]","meta[property=\"og:site_name\"]","meta[property=\"og:description\"]","head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"]):not([href="/music/"]):not([href="/no-pjax/"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>